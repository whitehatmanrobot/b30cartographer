g );                   // IProperty
    if ( FAILED(sc) )
        LogFail( "SA: can't create ps %#x\n", sc );

    // VT_ARRAY | VT_I4

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_I4, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "SA: can't create sa I4: %#x\n", sc );

        vaI4.vt = VT_I4 | VT_ARRAY;
        vaI4.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    LONG *pl;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pl );
                    *pl = (x-1) * 8 + (y-1) * 2 + (z-1);
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_I4,
                                   &vaI4,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "SA: can't writemultiple VT_I4 %#x\n", sc );
    }

    // VT_ARRAY | VT_BSTR

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = -1;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = 0;
        saBounds[1].cElements = 3;
        saBounds[2].lLbound = 49;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_BSTR, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "SA: can't create sa I4\n" );

        vaBSTR.vt = VT_BSTR | VT_ARRAY;
        vaBSTR.parray = psa;

        int i = 0;

        for ( int x = -1; x <= 0; x++ )
            for ( int y = 0; y <= 2; y++ )
                for ( int z = 49; z <= 50; z++ )
                {
                    void * pv;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, &pv );
                    WCHAR awc[20];
                    swprintf( awc, L"%db", i );
                    BSTR bstr = SysAllocString( awc );
                    * (BSTR *) pv = bstr;
                    i++;
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_BSTR,
                                   &vaBSTR,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "SA: can't writemultiple VT_BSTR %#x\n", sc );
    }

    // VT_ARRAY | VT_VARIANT

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 0;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = -3;
        saBounds[1].cElements = 2;
        saBounds[2].lLbound = 20;
        saBounds[2].cElements = 4;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_VARIANT, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "SA: can't create sa VARIANT\n" );

        vaVARIANT.vt = VT_VARIANT | VT_ARRAY;
        vaVARIANT.parray = psa;

        int i = 0;
        for ( int x = 0; x <= 1; x++ )
            for ( int y = -3; y <= -2; y++ )
                for ( int z = 20; z <= 23; z++ )
                {
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;

                    PROPVARIANT * pVar;
                    HRESULT hr = SafeArrayPtrOfIndex( psa,
                                                      aDim,
                                                      (void **) &pVar );

                    if ( 20 == z )
                    {
                        pVar->lVal = i;
                        pVar->vt = VT_I4;
                    }
                    else if ( 21 == z )
                    {
                        WCHAR awc[20];
                        swprintf( awc, L"%db", i );
                        pVar->bstrVal = SysAllocString( awc );
                        pVar->vt = VT_BSTR;

                    }
#if 0 // in 1829, the OLE group removed support for this!
                    else if ( 22 == z )
                    {
                        *pVar = vaI4;
                    }
                    else if ( 23 == z )
                    {
                        *pVar = vaBSTR;
                    }
#endif
                    else
                    {
                        pVar->fltVal = (float) i;
                        pVar->vt = VT_R4;
                    }

                    i++;
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_VARIANT,
                                   &vaVARIANT,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "SA: can't writemultiple VT_VARIANT %#x\n", sc );
    }

    // VT_ARRAY | VT_R8

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 100;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = -100;
        saBounds[1].cElements = 4;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_R8, 2, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "SA: can't create sa r8\n" );
        vaR8.vt = VT_R8 | VT_ARRAY;
        vaR8.parray = psa;

        double d = 0.0l;

        for ( int x = 100; x <= 102; x++ )
            for ( int y = -100; y <= -97; y++ )
            {
                double * pd;
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pd );
                *pd = d;
                d = d + 2.0l;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_R8,
                                   &vaR8,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "SA: can't writemultiple VT_r8 %#x\n", sc );
    }

    // VT_ARRAY | VT_DATE

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 3;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_DATE, 2, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of VT_DATE\n" );

        vaDATE.vt = VT_DATE | VT_ARRAY;
        vaDATE.parray = psa;

        int i = 0;

        for ( int x = 1; x <= 2; x++ )
            for ( int y = 1; y <= 3; y++ )
            {
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                DATE *pdate;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pdate );

                // round the seconds and milliseconds to 0 since the
                // property set API often is off by as much as 4 seconds
                // when you marshall and unmarshall the value.

                SYSTEMTIME st;
                GetSystemTime( &st );
                st.wSecond = 0;
                st.wMilliseconds = 0;
                st.wYear += (USHORT) i;
                SystemTimeToVariantTime( &st, pdate );
                i++;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_DATE,
                                   &vaDATE,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple date %#x\n", sc );
    }

    // VT_ARRAY | VT_BOOL

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 3;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_BOOL, 2, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of VT_BOOL\n" );

        vaBOOL.vt = VT_BOOL | VT_ARRAY;
        vaBOOL.parray = psa;

        int i = 0;
        GUID guid = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

        for ( int x = 1; x <= 2; x++ )
            for ( int y = 1; y <= 3; y++ )
            {
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                VARIANT_BOOL *pB;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pB );
                *pB = (i & 1) ? VARIANT_TRUE : VARIANT_FALSE;
                i++;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_BOOL,
                                   &vaBOOL,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple bool %#x\n", sc );
    }

    // VT_ARRAY | VT_DECIMAL

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 3;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_DECIMAL, 2, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of VT_DECIMAL\n" );

        vaDECIMAL.vt = VT_DECIMAL | VT_ARRAY;
        vaDECIMAL.parray = psa;

        int i = 0;

        for ( int x = 1; x <= 2; x++ )
            for ( int y = 1; y <= 3; y++ )
            {
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                DECIMAL *pd;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pd );
                if ( FAILED( hr ) )
                    LogFail( "can't get ptr of index for DECIMAL %#x", hr );
                double d = i;
                VarDecFromR8( d, pd );
                i++;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_DECIMAL,
                                   &vaDECIMAL,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple decimal %#x\n", sc );
    }

    // VT_ARRAY | VT_I4

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_I1, 3, saBounds, 0 );
        vaI1.vt = VT_I1 | VT_ARRAY;
        vaI1.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    BYTE *pb;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pb );
                    *pb = (x-1) * 8 + (y-1) * 2 + (z-1);
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_I1,
                                   &vaI1,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple i1 %#x\n", sc );
    }

    // VT_ARRAY | VT_R4

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 100;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = -100;
        saBounds[1].cElements = 4;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_R4, 2, saBounds, 0 );
        vaR4.vt = VT_R4 | VT_ARRAY;
        vaR4.parray = psa;

        float f = 0.0;

        for ( int x = 100; x <= 102; x++ )
            for ( int y = -100; y <= -97; y++ )
            {
                float * pf;
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pf );
                RtlCopyMemory( pf, &f, sizeof f );
                f = (float) ( f + (float) 3.0 );
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_R4,
                                   &vaR4,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple r4 %#x\n", sc );
    }

    // VT_ARRAY | VT_CY

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 100;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = -100;
        saBounds[1].cElements = 4;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_CY, 2, saBounds, 0 );
        vaCY.vt = VT_CY | VT_ARRAY;
        vaCY.parray = psa;

        double d = 0.0l;

        for ( int x = 100; x <= 102; x++ )
            for ( int y = -100; y <= -97; y++ )
            {
                CY *pcy;
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pcy );
                CY cy;
                VarCyFromR8( d, &cy );
                *pcy = cy;
                d = d + 4.0l;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_CY,
                                   &vaCY,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple cy %#x\n", sc );
    }

    // VT_ARRAY | VT_UINT

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_UINT, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of uint\n" );

        vaUINT.vt = VT_UINT | VT_ARRAY;
        vaUINT.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    unsigned *p;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &p );
                    *p = (unsigned) ( (x-1) * 8 + (y-1) * 2 + (z-1) );
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_UINT,
                                   &vaUINT,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple uint %#x\n", sc );
    }

    // VT_ARRAY | VT_INT

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_INT, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of int\n" );

        vaINT.vt = VT_INT | VT_ARRAY;
        vaINT.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    int *p;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &p );
                    *p = (x-1) * 8 + (y-1) * 2 + (z-1);
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_INT,
                                   &vaINT,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple int %#x\n", sc );
    }

    // VT_ARRAY | VT_ERROR

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_ERROR, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of error\n" );

        vaERROR.vt = VT_ERROR | VT_ARRAY;
        vaERROR.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    HRESULT *p;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &p );
                    *p = 0x80070000 + ( (x-1) * 8 + (y-1) * 2 + (z-1) );
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_ERROR,
                                   &vaERROR,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple error %#x\n", sc );
    }

    ppstg->Release();
} //AddSafeArrays

//+-------------------------------------------------------------------------
//
//  Function:   AddPropsToStorage, public
//
//  Synopsis:   Add several props to a file
//
//  Arguments:  [fAlternate]   -- TRUE to open alternate file
//
//--------------------------------------------------------------------------

typedef HRESULT (STDAPICALLTYPE * tdStgCreateStorage)
    ( const OLECHAR FAR* pwcsName,
      DWORD grfMode,
      DWORD dwStgFmt,
      LPSECURITY_ATTRIBUTES pssSecurity,
      IStorage FAR * FAR *ppstg);

tdStgCreateStorage pStgCreateStorage = 0;

static int fDidInitOfVariants = 0;

void AddPropsToStorage( BOOL fAlternate )
{
    SCODE sc;

    if (! fDidInitOfVariants)
    {
        //
        // Create a multi-dimensional safearray for an alternate value for
        // property 8.
        //
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 50;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 10;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 10;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_I4, 3, saBounds, 0 );
        LONG * plData;
        sc = SafeArrayAccessData( psa, (void **)&plData );

        if ( FAILED(sc) )
        {
            LogError( "SafeArrayAccessData returned 0x%x\n", sc );
            CantRun();
        }
        memcpy( plData, alProp8, sizeof alProp8 );
        sc = SafeArrayUnaccessData( psa );
        varProp8A.vt = VT_I4 | VT_ARRAY;
        varProp8A.parray = psa;

        varProp11.vt = PROP11_TYPE;
        varProp11.bstrVal = SysAllocString( PROP11_VAL );

        const unsigned cchProp11A = sizeof PROP11_LONGVAL/sizeof PROP11_LONGVAL[0];
        for (unsigned i = 0; i + 25 + 25 < cchProp11A; i += 25)
            wcsncpy(&PROP11_LONGVAL[i+25], &PROP11_LONGVAL[i], 25);
        varProp11A.vt = PROP11_TYPE;
        varProp11A.bstrVal = SysAllocStringLen( PROP11_LONGVAL, wcslen(PROP11_LONGVAL) );

        varProp12.vt = PROP12_TYPE;
        varProp12.cabstr.pElems = (BSTR *)CoTaskMemAlloc( PROP4_VAL.cElems * sizeof (BSTR) );
        varProp12.cabstr.cElems = PROP4_VAL.cElems;
        for (i=0; i < PROP4_VAL.cElems; i++)
            varProp12.cabstr.pElems[i] = SysAllocString( PROP4_VAL.pElems[i] );

        fDidInitOfVariants++;
    }

    // Create a storage

    IStorage * pstg;
    ULONG ulMode = STGM_DIRECT | STGM_SHARE_EXCLUSIVE;
    sc = StgCreateDocfile( wcsTestPath,                 // Name
                           ulMode | STGM_READWRITE | STGM_CREATE,
                           0,                                // reserved
                           &pstg );                          // Result


    if ( FAILED(sc) )
    {
        LogError( "StgCreateDocfile %ws returned 0x%x\n", wcsTestPath, sc );
        CantRun();
    }

    // Create a property set

    IPropertySetStorage * ppsstg;
    sc = pstg->QueryInterface( IID_IPropertySetStorage, (void **)&ppsstg );
    pstg->Release();
    if ( FAILED(sc) )
    {
        LogError( "QueryInterface(IPropertySetStorage) returned 0x%lx\n", sc );
        CantRun();
    }

    AddSafeArrays( ppsstg );

    IPropertyStorage * ppstg;
    sc = ppsstg->Create( guidMyPropSet,               // Property set GUID
                         0,
                         PROPSETFLAG_DEFAULT,
                         ulMode | STGM_READWRITE,              // Open mode
                         &ppstg );                   // IProperty
    if ( FAILED(sc) )
    {
        LogError( "IPropertySetStorage::Create returned 0x%lx\n", sc );
        CantRun();
    }

    // Add property values

    PROPID pid=0x1000;

    varProp1.vt = PROP1_TYPE;
    varProp1.lVal = fAlternate ? PROP1_VAL_Alternate : PROP1_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty1.GetPropSpec(),  // Property
                               &varProp1,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 1 returned 0x%lx\n", sc );
        CantRun();
    }


    varProp2.vt = PROP2_TYPE;
    varProp2.pwszVal = (WCHAR *)PROP2_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty2.GetPropSpec(),  // Property
                               &varProp2,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 2 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp10.vt = PROP10_TYPE;
    varProp10.pwszVal = (WCHAR *)PROP10_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty10.GetPropSpec(), // Property
                               &varProp10,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 10 returned 0x%lx\n", sc );
        CantRun();
    }

    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty11.GetPropSpec(), // Property
                               fAlternate ? &varProp11A :
                                            &varProp11,         // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 11 returned 0x%lx\n", sc );
        CantRun();
    }

    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty12.GetPropSpec(), // Property
                               &varProp12,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 12 returned 0x%lx\n", sc );
        CantRun();
    }


    varProp5.vt = PROP5_TYPE;
    varProp5.cal = PROP5_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psRelevantWords.GetPropSpec(),  // Property
                               &varProp5,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 5 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp6.vt = PROP6_TYPE;
    varProp6.blob = PROP6_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psBlobTest.GetPropSpec(),       // Property
                               &varProp6,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 6 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp7.vt = PROP7_TYPE;
    varProp7.puuid = &PROP7_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psGuidTest.GetPropSpec(),       // Property
                               &varProp7,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 7 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp8.vt = PROP8_TYPE;
    varProp8.cal = PROP8_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psManyRW.GetPropSpec(),         // Property
                               fAlternate ? &varProp8A :
                                            &varProp8,          // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 8 returned 0x%lx\n", sc );
        CantRun();
    }


    varProp13.vt = PROP13_TYPE;
    varProp13.bVal = PROP13_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty13.GetPropSpec(), // Property
                               &varProp13,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 13 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp14.vt = PROP14_TYPE;
    varProp14.iVal = PROP14_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty14.GetPropSpec(), // Property
                               &varProp14,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 14 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp15.vt = PROP15_TYPE;
    varProp15.uiVal = PROP15_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty15.GetPropSpec(), // Property
                               &varProp15,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 13 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp16.vt = PROP16_TYPE;
    varProp16.lVal = PROP16_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty16.GetPropSpec(), // Property
                               &varProp16,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 16 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp17.vt = PROP17_TYPE;
    varProp17.fltVal = PROP17_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty17.GetPropSpec(), // Property
                               &varProp17,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 17 returned 0x%lx\n", sc );
        CantRun();
    }

    if (fAlternate)
    {
        varProp18A.decVal.sign = 0;
        varProp18A.decVal.Hi32 = 0;
        varProp18A.decVal.Lo64 = 123412345678i64;
        varProp18A.decVal.scale = 8;
        varProp18A.vt = VT_DECIMAL;

        //double dbl = 0.;
        //VarR8FromDec( &varProp18A.decVal, &dbl );
        //LogError("\tvarProp18A.decVal = %.8f\n", dbl );
    }
    else
    {
        varProp18.vt = PROP18_TYPE;
        varProp18.dblVal = PROP18_VAL;
    }
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty18.GetPropSpec(), // Property
                               fAlternate ? &varProp18A :
                                            &varProp18,         // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 18 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp19.vt = PROP19_TYPE;
    varProp19.boolVal = PROP19_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty19.GetPropSpec(), // Property
                               &varProp19,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 19 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp20.vt = PROP20_TYPE;
    varProp20.pszVal = PROP20_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty20.GetPropSpec(), // Property
                               &varProp20,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 20 returned 0x%lx\n", sc );
        CantRun();
    }


    varProp21.vt = PROP21_TYPE;
    varProp21.pclipdata = PROP21_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty21.GetPropSpec(), // Property
                               &varProp21,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 21 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp22.vt = PROP22_TYPE;
    varProp22.caclipdata.pElems = PROP22_VAL;
    varProp22.caclipdata.cElems = PROP22_CVALS;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty22.GetPropSpec(), // Property
                               &varProp22,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 22 returned 0x%lx\n", sc );
        CantRun();
    }


    ppstg->Release();

    // PROP3 and PROP4 are in a different propertyset!

    sc = ppsstg->Create( guidDocument,               // Property set GUID
                         0,
                         PROPSETFLAG_DEFAULT,
                         ulMode | STGM_READWRITE,              // Open mode
                         &ppstg );                   // IProperty
    if ( FAILED(sc) )
    {
        LogError( "IPropertySetStorage::Create returned 0x%lx\n", sc );
        CantRun();
    }

    varProp3.vt = PROP3_TYPE;
    varProp3.pwszVal = (WCHAR *)PROP3_VAL;
    sc = ppstg->WriteMultiple( 1,                              // Count
                               &psAuthor.GetPropSpec(),        // Property
                               &varProp3,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 3 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp4.vt = PROP4_TYPE;
    varProp4.calpwstr = PROP4_VAL;
    sc = ppstg->WriteMultiple( 1,                              // Count
                               &psKeywords.GetPropSpec(),      // Property
                               &varProp4,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 4 returned 0x%lx\n", sc );
        CantRun();
    }




    ppstg->Release();

    /////////////////////// the secure prop plan 9

    sc = ppsstg->Create( guidSecurityTest,
                         0,
                         PROPSETFLAG_DEFAULT,
                         ulMode | STGM_READWRITE, // Open mode
                         &ppstg );                // IProperty
    if ( FAILED(sc) )
        LogFail( "IPropertySetStorage::Create (security2) returned 0x%lx\n", sc );

    // this value will be invisible to queries due to permissions...
    varProp9.vt = VT_EMPTY;
    varProp9.lVal = 0;

    ppstg->Release();
    ppsstg->Release();

} //AddPropsToStorage


//+-------------------------------------------------------------------------
//
//  Function:   AddFiles, public
//
//  Synopsis:   Add several files to a directory.
//
//  Arguments:  [wszPath] - path name where files should be added
//              [cFiles] - number of files to create
//              [wszPattern] - wsprintf string to create file name
//
//  History:    18 May 1995  AlanW     Created
//
//--------------------------------------------------------------------------

void AddFiles( const WCHAR *wszPath, unsigned cFiles, const WCHAR *wszPattern)
{
    WCHAR wszFileName[MAX_PATH];
    const unsigned owcFile = wcslen( wszPath );

    for (unsigned i=0; i < cFiles; i++)
    {
        wcscpy( wszFileName, wszPath );
        swprintf( &wszFileName[ owcFile ], wszPattern, i );

        BuildFile( wszFileName, szOFSFileData, strlen( szOFSFileData ) );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   Setup, public
//
//  Synopsis:   Clean up and initialize state
//
//  History:    13-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

void Setup()
{
    if ( 0 == wcsTestCatalog[0] )
        wcscpy( wcsTestCatalog, wcsDefaultTestCatalog );

    if ( GetEnvironmentVariable( L"TEMP",
                                 wcsTestPath,
                                 sizeof(wcsTestPath) / sizeof(wcsTestPath[0]) ) == 0 )
    {
        LogError( "Unable to find test directory.  Set TEMP variable.\n" );
        CantRun();
    }

    wcscat( wcsTestPath, L"\\" );
    int ccPath = wcslen( wcsTestPath );

    wcscat( wcsTestPath, wcsTestDir );

    if (Delnode( wcsTestPath ))
    {
        LogError("Delnode %ws failed\n", wcsTestPath);
        CantRun();
    }

    //
    // Create test directory.
    //

    if ( !CreateDirectory( (WCHAR *)wcsTestPath, 0 ) )
    {
        LogError( "Error 0x%lx creating directory %ws\n",
                    GetLastError(), wcsTestPath );
        CantRun();
    }

    //
    // Add property file + properties
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsPropFile );
    AddPropsToStorage( FALSE );

    //
    // Make a second (similar) file
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsPropFile2 );
    AddPropsToStorage( TRUE );

    wcscpy( wcsTestPath + ccPath, wcsTestDir );

    //
    // Add more files for the delete tests
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\DeleteTest.1" );
    if ( !CreateDirectory( (WCHAR *)wcsTestPath, 0 ) )
    {
        LogError( "Error 0x%lx creating directory %ws\n",
                    GetLastError(), wcsTestPath );
        CantRun();
    }

    AddFiles(  wcsTestPath, 20, L"\\\\F%04d.txt" );

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\DeleteTest.2" );
    if ( !CreateDirectory( (WCHAR *)wcsTestPath, 0 ) )
    {
        LogError( "Error 0x%lx creating directory %ws\n",
                    GetLastError(), wcsTestPath );
        CantRun();
    }

    AddFiles(  wcsTestPath, 20, L"\\\\F%04d.txt" );

    //
    //  Add three files for content query tests
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsTestCiFile1 );
    BuildFile( wcsTestPath, szCIFileData1, strlen( szCIFileData1 ) );

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsTestCiFile2 );
    BuildFile( wcsTestPath, szCIFileData2, strlen( szCIFileData2 ) );

    // make file 2 visible to both filter daemon and current user.
    // (it was already, but this verifies the file3 code below really works)
#ifdef CAIRO_SECURITY_WORKS
    DenyAllAccess( wcsTestPath );
    GiveAccess( wcsTestPath, TRUE, GENERIC_READ );
    GiveAccess( wcsTestPath, FALSE, GENERIC_READ );
#endif

    //
    // make a file that should show up in content queries.
    // give it write access to current user, read access to filter daemon
    //  => in the content index, but the current user can't see hit
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsTestCiFile3 );
    BuildFile( wcsTestPath, szCIFileData2, strlen( szCIFileData2 ) );
    DenyAllAccess( wcsTestPath );
#ifdef CAIRO_SECURITY_WORKS
    GiveAccess( wcsTestPath, TRUE, GENERIC_WRITE ); // just for kicks
    GiveAccess( wcsTestPath, FALSE, GENERIC_READ );
#endif

    //
    // Back to just directory
    //
    wcscpy( wcsTestPath + ccPath, wcsTestDir );

} //Setup

//+-------------------------------------------------------------------------
//
//  Function:   Cleanup, public
//
//  Synopsis:   Clean up and initialize state
//
//  History:    13-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

void Cleanup()
{
    if (Delnode( wcsTestPath ))
    {
        LogError("Delnode %ws failed\n", wcsTestPath);
        CantRun();
    }

    if ( fDidInitOfVariants )
    {
        PropVariantClear( &varProp8A );
        PropVariantClear( &varProp11 );
        PropVariantClear( &varProp11A );
        PropVariantClear( &varProp12 );
    }

    char acSysDir[MAX_PATH];
    if( !GetSystemDirectoryA( acSysDir, sizeof(acSysDir) ) )
    {
        LogFail( "Unable to determine system directory.\n" );
    }

#if defined( DO_NOTIFICATION )
    char acCmd[MAX_PATH];
    sprintf(acCmd,"del %s\\*.zzz",acSysDir);
    system(acCmd);
#endif  // DO_NOTIFICATION

} //Cleanup


//+---------------------------------------------------------------------------
//
//  Function:   FormQueryTree
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [pRst]      - pointer to Restriction tree describing the query
//              [Cols]      - Columns in the resulting table
//              [pSort]     - pointer to sort set; may be null
//              [aColNames] - pointer to column names; may be null
//
//  Returns:    A pointer to the query tree. It is the responsibility of
//              the caller to later free it.
//
//  History:    06 July 1995   AlanW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode * pRst,
                                CDbColumns & Cols,
                                CDbSortSet * pSort,
                                LPWSTR * aColNames )
{
    CDbCmdTreeNode *  pTree = 0;        // return value

    if (pRst)
    {
        //
        // First create a selection node and append the restriction tree to it
        //
        CDbSelectNode * pSelect = new CDbSelectNode();
        if ( 0 == pSelect )
        {
            LogFail("FormQueryTree: out of memory 0\n");
        }

        pTree = pSelect;
        if ( !pSelect->IsValid() )
        {
            delete pTree;
            LogFail("FormQueryTree: out of memory 1\n");
        }

        //
        // Clone the restriction and use it.
        //
        CDbCmdTreeNode * pExpr = pRst->Clone();
        if ( 0 == pExpr )
        {
            delete pTree;
            LogFail("FormQueryTree: out of memory 2\n");
        }

        //
        // Now make the restriction a child of the selection node.
        //
        pSelect->AddRestriction( pExpr );
    }
    else
    {
        //
        // No restriction.  Just use table ID node as start of tree.
        //
        pTree = new CDbTableId();
        if ( 0 == pTree )
        {
            LogFail("FormQueryTree: out of memory 3\n");
        }
    }

    //
    // Next create the projection nodes
    //
    CDbProjectNode * pProject = new CDbProjectNode();
    if ( 0 == pProject )
    {
        delete pTree;
        LogFail("FormQueryTree: out of memory 4\n");
    }

    //
    // Make the selection a child of the projection node.
    //
    pProject->AddTable( pTree );
    pTree = pProject;

    //
    // Next add all the columns in the state.
    //
    unsigned int cCol = Cols.Count();
    for ( unsigned int i = 0; i < cCol; i++ )
    {
        if ( !pProject->AddProjectColumn( Cols.Get(i),
                                          aColNames ? aColNames[i] : 0 ))
        {
            delete pTree;
            LogFail("FormQueryTree: out of memory 5\n");
        }
    }

    //
    // Next add a sort node and make the project node a child of the
    // sort node
    //

    if (pSort && pSort->Count())
    {
        unsigned int cSortProp = pSort->Count();
        CDbSortNode * pSortNode = new CDbSortNode();

        if ( 0 == pSortNode )
        {
            delete pTree;
            LogFail("FormQueryTree: out of memory 6\n");
        }

        //
        // Make the project node a child of the sort node.
        //
        pSortNode->AddTable( pTree );
        pTree = pSortNode;

        DWORD sd = QUERY_SORTASCEND;
        LCID lcid = 0;
        for( i = 0; i < cSortProp; i++ )
        {
            //
            // Add the sort column.
            //
            if ( !pSortNode->AddSortColumn(pSort->Get(i)))
            {
                delete pTree;
                LogFail("FormQueryTree: out of memory 7\n");
            }
        }
    }

    return pTree;
}

void GetCommandTreeErrors(ICommandTree* pCmdTree)
{

    DBCOMMANDTREE * pTreeCopy = 0;
    SCODE sc = pCmdTree->GetCommandTree(&pTreeCopy);
    if (FAILED(sc))
    {
        pCmdTree->Release();
        LogFail("GetCommandTree failed, %08x\n", sc);
    }

    ULONG cErrorNodes = 0;
    DBCOMMANDTREE ** rgpErrorNodes = 0;

    sc = pCmdTree->FindErrorNodes(pTreeCopy, &cErrorNodes, &rgpErrorNodes);
    if (FAILED(sc))
    {
        pCmdTree->FreeCommandTree(&pTreeCopy);
        pCmdTree->Release();
        LogFail("FindErrorNodes failed, %08x\n", sc);
    }

    for (unsigned i=0; i<cErrorNodes; i++)
    {
        DBCOMMANDTREE* pNode = rgpErrorNodes[i];
        if (pNode->hrError != S_OK)
        {
            LogError("tree node %08x\top=%d\tOp Error=%x\n",
                       pNode, pNode->op, pNode->hrError);
        }
        else
            LogError("tree node %x\top=%d\tNO ERROR!!\n",
                       pNode, pNode->op);
    }

    pCmdTree->FreeCommandTree(&pTreeCopy);
}

//+---------------------------------------------------------------------------
//
//  Function:   InstantiateRowset
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [pQueryIn]  - Input ICommand or NULL
//              [dwDepth]   - Query depth, one of QUERY_DEEP or QUERY_SHALLOW
//              [pswzScope] - Query scope
//              [pTree]     - pointer to DBCOMMANDTREE for the query
//              [riid]      - Interface ID of the desired rowset interface
//              [pUnkOuter] - pointer to outer unknown object
//              [ppCmdTree] - if non-zero, ICommandTree will be returned here.
//              [fExtendedTypes] - if TRUE, set property for extended variants
//
//  Returns:    IRowsetScroll* - a pointer to an instantiated rowset
//
//  History:    22 July 1995   AlanW   Created
//              01 July 1997   EmilyB  Added outer unknown support for
//                             ICommand only.
//
//  Notes:      Although the returned pointer is to IRowsetScroll, the
//              returned pointer may only support IRowset, depending
//              upon the riid parameter.
//
//              Ownership of the query tree is given to the ICommandTree
//              object.  The caller does not need to delete it.
//
//              Use InstantiateMultipleRowsets for categorized queries.
//
//----------------------------------------------------------------------------

static g_cLocatable = 0;

IRowsetScroll * InstantiateRowset(
    ICommand *pQueryIn,
    DWORD dwDepth,
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    REFIID riid,
    COuterUnk * pobjOuterUnk,
    ICommandTree **ppCmdTree,
    BOOL fExtendedTypes
) {
    // run the query
    ICommand * pQuery = 0;
    if ( 0 == pQueryIn )
    {
        IUnknown * pIUnknown;
        SCODE sc = CICreateCommand( &pIUnknown,
                                    (IUnknown *)pobjOuterUnk,
                                    IID_IUnknown,
                                    TEST_CATALOG,
                                    TEST_MACHINE );

        if ( FAILED( sc ) )
            LogFail( "InstantiateRowset - error 0x%x Unable to create ICommand\n",
                     sc );

        if (pobjOuterUnk)
        {
           pobjOuterUnk->Set(pIUnknown);
        }

        if (pobjOuterUnk)
            sc = pobjOuterUnk->QueryInterface(IID_ICommand, (void **) &pQuery );
        else
            sc = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );

        pIUnknown->Release();

        if ( FAILED( sc ) )
            LogFail( "InstantiateRowset - error 0x%x Unable to QI ICommand\n",
                     sc );

        if ( 0 == pQuery )
            LogFail( "InstantiateRowset - CICreateCommand succeeded, but returned null pQuery\n" );

        sc = SetScopeProperties( pQuery,
                                 1,
                                 &pwszScope,
                                 &dwDepth );

        if ( FAILED( sc ) )
            LogFail( "InstantiateRowset - error 0x%x Unable to set scope '%ws'\n",
                     sc, pwszScope );

        CheckPropertiesOnCommand( pQuery );
    }
    else
    {
        pQuery = pQueryIn;
    }

    ICommandTree *pCmdTree = 0;
    SCODE sc;
    if (pobjOuterUnk)
        sc = pobjOuterUnk->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);
    else
        sc = pQuery->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);

    if (FAILED (sc) )
    {
        if ( 0 == pQueryIn )
            pQuery->Release();

        LogFail("QI for ICommandTree failed\n");
    }

    DBCOMMANDTREE * pRoot = pTree->CastToStruct();

    sc = pCmdTree->SetCommandTree( &pRoot, 0, FALSE);
    if (FAILED (sc) )
    {
        if ( 0 == pQueryIn )
           pQuery->Release();

        pCmdTree->Release();
        LogFail("SetCommandTree failed, %08x\n", sc);
    }

    if (fExtendedTypes)
    {
        ICommandProperties *pCmdProp = 0;
        if (pobjOuterUnk)
            sc = pobjOuterUnk->QueryInterface(IID_ICommandProperties, (void **)&pCmdProp);
        else
            sc = pQuery->QueryInterface(IID_ICommandProperties, (void **)&pCmdProp);

        if (FAILED (sc) )
        {
            if ( 0 == pQueryIn )
                pQuery->Release();

            LogFail("QI for ICommandProperties failed\n");
        }

        //
        //  If we should NOT be using a enumerated query, notify pCommand
        //
        const unsigned MAX_PROPS = 6;
        DBPROPSET  aPropSet[MAX_PROPS];
        DBPROP     aProp[MAX_PROPS];
        ULONG      cProp = 0;

        aProp[cProp].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_BOOL;
        aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidQueryExt;

        cProp++;

        if (riid == IID_IRowsetLocate)
        {
            aProp[cProp].dwPropertyID = DBPROP_IRowsetLocate;
            aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
            aProp[cProp].dwStatus     = 0;         // Ignored
            aProp[cProp].colid        = dbcolNull;
            aProp[cProp].vValue.vt    = VT_BOOL;
            aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

            aPropSet[cProp].rgProperties = &aProp[cProp];
            aPropSet[cProp].cProperties = 1;
            aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

            cProp++;

            aProp[cProp].dwPropertyID = DBPROP_BOOKMARKS;
            aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
            aProp[cProp].dwStatus     = 0;         // Ignored
            aProp[cProp].colid        = dbcolNull;
            aProp[cProp].vValue.vt    = VT_BOOL;
            aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

            aPropSet[cProp].rgProperties = &aProp[cProp];
            aPropSet[cProp].cProperties = 1;
            aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

            cProp++;

            g_cLocatable++;
            if (g_cLocatable % 2)
            {
                aProp[cProp].dwPropertyID = DBPROP_IDBAsynchStatus;
                aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
                aProp[cProp].dwStatus     = 0;         // Ignored
                aProp[cProp].colid        = dbcolNull;
                aProp[cProp].vValue.vt    = VT_BOOL;
                aProp[cProp].vValue.boolVal = VARIANT_TRUE;

                aPropSet[cProp].rgProperties = &aProp[cProp];
                aPropSet[cProp].cProperties = 1;
                aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

                cProp++;
            }
            if ((g_cLocatable % 4) == 3)
            {
                aProp[cProp].dwPropertyID = DBPROP_IRowsetWatchAll;
                aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
                aProp[cProp].dwStatus     = 0;         // Ignored
                aProp[cProp].colid        = dbcolNull;
                aProp[cProp].vValue.vt    = VT_BOOL;
                aProp[cProp].vValue.boolVal = VARIANT_TRUE;

                aPropSet[cProp].rgProperties = &aProp[cProp];
                aPropSet[cProp].cProperties = 1;
                aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

                cProp++;
            }
        }
        else if (riid == IID_IRowsetScroll)
        {
            aProp[cProp].dwPropertyID = DBPROP_IRowsetScroll;
            aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
            aProp[cProp].dwStatus     = 0;         // Ignored
            aProp[cProp].colid        = dbcolNull;
            aProp[cProp].vValue.vt    = VT_BOOL;
            aProp[cProp].vValue.boolVal = VARIANT_TRUE;

            aPropSet[cProp].rgProperties = &aProp[cProp];
            aPropSet[cProp].cProperties = 1;
            aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

            cProp++;

            g_cLocatable++;
            if (g_cLocatable % 2)
            {
                aProp[cProp].dwPropertyID = DBPROP_ROWSET_ASYNCH;
                aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
                aProp[cProp].dwStatus     = 0;         // Ignored
                aProp[cProp].colid        = dbcolNull;
                aProp[cProp].vValue.vt    = VT_I4;
                aProp[cProp].vValue.lVal  = DBPROPVAL_ASYNCH_RANDOMPOPULATION;

                aPropSet[cProp].rgProperties = &aProp[cProp];
                aPropSet[cProp].cProperties = 1;
                aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

                cProp++;
            }
            if ((g_cLocatable % 4) == 3)
            {
                aProp[cProp].dwPropertyID = DBPROP_IRowsetWatchAll;
                aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
                aProp[cProp].dwStatus     = 0;         // Ignored
                aProp[cProp].colid        = dbcolNull;
                aProp[cProp].vValue.vt    = VT_BOOL;
                aProp[cProp].vValue.boolVal = VARIANT_TRUE;

                aPropSet[cProp].rgProperties = &aProp[cProp];
                aPropSet[cProp].cProperties = 1;
                aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

                cProp++;
            }
        }

        sc = pCmdProp->SetProperties( cProp, aPropSet );
        pCmdProp->Release();

        if ( FAILED(sc) || DB_S_ERRORSOCCURRED == sc )
        {
            if ( 0 == pQueryIn )
                pQuery->Release();

            LogError("ICommandProperties::SetProperties failed\n");
        }
    }

    IRowset * pRowset = 0;

    sc = pQuery->Execute( 0,                    // no aggr. IUnknown
                          (riid != IID_IRowset) ?
                                IID_IRowsetIdentity :
                                IID_IRowset,    // IID for i/f to return
                          0,                    // disp. params
                          0,                    // count of rows affected
                          (IUnknown **)&pRowset);  // Returned interface

    if (SUCCEEDED (sc) && 0 == pRowset )
    {
        LogError("ICommand::Execute returned success(%x), but pRowset is null\n", sc);
        if (DB_S_ERRORSOCCURRED == sc)
        {
            CheckPropertiesInError(pQuery);
        }
        pCmdTree->Release();
        pQuery->Release();
        Fail();
    }


    if ( 0 == pQueryIn )
        pQuery->Release();

    if (FAILED (sc) )
    {
        LogError("ICommand::Execute failed, %08x\n", sc);
        if (DB_E_ERRORSINCOMMAND == sc)
        {
            GetCommandTreeErrors(pCmdTree);
        }
        if (DB_E_ERRORSOCCURRED == sc)
        {
            CheckPropertiesInError(pQuery);
        }
        pCmdTree->Release();

        //
        // This isn't really kosher, but it helps to avoid spurious (client-side) memory leaks.
        //

        pQuery->Release();
        Fail();
    }

    if (riid != IID_IRowset)
    {
        IRowset * pRowset2 = 0;

        sc = pRowset->QueryInterface(riid, (void **)&pRowset2);

        if (FAILED (sc) )
        {
            LogError("InstantiateRowset - QI to riid failed, %08x\n", sc);
            pCmdTree->Release();
            Fail();
        }
        pRowset->Release();
        pRowset = pRowset2;
    }

    if ( 0 == ppCmdTree )
    {
        pCmdTree->Release();
    }
    else
    {
        *ppCmdTree = pCmdTree;
    }

    return (IRowsetScroll *)pRowset;
}


//+---------------------------------------------------------------------------
//
//  Function:   InstantiateMultipleRowsets
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [dwDepth]   - Query depth, one of QUERY_DEEP or QUERY_SHALLOW
//              [pswzScope] - Query scope
//              [pTree]     - pointer to DBCOMMANDTREE for the query
//              [riid]      - Interface ID of the desired rowset interface
//              [cRowsets]  - Number of rowsets to be returned
//              [ppRowsets] - Pointer to location where rowsets are returned
//              [ppCmdTree] - if non-zero, ICommandTree will be returned here.
//
//  Returns:    Nothing
//
//  History:    22 July 1995   AlanW   Created
//
//  Notes:      Ownership of the query tree is given to the ICommandTree
//              object.  The caller does not need to delete it.
//
//----------------------------------------------------------------------------

void
InstantiateMultipleRowsets(
    DWORD dwDepth,
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    REFIID riid,
    unsigned cRowsets,
    IUnknown **ppRowsets,
    ICommandTree ** ppCmdTree
) {
    // run the query
    ICommand * pQuery = 0;
    IUnknown * pIUnknown;
    SCODE scIC = CICreateCommand( &pIUnknown,
                                  0,
                                  IID_IUnknown,
                                  TEST_CATALOG,
                                  TEST_MACHINE );

    if (FAILED(scIC))
        LogFail( "InstantiateMultipleRowsets - error 0x%x, Unable to create ICommand\n",
                 scIC );

    scIC = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );
    pIUnknown->Release();

    if ( FAILED( scIC ) )
        LogFail( "InstantiateMultipleRowsets - error 0x%x Unable to QI ICommand\n",
                 scIC );


    if ( 0 == pQuery )
        LogFail( "InstantiateMultipleRowsets - CICreateCommand succeeded, but returned null pQuery\n" );

    scIC = SetScopeProperties( pQuery,
                               1,
                               &pwszScope,
                               &dwDepth );

    if ( FAILED( scIC ) )
        LogFail( "InstantiateMultipleRowsets - error 0x%x Unable to set scope '%ws'\n",
                 scIC, pwszScope );

    scIC = SetBooleanProperty( pQuery, DBPROP_CANHOLDROWS, VARIANT_TRUE );

    if ( FAILED( scIC ) )
        LogFail( "InstantiateMultipleRowsets - error 0x%x Unable to set HoldRows\n",
                 scIC );

    CheckPropertiesOnCommand( pQuery );

    ICommandTree *pCmdTree = 0;
    SCODE sc = pQuery->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);

    if (FAILED (sc) )
    {
        pQuery->Release();
        LogFail("QI for ICommandTree failed\n");
    }

    DBCOMMANDTREE * pRoot = pTree->CastToStruct();
    sc = pCmdTree->SetCommandTree( &pRoot, 0, FALSE);
    if (FAILED (sc) )
    {
        pQuery->Release();
        pCmdTree->Release();
        LogFail("SetCommandTree failed, %08x\n", sc);
    }

    sc = pQuery->Execute( 0,                    // no aggr. IUnknown
                          riid,                 // IID for i/f to return
                          0,                    // disp. params
                          0,                    // count of rows affected
                          (IUnknown **)ppRowsets);  // Returned interface

    pQuery->Release();

    if (FAILED (sc) )
    {
        LogError("ICommand::Execute failed, %08x\n", sc);
        if (DB_E_ERRORSINCOMMAND == sc)
        {
            GetCommandTreeErrors(pCmdTree);
        }
        pCmdTree->Release();
        Fail();
    }

    // Get rowset pointers for all child rowsets
    for (unsigned i=1; i<cRowsets; i++)
    {
        IUnknown * pRowset = ppRowsets[i-1];
        IColumnsInfo * pColumnsInfo = 0;
        sc = pRowset->QueryInterface(IID_IColumnsInfo, (void **)&pColumnsInfo);
        if (FAILED (sc) )
        {
            pCmdTree->Release();
            LogFail("QI for IColumnsInfo failed\n");
        }
        DBORDINAL iChaptOrdinal = 0;
        sc = pColumnsInfo->MapColumnIDs(1, &psChapt, &iChaptOrdinal);
        pColumnsInfo->Release();
        if (FAILED (sc) )
        {
            pCmdTree->Release();
            LogFail("MapColumnIDs of chapter column failed, %x\n", sc);
        }

        IRowsetInfo * pRowsetInfo = 0;
        sc = pRowset->QueryInterface(IID_IRowsetInfo, (void **)&pRowsetInfo);
        if (FAILED (sc) )
        {
            pCmdTree->Release();
            LogFail("QI for IRowsetInfo failed\n");
        }
        sc = pRowsetInfo->GetReferencedRowset(iChaptOrdinal, riid, &ppRowsets[i]);
        pRowsetInfo->Release();
        if (FAILED (sc) )
        {
            pCmdTree->Release();
            LogFail("GetReferencedRowset failed, %x\n", sc);
        }
    }

    if ( 0 == ppCmdTree )
    {
        pCmdTree->Release();
    }
    else
    {
        *ppCmdTree = pCmdTree;
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReleaseStaticHrows, public
//
//  Synopsis:   Release a caller allocated HROW array
//
//  Arguments:  [pRowset] - a pointer to IRowset
//              [cRows]   - nuumber of HROWs in the array
//              [phRows]  - a pointer to the HROWs array
//
//  Returns:    Nothing
//
//  History:    03 Oct 1996     AlanW   Created
//
//--------------------------------------------------------------------------

const unsigned MAX_ROWSTATUS = 20;

ULONG aRowRefcount[MAX_ROWSTATUS];
DBROWSTATUS aRowStatus[MAX_ROWSTATUS];

void ReleaseStaticHrows( IRowset * pRowset, DBCOUNTITEM cRows, HROW * phRows )
{
    ULONG *pRefCount = 0;
    DBROWSTATUS *pRowStatus = 0;

    if (cRows <= MAX_ROWSTATUS)
    {
        pRefCount = aRowRefcount;
        pRowStatus = aRowStatus;
    }

    SCODE sc = pRowset->ReleaseRows(cRows, phRows, 0, pRefCount, pRowStatus);
    if (sc != S_OK && sc != DB_S_ERRORSOCCURRED)
    {
        LogError("ReleaseStaticHrows: ReleaseRows failed, sc=%x\n", sc);
        cFailures++;
    }
    else if (cRows <= MAX_ROWSTATUS)
    {
        for (unsigned i=0; i<cRows; i++)
        {
            if ( pRowStatus[i] != DBROWSTATUS_S_OK &&
                 ! ( pRowStatus[i] == DBROWSTATUS_E_INVALID &&
                     phRows[i] == DB_NULL_HROW ))
            {
                LogError("ReleaseStaticHrows: ReleaseRows row status/refcount, "
                         "hrow=%x ref=%d stat=%d\n", phRows[i], pRefCount[i], pRowStatus[i]);
                cFailures++;
                continue;
            }
            if ( pRowStatus[i] != DBROWSTATUS_S_OK &&
                 sc != DB_S_ERRORSOCCURRED )
            {
                LogError("ReleaseStaticHrows: bad return status, sc = %x\n", sc);
                cFailures++;
                continue;
            }
        }
    }
} //ReleaseStaticHrows


//+-------------------------------------------------------------------------
//
//  Function:   FreeHrowsArray, public
//
//  Synopsis:   Release and free a callee allocated HROW array
//
//  Effects:    Memory is freed; pointer is zeroed
//
//  Arguments:  [pRowset] - a pointer to IRowset
//              [cRows]   - nuumber of HROWs in the array
//              [pphRows] - a pointer to pointer to the HROWs array
//
//  History:    01 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

void FreeHrowsArray( IRowset * pRowset, DBCOUNTITEM cRows, HROW ** pphRows )
{
    if (*pphRows)
    {
        ReleaseStaticHrows(pRowset, cRows, *pphRows);
        CoTaskMemFree(*pphRows);
        *pphRows = 0;
    }
} //FreeHrowsArray


//+-------------------------------------------------------------------------
//
//  Function:   MapColumns, public
//
//  Synopsis:   Map column IDs in column bindings.  Create an accessor
//              for the binding array.
//
//  Arguments:  [pUnknown]  -- Interface capable of returning IColumnsInfo and
//                             IAccessor
//              [cCols]     -- number of columns in arrays
//              [pBindings] -- column data binding array
//              [pDbCols]   -- column IDs array
//              [fByRef]    -- true if byref/vector columns should be byref
//
//  Returns:    HACCESSOR - a read accessor for the column bindings.
//
//  History:    18 May 1995     AlanW     Created
//
//--------------------------------------------------------------------------

static DBORDINAL aMappedColumnIDs[20];

HACCESSOR MapColumns(
    IUnknown * pUnknown,
    DBORDINAL cCols,
    DBBINDING * pBindings,
    const DBID * pDbCols,
    BOOL fByRef )
{
    IColumnsInfo * pColumnsInfo = 0;

    SCODE sc = pUnknown->QueryInterface( IID_IColumnsInfo, (void **)&pColumnsInfo);
    if ( FAILED( sc ) || pColumnsInfo == 0 )
    {
        LogFail( "IUnknown::QueryInterface for IColumnsInfo returned 0x%lx\n", sc );
    }

    sc = pColumnsInfo->MapColumnIDs(cCols, pDbCols, aMappedColumnIDs);
    pColumnsInfo->Release();

    if (S_OK != sc)
    {
        LogFail( "IColumnsInfo->MapColumnIDs returned 0x%lx\n",sc);
    }

    for (ULONG i = 0; i < cCols; i++)
    {
        pBindings[i].iOrdinal = aMappedColumnIDs[i];
        if ( fByRef &&
             ( (pBindings[i].wType & (DBTYPE_BYREF|DBTYPE_VECTOR)) ||
               pBindings[i].wType == DBTYPE_BSTR ||
               pBindings[i].wType == VT_LPWSTR ||
               pBindings[i].wType == VT_LPSTR ) &&
             pBindings[i].dwMemOwner != DBMEMOWNER_PROVIDEROWNED)
        {
            LogError( "Test error -- MapColumns with fByref, bad accessor %d\n", i);
        }

        if ( ! fByRef &&
             ( (pBindings[i].wType & (DBTYPE_BYREF|DBTYPE_VECTOR)) ||
               pBindings[i].wType == DBTYPE_BSTR ||
               pBindings[i].wType == VT_LPWSTR ||
               pBindings[i].wType == VT_LPSTR ) &&
             pBindings[i].dwMemOwner != DBMEMOWNER_CLIENTOWNED)
        {
            LogError( "Test error -- MapColumns without fByref, bad accessor %d\n", i);
        }
    }

    IAccessor * pIAccessor = 0;

    sc = pUnknown->QueryInterface( IID_IAccessor, (void **)&pIAccessor);
    if ( FAILED( sc ) || pIAccessor == 0 )
    {
        LogFail( "IRowset::QueryInterface for IAccessor returned 0x%lx\n", sc );
    }

    HACCESSOR hAcc;
    sc = pIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, cCols, pBindings,
                                     0, &hAcc, 0 );
    pIAccessor->Release();

    if (S_OK != sc)
    {
        LogFail( "IAccessor->CreateAccessor returned 0x%lx\n", sc);
    }
    return hAcc;
}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseAccessor, public
//
//  Synopsis:   Release an accessor obtained from MapColumns
//
//  Arguments:  [pUnknown]  -- Something that we can QI the IAccessor on
//              [hAcc]      -- Accessor handle to be released.
//
//  Returns:    nothing
//
//  History:    14 June 1995     AlanW     Created
//
//--------------------------------------------------------------------------

void ReleaseAccessor( IUnknown * pUnknown, HACCESSOR hAcc )
{
    IAccessor * pIAccessor = 0;

    SCODE sc = pUnknown->QueryInterface( IID_IAccessor, (void **)&pIAccessor);
    if ( FAILED( sc ) || pIAccessor == 0 )
    {
        LogFail( "IUnknown::QueryInterface for IAccessor returned 0x%lx\n", sc );
    }

    ULONG cRef;
    sc = pIAccessor->ReleaseAccessor( hAcc, &cRef );
    pIAccessor->Release();

    if (S_OK != sc)
    {
        LogFail( "IAccessor->ReleaseAccessor returned 0x%lx\n", sc);
    }
    if (0 != cRef)
    {
        LogFail( "IAccessor->ReleaseAccessor not last ref: %d\n", cRef);
    }
}

#if defined( DO_NOTIFICATION )
class CNotifyAsynch : public IDBAsynchNotify
{
    public:
        CNotifyAsynch() :
            _fChecking(FALSE),
            _fComplete(FALSE),
            _cRef(1)
        {}

        ~CNotifyAsynch()
        {
            if (_fChecking)
            {
                if (1 != _cRef) // NOTE: notify objects are static allocated
                {
                    LogError( "Bad refcount on CNotifyAsynch.\n" );
                }
            }
        }

        void DoChecking(BOOL fChecking)
        {
            _fChecking = fChecking;
        }

        //
        // IUnknown methods.
        //

        STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppiuk)
            {
                *ppiuk = (void **) this; // hold our breath and jump
                AddRef();
                return S_OK;
            }

        STDMETHOD_(ULONG, AddRef) (THIS)
            { return ++_cRef; }

        STDMETHOD_(ULONG, Release) (THIS)
            { return --_cRef; }

        //
        // IDBAsynchNotify methods
        //

        STDMETHOD(OnLowResource) (THIS_ DB_DWRESERVE dwReserved)
        {
            return S_OK;
        }

        STDMETHOD(OnProgress) (THIS_ HCHAPTER hChap, DBASYNCHOP ulOp,
                               DBCOUNTITEM ulProg, DBCOUNTITEM ulProgMax,
                               DBASYNCHPHASE ulStat, LPOLESTR pwszStatus )
        {
            if (ulProg == ulProgMax)
                _fComplete = TRUE;
            return S_OK;
        }

        STDMETHOD(OnStop) (THIS_ HCHAPTER hChap, ULONG ulOp,
                           HRESULT hrStat, LPOLESTR pwszStatus )
        {
            return S_OK;
        }

        BOOL IsComplete(void)
            { return _fComplete; }

    private:
        ULONG _cRef;
        BOOL _fChecking;
        BOOL _fComplete;
};
#endif //defined( DO_NOTIFICATION )

//+-------------------------------------------------------------------------
//
//  Function:   WaitForCompletion, public
//
//  Synopsis:   Loops until query is finished
//
//  Arguments:  [pRowset] -- Table cursor to wait for
//
//  Returns:    TRUE if successful
//
//  History:    30 Jun 94       AlanW     Created
//
//--------------------------------------------------------------------------

int WaitForCompletion( IRowset *pRowset, BOOL fQuiet )
{
    IDBAsynchStatus * pRowsetAsynch = 0;

    SCODE sc = pRowset->QueryInterface( IID_IDBAsynchStatus,
                                        (void **)&pRowsetAsynch);
    if ( sc == E_NOINTERFACE )
        return TRUE;

    if ( FAILED( sc ) || pRowsetAsynch == 0 )
    {
        LogError( "IRowset::QueryInterface for IDBAsynchStatus returned 0x%lx\n", sc );
        return( FALSE );
    }

    if (! fQuiet)
        LogProgress( "  Waiting for query to complete" );

    time( &tstart );
    ULONG ulSleep = 25;

    BOOL fDone = FALSE;

#if defined( DO_NOTIFICATION )
    IConnectionPoint *pConnectionPoint = 0;
    DWORD dwAdviseID = 0;

    CNotifyAsynch Notify;

    Notify.DoChecking(TRUE);

    //
    // Get the connection point container
    //

    IConnectionPointContainer *pConnectionPointContainer = 0;
    sc = pRowset->QueryInterface(IID_IConnectionPointContainer,
                                 (void **) &pConnectionPointContainer);
    if (FAILED(sc))
    {
        LogError( "IRowset->QI for IConnectionPointContainer failed: 0x%x\n",
                sc );
        pRowset->Release();
        Fail();
    }

    //
    // Make a connection point from the connection point container
    //

    sc = pConnectionPointContainer->FindConnectionPoint(
             IID_IDBAsynchNotify,
             &pConnectionPoint);

    if (FAILED(sc) && CONNECT_E_NOCONNECTION != sc )
    {
        LogError( "FindConnectionPoint failed: 0x%x\n",sc );
        pRowset->Release();
        Fail();
    }

    pConnectionPointContainer->Release();

    if (0 != pConnectionPoint)
    {
        //
        // Give a callback object to the connection point
        //

        sc = pConnectionPoint->Advise((IUnknown *) &Notify,
                                      &dwAdviseID);
        if (FAILED(sc))
        {
            LogError( "IConnectionPoint->Advise failed: 0x%x\n",sc );
            pConnectionPoint->Release();
            pRowset->Release();
            Fail();
        }
    }
#endif // DO_NOTIFICATION

    do
    {
#if defined( DO_NOTIFICATION )
       fDone = Notify.IsComplete( );
#else // ! defined( DO_NOTIFICATION )
        ULONG ulDen,ulNum,ulPhase;
        sc = pRowsetAsynch->GetStatus( DB_NULL_HCHAPTER, DBASYNCHOP_OPEN,
                                       &ulNum, &ulDen, &ulPhase, 0 );

        if ( FAILED( sc ) )
        {
            LogError( "IDBAsynchStatus::GetStatus returned 0x%lx\n", sc );
            break;
        }

        fDone = (ulDen == ulNum);

        if ( fDone   && ulPhase != DBASYNCHPHASE_COMPLETE ||
             ! fDone && ulPhase != DBASYNCHPHASE_POPULATION )
        {
            LogError( "IDBAsynchStatus::GetStatus returned invalid ulPhase %d\n", ulPhase );
            break;
        }
#endif // DO_NOTIFICATION

        if (fDone)
            break;

        if ( !CheckTime() )
        {
            LogError( "\nQuery took too long to complete.\n" );
            break;
        }

        if (! fQuiet)
            LogProgress( "." );
        Sleep( ulSleep );
#if 1
        ulSleep *= 2;
        if (ulSleep > MAXWAITTIME * 1000)
            ulSleep = MAXWAITTIME * 1000;
#else
        ulSleep = 500;
#endif

    } while ( ! fDone );

#if defined( DO_NOTIFICATION )
    if ( 0 != pConnectionPoint )
    {
        //
        // Clean up notification stuff
        //

        sc = pConnectionPoint->Unadvise(dwAdviseID);

        if (S_OK != sc)
        {
            LogError( "IConnectionPoint->Unadvise returned 0x%lx\n",sc);
            pRowset->Release();
            Fail();
        }

        pConnectionPoint->Release();
        //Notify.Release();
    }
#endif // DO_NOTIFICATION
    pRowsetAsynch->Release();

    if (fVerbose && !fQuiet)
    {
        //
        // Was it a long-running query?  If so, report how long.
        //
        time_t tend;
        time( &tend );

        if ( difftime( tend, tstart ) >= MINREPORTTIME )
            LogProgress( "Query took %d seconds to complete.",
                        (LONG)difftime(tend, tstart) );
        LogProgress("\n");
    }
    return fDone;
} //WaitForCompletion

//+-------------------------------------------------------------------------
//
//  Function:   Delnode, private
//
//  Synopsis:   Deletes a directory recursively.
//
//  Arguments:  [wcsDir] -- Directory to kill
//
//  Returns:    ULONG - error code if failure
//
//  History:    22-Jul-92 KyleP     Created
//              06 May 1995 AlanW   Made recursive, and more tolerant of
//                                  errors in case of interactions with
//                                  CI filtering.
//
//--------------------------------------------------------------------------

ULONG Delnode( WCHAR const * wcsDir )
{
    WIN32_FIND_DATA finddata;
    WCHAR wcsBuffer[MAX_PATH];

    wcscpy( wcsBuffer, wcsDir );
    wcscat( wcsBuffer, L"\\*.*" );

    HANDLE hFindFirst = FindFirstFile( wcsBuffer, &finddata );

    while( hFindFirst != INVALID_HANDLE_VALUE )
    {
        //
        // Look for . and ..
        //

        if ( ! (finddata.cFileName[0] == '.' &&
               (finddata.cFileName[1] == 0 ||
                 (finddata.cFileName[1] == '.' &&
                   finddata.cFileName[2] == 0 ) ) ) )
        {
            wcscpy( wcsBuffer, wcsDir );
            wcscat( wcsBuffer, L"\\");
            wcscat( wcsBuffer, finddata.cFileName );

            if ( finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                Delnode( wcsBuffer);
            else if ( !DeleteFile( wcsBuffer ) )
            {
                ULONG ulFailure = GetLastError();
                LogError("Error 0x%lx deleting %ws\n", ulFailure, wcsBuffer);
                return (ulFailure == 0) ? 0xFFFFFFFF : ulFailure;
            }
        }

        if ( !FindNextFile( hFindFirst, &finddata ) )
        {
            FindClose( hFindFirst );
            break;
        }
    }

    RemoveDirectory( (WCHAR *)wcsDir );

    // if racing with CI Filtering, retry after a short time
    if (GetLastError() == ERROR_DIR_NOT_EMPTY)
    {
        Sleep(2 * 1000);
        RemoveDirectory( (WCHAR *)wcsDir );
    }

    //
    // Make sure it's removed.
    //

    if ( FindFirstFile( (WCHAR *)wcsDir, &finddata ) != INVALID_HANDLE_VALUE )
    {
        ULONG ulFailure = GetLastError();
        LogError("Error 0x%lx removing directory %ws\n", ulFailure, wcsDir);
        return (ulFailure == 0) ? 0xFFFFFFFF : ulFailure;
    }
    return 0;
} //Delnode


//+-------------------------------------------------------------------------
//
//  Function:   BuildFile, private
//
//  Synopsis:   Creates a file and fills it with data.
//
//  Arguments:  [wcsFile] -- Path to file.
//              [data]    -- Contents of file.
//              [cb]      -- Size in bytes of [data]
//
//  History:    22-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

void BuildFile( WCHAR const * wcsFile, char const * data, ULONG cb )
{
    ULONG mode = CREATE_NEW;

    HANDLE hFile = CreateFile( (WCHAR *)wcsFile,
                               GENERIC_WRITE,
                               0,
                               0,
                               mode,
                               0,
                               0 );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        LogError( "Error 0x%lx opening file %ws\n", GetLastError(), wcsFile );
        CantRun();
    }

    ULONG ulWritten;

    if ( !WriteFile( hFile, data, cb, &ulWritten, 0 ) ||
         ulWritten != cb )
    {
        LogError( "Error 0x%lx writing file %ws\n", GetLastError(), wcsFile );
        CantRun();
    }

    if ( !CloseHandle( hFile ) )
    {
        LogError( "Error 0x%lx closing file %ws\n", GetLastError(), wcsFile );
        CantRun();
    }
} //BuildFile


//+-------------------------------------------------------------------------
//
//  Function:   CantRun, private
//
//  Synopsis:   Prints a "Can't Run" message and exits.
//
//  History:    09 Oct 1995   Alanw     Created
//
//--------------------------------------------------------------------------

void CantRun()
{
    printf( "%s: CAN'T RUN\n", ProgName );
    if (! _isatty(_fileno(stdout)) )
        fprintf( stderr, "%s: CAN'T RUN\n", ProgName );

//  CIShutdown();
    CoUninitialize();
    exit( 2 );
} //Fail


//+-------------------------------------------------------------------------
//
//  Function:   Fail, private
//
//  Synopsis:   Prints a failure message and exits.
//
//  History:    22-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

void Fail()
{
    printf( "%s: FAILED\n", ProgName );
    if (! _isatty(_fileno(stdout)) )
        fprintf( stderr, "%s: FAILED\n", ProgName );

//  CIShutdown();
    CoUninitialize();
    exit( 1 );
} //Fail



//+-------------------------------------------------------------------------
//
//  Function:   LogProgress, public
//
//  Synopsis:   Prints a verbose-mode message.
//
//  Arguments:  [pszfmt] -- Format string
//
//  History:    13-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

void LogProgress( char const * pszfmt, ... )
{
    if ( fVerbose )
    {
        va_list pargs;

        va_start(pargs, pszfmt);
        vprintf( pszfmt, pargs );
        va_end(pargs);
    }
} //LogProgress


//+-------------------------------------------------------------------------
//
//  Function:   LogError, public
//
//  Synopsis:   Prints a verbose-mode message.
//
//  Arguments:  [pszfmt] -- Format string
//
//  History:    13-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

static fLogError = TRUE;

void LogError( char const * pszfmt, ... )
{
    if ( fVerbose || fLogError )
    {
        fLogError = FALSE;      // print only first error if non-verbose

        va_list pargs;

        va_start(pargs, pszfmt);
        vprintf( pszfmt, pargs );
        va_end(pargs);
    }
} //LogError

//+-------------------------------------------------------------------------
//
//  Function:   LogFail, public
//
//  Synopsis:   Prints a verbose-mode message and fails the drt
//
//  Arguments:  [pszfmt] -- Format string
//
//  History:    3-Apr-95 dlee     Created
//
//--------------------------------------------------------------------------

void LogFail( char const * pszfmt, ... )
{
    if ( fVerbose || fLogError )
    {
        va_list pargs;

        va_start(pargs, pszfmt);
        vprintf( pszfmt, pargs );
        va_end(pargs);
    }

    Fail();
} //LogFail


//+-------------------------------------------------------------------------
//
//  Function:   FormatGuid, public
//
//  Synopsis:   Formats a guid in standard form
//
//  Arguments:  [pszfmt] -- Format string
//
//  Returns:    PWSTR - pointer to formatted guid
//
//  Notes:      Return value points to static memory.
//
//  History:    12 Sep 1997  AlanW     Created
//
//--------------------------------------------------------------------------

WCHAR * FormatGuid( GUID const & guid )
{
    static WCHAR awchGuid[40];
    StringFromGUID2( guid, awchGuid, sizeof awchGuid / sizeof WCHAR );
    return awchGuid;
} //FormatGuid


BOOL CheckTime()
{
    if ( fTimeout )
    {
        time_t tend;

        //
        // Did we run out of time?
        //

        time( &tend );

        return ( difftime( tend, tstart ) <= MAXTIME );

    }
    else
    {
        return( TRUE );
    }
} //CheckTime

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#if defined(UNIT_TEST)

//+-------------------------------------------------------------------------
//
//  Class:      CCompareDBValues
//
//  Purpose:    Compares oledb values.
//
//  History:    25-May-95 dlee     Created
//
//--------------------------------------------------------------------------

class CCompareDBValues : INHERIT_UNWIND
{
    INLINE_UNWIND( CCompareDBValues )

public:

    CCompareDBValues() : _aColComp( 0 ), _cColComp( 0 )
        { END_CONSTRUCTION( CCompareDBValues ); }

    ~CCompareDBValues() { delete _aColComp; }

    void Init( int              cCols,
               CSortSet const * psort,
               DBTYPEENUM *     aTypes );

    inline BOOL IsEmpty() { return( _aColComp == 0 ); }

    BOOL IsLT( BYTE ** rows1, ULONG *acb1, BYTE **rows2, ULONG *acb2 );
    BOOL IsGT( BYTE ** rows1, ULONG *acb1, BYTE **rows2, ULONG *acb2 );
    BOOL IsEQ( BYTE ** rows1, ULONG *acb1, BYTE **rows2, ULONG *acb2 );

private:

    struct SColCompare
    {
        ULONG _dir;                     // Direction
        ULONG _pt;                      // Property type (matches fns below)

        //
        // LE/GE are a bit of a misnomer.  If the sort order for a column
        // is reversed ( large to small ) then LE is really GE and
        // vice-versa.
        //

        FDBCmp _comp;
        int _DirMult;                   // -1 if directions reversed.
    };

    UINT          _cColComp;
    SColCompare * _aColComp;
};

//+-------------------------------------------------------------------------
//
//  Member:     CCompareDBValues::Init, public
//
//  Synopsis:   [Re] Initializes property comparator to use a different
//              sort order.
//
//  Arguments:  [cCols]     -- Count of columns
//              [pSort]     -- Sort keys
//              [aTypes]    -- Data types of each column to be compared
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

void CCompareDBValues::Init( int              cCols,
                             CSortSet const * pSort,
                             DBTYPEENUM *     aTypes )
{
    delete _aColComp;
    _aColComp = 0;

    if ( cCols > 0 )
    {
        _cColComp = cCols;
        _aColComp = new SColCompare[ _cColComp ];

        for ( unsigned i = 0; i < _cColComp; i++ )
        {
            _aColComp[i]._dir = pSort->Get(i).dwOrder;
            _aColComp[i]._DirMult =
                ( ( _aColComp[i]._dir & QUERY_SORTDESCEND ) != 0 ) ? -1 : 1;
            _aColComp[i]._pt = aTypes[i];
            _aColComp[i]._comp = VariantCompare.GetDBComparator( aTypes[i] );
        }
    }
} //Init

//+-------------------------------------------------------------------------
//
//  Member:     CCompareDBValues::IsLT, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if [row1] < [row2].
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

BOOL CCompareDBValues::IsLT(
    BYTE ** row1,
    ULONG * acb1,
    BYTE ** row2,
    ULONG * acb2 )
{
    //Win4Assert( !IsEmpty() );

    int iLT = 0;

    for ( unsigned i = 0; 0 == iLT && i < _cColComp; i++ )
    {
        if ( 0 != _aColComp[i]._comp )
            iLT = _aColComp[i]._comp( row1[i],
                                      acb1[i],
                                      row2[i],
                                      acb2[i] ) *
                  _aColComp[i]._DirMult;
        else
            LogFail("islt has no comparator!\n");
    }

    return ( iLT < 0 );
} //IsLT

//+-------------------------------------------------------------------------
//
//  Member:     CCompareDBValues::IsGT, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if [row1] > [row2].
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

BOOL CCompareDBValues::IsGT(
    BYTE ** row1,
    ULONG * acb1,
    BYTE ** row2,
    ULONG * acb2 )
{
    //Win4Assert( !IsEmpty() );

    int iGT = 0;

    for ( unsigned i = 0; 0 == iGT && i < _cColComp; i++ )
    {
        if ( 0 != _aColComp[i]._comp )
            iGT = _aColComp[i]._comp( row1[i],
                                      acb1[i],
                                      row2[i],
                                      acb2[i] ) *
                  _aColComp[i]._DirMult;
    }

    return ( iGT > 0 );
} //IsGT

//+-------------------------------------------------------------------------
//
//  Member:     CCompareDBValues::IsEQ, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if [row1] == [row2].
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

BOOL CCompareDBValues::IsEQ(
    BYTE ** row1,
    ULONG * acb1,
    BYTE ** row2,
    ULONG * acb2 )
{
    //Win4Assert( !IsEmpty() );

    int iEQ = 0;

    for ( unsigned i = 0; 0 == iEQ && i < _cColComp; i++ )
    {
        if ( 0 != _aColComp[i]._comp )
            iEQ = _aColComp[i]._comp( row1[i],
                                      acb1[i],
                                      row2[i],
                                      acb2[i] );
    }

    return ( iEQ == 0 );
} //IsEQ

struct SSortTestRow
{
    PROPVARIANT vI4;             // variant:  i4
    PROPVARIANT vV_I4;           // variant:  i4 vector
    DBVECTOR    aI4;             // dbvector: i4
    WCHAR       aWSTR[20];       // inline:   wstr
    WCHAR *     pWSTR;           // inline:   byref wstr
    PROPVARIANT vLPWSTR;         // variant:  lpwstr
    PROPVARIANT vV_LPWSTR;       // variant:  lpwstr vector
    DBVECTOR    aLPWSTR;         // dbvector: byref wstr
    int         i;               // inline:   i4
};

long ai4[] = { 3, 7, 9 };
LPWSTR alpwstr[] = { L"one", L"two", L"three" };

void InitTest( SSortTestRow &s )
{
    s.vI4.vt = VT_I4;
    s.vI4.lVal = 4;

    s.vV_I4.vt = VT_VECTOR | VT_I4;
    s.vV_I4.cal.cElems = 3;
    s.vV_I4.cal.pElems = ai4;

    s.aI4.size = 3;
    s.aI4.ptr = ai4;

    s.aWSTR[0] = L'h';
    s.aWSTR[1] = L'e';
    s.aWSTR[2] = L'l';

    s.pWSTR = L"yello";

    s.vLPWSTR.vt = VT_LPWSTR;
    s.vLPWSTR.pwszVal = L"green";

    s.vV_LPWSTR.vt = VT_VECTOR | VT_LPWSTR;
    s.vV_LPWSTR.calpwstr.cElems = 3;
    s.vV_LPWSTR.calpwstr.pElems = alpwstr;

    s.aLPWSTR.size = 3;
    s.aLPWSTR.ptr = alpwstr;
} //InitTest

SSortTestRow sr1,sr2,sr3;

BYTE * apr1[] =
{
    { (BYTE *) & sr1.vI4 },
    { (BYTE *) & sr1.vV_I4 },
    { (BYTE *) & sr1.aI4 },
    { (BYTE *) & sr1.aWSTR },
    { (BYTE *) & sr1.pWSTR },
    { (BYTE *) & sr1.vLPWSTR },
    { (BYTE *) & sr1.vV_LPWSTR },
    { (BYTE *) & sr1.aLPWSTR },
    { (BYTE *) & sr1.i },
};

BYTE * apr2[] =
{
    { (BYTE *) & sr2.vI4 },
    { (BYTE *) & sr2.vV_I4 },
    { (BYTE *) & sr2.aI4 },
    { (BYTE *) & sr2.aWSTR },
    { (BYTE *) & sr2.pWSTR },
    { (BYTE *) & sr2.vLPWSTR },
    { (BYTE *) & sr2.vV_LPWSTR },
    { (BYTE *) & sr2.aLPWSTR },
    { (BYTE *) & sr2.i },
};

BYTE * apr3[] =
{
    { (BYTE *) & sr3.vI4 },
    { (BYTE *) & sr3.vV_I4 },
    { (BYTE *) & sr3.aI4 },
    { (BYTE *) & sr3.aWSTR },
    { (BYTE *) & sr3.pWSTR },
    { (BYTE *) & sr3.vLPWSTR },
    { (BYTE *) & sr3.vV_LPWSTR },
    { (BYTE *) & sr3.aLPWSTR },
    { (BYTE *) & sr3.i },
};

DBTYPEENUM aEnum[] =
{
    { DBTYPE_VARIANT },
    { DBTYPE_VARIANT },
    { (DBTYPEENUM) (DBTYPE_VECTOR | DBTYPE_I4) },
    { DBTYPE_WSTR },
    { (DBTYPEENUM) (DBTYPE_BYREF | DBTYPE_WSTR) },
    { DBTYPE_VARIANT },
    { DBTYPE_VARIANT },
    { (DBTYPEENUM) (DBTYPE_VECTOR | DBTYPE_BYREF | DBTYPE_WSTR) },
    { DBTYPE_I4 },
};

ULONG aLen[] =
{
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
};

const ULONG cArray = sizeof aEnum / sizeof DBTYPEENUM;

void DBSortTest()
{
    InitTest( sr1 );
    sr1.i = 1;

    InitTest( sr2 );
    sr2.i = 2;

    InitTest( sr3 );
    sr3.i = 3;

    CSortSet ss( cArray );

    SSortKey sk = { 0, 0, 0 };

    for (unsigned x = 0; x < cArray; x++)
        ss.Add( sk, x );

    CCompareDBValues c;

    c.Init( cArray, &ss, aEnum );

    BOOL fLT = c.IsLT( apr1, aLen, apr2, aLen );

    if (!fLT)
        LogFail("compare test 1 failed\n");

    fLT = c.IsLT( apr2, aLen, apr1, aLen );

    if (fLT)
        LogFail("compare test 2 failed\n");


} //DBSortTest

#endif // UNIT_TEST


BOOL SetBooleanProperty ( ICommand * pCmd, DBPROPID dbprop, VARIANT_BOOL f )
{
    ICommandProperties * pCmdProp;

    SCODE sc = pCmd->QueryInterface( IID_ICommandProperties, (void **) &pCmdProp );

    if ( FAILED( sc ) )
    {
         LogError( "Error 0x%x from QI for ICommandProperties\n", sc );
         return sc;
    }

    DBPROPSET  aPropSet[1];
    DBPROP     aProp[1];

    aProp[0].dwPropertyID   = dbprop;
    aProp[0].dwOptions      = DBPROPOPTIONS_REQUIRED;
    aProp[0].dwStatus       = 0;         // Ignored
    aProp[0].colid          = dbcolNull;
    aProp[0].vValue.vt      = VT_BOOL;
    aProp[0].vValue.boolVal = f;

    aPropSet[0].rgProperties = &aProp[0];
    aPropSet[0].cProperties = 1;
    aPropSet[0].guidPropertySet = DBPROPSET_ROWSET;

    sc = pCmdProp->SetProperties( 1, aPropSet );
    pCmdProp->Release();

    if ( FAILED(sc) )
        LogError( "ICommandProperties::SetProperties returned 0x%x\n", sc );

    return sc;
}


SCODE SetScopeProperties( ICommand * pCmd,
                          unsigned cDirs,
                          WCHAR const * const * apDirs,
                          ULONG const *  aulFlags,
                          WCHAR const * const * apCats,
                          WCHAR const * const * apMachines )
{
    ICommandProperties * pCmdProp;

    SCODE sc = pCmd->QueryInterface( IID_ICommandProperties, (void **) &pCmdProp );

    if ( FAILED( sc ) )
    {
         LogError( "Error 0x%x from QI for ICommandProperties\n", sc );
         return sc;
    }

    BSTR abDirs[10];
    if ( 0 != apDirs )
        for ( unsigned i = 0; i < cDirs; i++ )
            abDirs[i] = SysAllocString( apDirs[i] );

    BSTR abCats[10];
    if ( 0 != apCats )
        for ( unsigned i = 0; i < cDirs; i++ )
            abCats[i] = SysAllocString( apCats[i] );

    BSTR abMachines[10];
    if ( 0 != apMachines )
        for ( unsigned i = 0; i < cDirs; i++ )
            abMachines[i] = SysAllocString( apMachines[i] );

    //
    // Cheating here.  Big time. These aren't really BSTRs, but I also know the
    // size before the string won't be referenced.  By ::SetProperties.
    //

    SAFEARRAY saScope = { 1,                      // Dimension
                          FADF_AUTO | FADF_BSTR,  // Flags: on stack, contains BSTRs
                          sizeof(BSTR),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)abDirs,         // The data
                          { cDirs, 0 } };         // Bounds (element count, low bound)

    SAFEARRAY saDepth = { 1,                      // Dimension
                          FADF_AUTO,              // Flags: on stack
                          sizeof(LONG),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)aulFlags,       // The data
                          { cDirs, 0 } };         // Bounds (element count, low bound)

    SAFEARRAY saCatalog = { 1,                    // Dimension
                            FADF_AUTO | FADF_BSTR,// Flags: on stack, contains BSTRs
                            sizeof(BSTR),         // Size of an element
                            1,                    // Lock count.  1 for safety.
                            (void *)abCats,       // The data
                            { cDirs, 0 } };       // Bounds (element count, low bound)

    SAFEARRAY saMachine = { 1,                    // Dimension
                            FADF_AUTO | FADF_BSTR,// Flags: on stack, contains BSTRs
                            sizeof(BSTR),         // Size of an element
                            1,                    // Lock count.  1 for safety.
                            (void *)abMachines,   // The data
                            { cDirs, 0 } };       // Bounds (element count, low bound)

    DBPROP    aQueryPropsScopeOnly[2] = { { DBPROP_CI_INCLUDE_SCOPES, 0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saScope } },
                                          { DBPROP_CI_DEPTHS        , 0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_I4   | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saDepth } } };

    DBPROPSET QueryPropsetScopeOnly = { aQueryPropsScopeOnly, 2, DBPROPSET_FSCIFRMWRK_EXT };

    DBPROP    aQueryProps[3] = { { DBPROP_CI_INCLUDE_SCOPES ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saScope } },
                                 { DBPROP_CI_DEPTHS         ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_I4   | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saDepth } },
                                 { DBPROP_CI_CATALOG_NAME   ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saCatalog } } };


    DBPROP    aCoreProps[1]  = { { DBPROP_MACHINE ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saMachine } } };

    DBPROPSET aAllPropsets[2] = {  {aQueryProps, 3, DBPROPSET_FSCIFRMWRK_EXT   } ,
                                   {aCoreProps , 1, DBPROPSET_CIFRMWRKCORE_EXT } };

    if ( 0 == apCats || 0 == apMachines )
        sc = pCmdProp->SetProperties( 1, &QueryPropsetScopeOnly );
    else
        sc = pCmdProp->SetProperties( 2, aAllPropsets );

    if ( 0 != apMachines )
        for ( unsigned i = 0; i < cDirs; i++ )
            SysFreeString( abMachines[i] );

    if ( 0 != apCats )
        for ( unsigned i = 0; i < cDirs; i++ )
            SysFreeString( abCats[i] );

    if ( 0 != apDirs )
        for ( unsigned i = 0; i < cDirs; i++ )
            SysFreeString( abDirs[i] );

    pCmdProp->Release();

    if ( FAILED(sc) )
        LogError( "ICommandProperties::SetProperties returned 0x%x\n", sc );

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\txtfilt\tfilt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2001.
//
//  File:       TFILT.CXX
//
//  Contents:   Text Filter
//
//  History:    16-Jul-93   AmyA        Created
//              23-Feb-94   KyleP       Cleaned up
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <scode.h>
#include <tfilt.hxx>
#include <pfilter.hxx>
#include <codepage.hxx>

// has to be COMMON_PAGE_SIZE multiple
const ULONG TEXT_FILTER_CHUNK_SIZE = 1 * COMMON_PAGE_SIZE;

GUID const guidStorage  = PSGUID_STORAGE;

extern "C" GUID CLSID_CTextIFilter;

extern ULONG g_cbMaxTextFilter;

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::CTextIFilter, public
//
//  Synopsis:   Constructor
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CTextIFilter::CTextIFilter( LCID locale )
        : _idChunk(1),
          _bytesReadFromChunk(0),
          _pwszFileName(0),
          _pStream(0),
          _fUniCode(FALSE),
          _fBigEndian(FALSE),
          _fContents(FALSE),
          _fNSS(FALSE),
          _locale(locale),
          _fDBCSSplitChar(FALSE)
{
    //
    // We need a code page for MultiByteToWideChar.
    //
    _ulCodePage = LocaleToCodepage( locale );

    _fDBCSCodePage = IsDBCSCodePage( _ulCodePage );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::~CTextIFilter, public
//
//  Synopsis:   Destructor
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CTextIFilter::~CTextIFilter()
{
    delete [] _pwszFileName;

    if ( 0 != _pStream )
        _pStream->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Init, public
//
//  Synopsis:   Initializes instance of text filter
//
//  Arguments:  [grfFlags]    -- Flags for filter behavior
//              [cAttributes] -- Number of strings in array ppwcsAttributes
//              [aAttributes] -- Array of attribute strings
//              [pFlags]      -- Must be zero for Cairo V1
//
//  History:    16-Jul-93   AmyA           Created.
//              23-Feb-94   KyleP          Cleaned up.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Init( ULONG grfFlags,
                                            ULONG cAttributes,
                                            FULLPROPSPEC const * aAttributes,
                                            ULONG * pFlags )
{
    SCODE sc = S_OK;

    //
    // Text files only support the 'contents' attribute.
    //

    if( cAttributes > 0 )
    {
        //
        // Known, safe cast
        //

        CFullPropSpec const * pAttrib = (CFullPropSpec const *)aAttributes;

        if ( pAttrib == 0 )
            return E_FAIL;

        for ( ULONG i = 0; i < cAttributes; i++ )
        {
            if ( pAttrib[i].IsPropertyPropid() &&
                 pAttrib[i].GetPropertyPropid() == PID_STG_CONTENTS &&
                 memcmp( &pAttrib[i].GetPropSet(),
                         &guidStorage,
                         sizeof(guidStorage) ) == 0 )
            {
                break;
            }
        }

        if ( i < cAttributes )
            _fContents = TRUE;
        else
            _fContents = FALSE;
    }
    else if ( 0 == grfFlags || (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES) )
    {
        _fContents = TRUE;
    }
    else
        _fContents = FALSE;

    //
    // Open memory-mapped file
    //

    if ( 0 != _pwszFileName )
    {
        if ( _mmStream.Ok() )
        {
            _mmStreamBuf.Rewind();
        }
        else
        {
            if ( !_fNSS )
            {
                TRY
                {
                    _mmStreamBuf.Rewind();
                    _mmStream.Close();
                    _mmStream.Open( _pwszFileName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    OPEN_EXISTING );

                    if ( _mmStream.Ok() )
                        _mmStreamBuf.Init( &_mmStream );
                    else
                    {
                        sc = ( STATUS_ACCESS_DENIED == GetLastError() ?   // Open sets the last error
                               FILTER_E_PASSWORD :
                               FILTER_E_ACCESS );
                    }
                }
                CATCH( CException, e )
                {
                    if ( e.GetErrorCode() == HRESULT_FROM_WIN32( ERROR_BAD_EXE_FORMAT ) )
                    {
                        _fNSS = TRUE;
                        sc = S_OK;
                    }
                    else
                    {
                        sc = ( STATUS_ACCESS_DENIED == e.GetErrorCode() ?
                               FILTER_E_PASSWORD :
                               FILTER_E_ACCESS );
                    }
                }
                END_CATCH;
            }
        }
    }

    //
    // ...or, Memory mapped stream
    //

    else if ( 0 != _pStream )
    {
        if ( _mmIStream.Ok() )
        {
            _mmStreamBuf.Rewind();
        }
        else
        {
            TRY
            {
                _mmIStream.Close();
                _mmIStream.Open( _pStream );

                if ( _mmIStream.Ok() )
                    _mmStreamBuf.Init( &_mmIStream );
                else
                {
                    sc = ( STG_E_ACCESSDENIED == GetLastError() ?
                           FILTER_E_PASSWORD :
                           FILTER_E_ACCESS );
                }
            }
            CATCH( CException, e )
            {
                sc = ( STG_E_ACCESSDENIED == e.GetErrorCode() ?
                       FILTER_E_PASSWORD :
                       FILTER_E_ACCESS );
            }
            END_CATCH;
        }
    }

    //
    // Might as well try filtering properties.
    //

    *pFlags = IFILTER_FLAGS_OLE_PROPERTIES;

    //
    // Re-initialize
    //

    _idChunk = 1;
    _bytesReadFromChunk = 0;
    _fDBCSSplitChar = FALSE;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetChunk, public
//
//  Synopsis:   Gets the next chunk and returns chunk information in ppStat
//
//  Arguments:  [ppStat] -- for chunk information
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetChunk( STAT_CHUNK * pStat )
{
    //
    // Error checking
    //

    if ( _fNSS )
        return FILTER_E_END_OF_CHUNKS;

    if ( (IsFileBased() && !_mmStream.Ok()) ||
         (IsStreamBased() && !_mmIStream.Ok()) )
        return FILTER_E_ACCESS;

    if ( !_fContents || _mmStreamBuf.Eof() )
        return FILTER_E_END_OF_CHUNKS;

    // Is the file to big?  If so, stop filtering now

    if ( (ULONGLONG) _mmStreamBuf.CurrentOffset() > (ULONGLONG) g_cbMaxTextFilter )
        return FILTER_E_PARTIALLY_FILTERED;

    SCODE sc = S_OK;

    TRY
    {
        _mmStreamBuf.Map( TEXT_FILTER_CHUNK_SIZE );
    }
    CATCH( CException, e )
    {
        return FILTER_E_ACCESS;
    }
    END_CATCH;

    _bytesReadFromChunk = 0;

    //
    // If this is the first time we've touched the file, determine if it
    // is a UniCode or ASCII stream.  The first two bytes of all UniCode
    // plain text streams are 0xff 0xfe
    //

    WCHAR const wcUniCode = 0xfeff;
    WCHAR const wcBigUniCode = 0xfffe;

    if ( _idChunk == 1 )
    {
        //
        // Are there at least two bytes in file?
        //

        if ( _mmStreamBuf.Size() >= 2 )
        {
            if ( *(WCHAR *)(_mmStreamBuf.Get()) == wcUniCode &&
                 _mmStreamBuf.Size() % sizeof(WCHAR) == 0 )
            {
                _fUniCode = TRUE;
                _bytesReadFromChunk += sizeof(WCHAR);
            }
            else if ( *(WCHAR *)(_mmStreamBuf.Get()) == wcBigUniCode &&
                 _mmStreamBuf.Size() % sizeof(WCHAR) == 0 )
            {
                _fUniCode = TRUE;
                _fBigEndian = TRUE;
                _bytesReadFromChunk += sizeof(WCHAR);
            }
            else
                _fUniCode = FALSE;
        }
        else
            _fUniCode = FALSE;
    }

    pStat->idChunk = _idChunk;
    pStat->flags   = CHUNK_TEXT;
    pStat->locale  = _locale;
    pStat->attribute.guidPropSet = guidStorage;
    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
    pStat->breakType = CHUNK_NO_BREAK;
    pStat->idChunkSource = _idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

    _idChunk++;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetText, public
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//  History:    16-Jul-93       AmyA            Created.
//              30-Aug-94       Bartoszm        Rewrote
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetText( ULONG * pcwcOutput,
                                               WCHAR * awcOutput )
{
    if ( 0 == awcOutput || 0 == pcwcOutput )
    { 
        return E_INVALIDARG;  
    }

    if ( !_fContents || _fNSS )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    if ( 0 == *pcwcOutput )
    { 
        if ( _bytesReadFromChunk == _mmStreamBuf.Size() )
        {
            return FILTER_E_NO_MORE_TEXT;
        }

        if ( _fUniCode )
        {
            ULONG ccInput = _mmStreamBuf.Size() - _bytesReadFromChunk;
            ccInput /= sizeof(WCHAR);

            //
            // Handle bogus Unicode file with an odd byte count.
            //

            if ( 0 == ccInput )
            {
                return FILTER_E_NO_MORE_TEXT;
            }
        }
        
        return S_OK;
    }

    if ( _fDBCSSplitChar )
    {
        //
        // Convert DBCS lead byte from the previous mapping and the trail byte (first
        // char) from this mapping to Unicode
        //
        Win4Assert( IsDBCSLeadByteEx( _ulCodePage, _abDBCSInput[0] ) );

        _abDBCSInput[1] = * (BYTE *) _mmStreamBuf.Get();

        if ( 1 == *pcwcOutput )
        {
            //
            // In the DBCS case, output buffer must be bigger than one byte
            //
            return E_INVALIDARG;
        }

        ULONG cwcActual = MultiByteToWideChar( _ulCodePage,
                                               0,
                                               (char *) _abDBCSInput,
                                               2,
                                               awcOutput,
                                               *pcwcOutput );
        if ( cwcActual == 0 )
        {
            //
            // Input buffer is 2 bytes, and output buffer is 2k, hence there
            // should be ample space
            //
            Win4Assert( GetLastError() != ERROR_INSUFFICIENT_BUFFER );

            return E_FAIL;
        }

        *pcwcOutput = cwcActual;
        _bytesReadFromChunk = 1;
        _fDBCSSplitChar = FALSE;

        return S_OK;
    }

    if ( _bytesReadFromChunk == _mmStreamBuf.Size() )
        _fDBCSSplitChar = FALSE;
    else
    {
        _fDBCSSplitChar = _fDBCSCodePage
                          && _bytesReadFromChunk == _mmStreamBuf.Size() - 1
                          && IsDBCSLeadByteEx( _ulCodePage,
                                               *( (BYTE *) _mmStreamBuf.Get()
                                                     + _bytesReadFromChunk ) );
    }

    if ( _bytesReadFromChunk == _mmStreamBuf.Size()
         || _fDBCSSplitChar )
    {
        if ( _fDBCSSplitChar )
        {
            //
            // Store the DBCS lead byte for conversion as part of next chunk.
            // This works across chunks because the chunks are emitted
            // with CHUNK_NO_BREAK break type.
            //
            _abDBCSInput[0] = *( (BYTE *) _mmStreamBuf.Get()
                                             + _bytesReadFromChunk );
        }

        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    Win4Assert( _mmStreamBuf.Size() >= _bytesReadFromChunk );

    SCODE sc = S_OK;
    ULONG ccInput = _mmStreamBuf.Size() - _bytesReadFromChunk;
    BYTE* pbInput = (BYTE*) _mmStreamBuf.Get() + _bytesReadFromChunk;
    ULONG cwcOutput = *pcwcOutput; // size of the output buffer

    if ( _fUniCode )
    {
        ccInput /= sizeof(WCHAR);

        //
        // Handle bogus Unicode file with an odd byte count.
        //

        if ( 0 == ccInput )
        {
            *pcwcOutput = 0;
            return FILTER_E_NO_MORE_TEXT;
        }
    }

    //
    // ASCII text must be converted to UniCode.
    // UniCode text must be folded into pre-composed characters
    // There is no guarantee about how many UniCode characters it takes
    // to represent a single multi-byte character.  Most of the time, it
    // takes 1 UniCode character to represent 1 ASCII character.
    //
    // MultiByteToWideChar returns 0 and sets LastError to
    // ERROR_INSUFFICIENT_BUFFER if all characters in the input buffer cannot
    // be translated in the output space provided.
    //
    // We'll assume a fairly optimistic target count of 1:1 translations
    // (7/8 of all characters) and deal with the overflow when it occurs.
    //

    // Let's try to convert this many characters from the input buffer

    ULONG cInputChar = 1 + cwcOutput / 2 + cwcOutput / 4 + cwcOutput / 8;


    //
    // Don't overflow
    //

    if (cInputChar > ccInput)
        cInputChar = ccInput;

    //
    // Translate
    //

    ULONG cwcActual = 0;

    do
    {
        if ( _fUniCode )
        {
            if ( _fBigEndian )
            {
                TRY
                {
                    XArray<WCHAR> xTmp( cInputChar );

                    for ( ULONG i = 0; i < cInputChar; i++ )
                        xTmp[i] = MAKEWORD( pbInput[ sizeof WCHAR * i + 1 ],
                                            pbInput[ sizeof WCHAR * i ] );

                    cwcActual = FoldStringW( MAP_PRECOMPOSED,
                                             xTmp.GetPointer(),
                                             cInputChar,
                                             awcOutput,
                                             cwcOutput );

                    ciDebugOut(( DEB_ITRACE, "before %#x, after %#x\n",
                                 pbInput, awcOutput ));
                }
                CATCH( CException, e )
                {
                    sc = e.GetErrorCode();
                    break;
                }
                END_CATCH
            }
            else
            {
                cwcActual = FoldStringW( MAP_PRECOMPOSED,
                                         (WCHAR*) pbInput,
                                         cInputChar,
                                         awcOutput,
                                         cwcOutput );
            }
        }
        else
        {
            //
            // If last char is a DBCS lead byte, then don't convert the last char
            //
            if ( _fDBCSCodePage
                 && IsLastCharDBCSLeadByte( pbInput, cInputChar ) )
            {
                Win4Assert( cInputChar > 1 );
                cInputChar--;
            }

            cwcActual = MultiByteToWideChar( _ulCodePage,
                                             0,
                                             (char*) pbInput,
                                             cInputChar,
                                             awcOutput,
                                             cwcOutput);
        }

        if ( 0 == cwcActual )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                 cInputChar >= 2 )
            {
                cInputChar /= 2;
            }
            else
            {
                Win4Assert( !"Can't translate single char" );
                sc = E_FAIL;
                break;
            }
        }

    } while ( cwcActual == 0 );

    if ( SUCCEEDED(sc) )
    {
        *pcwcOutput = cwcActual;
        if ( _fUniCode )
            _bytesReadFromChunk += cInputChar * sizeof(WCHAR);
        else
            _bytesReadFromChunk += cInputChar;
    }
    else
        *pcwcOutput = 0;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetValue, public
//
//  Synopsis:   No value chunks for plain text.
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    return FILTER_E_NO_VALUES;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::BindRegion, public
//
//  Synopsis:   Creates moniker or other interface for text indicated
//
//  Arguments:  [origPos] -- the region of text to be mapped to a moniker
//              [riid]    -- Interface to bind
//              [ppunk]   -- Output pointer to interface
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::BindRegion( FILTERREGION origPos,
                                                  REFIID riid,
                                                  void ** ppunk )
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_CTextIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since this class is read-only.
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::IsDirty()
{
    return S_FALSE; // Since the filter is read-only, there will never be
                    // changes to the file.
}

//+---------------------------------------------------------------------------
//
//  Function:   WellKnownExtension
//
//  Synopsis:   Checks if the file extension is well-known to the text filter
//
//  Arguments:  [pwcFile]  -- path of the file to be checked
//
//  Returns:    TRUE if the extension is well-known by the text filter
//
//  History:    28-Jul-98   dlee         Created.
//
//----------------------------------------------------------------------------

BOOL WellKnownExtension( WCHAR const * pwcFile )
{
    //
    // All we really care about is .dic and .txt files.  Others have script
    // code that is better broken by the neutral word breaker.
    //

    const WCHAR *aKnownExt[] =
    {
        L"dic",     // MS spell-check custom word dictionary
        L"txt",
//        L"wtx",
//        L"bat",
//        L"cmd",
//        L"idq",
//        L"ini",
//        L"inx",
//        L"reg",
//        L"inf",
//        L"vbs",
    };
    
    const unsigned cKnownExt = sizeof aKnownExt / sizeof aKnownExt[0];

    WCHAR const * pwcExt = wcsrchr( pwcFile, '.' );

    if ( 0 == pwcExt )
        return FALSE;

    pwcExt++;
    unsigned cwc = wcslen( pwcExt );

    // all the entries in the array above are 3 long

    if ( 3 == cwc )
    {
        WCHAR awcExt[ 4 ];

        unsigned cwcOut = LCMapString( LOCALE_NEUTRAL,
                                       LCMAP_LOWERCASE,
                                       pwcExt,
                                       3,
                                       awcExt,
                                       3 );
    
        Win4Assert( 3 == cwcOut );
        awcExt[ 3 ] = 0;

        for ( unsigned i = 0; i < cKnownExt; i++ )
            if ( !wcscmp( awcExt, aKnownExt[i] ) )
                return TRUE;
    }

    return FALSE;
} //WellKnownExtension

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode] -- the mode to load the file in
//
//  History:    16-Jul-93   AmyA           Created.
//
//  Notes:      dwMode must be either 0 or STGM_READ.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    if ( 0 == pszFileName )
        return E_INVALIDARG;

    _fNSS = FALSE;

    if ( 0 != _pStream )
    {
        _pStream->Release();
        _pStream = 0;
        _mmIStream.Close();
    }

    if (_pwszFileName != 0)
    {
        delete _pwszFileName;
        _pwszFileName = 0;
        _mmStreamBuf.Rewind();
        _mmStream.Close();
    }

    SCODE sc = S_OK;
    unsigned cc = 0;

    TRY
    {
        //
        // If it's a file the text filter knows how to filter, use the
        // default system locale.  Otherwise, use the neutral locale.
        //

        LCID lcid = MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                              SORT_DEFAULT );

        if ( WellKnownExtension( pszFileName ) )
            lcid = GetSystemDefaultLCID();

        if ( _locale != lcid )
        {
            _locale = lcid;
            _ulCodePage = LocaleToCodepage( _locale );
            _fDBCSCodePage = IsDBCSCodePage( _ulCodePage );
        }

        cc = wcslen( pszFileName ) + 1;

        _pwszFileName = new WCHAR [cc];

        wcscpy( _pwszFileName, pszFileName );

        _mmStream.Open( _pwszFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        OPEN_EXISTING );

        if ( _mmStream.Ok() )
            _mmStreamBuf.Init( &_mmStream );
        else
            sc = ( STATUS_ACCESS_DENIED == GetLastError() ?   // Open sets the last error
                   FILTER_E_PASSWORD :
                   FILTER_E_ACCESS );
    }
    CATCH( CException, e )
    {
        if ( e.GetErrorCode() == HRESULT_FROM_WIN32( ERROR_BAD_EXE_FORMAT ) )
        {
            _fNSS = TRUE;
            sc = S_OK;
        }
        else
        {
            sc = ( STATUS_ACCESS_DENIED == e.GetErrorCode() ?
                   FILTER_E_PASSWORD :
                   FILTER_E_ACCESS );
        }
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return E_FAIL;  // cannot be saved since it is read-only
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::SaveCompleted(LPCWSTR pszFileName)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned.
//
//  History:    09-Aug-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetCurFile(LPWSTR * ppszFileName)
{
    if ( _pwszFileName == 0 )
        return E_FAIL;

    SCODE sc = S_OK;

    unsigned cc = wcslen( _pwszFileName ) + 1;
    *ppszFileName = (WCHAR *)CoTaskMemAlloc(cc*sizeof(WCHAR));

    if ( *ppszFileName )
        wcscpy( *ppszFileName, _pwszFileName );
    else
        sc = E_OUTOFMEMORY;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Load, public
//
//  Synopsis:   Loads the indicated stream
//
//  Arguments:  [pStm] -- The IStream
//
//  History:    11-Feb-97   KyleP          Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Load( IStream * pStm )
{
    if ( 0 == pStm )
        return E_INVALIDARG;

    _fNSS = FALSE;

    //
    // Close any previously open stuff.
    //

    if ( 0 != _pStream )
    {
        _pStream->Release();
        _pStream = 0;
        _mmIStream.Close();
    }

    if (_pwszFileName != 0)
    {
        delete _pwszFileName;
        _pwszFileName = 0;

        _mmStreamBuf.Rewind();
        _mmStream.Close();
    }

    //
    // Try to initialize map.
    //

    SCODE sc = S_OK;

    TRY
    {
        _pStream = pStm;
        _pStream->AddRef();

        _mmIStream.Open( pStm );

        if ( _mmIStream.Ok() )
            _mmStreamBuf.Init( &_mmIStream );
        else
        {
            sc = ( STG_E_ACCESSDENIED == GetLastError() ?
                   FILTER_E_PASSWORD :
                   FILTER_E_ACCESS );
        }
    }
    CATCH( CException, e )
    {
        sc = ( STG_E_ACCESSDENIED == e.GetErrorCode() ?
               FILTER_E_PASSWORD :
               FILTER_E_ACCESS );
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the stream is opened read-only
//
//  Arguments:  [pStm]        -- Stream
//              [fClearDirty] -- TRUE --> Clear dirty bit in stream
//
//  History:    11-Feb-97   KyleP          Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Save( IStream * pStm, BOOL fClearDirty )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetSizeMax, public
//
//  Synopsis:   Always returns E_FAIL, since the stream is opened read-only
//
//  Arguments:  [pcbSize] -- Size of stream needed to save object.
//
//  History:    11-Feb-97   KyleP          Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetSizeMax( ULARGE_INTEGER * pcbSize )
{
    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilter::IsLastCharDBCSLeadByte
//
//  Synopsis:   Check if last byte in buffer is a DBCS lead byte
//
//  Arguments:  [pbIn]    --  Input buffer
//              [cChIn]   --  Buffer length
//
//  History:    6-Jan-96      SitaramR           Created
//
//--------------------------------------------------------------------------

BOOL CTextIFilter::IsLastCharDBCSLeadByte( BYTE *pbIn,
                                           ULONG cChIn )
{
    Win4Assert( IsDBCSCodePage( _ulCodePage ) );

    for ( ULONG cCh=0; cCh<cChIn; cCh++ )
        if ( IsDBCSLeadByteEx( _ulCodePage, pbIn[cCh] ) )
            cCh++;

    //
    // If last char is DBCS lead byte, then cCh == cChIn + 1, else cCh == cChIin
    //
    return cCh != cChIn;
}



//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilter::IsDBCSCodePage
//
//  Synopsis:   Check if the codepage is a DBCS code page
//
//  Arguments:  [codePage]    --  Code page to check
//
//  History:    6-Jan-96      SitaramR           Created
//
//--------------------------------------------------------------------------

BOOL CTextIFilter::IsDBCSCodePage( ULONG ulCodePage )
{
    CPINFO cpInfo;

    BOOL fSuccess = GetCPInfo( ulCodePage, &cpInfo );

    if ( fSuccess )
    {
        if ( cpInfo.LeadByte[0] != 0 && cpInfo.LeadByte[1] != 0 )
            return TRUE;
        else
            return FALSE;
    }

    ciDebugOut(( DEB_ERROR,
                 "IsDBCSCodePage failed, 0x%x\n",
                 GetLastError() ));
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\htx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2002.
//
//  File:       htx.cxx
//
//  Contents:   Parser for a HTX file
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::CHTXScanner - public constructor
//
//  Synopsis:   Builds a scanner for a section within a HTX file
//
//  Arguments:  [variableSet] - list of replaceable parameters
//              [wcsPrefix]   - prefix delimiter for replacable parameters
//              [wcsSuffix]   - suffix delimiter for replacable parameters
//
//  Notes:      The wcsPrefix and wcsSuffix are expected to be the same
//              length and either one or two characters.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXScanner::CHTXScanner( CVariableSet & variableSet,
                          WCHAR const * wcsPrefix,
                          WCHAR const * wcsSuffix ) :
                                    _wcsPrefix(wcsPrefix),
                                    _wcsSuffix(wcsSuffix),
                                    _variableSet(variableSet),
                                    _type(eNone),
                                    _nextType(eNone),
                                    _wcsString(0),
                                    _wcsPrefixToken(0),
                                    _wcsSuffixToken(0)
{
    Win4Assert( wcslen( _wcsPrefix ) == wcslen( _wcsSuffix ) &&
                wcslen( _wcsPrefix ) <= 2 );

    if ( _wcsPrefix[1] == L'\0' )
        _cchPrefix = _cchSuffix = 1;
    else
        _cchPrefix = _cchSuffix = 2;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::Init - public
//
//  Synopsis:   Saves a pointer to the string to be parsed.
//
//  Arguments:  [wcsString] - the string to be parsed
//
//  History:    96/Jan/03   DwightKr    created
//
//  NOTES:      THIS STRING WILL BE MODIFIED BY SUBSEQUENT CALLS TO MEMBER
//              FUNCTIONS OF THIS CLASS.
//
//----------------------------------------------------------------------------
void CHTXScanner::Init( WCHAR * wcsString )
{
    _wcsString = wcsString;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::IsToken - private
//
//  Synopsis:   Determines if a string is a special token.
//
//  Arguments:  [wcs] - start of string to be tested.
//
//  Notes:      If the string is a token, the members _type, _wcsPrefixToken
//              and _wcsSuffixToken are set appropriately.
//
//  History:    96/Apr/02   AlanW       Created
//              96/May/17   DwightKr    Treat all <%..%> as variables
//
//----------------------------------------------------------------------------

BOOL CHTXScanner::IsToken(WCHAR * wcs)
{
    if ( wcsncmp( _wcsPrefix, wcs, _cchPrefix ) != 0 )
    {
        ciGibDebugOut(( DEB_USER1, "CHTXScanner::IsToken  end of string\n" ));
        return FALSE;
    }

    wcs += _cchPrefix;
    WCHAR * wcsSuffixTok = wcs2chr( wcs, _wcsSuffix );
    if ( 0 == wcsSuffixTok )
    {
        ciGibDebugOut(( DEB_USER1, "CHTXScanner::IsToken  no suffix token\n" ));
        return FALSE;
    }

    *wcsSuffixTok = L'\0';
    _wcsPrefixToken = wcs - _cchPrefix;
    _wcsupr( wcs );

    //
    //  Strip leading spaces before token
    //
    while ( iswspace(*wcs) && (wcs < wcsSuffixTok) )
    {
        wcs++;
    }

    //
    //  Strip trailing spaces after token
    //
    WCHAR * wcsSuffix = wcsSuffixTok - 1;
    while ( iswspace(*wcsSuffix) && (wcsSuffix > wcs) )
    {
        *wcsSuffix = 0;
        wcsSuffix--;
    }

    ciGibDebugOut(( DEB_USER1, "CHTXScanner::IsToken  wcs=%ws\n", wcs ));

    if ( wcsncmp( wcs, L"IF ", 3 ) == 0 )
    {
        _type = eIf;
    }
    else if ( wcscmp( wcs, L"ELSE" ) == 0 )
    {
        _type = eElse;
    }
    else if ( wcscmp( wcs, L"ENDIF" ) == 0 )
    {
        _type = eEndIf;
    }
    else if ( wcsncmp( wcs, L"ESCAPEHTML ", 11 ) == 0 )
    {
        _type = eEscapeHTML;
    }
    else if ( wcsncmp( wcs, L"ESCAPEURL ", 10 ) == 0 )
    {
        _type = eEscapeURL;
    }
    else if ( wcsncmp( wcs, L"ESCAPERAW ", 10 ) == 0 )
    {
        _type = eEscapeRAW;
    }
    else
    {
        //
        //  Find this name in the list of replaceable parameters.  Note that
        //  if we can't find this variable in the list of replaceable
        //  parameters, we've converted some output text to uppercase.  This
        //  is probably OK since the user used <% ... %> to delimit their
        //  output; <% & %> are reserved tokens hence this would be an error.
        //
        CVariable *pVariable = _variableSet.Find( wcs );

        if ( 0 != pVariable )
        {
            //
            //  We have a match, this is a replaceable parameter.  Compiler
            //  bug.  _type needs to be assigned in both places.
            //
            _type = eParameter | pVariable->GetFlags();
        }
        else
        {
            ciGibDebugOut(( DEB_IWARN,
                            "Warning: CHTXScanner::IsToken found a unknown variable: '%ws'\n",
                            wcs ));

            _type = eParameter;
        }
    }

    *_wcsPrefixToken = L'\0';
    _wcsSuffixToken = wcsSuffixTok;
    _wcsNextToken = wcsSuffixTok + _cchSuffix;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::FindNextToken - public
//
//  Synopsis:   Locates the next token in the string.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------

BOOL CHTXScanner::FindNextToken()
{
    if (_nextType != eNone)
    {
        //
        // Found a token on the previous call.  Just return it.
        //
        Win4Assert ( _wcsPrefixToken && _wcsSuffixToken > _wcsPrefixToken );
        _type = _nextType;
        _nextType = eNone;
        _wcsString = _wcsNextToken = _wcsSuffixToken + _cchSuffix;
        return TRUE;
    }

    if ( (0 == _wcsString) || (0 == *_wcsString) )
    {
        _type = eNone;
        _wcsNextToken = 0;

        return FALSE;
    }

    if ( *_wcsString == *_wcsPrefix &&
         IsToken( _wcsString ) )
    {
        _nextType = eNone;
        return TRUE;
    }

    //
    // The string doesn't start with one of our special keywords.
    // Treat it as an ordinary string, and look ahead to the next
    // valid token.
    //

    _wcsPrefixToken = wcs2chr( _wcsString+1, _wcsPrefix );
    while ( _wcsPrefixToken )
    {
        if ( IsToken( _wcsPrefixToken ) )
        {
            _nextType = _type;
            _wcsNextToken = _wcsPrefixToken;
            _type = eString;
            return TRUE;
        }
        _wcsPrefixToken = wcs2chr( _wcsPrefixToken+_cchPrefix, _wcsPrefix );
    }

    _nextType = eNone;
    _type = eString;
    _wcsNextToken = _wcsString + wcslen( _wcsString );
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::GetToken - public
//
//  Synopsis:   Returns a pointer to the replaceable parameter token found.
//              Prepares the scanner to return the next token.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Mar/13   DwightKr    add support for eEscapeURL &
//                                      eEscapeHTML
//
//----------------------------------------------------------------------------

WCHAR * CHTXScanner::GetToken()
{
    if ( eString == _type )
    {
        if ( 0 != _wcsString )
        {
            WCHAR * wcsString = _wcsString;
            _wcsString = _wcsNextToken;

            return wcsString;
        }
    }
    else if ( eEscapeHTML == _type )
    {
        WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
        wcsString += 10;                        // Skip 'EscapeHTML'
        *_wcsSuffixToken = 0;                   // Null terminate

        while ( (0 != *wcsString) && iswspace(*wcsString) )
        {
            wcsString++;
        }

        _wcsString = _wcsNextToken;

        return wcsString;
    }
    else if ( eEscapeURL == _type ||
              eEscapeRAW == _type )
    {
        WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
        wcsString += 9;                         // Skip 'EscapeURL'
        *_wcsSuffixToken = 0;                   // Null terminate

        while ( (0 != *wcsString) && iswspace(*wcsString) )
        {
            wcsString++;
        }

        _wcsString = _wcsNextToken;

        return wcsString;
    }
    else
    {
        if ( 0 != _wcsPrefixToken )
        {
            Win4Assert( 0 != _wcsSuffixToken &&
                        _wcsPrefixToken < _wcsSuffixToken &&
                        _wcsSuffixToken < _wcsNextToken );

            *_wcsPrefixToken = 0;
            *_wcsSuffixToken = 0;

            _wcsString = _wcsNextToken;

            WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
            while ( (0 != *wcsString) && iswspace(*wcsString) )
            {
                wcsString++;
            }


            return wcsString;
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::CHTXFile - public constructor
//
//  Synopsis:   Builds a CHTXFile object and initializes values.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXFile::CHTXFile( XPtrST<WCHAR> & wcsTemplate,
                    UINT codePage,
                    CSecurityIdentity const & securityIdentity,
                    ULONG ulServerInstance )
        : _wcsVirtualName( wcsTemplate.Acquire() ),
          _pVarHeader(0),
          _pVarRowDetails(0),
          _pVarFooter(0),
          _wcsFileBuffer(0),
          _fSequential(TRUE),
          _cIncludeFiles(0),
          _refCount(0),
          _codePage(codePage),
          _securityIdentity( securityIdentity ),
          _ulServerInstance( ulServerInstance )
{
    _wcsPhysicalName[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::~CHTXFile - public destructor
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXFile::~CHTXFile()
{
    Win4Assert( _refCount == 0 );

    delete _wcsVirtualName;
    delete _pVarHeader;
    delete _pVarRowDetails;
    delete _pVarFooter;
    delete _wcsFileBuffer;

    for (unsigned i=0; i<_cIncludeFiles; i++)
    {
        delete _awcsIncludeFileName[i];
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::ParseFile - public
//
//  Synopsis:   Parses the HTX file and breaks it up into its sections.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXFile::ParseFile( WCHAR const * wcsFileName,
                          CVariableSet & variableSet,
                          CWebServer & webServer )
{
    Win4Assert( wcsFileName != 0 );

    if ( wcslen( wcsFileName ) >= MAX_PATH )
        THROW( CException( E_INVALIDARG ) );

    wcscpy( _wcsPhysicalName, wcsFileName );

    //
    //  Read the entire file into a buffer
    //
    CVirtualString wcsBuffer;
    ExpandFile( _wcsPhysicalName, webServer, wcsBuffer, _ftHTXLastWriteTime );

    Win4Assert( wcsBuffer.GetPointer() != 0 );

    //
    //  Break the buffer into the sections; the header, the detail section,
    //  and the footer.  Verify that if there is a <%BeginDetail%>
    //  section, then there MUST be a <%EndDetail%> section AFTER it, not
    //  before.  Neither <%EndDetail%> nor <%BeginDetail%> can appear on
    //  their own.
    //

    //
    //  Find the <%BeginDetail%> and <%EndDetail%> sections
    //
    _wcsFileBuffer        = wcsBuffer.StrDup();         // Save buffer
    WCHAR * wcsHeader     = _wcsFileBuffer;             // Assume a header
    WCHAR * wcsRowDetails = wcsipattern(wcsHeader, L"<%BEGINDETAIL%>" );
    WCHAR * wcsFooter     = wcsipattern(wcsHeader, L"<%ENDDETAIL%>" );

    if ( wcsHeader == wcsRowDetails )
    {
        //
        //  No header found in this file; it begins with the detail section.
        //
        wcsHeader = 0;
    }

    const int cwcBeginDetail = 15;
    const int cwcEndDetail   = 13;

    Win4Assert( cwcBeginDetail == wcslen( L"<%BEGINDETAIL%>" ) );
    Win4Assert( cwcEndDetail == wcslen( L"<%ENDDETAIL%>" ) );

    if ( 0 != wcsRowDetails )
    {
        //
        //  A <%BeginDetail%> section was found.  We better also have an
        //  <%EndDetail%> section AFTER the <%BeginDetail%> section.
        //

        *wcsRowDetails = 0;         // Null terminate the header string
        wcsRowDetails += cwcBeginDetail;

        if ( 0 != wcsFooter )
        {
            if ( wcsFooter < wcsRowDetails )
            {
                //
                //  The <%EndDetail%> was found before the <%BeginDetail%>
                //
                WCHAR * wcsHTXFileName;
                LONG    lLineNumber;

                GetFileNameAndLineNumber( (int)(wcsFooter - _wcsFileBuffer),
                                          wcsHTXFileName,
                                          lLineNumber );

                THROW( CHTXException(MSG_CI_HTX_ENDDETAIL_BEFORE_BEGINDETAIL,
                                     wcsHTXFileName,
                                     lLineNumber) );
            }

            *wcsFooter = 0;         // Null terminate the BeginDetail section
            wcsFooter += cwcEndDetail;
        }
        else
        {
            //
            //  Report an error:  <%BeginDetail%> without an <%EndDetail%>
            //

            WCHAR * wcsHTXFileName;
            LONG    lLineNumber;

            GetFileNameAndLineNumber( (int)(wcsRowDetails - _wcsFileBuffer),
                                      wcsHTXFileName,
                                      lLineNumber );

            THROW( CHTXException(MSG_CI_HTX_NO_ENDDETAIL_SECTION,
                                 wcsHTXFileName,
                                 lLineNumber) );
        }
    }
    else if ( 0 != wcsFooter )
    {
        //
        //  A <%BeginDetail%> section could be found.  There should
        //  be no <%EndDetail%> section either.
        //

        WCHAR * wcsHTXFileName;
        LONG    lLineNumber;

        GetFileNameAndLineNumber( (int)(wcsFooter - _wcsFileBuffer),
                                  wcsHTXFileName,
                                  lLineNumber );

        THROW( CHTXException(MSG_CI_HTX_NO_BEGINDETAIL_SECTION,
                             wcsHTXFileName,
                             lLineNumber) );
    }


    if ( 0 != wcsHeader )
    {
        _pVarHeader = new CParameterReplacer ( wcsHeader,
                                               L"<%",
                                               L"%>" );
        _pVarHeader->ParseString( variableSet );
    }

    if ( 0 != wcsRowDetails )
    {
        _pVarRowDetails = new CParameterReplacer ( wcsRowDetails,
                                                   L"<%",
                                                   L"%>" );
        _pVarRowDetails->ParseString( variableSet );
    }

    if ( 0 != wcsFooter )
    {
        _pVarFooter = new CParameterReplacer ( wcsFooter,
                                               L"<%",
                                               L"%>" );
        _pVarFooter->ParseString( variableSet );
    }

    _fSequential = CheckForSequentialAccess();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::ReadFile - public
//
//  Synopsis:   Read the HTX file into a buffer
//
//  Arguments:  [wcsFileName]  - full physical path name of file
//              [ftLastWrite]  - File's last write time is stored here
//
//  History:    96/Jan/03   DwightKr    created
//              96/Apr/06   DwightKr    add support for unicode files
//
//----------------------------------------------------------------------------
WCHAR * CHTXFile::ReadFile( WCHAR const * wcsFileName,
                            FILETIME & ftLastWrite )
{
    Win4Assert ( 0 != wcsFileName );

    // We don't support impersonation for scripts.
    // It involves getting the server ip address, vpath and then using
    // that for impersonation

    if ( IsNetPath(wcsFileName) )
    {
        ciGibDebugOut(( DEB_ERROR, "The htx file (%ws) is on remote UNC\n",
                        wcsFileName ));
        THROW( CHTXException( MSG_CI_SCRIPTS_ON_REMOTE_UNC, wcsFileName, 0 ));
    }

    //
    //  Verify the HTX file exists, and is a file, not a directory.
    //
    WIN32_FILE_ATTRIBUTE_DATA ffData;
    if ( !GetFileAttributesEx( wcsFileName, GetFileExInfoStandard, &ffData ) )
    {
        ULONG error = GetLastError();

        ciGibDebugOut(( DEB_IERROR,
                        "Unable to GetFileAttributesEx(%ws) GetLastError=0x%x\n",
                        wcsFileName,
                        error ));

        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_TEMPLATE, 0) );
    }


    if ( (ffData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 )
    {
        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_TEMPLATE, 0) );
    }

    //
    //  Save the last write time of this file.
    //
    ftLastWrite = ffData.ftLastWriteTime;


    //
    //  Open the file and map its contents
    //
    CFileMapView mapView( wcsFileName );
    mapView.Init();

    int cbBuffer = mapView.GetBufferSize() + 1;
    XArray<WCHAR> pwBuffer(cbBuffer);

    //
    //  If the first two BYTES of the file are 0xFF 0xFE, then this is a
    //  unicode file, and we don't need to convert it.
    //
    if ( mapView.IsUnicode() )
    {
        RtlCopyMemory( pwBuffer.Get(), mapView.GetBuffer()+2, cbBuffer-2 );
        pwBuffer[ ( cbBuffer - 2 ) / sizeof WCHAR ] = 0;

        return pwBuffer.Acquire();
    }

    //
    //  Copy & convert the ASCII buffer to a WCHAR buffer.
    //
    int cwBuffer = mapView.GetBufferSize() + 1;
    int cwConvert;

    do
    {
        cwConvert = MultiByteToWideChar(_codePage,
                                        0,
                         (const char *) mapView.GetBuffer(),    // Ptr to input buf
                                        mapView.GetBufferSize(),// Size of input buf
                                        pwBuffer.Get(), // Ptr to output buf
                                        cwBuffer - 1 ); // Size of output buf

        if ( 0 == cwConvert )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                cwBuffer += (cwBuffer/2);
                delete pwBuffer.Acquire();
                pwBuffer.Init(cwBuffer);
            }
            else
            {
                THROW( CException() );
            }
        }
        else
        {
            pwBuffer[cwConvert] = 0;        // Null terminate the buffer
        }

        Win4Assert( cwConvert < cwBuffer );

    } while ( 0 == cwConvert );

    return pwBuffer.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::ExpandFile, public
//
//  Synopsis:   Expands the contents of an HTX file into memory, processing
//              included files.
//
//  Arguments:  [wcsFileName]  - file path name of the file to be expanded
//              [webServer]    - CWebServer for virtual path translation
//              [vString]      - String to which file contents are appended
//              [ftLastWrite]  - File's last write time is stored here
//
//----------------------------------------------------------------------------
void CHTXFile::ExpandFile( WCHAR const * wcsFileName,
                           CWebServer & webServer,
                           CVirtualString & vString,
                           FILETIME & ftLastWrite )
{
    Win4Assert ( 0 != wcsFileName );

    //
    //  Read the existing file into a WCHAR buffer.
    //
    XPtrST<WCHAR> wcsBuffer( ReadFile(wcsFileName, ftLastWrite) );

    WCHAR * wcsString = wcsBuffer.GetPointer();
    ULONG   cwcString = wcslen( wcsString );
    WCHAR * wcsEnd    = wcsString + cwcString;

    //
    //  Search the WCHAR buffer for <%include ... %>
    //
    WCHAR * wcsPattern = L"<%INCLUDE ";
    ULONG   cwcPattern = 10;

    Win4Assert( cwcPattern == wcslen(wcsPattern) );

    WCHAR * wcsToken = wcsipattern( wcsString, wcsPattern );

    while ( 0 != wcsToken )
    {
        if ( _cIncludeFiles >= MAX_HTX_INCLUDE_FILES )
        {
            LONG cLines = CountLines( wcsBuffer.GetPointer(), wcsToken );

            THROW( CHTXException(MSG_CI_HTX_TOO_MANY_INCLUDES,
                                 wcsFileName,
                                 cLines) );
        }

        //
        //  Concatentate everything before the <%include .. %> into the
        //  virtual string.
        //
        ULONG cwcCat = (ULONG)(wcsToken - wcsString);
        Win4Assert( cwcCat <= cwcString );
        *wcsToken = 0;                          // Null terminate the string
        vString.StrCat( wcsString, cwcCat );

        //
        //  Find the end of the <%include ... %>
        //

        wcsToken += cwcPattern;                 //  Skip the <%include
        WCHAR * wcsIncludeFileName = wcsToken;  //  Point to the include filename
        wcsString = wcs2chr( wcsToken, L"%>" );  //  Point to the end of the filename

        //
        //  wcsString should be pointing to the %> at the end of the include
        //
        if ( 0 == wcsString )
        {
            //
            //  Missing %>
            //

            LONG cLines = CountLines( vString.GetPointer(), wcsToken );

            THROW( CHTXException(MSG_CI_HTX_ILL_FORMED_INCLUDE,
                                 wcsFileName,
                                 cLines) );
        }

        //
        //  Process the <%include ... %>
        //
        *wcsString = 0;
        if ( (wcsString - wcsIncludeFileName) >= MAX_PATH )
        {
            LONG cLines = CountLines( wcsBuffer.GetPointer(), wcsToken );

            THROW( CHTXException(MSG_CI_HTX_INVALID_INCLUDE_FILENAME,
                                 wcsFileName,
                                 cLines ) );
        }

        WCHAR   awcPhysicalPath[MAX_PATH];
        webServer.GetPhysicalPath( wcsIncludeFileName,
                                   awcPhysicalPath,
                                   MAX_PATH );

        //
        //  Save the include filename away
        //
        ULONG cwcPhysicalPath = wcslen(awcPhysicalPath) + 1;
        _awcsIncludeFileName[_cIncludeFiles]  = new WCHAR[ cwcPhysicalPath ];
        _aulIncludeFileOffset[_cIncludeFiles] = vString.StrLen();

        RtlCopyMemory( _awcsIncludeFileName[_cIncludeFiles],
                       awcPhysicalPath,
                       cwcPhysicalPath * sizeof(WCHAR) );

        FILETIME & ftLastWrite = _aftIncludeLastWriteTime[ _cIncludeFiles ];
        _cIncludeFiles++;

        ExpandFile( awcPhysicalPath, webServer, vString, ftLastWrite );

        wcsString += 2;                     // Skip the %>
        cwcString = (ULONG)(wcsEnd - wcsString);
        wcsToken  = wcsipattern( wcsString, wcsPattern );
    }

    vString.StrCat( wcsString, cwcString );
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::GetFileNameAndLineNumber
//
//  Synopsis:   Determines the filename & line number amoung a group of
//              nested includes for a particular offset into the buffer.
//
//  Arguments:  [offset] - offset of the error in the overall buffer
//              [wcsFileName] - resulting name of file containing error
//              [lineNumber]  - line # containing the error
//
//  History:    96/Jun/25   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXFile::GetFileNameAndLineNumber( int offset,
                                         WCHAR *& wcsFileName,
                                         LONG & lineNumber )
{
    //
    //  Search the array of offsets for the one containing our offset
    //
    for (ULONG i = 0;
         (i < _cIncludeFiles) && ((ULONG) offset > _aulIncludeFileOffset[i]);
         i++ )
    {
    }

    //
    //  Save a pointer to the name of the file containing the error
    //
    WCHAR const * pCurrent = _wcsFileBuffer;
    if ( 0 == i )
    {
        //
        //  We have a problem in the outer-most container file; not
        //  an include file.
        //
        wcsFileName = _wcsVirtualName;
    }
    else
    {
        wcsFileName = _awcsIncludeFileName[i-1];
        pCurrent += _aulIncludeFileOffset[i-1];
    }


    //
    //  Count the number of lines in this sub-file
    //
    Win4Assert( 0 != _wcsFileBuffer );
    WCHAR const * pEnd = _wcsFileBuffer + offset;

    lineNumber = CountLines( pCurrent, pEnd );
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::CountLines - private
//
//  Synopsis:   Deterines the number of lines (CR's) between the start
//              of the buffer and the end.
//
//  Arguments:  [wcsStart] - start location of search
//              [wcsEnd]   - end of search
//
//  History:    96/Jun/25   DwightKr    created
//
//----------------------------------------------------------------------------
LONG CHTXFile::CountLines( WCHAR const * wcsStart,
                           WCHAR const * wcsEnd ) const
{
    Win4Assert( 0 != wcsStart );
    Win4Assert( 0 != wcsEnd );

    LONG cLines = 1;

    while ( wcsStart <= wcsEnd )
    {
        if ( L'\n' == *wcsStart )
        {
            cLines++;
        }

        wcsStart++;
    }

    return cLines;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::IsCachedDataValid - public
//
//  Synopsis:   Determines if the cached & parsed data from the HTX file
//              is still valid.  The HTX file itself may have changed
//              since we read and parsed it.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Mar/14   DwightKr    check <%include%> file times
//
//----------------------------------------------------------------------------
BOOL CHTXFile::IsCachedDataValid()
{
    FILETIME ft;

    SCODE sc = GetLastWriteTime( _wcsPhysicalName, ft );

    if ( FAILED( sc ) )
        return FALSE;

    if ( (_ftHTXLastWriteTime.dwLowDateTime != ft.dwLowDateTime) ||
         (_ftHTXLastWriteTime.dwHighDateTime != ft.dwHighDateTime) )
    {
        return FALSE;
    }

    for ( unsigned i=0; i<_cIncludeFiles; i++ )
    {
        sc = GetLastWriteTime(_awcsIncludeFileName[i], ft );

        if ( FAILED( sc ) )
            return FALSE;

        if ( (_aftIncludeLastWriteTime[i].dwLowDateTime != ft.dwLowDateTime) ||
             (_aftIncludeLastWriteTime[i].dwHighDateTime != ft.dwHighDateTime) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::GetHeader - public
//
//  Synopsis:   Appends to a CVirtualString the data in the HTX file BEFORE
//              the <%begindetail%> section.  This may require replacing
//              parameters.
//
//  Arguments:  [string]       - the CVirtualString to append data to
//              [variableSet]  - a list of replaceable parameters
//              [outputFormat] - format for numbers & dates
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXFile::GetHeader( CVirtualString & string,
                          CVariableSet & variableSet,
                          COutputFormat & outputFormat )
{
    if ( 0 != _pVarHeader )
    {
        _pVarHeader->ReplaceParams( string, variableSet, outputFormat );
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::GetFooter - public
//
//  Synopsis:   Appends to a CVirtualString the data in the HTX file AFTER
//              the <%enddetail%> section.  This may require replacing
//              parameters.
//
//  Arguments:  [string]      - the CVirtualString to append data to
//              [variableSet] - a list of replaceable parameters
//              [outputFormat] - format for numbers & dates
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXFile::GetFooter( CVirtualString & string,
                          CVariableSet & variableSet,
                          COutputFormat & outputFormat )
{
    if ( 0 != _pVarFooter )
    {
        _pVarFooter->ReplaceParams( string, variableSet, outputFormat );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::CheckForSequentialAccess - public
//
//  Synopsis:   Determines if a sequential query cursor can be used to
//              extract query results.  This is possible if the HTX file
//              does not use any replaceable parameters which require
//              data from an IRowsetScroll.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXFile::CheckForSequentialAccess()
{
    //
    //  If an HTX file contains any of the following variables, it must
    //  use a non-sequential access, since we need one or more interfaces
    //  from IRowsetScroll.
    //
    //      CiMatchedRecordCount
    //      CiRecordsNextPage
    //      CiTotalNumberPages
    //

    if ( (0 != _pVarHeader) && (_pVarHeader->GetFlags() & eParamRequiresNonSequentialCursor) )
    {
        return FALSE;
    }

    if ( (0 != _pVarRowDetails) && (_pVarRowDetails->GetFlags() & eParamRequiresNonSequentialCursor) )
    {
        return FALSE;
    }

    if ( (0 != _pVarFooter) && (_pVarFooter->GetFlags() & eParamRequiresNonSequentialCursor) )
    {
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::Find - public
//
//  Synopsis:   Finds a matching parsed HTX file in list, or builds a new
//              one if a match can not be found.
//
//  Arguments:  [wcsFileName]      -- full path to HTX file
//              [variableSet]      -- list of replaceable parameters
//              [outputFormat]     -- format for numbers and dates
//              [securityIdentity] -- Logon for this query
//              [ulServerInstance] -- Virtual Server Instance Number
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------

CHTXFile & CHTXFileList::Find( WCHAR const * wcsFileName,
                               CVariableSet & variableSet,
                               COutputFormat & outputFormat,
                               CSecurityIdentity const & securityIdentity,
                               ULONG ulServerInstance )
{
    Win4Assert( 0 != wcsFileName );

    //
    //  Determine the name of the HTX/template file.  It may have a
    //  replaceable value from the client.
    //

    ULONG cwcOut;
    XPtrST<WCHAR> wcsVirtualName( ReplaceParameters( wcsFileName,
                                                     variableSet,
                                                     outputFormat,
                                                     cwcOut ) );

    if ( 0 == *(wcsVirtualName.GetPointer()) )
    {
        THROW( CIDQException( MSG_CI_IDQ_MISSING_TEMPLATEFILE, 0 ) );
    }


    //
    //  Refcount everything in the list so that we can examine the list
    //  outside of the lock.
    //

    ULONG      cItems;
    XArray<CHTXFile *> aHTXFile;

    // ==========================================
    {
        CLock lock( _mutex );

        cItems = _aHTXFile.Count();         // Save count of items to examine
        aHTXFile.Init( cItems );

        for (unsigned i=0; i<cItems; i++)
        {
            aHTXFile[i] = _aHTXFile[i];
            aHTXFile[i]->LokAddRef();
        }
    }
    // ==========================================


    //
    //  Now walk though the list looking for a match; outside of the lock.
    //
    XInterface<CHTXFile> xHTXFile;
    SCODE sc = S_OK;

    TRY
    {
        for (unsigned i=0; i<cItems; i++)
        {
            if ( (_wcsicmp(aHTXFile[i]->GetVirtualName(), wcsVirtualName.GetPointer() ) == 0) &&
                 (aHTXFile[i]->GetCodePage() == outputFormat.CodePage()) &&
                 (aHTXFile[i]->GetServerInstance() == ulServerInstance) &&
                 (aHTXFile[i]->IsCachedDataValid() )
               )
            {
                xHTXFile.Set( aHTXFile[i] );

                ciGibDebugOut(( DEB_ITRACE,
                                "A cached version of HTX file %ws was found\n",
                                wcsVirtualName.GetPointer() ));

                break;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    //
    //  If xHTXFile is non-0, we've found a match.  Decrement the ref-count
    //  for all items which did not match.
    //

    for (unsigned i=0; i<cItems; i++)
    {
        if ( aHTXFile[i] != xHTXFile.GetPointer() )
        {
            aHTXFile[i]->Release();
        }
    }

    if ( S_OK != sc )
    {
        Win4Assert( xHTXFile.IsNull() );
        THROW( CException( sc ) );
    }

    //
    // We may have matched, but still not have access to this file.  First, make
    // a quick check for an exact match on security token, and then try harder
    // by opening the file.
    //

    if ( !xHTXFile.IsNull() )
    {
        if ( !xHTXFile->CheckSecurity( securityIdentity ) )
        {
            HANDLE h = CreateFile( xHTXFile->GetPhysicalName(),
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   0,
                                   OPEN_EXISTING,
                                   0,
                                   0 );

            //
            // Don't try to determine here if security caused the problem.
            // Just let the standard exception handling below in file parsing
            // deal with the error.
            //

            if ( INVALID_HANDLE_VALUE == h )
            {
                xHTXFile.Free();
            }
            else
            {
                CloseHandle( h );

                //
                // Update the security token of the cached Htx file,
                // to optimize away the CreateFile check in two cases:
                //   1.  When the file is first parsed with admin
                //       privileges, and all subsequent queries are with
                //       anonymous privileges.
                //   2.  When the security token changes over time
                //
                xHTXFile->SetSecurityToken( securityIdentity );
            }
        }
    }

    //
    //  If we didn't find a match, then open and parse a new HTX file, and
    //  add it to the list of parsed HTX files
    //

    if ( xHTXFile.IsNull() )
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Adding HTX file %ws to cache\n",
                        wcsVirtualName.GetPointer() ));

        WCHAR wcsPhysicalName[MAX_PATH];
        if ( outputFormat.IsValid() )
        {
            outputFormat.GetPhysicalPath( wcsVirtualName.GetPointer(),
                                          wcsPhysicalName,
                                          MAX_PATH );
        }
        else
        {
            if ( !GetFullPathName( wcsVirtualName.GetPointer(),
                                   MAX_PATH,
                                   wcsPhysicalName,
                                   0 ) )
            {
                THROW( CException() );
            }
        }

        XPtr<CHTXFile> xHTXFilePtr( new CHTXFile( wcsVirtualName,
                                                  outputFormat.CodePage(),
                                                  securityIdentity,
                                                  ulServerInstance ) );
        xHTXFilePtr->ParseFile( wcsPhysicalName,
                                variableSet,
                                outputFormat );

        {
            // ==========================================
            CLock lock( _mutex );
            _aHTXFile.Add( xHTXFilePtr.GetPointer(), _aHTXFile.Count() );
            xHTXFilePtr->LokAddRef();
            // ==========================================
        }

        xHTXFile.Set( xHTXFilePtr.Acquire() );
    }

    // CopyStringValue can fail.

    variableSet.CopyStringValue( ISAPI_CI_TEMPLATE,
                                 xHTXFile->GetVirtualName(),
                                 0 );

    return *xHTXFile.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::~CHTXFileList - public destructor
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
CHTXFileList::~CHTXFileList()
{
    for (unsigned i=0; i<_aHTXFile.Count(); i++)
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Deleting HTX cache entry %ws\n",
                        _aHTXFile[i]->GetVirtualName() ));

        delete _aHTXFile[i];
    }

    delete _pCanonicHTX;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::Release - public
//
//  Synopsis:   Releases the HTX file by decrementing its refcount.
//
//  Arguments:  [htxFile] -- pointer to the HTX file object
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CHTXFileList::Release( CHTXFile & htxFile )
{
    htxFile.Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::DeleteZombies - public
//
//  Synopsis:   Removes HTX files that are zombies; i.e. out of date
//
//  History:    96/Mar/28   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CHTXFileList::DeleteZombies()
{
    // ==========================================
    CLock lock( _mutex );

    unsigned i=0;
    while ( i<_aHTXFile.Count() )
    {
        if ( _aHTXFile[i]->LokGetRefCount() == 0 &&
             !_aHTXFile[i]->IsCachedDataValid() )
        {
            CHTXFile * pHTXFile = _aHTXFile[i];
            _aHTXFile.Remove(i);

            ciGibDebugOut(( DEB_ITRACE,
                            "Deleting zombie HTX cache entry %ws, %d entries cached\n",
                            pHTXFile->GetVirtualName(),
                            _aHTXFile.Count() ));

            delete pHTXFile;
        }
        else
        {
            ciGibDebugOut(( DEB_ITRACE,
                            "HTX cache entry %ws was not deleted, refCount=%d\n",
                            _aHTXFile[i]->GetVirtualName(),
                            _aHTXFile[i]->LokGetRefCount() ));
            i++;
        }
    }
    // ==========================================
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\ida.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:   ida.cxx
//
//  Contents:   Parser for an IDQ file
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fsciexps.hxx>

//
// Constants
//

static WCHAR const wcsPRootVar[] = L"PROOT_";
unsigned const ccPRootVar = sizeof(wcsPRootVar)/sizeof(WCHAR) - 1;

static WCHAR const wcsIndexVar[] = L"INDEX_";
unsigned const ccIndexVar = sizeof(wcsIndexVar)/sizeof(WCHAR) - 1;

static WCHAR const wcsNNTP[] = L"NNTP_";
unsigned const ccNNTP = sizeof(wcsNNTP)/sizeof(WCHAR) - 1;

static WCHAR const wcsIMAP[] = L"IMAP_";
unsigned const ccIMAP = sizeof(wcsIMAP)/sizeof(WCHAR) - 1;

static WCHAR const wcsScanVar[] = L"SCAN_";
unsigned const ccScanVar = sizeof(wcsScanVar)/sizeof(WCHAR) - 1;

unsigned const ccStringizedGuid = 36;

BOOL ParseGuid( WCHAR const * pwcsGuid, GUID & guid );

//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::CIDAFile - public constructor
//
//  Synopsis:   Builds a CIDAFile object, initializes values
//
//  Arguments:  [wcsFileName] -- full path to IDQ file
//
//  History:    13-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

CIDAFile::CIDAFile( WCHAR const * wcsFileName, UINT codePage )
        : _eOperation( CIDAFile::CiState ),
          _wcsCatalog(0),
          _wcsHTXFileName( 0 ),
          _wcsLocale(0),
          _cReplaceableParameters(0),
          _refCount(0),
          _codePage(codePage)
{
    ULONG cwc = wcslen(wcsFileName);

    if ( cwc >= sizeof(_wcsIDAFileName)/sizeof(WCHAR) )
    {
        ciGibDebugOut(( DEB_WARN, "Too long a path (%ws)\n", wcsFileName ));
        THROW( CException( STATUS_INVALID_PARAMETER ));
    }

    RtlCopyMemory( _wcsIDAFileName, wcsFileName, (cwc+1) * sizeof(WCHAR) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::~CIDAFile - public destructor
//
//  History:    13-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

CIDAFile::~CIDAFile()
{
    Win4Assert( _refCount == 0 );

    delete [] _wcsCatalog;
    delete [] _wcsHTXFileName;
    delete [] _wcsLocale;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::ParseFile, private
//
//  Synopsis:   Parses the given file and sets up the necessary variables
//
//  History:    13-Apr-96   KyleP       Created.
//              23-Jul-96   DwightKr    Use mapped file I/O which checks
//                                      ACLs and throws ACCESS_DENIED if
//                                      not available.
//
//----------------------------------------------------------------------------

void CIDAFile::ParseFile()
{
    //
    //  Parse the query parameters
    //

    XPtr<CFileMapView> xMapView;

    TRY
    {
        xMapView.Set( new CFileMapView( _wcsIDAFileName ) );
        xMapView->Init();
    }
    CATCH( CException, e )
    {
        if ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == e.GetErrorCode() )
        {
            THROW( CIDQException( MSG_CI_IDQ_NOT_FOUND, 0 ) );
        }
        else
        {
            RETHROW();
        }
    }
    END_CATCH

    CFileBuffer idaFile( xMapView.GetReference(), _codePage );

    //
    //  Process a line at a time, look for the [Admin] section and
    //  process lines within that section.
    //

    BOOL fAdminSection = FALSE;
    int iLine = 0;                  // Start counting at line #1

    for( ;; )
    {
        iLine++;
        XGrowable<WCHAR> xLine;

        ULONG cwcChar = idaFile.fgetsw( xLine );

        if( 0 == cwcChar )
        {
            break;
        }

        WCHAR *pwcLine = xLine.Get();

        //
        //  Skip ahead until we find a [Admin] section
        //

        if ( L'[' == *pwcLine )
        {
            if ( _wcsnicmp(pwcLine+1, L"Admin]", 6) == 0 )
                fAdminSection = TRUE;
            else
                fAdminSection = FALSE;

            continue;
        }

        //
        // Ignore comments.
        //

        else if ( L'#' == *pwcLine )
            continue;


        if ( fAdminSection )
        {
            CQueryScanner scanner( pwcLine, FALSE );
            ParseOneLine( scanner, iLine );
        }
    }

    //
    //  Verify that the minimum set of parameters are specified.
    //

    //
    //  We must have all of the following:
    //
    //      - a HTX file name
    //

    if ( 0 == _wcsHTXFileName )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "Template not found in IDA file.\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_TEMPLATEFILE, 0) );
    }

    //
    //  If no catalog was specified, use the default catalog in the registry
    //
    if ( 0 == _wcsCatalog )
    {
        ciGibDebugOut(( DEB_ITRACE, "Using default catalog\n" ));

        WCHAR awcTmp[ MAX_PATH ];
        ULONG cwcRequired = TheIDQRegParams.GetISDefaultCatalog( awcTmp,
                                                                 MAX_PATH );
        if ( cwcRequired > MAX_PATH )
            THROW( CException(STATUS_INVALID_PARAMETER) );

        cwcRequired++; // make room for termination
        _wcsCatalog = new WCHAR[ cwcRequired ];
        RtlCopyMemory( _wcsCatalog, awcTmp, cwcRequired * sizeof WCHAR );
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::ParseOneLine, private
//
//  Synopsis:   Parses one line of the IDQ file
//
//  Arguments:  [scan]   -- scanner initialized with the current line
//              [iLine]  -- current line number
//
//  History:    13-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CIDAFile::ParseOneLine( CQueryScanner & scan, unsigned iLine )
{
    //
    //  Is this a comment line (does it start with #) or an empty line?
    //
    if ( scan.LookAhead() == PROP_REGEX_TOKEN || scan.LookAhead() == EOS_TOKEN )
    {
        return;
    }

    if ( scan.LookAhead() != TEXT_TOKEN )    //  Better be a word
    {
        // Report an error
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_NAME, iLine ) );
    }

    XPtrST<WCHAR> wcsAttribute( scan.AcqWord() );

    if( wcsAttribute.GetPointer() == 0 )                  // Better find a word
    {
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_TYPE, iLine ) );
    }

    scan.Accept();

    if ( scan.LookAhead() != EQUAL_TOKEN )
    {
        // Report an error
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_EQUAL, iLine ) );
    }

    scan.Accept();

    if ( 0 == _wcsicmp( wcsAttribute.GetPointer(), ISAPI_CI_CATALOG ) )
        GetStringValue( scan, iLine, &_wcsCatalog );
    else if ( 0 == _wcsicmp( wcsAttribute.GetPointer(), ISAPI_CI_TEMPLATE ) )
        GetStringValue( scan, iLine, &_wcsHTXFileName );
    else if ( 0 == _wcsicmp( wcsAttribute.GetPointer(), ISAPI_CI_ADMIN_OPERATION ) )
    {
        WCHAR * pwcsTemp = 0;
        GetStringValue( scan, iLine, &pwcsTemp );

        XPtrST<WCHAR> xwcsTemp( pwcsTemp );

        if ( 0 == pwcsTemp )
        {
            THROW( CIDQException( MSG_CI_IDA_INVALID_OPERATION, iLine ) );
        }
        else if ( 0 == _wcsicmp( pwcsTemp, wcsOpGetState ) )
            _eOperation = CIDAFile::CiState;
        else if ( 0 == _wcsicmp( pwcsTemp, wcsOpForceMerge ) )
            _eOperation = CIDAFile::ForceMerge;
        else if ( 0 == _wcsicmp( pwcsTemp, wcsOpScanRoots ) )
            _eOperation = CIDAFile::ScanRoots;
        else if ( 0 == _wcsicmp( pwcsTemp, wcsOpUpdateCache ) )
            _eOperation = CIDAFile::UpdateCache;
        else
        {
            THROW( CIDQException( MSG_CI_IDA_INVALID_OPERATION, iLine ) );
        }
    }
    else if ( 0 == _wcsicmp( wcsAttribute.GetPointer(), ISAPI_CI_LOCALE ) )
    {
        GetStringValue( scan, iLine, &_wcsLocale );
    }
    else
    {
        //
        //  We've found a keyword/attribute that we don't support.
        //  Don't report an error. This will allow this version of the
        //  parser to work with newer .IDA file versions with new parameters.
        //

        ciGibDebugOut(( DEB_ERROR, "Invalid string in IDQ file: %ws\n", wcsAttribute.GetPointer() ));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::GetStringValue - private
//
//  Synopsis:   Gets the string value on the currenct line
//
//  Arguments:  [scan]   -- scanner initialized with the current line
//              [iLine]  -- current line number
//              [pwcsStringValue] -- value to put string into
//
//  History:    13-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CIDAFile::GetStringValue( CQueryScanner & scan,
                               unsigned iLine,
                               WCHAR ** pwcsStringValue )
{
    if ( 0 != *pwcsStringValue )
    {
        ciGibDebugOut(( DEB_IWARN,
                        "Duplicate CiXX=value in IDA file on line #%d\n",
                        iLine ));
        THROW( CIDQException(MSG_CI_IDQ_DUPLICATE_ENTRY, iLine) );
    }

    *pwcsStringValue = scan.AcqLine();

    if ( IsAReplaceableParameter( *pwcsStringValue ) != eIsSimpleString )
    {
        _cReplaceableParameters++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FindEntry, public
//
//  Synopsis:   Helper function for admin variable parsing.
//
//  Arguments:  [pwcsName]   -- Variable name
//              [fScan]      -- TRUE for SCAN, FALSE for INDEX
//              [pwcsBuf]    -- Buffer for search token
//
//  History:    10-Oct-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL FindEntry( WCHAR const * * ppwcsName, BOOL fScan, WCHAR * pwcsBuf )
{
    if ( 0 != _wcsnicmp( *ppwcsName, wcsPRootVar, ccPRootVar ) )
        return FALSE;

    //
    // Scan or Index?
    //

    WCHAR const * pwcsOutputTag;
    unsigned ccOutputTag;

    if ( fScan )
    {
        pwcsOutputTag = wcsScanVar;
        ccOutputTag = ccScanVar;
    }
    else
    {
        pwcsOutputTag = wcsIndexVar;
        ccOutputTag = ccIndexVar;
    }

    //
    // IMAP, NNTP or W3?
    //

    unsigned ccPrefix = ccOutputTag;

    BOOL fW3 = FALSE;
    BOOL fNNTP = FALSE;
    BOOL fIMAP = FALSE;

    if ( 0 == _wcsnicmp( *ppwcsName + ccPRootVar, wcsNNTP, ccNNTP ) )
    {
        fNNTP = TRUE;
        *ppwcsName += ccNNTP;
        ccPrefix += ccNNTP;
    }
    else if ( 0 == _wcsnicmp( *ppwcsName + ccPRootVar, wcsIMAP, ccIMAP ) )
    {
        fIMAP = TRUE;
        *ppwcsName += ccIMAP;
        ccPrefix += ccIMAP;
    }
    else
    {
        fW3 = TRUE;
    }

    *ppwcsName += ccPRootVar;

    //
    // Length check.
    //

    unsigned ccName = wcslen( *ppwcsName ) + 1;

    if ( ccName + ccPrefix > (MAX_PATH + ccIndexVar + ccNNTP + 1) )
    {
        ciGibDebugOut(( DEB_WARN, "Path %ws too long for admin\n", *ppwcsName ));
        return FALSE;
    }

    if ( ccName + ccPrefix > (MAX_PATH + ccIndexVar + ccIMAP + 1) )
    {
        ciGibDebugOut(( DEB_WARN, "Path %ws too long for admin\n", *ppwcsName ));
        return FALSE;
    }

    //
    // Build output name
    //

    RtlCopyMemory( pwcsBuf, pwcsOutputTag, ccOutputTag * sizeof(WCHAR) );

    if ( fNNTP )
        RtlCopyMemory( pwcsBuf + ccOutputTag, wcsNNTP, ccNNTP * sizeof(WCHAR) );
    else if ( fIMAP )
        RtlCopyMemory( pwcsBuf + ccOutputTag, wcsIMAP, ccIMAP * sizeof(WCHAR) );

    RtlCopyMemory( pwcsBuf + ccPrefix, *ppwcsName, ccName * sizeof(WCHAR) );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DoAdmin, public
//
//  Synopsis:   Executes an administrative change.
//
//  Arguments:  [wcsIDAFile]   -- Virtual path to .IDA file
//              [VarSet]       -- Query variables
//              [OutputFormat] -- Output format
//              [vsResults]    -- On success (non exception) result page
//                                written here.
//
//  History:    13-Apr-96   KyleP       Created.
//              22-Jul-96   DwightKr    Make CiLocale replaceable & visible
//                                      in HTX files
//              11-Jun-97   KyleP       Use web server in Output Format
//
//----------------------------------------------------------------------------

void DoAdmin( WCHAR const * wcsIDAFile,
              CVariableSet & VarSet,
              COutputFormat & OutputFormat,
              CVirtualString & vsResults )
{
    //
    // Parse .IDA file.  We don't bother to cache these.
    //

    XPtr<CIDAFile> xIDAFile( new CIDAFile(wcsIDAFile, OutputFormat.CodePage()) );
    xIDAFile->ParseFile();


    ULONG cwcOut;
    XPtrST<WCHAR> wcsLocaleID( ReplaceParameters( xIDAFile->GetLocale(),
                                                  VarSet,
                                                  OutputFormat,
                                                  cwcOut ) );

    XArray<WCHAR> wcsLocale;
    LCID locale = GetQueryLocale( wcsLocaleID.GetPointer(),
                                  VarSet,
                                  OutputFormat,
                                  wcsLocale );

    if ( OutputFormat.GetLCID() != locale )
    {

        ciGibDebugOut(( DEB_ITRACE,
                        "Wrong codePage used for loading IDA file, used 0x%x retrying with 0x%x\n",
                        OutputFormat.CodePage(),
                        LocaleToCodepage(locale) ));

        //
        //  We've parsed the IDA file with the wrong locale.
        //

        delete xIDAFile.Acquire();

        OutputFormat.LoadNumberFormatInfo( locale );

        xIDAFile.Set( new CIDAFile(wcsIDAFile, OutputFormat.CodePage()) );
        xIDAFile->ParseFile();
    }


    SetupDefaultCiVariables( VarSet );
    SetupDefaultISAPIVariables( VarSet );
    SetCGIVariables( VarSet, OutputFormat );

    //
    // Get the catalog.
    //

    XPtrST<WCHAR> wcsCiCatalog( ReplaceParameters( xIDAFile->GetCatalog(),
                                                   VarSet,
                                                   OutputFormat,
                                                   cwcOut ) );

    //
    //  Verify that the wcsCatalog is valid
    //
    if ( !IsAValidCatalog( wcsCiCatalog.GetPointer(), cwcOut ) )
    {
        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_CATALOG, 0) );
    }

    //
    // Get the catalog and machine from the URL style catalog.
    //

    XPtrST<WCHAR> wcsMachine( 0 );
    XPtrST<WCHAR> wcsCatalog( 0 );
    SCODE sc = ParseCatalogURL( wcsCiCatalog.GetPointer(),
                                wcsCatalog,
                                wcsMachine );

    if (FAILED(sc))
    {
        THROW( CException(sc) );
    }

    Win4Assert ( 0 != wcsMachine.GetPointer() );

    //
    // Check that the client is allowed to perform administration
    //
    CheckAdminSecurity( wcsMachine.GetPointer() );

    //
    // Build the HTX page for [success] output
    //

    XPtrST<WCHAR> wcsTemplate( ReplaceParameters( xIDAFile->GetHTXFileName(),
                                                  VarSet,
                                                  OutputFormat,
                                                  cwcOut ) );

    WCHAR wcsPhysicalName[_MAX_PATH];

    if ( OutputFormat.IsValid() )
    {
        OutputFormat.GetPhysicalPath( wcsTemplate.GetPointer(),
                                      wcsPhysicalName,
                                      _MAX_PATH );
    }
    else
    {
        if ( !GetFullPathName( wcsTemplate.GetPointer(),
                               MAX_PATH,
                               wcsPhysicalName,
                               0 ) )
        {
            THROW( CException() );
        }
    }


    //
    // Note: Parsing of HTX file needs to be done in different locations
    //       to ensure variables added to variable set by admin operations
    //       are added before parse.  But we also don't want to fail the
    //       parse *after* doing a dangerous operation (like force merge).
    //

    CSecurityIdentity securityStub;

    CHTXFile SuccessHTX( wcsTemplate,
                         OutputFormat.CodePage(),
                         securityStub,
                         OutputFormat.GetServerInstance() );

    switch ( xIDAFile->Operation() )
    {

    case CIDAFile::ScanRoots:
    {
        SuccessHTX.ParseFile( wcsPhysicalName, VarSet, OutputFormat );

        if ( SuccessHTX.DoesDetailSectionExist() )
        {
            THROW( CIDQException(MSG_CI_IDA_TEMPLATE_DETAIL_SECTION, 0) );
        }

        //
        // Execute the changes.  'Entries' have the following format:
        //     Variable: P<virtual root> = physical root for <virtual root>
        //     Variable: S<virtual root> = "on" / existence means root is scanned
        //     Variable: T<virtual root> = "on" / existence means full scan
        //

        CVariableSetIter iter( VarSet );

        while ( !iter.AtEnd() )
        {
            CVariable * pVar = iter.Get();
            WCHAR const * pwcsName = pVar->GetName();

            WCHAR wcsScanName[MAX_PATH + ccScanVar + __max( ccNNTP, ccIMAP ) + 10 ];

            if ( FindEntry( &pwcsName,     // Starting variable
                            TRUE,          // SCAN
                            wcsScanName )) // Matching search string returned here
            {
                PROPVARIANT * ppvPRoot = pVar->GetValue();

                CVariable * pScanVar = VarSet.Find( wcsScanName );

                if ( 0 !=  pScanVar )
                {
                    WCHAR const * pwszScanType = pScanVar->GetStringValueRAW();

                    if ( 0 != pwszScanType &&
                         ( 0 == _wcsicmp( pwszScanType, L"FullScan" ) ||
                           0 == _wcsicmp( pwszScanType, L"IncrementalScan")
                         ) )
                    {
                        BOOL fFull = (0 == _wcsicmp( pwszScanType, L"FullScan" ));
                        SCODE sc = UpdateContentIndex( ppvPRoot->pwszVal,
                                                       wcsCatalog.GetPointer(),
                                                       wcsMachine.GetPointer(),
                                                       fFull );
                        if ( FAILED(sc) )
                        {
                            ciGibDebugOut(( DEB_ERROR,
                                            "Error 0x%x scanning virtual scope %ws\n",
                                            pwcsName ));
                            THROW( CException( sc ) );
                        }

                    }
                }
            }

            iter.Next();
        }
        break;
    }

    case CIDAFile::UpdateCache:
    {
        SuccessHTX.ParseFile( wcsPhysicalName, VarSet, OutputFormat );

        if ( SuccessHTX.DoesDetailSectionExist() )
        {
            THROW( CIDQException(MSG_CI_IDA_TEMPLATE_DETAIL_SECTION, 0) );
        }

        //
        // Execute the changes.  'Entries' have the following format:
        //     Variable: CACHESIZE_<guid>_NAME_<name>     = Size for named entry
        //     Variable: CACHESIZE_<guid>_PROPID_<propid> = Size for numbered entry
        //     Variable: CACHETYPE_<guid>_NAME_<name>     = Type for named entry
        //     Variable: CACHETYPE_<guid>_PROPID_<propid> = Type for numbered entry
        //

        CVariableSetIter iter( VarSet );

        BOOL fSawOne = FALSE;
        ULONG_PTR ulToken;

        SCODE sc = BeginCacheTransaction( &ulToken,
                                          wcsCatalog.GetPointer(),
                                          wcsCatalog.GetPointer(),
                                          wcsMachine.GetPointer() );

        if ( FAILED(sc) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error 0x%x setting up cache transaction.\n", sc ));
            THROW( CException( sc ) );
        }

        while ( !iter.AtEnd() )
        {
            CVariable * pVar = iter.Get();
            WCHAR const * pwcsName = pVar->GetName();

            //
            // We write out last prop twice, 2nd time to commit everything.
            //


            //
            // Constants.
            //

            static WCHAR const wcsSizeVar[] = L"CACHESIZE_";
            unsigned ccSizeVar = sizeof(wcsSizeVar)/sizeof(WCHAR) - 1;
            static WCHAR const wcsTypeVar[] = L"CACHETYPE_";
            unsigned ccTypeVar = sizeof(wcsTypeVar)/sizeof(WCHAR) - 1;

            if ( 0 == _wcsnicmp( pwcsName, wcsSizeVar, ccSizeVar ) )
            {
                CFullPropSpec ps;

                //
                // Parse the GUID.
                //

                unsigned cc = wcslen( pwcsName );
                GUID guid;

                if ( cc <= ccSizeVar || !ParseGuid( pwcsName + ccSizeVar, guid ) )
                {
                    ciGibDebugOut(( DEB_WARN, "Improperly formatted CACHESIZE entry %ws\n", pwcsName ));
                    iter.Next();
                    continue;
                }

                ps.SetPropSet( guid );

                //
                // PROPID or string?
                //

                static WCHAR const wcsName[] = L"_NAME_";
                unsigned ccName = sizeof(wcsName)/sizeof(WCHAR) - 1;
                static WCHAR const wcsPropid[] = L"_PROPID_";
                unsigned ccPropid = sizeof(wcsPropid)/sizeof(WCHAR) - 1;

                if ( 0 == _wcsnicmp( pwcsName + ccSizeVar + ccStringizedGuid, wcsPropid, ccPropid ) )
                {
                    CQueryScanner scan( pwcsName + ccSizeVar + ccStringizedGuid + ccPropid, FALSE );

                    PROPID propid;
                    BOOL fEnd;

                    if ( !scan.GetNumber( propid, fEnd ) )
                    {
                        ciGibDebugOut(( DEB_WARN, "Improperly formatted CACHESIZE entry %ws\n", pwcsName ));
                        iter.Next();
                        continue;
                    }

                    ps.SetProperty( propid );
                }
                else if ( 0 == _wcsnicmp( pwcsName + ccSizeVar + ccStringizedGuid, wcsName, ccName ) )
                {
                    ps.SetProperty( pwcsName + ccSizeVar + ccStringizedGuid + ccName );
                }
                else
                {
                    ciGibDebugOut(( DEB_WARN, "Improperly formatted CACHESIZE entry %ws\n", pwcsName ));
                    iter.Next();
                    continue;
                }

                //
                // Get value.
                //

                PROPVARIANT * ppvSize = pVar->GetValue();
                ULONG cb;

                if ( ppvSize->vt == VT_LPWSTR )
                {
                    CQueryScanner scan( ppvSize->pwszVal, FALSE );

                    BOOL fEnd;

                    if ( !scan.GetNumber( cb, fEnd ) )
                    {
                        ciGibDebugOut(( DEB_WARN, "Improper CACHESIZE size: \"%ws\".\n", ppvSize->pwszVal ));
                        iter.Next();
                        continue;
                    }
                }
                else
                {
                    ciGibDebugOut(( DEB_IWARN, "Improper CACHESIZE size (type = %d).\n", ppvSize->vt ));
                    iter.Next();
                    continue;
                }

                if ( 0 == cb )
                {
                    //
                    // Delete property from cache (if it was even there).
                    //

                    //
                    // If IDA were the future...
                    // Need to allow primary or secondary store to be chosen!
                    // Also allow the ability to set true/false for prop meta info
                    // modifiability.
                    //

                    SCODE sc = SetupCacheEx( ps.CastToStruct(),
                                             0,
                                             0,
                                             ulToken,
                                             TRUE,
                                             PRIMARY_STORE,
                                             wcsCatalog.GetPointer(),
                                             wcsCatalog.GetPointer(),
                                             wcsMachine.GetPointer() );

                    if ( FAILED(sc) )
                    {
                        ciGibDebugOut(( DEB_ERROR, "Error 0x%x modifying cache\n", sc ));
                        THROW( CException( sc ) );
                    }

                    fSawOne       = TRUE;
                    iter.Next();
                    continue;
                }

                //
                // At this point, we have a non-zero size. The property will
                // be added to the cache.
                //

                //
                // Fetch data type
                //

                XArray<WCHAR> xVar(cc+1);

                RtlCopyMemory( xVar.GetPointer(), pwcsName, (cc+1) * sizeof(WCHAR) );
                RtlCopyMemory( xVar.GetPointer(), wcsTypeVar, ccTypeVar * sizeof(WCHAR) );


                CVariable * pVarType =  VarSet.Find( xVar.GetPointer() );

                if ( 0 == pVarType )
                {
                    ciGibDebugOut(( DEB_WARN, "Missing CACHETYPE value.\n" ));
                    iter.Next();
                    continue;
                }

                PROPVARIANT * ppvType = pVarType->GetValue();
                ULONG type;

                if ( ppvType->vt == VT_LPWSTR )
                {
                    CQueryScanner scan( ppvType->pwszVal, FALSE );

                    BOOL fEnd;

                    if ( !scan.GetNumber( type, fEnd ) )
                    {
                        ciGibDebugOut(( DEB_WARN, "Improper CACHETYPE type: \"%ws\".\n", ppvType->pwszVal ));
                        iter.Next();
                        continue;
                    }
                }
                else
                {
                    ciGibDebugOut(( DEB_WARN, "Improper CACHETYPE size (type = %d).\n", ppvType->vt ));
                    iter.Next();
                    continue;
                }

                ciGibDebugOut(( DEB_WARN, "Add/change %ws\n", pwcsName ));

                //
                // If IDA were the future...
                // Need to allow primary or secondary store to be chosen!
                // Also allow the ability to set true/false for prop meta info
                // modifiability.
                //

                SCODE sc = SetupCacheEx( ps.CastToStruct(),
                                         type,
                                         cb,
                                         ulToken,
                                         TRUE,
                                         SECONDARY_STORE,
                                         wcsCatalog.GetPointer(),
                                         wcsCatalog.GetPointer(),
                                         wcsMachine.GetPointer() );

                if ( FAILED(sc) )
                {
                    ciGibDebugOut(( DEB_ERROR, "Error 0x%x modifying cache\n", sc ));
                    THROW( CException( sc ) );
                }

                fSawOne       = TRUE;
            }

            iter.Next();
        }

        sc = EndCacheTransaction( ulToken,
                                  fSawOne,
                                  wcsCatalog.GetPointer(),
                                  wcsCatalog.GetPointer(),
                                  wcsMachine.GetPointer() );

        if ( FAILED(sc) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error 0x%x completing cache transaction.\n", sc ));
            THROW( CException( sc ) );
        }
        break;
    }

    case CIDAFile::CiState:
    {
        //
        // Populate the variable set.
        //

        CStorageVariant var;

        var.SetUI4( TheWebQueryCache.Hits() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_HITS, var, 0 );

        var.SetUI4( TheWebQueryCache.Misses() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_MISSES, var, 0 );

        var.SetUI4( TheWebQueryCache.Running() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_ACTIVE, var, 0 );

        var.SetUI4( TheWebQueryCache.Cached() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_COUNT, var, 0 );

        var.SetUI4( TheWebPendingRequestQueue.Count() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_PENDING, var, 0 );

        var.SetUI4( TheWebQueryCache.Rejected() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_REJECTED, var, 0 );

        var.SetUI4( TheWebQueryCache.Total() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_TOTAL, var, 0 );

        var.SetUI4( TheWebQueryCache.QPM() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_QPM, var, 0 );

        //
        // Fetch CI state.
        //

        CI_STATE sState;
        sState.cbStruct = sizeof(sState);

        SCODE sc = CIState ( wcsCatalog.GetPointer(),
                             wcsMachine.GetPointer(),
                             &sState );

        if ( FAILED(sc) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error 0x%x getting CI state.\n", sc ));
            THROW( CException( sc ) );
        }

        var.SetUI4( sState.cWordList );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_WORDLISTS, var, 0 );

        var.SetUI4( sState.cPersistentIndex );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_PERSINDEX, var, 0 );

        var.SetUI4( sState.cQueries );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_QUERIES, var, 0 );

        var.SetUI4( sState.cDocuments );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_TOFILTER, var, 0 );

        var.SetUI4( sState.cFreshTest );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_FRESHTEST, var, 0 );

        var.SetUI4( sState.dwMergeProgress );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_MERGE_PROGRESS, var, 0 );

        var.SetUI4( sState.cPendingScans );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_PENDINGSCANS, var, 0 );

        var.SetUI4( sState.cFilteredDocuments );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_FILTERED, var, 0 );

        var.SetUI4( sState.cTotalDocuments );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_TOTAL, var, 0 );

        var.SetUI4( sState.cUniqueKeys );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_UNIQUE, var, 0 );

        var.SetUI4( sState.dwIndexSize );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_SIZE, var, 0 );

        if ( sState.eState & CI_STATE_SHADOW_MERGE )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_SHADOWMERGE, var, 0 );

        if ( sState.eState & CI_STATE_MASTER_MERGE )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_MASTERMERGE, var, 0 );

        if ( sState.eState & CI_STATE_ANNEALING_MERGE )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_ANNEALINGMERGE, var, 0 );

        if ( sState.eState & CI_STATE_CONTENT_SCAN_REQUIRED )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_SCANREQUIRED, var, 0 );

        if ( sState.eState & CI_STATE_SCANNING )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_SCANNING, var, 0 );

        if ( sState.eState & CI_STATE_RECOVERING )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_RECOVERING, var, 0 );

        //
        // Now that we've got the variables, we can parse the file.
        //

        SuccessHTX.ParseFile( wcsPhysicalName, VarSet, OutputFormat );

        if ( SuccessHTX.DoesDetailSectionExist() )
        {
            THROW( CIDQException(MSG_CI_IDA_TEMPLATE_DETAIL_SECTION, 0) );
        }

        break;
    }

    case CIDAFile::ForceMerge:
    {
        SuccessHTX.ParseFile( wcsPhysicalName, VarSet, OutputFormat );

        if ( SuccessHTX.DoesDetailSectionExist() )
        {
            THROW( CIDQException(MSG_CI_IDA_TEMPLATE_DETAIL_SECTION, 0) );
        }

        SCODE sc = ForceMasterMerge( wcsCatalog.GetPointer(),  // Drive
                                     wcsCatalog.GetPointer(),  // Catalog
                                     wcsMachine.GetPointer(),  // Machine
                                     1 );                      // Partition

        if ( FAILED(sc) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error 0x%x calling ForceMerge for %ws\n",
                            sc, wcsCatalog.GetPointer() ));
            THROW( CException( sc ) );
        }
        break;
    }
    }

    //
    //  Set CiQueryTime
    //
    ULONG cwcQueryTime = 40;
    SYSTEMTIME QueryTime;
    GetLocalTime( &QueryTime );

    XArray<WCHAR> wcsQueryTime(cwcQueryTime+1);
    cwcQueryTime = OutputFormat.FormatTime( QueryTime,
                                            wcsQueryTime.GetPointer(),
                                            cwcQueryTime );

    //
    //  SetCiQueryDate
    //
    ULONG cwcQueryDate = 40;
    XArray<WCHAR> wcsQueryDate(cwcQueryDate+1);
    cwcQueryDate = OutputFormat.FormatDate( QueryTime,
                                            wcsQueryDate.GetPointer(),
                                            cwcQueryDate );


    VarSet.AcquireStringValue( ISAPI_CI_QUERY_TIME, wcsQueryTime.GetPointer(), 0 );
    wcsQueryTime.Acquire();

    VarSet.AcquireStringValue( ISAPI_CI_QUERY_DATE, wcsQueryDate.GetPointer(), 0 );
    wcsQueryDate.Acquire();

    //
    //  Set CiQueryTimeZone
    //
    TIME_ZONE_INFORMATION TimeZoneInformation;
    DWORD dwResult = GetTimeZoneInformation( &TimeZoneInformation );
    LPWSTR pwszTimeZoneName = 0;

    if ( TIME_ZONE_ID_DAYLIGHT == dwResult )
    {
        pwszTimeZoneName = TimeZoneInformation.DaylightName;
    }
    else if ( 0xFFFFFFFF == dwResult )
    {
#       if CIDBG == 1
           DWORD dwError = GetLastError();
           ciGibDebugOut(( DEB_ERROR, "Error %d from GetTimeZoneInformation.\n", dwError ));
           THROW(CException( HRESULT_FROM_WIN32(dwError) ));
#       else
           THROW( CException() );
#       endif
    }
    else
    {
        pwszTimeZoneName = TimeZoneInformation.StandardName;
    }

    VarSet.CopyStringValue( ISAPI_CI_QUERY_TIMEZONE, pwszTimeZoneName, 0);

    //
    //  Set CiCatalog, CiLocale and CiTemplate
    //
    VarSet.AcquireStringValue( ISAPI_CI_CATALOG, wcsCiCatalog.GetPointer(), 0 );
    wcsCiCatalog.Acquire();

    VarSet.AcquireStringValue( ISAPI_CI_LOCALE, wcsLocale.GetPointer(), 0 );
    wcsLocale.Acquire();

    VarSet.CopyStringValue( ISAPI_CI_TEMPLATE, SuccessHTX.GetVirtualName(), 0 );


    //
    // If we got here, then all changes succeeded and we build success page.
    //

    SuccessHTX.GetHeader( vsResults, VarSet, OutputFormat );
    SuccessHTX.GetFooter( vsResults, VarSet, OutputFormat );
}

BOOL ParseGuid( WCHAR const * pwcsGuid, GUID & guid )
{
    unsigned cc = wcslen( pwcsGuid );

    if ( cc < ccStringizedGuid ||
         L'-' != pwcsGuid[8] ||
         L'-' != pwcsGuid[13] ||
         L'-' != pwcsGuid[18] ||
         L'-' != pwcsGuid[23] )
    {
        ciGibDebugOut(( DEB_WARN, "Improperly formatted guid %ws\n", pwcsGuid ));
        return FALSE;
    }

    //
    // Copy into local, editable, storage
    //

    WCHAR wcsGuid[ccStringizedGuid + 1];

    RtlCopyMemory( wcsGuid, pwcsGuid, (ccStringizedGuid + 1) * sizeof(WCHAR) );
    wcsGuid[ccStringizedGuid] = 0;

    wcsGuid[8] = 0;
    WCHAR * pwcStart = &wcsGuid[0];
    WCHAR * pwcEnd;
    guid.Data1 = wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 8 )   // The 1st number MUST be 8 digits long
        return FALSE;

    wcsGuid[13] = 0;
    pwcStart = &wcsGuid[9];
    guid.Data2 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 4 ) //  The 2nd number MUST be 4 digits long
        return FALSE;

    wcsGuid[18] = 0;
    pwcStart = &wcsGuid[14];
    guid.Data3 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 4 ) //  The 3rd number MUST be 4 digits long
        return FALSE;

    WCHAR wc = wcsGuid[21];
    wcsGuid[21] = 0;
    pwcStart = &wcsGuid[19];
    guid.Data4[0] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 2 ) //  The 4th number MUST be 4 digits long
        return FALSE;
    wcsGuid[21] = wc;

    wcsGuid[23] = 0;
    pwcStart = &wcsGuid[21];
    guid.Data4[1] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 2 ) //  The 4th number MUST be 4 digits long
        return FALSE;

    for ( unsigned i = 0; i < 6; i++ )
    {
        wc = wcsGuid[26+i*2];
        wcsGuid[26+i*2] = 0;
        pwcStart = &wcsGuid[24+i*2];
        guid.Data4[2+i] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
        if ( pwcStart == pwcEnd )
            return FALSE;

        wcsGuid[26+i*2] = wc;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckAdminSecurity, public
//
//  Synopsis:   Checks to see if the client has administrative access.
//
//  Arguments:  [pwszMachine] - machine name
//
//  Returns:    Nothing, throws if access is denied.
//
//  Notes:      The ACL on the HKEY_CURRENT_MACHINE\system\CurrentControlSet\
//              Control\ContentIndex registry key is used to determine if
//              access is permitted.
//
//              The access check is only done when the administrative operation
//              is local.  Otherwise, it will be checked in the course of doing
//              the administrative operation.
//
//  History:    26 Jun 96   AlanW       Created.
//
//----------------------------------------------------------------------------

void CheckAdminSecurity( WCHAR const * pwszMachine )
{
    HKEY hNewKey = (HKEY) INVALID_HANDLE_VALUE;

    if ( 0 != wcscmp( pwszMachine, CATURL_LOCAL_MACHINE ) )
        return;

    LONG dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 wcsRegAdminSubKey,
                                 0,
                                 KEY_WRITE,
                                 &hNewKey );

    if ( ERROR_SUCCESS == dwError )
    {
        RegCloseKey( hNewKey );
    }
    else if ( ERROR_ACCESS_DENIED == dwError )
    {
        THROW(CException( STATUS_ACCESS_DENIED ) );
    }
    else
    {
        ciGibDebugOut(( DEB_ERROR,
                        "Can not open reg key %ws, error %d\n",
                        wcsRegAdminSubKey, dwError ));
        THROW(CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\idqreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002.
//
//  File:       idqreg.cxx
//
//  Contents:   CIdqRegParams class
//
//  History:    22 Oct 97   AlanW       Created from params.cxx
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <regacc.hxx>
#include <params.hxx>


const WCHAR * IS_DEFAULT_CATALOG_DIRECTORY = L"web";


//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegParams::CIdqRegParams, public
//
//  Synopsis:   Constructor for registry param object
//
//  Arguments:  - NONE -
//
//  History:    12-Oct-96 dlee  Created
//
//--------------------------------------------------------------------------

CIdqRegParams::CIdqRegParams( )
{
    SetDefault();

    Refresh( );
} //CIdqRegParams

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegVars::SetDefault, public
//
//  Synopsis:   Sets default values for registry params
//
//  History:    12-Oct-96 dlee  Added header
//
//--------------------------------------------------------------------------

void CIdqRegVars::SetDefault()
{
    _maxISRowsInResultSet = IS_MAX_ROWS_IN_RESULT_DEFAULT;
    _maxISQueryCache = IS_MAX_ENTRIES_IN_CACHE_DEFAULT;
    _ISFirstRowsInResultSet = IS_FIRST_ROWS_IN_RESULT_DEFAULT;
    _ISCachePurgeInterval = IS_QUERY_CACHE_PURGE_INTERVAL_DEFAULT;
    _ISRequestQueueSize = IS_QUERY_REQUEST_QUEUE_SIZE_DEFAULT;
    _ISRequestThresholdFactor = IS_QUERY_REQUEST_THRESHOLD_FACTOR_DEFAULT;
    _ISDateTimeFormatting = IS_QUERY_DATETIME_FORMATTING_DEFAULT;
    _ISDateTimeLocal = IS_QUERY_DATETIME_LOCAL_DEFAULT;
    _maxActiveQueryThreads = CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT;
    wcscpy( _awcISDefaultCatalog, IS_DEFAULT_CATALOG_DIRECTORY );
} //SetDefault

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegParams::_ReadValues, private
//
//  Synopsis:   Reads values for variables
//
//  History:    12-Oct-96 dlee  Added header
//
//--------------------------------------------------------------------------

void CIdqRegParams::_ReadValues(
    CRegAccess & reg,
    CIdqRegVars & vars )
{
    vars._maxISRowsInResultSet     = reg.Read(wcsISMaxRecordsInResultSet, IS_MAX_ROWS_IN_RESULT_DEFAULT);
    vars._maxISQueryCache          = reg.Read(wcsISMaxEntriesInQueryCache, IS_MAX_ENTRIES_IN_CACHE_DEFAULT);
    vars._ISFirstRowsInResultSet   = reg.Read(wcsISFirstRowsInResultSet, IS_FIRST_ROWS_IN_RESULT_DEFAULT);
    vars._ISCachePurgeInterval     = reg.Read(wcsISQueryCachePurgeInterval, IS_QUERY_CACHE_PURGE_INTERVAL_DEFAULT);
    vars._ISRequestQueueSize       = reg.Read(wcsISRequestQueueSize, IS_QUERY_REQUEST_QUEUE_SIZE_DEFAULT);
    vars._ISRequestThresholdFactor = reg.Read(wcsISRequestThresholdFactor, IS_QUERY_REQUEST_THRESHOLD_FACTOR_DEFAULT);
    vars._ISDateTimeFormatting     = reg.Read(wcsISDateTimeFormatting, IS_QUERY_DATETIME_FORMATTING_DEFAULT);
    vars._ISDateTimeLocal          = reg.Read(wcsISDateTimeLocal, IS_QUERY_DATETIME_LOCAL_DEFAULT);
    vars._maxActiveQueryThreads    = reg.Read(wcsMaxActiveQueryThreads, CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT);

    XPtrST<WCHAR> xwszISDefaultCatalog( reg.Read(wcsISDefaultCatalogDirectory, IS_DEFAULT_CATALOG_DIRECTORY) );
    wcsncpy( vars._awcISDefaultCatalog, xwszISDefaultCatalog.GetPointer(), MAX_PATH );
} //_ReadValues

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegVars::_StoreNewValues, private
//
//  Synopsis:   Transfers range-checked values
//
//  History:    12-Oct-96 dlee  Added header
//
//--------------------------------------------------------------------------

void CIdqRegParams::_StoreNewValues(CIdqRegVars & vars )
{
    InterlockedExchange( (long *) &_maxISRowsInResultSet, Range( vars._maxISRowsInResultSet, IS_MAX_ROWS_IN_RESULT_MIN, IS_MAX_ROWS_IN_RESULT_MAX ) );
    InterlockedExchange( (long *) &_maxISQueryCache, Range( vars._maxISQueryCache, IS_MAX_ENTRIES_IN_CACHE_MIN, IS_MAX_ENTRIES_IN_CACHE_MAX ) );
    InterlockedExchange( (long *) &_ISFirstRowsInResultSet, Range( vars._ISFirstRowsInResultSet, IS_FIRST_ROWS_IN_RESULT_MIN, IS_FIRST_ROWS_IN_RESULT_MAX ) );
    InterlockedExchange( (long *) &_ISCachePurgeInterval, Range( vars._ISCachePurgeInterval, IS_QUERY_CACHE_PURGE_INTERVAL_MIN, IS_QUERY_CACHE_PURGE_INTERVAL_MAX ) );
    InterlockedExchange( (long *) &_ISRequestQueueSize, Range( vars._ISRequestQueueSize, IS_QUERY_REQUEST_QUEUE_SIZE_MIN, IS_QUERY_REQUEST_QUEUE_SIZE_MAX ) );
    InterlockedExchange( (long *) &_ISRequestThresholdFactor, Range( vars._ISRequestThresholdFactor, IS_QUERY_REQUEST_THRESHOLD_FACTOR_MIN, IS_QUERY_REQUEST_THRESHOLD_FACTOR_MAX ) );
    InterlockedExchange( (long *) &_ISDateTimeFormatting, Range( vars._ISDateTimeFormatting, IS_QUERY_DATETIME_FORMATTING_MIN, IS_QUERY_DATETIME_FORMATTING_MAX ) );
    InterlockedExchange( (long *) &_ISDateTimeLocal, vars._ISDateTimeLocal );
    InterlockedExchange( (long *) &_maxActiveQueryThreads, Range( vars._maxActiveQueryThreads, CI_MAX_ACTIVE_QUERY_THREADS_MIN, CI_MAX_ACTIVE_QUERY_THREADS_MAX ) );

    wcscpy( _awcISDefaultCatalog, vars._awcISDefaultCatalog );
} //_StoreNewValues

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegParams::Refresh, public
//
//  Synopsis:   Reads the values from the registry
//
//  History:    12-Oct-96 dlee  Added header, reorganized
//
//--------------------------------------------------------------------------

void CIdqRegParams::Refresh(
    BOOL             fUseDefaultsOnFailure )
{
    // Grab the lock so no other writers try to update at the same time

    CIdqRegVars newVals;
    CLock lock( _mutex );

    TRY
    {
        //  Query the registry.

        CRegAccess regAdmin( RTL_REGISTRY_CONTROL, wcsRegAdmin );

        _ReadValues( regAdmin, newVals );
        _StoreNewValues( newVals );
    }
    CATCH (CException, e)
    {
        // Only store defaults when told to do so -- the params
        // are still in good shape at this point and are more
        // accurate than the default settings.

        if ( fUseDefaultsOnFailure )
        {
            newVals.SetDefault();
            _StoreNewValues( newVals );
        }
    }
    END_CATCH
} //Refresh
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\idq.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:   idq.cxx
//
//  Contents:   Parser for an IDQ file
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//
//  These hash values MUST be unique.  They have been calculated to be
//  unique via the ISAPI_IDQHash function below.
//
//  If the spelling of a IDQ variable name is changed, or a new variable
//  is added to the list, this table must be re-generated using the
//  code supplied below.
//
static const ULONG ISAPI_CIBOOLVECTORPREFIX_HASH        = 0x1174d5c;
static const ULONG ISAPI_CIBOOLVECTORSEPARATOR_HASH     = 0x8ba6b1d;
static const ULONG ISAPI_CIBOOLVECTORSUFFIX_HASH        = 0x1174df4;
static const ULONG ISAPI_CICATALOG_HASH                 = 0x89c6;
static const ULONG ISAPI_CICOLUMNS_HASH                 = 0x8bb4;
static const ULONG ISAPI_CICURRENCYVECTORPREFIX_HASH    = 0x119add60;
static const ULONG ISAPI_CICURRENCYVECTORSEPARATOR_HASH = 0x8cd6eb21;
static const ULONG ISAPI_CICURRENCYVECTORSUFFIX_HASH    = 0x119addf8;
static const ULONG ISAPI_CICURRENTPAGENUMBER_HASH       = 0x233792f;
static const ULONG ISAPI_CICURRENTRECORDNUMBER_HASH     = 0x8ce0671;
static const ULONG ISAPI_CIDATEVECTORPREFIX_HASH        = 0x114fd5c;
static const ULONG ISAPI_CIDATEVECTORSEPARATOR_HASH     = 0x8a7eb1d;
static const ULONG ISAPI_CIDATEVECTORSUFFIX_HASH        = 0x114fdf4;
static const ULONG ISAPI_CIFORCEUSECI_HASH              = 0x46337;
static const ULONG ISAPI_CIDEFERTRIMMING_HASH           = 0x8a26e6f8;
static const ULONG ISAPI_CIDIALECT_HASH                 = 0x8a07;
static const ULONG ISAPI_CIFLAGS_HASH                   = 0x228c;
static const ULONG ISAPI_CILOCALE_HASH                  = 0x4631;
static const ULONG ISAPI_CIMATCHEDRECORDCOUNT_HASH      = 0x4639280;
static const ULONG ISAPI_CIMAXRECORDSINRESULTSET_HASH   = 0x2349b581;
static const ULONG ISAPI_CIMAXRECORDSPERPAGE_HASH       = 0x2349baa;
static const ULONG ISAPI_CIFIRSTROWSINRESULTSET_HASH    = 0x118dc580;   
static const ULONG ISAPI_CINUMBERVECTORPREFIX_HASH      = 0x476ad5e;
static const ULONG ISAPI_CINUMBERVECTORSEPARATOR_HASH   = 0x23b56b1f;
static const ULONG ISAPI_CINUMBERVECTORSUFFIX_HASH      = 0x476adf6;
static const ULONG ISAPI_CIRESTRICTION_HASH             = 0x8ed8d;
static const ULONG ISAPI_CISCOPE_HASH                   = 0x2350;
static const ULONG ISAPI_CISORT_HASH                    = 0x11c2;
static const ULONG ISAPI_CISTRINGVECTORPREFIX_HASH      = 0x4845d5e;
static const ULONG ISAPI_CISTRINGVECTORSEPARATOR_HASH   = 0x2422eb1f;
static const ULONG ISAPI_CISTRINGVECTORSUFFIX_HASH      = 0x4845df6;
static const ULONG ISAPI_CITEMPLATE_HASH                = 0x11d3b;
static const ULONG ISAPI_CICANONICALOUTPUT_HASH         = 0x8a0c9f;
static const ULONG ISAPI_CIDONTTIMEOUT_HASH             = 0x8c55f;

#if 0

//
//  Use the following routine to verify the above hash values are perfect.
//
//+---------------------------------------------------------------------------
//
//  Function:   main - program entry point; used to verify perfect hash
//
//----------------------------------------------------------------------------
int __cdecl main( int argc, char ** argv )
{
    ULONG aHash[100];
    Win4Assert( 100 > cISAPI_CiParams );

    for (unsigned i=0; i<cISAPI_CiParams; i++)
    {
        aHash[i] = ISAPI_IDQHash( aISAPI_CiParams[i] );
    }


    for (i=0; i<cISAPI_CiParams-1; i++)
    {
        for (unsigned j=i+1; j<cISAPI_CiParams; j++)
        {
            if ( aHash[i] == aHash[j] )
            {
                printf( "Hash collision between %ls(0x%x) and %ls(0x%x)\n",
                         aISAPI_CiParams[i],
                         aHash[i],
                         aISAPI_CiParams[j],
                         aHash[j] );
            }
        }
    }

    printf ("Hash table: Copy this as necessary into idq\\idq.cxx\n");
    for (i=0; i<cISAPI_CiParams; i++)
    {
        printf("static const ULONG ISAPI_%ws_HASH\t= 0x%x;\n", aISAPI_CiParams[i], aHash[i] );
    }

    return 0;
}

#endif  // 0

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::CIDQFile - public constructor
//
//  Synopsis:   Builds a CIDQFile object, initializes values
//
//  Arguments:  [wcsFileName] -- full path to IDQ file
//              [codePage]    -- code page to translate IDQ file
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CIDQFile::CIDQFile( WCHAR const * wcsFileName,
                    UINT codePage,
                    CSecurityIdentity const & securityIdentity )
        : _wcsRestriction(0),
          _wcsDialect(0),
          _wcsScope(0),
          _wcsSort(0),
          _wcsColumns(0),
          _wcsLocale(0),
          _wcsHTXFileName(0),
          _wcsMaxRecordsInResultSet(0),
          _wcsMaxRecordsPerPage(0),
          _wcsFirstRowsInResultSet(0),
          _wcsCatalog(0),
          _wcsForceUseCi(0),
          _wcsDeferTrimming(0),
          _wcsCanonicalOutput(0),
          _wcsDontTimeout(0),
          _wcsCiFlags(0),
          _wcsBoolVectorPrefix(0),
          _wcsBoolVectorSeparator(0),
          _wcsBoolVectorSuffix(0),
          _wcsCurrencyVectorPrefix(0),
          _wcsCurrencyVectorSeparator(0),
          _wcsCurrencyVectorSuffix(0),
          _wcsDateVectorPrefix(0),
          _wcsDateVectorSeparator(0),
          _wcsDateVectorSuffix(0),
          _wcsNumberVectorPrefix(0),
          _wcsNumberVectorSeparator(0),
          _wcsNumberVectorSuffix(0),
          _wcsStringVectorPrefix(0),
          _wcsStringVectorSeparator(0),
          _wcsStringVectorSuffix(0),
          _cReplaceableParameters(0),
          _refCount(0),
          _codePage(codePage),
          _securityIdentity( securityIdentity )
{
    wcscpy( _wcsIDQFileName, wcsFileName );
}



//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::~CIDQFile - public destructor
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CIDQFile::~CIDQFile()
{
    Win4Assert( _refCount == 0 );

    delete _wcsRestriction;
    delete _wcsDialect;
    delete _wcsScope;
    delete _wcsSort;
    delete _wcsColumns;
    delete _wcsLocale;
    delete _wcsHTXFileName;
    delete _wcsMaxRecordsInResultSet;
    delete _wcsMaxRecordsPerPage;
    delete _wcsFirstRowsInResultSet;
    delete _wcsCatalog;
    delete _wcsCiFlags;
    delete _wcsForceUseCi;
    delete _wcsDeferTrimming;
    delete _wcsCanonicalOutput;
    delete _wcsDontTimeout;
    delete _wcsBoolVectorPrefix;
    delete _wcsBoolVectorSeparator;
    delete _wcsBoolVectorSuffix;
    delete _wcsCurrencyVectorPrefix;
    delete _wcsCurrencyVectorSeparator;
    delete _wcsCurrencyVectorSuffix;
    delete _wcsDateVectorPrefix;
    delete _wcsDateVectorSeparator;
    delete _wcsDateVectorSuffix;
    delete _wcsNumberVectorPrefix;
    delete _wcsNumberVectorSeparator;
    delete _wcsNumberVectorSuffix;
    delete _wcsStringVectorPrefix;
    delete _wcsStringVectorSeparator;
    delete _wcsStringVectorSuffix;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseFile, private
//
//  Synopsis:   Parses the given file and sets up the necessary variables
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CIDQFile::ParseFile()
{
    _xList.Set(new CLocalGlobalPropertyList( _codePage ));

    // We don't support impersonation for scripts.
    // It involves getting the server ip address, vpath and then using
    // that for impersonation

    Win4Assert( !IsNetPath( _wcsIDQFileName ) );

    //
    //  Now parse the query parameters
    //

    // Open the file in a TRY block, so we can make this an IDQ error
    // if the IDQ file isn't found.  Otherwise the error doesn't include
    // the IDQ filename.
    // For scoping reasons, the CFileMapView is new'ed, not on the stack.

    XPtr<CFileMapView> xMapView;

    TRY
    {
        xMapView.Set( new CFileMapView( _wcsIDQFileName ) );
        xMapView->Init();
    }
    CATCH( CException, e )
    {
        if ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == e.GetErrorCode() )
        {
            THROW( CIDQException( MSG_CI_IDQ_NOT_FOUND, 0 ) );
        }
        else
        {
            RETHROW();
        }
    }
    END_CATCH

    CFileBuffer idqFile( xMapView.GetReference(), _codePage );

    //
    //  Save the last write time of this file.
    //

    SCODE sc = GetLastWriteTime( _wcsIDQFileName, _ftIDQLastWriteTime );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    //
    //  Process a line at a time, look for either the [Names] or the [Query]
    //  section and process lines within those sections.
    //

    BOOL fQuerySection = FALSE;
    BOOL fNamesSection = FALSE;
    int iLine = 0;                  // Start counting at line #1

    for( ;; )
    {
        iLine++;
        XGrowable<WCHAR> xLine;

        ULONG cwcChar = idqFile.fgetsw( xLine );

        if ( 0 == cwcChar )
        {
            break;
        }

        WCHAR *pwcLine = xLine.Get();

        //
        //  Skip ahead until we find a [Query] section
        //
        if ( L'[' == *pwcLine )
        {
            if (_wcsnicmp(pwcLine+1, L"Query]", 6) == 0 )
            {
                fQuerySection = TRUE;
                continue;
            }
            else if (_wcsnicmp(pwcLine+1, L"Names]", 6) == 0 )
            {
                fNamesSection = TRUE;
                continue;
            }
            else
            {
                fQuerySection = fNamesSection = FALSE;
                continue;
            }
        }
        else if ( L'#' == *pwcLine )
        {
            continue;
        }


        

        if ( fQuerySection )
        {
            CQueryScanner scanner( pwcLine, FALSE );
            ParseOneLine( scanner, iLine );
        }
        else if (fNamesSection)
        {
            XPtr<CPropEntry> propentry;

            CQueryScanner scanner( pwcLine, FALSE );
            CPropertyList::ParseOneLine(scanner, iLine, propentry);
            if (propentry.GetPointer())
            {
                _xList->AddEntry( propentry.GetPointer(), iLine );
                propentry.Acquire();
            }
        }
    }

    //
    //  Verify that the minimum set of parameters are specified.
    //

    //
    //  We must have all of the following:
    //
    //      - a restriction
    //      - a scope
    //      - a template (HTX) file
    //      - output columns
    //

    if ( 0 == _wcsRestriction )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "Restriction not found in IDQ file\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_RESTRICTION, 0) );
    }
    else if ( 0 == _wcsScope )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "Scope not found in IDQ file\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_SCOPE, 0) );
    }
    else if ( 0 == _wcsHTXFileName && !IsCanonicalOutput() )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "HTX filename not found in IDQ file\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_TEMPLATEFILE, 0) );
    }
    else if ( 0 == _wcsColumns )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "Output columns not found in IDQ file\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_OUTPUTCOLUMNS, 0) );
    }

    //
    //  If no catalog was specified, use the default catalog in the registry
    //
    if ( 0 == _wcsCatalog )
    {
        ciGibDebugOut(( DEB_ITRACE, "Using default catalog\n" ));

        WCHAR awcTmp[ MAX_PATH ];
        ULONG cwcRequired = TheIDQRegParams.GetISDefaultCatalog( awcTmp,
                                                                 MAX_PATH );
        if ( cwcRequired > MAX_PATH )
            THROW( CException(STATUS_INVALID_PARAMETER) );

        cwcRequired++; // make room for termination
        _wcsCatalog = new WCHAR[ cwcRequired ];
        RtlCopyMemory( _wcsCatalog, awcTmp, cwcRequired * sizeof WCHAR );
    }

}



//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseOneLine, private
//
//  Synopsis:   Parses one line of the IDQ file
//
//  Arguments:  [scan]   -- scanner initialized with the current line
//              [iLine]  -- current line number
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------

void CIDQFile::ParseOneLine( CQueryScanner & scan,
                             unsigned iLine )
{
    //
    //  Is this a comment line (does it start with #) or an empty line?
    //
    if ( scan.LookAhead() == PROP_REGEX_TOKEN || scan.LookAhead() == EOS_TOKEN )
    {
        return;
    }

    if ( scan.LookAhead() != TEXT_TOKEN )    //  Better be a word
    {
        // Report an error
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_NAME, iLine ) );
    }

    XPtrST<WCHAR> wcsAttribute( scan.AcqWord() );

    if( wcsAttribute.GetPointer() == 0 )                  // Better find a word
    {
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_TYPE, iLine ) );
    }

    scan.Accept();

    if ( scan.LookAhead() != EQUAL_TOKEN )
    {
        // Report an error
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_EQUAL, iLine ) );
    }

    scan.Accept();


    //
    //  Convert the string to upper-case and HASH it. Lookup the hashed value.
    //  Note that this code assumes the HASH IS PERFECT.  Whenever a IDQ
    //  variable is renamed or added, this assumption may no-longer be true.
    //  Check it out with the above program.
    //
    //  This code essentially replaces 25 wcsicmp functions; or an average
    //  of 12.5 wscicmp calls per line in the IDQ file.
    //
    Win4Assert( ISAPI_CICOLUMNS_HASH == ISAPI_IDQHash(ISAPI_CI_COLUMNS) );
    Win4Assert( ISAPI_CIFLAGS_HASH == ISAPI_IDQHash(ISAPI_CI_FLAGS) );
    Win4Assert( ISAPI_CIMAXRECORDSINRESULTSET_HASH == ISAPI_IDQHash(ISAPI_CI_MAX_RECORDS_IN_RESULTSET) );
    Win4Assert( ISAPI_CIMAXRECORDSPERPAGE_HASH == ISAPI_IDQHash(ISAPI_CI_MAX_RECORDS_PER_PAGE) );
    Win4Assert( ISAPI_CIFIRSTROWSINRESULTSET_HASH == ISAPI_IDQHash(ISAPI_CI_FIRST_ROWS_IN_RESULTSET) );
    Win4Assert( ISAPI_CIRESTRICTION_HASH == ISAPI_IDQHash(ISAPI_CI_RESTRICTION) );
    Win4Assert( ISAPI_CIDIALECT_HASH == ISAPI_IDQHash(ISAPI_CI_DIALECT) );
    Win4Assert( ISAPI_CISCOPE_HASH == ISAPI_IDQHash(ISAPI_CI_SCOPE) );
    Win4Assert( ISAPI_CISORT_HASH == ISAPI_IDQHash(ISAPI_CI_SORT) );
    Win4Assert( ISAPI_CITEMPLATE_HASH == ISAPI_IDQHash(ISAPI_CI_TEMPLATE) );
    Win4Assert( ISAPI_CICATALOG_HASH == ISAPI_IDQHash(ISAPI_CI_CATALOG) );
    Win4Assert( ISAPI_CILOCALE_HASH == ISAPI_IDQHash(ISAPI_CI_LOCALE) );
    Win4Assert( ISAPI_CIBOOLVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_BOOL_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CIBOOLVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_BOOL_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CIBOOLVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_BOOL_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CICURRENCYVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_CURRENCY_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CICURRENCYVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_CURRENCY_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CICURRENCYVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_CURRENCY_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CIDATEVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_DATE_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CIDATEVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_DATE_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CIDATEVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_DATE_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CINUMBERVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_NUMBER_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CINUMBERVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_NUMBER_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CINUMBERVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_NUMBER_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CISTRINGVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_STRING_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CISTRINGVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_STRING_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CISTRINGVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_STRING_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CIFORCEUSECI_HASH == ISAPI_IDQHash(ISAPI_CI_FORCE_USE_CI) );
    Win4Assert( ISAPI_CIDEFERTRIMMING_HASH == ISAPI_IDQHash(ISAPI_CI_DEFER_NONINDEXED_TRIMMING ) );
    Win4Assert( ISAPI_CICANONICALOUTPUT_HASH == ISAPI_IDQHash(ISAPI_CI_CANONICAL_OUTPUT ) );
    Win4Assert( ISAPI_CIDONTTIMEOUT_HASH == ISAPI_IDQHash(ISAPI_CI_DONT_TIMEOUT ) );

    _wcsupr( wcsAttribute.GetPointer() );
    ULONG ulHash = ISAPI_IDQHash( wcsAttribute.GetPointer() );

    switch ( ulHash )
    {
    case  ISAPI_CICOLUMNS_HASH:
        GetStringValue( scan, iLine, &_wcsColumns );
    break;

    case ISAPI_CIFLAGS_HASH:
        GetStringValue( scan, iLine, &_wcsCiFlags );
    break;

    case ISAPI_CIMAXRECORDSINRESULTSET_HASH:
        GetStringValue( scan, iLine, &_wcsMaxRecordsInResultSet );
    break;

    case ISAPI_CIMAXRECORDSPERPAGE_HASH:
        GetStringValue( scan, iLine, &_wcsMaxRecordsPerPage );
    break;

    case ISAPI_CIFIRSTROWSINRESULTSET_HASH:
        GetStringValue( scan, iLine, &_wcsFirstRowsInResultSet );
    break;

    case ISAPI_CIRESTRICTION_HASH:
        GetStringValue( scan, iLine, &_wcsRestriction );
    break;

    case ISAPI_CIDIALECT_HASH:
        GetStringValue( scan, iLine, &_wcsDialect );
    break;

    case ISAPI_CISCOPE_HASH:
        GetStringValue( scan, iLine, &_wcsScope, FALSE );
    break;

    case ISAPI_CISORT_HASH:
        GetStringValue( scan, iLine, &_wcsSort );
    break;

    case ISAPI_CITEMPLATE_HASH:
        GetStringValue( scan, iLine, &_wcsHTXFileName );
    break;

    case ISAPI_CICATALOG_HASH:
        GetStringValue( scan, iLine, &_wcsCatalog );
    break;

    case ISAPI_CIBOOLVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsBoolVectorPrefix );
    break;

    case ISAPI_CIBOOLVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsBoolVectorSeparator );
    break;

    case ISAPI_CIBOOLVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsBoolVectorSuffix );
    break;

    case ISAPI_CICURRENCYVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsCurrencyVectorPrefix );
    break;

    case ISAPI_CICURRENCYVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsCurrencyVectorSeparator );
    break;

    case ISAPI_CICURRENCYVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsCurrencyVectorSuffix );
    break;

    case ISAPI_CIDATEVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsDateVectorPrefix );
    break;

    case ISAPI_CIDATEVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsDateVectorSeparator );
    break;

    case ISAPI_CIDATEVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsDateVectorSuffix );
    break;

    case ISAPI_CINUMBERVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsNumberVectorPrefix );
    break;

    case ISAPI_CINUMBERVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsNumberVectorSeparator );
    break;

    case ISAPI_CINUMBERVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsNumberVectorSuffix );
    break;

    case ISAPI_CISTRINGVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsStringVectorPrefix );
    break;

    case ISAPI_CISTRINGVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsStringVectorSeparator );
    break;

    case ISAPI_CISTRINGVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsStringVectorSuffix );
    break;

    case ISAPI_CIFORCEUSECI_HASH:
        GetStringValue( scan, iLine, &_wcsForceUseCi );
    break;

    case ISAPI_CIDEFERTRIMMING_HASH:
        GetStringValue( scan, iLine, &_wcsDeferTrimming );
    break;

    case ISAPI_CILOCALE_HASH:
        GetStringValue( scan, iLine, &_wcsLocale );
    break;

    case ISAPI_CICANONICALOUTPUT_HASH:
        GetStringValue( scan, iLine, &_wcsCanonicalOutput );
    break;

    case ISAPI_CIDONTTIMEOUT_HASH:
        GetStringValue( scan, iLine, &_wcsDontTimeout );
    break;

    default:


        //
        //  We've found a keyword/attribute that we don't support.
        //  Don't report an error. This will allow this version of the
        //  parser to work with newer .IDQ file versions with new parameters.
        //
        ciGibDebugOut(( DEB_ERROR,
                        "Invalid string in hash table for %ws; hash = 0x%x\n",
                        wcsAttribute.GetPointer(),
                        ulHash ));
    break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseColumns, public
//
//  Synopsis:   Parses the columns attribute
//
//  Arguments:  [wcsColumns]  -- string to convert
//              [variableSet] -- list of replaceable parameters
//              [varColumns]  -- Column variables returned here
//
//  Returns:    CDbColumns* - counted array of column IDs
//
//  History:    96/Jan/03   DwightKr    created
//              96/Feb/23   DwightKr    Add check for duplicate value
//              96/Mar/12   DwightKr    Made public
//              96/May/23   AlanW       Detect duplicate column names
//
//----------------------------------------------------------------------------

CDbColumns * CIDQFile::ParseColumns( WCHAR const * wcsColumns,
                                     CVariableSet & variableSet,
                                     CDynArray<WCHAR> & awcsColumns )
{
    return ::ParseStringColumns( wcsColumns,
                                 _xList.GetPointer(),
                                 GetUserDefaultLCID(),
                                 &variableSet,
                                 &awcsColumns );
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseFlags, private
//
//  Synopsis:   Parses the flags attribute
//
//  Arguments:  [wcsCiFlags] -- flags
//
//  History:    96/Jan/03   DwightKr    created
//              96/Apr/12   DwightKr    mad a replaceable parameter
//
//----------------------------------------------------------------------------
ULONG CIDQFile::ParseFlags( WCHAR const * wcsCiFlags )
{
    if ( 0 == wcsCiFlags )
    {
        return QUERY_DEEP;
    }

    ULONG ulFlags;

    if ( _wcsicmp(wcsCiFlags, L"SHALLOW") == 0 )
    {
        ulFlags = QUERY_SHALLOW;
    }
    else if ( _wcsicmp(wcsCiFlags, L"DEEP") == 0 )
    {
        ulFlags = QUERY_DEEP;
    }
    else
    {
        THROW( CIDQException(MSG_CI_IDQ_EXPECTING_SHALLOWDEEP, 0) );
    }

    return ulFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::IsCanonicalOutput
//
//  Synopsis:   Tests if canonical output is enabled.
//
//  Returns:    TRUE if canonical output is needed; FALSE o/w
//
//  History:    6-14-96   srikants   Created
//
//  Notes:      Assumed here that it is not a replaceable parameter.
//
//----------------------------------------------------------------------------

BOOL CIDQFile::IsCanonicalOutput() const
{
    if ( 0 == _wcsCanonicalOutput )
        return FALSE;

    return _wcsicmp(_wcsCanonicalOutput, L"TRUE") == 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::IsDontTimeout
//
//  Synopsis:   Specifies if the don't timeout parameter is true
//
//  History:    9-13-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CIDQFile::IsDontTimeout() const
{
    if ( 0 == _wcsDontTimeout )
        return FALSE;

    return _wcsicmp(_wcsDontTimeout, L"TRUE") == 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::GetStringValue - private
//
//  Synopsis:   Gets the string value on the currenct line
//
//  Arguments:  [scan]            -- scanner initialized with the current line
//              [iLine]           -- current line number
//              [pwcsStringValue] -- value to put string into
//              [fParseQuotes]    -- if TRUE, remove first and trailing quotes
//
//  History:    96/Jan/03   DwightKr    created
//              96/Feb/23   DwightKr    Add check for duplicate value
//
//----------------------------------------------------------------------------
void CIDQFile::GetStringValue( CQueryScanner & scan,
                               unsigned iLine,
                               WCHAR ** pwcsStringValue,
                               BOOL fParseQuotes )
{
    if ( 0 != *pwcsStringValue )
    {
        ciGibDebugOut(( DEB_IWARN,
                        "Duplicate CiXX=value in IDQ file on line #%d\n",
                        iLine ));
        THROW( CIDQException(MSG_CI_IDQ_DUPLICATE_ENTRY, iLine) );
    }

    *pwcsStringValue = scan.AcqLine( fParseQuotes );

    if ( IsAReplaceableParameter( *pwcsStringValue ) != eIsSimpleString )
    {
        _cReplaceableParameters++;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::IsCachedDataValid - public
//
//  Synopsis:   Determines if the IDQ file is still vaid, or has it
//              changed since it was last read.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CIDQFile::IsCachedDataValid()
{
    FILETIME ft;
    SCODE sc = GetLastWriteTime( _wcsIDQFileName, ft );

    // this usually fails because the file no longer exists

    if ( FAILED( sc ) )
        return FALSE;

    return ( (_ftIDQLastWriteTime.dwLowDateTime == ft.dwLowDateTime) &&
             (_ftIDQLastWriteTime.dwHighDateTime == ft.dwHighDateTime) );

}


//+---------------------------------------------------------------------------
//
//  Function:   GetLastWriteTime
//
//  Purpose:    Gets the last change time of the file specified
//
//  Arguments:  [wcsFileName] - name of file to get last write time of
//              [filetime]    - where the filetime is returned
//
//  Returns:    SCODE result
//
//  History:    96/Jan/23   DwightKr    Created
//              96/Mar/13   DwightKr    Changed to use GetFileAttributesEx()
//
//----------------------------------------------------------------------------
SCODE GetLastWriteTime(
    WCHAR const * wcsFileName,
    FILETIME &    filetime )
{
    Win4Assert( 0 != wcsFileName );

    // CImpersonateRemoteAccess imprsnat;
    // imprsnat.ImpersonateIf( wcsFileName );

    WIN32_FIND_DATA ffData;

    if ( !GetFileAttributesEx( wcsFileName, GetFileExInfoStandard, &ffData ) )
    {
        ULONG error = GetLastError();

        ciGibDebugOut(( DEB_IERROR,
                        "Unable to GetFileAttributesEx(%ws) GetLastError=0x%x\n",
                        wcsFileName,
                        error ));
        return HRESULT_FROM_WIN32( error );
    }

    filetime = ffData.ftLastWriteTime;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseForceUseCI - public
//
//  Synopsis:   Gets the TRUE/FALSE value for CiForceUseCI
//
//  Arguments:  [wcsForceUseCi] -- string to parse
//
//  History:    96/Mar/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CIDQFile::ParseForceUseCI( WCHAR const * wcsForceUseCi )
{
    if ( 0 == wcsForceUseCi )
    {
        return FALSE;
    }

    BOOL fForceUseCi;

    if ( _wcsicmp( wcsForceUseCi, L"FALSE" ) == 0 )
    {
        fForceUseCi = FALSE;
    }
    else if ( _wcsicmp( wcsForceUseCi, L"TRUE" ) == 0 )
    {
        fForceUseCi = TRUE;
    }
    else
    {
        THROW( CIDQException(MSG_CI_IDQ_EXPECTING_TRUEFALSE, 0) );
    }

    return fForceUseCi;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseDeferTrimming - public
//
//  Synopsis:   Gets the TRUE/FALSE value for CiDeferNonIndexedTrimming
//
//  Arguments:  [wcsDeferTrimming] -- string to parse
//
//  History:    96/Mar/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CIDQFile::ParseDeferTrimming( WCHAR const * wcsDeferTrimming )
{
    if ( 0 == wcsDeferTrimming )
    {
        return FALSE;
    }

    BOOL fDeferTrimming;

    if ( _wcsicmp( wcsDeferTrimming, L"FALSE" ) == 0 )
    {
        fDeferTrimming = FALSE;
    }
    else if ( _wcsicmp( wcsDeferTrimming, L"TRUE" ) == 0 )
    {
        fDeferTrimming = TRUE;
    }
    else
    {
        THROW( CIDQException(MSG_CI_IDQ_EXPECTING_TRUEFALSE, 0) );
    }

    return fDeferTrimming;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::GetVectorFormatting, public
//
//  Synopsis:   Sets up the vector formatting for output
//
//  Arguments:  [outputFormat] -- the output format object to setup
//
//  History:    96/Feb/26   DwightKr    created
//
//----------------------------------------------------------------------------
void CIDQFile::GetVectorFormatting( COutputFormat & outputFormat )
{
    outputFormat.SetBoolVectorFormat( _wcsBoolVectorPrefix,
                                      _wcsBoolVectorSeparator,
                                      _wcsBoolVectorSuffix );

    outputFormat.SetCurrencyVectorFormat( _wcsCurrencyVectorPrefix,
                                          _wcsCurrencyVectorSeparator,
                                          _wcsCurrencyVectorSuffix );

    outputFormat.SetDateVectorFormat( _wcsDateVectorPrefix,
                                      _wcsDateVectorSeparator,
                                      _wcsDateVectorSuffix );

    outputFormat.SetNumberVectorFormat( _wcsNumberVectorPrefix,
                                        _wcsNumberVectorSeparator,
                                        _wcsNumberVectorSuffix );

    outputFormat.SetStringVectorFormat( _wcsStringVectorPrefix,
                                        _wcsStringVectorSeparator,
                                        _wcsStringVectorSuffix );
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFileList::Find - public
//
//  Synopsis:   Finds a matching parsed IDQ file in list, or builds a new
//              one if a match can not be found.
//
//  Arguments:  [wcsFileName] -- full path to IDQ file
//              [codePage]    -- code page of parsed IDQ file
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
CIDQFile * CIDQFileList::Find( WCHAR const * wcsFileName,
                               UINT codePage,
                               CSecurityIdentity const & securityIdentity )
{
    //
    //  Refcount everything in the list so that we can examine the list
    //  outside of the lock.
    //

    ULONG      cItems;
    XArray<CIDQFile *> aIDQFile;

    // ==========================================
    {
        CLock lock( _mutex );

        cItems = _aIDQFile.Count();         // Save count of items to examine
        aIDQFile.Init( cItems );

        for (unsigned i=0; i<cItems; i++)
        {
            aIDQFile[i] = _aIDQFile[i];
            aIDQFile[i]->LokAddRef();
        }
    }
    // ==========================================

    // Can't throw while the .idq files are addref'ed -- remember the
    // error and throw it after the .idq files are released.
    // IsCachedDataValid() throws!

    SCODE sc = S_OK;
    CIDQFile * pIDQFile = 0;

    TRY
    {
        //
        //  Now walk though the list looking for a match; outside of the lock.
        //

        for (unsigned i=0; i<cItems; i++)
        {
            if ( (_wcsicmp(aIDQFile[i]->GetIDQFileName(), wcsFileName) == 0) &&
                 (aIDQFile[i]->GetCodePage() == codePage) &&
                 (aIDQFile[i]->IsCachedDataValid() )
               )
            {
                pIDQFile = aIDQFile[i];

                ciGibDebugOut(( DEB_ITRACE,
                                "A cached version of IDQ file %ws was found\n",
                                wcsFileName ));

                break;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    //
    //  If pIDQFile is non-0, we've found a match.  Decrement the ref-count
    //  for all items which did not match.
    //

    for (unsigned i=0; i<cItems; i++)
    {
        if ( pIDQFile != aIDQFile[i] )
        {
            aIDQFile[i]->Release();
        }
    }

    if ( S_OK != sc )
    {
        Win4Assert( 0 == pIDQFile );
        THROW( CException( sc ) );
    }

    //
    // We may have matched, but still not have access to this file.  First, make
    // a quick check for an exact match on security token, and then try harder
    // by opening the file.
    //

    if ( 0 != pIDQFile )
    {
        if ( !pIDQFile->CheckSecurity( securityIdentity ) )
        {
            HANDLE h = CreateFile( wcsFileName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   0,
                                   OPEN_EXISTING,
                                   0,
                                   0 );

            //
            // Don't try to determine here if security caused the problem.
            // Just let the standard exception handling below in file parsing
            // deal with the error.
            //

            if ( INVALID_HANDLE_VALUE == h )
            {
                pIDQFile->Release();
                pIDQFile = 0;
            }
            else
            {
                CloseHandle( h );

                //
                // Update the security token of the cached Idq file,
                // to optimize away the CreateFile check in two cases:
                //   1.  When the file is first parsed with admin
                //       privileges, and all subsequent queries are with
                //       anonymous privileges.
                //   2.  When the security token changes over time
                //
                pIDQFile->SetSecurityToken( securityIdentity );
            }
        }
    }

    //
    //  If we didn't find a match, then open and parse a new IDQ file, and
    //  add it to the list of parsed IDQ files
    //

    if ( 0 == pIDQFile )
    {
        ciGibDebugOut(( DEB_ITRACE, "Adding IDQ file %ws to cache\n", wcsFileName ));

        pIDQFile = new CIDQFile(wcsFileName, codePage, securityIdentity);
        XPtr<CIDQFile> xIDQFile( pIDQFile );

        pIDQFile->ParseFile();

        {
            // ==========================================
            CLock lock( _mutex );
            _aIDQFile.Add( pIDQFile, _aIDQFile.Count() );
            pIDQFile->LokAddRef();
            // ==========================================
        }

        xIDQFile.Acquire();
    }

    return pIDQFile;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFileList::~CIDQFileList - public destructor
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
CIDQFileList::~CIDQFileList()
{
    for (unsigned i=0; i<_aIDQFile.Count(); i++)
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Deleting IDQ cache entry %ws\n",
                        _aIDQFile[i]->GetIDQFileName() ));

        delete _aIDQFile[i];
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFileList::Release - public
//
//  Synopsis:   Releases the IDQ file by decrementing its refcount.
//
//  Arguments:  [idqFile] -- pointer to the IDQ file object
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CIDQFileList::Release( CIDQFile & idqFile )
{
    idqFile.Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFileList::DeleteZombies - public
//
//  Synopsis:   Removes IDQ files that are zombies; i.e. out of date
//
//  History:    96/Mar/28   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CIDQFileList::DeleteZombies()
{
    // ==========================================
    CLock lock( _mutex );

    unsigned i=0;
    while ( i<_aIDQFile.Count() )
    {
        if ( _aIDQFile[i]->LokGetRefCount() == 0 &&
             !_aIDQFile[i]->IsCachedDataValid() )
        {
            CIDQFile * pIDQFile = _aIDQFile[i];
            _aIDQFile.Remove(i);

            ciGibDebugOut(( DEB_ITRACE,
                            "Deleting zombie IDQ cache entry %ws, %d entries cached\n",
                            pIDQFile->GetIDQFileName(),
                            _aIDQFile.Count() ));

            delete pIDQFile;
        }
        else
        {
            ciGibDebugOut(( DEB_ITRACE,
                            "IDQ cache entry %ws was not deleted, refCount=%d\n",
                            _aIDQFile[i]->GetIDQFileName(),
                            _aIDQFile[i]->LokGetRefCount() ));
            i++;
        }
    }

    // ==========================================
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\express.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       express.cxx
//
//  Contents:   Used to parse and evaluate IF expressions
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

// Copied from propvar.h
#define BSTRLEN(bstrVal)        *((ULONG *) bstrVal - 1)

//+---------------------------------------------------------------------------
//
//  Function:   IsEmpty (DBCS version), private
//
//  Arguments:  [pszVal]  -- string to search
//              [cc]      -- size (in chars) of string
//
//  Returns;    TRUE if string is empty (all chars in string space-like things)
//
//  History:    28-Jun-96   KyleP       created
//
//----------------------------------------------------------------------------

BOOL IsEmpty( char const * pszVal, unsigned cc )
{
    //
    // Optimize for the common case: non-empty strings
    //

    WORD aCharType[10];

    unsigned ccProcessed = 0;

    while ( ccProcessed < cc )
    {
        unsigned ccThisPass = (unsigned)min( sizeof(aCharType)/sizeof(aCharType[0]),
                                   cc - ccProcessed );

        if ( !GetStringTypeExA( LOCALE_SYSTEM_DEFAULT,
                                CT_CTYPE1,
                                pszVal + ccProcessed,
                                ccThisPass,
                                aCharType ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error %d from GetStringTypeExA\n", GetLastError() ));
            return FALSE;
        }

        for ( unsigned i = 0; i < ccThisPass; i++ )
        {
            if ( (aCharType[i] & (C1_SPACE | C1_CNTRL | C1_BLANK)) == 0 )
                return FALSE;
        }

        ccProcessed += ccThisPass;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEmpty (UniCode version), private
//
//  Arguments:  [pwszVal]  -- string to search
//              [cc]      -- size (in chars) of string
//
//  Returns;    TRUE if string is empty (all chars in string space-like things)
//
//  History:    28-Jun-96   KyleP       created
//
//----------------------------------------------------------------------------

BOOL IsEmpty( WCHAR const * pwszVal, unsigned cc )
{
    //
    // Optimize for the common case: non-empty strings
    //

    WORD aCharType[10];

    unsigned ccProcessed = 0;

    while ( ccProcessed < cc )
    {
        unsigned ccThisPass = (unsigned)min( sizeof(aCharType)/sizeof(aCharType[0]),
                                   cc - ccProcessed );

        //
        // NOTE: the unicode version of GetStringTypeEx ignores the locale
        //

        if ( !GetStringTypeExW( LOCALE_SYSTEM_DEFAULT,
                                CT_CTYPE1,
                                pwszVal + ccProcessed,
                                ccThisPass,
                                aCharType ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error %d from GetStringTypeExA\n", GetLastError() ));
            return FALSE;
        }

        for ( unsigned i = 0; i < ccThisPass; i++ )
        {
            if ( (aCharType[i] & (C1_SPACE | C1_CNTRL | C1_BLANK)) == 0 )
                return FALSE;
        }

        ccProcessed += ccThisPass;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   StringToSystemTime
//
//  Synopsis:   Read a SystemTime from a string
//
//  Arguments:  [wcsSystemTime] - system time to parse
//              [stUTC]         - resulting system time
//
//  Returns TRUE if the coearcion was possible, FALSE otherwise.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
static BOOL StringToSystemTime( WCHAR const * wcsSystemTime,
                                SYSTEMTIME & stUTC )
{
    if ( 0 == wcsSystemTime )
    {
        return FALSE;
    }

    stUTC.wHour = 0;
    stUTC.wMinute = 0;
    stUTC.wSecond = 0;
    stUTC.wMilliseconds = 0;

    int cItems = swscanf( wcsSystemTime,
                          L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                          &stUTC.wYear,
                          &stUTC.wMonth,
                          &stUTC.wDay,
                          &stUTC.wHour,
                          &stUTC.wMinute,
                          &stUTC.wSecond,
                          &stUTC.wMilliseconds );

    return (cItems >= 3);
}


//+---------------------------------------------------------------------------
//
//  Function:   StringToFileTime
//
//  Synopsis:   Read a FileTime from a string
//
//  Arguments:  [wcsSystemTime] - system time to parse
//              [filetime]      - resulting file time
//
//  Returns TRUE if the coearcion was possible, FALSE otherwise.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
static BOOL StringToFileTime( WCHAR const * wcsSystemTime,
                              FILETIME & fileTime )
{
    SYSTEMTIME stUTC;

    if ( !StringToSystemTime( wcsSystemTime, stUTC ) )
    {
        return FALSE;
    }

    return SystemTimeToFileTime( &stUTC, &fileTime );
}


//+---------------------------------------------------------------------------
//
//  Function:   VectorCoerce
//
//  Synopsis:   Coerce's the type of a vector
//
//  Arguments:  [Value]      - value to coerce
//              [type]       - final type desired
//
//  Returns TRUE if the coearcion was possible, FALSE otherwise.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
static BOOL VectorCoerce( CHTXIfExpressionValue & Value,
                           VARTYPE type,
                           PROPVARIANT & propVariant )
{
    ULONG size = Value.GetValue()->cal.cElems;
    _int64          i64Value;
    unsigned _int64 ui64Value;
    double          dblValue;

    switch (type)
    {
    case VT_LPSTR | VT_VECTOR:
    {
        XCoMem<PCHAR> aStr( size );
        for (unsigned i=0; i<size; i++)
        {
            XCoMem<CHAR> pszStringValue;
            if ( !Value.GetVectorValueStr(i, pszStringValue ) )
            {
                return FALSE;
            }

            aStr[i] = pszStringValue.Acquire();
        }

        propVariant.calpstr.cElems = size;
        propVariant.calpstr.pElems = (PCHAR *) aStr.Acquire();
    }
    break;

    case VT_LPWSTR | VT_VECTOR:
    {
        XCoMem<PWCHAR> aWStr( size );
        for (unsigned i=0; i<size; i++)
        {
            XCoMem<WCHAR> wszStringValue;
            if ( !Value.GetVectorValueWStr(i, wszStringValue) )
            {
                return FALSE;
            }

            aWStr[i] = wszStringValue.Acquire();
        }

        propVariant.calpwstr.cElems = size;
        propVariant.calpwstr.pElems = aWStr.Acquire();
    }
    break;

    case VT_BSTR | VT_VECTOR:
    {
        XCoMem<BSTR> aBStr( size );
        for (unsigned i=0; i<size; i++)
        {
            BSTR bwszStringValue;
            if ( !Value.GetVectorValueBStr(i, bwszStringValue) )
            {
                return FALSE;
            }

            aBStr[i] = bwszStringValue;
        }

        propVariant.cabstr.cElems = size;
        propVariant.cabstr.pElems = aBStr.Acquire();
    }
    break;

    case VT_UI1 | VT_VECTOR:
    {
        XCoMem<BYTE> aUI1( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueUnsignedInteger(i, ui64Value) ||
                  ui64Value > UCHAR_MAX )
            {
                return FALSE;
            }

            aUI1[i] = (BYTE) ui64Value;
        }

        propVariant.caub.cElems = size;
        propVariant.caub.pElems = aUI1.Acquire();
    }
    break;

    case VT_I1 | VT_VECTOR:
    {
        XCoMem<BYTE> aI1( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueInteger(i, i64Value) ||
                 (i64Value < SCHAR_MIN) || (i64Value > SCHAR_MAX) )
            {
                return FALSE;
            }

            aI1[i] = (BYTE) i64Value;
        }

        propVariant.caub.cElems = size;
        propVariant.caub.pElems = aI1.Acquire();
    }
    break;

    case VT_UI2 | VT_VECTOR:
    {
        XCoMem<USHORT> aUI2( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueUnsignedInteger(i, ui64Value) ||
                 (ui64Value > USHRT_MAX) )
            {
                return FALSE;
            }

            aUI2[i] = (USHORT) ui64Value;
        }

        propVariant.caui.cElems = size;
        propVariant.caui.pElems = (USHORT *) aUI2.Acquire();
    }
    break;

    case VT_I2 | VT_VECTOR:
    {
        XCoMem<SHORT> aI2( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueInteger(i, i64Value) ||
                 (i64Value < SHRT_MIN)|| (i64Value > SHRT_MAX) )
            {
                return FALSE;
            }

            aI2[i] = (SHORT) i64Value;
        }

        propVariant.cai.cElems = size;
        propVariant.cai.pElems = aI2.Acquire();
    }
    break;

    case VT_UI4 | VT_VECTOR:
    {
        XCoMem<ULONG> aUI4( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueUnsignedInteger(i, ui64Value) ||
                 (ui64Value > ULONG_MAX) )
            {
                return FALSE;
            }
            aUI4[i] = (ULONG) ui64Value;
        }

        propVariant.caul.cElems = size;
        propVariant.caul.pElems = aUI4.Acquire();
    }
    break;

    case VT_I4 | VT_VECTOR:
    {
        XCoMem<LONG> aI4( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueInteger(i, i64Value) ||
                 (i64Value < LONG_MIN) || (i64Value > LONG_MAX) )
            {
                return FALSE;
            }

            aI4[i] = (LONG) i64Value;
        }

        propVariant.cal.cElems = size;
        propVariant.cal.pElems = aI4.Acquire();
    }
    break;

    case VT_UI8 | VT_VECTOR:
    case VT_I8 | VT_VECTOR:
    {
        //
        // hVal used instead of uhVal because latter coercion
        // is not yet supported by x86 compiler.
        //

        XCoMem<LARGE_INTEGER> aUI8( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueInteger(i, i64Value) )
            {
                return FALSE;
            }

            aUI8[i].QuadPart = i64Value;
        }

        propVariant.cah.cElems = size;
        propVariant.cah.pElems = aUI8.Acquire();
    }
    break;

    case VT_R4 | VT_VECTOR:
    {
        XCoMem<float> aR4( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueDouble(i, dblValue) ||
                 (dblValue < -FLT_MAX) || (dblValue > FLT_MAX) )
            {
                return FALSE;
            }

            aR4[i] = (float) dblValue;
        }

        propVariant.caflt.cElems = size;
        propVariant.caflt.pElems = aR4.Acquire();
    }
    break;

    case VT_R8 | VT_VECTOR:
    {
        XCoMem<double> aR8( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueDouble(i, dblValue) )
            {
                return FALSE;
            }

            aR8[i] = (double) dblValue;
        }

        propVariant.cadbl.cElems = size;
        propVariant.cadbl.pElems = aR8.Acquire();
    }
    break;

    case VT_BOOL | VT_VECTOR:
    {
        XCoMem<VARIANT_BOOL> aBOOL( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( Value.GetType() == (VT_LPWSTR | VT_VECTOR) )
            {
                if ( (_wcsicmp(Value.GetValue()->calpwstr.pElems[i], L"TRUE") == 0) ||
                     (_wcsicmp(Value.GetValue()->calpwstr.pElems[i], L"T") == 0)
                   )
                {
                    aBOOL[i] = VARIANT_TRUE;
                }
                else if ( (_wcsicmp(Value.GetValue()->calpwstr.pElems[i], L"FALSE") == 0) ||
                          (_wcsicmp(Value.GetValue()->calpwstr.pElems[i], L"F") == 0)
                        )
                {
                    aBOOL[i] = VARIANT_FALSE;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                if ( !Value.GetVectorValueInteger(i, i64Value) )
                {
                    return FALSE;
                }

                aBOOL[i] = (VARIANT_BOOL) i64Value != VARIANT_FALSE;
            }
        }

        propVariant.cabool.cElems = size;
        propVariant.cabool.pElems = aBOOL.Acquire();
    }
    break;

    case VT_DATE | VT_VECTOR:
    {
        //
        //  Dates are in the format YYYY/MM/DD hh:mm:ss:ii
        //

        if ( Value.GetType() != (VT_LPWSTR | VT_VECTOR) )
        {
            return FALSE;
        }

        XCoMem<DATE> aDate( size );
        for (unsigned i=0; i<size; i++)
        {
            SYSTEMTIME stUTC;

            if ( !StringToSystemTime( Value.GetValue()->calpwstr.pElems[i],
                                      stUTC )
               )
            {
                return FALSE;
            }

            if ( !SystemTimeToVariantTime( &stUTC, &aDate[i] ) )
            {
                return FALSE;
            }
        }

        propVariant.cadate.cElems = size;
        propVariant.cadate.pElems = aDate.Acquire();
    }
    break;

    case VT_FILETIME | VT_VECTOR:
    {
        //
        //  FileTimes are in the format YYYY/MM/DD hh:mm:ss:ii
        //

        if ( Value.GetType() != (VT_LPWSTR | VT_VECTOR) )
        {
            return FALSE;
        }

        XCoMem<FILETIME> aFileTime( size );
        for (unsigned i=0; i<size; i++)
        {
            SYSTEMTIME stUTC;

            if ( !StringToFileTime( Value.GetValue()->calpwstr.pElems[i],
                                    aFileTime[i] )
               )
            {
                return FALSE;
            }
        }

        propVariant.cafiletime.cElems = size;
        propVariant.cafiletime.pElems = aFileTime.Acquire();
    }
    break;

    case VT_CY | VT_VECTOR:
    {
        XCoMem<CY> acy( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueDouble(i, dblValue) )
            {
                return FALSE;
            }

            VarCyFromR8( dblValue, &acy[i] );
        }

        propVariant.cacy.cElems = size;
        propVariant.cacy.pElems = acy.Acquire();
    }
    break;

    default:
        return FALSE;
    break;
    }

    propVariant.vt = type;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   A case-insensitive, WCHAR implemtation or strstr.
//
//  Arguments:  [wcsString]  - string to search
//              [wcsPattern] - pattern to look for
//
//  Returns;    pointer to pattern, 0 if no match found.
//
//  History:    96/Mar/12   DwightKr    created
//
//----------------------------------------------------------------------------
static WCHAR const * wcsistr( WCHAR const * wcsString, WCHAR const * wcsPattern )
{
    if ( (wcsPattern == 0) || (*wcsPattern == 0) )
    {
        return wcsString;
    }

    ULONG cwcPattern = wcslen(wcsPattern);

    while ( *wcsString != 0 )
    {
        while ( (*wcsString != 0) &&
                (towupper(*wcsString) != towupper(*wcsPattern))
              )
        {
            wcsString++;
        }

        if ( 0 == *wcsString )
        {
            return 0;
        }

        if ( _wcsnicmp( wcsString, wcsPattern, cwcPattern) == 0 )
        {
            return wcsString;
        }

        wcsString++;
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetDoubleFromVariant - static
//
//  Synopsis:   Converts a numerical value in a variant to a double.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
static double GetDoubleFromVariant( PROPVARIANT * pVariant )
{
    switch (pVariant->vt)
    {
    case VT_UI1:
        return (double)pVariant->bVal;
    break;

    case VT_I1:
        return (double)(char)pVariant->bVal;
    break;

    case VT_UI2:
        return (double)pVariant->uiVal;
    break;

    case VT_I2:
        return (double)pVariant->iVal;
    break;

    case VT_UI4:
    case VT_UINT:
        return (double)pVariant->ulVal;
    break;

    case VT_I4:
    case VT_INT:
    case VT_ERROR:
        return (double)pVariant->lVal;
    break;

    case VT_UI8:
        //
        // hVal used instead of uhVal because latter coercion
        // is not yet supported by x86 compiler.
        //
        return (double)pVariant->hVal.QuadPart;
    break;

    case VT_I8:
        return (double) pVariant->hVal.QuadPart;
    break;

    case VT_R4:
        return (double)pVariant->fltVal;
    break;

    case VT_R8:
        return pVariant->dblVal;
    break;

    case VT_BOOL:
        return (double)( VARIANT_FALSE != pVariant->boolVal );
    break;

    case VT_DATE:
        return (double) pVariant->date;
    break;

    case VT_CY:
    {
        double dblValue;

        VarR8FromCy( pVariant->cyVal, &dblValue );

        return dblValue;
    }
    case VT_DECIMAL:
    {
        double dblValue;

        VarR8FromDec( & pVariant->decVal, &dblValue );

        return dblValue;
    }
    break;

    default:
        Win4Assert( !"VT_TYPE not supported in GetDoubleFromVariant" );
    break;
    }

    return 0.0;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetI64FromVariant - static
//
//  Synopsis:   Converts a numerical value in a variant to a _int64
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
static _int64 GetI64FromVariant( PROPVARIANT * pVariant )
{
    switch (pVariant->vt)
    {
    case VT_UI1:
        return (_int64)pVariant->bVal;
    break;

    case VT_I1:
        return (_int64)pVariant->bVal;
    break;

    case VT_UI2:
        return (_int64)pVariant->uiVal;
    break;

    case VT_I2:
        return (_int64)pVariant->iVal;
    break;

    case VT_UI4:
    case VT_UINT:
        return (_int64)pVariant->ulVal;
    break;

    case VT_I4:
    case VT_INT:
    case VT_ERROR:
        return (_int64)pVariant->lVal;
    break;

    case VT_UI8:
        return (_int64)pVariant->uhVal.QuadPart;
    break;

    case VT_I8:
        return pVariant->hVal.QuadPart;
    break;

    case VT_R4:
        Win4Assert( !"VT_R4 not supported in GetI64FromVariant, use GetDoubleFromVariant" );
    break;

    case VT_R8:
        Win4Assert( !"VT_R8 not supported in GetI64FromVariant, use GetDoubleFromVariant" );
    break;

    case VT_DECIMAL:
        Win4Assert( !"VT_DECIMAL not supported in GetI64FromVariant, use GetDoubleFromVariant" );
    break;

    case VT_DATE:
    {
        LONG lValue;
        VarI4FromDate( pVariant->date, & lValue );

        return lValue;
    }
    break;

    case VT_BOOL:
        return (_int64) ( VARIANT_FALSE != pVariant->boolVal );
    break;

    case VT_CY:
    {
        return (_int64) pVariant->cyVal.Hi;
    }
    break;

    default:
        Win4Assert( !"VT_TYPE not supported in GetI64FromVariant" );
    break;
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpression::CHTXIfExpression - public constructor
//
//  Synopsis:   Builds a CHTXIfExpression object, and determines if
//              this is an IF expression.
//
//  Arguments:  [scanner]     - parser containing the line to be parsed
//              [variableSet] - list of replaceable parameters
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXIfExpression::CHTXIfExpression( CTokenizeString & scanner,
                                    CVariableSet & variableSet,
                                    COutputFormat & outputFormat ) :
                                      _scanner(scanner),
                                      _variableSet(variableSet),
                                      _outputFormat(outputFormat)
{
    //
    //  The first word better be an 'if'
    //
    Win4Assert ( _scanner.LookAhead() == TEXT_TOKEN );

    XPtrST<WCHAR> wcsIf( _scanner.AcqWord() );

    Win4Assert( _wcsicmp(wcsIf.GetPointer(), L"if") == 0 );

    _scanner.Accept();                  // Skip over the "if"
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpression::Evaluate - public
//
//  Synopsis:   Evaluates an IF expression by breaking it up into the
//              left-side, operator & right-side.
//
//  Returns:    TRUE or FALSE - the evaluation of the IF expression
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpression::Evaluate()
{
    CHTXIfExpressionValue    lhValue( _scanner, _variableSet, _outputFormat );
    lhValue.ParseValue();

    CHTXIfExpressionOperator ifOperator( _scanner );
    ifOperator.ParseOperator();

    if ( ifOperator.Operator() != ISEMPTY_TOKEN )
    {
        CHTXIfExpressionValue    rhValue( _scanner, _variableSet, _outputFormat );
        rhValue.ParseValue();

        return ifOperator.Evaluate( lhValue, rhValue );
    }
    else
    {
        if ( _scanner.LookAhead() != EOS_TOKEN )
            THROW( CHTXException( MSG_CI_HTX_EXPECTING_OPERATOR, 0, 0 ) );

        return ifOperator.Evaluate( lhValue );
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::CHTXIfExpressionValue - public constructor
//
//  Synopsis:   Parses one half of an IF expression and determines its value
//
//  Parameters: [scanner]     - parser containing the IF to be parsed
//              [variableSet] - list of replaceable paremeters
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXIfExpressionValue::CHTXIfExpressionValue( CTokenizeString & scanner,
                                              CVariableSet & variableSet,
                                              COutputFormat & outputFormat) :
                                              _scanner(scanner),
                                              _variableSet(variableSet),
                                              _outputFormat(outputFormat),
                                              _wcsStringValue(0),
                                              _fOwnVector(FALSE),
                                              _fIsConstant(FALSE)
{
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CHTXIfExpressionValue::~CHTXIfExpressionValue()
{
    delete _wcsStringValue;

    if ( _fOwnVector )
    {
        Win4Assert ( ( _propVariant.vt & VT_VECTOR ) != 0 );
        if ( _propVariant.vt == ( VT_LPWSTR | VT_VECTOR ) )
        {
            for (unsigned i=0; i<_propVariant.calpwstr.cElems; i++)
            {
                delete _propVariant.calpwstr.pElems[i];
            }
        }

        delete _propVariant.cal.pElems;
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::ParseValue - public
//
//  Synopsis:   Parses one side of an IF expression.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Feb/13   DwightKr    add suppport for quoted strings
//
//----------------------------------------------------------------------------
void CHTXIfExpressionValue::ParseValue()
{
    //
    //  The first token on this line must be a word/phrase, and not an
    //  operator. It may be quoted.
    //
    _fIsConstant = TRUE;                // Assume it is a constant, not a var

    if ( _scanner.LookAhead() == QUOTES_TOKEN )
    {
        _scanner.AcceptQuote();                  // Skip over the opening "
        _propVariant.vt = VT_LPWSTR;

        _wcsStringValue = _scanner.AcqPhrase();
        _scanner.Accept();              // Skip over the string

        if ( _scanner.LookAhead() != QUOTES_TOKEN )
        {
            THROW( CHTXException(MSG_CI_HTX_MISSING_QUOTE, 0, 0) );
        }

        _scanner.Accept();              // Skip over the closing "
    }
    else if (_scanner.LookAhead() == C_OPEN_TOKEN )
    {
        _scanner.Accept();                  // Skip over the opening {
        _scanner.AcqVector( _propVariant );
        _fOwnVector = TRUE;

        if ( _scanner.LookAhead() != C_CLOSE_TOKEN )
        {
            THROW( CHTXException(MSG_CI_HTX_MISSING_BRACKET, 0, 0) );
        }

        _scanner.Accept();              // Skip over the closing }
    }
    else
    {
        if ( _scanner.LookAhead() != TEXT_TOKEN )
        {
            THROW( CHTXException(QPARSE_E_UNEXPECTED_EOS, 0, 0) );
        }

        //
        //  Determine if this is a number, or a string.  If it is a string,
        //  then look it up in the variableSet.  If it's defined in the
        //  variableSet, look up its value, and determine if this new value
        //  is a number.
        //
        if ( _scanner.GetGUID( _guid ) )
        {
            _propVariant.vt = VT_CLSID;
            _propVariant.puuid = &_guid;
        }
        else if ( _scanner.GetNumber( (unsigned _int64) *((unsigned _int64 *) (&_propVariant.uhVal)) ) )
        {
            _propVariant.vt = VT_UI8;
        }
        else if ( _scanner.GetNumber( (_int64) *((_int64 *) (&_propVariant.hVal))  ) )
        {
            _propVariant.vt = VT_I8;
        }
        else if ( _scanner.GetNumber( _propVariant.dblVal ) )
        {
            _propVariant.vt = VT_R8;
        }
        else
        {
            //
            //  Its not a number, get its value in a local buffer.
            //
            _propVariant.vt = VT_LPWSTR;
            XPtrST<WCHAR> wcsVariableName( _scanner.AcqWord() );

            //
            //  Try to find this variable/string in the variableSet
            //
            CVariable *pVariable = _variableSet.Find( wcsVariableName.GetPointer() );

            if ( 0 != pVariable )
            {
                _fIsConstant = FALSE;

                //
                //  We have a variable with this name.  Get its string value.
                //
                ULONG cwcValue;
                WCHAR * wcsValue = pVariable->GetStringValueRAW(_outputFormat, cwcValue);

                _wcsStringValue = new WCHAR[ cwcValue + 1 ];
                RtlCopyMemory( _wcsStringValue,
                               wcsValue,
                               (cwcValue+1) * sizeof(WCHAR) );

                _propVariant = *pVariable->GetValue();
            }
            else
            {
                //
                //  The variable name could not be found.
                //
                _wcsStringValue = wcsVariableName.Acquire();
            }
        }

        _scanner.Accept();              // Skip over the "value"
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetStringValue - public
//
//  Synopsis:   Returns the string value of the variable
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
WCHAR * CHTXIfExpressionValue::GetStringValue()
{
    if ( 0 == _wcsStringValue )
    {
        switch ( _propVariant.vt )
        {
        case VT_I4:
            _wcsStringValue = new WCHAR[20];
            _itow( _propVariant.ulVal, _wcsStringValue, 10 );
        break;

        case VT_UI4:
            _wcsStringValue = new WCHAR[20];
            _itow( _propVariant.lVal, _wcsStringValue, 10 );
        break;

        case VT_R8:
            _wcsStringValue = new WCHAR[ maxFloatSize ];
            swprintf( _wcsStringValue, L"%f", _propVariant.dblVal );
        break;

        default:
            _wcsStringValue = new WCHAR[1];
            _wcsStringValue[0] = 0;
        break;
        }
    }

    return _wcsStringValue;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionOperator::CHTXIfExpressionOperator - public constructor
//
//  Synopsis:   Parses the operator in an IF expression
//
//  Parameters: [scanner]     - parser containing the operator to be parsed
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXIfExpressionOperator::CHTXIfExpressionOperator( CTokenizeString & scanner ) :
                               _scanner(scanner), _operator(EQUAL_TOKEN)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionOperator::ParseOperator - public
//
//  Synopsis:   Parses the operator in an IF expression
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXIfExpressionOperator::ParseOperator()
{
    //
    //  The first token on this line must be a word, and not an operator.
    //  We're looking for operators such as eq, ne, gt, ...
    //
    if ( _scanner.LookAhead() != TEXT_TOKEN )
    {
        THROW( CHTXException(MSG_CI_HTX_EXPECTING_OPERATOR, 0, 0) );
    }

    XPtrST<WCHAR> wcsOperator( _scanner.AcqWord() );

    if ( 0 == wcsOperator.GetPointer() )
        THROW( CHTXException(MSG_CI_HTX_EXPECTING_OPERATOR, 0, 0) );

    if ( wcscmp(wcsOperator.GetPointer(), L"EQ") == 0 )
    {
        _operator = EQUAL_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"NE") == 0 )
    {
        _operator = NOT_EQUAL_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"GT") == 0 )
    {
        _operator = GREATER_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"GE") == 0 )
    {
        _operator = GREATER_EQUAL_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"LT") == 0 )
    {
        _operator = LESS_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"LE") == 0 )
    {
        _operator = LESS_EQUAL_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"CONTAINS") == 0 )
    {
        _operator = CONTAINS_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"ISEMPTY") == 0 )
    {
        _operator = ISEMPTY_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"ISTYPEEQ") == 0 )
    {
        _operator = ISTYPEEQUAL_TOKEN;
    }
    else
    {
        THROW( CHTXException(MSG_CI_HTX_EXPECTING_OPERATOR, 0, 0) );
    }

    _scanner.Accept();                  // Skip over the "operator"
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionOperator::Evaluate - public
//
//  Synopsis:   Using the operator already obtained, it evaluates a TRUE/FALSE
//              result by comparing the lhValue and the rhValue.
//
//  Arguments:  [lhValue] - left hand value of the IF statement
//              [rhValue] - right hand value of the IF statement
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionOperator::Evaluate( CHTXIfExpressionValue & lhValue,
                                         CHTXIfExpressionValue & rhValue )
{
    //
    //  If the operator is CONTAINS_TOKEN, then we'll simply do a wcsistr
    //  of the string representations of the two values.
    //
    if ( CONTAINS_TOKEN == _operator )
    {
        return wcsistr(lhValue.GetStringValue(), rhValue.GetStringValue()) != 0;
    }

    //
    //  We must setup the comparision functions to examine like types.
    //  The type of lhValue and rhValue must be converted to like types.
    //  If any one of them is a string, then we'll treat both of them
    //  like strings.
    //

    PROPVARIANT lhVariant;
    PROPVARIANT rhVariant;

    SPropVariant xlhPropVariant;
    SPropVariant xrhPropVariant;

    //
    //  If neither one are vectors, perform the following conversions
    //
    if ( ((lhValue.GetType() & VT_VECTOR) == 0) &&
         ((rhValue.GetType() & VT_VECTOR) == 0) )
    {
        if ( (lhValue.GetType() == VT_LPWSTR) ||
             (rhValue.GetType() == VT_LPWSTR) ||
             (lhValue.GetType() == VT_LPSTR) ||
             (rhValue.GetType() == VT_LPSTR) ||
             (lhValue.GetType() == VT_BSTR) ||
             (rhValue.GetType() == VT_BSTR)
           )
        {
            lhVariant.vt = VT_LPWSTR;
            rhVariant.vt = VT_LPWSTR;

            lhVariant.pwszVal = lhValue.GetStringValue();
            rhVariant.pwszVal = rhValue.GetStringValue();
        }
        else if (lhValue.GetType() == rhValue.GetType() ||
                 lhValue.GetType() == VT_EMPTY ||
                 rhValue.GetType() == VT_EMPTY)
        {
            lhVariant = *lhValue.GetValue();
            rhVariant = *rhValue.GetValue();
        }
        else if ( (lhValue.GetType() == VT_FILETIME) ||
                  (rhValue.GetType() == VT_FILETIME) )
        {
            if ( lhValue.GetType() == VT_LPWSTR )
            {
                if ( !StringToFileTime( lhValue.GetValue()->pwszVal,
                                        lhVariant.filetime )
                   )
                {
                    return FALSE;
                }

                lhVariant.vt = VT_FILETIME;
                rhVariant = *rhValue.GetValue();
            }
            else if ( rhValue.GetType() == VT_LPWSTR )
            {
                if ( !StringToFileTime( rhValue.GetValue()->pwszVal,
                                        rhVariant.filetime )
                   )
                {
                    return FALSE;
                }

                rhVariant.vt = VT_FILETIME;
                lhVariant = *lhValue.GetValue();
            }
        }
        else if ( (lhValue.GetType() == VT_R4) || (lhValue.GetType() == VT_R8) ||
                  (rhValue.GetType() == VT_R4) || (rhValue.GetType() == VT_R8) ||
                  (lhValue.GetType() == VT_CY) || (rhValue.GetType() == VT_CY) ||
                  (lhValue.GetType() == VT_DECIMAL) || (rhValue.GetType() == VT_DECIMAL) ||
                  (lhValue.GetType() == VT_DATE) || (rhValue.GetType() == VT_DATE)
                )
        {
            //
            //  At least one of them is a floating number.  Convert them both
            //  to floating point.
            //
            lhVariant.vt = VT_R8;
            rhVariant.vt = VT_R8;

            lhVariant.dblVal = GetDoubleFromVariant( lhValue.GetValue() );
            rhVariant.dblVal = GetDoubleFromVariant( rhValue.GetValue() );
        }
        else if ( (lhValue.GetType() == VT_I8)  || (lhValue.GetType() == VT_I4) ||
                  (lhValue.GetType() == VT_I2)  || (lhValue.GetType() == VT_I1) ||
                  (rhValue.GetType() == VT_I8)  || (rhValue.GetType() == VT_I4) ||
                  (rhValue.GetType() == VT_I2)  || (rhValue.GetType() == VT_I1) ||
                  (lhValue.GetType() == VT_INT) || (rhValue.GetType() == VT_INT)
                )
        {
            lhVariant.vt = VT_I8;
            rhVariant.vt = VT_I8;

            lhVariant.hVal.QuadPart = GetI64FromVariant( lhValue.GetValue() );
            rhVariant.hVal.QuadPart = GetI64FromVariant( rhValue.GetValue() );
        }
        else if ( (lhValue.GetType() == VT_UI8)  || (lhValue.GetType() == VT_UI4) ||
                  (lhValue.GetType() == VT_UI2)  || (lhValue.GetType() == VT_UI1) ||
                  (rhValue.GetType() == VT_UI8)  || (rhValue.GetType() == VT_UI4) ||
                  (rhValue.GetType() == VT_UI2)  || (rhValue.GetType() == VT_UI1) ||
                  (lhValue.GetType() == VT_UINT) || (rhValue.GetType() == VT_UINT)
                )
        {
            lhVariant.vt = VT_UI8;
            rhVariant.vt = VT_UI8;

            lhVariant.uhVal.QuadPart = GetI64FromVariant( lhValue.GetValue() );
            rhVariant.uhVal.QuadPart = GetI64FromVariant( rhValue.GetValue() );
        }
        else
        {
            lhVariant = *lhValue.GetValue();
            rhVariant = *rhValue.GetValue();
        }
    }
    else if ( ((lhValue.GetType() & VT_VECTOR) != 0) &&
              ((rhValue.GetType() & VT_VECTOR) != 0)
            )
    {
        //
        //  Both are vectors
        //

        //
        //  If the vector's are of different types, attempt to Coerce one
        //  type into the other.
        //
        if ( lhValue.GetType() != rhValue.GetType() )
        {
            //
            //  Coerce the types to be the same if possible. Attempt to
            //  Coerce a constant into the type of the variable, rather
            //  then vise versa.  If this fails, attempt the opposite
            //  coearison.
            //
            if ( lhValue.IsConstant() )
            {
                if ( VectorCoerce( lhValue, rhValue.GetType(), lhVariant ) )
                {
                    Win4Assert( xlhPropVariant.IsNull() );
                    xlhPropVariant.Set( &lhVariant );
                    rhVariant = *rhValue.GetValue();
                }
                else
                {
                    if ( VectorCoerce( rhValue, lhValue.GetType(), rhVariant ) )
                    {
                        Win4Assert( xrhPropVariant.IsNull() );
                        xrhPropVariant.Set( &rhVariant );
                        lhVariant = *lhValue.GetValue();
                    }
                }
            }
            else if ( rhValue.IsConstant() )
            {
                if ( VectorCoerce( rhValue, lhValue.GetType(), rhVariant ) )
                {
                    Win4Assert( xrhPropVariant.IsNull() );
                    xrhPropVariant.Set( &rhVariant );
                    lhVariant = *lhValue.GetValue();
                }
                else
                {
                    if ( VectorCoerce( lhValue, rhValue.GetType(), lhVariant ) )
                    {
                        Win4Assert( xlhPropVariant.IsNull() );
                        xlhPropVariant.Set( &lhVariant );
                        rhVariant = *rhValue.GetValue();
                    }
                }
            }
            else
            {
                lhVariant = *lhValue.GetValue();
                rhVariant = *rhValue.GetValue();
            }

        }
        else
        {
            lhVariant = *lhValue.GetValue();
            rhVariant = *rhValue.GetValue();
        }
    }
    else
    {
        lhVariant = *lhValue.GetValue();
        rhVariant = *rhValue.GetValue();
    }

    switch ( _operator )
    {
    case EQUAL_TOKEN:
        return VT_VARIANT_EQ( lhVariant, rhVariant );
    break;

    case NOT_EQUAL_TOKEN:
        return VT_VARIANT_NE( lhVariant, rhVariant );
    break;

    case GREATER_TOKEN:
        return VT_VARIANT_GT( lhVariant, rhVariant );
    break;

    case GREATER_EQUAL_TOKEN:
        return VT_VARIANT_GE( lhVariant, rhVariant );
    break;

    case LESS_TOKEN:
        return VT_VARIANT_LT( lhVariant, rhVariant );
    break;

    case LESS_EQUAL_TOKEN:
        return VT_VARIANT_LE( lhVariant, rhVariant );
    break;

    case ISTYPEEQUAL_TOKEN:
    {
        //
        //  Three valid cases exist:
        //
        //      if variable IsTypeEQ constant
        //      if constant IsTypeEQ variable
        //      if variable IsTypeEQ variable
        //
        //  Therefore, at least ONE of them must be a variable.
        //
        if ( lhValue.IsConstant() && rhValue.IsConstant() )
        {
            THROW( CHTXException(MSG_CI_HTX_ISTYPEEQUAL_WITH_CONSTANTS, 0, 0) );
        }

        //
        //  If a constant is used, then it must be of type I4. Not floating,
        //  guid, vector, etc.
        //
        if ( lhValue.IsConstant() )
        {
            if ( lhValue.GetType() != VT_UI4 )
            {
                THROW( CHTXException(MSG_CI_HTX_ISTYPEEQUAL_INVALID_CONSTANT, 0, 0) );
            }

            return lhValue.GetValue()->ulVal == (ULONG) rhValue.GetType();
        }
        else if ( rhValue.IsConstant() )
        {
            if ( rhValue.GetType() != VT_UI4 )
            {
                THROW( CHTXException(MSG_CI_HTX_ISTYPEEQUAL_INVALID_CONSTANT, 0, 0) );
            }

            return rhValue.GetValue()->ulVal == (ULONG) lhValue.GetType();
        }
        else
        {
            return lhValue.GetType() == rhValue.GetType();
        }
    }
    break;

    default:
        Win4Assert(!"Illegal case in NON-VECTOR CExpressionOperator::Evaluate" );
        return FALSE;
    break;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionOperator::Evaluate - public
//
//  Synopsis:   Using the operator already obtained, it evaluates a TRUE/FALSE
//              result by comparing the lhValue and the rhValue.
//
//  Arguments:  [lhValue] - left hand value of the IF statement
//
//  History:    29-Jun-96   KyleP       created
//
//----------------------------------------------------------------------------

BOOL CHTXIfExpressionOperator::Evaluate( CHTXIfExpressionValue & lhValue )
{
    Win4Assert( ISEMPTY_TOKEN == _operator );

    BOOL fEmpty;
    ULONG vt = lhValue.GetType();

    switch ( vt )
    {
    case VT_EMPTY:
    case VT_NULL:
        fEmpty = TRUE;
        break;

    case VT_LPSTR:
    {
        char const * pszVal = lhValue.GetValue()->pszVal;
        unsigned cc = strlen( pszVal );

        fEmpty = IsEmpty( pszVal, cc );
        break;
    }

    case VT_LPSTR | VT_VECTOR:
    {
        for ( unsigned i = 0; i < lhValue.GetValue()->calpstr.cElems; i++ )
        {
        char const * pszVal = lhValue.GetValue()->calpstr.pElems[i];
        unsigned cc = strlen( pszVal );
        fEmpty = IsEmpty( pszVal, cc );

        if ( !fEmpty )
        break;
        }

        break;
    }

    case VT_BSTR:
    {
        WCHAR const * pwszVal = lhValue.GetValue()->bstrVal;
        unsigned cc = BSTRLEN( lhValue.GetValue()->bstrVal );

        fEmpty = IsEmpty( pwszVal, cc );
        break;
    }

    case VT_BSTR | VT_VECTOR:
    {
        for ( unsigned i = 0; i < lhValue.GetValue()->cabstr.cElems; i++ )
        {
        WCHAR const * pwszVal = lhValue.GetValue()->cabstr.pElems[i];
        unsigned cc = BSTRLEN( lhValue.GetValue()->cabstr.pElems[i] );

        fEmpty = IsEmpty( pwszVal, cc );

        if ( !fEmpty )
        break;
        }

        break;
    }

    case VT_LPWSTR:
    {
        WCHAR const * pwszVal = lhValue.GetValue()->pwszVal;
        unsigned cc = wcslen( pwszVal );

        fEmpty = IsEmpty( pwszVal, cc );
        break;
    }

    case VT_LPWSTR | VT_VECTOR:
    {
        for ( unsigned i = 0; i < lhValue.GetValue()->calpwstr.cElems; i++ )
        {
        WCHAR const * pwszVal = lhValue.GetValue()->calpwstr.pElems[i];
        unsigned cc = wcslen( pwszVal );
        fEmpty = IsEmpty( pwszVal, cc );

        if ( !fEmpty )
        break;
        }

        break;
    }

    default:
        fEmpty = FALSE;
    }

    return fEmpty;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueInteger, public
//
//  Synopsis:   Returns the _int64 value of a vector's element
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueInteger( unsigned index,
                                                  _int64 & i64Value )
{
    switch ( GetType() )
    {
    case VT_UI1 | VT_VECTOR:
        i64Value = (_int64) _propVariant.caub.pElems[index];
    break;

    case VT_I1 | VT_VECTOR:
        i64Value = (_int64) _propVariant.caub.pElems[index];
    break;

    case VT_UI2 | VT_VECTOR:
        i64Value = (_int64) _propVariant.caui.pElems[index];
    break;

    case VT_I2 | VT_VECTOR:
        i64Value = (_int64) _propVariant.cai.pElems[index];
    break;

    case VT_UI4 | VT_VECTOR:
        i64Value = (_int64) _propVariant.caul.pElems[index];
    break;

    case VT_I4 | VT_VECTOR:
        i64Value = (_int64) _propVariant.cal.pElems[index];
    break;

    case VT_UI8 | VT_VECTOR:
        i64Value = (_int64) _propVariant.cauh.pElems[index].QuadPart;
    break;

    case VT_I8 | VT_VECTOR:
        i64Value = (_int64) _propVariant.cah.pElems[index].QuadPart;
    break;

    case VT_R4 | VT_VECTOR:
        return FALSE;
    break;

    case VT_R8 | VT_VECTOR:
        return FALSE;
    break;

    case VT_DATE | VT_VECTOR:
    {
        LONG lValue;
        VarI4FromDate( _propVariant.cadate.pElems[index], &lValue );

        i64Value = lValue;
    }
    break;

    case VT_BOOL | VT_VECTOR:
        i64Value = (_int64) ( VARIANT_FALSE != _propVariant.cabool.pElems[index] );
    break;

    case VT_CY | VT_VECTOR:
    {
        return FALSE;
    }
    break;

    default:
        return FALSE;
    break;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueUnsignedInteger, public
//
//  Synopsis:   Returns the unsigned _int64 value of a vector's element
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueUnsignedInteger( unsigned index,
                                                           unsigned _int64 & ui64Value )
{
    switch ( GetType() )
    {
    case VT_UI1 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.caub.pElems[index];
    break;

    case VT_I1 | VT_VECTOR:
        if ( _propVariant.cac.pElems[index] < 0 )
            return FALSE;

        ui64Value = (unsigned _int64) _propVariant.cac.pElems[index];
    break;

    case VT_UI2 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.caui.pElems[index];
    break;

    case VT_I2 | VT_VECTOR:
        if ( _propVariant.cai.pElems[index] < 0 )
            return FALSE;

        ui64Value = (unsigned _int64) _propVariant.cai.pElems[index];
    break;

    case VT_UI4 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.caul.pElems[index];
    break;

    case VT_I4 | VT_VECTOR:
        if ( _propVariant.cal.pElems[index] < 0 )
            return FALSE;

        ui64Value = (unsigned _int64) _propVariant.cal.pElems[index];
    break;

    case VT_UI8 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.cauh.pElems[index].QuadPart;
    break;

    case VT_I8 | VT_VECTOR:
        if ( _propVariant.cah.pElems[index].QuadPart < 0 )
            return FALSE;

        ui64Value = (unsigned _int64) _propVariant.cah.pElems[index].QuadPart;
    break;

    case VT_R4 | VT_VECTOR:
        return FALSE;
    break;

    case VT_R8 | VT_VECTOR:
        return FALSE;
    break;

    case VT_BOOL | VT_VECTOR:
        ui64Value = (unsigned _int64) ( VARIANT_FALSE != _propVariant.cabool.pElems[index] );
    break;

    case VT_CY | VT_VECTOR:
    {
        return FALSE;
    }
    break;

    default:
        return FALSE;
    break;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueDouble, public
//
//  Synopsis:   Returns the double value of a vector's element
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueDouble(unsigned index,
                                                 double & dblValue)
{
    switch ( GetType() )
    {
    case VT_UI1 | VT_VECTOR:
        VarR8FromUI1( _propVariant.caub.pElems[index], &dblValue );
    break;

    case VT_I1 | VT_VECTOR:
        VarR8FromI1( _propVariant.caub.pElems[index], &dblValue );
    break;

    case VT_UI2 | VT_VECTOR:
        VarR8FromUI2( _propVariant.caui.pElems[index], &dblValue );
    break;

    case VT_I2 | VT_VECTOR:
        VarR8FromI2( _propVariant.cai.pElems[index], &dblValue );
    break;

    case VT_UI4 | VT_VECTOR:
        VarR8FromUI4( _propVariant.caul.pElems[index], &dblValue );
    break;

    case VT_I4 | VT_VECTOR:
        VarR8FromI4( _propVariant.cal.pElems[index], &dblValue );
    break;

    case VT_UI8 | VT_VECTOR:
        dblValue = (double) _propVariant.cah.pElems[index].QuadPart;
    break;

    case VT_I8 | VT_VECTOR:
        //
        // hVal used instead of uhVal because latter coercion
        // is not yet supported by x86 compiler.
        //
        dblValue = (double) _propVariant.cah.pElems[index].QuadPart;
    break;

    case VT_R4 | VT_VECTOR:
        VarR8FromR4( _propVariant.caflt.pElems[index], &dblValue );
    break;

    case VT_R8 | VT_VECTOR:
        dblValue = (double) _propVariant.cadbl.pElems[index];
    break;

    case VT_DATE | VT_VECTOR:
        VarR8FromDate( _propVariant.cadate.pElems[index], &dblValue );
    break;

    case VT_BOOL | VT_VECTOR:
        VarR8FromBool( _propVariant.cabool.pElems[index], &dblValue );
    break;

    case VT_CY | VT_VECTOR:
        VarR8FromCy( _propVariant.cacy.pElems[index], &dblValue );
    break;

    default:
        return FALSE;
    break;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueWStr, public
//
//  Synopsis:   Returns the wide string representation of a vector's element
//              in OLE memory.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueWStr(unsigned index,
                                              XCoMem<WCHAR> & wcsStringValue )
{
    switch ( GetType() )
    {
    case VT_BSTR | VT_VECTOR:
    case VT_LPWSTR | VT_VECTOR:
    {
        unsigned cwcStringValue;
        if ( GetType() == (VT_LPWSTR | VT_VECTOR) )
        {
            cwcStringValue = wcslen( _propVariant.calpwstr.pElems[index] ) + 1;
        }
        else
        {
            cwcStringValue = BSTRLEN( _propVariant.cabstr.pElems[index] ) + 1;
        }

        wcsStringValue.Init( cwcStringValue );

        RtlCopyMemory( wcsStringValue.GetPointer(),
                       _propVariant.calpwstr.pElems[index],
                       cwcStringValue * sizeof(WCHAR) );
    }
    break;

    case VT_LPSTR | VT_VECTOR:
    {
        XArray<WCHAR> wcsBuffer;
        ULONG cbBuffer = strlen(_propVariant.calpstr.pElems[index]) + 1;
        ULONG cwcBuffer = MultiByteToXArrayWideChar( (UCHAR const *) _propVariant.calpstr.pElems[index],
                                                     cbBuffer,
                                                     _outputFormat.CodePage(),
                                                     wcsBuffer );

        if ( 0 == cwcBuffer )
        {
            return FALSE;
        }

        wcsStringValue.Init( cwcBuffer + 1 );
        RtlCopyMemory( wcsStringValue.GetPointer(),
                       wcsBuffer.GetPointer(),
                       (cwcBuffer+1) * sizeof(WCHAR) );
    }
    break;

    default:
        return FALSE;
    break;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueStr, public
//
//  Synopsis:   Returns the string representation of a vector's element
//              in OLE memory.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueStr(unsigned index,
                                              XCoMem<CHAR> & pszStringValue )
{
    XCoMem<WCHAR> wcsStringValue;
    if ( !GetVectorValueWStr( index, wcsStringValue ) )
    {
        return FALSE;
    }

    ULONG cwcBuffer = wcslen( wcsStringValue.GetPointer() ) + 1;
    XArray<BYTE> pszMessage(cwcBuffer);
    ULONG cbBuffer = WideCharToXArrayMultiByte( wcsStringValue.GetPointer(),
                                                cwcBuffer,
                                                _outputFormat.CodePage(),
                                                pszMessage );

    if ( 0 == cbBuffer )
    {
        return FALSE;
    }

    pszStringValue.Init( cbBuffer + 1 );
    RtlCopyMemory( pszStringValue.GetPointer(),
                   pszMessage.GetPointer(),
                   cbBuffer + 1 );

    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueBStr, public
//
//  Synopsis:   Returns the B string representation of a vector's element
//              in OLE memory.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueBStr(unsigned index,
                                               BSTR & bwszStringValue )
{
    XCoMem<WCHAR> wszStringValue;
    if ( !GetVectorValueWStr(index, wszStringValue) )
    {
        return FALSE;
    }


    bwszStringValue = SysAllocString( wszStringValue.GetPointer() );
    if ( 0 == bwszStringValue )
    {
        THROW ( CException( E_OUTOFMEMORY ) );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\errormsg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       errormsg.cxx
//
//  Contents:   Error messages for output/running queries
//
//  History:    96/Mar/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define ERROR_MESSAGE_SIZE 512

//+---------------------------------------------------------------------------
//
//  Function:   GetErrorPageNoThrow - public
//
//  Synposis:   Generates an error page based on the error parameters passed.
//
//  Arguments:  [eErrorClass]      - class of error (IDQ, HTX, restirction, etc)
//              [status]           - error code generated
//              [ulErrorLine]      - line on which the error occured
//              [wcsErrorFileName] - name of file which generated the error
//              [pVariableSet]     - replaceable parameters which generated the error
//              [pOutputFormat]    - format of dates & numbers
//              [locale]           - locale of the browser
//              [webServer]        - the web server
//              [vString]          - virtual string to contain error code
//
//  History:    96/Feb/29   DwightKr    Created
//
//----------------------------------------------------------------------------
void GetErrorPageNoThrow(
    int   eErrorClass,
    NTSTATUS status,
    ULONG ulErrorLine,
    WCHAR const * wcsErrorFileName,
    CVariableSet * pVariableSet,
    COutputFormat * pOutputFormat,
    LCID locale,
    CWebServer & webServer,
    CVirtualString & vString )
{
    //
    //  If the error was caused by a failure to WRITE to the web server,
    //  then don't bother trying to report an error, there is no one to
    //  receive it.
    //
    if ( eWebServerWriteError == eErrorClass )
    {
        ciGibDebugOut(( DEB_IWARN, "Failed to write to the web server" ));

        return;
    }

    //
    //  If the error was the result of an access denied problem, then simply
    //  return a 401 error to the browser
    //

    WCHAR awcsErrorMessage[ERROR_MESSAGE_SIZE];
    WCHAR * pwszErrorMessage = awcsErrorMessage;
    ULONG cchAvailMessage = ERROR_MESSAGE_SIZE;

    //
    //  Generate the Win32 error code by removing the facility code (7) and
    //  the error bit.
    //
    ULONG Win32status = status;
    if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
    {
        Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );
    }

    if ( (STATUS_ACCESS_DENIED == status) ||
         (STATUS_NETWORK_ACCESS_DENIED == status) ||
         (ERROR_ACCESS_DENIED == Win32status) ||
         (ERROR_INVALID_ACCESS == Win32status) ||
         (ERROR_NETWORK_ACCESS_DENIED == Win32status)
       )
    {
        ciGibDebugOut(( DEB_WARN, "mapping 0x%x to 401 access denied\n", status ));

        ReturnServerError( HTTP_STATUS_DENIED, webServer );
        return;
    }

    //
    // Map special error codes to their message equivalents.
    //
    if ( QUERY_E_DUPLICATE_OUTPUT_COLUMN == status )
    {
        status = MSG_CI_IDQ_DUPLICATE_COLUMN;
    }
    else if ( QUERY_E_INVALID_OUTPUT_COLUMN == status )
    {
        status = MSG_CI_IDQ_NO_SUCH_COLUMN_PROPERTY;
    }

    if ( 0 != wcsErrorFileName )
    {
        WCHAR *p = wcsrchr( wcsErrorFileName, L'\\' );
        if ( 0 == p )
            p = wcsrchr( wcsErrorFileName, L'/' );
        if ( 0 == p )
            p = wcsrchr( wcsErrorFileName, L':' );

        if ( 0 != p )
            wcsErrorFileName = p + 1;
    }

    //
    // Don't pass a specific lang id to FormatMessage since it will
    // fail if there's no message in that language. Instead set
    // the thread locale, which will get FormatMessage to use a search
    // algorithm to find a message of the appropriate language or
    // use a reasonable fallback msg if there's none.
    //
    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale(locale);

    switch (eErrorClass)
    {
    case eIDQParseError:
    {
        //
        //  These are errors encountered while parsing the IDQ file
        //
        DWORD_PTR args [] = {
                         (DWORD_PTR) ulErrorLine,
                         (DWORD_PTR) wcsErrorFileName
                        };

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              GetModuleHandle(L"idq.dll"),
                              status,
                              0,
                              pwszErrorMessage,
                              cchAvailMessage,
                              (va_list *) args ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                     L"Processing of IDQ file %ls failed with error 0x%x\n",
                     wcsErrorFileName,
                     status );
        }
    }
    break;

    case eIDQPlistError:
    {
        //
        //  These are errors encountered while parsing the [names] section
        //

        if (wcsErrorFileName != 0)
        {
            DWORD_PTR args [] = {
                             (DWORD_PTR) wcsErrorFileName,
                             (DWORD_PTR) ulErrorLine,
                            };

            NTSTATUS MsgNum = MSG_IDQ_FILE_MESSAGE;
            if (ulErrorLine != 0)
            {
                MsgNum = MSG_IDQ_FILE_LINE_MESSAGE;
            }

            ULONG cchMsg = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                             FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          GetModuleHandle(L"idq.dll"),
                                          MsgNum,
                                          0,
                                          pwszErrorMessage,
                                          cchAvailMessage,
                                          (va_list *) args );
            pwszErrorMessage += cchMsg;
            cchAvailMessage -= cchMsg;
        }

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle(L"query.dll"),
                              status,
                              0,
                              pwszErrorMessage,
                              cchAvailMessage,
                              0 ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                     L"Processing of IDQ file [names] failed with error 0x%x\n",
                     status );
        }
    }
    break;

    case eHTXParseError:
    {
        //
        //  These are errors encountered while parsing the IDQ file
        //
        DWORD_PTR args [] = {
                         (DWORD_PTR) ulErrorLine,
                         (DWORD_PTR) wcsErrorFileName
                        };

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               GetModuleHandle(L"idq.dll"),
                               status,
                               0,
                               pwszErrorMessage,
                               cchAvailMessage,
                               (va_list *) args ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                      L"Error 0x%x occured while parsing in HTX file %ls\n",
                      status,
                      wcsErrorFileName );
        }
    }
    break;

    case eRestrictionParseError:
    {
        //
        //  These are errors encountered while parsing the restriction
        //
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                               GetModuleHandle(L"query.dll"),
                               status,
                               0,
                               pwszErrorMessage,
                               cchAvailMessage,
                               0 ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                     L"Restriction parsing failed with error 0x%x\n",
                     status );
        }
    }
    break;

    default:
    {
        //
        //  All other errors; other major classes of errors are caught above.
        //

        DWORD_PTR args [] = {
                         (DWORD_PTR) ulErrorLine,
                         (DWORD_PTR) wcsErrorFileName
                        };

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               GetModuleHandle(L"idq.dll"),
                               status,
                               0,
                               pwszErrorMessage,
                               cchAvailMessage,
                               (va_list *) args ) )
        {
            if (wcsErrorFileName != 0)
            {
                NTSTATUS MsgNum = MSG_IDQ_FILE_MESSAGE;
                args[0] = (DWORD_PTR)wcsErrorFileName;
                if (ulErrorLine != 0)
                {
                    args[1] = ulErrorLine;
                    MsgNum = MSG_IDQ_FILE_LINE_MESSAGE;
                }

                ULONG cchMsg = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                              GetModuleHandle(L"idq.dll"),
                                              MsgNum,
                                              0,
                                              pwszErrorMessage,
                                              cchAvailMessage,
                                              (va_list *) args );
                pwszErrorMessage += cchMsg;
                cchAvailMessage -= cchMsg;
            }

            if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                   GetModuleHandle(L"query.dll"),
                                   status,
                                   0,
                                   pwszErrorMessage,
                                   cchAvailMessage,
                                   0 ) )
            {
                //
                //  Try looking up the error in the Win32 list of error codes
                //
                if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                       GetModuleHandle(L"kernel32.dll"),
                                       Win32status,
                                       0,
                                       pwszErrorMessage,
                                       cchAvailMessage,
                                       0 ) )
                {
                    ciGibDebugOut(( DEB_ERROR,
                                    "Format message failed with error 0x%x\n",
                                    GetLastError() ));

                    swprintf( pwszErrorMessage,
                             L"Error 0x%x caught while processing query\n",
                             status );
                }
            }
        }
    }
    break;
    }
    SetThreadLocale(SaveLCID);

    BOOL fCaughtException = FALSE;

    //
    //  Try to bind to language object by looking up registry and get
    //  the error message HTX file associated with this class of error.
    //
    TRY
    {
        CWebLangLocator langreg( locale );

        WCHAR * wcsErrorFile = 0;

        if ( langreg.LocaleFound() )
        {
            //
            //  If the locale was found in the registry, get the error message
            //  file associated with this language.
            //

            switch (eErrorClass)
            {
            case eIDQParseError:
            case eIDQPlistError:
                wcsErrorFile = langreg.GetIDQErrorFile();
            break;

            case eHTXParseError:
                wcsErrorFile = langreg.GetHTXErrorFile();
            break;

            case eRestrictionParseError:
                wcsErrorFile = langreg.GetRestrictionErrorFile();
            break;

            default:
                wcsErrorFile = langreg.GetDefaultErrorFile();
            break;
            }
        }

        if ( ( 0 != pVariableSet ) &&
             ( 0 != pOutputFormat ) &&
             ( 0 != wcsErrorFile ) &&
             ( wcslen(wcsErrorFile) > 0 ) )
        {
            //
            //  Set CiErrorMessage and CiErrorNumber.
            //
            //  The variables won't own the memory for the strings;
            //  the pointers will be reset later.
            //
            PROPVARIANT propVariant;
            propVariant.vt = VT_LPWSTR;
            propVariant.pwszVal = awcsErrorMessage;

            pVariableSet->SetVariable( ISAPI_CI_ERROR_MESSAGE,
                                       &propVariant,
                                       0 );

            WCHAR achErrorNumber[11];
            swprintf( achErrorNumber, L"0x%8x", status );

            propVariant.pwszVal = achErrorNumber;
            pVariableSet->SetVariable( ISAPI_CI_ERROR_NUMBER,
                                       &propVariant,
                                       0 );

            WCHAR wcsPhysicalPath[_MAX_PATH];
            ULONG cwcVirtualPath = wcslen(wcsErrorFile) + 1;

            XPtrST<WCHAR> wcsVirtualPath( new WCHAR[cwcVirtualPath] );

            //
            // We could have a virtual root or a physical root
            // All virtual roots begin with a "/".
            //

            if (wcsErrorFile[0] == L'/')
            {
                //
                //  Ask the web server to convert the virtual path to our error
                //  message file to a physical path.
                //
                webServer.GetPhysicalPath( wcsErrorFile, wcsPhysicalPath, _MAX_PATH );
   
                RtlCopyMemory( wcsVirtualPath.GetPointer(),
                               wcsErrorFile,
                               cwcVirtualPath*sizeof(WCHAR) );
            }
            else
            {
                // simply copy the path to physical path. It has to be a physical
                // path. If not, it will result in an error later.

                wcscpy(wcsPhysicalPath, wcsErrorFile);
            }

            CSecurityIdentity securityStub;

            CHTXFile htxFile( wcsVirtualPath,
                              pOutputFormat->CodePage(),
                              securityStub,
                              pOutputFormat->GetServerInstance() );

            ciGibDebugOut((DEB_ITRACE, "File is: %ws\n", wcsPhysicalPath));
            htxFile.ParseFile( wcsPhysicalPath, *pVariableSet, webServer );
            htxFile.GetHeader( vString, *pVariableSet, *pOutputFormat );
        }
        else
        {
            vString.StrCat( L"<HTML>" );
            HTMLEscapeW( awcsErrorMessage,
                         vString, 
                         pOutputFormat->CodePage() );
        }
    }
    CATCH ( CException, e )
    {
        fCaughtException = TRUE;
    }
    END_CATCH

    TRY
    {
        // Extending the vstring can fail

        if ( fCaughtException )
        {
            vString.StrCat( L"<HTML>" );
            HTMLEscapeW( awcsErrorMessage,
                         vString, 
                         pOutputFormat->CodePage() );
        }

        // These can fail if the variable wasn't set above

        if ( pVariableSet )
        {
            PROPVARIANT propVariant;
            propVariant.vt = VT_EMPTY;

            pVariableSet->SetVariable( ISAPI_CI_ERROR_MESSAGE,
                                       &propVariant,
                                       0 );
            pVariableSet->SetVariable( ISAPI_CI_ERROR_NUMBER,
                                       &propVariant,
                                       0 );
        }
    }
    CATCH ( CException, e )
    {
        // give up
    }
    END_CATCH
} //GetErrorPageNoThrow


//+---------------------------------------------------------------------------
//
//  Function:   GetErrorPageNoThrow - public
//
//  Synposis:   Generates an error page based on the error parameters passed.
//              The error description is already available.
//
//  Arguments:  [scError]          - error SCODE generated
//              [pwszErrorMessage] - description provided by ole-db error mechanism
//              [pVariableSet]     - replaceable parameters which generated the error
//              [pOutputFormat]    - format of dates & numbers
//              [locale]           - locale of the browser
//              [webServer]        - the web server
//              [vString]          - virtual string to contain error code
//
//  History:    08-May-97   KrishnaN    Created
//
//----------------------------------------------------------------------------

void GetErrorPageNoThrow( int eErrorClass,
                          SCODE scError,
                          WCHAR const * pwszErrorMessage,
                          CVariableSet * pVariableSet,
                          COutputFormat * pOutputFormat,
                          LCID locale,
                          CWebServer & webServer,
                          CVirtualString & vString
                        )
{
    BOOL fCaughtException = FALSE;

    //
    //  Try to bind to language object by looking up registry and get
    //  the error message HTX file associated with this class of error.
    //
    TRY
    {
        //
        //  If the error was the result of an access denied problem, then simply
        //  return a 401 error to the browser
        //

        //
        //  Generate the Win32 error code by removing the facility code (7) and
        //  the error bit.
        //
        ULONG Win32status = scError;
        if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
        {
            Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );
        }


        if ( (STATUS_ACCESS_DENIED == scError) ||
             (STATUS_NETWORK_ACCESS_DENIED == scError) ||
             (ERROR_ACCESS_DENIED == Win32status) ||
             (ERROR_INVALID_ACCESS == Win32status) ||
             (ERROR_NETWORK_ACCESS_DENIED == Win32status)
           )
        {
            ciGibDebugOut(( DEB_WARN, "mapping 0x%x to 401 access denied\n", scError ));

            ReturnServerError( HTTP_STATUS_DENIED, webServer );
            return;
        }

        CWebLangLocator langreg( locale );

        WCHAR * wcsErrorFile = 0;

        if ( langreg.LocaleFound() )
        {
            //
            //  If the locale was found in the registry, get the error message
            //  file associated with this language.
            //

            switch (eErrorClass)
            {
            case eIDQParseError:
            case eIDQPlistError:
                wcsErrorFile = langreg.GetIDQErrorFile();
            break;

            case eHTXParseError:
                wcsErrorFile = langreg.GetHTXErrorFile();
            break;

            case eRestrictionParseError:
                wcsErrorFile = langreg.GetRestrictionErrorFile();
            break;

            default:
                wcsErrorFile = langreg.GetDefaultErrorFile();
            break;
            }
        }

        if ( ( 0 != pVariableSet ) &&
             ( 0 != pOutputFormat ) &&
             ( 0 != wcsErrorFile ) &&
             ( wcslen(wcsErrorFile) > 0 ) )
        {
            //
            //  Set CiErrorMessage and CiErrorNumber.
            //
            //  The variables won't own the memory for the strings;
            //  the pointers will be reset later.
            //
            PROPVARIANT propVariant;
            propVariant.vt = VT_LPWSTR;
            propVariant.pwszVal = (LPWSTR)pwszErrorMessage;

            pVariableSet->SetVariable( ISAPI_CI_ERROR_MESSAGE,
                                       &propVariant,
                                       0 );

            WCHAR achErrorNumber[11];
            swprintf( achErrorNumber, L"0x%8x", scError );

            propVariant.pwszVal = achErrorNumber;
            pVariableSet->SetVariable( ISAPI_CI_ERROR_NUMBER,
                                       &propVariant,
                                       0 );

            WCHAR wcsPhysicalPath[_MAX_PATH];
            ULONG cwcVirtualPath = wcslen(wcsErrorFile) + 1;

            XPtrST<WCHAR> wcsVirtualPath( new WCHAR[cwcVirtualPath] );

            //
            // We could have a virtual root or a physical root
            // All virtual roots begin with a "/".
            //

            if (wcsErrorFile[0] == L'/')
            {
                //
                //  Ask the web server to convert the virtual path to our error
                //  message file to a physical path.
                //
                webServer.GetPhysicalPath( wcsErrorFile, wcsPhysicalPath, _MAX_PATH );
   
                RtlCopyMemory( wcsVirtualPath.GetPointer(),
                               wcsErrorFile,
                               cwcVirtualPath*sizeof(WCHAR) );
            }
            else
            {
                // simply copy the path to physical path. It has to be a physical
                // path. If not, it will result in an error later.

                wcscpy(wcsPhysicalPath, wcsErrorFile);
            }



            CSecurityIdentity securityStub;

            CHTXFile htxFile( wcsVirtualPath,
                              pOutputFormat->CodePage(),
                              securityStub,
                              pOutputFormat->GetServerInstance() );

            ciGibDebugOut((DEB_ITRACE, "File is: %ws\n", wcsPhysicalPath));
            htxFile.ParseFile( wcsPhysicalPath, *pVariableSet, webServer );
            htxFile.GetHeader( vString, *pVariableSet, *pOutputFormat );
        }
        else
        {
            vString.StrCat( L"<HTML>" );
            vString.StrCat( pwszErrorMessage );
        }
    }
    CATCH ( CException, e )
    {
        fCaughtException = TRUE;
    }
    END_CATCH

    TRY
    {
        // Extending the vstring can fail

        if ( fCaughtException )
        {
            vString.StrCat( L"<HTML>" );
            vString.StrCat( pwszErrorMessage );
        }

        // These can fail if the variable wasn't set above

        if ( pVariableSet )
        {
            PROPVARIANT propVariant;
            propVariant.vt = VT_EMPTY;

            pVariableSet->SetVariable( ISAPI_CI_ERROR_MESSAGE,
                                       &propVariant,
                                       0 );
            pVariableSet->SetVariable( ISAPI_CI_ERROR_NUMBER,
                                       &propVariant,
                                       0 );
        }
    }
    CATCH ( CException, e )
    {
        // give up
    }
    END_CATCH
} //GetErrorPageNoThrow


enum
{
    eAccessDeniedMsg = 0,
    eServerBusyMsg,
    eServerErrorMsg,
};

#define MAX_SERVER_ERROR_MSGSIZE 100

WCHAR g_awszServerErrorMsgs [3] [MAX_SERVER_ERROR_MSGSIZE] =
{
    L"Access denied.\r\n",
    L"Server too busy.\r\n",
    L"Unexpected server error.\r\n",
};

//+---------------------------------------------------------------------------
//
//  Function:   ReturnServerError - public
//
//  Synposis:   Generates an error page for an HTTP error code.
//
//  Arguments:  [httpError]       - the HTTP status code
//              [webServer]       - the web server
//
//  Notes:      This is used when the server is too busy; it should be a
//              very low-overhead path.
//
//  History:    12 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void ReturnServerError( ULONG httpError,
                        CWebServer & webServer )
{
    char const * pszHeader = "";
    int iMessage = 0;

    switch (httpError)
    {
    case HTTP_STATUS_DENIED:
        pszHeader = "401 Access denied";
        iMessage = eAccessDeniedMsg;
        break;

    case HTTP_STATUS_SERVICE_UNAVAIL:
        pszHeader = "503 Server busy";
        iMessage = eServerBusyMsg;
        break;

    default:
        ciGibDebugOut(( DEB_ERROR, "unexpected server error status %d\n", httpError ));
        httpError = HTTP_STATUS_SERVER_ERROR;
        iMessage = eServerErrorMsg;
        break;
    }

    webServer.WriteHeader( 0, pszHeader );

    WCHAR * pwszMessage = g_awszServerErrorMsgs[iMessage];
    webServer.WriteClient( pwszMessage );
    webServer.SetHttpStatus( httpError );
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadServerErrors - public
//
//  Synposis:   Load messages for server errors.
//
//  Arguments:  -NONE-
//
//  Notes:
//
//  History:    29 Sep 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void LoadServerErrors( )
{
    unsigned iMessage = eAccessDeniedMsg;
    SCODE scMessage = MSG_CI_ACCESS_DENIED;
    const unsigned cMessages = sizeof g_awszServerErrorMsgs /
                               sizeof g_awszServerErrorMsgs[0];


    while (iMessage < cMessages)
    {
        FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                       GetModuleHandle(L"idq.dll"),
                       scMessage,
                       GetSystemDefaultLangID(),
                       &g_awszServerErrorMsgs [iMessage][0],
                       MAX_SERVER_ERROR_MSGSIZE,
                       0 );
        scMessage++;
        iMessage++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\outfmt.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       OutFmt.cxx
//
//  Contents:   COutputFormat
//
//  History:    11-Jun-97   KyleP       Moved from WQIter.cxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

static WCHAR * wcsDefaultBoolVectorPrefix        = L" ";
static WCHAR * wcsDefaultBoolVectorSeparator     = L" ";
static WCHAR * wcsDefaultBoolVectorSuffix        = L" ";
static WCHAR * wcsDefaultCurrencyVectorPrefix    = L" ";
static WCHAR * wcsDefaultCurrencyVectorSeparator = L" ";
static WCHAR * wcsDefaultCurrencyVectorSuffix    = L" ";
static WCHAR * wcsDefaultDateVectorPrefix        = L" ";
static WCHAR * wcsDefaultDateVectorSeparator     = L" ";
static WCHAR * wcsDefaultDateVectorSuffix        = L" ";
static WCHAR * wcsDefaultNumberVectorPrefix      = L" ";
static WCHAR * wcsDefaultNumberVectorSeparator   = L" ";
static WCHAR * wcsDefaultNumberVectorSuffix      = L" ";
static WCHAR * wcsDefaultStringVectorPrefix      = L" ";
static WCHAR * wcsDefaultStringVectorSeparator   = L" ";
static WCHAR * wcsDefaultStringVectorSuffix      = L" ";

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::COutputFormat - public
//
//  Arguments:  [webServer] - makes a copy of the web server to resolve CGI
//                            variables
//
//  Synopsis:   Constructor
//
//  History:    96-Jan-18   DwightKr    Created
//              96-Feb-26   DwightKr    Added vector formatting
//
//----------------------------------------------------------------------------

COutputFormat::COutputFormat( CWebServer & webServer )
        : CWebServer( webServer ),
          _wcsBoolVectorPrefix( wcsDefaultBoolVectorPrefix ),
          _wcsBoolVectorSeparator( wcsDefaultBoolVectorSeparator ),
          _wcsBoolVectorSuffix( wcsDefaultBoolVectorSuffix ),
          _wcsCurrencyVectorPrefix( wcsDefaultCurrencyVectorPrefix ),
          _wcsCurrencyVectorSeparator( wcsDefaultCurrencyVectorSeparator ),
          _wcsCurrencyVectorSuffix( wcsDefaultCurrencyVectorSuffix ),
          _wcsDateVectorPrefix( wcsDefaultDateVectorPrefix ),
          _wcsDateVectorSeparator( wcsDefaultDateVectorSeparator ),
          _wcsDateVectorSuffix( wcsDefaultDateVectorSuffix ),
          _wcsNumberVectorPrefix( wcsDefaultNumberVectorPrefix ),
          _wcsNumberVectorSeparator( wcsDefaultNumberVectorSeparator ),
          _wcsNumberVectorSuffix( wcsDefaultNumberVectorSuffix ),
          _wcsStringVectorPrefix( wcsDefaultStringVectorPrefix ),
          _wcsStringVectorSeparator( wcsDefaultStringVectorSeparator ),
          _wcsStringVectorSuffix( wcsDefaultStringVectorSuffix )
{
    _numberFormat.lpDecimalSep  = 0;
    _numberFormat.lpThousandSep = 0;

    _currencyFormat.lpDecimalSep     = 0;
    _currencyFormat.lpThousandSep    = 0;
    _currencyFormat.lpCurrencySymbol = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::GetIntegerFormat - private
//
//  Synopsis:   Formats a number and returns results in the string
//              buffer supplied.
//
//  Arguments:  [wcsInput]  - string to convert
//              [wcsNumber] - output location for results
//              [_cwcNumber] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::GetIntegerFormat( WCHAR * const wcsInput,
                                     WCHAR * wcsNumber,
                                     ULONG cwcNumber )
{
    Win4Assert( 0 != _numberFormat.lpDecimalSep );
    Win4Assert( 0 != _numberFormat.lpThousandSep );
    Win4Assert( InvalidLCID != GetLCID() );

    ULONG numDigits = _numberFormat.NumDigits;
    _numberFormat.NumDigits = 0;

    int cwcResult = ::GetNumberFormat( GetLCID(),
                                       0,
                                       wcsInput,
                                      &_numberFormat,
                                       wcsNumber,
                                       cwcNumber );

    _numberFormat.NumDigits = numDigits;

    if ( 0 == cwcResult )
    {
        THROW( CException() );
    }

    return cwcResult - 1;
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatNumber - public
//
//  Synopsis:   Formats a unsigned number and returns results in the string
//              buffer supplied.
//
//  Arguments:  [ulNumber]  - number to convert
//              [wcsNumber] - output location for results
//              [cwcNumber] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatNumber( ULONG ulNumber,
                                 WCHAR * wcsNumber,
                                 ULONG cwcNumber )
{
    WCHAR wcsBuffer[40];
    IDQ_ultow( ulNumber, wcsBuffer );

    return GetIntegerFormat( wcsBuffer, wcsNumber, cwcNumber );
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatNumber
//
//  Synopsis:   Formats a signed number and returns results in the string
//              buffer supplied.
//
//  Arguments:  [lNumber]   - number to convert
//              [wcsNumber] - output location for results
//              [cwcNumber] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatNumber( LONG lNumber,
                                 WCHAR * wcsNumber,
                                 ULONG cwcNumber )
{
    WCHAR wcsBuffer[40];
    IDQ_ltow( lNumber, wcsBuffer );

    return GetIntegerFormat( wcsBuffer, wcsNumber, cwcNumber );
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatNumber
//
//  Synopsis:   Formats a _int64 and returns results in the string
//              buffer supplied.
//
//  Arguments:  [i64Number] - number to convert
//              [wcsNumber] - output location for results
//              [cwcNumber] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatNumber( _int64 i64Number,
                                 WCHAR * wcsNumber,
                                 ULONG cwcNumber )
{
    WCHAR wcsBuffer[40];
    IDQ_lltow( i64Number, wcsBuffer );

    return GetIntegerFormat( wcsBuffer, wcsNumber, cwcNumber );
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatNumber
//
//  Synopsis:   Formats a unsigned _int64 and returns results in the string
//              buffer supplied.
//
//  Arguments:  [ui64Number] - number to convert
//              [wcsNumber]  - output location for results
//              [cwcNumber]  - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatNumber( unsigned _int64 ui64Number,
                                 WCHAR * wcsNumber,
                                 ULONG cwcNumber )
{
    WCHAR wcsBuffer[40];
    IDQ_ulltow( ui64Number, wcsBuffer );

    return GetIntegerFormat( wcsBuffer, wcsNumber, cwcNumber );
}


//+---------------------------------------------------------------------------
//
//  Method:     COutputFormat::FormatFloatRaw, public
//
//  Synopsis:   Formats a floating point number and returns results in the
//              string buffer supplied.
//
//  Arguments:  [flt]        - number to be formatted
//              [cchPrec]    - number of digits of precision to use
//              [pwszNumber] - output location for results
//              [cchNumber]  - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  Notes:      GetNumberFormat isn't really very useful for numbers with
//              very large or small magnitudes.  It gives up when there are
//              about 100 digits to the left of the decimal place.
//
//  History:    96-Jan-18   DwightKr    Created
//              96-May-22   DwightKr    Increased buffer size
//              97-Mar-12   AlanW       Changed signature to better handle
//                                      single-precision floating point
//
//----------------------------------------------------------------------------

int COutputFormat::FormatFloatRaw( double flt,
                                   unsigned cchPrec,
                                   WCHAR * pwszNumber,
                                   ULONG cchNumber )
{
    int  iDec, fSign;
    char * pszCvt = _ecvt( flt, cchPrec, &iDec, &fSign );

    WCHAR *pwsz = pwszNumber;

    if (fSign)
        *pwsz++ = L'-';

    if (iDec <= 0)
    {
        *pwsz++ = L'.';
        while (iDec < 0)
        {
            *pwsz++ = L'0';
            iDec++;
        }
    }

    for (unsigned i=0; i< cchPrec; i++)
    {
        *pwsz++ = *pszCvt++;

        if (iDec && --iDec == 0)
            *pwsz++ = L'.';
    }

    while (iDec > 0)
    {
        *pwsz++ = L'0';
        iDec--;
    }
    *pwsz = L'\0';

    int cchResult = (int)(pwsz - pwszNumber);
    Win4Assert ((unsigned)cchResult < cchNumber);

    if ((unsigned)cchResult >= cchNumber)
    {
        ciGibDebugOut((DEB_WARN, "FormatFloatRaw - string buffer overflow!\n"));
        cchResult = -1;
    }

    return cchResult;
} //FormatFloatRaw

//+---------------------------------------------------------------------------
//
//  Method:     COutputFormat::FormatFloat, public
//
//  Synopsis:   Formats a floating point number and returns results in the
//              string buffer supplied.
//
//  Arguments:  [flt]        - number to be formatted
//              [cchPrec]    - number of digits of precision to use
//              [pwszNumber] - output location for results
//              [cchNumber]  - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  Notes:      GetNumberFormat isn't really very useful for numbers with
//              very large or small magnitudes.  It gives up when there are
//              about 100 digits to the left of the decimal place.
//
//  History:    96-Jan-18   DwightKr    Created
//              96-May-22   DwightKr    Increased buffer size
//              97-Mar-12   AlanW       Changed signature to better handle
//                                      single-precision floating point
//
//----------------------------------------------------------------------------

int COutputFormat::FormatFloat( double flt,
                                unsigned cchPrec,
                                WCHAR * pwszNumber,
                                ULONG cchNumber )
{
    Win4Assert( 0 != _numberFormat.lpDecimalSep );
    Win4Assert( 0 != _numberFormat.lpThousandSep );
    Win4Assert( InvalidLCID != GetLCID() );

    WCHAR pwszInput[ maxFloatSize ];
    WCHAR *pwsz = pwszInput;

    int cch = FormatFloatRaw( flt,
                              cchPrec,
                              pwszInput,
                              sizeof pwszInput / sizeof pwszInput[0]);

    Win4Assert( cch > 0 );

    int cchResult = ::GetNumberFormat( GetLCID(),
                                       0,
                                       pwszInput,
                                       &_numberFormat,
                                       pwszNumber,
                                       cchNumber );

    if ( 0 == cchResult )
    {
        ciGibDebugOut(( DEB_WARN, "FormatFloat - GetNumberFormat failed, error = %d\n", GetLastError() ));
        THROW( CException() );
    }

    return cchResult - 1;
} //FormatFloat

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatDate
//
//  Synopsis:   Formats a SYSTEMTIME and returns results in the string
//              buffer supplied.
//
//  Arguments:  [sysTime] - date to convert
//              [wcsDate] - output location for results
//              [cwcDate] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

int COutputFormat::FormatDate(
    SYSTEMTIME & sysTime,
    WCHAR *      wcsDate,
    ULONG        cwcDate )
{
    *wcsDate = 0;
    Win4Assert( InvalidLCID != GetLCID() );

    ULONG ulMethod = TheIDQRegParams.GetDateTimeFormatting();

    // Fixed, non-localized formatting

    if ( IS_DATETIME_FORMATTING_FAST_LCID == ulMethod )
    {
        if ( cwcDate < 10 )
            return 0;

        wsprintf( wcsDate, L"%4d/%02d/%02d",
                  (DWORD) sysTime.wYear,
                  (DWORD) sysTime.wMonth,
                  (DWORD) sysTime.wDay );
        return 10;
    }

    // Format the date using the locale provided.
    
    ULONG ulFlags = DATE_SHORTDATE;

    if ( IS_DATETIME_FORMATTING_SYSTEM_LCID == ulMethod )
        ulFlags |= LOCALE_NOUSEROVERRIDE;

    ULONG cwcUsed = GetDateFormat( GetLCID(),
                                   ulFlags,
                                   &sysTime,
                                   0,
                                   wcsDate,
                                   cwcDate );
    
    if ( 0 != cwcUsed )
    {
        Win4Assert( 0 == wcsDate[cwcUsed - 1] );
    
        // cwcUsed includes the null termination -- remove it.
    
        return cwcUsed - 1;
    }
    
    #if DBG == 1
    
        ULONG error = GetLastError();
    
        ciGibDebugOut(( DEB_ERROR,
                        "GetDateFormat failed: 0x%x\n",
                        error ));
    
        // ERROR_INVALID_PARAMETER indicates that the date is
        // bogus -- perhaps because the file was deleted.
    
        if ( ERROR_INVALID_PARAMETER != error )
            Win4Assert( !"GetTimeFormat failed" );
    
    #endif // DBG == 1
    
    return 0;
} //FormatDate

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatTime
//
//  Synopsis:   Formats a SYSTEMTIME and returns results in the string
//              buffer supplied.
//
//  Arguments:  [sysTime] - date to convert
//              [wcsTime] - output location for results
//              [cwcTime] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

int COutputFormat::FormatTime(
    SYSTEMTIME & sysTime,
    WCHAR *      wcsTime,
    ULONG        cwcTime )
{
    *wcsTime = 0;
    Win4Assert( InvalidLCID != GetLCID() );

    ULONG ulMethod = TheIDQRegParams.GetDateTimeFormatting();

    // Fixed, non-localized formatting

    if ( IS_DATETIME_FORMATTING_FAST_LCID == ulMethod )
    {
        if ( cwcTime < 8 )
            return 0;

        wsprintf( wcsTime, L"%2d:%02d:%02d",
                  (DWORD) sysTime.wHour,
                  (DWORD) sysTime.wMinute,
                  (DWORD) sysTime.wSecond );
        return 8;
    }
    
    // Format the time using the locale provided.

    ULONG ulFlags = ( IS_DATETIME_FORMATTING_USER_LCID == ulMethod ) ?
                    0 : LOCALE_NOUSEROVERRIDE;

    ULONG cwcUsed = GetTimeFormat( GetLCID(),
                                   ulFlags,
                                   &sysTime,
                                   0,
                                   wcsTime,
                                   cwcTime );

    if ( 0 != cwcUsed )
    {
        Win4Assert( 0 == wcsTime[cwcUsed - 1] );

        // cwcUsed includes the null termination -- remove it.

        return cwcUsed - 1;
    }

    #if DBG == 1

        ULONG error = GetLastError();

        ciGibDebugOut(( DEB_ERROR,
                        "GetTimeFormat failed: 0x%x\n",
                        error ));

        // ERROR_INVALID_PARAMETER indicates that the date is
        // bogus -- perhaps because the file was deleted.

        if ( ERROR_INVALID_PARAMETER != error )
            Win4Assert( !"GetTimeFormat failed" );

    #endif // DBG == 1

    return 0;
} //FormatTime

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatDateTime
//
//  Synopsis:   Formats a SYSTEMTIME and returns results in the string
//              buffer supplied.
//
//  Arguments:  [sysTime] - date to convert
//              [wcsDate] - output location for results
//              [cwcDate] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

int COutputFormat::FormatDateTime( SYSTEMTIME & SysTime,
                                   WCHAR * wcsDate,
                                   ULONG cwcDate )
{
    //
    // Convert UTC/GMT to local system time if set in the registry
    //

    if ( TheIDQRegParams.GetDateTimeLocal() )
    {
        FILETIME ft, ftLocal;
        SystemTimeToFileTime( &SysTime, &ft );
        FileTimeToLocalFileTime( &ft, &ftLocal );
        FileTimeToSystemTime( &ftLocal, &SysTime );
    }

    int cwcDateBuffer = FormatDate( SysTime, wcsDate, cwcDate );

    wcsDate[cwcDateBuffer] = L' ';

    int cwcBuffer = max( 0, ( (int) (cwcDate - cwcDateBuffer ) ) - 2 );

    int cwcTimeBuffer = FormatTime( SysTime,
                                    wcsDate+cwcDateBuffer+1,
                                    cwcBuffer );

    return cwcTimeBuffer + cwcDateBuffer + 1;
} //FormatDateTime

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatCurrency
//
//  Synopsis:   Formats a CY and returns results in the string
//              buffer supplied.
//
//  Arguments:  [cyValue]     - number to convert
//              [wcsCurrency] - output location for results
//              [cwcCurrency] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatCurrency( CY cyValue,
                                   WCHAR * wcsCurrency,
                                   ULONG cwcCurrency )
{
    Win4Assert( 0 != _numberFormat.lpDecimalSep );
    Win4Assert( 0 != _numberFormat.lpThousandSep );
    Win4Assert( 0 != _currencyFormat.lpDecimalSep );
    Win4Assert( 0 != _currencyFormat.lpThousandSep );
    Win4Assert( InvalidLCID != GetLCID() );

    WCHAR wcsBuffer[ maxFloatSize ];
    double dblValue;
    VarR8FromCy( cyValue, &dblValue );

    swprintf( wcsBuffer, L"%lf", dblValue );

    int cwcResult = ::GetCurrencyFormat( GetLCID(),
                                         0,
                                         wcsBuffer,
                                        &_currencyFormat,
                                         wcsCurrency,
                                         cwcCurrency );
    if ( 0 == cwcResult )
    {
        THROW( CException() );
    }

    return cwcResult - 1;
} //FormatCurrency

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::LoadNumberFormatInfo - public
//
//  Synopsis:   Fills the numberFormat stucture with formatting information
//              used to subsequently format numbers.
//
//  History:    97-Jun-24   t-elainc    Created
//
//----------------------------------------------------------------------------

void COutputFormat::LoadNumberFormatInfo( LCID lcid )
{
    LoadNumberFormatInfo(lcid, LocaleToCodepage(lcid) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertGroupingStringToInt
//
//  Synopsis:   Converts a grouping string from the registry to an integer,
//              as required by the Win32 number formatting API
//
//  History:    5-Feb-99   dlee      Stole from the Win32 implementation
//
//----------------------------------------------------------------------------

int ConvertGroupingStringToInt( WCHAR const * pwcGrouping )
{
    XGrowable<WCHAR> xDest( 1 + wcslen( pwcGrouping ) );
    WCHAR * pDest = xDest.Get();

    //
    //  Filter out all non-numeric values and all zero values.
    //  Store the result in the destination buffer.
    //

    WCHAR const * pSrc  = pwcGrouping;

    while (0 != *pSrc)
    {
        if ( ( *pSrc < L'1' ) || ( *pSrc > L'9' ) )
        {
            pSrc++;
        }
        else
        {
            if (pSrc != pDest)
                *pDest = *pSrc;

            pSrc++;
            pDest++;
        }
    }

    //
    // Make sure there is something in the destination buffer.
    // Also, see if we need to add a zero in the case of 3;2 becomes 320.
    //

    if ( ( pDest == xDest.Get() ) || ( *(pSrc - 1) != L'0' ) )
    {
        *pDest = L'0';
        pDest++;
    }

    // Null terminate the buffer.

    *pDest = 0;

    // Convert the string to an integer.

    return _wtoi( xDest.Get() );
} //ConvertGroupingStringToInt

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::LoadNumberFormatInfo - public
//
//  Synopsis:   Fills the numberFormat stucture with formatting information
//              used to subsequently format numbers.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void COutputFormat::LoadNumberFormatInfo( LCID lcid , ULONG codepage)
{
    Win4Assert( InvalidLCID != lcid );

    //
    // If we're already loaded, then don't do it again.
    //

    if ( lcid == GetLCID() && 0 != _numberFormat.lpDecimalSep )
        return;

    delete _numberFormat.lpDecimalSep;
    delete _numberFormat.lpThousandSep;
    delete _currencyFormat.lpDecimalSep;
    delete _currencyFormat.lpThousandSep;

    _numberFormat.lpDecimalSep = 0;
    _numberFormat.lpThousandSep = 0;
    _currencyFormat.lpDecimalSep = 0;
    _currencyFormat.lpThousandSep = 0;

    Win4Assert( 0 == _numberFormat.lpDecimalSep );
    Win4Assert( 0 == _numberFormat.lpThousandSep );
    Win4Assert( 0 == _currencyFormat.lpDecimalSep );
    Win4Assert( 0 == _currencyFormat.lpThousandSep );

    SetLCID( lcid, 0, 0 );

    TheFormattingCache.GetFormattingInfo( lcid,
                                          _numberFormat,
                                          _currencyFormat );

    SetCodePage( codepage );

    ciGibDebugOut(( DEB_ITRACE, "Using a codePage of 0x%x for locale 0x%x\n",
                                 CodePage(),
                                 GetLCID() ));
} //LoadNumberFormatInfo


//+---------------------------------------------------------------------------
//
//  Method:     CFormatItem::CFormatItem, public
//
//  Synopsis:   Constructs formatting info.
//
//  Arguments:  [lcid]  -- The locale to use.
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

CFormatItem::CFormatItem( LCID lcid ) : _lcid( lcid )
{
    WCHAR wcsBuffer[256];

    RtlZeroMemory( &_numberFormat, sizeof _numberFormat );
    RtlZeroMemory( &_currencyFormat, sizeof _currencyFormat );

    //  Get the number of decimal digits.
    GetLocaleInfo(lcid, LOCALE_IDIGITS, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _numberFormat.NumDigits = _wtoi(wcsBuffer);

    //  Get the leading zero in decimal fields option.
    GetLocaleInfo(lcid, LOCALE_ILZERO, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _numberFormat.LeadingZero = _wtoi(wcsBuffer);

    //  Get the negative ordering.
    GetLocaleInfo(lcid, LOCALE_INEGNUMBER, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _numberFormat.NegativeOrder = _wtoi(wcsBuffer);

    //  Get the grouping left of the decimal.
    GetLocaleInfo(lcid, LOCALE_SGROUPING, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _numberFormat.Grouping = ConvertGroupingStringToInt( wcsBuffer );
    ciGibDebugOut(( DEB_ITRACE, "grouping '%ws' -> %d\n",
                    wcsBuffer, _numberFormat.Grouping ));

    //  Get the decimal separator.
    GetLocaleInfo(lcid, LOCALE_SDECIMAL, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    XPtrST<WCHAR> xNumDecimalSep( CopyString( wcsBuffer ) );
    _numberFormat.lpDecimalSep = xNumDecimalSep.GetPointer();

    //  Get the thousand separator.
    GetLocaleInfo(lcid, LOCALE_STHOUSAND, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    XPtrST<WCHAR> xNumThousandSep( CopyString( wcsBuffer ) );
    _numberFormat.lpThousandSep = xNumThousandSep.GetPointer();

    //  Get the number of currency digits.
    GetLocaleInfo(lcid, LOCALE_ICURRDIGITS, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _currencyFormat.NumDigits = _wtoi(wcsBuffer);

    GetLocaleInfo(lcid, LOCALE_ILZERO, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    //  Get the leading zero in currency fields option.
    _currencyFormat.LeadingZero = _wtoi(wcsBuffer);

    //  Get the currency grouping left of the decimal.
    GetLocaleInfo(lcid, LOCALE_SMONGROUPING, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _currencyFormat.Grouping = _wtoi(wcsBuffer);

    //  Get the currency decimal separator.
    GetLocaleInfo(lcid, LOCALE_SMONDECIMALSEP, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    XPtrST<WCHAR> xCurDecimalSep( CopyString( wcsBuffer ) );
    _currencyFormat.lpDecimalSep = xCurDecimalSep.GetPointer();

    //  Get the currency thousand separator.
    GetLocaleInfo(lcid, LOCALE_SMONTHOUSANDSEP, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    XPtrST<WCHAR> xCurThousandSep( CopyString( wcsBuffer ) );
    _currencyFormat.lpThousandSep = xCurThousandSep.GetPointer();

    //  Get the negative ordering.
    GetLocaleInfo(lcid, LOCALE_INEGCURR, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _currencyFormat.NegativeOrder = _wtoi(wcsBuffer);

    //  Get the positive ordering.
    GetLocaleInfo(lcid, LOCALE_ICURRENCY, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _currencyFormat.PositiveOrder = _wtoi(wcsBuffer);

    _currencyFormat.lpCurrencySymbol = L"";

    xNumDecimalSep.Acquire();
    xNumThousandSep.Acquire();
    xCurDecimalSep.Acquire();
    xCurThousandSep.Acquire();
} //CFormatItem

//+---------------------------------------------------------------------------
//
//  Method:     CFormatItem::~CFormatItem, public
//
//  Synopsis:   Frees formatting info.
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

CFormatItem::~CFormatItem()
{
    delete _numberFormat.lpDecimalSep;
    delete _numberFormat.lpThousandSep;
    delete _currencyFormat.lpDecimalSep;
    delete _currencyFormat.lpThousandSep;
} //~CFormatItem

//+---------------------------------------------------------------------------
//
//  Method:     CFormatItem::Copy, public
//
//  Synopsis:   Copies formatting info into the arguments
//
//  Arguments:  [numberFormat]   -- Where the number format is copied to
//              [currencyFormat] -- Where the currency format is copied to
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

void CFormatItem::Copy(
    NUMBERFMT &   numberFormat,
    CURRENCYFMT & currencyFormat ) const
{
    XPtrST<WCHAR> xNumDecimalSep( CopyString( _numberFormat.lpDecimalSep ) );
    XPtrST<WCHAR> xNumThousandSep( CopyString( _numberFormat.lpThousandSep ) );
    XPtrST<WCHAR> xCurDecimalSep( CopyString( _currencyFormat.lpDecimalSep ) );
    XPtrST<WCHAR> xCurThousandSep( CopyString( _currencyFormat.lpDecimalSep ) );

    RtlCopyMemory( &numberFormat, &_numberFormat, sizeof NUMBERFMT );
    RtlCopyMemory( &currencyFormat, &_currencyFormat, sizeof CURRENCYFMT );

    numberFormat.lpDecimalSep = xNumDecimalSep.Acquire();
    numberFormat.lpThousandSep = xNumThousandSep.Acquire();
    currencyFormat.lpDecimalSep = xCurDecimalSep.Acquire();
    currencyFormat.lpThousandSep = xCurThousandSep.Acquire();
} //Copy

//+---------------------------------------------------------------------------
//
//  Method:     CFormattingCache::GetFormattingInfo, public
//
//  Synopsis:   Copies formatting info for lcid into the arguments
//
//  Arguments:  [lcid]           -- Locale of info to lookup
//              [numberFormat]   -- Where the number format is copied to
//              [currencyFormat] -- Where the currency format is copied to
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

void CFormattingCache::GetFormattingInfo(
    LCID          lcid,
    NUMBERFMT &   numberFormat,
    CURRENCYFMT & currencyFormat )
{
    CLock lock( _mutex );

    for ( unsigned i = 0; i < _aItems.Count(); i++ )
    {
        if ( _aItems[i]->GetLCID() == lcid )
        {
            _aItems[i]->Copy( numberFormat, currencyFormat );
            return;
        }
    }

    XPtr<CFormatItem> xItem( new CFormatItem( lcid ) );
    xItem->Copy( numberFormat, currencyFormat );
    _aItems.Add( xItem.GetPointer(), _aItems.Count() );
    xItem.Acquire();
} //GetFormattingInfo

//+---------------------------------------------------------------------------
//
//  Method:     CFormattingCache::Purge, public
//
//  Synopsis:   Purges the cache of all entries
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

void CFormattingCache::Purge()
{
    CLock lock( _mutex );

    _aItems.Clear();
} //Purge
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\main.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       main.cxx
//
//  Contents:   External entry points for idq.dll.
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ntverp.h>

#define IDQ_VERSION       3
#define IDQ_VERSION_MINOR 1

#define _DECL_DLLMAIN 1

CTheGlobalIDQVariables * pTheGlobalIDQVariables = 0;
DWORD                    g_cClients = 0;
CRITICAL_SECTION         g_csInitExclusive;

//+---------------------------------------------------------------------------
//
//  Function:   GetExtensionVersion - public
//
//  Synposis:   Returns extension info to the server.  This is called before
//              HttpExtensionProc is called, and it is called in System
//              context, so any initialization that requires this context
//              must be handled here.
//
//  Arguments:  [pVer]  - where the info goes
//
//  History:    96-Apr-15   dlee        Added header
//
//  Notes:      There may be multiple clients of this ISAPI app in one
//              process (eg W3Svc and NNTPSvc), so refcount the users.
//
//----------------------------------------------------------------------------

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO * pVer )
{
    BOOL fSuccess = TRUE;

    EnterCriticalSection( &g_csInitExclusive );

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        pVer->dwExtensionVersion = MAKELONG( IDQ_VERSION_MINOR, IDQ_VERSION );
        strcpy( pVer->lpszExtensionDesc, "Indexing Service extension" );

        if ( 0 == g_cClients )
        {
            Win4Assert( 0 == pTheGlobalIDQVariables );
            pTheGlobalIDQVariables = new CTheGlobalIDQVariables();
            LoadServerErrors();
        }

        g_cClients++;
    }
    CATCH( CException, e )
    {
        fSuccess = FALSE;

        ciGibDebugOut(( DEB_WARN, "GetExtensionVersion failed 0x%x\n",
                        e.GetErrorCode() ));
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    LeaveCriticalSection( &g_csInitExclusive );

    return fSuccess;
} //GetExtensionVersion

//+---------------------------------------------------------------------------
//
//  Function:   TerminateExtension, public
//
//  Synposis:   Called by IIS during shutdown

//  History:    29-Apr-96   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL WINAPI TerminateExtension( DWORD dwFlags )
{
    EnterCriticalSection( &g_csInitExclusive );

    TRANSLATE_EXCEPTIONS;

    BOOL fOK = FALSE;

    if ( dwFlags & HSE_TERM_MUST_UNLOAD )
    {
        TRY
        {
            Win4Assert( 0 != g_cClients );
            g_cClients--;
            if ( 0 == g_cClients )
            {
                ciGibDebugOut(( DEB_WARN, "Mandatory extension unload. Shutting down CI.\n" ));

                TheWebQueryCache.Shutdown();
                TheWebPendingRequestQueue.Shutdown();

                //
                //  Wait for all ISAPI threads to exit before shutting down CI
                //
                while ( TheWebResourceArbiter.GetThreadCount() > 0 )
                {
                    ciGibDebugOut(( DEB_WARN, "TerminateExtension: waiting for ISAPI threads to complete\n" ));
                    Sleep( 50 );
                }

                ciGibDebugOut(( DEB_WARN,
                                "TerminatExtension, request count %d\n",
                                TheWebQueryCache.ActiveRequestCount() ));

                // note: don't call CIShutdown here.  There's no need
                // to, and it'll hose the impersonation token cache for
                // webhits.

                delete pTheGlobalIDQVariables;
                pTheGlobalIDQVariables = 0;
            }
        }
        CATCH( CException, e )
        {
            // ignore
        }
        END_CATCH

        fOK = TRUE;
    }

    ciGibDebugOut(( DEB_WARN, "Extension unload: 0x%x. Flags = 0x%x\n",
                    fOK, dwFlags ));

    UNTRANSLATE_EXCEPTIONS;

    LeaveCriticalSection( &g_csInitExclusive );

    return fOK;
} //TerminateExtension


//+---------------------------------------------------------------------------
//
//  Function:   CreateQueryFromRequest, private
//
//  Synposis:   Issues a query from a request.
//
//  Arguments:  [outputFormat]  -- returns the formatting info.
//              [localVars]     -- returns the local variables.
//              [wcsIDQFile]    -- returns the idq file name.
//              [webServer]     -- web server for the request.
//              [eErrorClass]   -- returns the error class
//              [status]        -- returns the error code
//              [fPending]      -- returns TRUE if the request is pending
//
//  History:    96-Apr-15   dlee        created from existing code
//
//----------------------------------------------------------------------------

#if (CIDBG == 0)
inline
#endif

CWQueryItem * CreateQueryFromRequest( XPtr<COutputFormat> & outputFormat,
                                      XPtr<CVariableSet> &  localVars,
                                      WCHAR *               wcsIDQFile,
                                      CWebServer &          webServer,
                                      int &                 eErrorClass,
                                      NTSTATUS &            status,
                                      BOOL &                fPending )
{
    //
    // NOTE: COutputFormat makes a **copy** of the web server.  This
    //       copy should be used exclusively from this point on. The
    //       original web server will still be used by callers of this
    //       routine in cases where we fail to create the copy.
    //

    outputFormat.Set( new COutputFormat( webServer ) );
    localVars.Set( new CVariableSet );

    CSecurityIdentity securityIdentity;
    XArray<WCHAR> xLocale;

    //
    // Update the original web server, in case we use it in a top-level
    // error path.
    //

    webServer = outputFormat.GetReference();
    LCID locale = GetBrowserLCID( outputFormat.GetReference() , xLocale );
    outputFormat->LoadNumberFormatInfo( locale, GetBrowserCodepage(outputFormat.GetReference(), locale) );
    localVars->AddExtensionControlBlock( outputFormat.GetReference() );

    ULONG cwc = MAX_PATH;
    BOOL fOK = outputFormat->GetCGI_PATH_TRANSLATED( wcsIDQFile, cwc );

    if ( !fOK )
    {
        wcsIDQFile[0] = 0;
        THROW( CIDQException( MSG_CI_IDQ_NOT_FOUND, 0 ) );
    }

    outputFormat->SetCodePage(outputFormat->CodePage());

    Win4Assert( fOK );

    if ( IsNetPath(wcsIDQFile) )
    {
        ciGibDebugOut(( DEB_ERROR, "Path for idq file (%ws) is a UNC name\n",
                        wcsIDQFile ));

        THROW( CIDQException(MSG_CI_SCRIPTS_ON_REMOTE_UNC, 0) );
    }

    CWQueryItem *pItem = 0;

    //
    // Check to see whether this is an .IDQ or .IDA file.
    //

    static WCHAR const wszAdmin[] = L".IDA";
    static unsigned const ccAdmin = sizeof(wszAdmin)/sizeof(wszAdmin[0]) - 1;

    if ( cwc > ccAdmin && 0 == _wcsicmp( wszAdmin, wcsIDQFile + cwc - ccAdmin - 1 ) )
    {
        CVirtualString IDAResults;

        DoAdmin( wcsIDQFile,
                 localVars.GetReference(),
                 outputFormat.GetReference(),
                 IDAResults );

        if ( outputFormat->WriteClient( IDAResults ) )
            outputFormat->SetHttpStatus( HTTP_STATUS_OK );
        else
        {
            eErrorClass = eWebServerWriteError;
            outputFormat->SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
        }
    }
    else
    {
        //
        //  Atempt to find an existing query using this IDQ file, &
        //  sequence number, based on the bookmark received.
        //

        fPending = FALSE;
        pItem = TheWebQueryCache.CreateOrFindQuery( wcsIDQFile,
                                                    localVars,
                                                    outputFormat,
                                                    securityIdentity,
                                                    fPending );

        if ( fPending )
        {
            Win4Assert( 0 == pItem );
        }
        else
        {
            TRY
            {
                Win4Assert( !pItem->IsCanonicalOutput() );

                CVirtualString queryResults( 16384 );

                //
                //  Write the query results to a WCHAR string buffer
                //  Initial virtual string size is in WCHARs
                //
                pItem->OutputQueryResults( localVars.GetReference(),
                                           outputFormat.GetReference(),
                                           queryResults );

                //
                //  Send the query results to the browser
                //
                if ( outputFormat->WriteClient( queryResults ) )
                    outputFormat->SetHttpStatus( HTTP_STATUS_OK );
                else
                {
                    eErrorClass = eWebServerWriteError;
                    outputFormat->SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
                }
            }
            CATCH( CException, e )
            {
                eErrorClass = eDefaultISAPIError;
                status = e.GetErrorCode();
            }
            END_CATCH
        }
    }

    return pItem;
} //CreateQueryFromRequest

//+---------------------------------------------------------------------------
//
//  Function:   ReportErrorNoThrow, public
//
//  Synposis:   Attempts to report an error condition and log the query
//
//  Arguments:  [localVars]     -- local variables.
//              [eErrorClass]   -- error class
//              [status]        -- status code of faulure
//              [ulErrorLine]   -- line # of the error
//              [wcsErrorFile]  -- file associated with error
//              [outputFormat]  -- formatting info.
//              [webServer]     -- web server for the request.
//
//  History:    96-Nov-25   dlee    created from existing code, added TRY
//
//----------------------------------------------------------------------------
void ReportErrorNoThrow(
    XPtr<CVariableSet> &  localVars,
    int                   eErrorClass,
    NTSTATUS              status,
    ULONG                 ulErrorLine,
    WCHAR const *         wcsErrorFile,
    XPtr<COutputFormat> & outputFormat,
    CWebServer &          webServer )
{
    TRY
    {
        WCHAR * wcsRestriction = 0;

        //
        //  Lookup the restriction, if one has been fully constructed.
        //
        if ( 0 != localVars.GetPointer() )
        {
            CVariable * pVarRestriction = localVars->Find(ISAPI_CI_RESTRICTION);

            if ( 0 != pVarRestriction )
            {
                ULONG cwcValue;
                wcsRestriction = pVarRestriction->GetStringValueRAW( outputFormat.GetReference(), cwcValue );
            }
        }

        //
        //  Attempt to write out the error picture, if appropriate
        //

        CVirtualString vString;

        GetErrorPageNoThrow( eErrorClass,
                             status,
                             ulErrorLine,
                             wcsErrorFile,
                             localVars.GetPointer(),
                             outputFormat.GetPointer(),
                             outputFormat.GetPointer() ? outputFormat->GetLCID() : 0,
                             webServer,
                             vString );

        ciGibDebugOut(( DEB_IWARN, "WARNING: %ws\n", vString.Get() ));
        webServer.WriteClient( vString );

        Win4Assert( webServer.GetHttpStatus() >= HTTP_STATUS_FIRST );

        //
        //  Log the restriction in the failed query.  It may not have
        //  been logged yet since we may have thrown before it was
        //  logged in the query execution path.
        //
        // if ( 0 != wcsRestriction )
        //     webServer.WriteLogData( wcsRestriction );
    }
    CATCH( CException, e )
    {
        // ignore -- not enough memory to output an error message
    }
    END_CATCH
} //ReportErrorNoThrow

//+---------------------------------------------------------------------------
//
//  Function:   ReportErrorNoThrow, public
//
//  Synposis:   Attempts to report an error condition and log the query
//
//  Arguments:  [localVars]        -- local variables.
//              [scError]          -- error code
//              [pwszErrorMessage] -- Description provided by Ole-DB error svc.
//              [outputFormat]     -- formatting info.
//              [webServer]        -- web server for the request.
//
//  History:    97-May-08   KrishnaN    created from existing ReportErrorNoThrow
//
//----------------------------------------------------------------------------
void ReportErrorNoThrow(
    XPtr<CVariableSet> &  localVars,
    int                   eErrorClass,
    SCODE                 scError,
    WCHAR const *         pwszErrorMessage,
    XPtr<COutputFormat> & outputFormat,
    CWebServer &          webServer )
{
    TRY
    {
        WCHAR * wcsRestriction = 0;

        //
        //  Lookup the restriction, if one has been fully constructed.
        //
        if ( 0 != localVars.GetPointer() )
        {
            CVariable * pVarRestriction = localVars->Find(ISAPI_CI_RESTRICTION);

            if ( 0 != pVarRestriction )
            {
                ULONG cwcValue;
                wcsRestriction = pVarRestriction->GetStringValueRAW( outputFormat.GetReference(), cwcValue );
            }
        }

        //
        //  Attempt to write out the error picture, if appropriate
        //

        CVirtualString vString;

        GetErrorPageNoThrow(eErrorClass,
                            scError,
                            pwszErrorMessage,
                            localVars.GetPointer(),
                            outputFormat.GetPointer(),
                            outputFormat.GetPointer() ? outputFormat->GetLCID() : 0,
                            webServer,
                            vString );

        ciGibDebugOut(( DEB_IWARN, "WARNING: %ws\n", vString.Get() ));
        webServer.WriteClient( vString );

        Win4Assert( webServer.GetHttpStatus() >= HTTP_STATUS_FIRST );

        //
        //  Log the restriction in the failed query.  It may not have
        //  been logged yet since we may have thrown before it was
        //  logged in the query execution path.
        //
        // if ( 0 != wcsRestriction )
        //     webServer.WriteLogData( wcsRestriction );
    }
    CATCH( CException, e )
    {
        // ignore -- not enough memory to output an error message
    }
    END_CATCH
} //ReportErrorNoThrow

//+---------------------------------------------------------------------------
//
//  Function:   ProcessWebRequest, public
//
//  Synposis:   Issues a query from a request.
//
//  Arguments:  [webServer]     -- web server for the request.
//
//  Returns:    The HSE_STATUS code.
//
//  History:    96-Apr-15   dlee        created from existing code
//              98-Sep-16   KLam        Checks for valid method
//
//----------------------------------------------------------------------------

DWORD ProcessWebRequest(
    CWebServer & webServer )
{
    Win4Assert( HTTP_STATUS_ACCEPTED == webServer.GetHttpStatus() );

    WCHAR wcsIDQFile[MAX_PATH];
    wcsIDQFile[0] = 0;
    CWQueryItem *pItem = 0;

    XPtr<COutputFormat> outputFormat;
    XPtr<CVariableSet> localVars;

    NTSTATUS status = STATUS_SUCCESS;   // Error code from query
    ULONG ulErrorLine;                  // Line # in IDQ file error occured
    int eErrorClass;                    // Type of error, IDQ, HTX, parse, ...
    WCHAR const * wcsErrorFile = 0;     // Name of file containing error

    BOOL fPending = FALSE;

    //
    // Set the following flag to TRUE if we encounter an error
    // whose description is already available.
    //

    BOOL fReportErrorWithDescription = FALSE;
    BSTR bstrErrorDescription = 0;

    // 
    // Make sure we have a valid method
    //
    if ( strcmp ( webServer.GetMethod(), "HEAD" ) == 0 )
    {
        //
        // Do not need to execute the query if the client only wants the head
        //
        if ( webServer.WriteHeader() )
            webServer.SetHttpStatus ( HTTP_STATUS_OK );
        else
        {
            eErrorClass = eWebServerWriteError;
            webServer.SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
            return HSE_STATUS_ERROR;
        }

        return HSE_STATUS_SUCCESS;
    }
    // Only support GET and POST for queries
    else if ( strcmp( webServer.GetMethod(), "GET" ) != 0
              && strcmp ( webServer.GetMethod(), "POST" ) != 0 )
    {
        // HTTP 1.1 Spec determines value of header status string
        if ( webServer.WriteHeader( NULL, "501 Not Implemented" ) )
            webServer.SetHttpStatus ( HTTP_STATUS_NOT_SUPPORTED );
        else
        {
            eErrorClass = eWebServerWriteError;
            webServer.SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
        }

        return HSE_STATUS_ERROR;
    }
    else
    {
        TRY
        {
            pItem = CreateQueryFromRequest( outputFormat,
                                            localVars,
                                            wcsIDQFile,
                                            webServer,
                                            eErrorClass,
                                            status,
                                            fPending );
        }
        CATCH( CPListException, e )
        {
            status = e.GetPListError();
            ulErrorLine = e.GetLine();
            eErrorClass = eIDQPlistError;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        AND_CATCH( CIDQException, e )
        {
            status = e.GetErrorCode();
            ulErrorLine = e.GetErrorIndex();
            eErrorClass = eIDQParseError;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        AND_CATCH( CHTXException, e )
        {
            status = e.GetErrorCode();
            ulErrorLine = e.GetErrorIndex();
            eErrorClass = eHTXParseError;
            wcsErrorFile = e.GetHTXFileName();
 
            //
            // copy the error file name; it's stored on the stack below
            // this function.
            //
            ULONG cchFileName = min( wcslen(wcsErrorFile) + 1, MAX_PATH );
            Win4Assert(cchFileName < MAX_PATH);

            RtlCopyMemory( wcsIDQFile,
                           wcsErrorFile,
                           sizeof(WCHAR) * cchFileName );

            wcsIDQFile[MAX_PATH-1] = 0;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        AND_CATCH( CParserException, e )
        {
            status = e.GetParseError();
            ulErrorLine = 0;
            eErrorClass = eRestrictionParseError;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        AND_CATCH( CPostedOleDBException, e )
        {
            //
            // When the execution error was detected, the Ole DB error
            // info was retrieved and stored in the exception object.
            // We retrieve that here and compose the error message.
            //

            status = e.GetErrorCode();
            eErrorClass = e.GetErrorClass();
            Win4Assert( STATUS_SUCCESS != status );

            XInterface <IErrorInfo> xErrorInfo(e.AcquireErrorInfo());

            if (xErrorInfo.GetPointer())
                xErrorInfo->GetDescription(&bstrErrorDescription);
            if (bstrErrorDescription)
                fReportErrorWithDescription = TRUE;
            else
            {
                // NO description. Follow the normal path.
                ulErrorLine = 0;
                wcsErrorFile = wcsIDQFile;
            }
        }
        AND_CATCH( CException, e )
        {
            status = e.GetErrorCode();
            ulErrorLine = 0;
            eErrorClass = eDefaultISAPIError;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        END_CATCH
    }

    TRY
    {
        if ( STATUS_SUCCESS != status )
        {
            fPending = FALSE;

            // the request failed, but we're returning an error message,
            // so indicate that everything is ok.

            webServer.SetHttpStatus( HTTP_STATUS_OK );

            if (fReportErrorWithDescription)
            {
                Win4Assert(bstrErrorDescription);
                ReportErrorNoThrow(localVars,
                                   eErrorClass,
                                   status,
                                   (WCHAR const *)bstrErrorDescription,
                                   outputFormat,
                                   webServer );
                SysFreeString(bstrErrorDescription);
            }
            else
            {
                Win4Assert(0 == bstrErrorDescription);
                ReportErrorNoThrow( localVars,
                                    eErrorClass,
                                    status,
                                    ulErrorLine,
                                    wcsErrorFile,
                                    outputFormat,
                                    webServer );
            }

            if ( 0 != pItem )
                pItem->Zombify();
        }

        TheWebQueryCache.Release( pItem );
    }
    CATCH( CException, e )
    {
        ciGibDebugOut(( DEB_ERROR, "ProcessWebRequest Error 0x%X\n", e.GetErrorCode() ));
        Win4Assert( e.GetErrorCode() != STATUS_ACCESS_VIOLATION );
    }
    END_CATCH

    #if CIDBG == 1

        //
        // If fPending is TRUE, the http status of the ecb can't be trusted,
        // because the request may have asynchronously completed by now:
        //

        if ( !fPending )
        {
            DWORD dwHttpStatus = webServer.GetHttpStatus();

            Win4Assert( HTTP_STATUS_ACCEPTED != dwHttpStatus );
            Win4Assert( HTTP_STATUS_OK == dwHttpStatus ||
                        HTTP_STATUS_SERVER_ERROR == dwHttpStatus ||
                        HTTP_STATUS_DENIED == dwHttpStatus ||
                        HTTP_STATUS_SERVICE_UNAVAIL == dwHttpStatus );
        }

    #endif // CIDBG == 1

    if ( fPending )
        return HSE_STATUS_PENDING;

    return HSE_STATUS_SUCCESS;
} //ProcessWebRequest

//+---------------------------------------------------------------------------
//
//  Function:   HttpExtensionProc, public
//
//  Synposis:   Handles a request from the web server
//
//  Arguments:  [pEcb]          -- block from the server
//
//  History:    96-Apr-15   dlee        created header
//
//----------------------------------------------------------------------------

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pEcb )
{
    if ( 0 == pTheGlobalIDQVariables || fTheActiveXSearchShutdown )
    {
        ciGibDebugOut(( DEB_GIB_REQUEST,
                        "Indexing Service being shutdown\n" ));
        pEcb->dwHttpStatusCode = HTTP_STATUS_SERVICE_UNAVAIL;
        return HSE_STATUS_ERROR;
    }

    CIncomingThread incoming( TheWebResourceArbiter );

    TheWebQueryCache.IncrementActiveRequests();

    CWebServer webServer( pEcb );
    DWORD  hseStatus = HSE_STATUS_ERROR;
    webServer.SetHttpStatus( HTTP_STATUS_ACCEPTED );

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        if ( TheWebResourceArbiter.IsSystemBusy() )
        {
            if ( TheWebQueryCache.AddToPendingRequestQueue( pEcb ) )
            {
                ciGibDebugOut(( DEB_GIB_REQUEST, "Server busy, queueing request\n" ));
                hseStatus = HSE_STATUS_PENDING;

                TheWebQueryCache.Wakeup();
                TheWebQueryCache.UpdatePendingRequestCount();
            }
            else
            {
                TheWebQueryCache.IncrementRejectedRequests();
                ciGibDebugOut(( DEB_GIB_REQUEST,
                                "Server too busy, failing request!!!\n" ));
                ReturnServerError( HTTP_STATUS_SERVICE_UNAVAIL, webServer );
                hseStatus = HSE_STATUS_SUCCESS;
            }
        }
        else
        {
            ciGibDebugOut(( DEB_GIB_REQUEST, "Server not busy, processing request\n" ));
            hseStatus = ProcessWebRequest( webServer );
        }
    }
    CATCH( CException, e )
    {
        hseStatus = HSE_STATUS_ERROR;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( HSE_STATUS_PENDING != hseStatus )
    {
        TheWebQueryCache.DecrementActiveRequests();

        ciGibDebugOut(( DEB_GIB_REQUEST,
                        "Falling out of isapi proc, active: %d\n",
                        TheWebQueryCache.ActiveRequestCount() ));

        Win4Assert( webServer.GetHttpStatus() >= HTTP_STATUS_FIRST &&
                    webServer.GetHttpStatus() <= HTTP_STATUS_LAST );

        if ( ( webServer.GetHttpStatus() < HTTP_STATUS_FIRST ) ||
             ( webServer.GetHttpStatus() > HTTP_STATUS_LAST ) )
        {
            ciGibDebugOut(( DEB_WARN,
                            "non-pending hse %d ECB %08x status invalid: %d\n",
                            hseStatus,
                            pEcb,
                            webServer.GetHttpStatus() ));
            webServer.SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
        }
    }
    else
    {
        //
        // The pending request may have asynchronously completed by now,
        // so nothing can be asserted about the http status except that it
        // is a valid http status code, which retrieving the status does.
        //

        #if CIDBG == 1
            webServer.GetHttpStatus();
        #endif
    }

    ciGibDebugOut(( DEB_ITRACE, "httpExtensionProc: hse %d, http %d\n",
                    hseStatus, webServer.GetHttpStatus() ));

    return hseStatus;
} //HttpExtensionProc

//+---------------------------------------------------------------------------
//
//  Method:     CWebPendingQueue::CWebPendingQueue, public
//
//  Synposis:   Constructs the pending request queue
//
//  History:    96-Apr-15   dlee        created
//
//----------------------------------------------------------------------------

CWebPendingQueue::CWebPendingQueue()
    :  TFifoCircularQueue<CWebPendingItem>
           ( TheIDQRegParams.GetISRequestQueueSize() ),
     _ulSignature( LONGSIG( 'p', 'e', 'n', 'd' ) )
{
} //CWebPendingQueue

//+---------------------------------------------------------------------------
//
//  Method:     CWebResourceArbiter::CWebResourceArbiter, public
//
//  Synposis:   Constructs the web resource arbiter
//
//  History:    96-Apr-15   dlee        created
//
//----------------------------------------------------------------------------

CWebResourceArbiter::CWebResourceArbiter() :
    _ulSignature( LONGSIG( 'a', 'r', 'b', 'i' ) ),
    _cThreads( 0 )
{
    ULONG factor = TheIDQRegParams.GetISRequestThresholdFactor();

    Win4Assert( 0 != factor );

    SYSTEM_INFO si;
    GetSystemInfo( &si );

    _maxThreads = si.dwNumberOfProcessors * factor;

    Win4Assert( _maxThreads >= (LONG) factor );

    _maxPendingQueries = TheIDQRegParams.GetMaxActiveQueryThreads() *
                         factor;
} //CWebResourceArbiter

//+---------------------------------------------------------------------------
//
//  Method:     CWebResourceArbiter::IsSystemBusy, public
//
//  Synposis:   Determines if the system is too busy to process a request.
//
//  Returns:    TRUE if the request should be queued or rejected, FALSE
//              if the system is free enough to handle it.
//
//  History:    96-Apr-15   dlee        created
//
//----------------------------------------------------------------------------

BOOL CWebResourceArbiter::IsSystemBusy()
{
    return ( _cThreads > _maxThreads ) ||
           ( TheWebQueryCache.PendingQueryCount() >= _maxPendingQueries );
} //IsSystemBusy

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Called from C-Runtime on process/thread attach/detach
//
//  Arguments:  [hInstance]  -- Module handle
//              [dwReason]   -- Reason for being called
//              [lpReserved] --
//
//  History:    23-Apr-97   dlee       Created
//
//----------------------------------------------------------------------------

#if CIDBG == 1
#define VER_CIDEBUG "chk"
#else // CIDBG == 1
#define VER_CIDEBUG "fre"
#endif // CIDBG == 1

#if IDQ_VERSION == 3
#define VER_PROJECT "query"
#else // IDQ_VERSION != 3
#define VER_PROJECT "indexsrv"
#endif // IDQ_VERSION == 3

#define MAKELITERALSTRING( s, lit ) s #lit
#define MAKELITERAL( s, lit ) MAKELITERALSTRING( s, lit )

#define VERSION_STRING MAKELITERAL("Indexing Service ", IDQ_VERSION) \
                       "(" VER_PROJECT ") " VER_CIDEBUG \
                       MAKELITERAL(" built by ", BUILD_USERNAME) \
                       MAKELITERAL(" with ", VER_PRODUCTBUILD) \
                        " on " __DATE__ " at " __TIME__

char g_ciBuild[ ] = VERSION_STRING;


BOOL WINAPI DllMain(
    HANDLE hInstance,
    DWORD  dwReason,
    void * lpReserved )
{
    BOOL fRetval = TRUE;
    TRANSLATE_EXCEPTIONS;

    TRY
    {
        switch ( dwReason )
        {
            case DLL_PROCESS_ATTACH:
            {
                DisableThreadLibraryCalls( (HINSTANCE) hInstance );
                InitializeCriticalSection( &g_csInitExclusive );

                break;
            }

            case DLL_PROCESS_DETACH:
            {
                DeleteCriticalSection( &g_csInitExclusive );
                break;
            }
        }
    }
    CATCH( CException, e )
    {
        // About the only thing this could be is STATUS_NO_MEMORY which
        // can be thrown by InitializeCriticalSection.

        ciGibDebugOut(( DEB_ERROR,
                        "IDQ: Exception %#x in DllMain\n",
                        e.GetErrorCode()));

#if CIDBG == 1  // for debugging NTRAID 340297
        if (e.GetErrorCode() == STATUS_NO_MEMORY)
            DbgPrint( "IDQ: STATUS_NO_MEMORY exception in DllMain\n");
        else
            DbgPrint( "IDQ: ??? Exception in DllMain\n");
#endif // CIDBG == 1

        fRetval = FALSE;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return fRetval;
} //DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\param.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       param.cxx
//
//  Contents:   Used to replace variables in strings
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//
//  These ISAPI variables are Ci values available on HTX generated output.
//

const WCHAR * ISAPI_CI_ADMIN_OPERATION        = L"CIADMINOPERATION";
const WCHAR * ISAPI_CI_BOOKMARK               = L"CIBOOKMARK";
const WCHAR * ISAPI_CI_BOOKMARK_SKIP_COUNT    = L"CIBOOKMARKSKIPCOUNT";
const WCHAR * ISAPI_CI_BOOL_VECTOR_PREFIX     = L"CIBOOLVECTORPREFIX";
const WCHAR * ISAPI_CI_BOOL_VECTOR_SEPARATOR  = L"CIBOOLVECTORSEPARATOR";
const WCHAR * ISAPI_CI_BOOL_VECTOR_SUFFIX     = L"CIBOOLVECTORSUFFIX";
const WCHAR * ISAPI_CI_CANONICAL_OUTPUT       = L"CICANONICALOUTPUT";
const WCHAR * ISAPI_CI_CATALOG                = L"CICATALOG";
const WCHAR * ISAPI_CI_CODEPAGE               = L"CICODEPAGE";
const char  * ISAPI_CI_CODEPAGE_A             =  "CICODEPAGE";
const WCHAR * ISAPI_CI_COLUMNS                = L"CICOLUMNS";
const WCHAR * ISAPI_CI_CONTAINS_FIRST_RECORD  = L"CICONTAINSFIRSTRECORD";
const WCHAR * ISAPI_CI_CONTAINS_LAST_RECORD   = L"CICONTAINSLASTRECORD";
const WCHAR * ISAPI_CI_CURRENCY_VECTOR_PREFIX = L"CICURRENCYVECTORPREFIX";
const WCHAR * ISAPI_CI_CURRENCY_VECTOR_SEPARATOR=L"CICURRENCYVECTORSEPARATOR";
const WCHAR * ISAPI_CI_CURRENCY_VECTOR_SUFFIX = L"CICURRENCYVECTORSUFFIX";
const WCHAR * ISAPI_CI_CURRENT_PAGE_NUMBER    = L"CICURRENTPAGENUMBER";
const WCHAR * ISAPI_CI_CURRENT_RECORD_NUMBER  = L"CICURRENTRECORDNUMBER";
const WCHAR * ISAPI_CI_DATE_VECTOR_PREFIX     = L"CIDATEVECTORPREFIX";
const WCHAR * ISAPI_CI_DATE_VECTOR_SEPARATOR  = L"CIDATEVECTORSEPARATOR";
const WCHAR * ISAPI_CI_DATE_VECTOR_SUFFIX     = L"CIDATEVECTORSUFFIX";
const WCHAR * ISAPI_CI_DIALECT                = L"CIDIALECT";
const WCHAR * ISAPI_CI_DONT_TIMEOUT           = L"CIDONTTIMEOUT";
const WCHAR * ISAPI_CI_ERROR_MESSAGE          = L"CIERRORMESSAGE";
const WCHAR * ISAPI_CI_ERROR_NUMBER           = L"CIERRORNUMBER";
const WCHAR * ISAPI_CI_FIRST_RECORD_NUMBER    = L"CIFIRSTRECORDNUMBER";
const WCHAR * ISAPI_CI_FLAGS                  = L"CIFLAGS";
const WCHAR * ISAPI_CI_FORCE_USE_CI           = L"CIFORCEUSECI";
const WCHAR * ISAPI_CI_DEFER_NONINDEXED_TRIMMING = L"CIDEFERNONINDEXEDTRIMMING";
const WCHAR * ISAPI_CI_LAST_RECORD_NUMBER     = L"CILASTRECORDNUMBER";
const WCHAR * ISAPI_CI_LOCALE                 = L"CILOCALE";
const WCHAR * ISAPI_CI_MATCHED_RECORD_COUNT   = L"CIMATCHEDRECORDCOUNT";
const WCHAR * ISAPI_CI_MAX_RECORDS_IN_RESULTSET = L"CIMAXRECORDSINRESULTSET";
const WCHAR * ISAPI_CI_MAX_RECORDS_PER_PAGE   = L"CIMAXRECORDSPERPAGE";
const WCHAR * ISAPI_CI_FIRST_ROWS_IN_RESULTSET = L"CIFIRSTROWSINRESULTSET";
const WCHAR * ISAPI_CI_NUMBER_VECTOR_PREFIX   = L"CINUMBERVECTORPREFIX";
const WCHAR * ISAPI_CI_NUMBER_VECTOR_SEPARATOR= L"CINUMBERVECTORSEPARATOR";
const WCHAR * ISAPI_CI_NUMBER_VECTOR_SUFFIX   = L"CINUMBERVECTORSUFFIX";
const WCHAR * ISAPI_CI_OUT_OF_DATE            = L"CIOUTOFDATE";
const WCHAR * ISAPI_CI_QUERY_INCOMPLETE       = L"CIQUERYINCOMPLETE";
const WCHAR * ISAPI_CI_QUERY_TIMEDOUT         = L"CIQUERYTIMEDOUT";
const WCHAR * ISAPI_CI_QUERY_DATE             = L"CIQUERYDATE";
const WCHAR * ISAPI_CI_QUERY_TIME             = L"CIQUERYTIME";
const WCHAR * ISAPI_CI_QUERY_TIMEZONE         = L"CIQUERYTIMEZONE";
const WCHAR * ISAPI_CI_RESTRICTION            = L"CIRESTRICTION";
const WCHAR * ISAPI_CI_RECORDS_NEXT_PAGE      = L"CIRECORDSNEXTPAGE";
const WCHAR * ISAPI_CI_SCOPE                  = L"CISCOPE";
const WCHAR * ISAPI_CI_SORT                   = L"CISORT";
const WCHAR * ISAPI_CI_STRING_VECTOR_PREFIX   = L"CISTRINGVECTORPREFIX";
const WCHAR * ISAPI_CI_STRING_VECTOR_SEPARATOR= L"CISTRINGVECTORSEPARATOR";
const WCHAR * ISAPI_CI_STRING_VECTOR_SUFFIX   = L"CISTRINGVECTORSUFFIX";
const WCHAR * ISAPI_CI_TEMPLATE               = L"CITEMPLATE";
const WCHAR * ISAPI_CI_TOTAL_NUMBER_PAGES     = L"CITOTALNUMBERPAGES";
const WCHAR * ISAPI_CI_VERSION_MAJOR          = L"CIVERSIONMAJOR";
const WCHAR * ISAPI_CI_VERSION_MINOR          = L"CIVERSIONMINOR";

const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_WORDLISTS      = L"CIADMININDEXCOUNTWORDLISTS";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_PERSINDEX      = L"CIADMININDEXCOUNTPERSINDEX";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_QUERIES        = L"CIADMININDEXCOUNTQUERIES";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_UNIQUE         = L"CIADMININDEXCOUNTUNIQUE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_FRESHTEST      = L"CIADMININDEXCOUNTDELTAS";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_TOFILTER       = L"CIADMININDEXCOUNTTOFILTER";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_FILTERED       = L"CIADMININDEXCOUNTFILTERED";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_PENDINGSCANS   = L"CIADMININDEXCOUNTPENDINGSCANS";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_TOTAL          = L"CIADMININDEXCOUNTTOTAL";
const WCHAR * ISAPI_CI_ADMIN_INDEX_SIZE                 = L"CIADMININDEXSIZE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_MERGE_PROGRESS       = L"CIADMININDEXMERGEPROGRESS";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_SHADOWMERGE    = L"CIADMININDEXSTATESHADOWMERGE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_MASTERMERGE    = L"CIADMININDEXSTATEMASTERMERGE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_ANNEALINGMERGE = L"CIADMININDEXSTATEANNEALINGMERGE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_SCANREQUIRED   = L"CIADMININDEXSTATESCANREQUIRED";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_SCANNING       = L"CIADMININDEXSTATESCANNING";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_RECOVERING     = L"CIADMININDEXSTATERECOVERING";

const WCHAR * ISAPI_CI_ADMIN_CACHE_HITS       = L"CIADMINCACHEHITS";
const WCHAR * ISAPI_CI_ADMIN_CACHE_MISSES     = L"CIADMINCACHEMISSES";
const WCHAR * ISAPI_CI_ADMIN_CACHE_ACTIVE     = L"CIADMINCACHEACTIVE";
const WCHAR * ISAPI_CI_ADMIN_CACHE_COUNT      = L"CIADMINCACHECOUNT";
const WCHAR * ISAPI_CI_ADMIN_CACHE_PENDING    = L"CIADMINCACHEPENDING";
const WCHAR * ISAPI_CI_ADMIN_CACHE_REJECTED   = L"CIADMINCACHEREJECTED";
const WCHAR * ISAPI_CI_ADMIN_CACHE_TOTAL      = L"CIADMINCACHETOTAL";
const WCHAR * ISAPI_CI_ADMIN_CACHE_QPM        = L"CIADMINCACHERATE";

const WCHAR * ISAPI_ALL_HTTP                  = L"ALL_HTTP";
const WCHAR * ISAPI_AUTH_TYPE                 = L"AUTH_TYPE";
const WCHAR * ISAPI_CONTENT_LENGTH            = L"CONTENT_LENGTH";
const WCHAR * ISAPI_CONTENT_TYPE              = L"CONTENT_TYPE";
const WCHAR * ISAPI_GATEWAY_INTERFACE         = L"GATEWAY_INTERFACE";
const WCHAR * ISAPI_HTTP_ACCEPT               = L"HTTP_ACCEPT";
const WCHAR * ISAPI_HTTP_ACCEPT_LANGUAGE      = L"HTTP_ACCEPT_LANGUAGE";
const WCHAR * ISAPI_HTTP_COOKIE               = L"HTTP_COOKIE";
const WCHAR * ISAPI_HTTP_CONNECTION           = L"HTTP_CONNECTION";
const WCHAR * ISAPI_HTTP_CONTENT_TYPE         = L"HTTP_CONTENT_TYPE";
const WCHAR * ISAPI_HTTP_CONTENT_LENGTH       = L"HTTP_CONTENT_LENGTH";
const WCHAR * ISAPI_HTTP_PRAGMA               = L"HTTP_PRAGMA";
const WCHAR * ISAPI_HTTP_REFERER              = L"HTTP_REFERER";
const WCHAR * ISAPI_HTTP_USER_AGENT           = L"HTTP_USER_AGENT";
const WCHAR * ISAPI_PATH_INFO                 = L"PATH_INFO";
const WCHAR * ISAPI_PATH_TRANSLATED           = L"PATH_TRANSLATED";
const WCHAR * ISAPI_QUERY_STRING              = L"QUERY_STRING";
const WCHAR * ISAPI_REMOTE_ADDR               = L"REMOTE_ADDR";
const WCHAR * ISAPI_REMOTE_HOST               = L"REMOTE_HOST";
const WCHAR * ISAPI_REMOTE_USER               = L"REMOTE_USER";
const WCHAR * ISAPI_REQUEST_METHOD            = L"REQUEST_METHOD";
const WCHAR * ISAPI_SCRIPT_NAME               = L"SCRIPT_NAME";
const WCHAR * ISAPI_SERVER_NAME               = L"SERVER_NAME";
const WCHAR * ISAPI_SERVER_PORT               = L"SERVER_PORT";
const WCHAR * ISAPI_SERVER_PROTOCOL           = L"SERVER_PROTOCOL";
const WCHAR * ISAPI_SERVER_SOFTWARE           = L"SERVER_SOFTWARE";

const struct tagCiGlobalVars aCiGlobalVars[] =
{
    { ISAPI_CI_BOOKMARK,                      VT_EMPTY,   0, 0 },
    { ISAPI_CI_BOOKMARK_SKIP_COUNT,           VT_I4,      0, 0 },
    { ISAPI_CI_CANONICAL_OUTPUT,              VT_EMPTY,   0, 0 },
    { ISAPI_CI_CATALOG,                       VT_EMPTY,   0, 0 },
    { ISAPI_CI_COLUMNS,                       VT_EMPTY,   0, 0 },
    { ISAPI_CI_CONTAINS_FIRST_RECORD,         VT_BOOL,    VARIANT_TRUE,  0 },
    { ISAPI_CI_CONTAINS_LAST_RECORD,          VT_BOOL,    VARIANT_FALSE, 0 },
    { ISAPI_CI_CURRENT_RECORD_NUMBER,         VT_I4,      0, 0 },
    { ISAPI_CI_CURRENT_PAGE_NUMBER,           VT_I4,      0, 0 },
    { ISAPI_CI_DIALECT,                       VT_UI4,     ISQLANG_V2, 0 },
    { ISAPI_CI_DONT_TIMEOUT,                  VT_LPWSTR,  0, 0 },
    { ISAPI_CI_ERROR_MESSAGE,                 VT_EMPTY,   0, 0 },
    { ISAPI_CI_ERROR_NUMBER,                  VT_I4,      0, 0 },
    { ISAPI_CI_FIRST_RECORD_NUMBER,           VT_I4,      1, 0 },
    { ISAPI_CI_FLAGS,                         VT_EMPTY,   0, 0 },
    { ISAPI_CI_FORCE_USE_CI,                  VT_EMPTY,   0, 0 },
    { ISAPI_CI_LAST_RECORD_NUMBER,            VT_UI4,     1, 0 },
    { ISAPI_CI_LOCALE,                        VT_EMPTY,   0, 0 },
    { ISAPI_CI_MATCHED_RECORD_COUNT,          VT_I4,      0, eParamRequiresNonSequentialCursor },
    { ISAPI_CI_MAX_RECORDS_IN_RESULTSET,      VT_I4,      0, 0 },
    { ISAPI_CI_MAX_RECORDS_PER_PAGE,          VT_I4,     10, 0 },
    { ISAPI_CI_FIRST_ROWS_IN_RESULTSET,       VT_I4,      0, 0 },
    { ISAPI_CI_OUT_OF_DATE,                   VT_BOOL,    VARIANT_FALSE, 0 },
    { ISAPI_CI_QUERY_INCOMPLETE,              VT_BOOL,    VARIANT_FALSE, 0 },
    { ISAPI_CI_QUERY_TIMEDOUT,                VT_BOOL,    VARIANT_FALSE, 0 },
    { ISAPI_CI_QUERY_DATE,                    VT_EMPTY,   0, 0 },
    { ISAPI_CI_QUERY_TIME,                    VT_EMPTY,   0, 0 },
    { ISAPI_CI_QUERY_TIMEZONE,                VT_EMPTY,   0, 0 },
    { ISAPI_CI_RESTRICTION,                   VT_EMPTY,   0, 0 },
    { ISAPI_CI_RECORDS_NEXT_PAGE,             VT_I4,      0, eParamRequiresNonSequentialCursor },
    { ISAPI_CI_SCOPE,                         VT_EMPTY,   0, 0 },
    { ISAPI_CI_SORT,                          VT_EMPTY,   0, 0 },
    { ISAPI_CI_TEMPLATE,                      VT_EMPTY,   0, 0 },
    { ISAPI_CI_TOTAL_NUMBER_PAGES,            VT_I4,      1, eParamRequiresNonSequentialCursor },
    { ISAPI_CI_VERSION_MAJOR,                 VT_I4,      3, 0 },
    { ISAPI_CI_VERSION_MINOR,                 VT_I4,      0, 0 },
};

const struct tagCiGlobalVars aISAPIGlobalVars[] =
{
    { ISAPI_ALL_HTTP,                         VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_AUTH_TYPE,                        VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_CONTENT_LENGTH,                   VT_EMPTY,   0, 0 },
    { ISAPI_CONTENT_TYPE,                     VT_EMPTY,   0, 0 },
    { ISAPI_GATEWAY_INTERFACE,                VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_HTTP_ACCEPT,                      VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_ACCEPT_LANGUAGE,             VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_COOKIE,                      VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_CONNECTION,                  VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_CONTENT_TYPE,                VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_CONTENT_LENGTH,              VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_PRAGMA,                      VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_REFERER,                     VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_USER_AGENT,                  VT_EMPTY,   0, 0 },
    { ISAPI_PATH_INFO,                        VT_EMPTY,   0, 0 },
    { ISAPI_PATH_TRANSLATED,                  VT_EMPTY,   0, 0 },
    { ISAPI_QUERY_STRING,                     VT_EMPTY,   0, 0 },
    { ISAPI_REMOTE_ADDR,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_REMOTE_HOST,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_REMOTE_USER,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_REQUEST_METHOD,                   VT_EMPTY,   0, 0 },
    { ISAPI_SCRIPT_NAME,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_SERVER_NAME,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_SERVER_PORT,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_SERVER_PROTOCOL,                  VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_SERVER_SOFTWARE,                  VT_LPWSTR,  0, eParamDeferredValue },
};

const unsigned cCiGlobalVars = sizeof(aCiGlobalVars) / sizeof(aCiGlobalVars[0]);
const unsigned cISAPIGlobalVars = sizeof(aISAPIGlobalVars) / sizeof(aISAPIGlobalVars[0]);

const WCHAR * aISAPI_CiParams[] =
{
    ISAPI_CI_BOOKMARK,
    ISAPI_CI_BOOKMARK_SKIP_COUNT,
    ISAPI_CI_BOOL_VECTOR_PREFIX,
    ISAPI_CI_BOOL_VECTOR_SEPARATOR,
    ISAPI_CI_BOOL_VECTOR_SUFFIX,
    ISAPI_CI_CANONICAL_OUTPUT,
    ISAPI_CI_CATALOG,
    ISAPI_CI_COLUMNS,
    ISAPI_CI_CONTAINS_FIRST_RECORD,
    ISAPI_CI_CONTAINS_LAST_RECORD,
    ISAPI_CI_CURRENCY_VECTOR_PREFIX,
    ISAPI_CI_CURRENCY_VECTOR_SEPARATOR,
    ISAPI_CI_CURRENCY_VECTOR_SUFFIX,
    ISAPI_CI_CURRENT_PAGE_NUMBER,
    ISAPI_CI_CURRENT_RECORD_NUMBER,
    ISAPI_CI_DATE_VECTOR_PREFIX,
    ISAPI_CI_DATE_VECTOR_SEPARATOR,
    ISAPI_CI_DATE_VECTOR_SUFFIX,
    ISAPI_CI_DIALECT,
    ISAPI_CI_DONT_TIMEOUT,
    ISAPI_CI_ERROR_MESSAGE,
    ISAPI_CI_FIRST_RECORD_NUMBER,
    ISAPI_CI_FORCE_USE_CI,
    ISAPI_CI_DEFER_NONINDEXED_TRIMMING,
    ISAPI_CI_FLAGS,
    ISAPI_CI_LAST_RECORD_NUMBER,
    ISAPI_CI_LOCALE,
    ISAPI_CI_MATCHED_RECORD_COUNT,
    ISAPI_CI_MAX_RECORDS_IN_RESULTSET,
    ISAPI_CI_MAX_RECORDS_PER_PAGE,
    ISAPI_CI_FIRST_ROWS_IN_RESULTSET,
    ISAPI_CI_NUMBER_VECTOR_PREFIX,
    ISAPI_CI_NUMBER_VECTOR_SEPARATOR,
    ISAPI_CI_NUMBER_VECTOR_SUFFIX,
    ISAPI_CI_OUT_OF_DATE,
    ISAPI_CI_QUERY_INCOMPLETE,
    ISAPI_CI_QUERY_DATE,
    ISAPI_CI_QUERY_TIME,
    ISAPI_CI_QUERY_TIMEZONE,
    ISAPI_CI_RESTRICTION,
    ISAPI_CI_RECORDS_NEXT_PAGE,
    ISAPI_CI_SCOPE,
    ISAPI_CI_SORT,
    ISAPI_CI_STRING_VECTOR_PREFIX,
    ISAPI_CI_STRING_VECTOR_SEPARATOR,
    ISAPI_CI_STRING_VECTOR_SUFFIX,
    ISAPI_CI_TEMPLATE,
    ISAPI_CI_TOTAL_NUMBER_PAGES,
    ISAPI_CI_VERSION_MAJOR,
    ISAPI_CI_VERSION_MINOR,

    ISAPI_ALL_HTTP,
    ISAPI_AUTH_TYPE,
    ISAPI_CONTENT_LENGTH,
    ISAPI_CONTENT_TYPE,
    ISAPI_GATEWAY_INTERFACE,
    ISAPI_HTTP_ACCEPT,
    ISAPI_HTTP_ACCEPT_LANGUAGE,
    ISAPI_HTTP_COOKIE,
    ISAPI_HTTP_CONNECTION,
    ISAPI_HTTP_CONTENT_TYPE,
    ISAPI_HTTP_CONTENT_LENGTH,
    ISAPI_HTTP_PRAGMA,
    ISAPI_HTTP_REFERER,
    ISAPI_HTTP_USER_AGENT,
    ISAPI_PATH_INFO,
    ISAPI_PATH_TRANSLATED,
    ISAPI_QUERY_STRING,
    ISAPI_REMOTE_ADDR,
    ISAPI_REMOTE_HOST,
    ISAPI_REMOTE_USER,
    ISAPI_REQUEST_METHOD,
    ISAPI_SCRIPT_NAME,
    ISAPI_SERVER_NAME,
    ISAPI_SERVER_PORT,
    ISAPI_SERVER_PROTOCOL,
    ISAPI_SERVER_SOFTWARE,
};

const unsigned cISAPI_CiParams = sizeof(aISAPI_CiParams) / sizeof(aISAPI_CiParams[0]);


extern const CDbColId dbColIdVirtualPath;

//+---------------------------------------------------------------------------
//
//  Member:     CParameterNode::~CParameterNode - public destructor
//
//  Synopsis:   Deletes all nodes attached to this one
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CParameterNode::~CParameterNode()
{
    if ( 0 != _pTrueNode )
    {
        _pTrueNode->DecrementRefCount();
        if ( 0 == _pTrueNode->GetRefCount() )
        {
            delete _pTrueNode;
        }
    }

    if ( 0 != _pFalseNode )
    {
        _pFalseNode->DecrementRefCount();
        if ( 0 == _pFalseNode->GetRefCount() )
        {
            delete _pFalseNode;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterNodeIter::CParameterNodeIter - public constructor
//
//  Synopsis:   Iteraties over a CParameterNode tree
//
//  Arguments:  [pNode]       - root of the tree to iterate over
//              [variableSet] - a list of replaceable parameters
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CParameterNodeIter::CParameterNodeIter( CParameterNode *pNode,
                                        CVariableSet & variableSet,
                                        COutputFormat & outputFormat ) :
                                        _root( pNode ),
                                        _variableSet(variableSet),
                                        _outputFormat(outputFormat)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CParameterNodeIter::EvaluateExpression - private
//
//  Synopsis:   Evaluates an IF expression
//
//  Arguments:  [wcsCondition] - the string containing the condition to
//                               evaluate
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
BOOL CParameterNodeIter::EvaluateExpression( WCHAR const * wcsCondition )
{
    CTokenizeString scanner( wcsCondition );
    CHTXIfExpression ifExpression( scanner, _variableSet, _outputFormat );

    return ifExpression.Evaluate();
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterReplacer - public constructor
//
//  Synopsis:   Initializes the variableSet and parses the string
//
//  Arguments:  [wcsString] - the string to parse and replace parameters in
//              [wcsPrefix] - the prefix delimiting parameters
//              [wcsSuffix] - the suffix delimiting parameters
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CParameterReplacer::CParameterReplacer( WCHAR const * wcsString,
                                        WCHAR const * wcsPrefix,
                                        WCHAR const * wcsSuffix ) :
                                        _wcsString(0),
                                        _wcsPrefix(wcsPrefix),
                                        _wcsSuffix(wcsSuffix),
                                        _ulFlags(0),
                                        _paramNode(L"Top")
{
    Win4Assert( 0 != wcsString );
    Win4Assert( 0 != wcsPrefix );
    Win4Assert( 0 != wcsSuffix );

    ULONG cwcString = wcslen(wcsString) + 1;
    _wcsString = new WCHAR[ cwcString ];
    RtlCopyMemory( _wcsString, wcsString, cwcString * sizeof(WCHAR) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterReplacer::ParseString - public
//
//  Arguments:  [variableSet] - the list of replaceable parameter values
//
//  Synopsis:   Parses the string and builds a tree of replaceable parameters.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CParameterReplacer::ParseString( CVariableSet & variableSet )
{
    CHTXScanner scanner( variableSet, _wcsPrefix, _wcsSuffix );
    scanner.Init( _wcsString );

    CDynStackInPlace<ULONG> ifStack;
    BuildTree( scanner, &_paramNode, ifStack );

    if ( ifStack.Count() != 0 )
    {
        THROW( CHTXException(MSG_CI_HTX_EXPECTING_ELSE_ENDIF, 0, 0) );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterReplacer::ReplaceParams - public
//
//  Synopsis:   Generates a new string replacing all %values% in the original
//              string
//
//  Arguments:  [StrResult]   - a safe string to append the new params to
//              [variableSet] - the list of replaceable parameter values
//
//  Notes:      If expressions are handled in the parameter node iterator.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CParameterReplacer::ReplaceParams( CVirtualString & StrResult,
                                        CVariableSet & variableSet,
                                        COutputFormat & outputFormat )
{
    BOOL fIsIDQ = ( L'%' == _wcsPrefix[0] );

    for ( CParameterNodeIter iter(&_paramNode, variableSet, outputFormat);
          !iter.AtEnd();
           iter.Next() )
    {
        CParameterNode * pNode = iter.Get();

        ULONG type = pNode->Type() & eJustParamMask;

        // Always escape variables in .idq files as RAW

        if ( ( fIsIDQ ) && ( eParameter == type ) )
        {
            type = eEscapeRAW;
        }

        switch ( type )
        {

        case eString:
            StrResult.StrCat( pNode->String(), pNode->Length() );
        break;

        case eParameter:
        case eEscapeHTML:
        {
            if (! variableSet.GetStringValueHTML( pNode->String(),
                                                  pNode->Hash(),
                                                  outputFormat,
                                                  StrResult ) )
            {
                ciGibDebugOut(( DEB_IWARN,
                                "Warning: CParameterReplacer::ReplaceParams GetStringValueHTML returned FALSE for '%ws'\n",
                                pNode->String() ));

                if ( eParameter == type )
                    StrResult.StrCat( _wcsPrefix );
                HTMLEscapeW( pNode->String(),
                             StrResult,
                             outputFormat.CodePage() );
                if ( eParameter == type )
                    StrResult.StrCat( _wcsSuffix );
            }
        }
        break;

        case eEscapeURL:
        {
            if (! variableSet.GetStringValueURL( pNode->String(),
                                                 pNode->Hash(),
                                                 outputFormat,
                                                 StrResult ) )
            {
                ciGibDebugOut(( DEB_IWARN,
                                "Warning: CParameterReplacer::ReplaceParams GetStringValueURL returned FALSE for '%ws'\n",
                                pNode->String() ));

                URLEscapeW( pNode->String(),
                            StrResult,
                            outputFormat.CodePage() );
            }
        }
        break;

        case eEscapeRAW:
        {
            ULONG cwcValue;
            WCHAR const * wcsValue = variableSet.GetStringValueRAW( pNode->String(),
                                                                    pNode->Hash(),
                                                                    outputFormat,
                                                                    cwcValue );


            if ( 0 != wcsValue )
            {
                StrResult.StrCat( wcsValue, cwcValue );
            }
            else
            {
                ciGibDebugOut(( DEB_IWARN,
                                "Warning: CParameterReplacer::ReplaceParams GetStringValueRAW returned NULL for '%ws'\n",
                                pNode->String() ));

                StrResult.StrCat( pNode->String(), pNode->Length() );
            }
        }
        break;

#if DBG==1
        case eNone :
        case eIf :
        case eElse :
        case eEndIf :
        break;

        default :
            ciGibDebugOut(( DEB_ERROR, "unexpected param type: %#x\n", type ) );
            Win4Assert( !"unexpected parameter type" );
            break;
#endif // DBG==1

        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterReplacer::BuildTree - private
//
//  Synposis:   Parses the string contained in the scanner object and builds
//              a parse tree which can later be walked
//
//  Arguments:  [scanner]    - contains the string to build the tree from
//              [pBranch]    - the branch which new nodes should be attached to
//              [ifStack]    - depth of the 'if/else/endif' clauses seen thus far
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CParameterReplacer::BuildTree( CHTXScanner & scanner,
                                    CParameterNode *pBranch,
                                    CDynStackInPlace<ULONG> & ifStack )
{
    CParameterNode *pNode = 0;

    while ( scanner.FindNextToken() )
    {
        switch ( scanner.TokenType() & eParamMask )
        {
        case eString:
        {
            //
            //  A non-replaceable wcsString was found before any replaceable/
            //  conditional nodes.  Save the wcsString in a node;
            //
            pNode = new CParameterNode( scanner.GetToken(), eString );
            pBranch->SetNextNode( pNode );
            pBranch = pNode;

            break;
        }

        case eParameter | eParamRequiresNonSequentialCursor:
            _ulFlags |= eParamRequiresNonSequentialCursor;

            // Fall through

        case eParameter:
        {
            //
            //  We've found a replaceable node.
            //
            WCHAR * wcsParameter = scanner.GetToken();

            Win4Assert( 0 != wcsParameter );

            pNode = new CParameterNode( wcsParameter, eParameter );

            pBranch->SetNextNode( pNode );
            pBranch = pNode;

            break;
        }

        case eIf:
        {
            ifStack.Push( eIf );

            //
            //  We've found an IF node.  Build the IF and ELSE clauses upto
            //  and including the ENDIF node for this IF.
            //
            //  If there is an IF enbedded within the IF or ELSE clause,
            //  we'll recurse down to build that IF tree.
            //
            CParameterNode *pIfNode = new CParameterNode( scanner.GetToken(), eIf );
            XPtr<CParameterNode> xIfNode( pIfNode );

            CParameterNode trueNode(L"true");
            CParameterNode falseNode(L"false");

            //
            //  Build the TRUE node/clause of the IF statement
            //
            BuildTree( scanner, &trueNode, ifStack );

            //
            //  Build the FALSE node/clause of the IF statement
            //
            if ( scanner.TokenType() == eElse )
            {
                scanner.GetToken();
                BuildTree( scanner, &falseNode, ifStack );
            }

            if ( scanner.TokenType() != eEndIf )
            {
                // 'if' without matching 'else' or 'endif'
                THROW( CHTXException(MSG_CI_HTX_EXPECTING_ELSE_ENDIF, 0, 0) );
            }

            scanner.GetToken();

            //
            //  Build the TRUE and FALSE branches on the IF node and
            //  join the bottom of the TRUE and FALSE branches together
            //  to a common ENDIF node.
            //
            CParameterNode *pEndifNode = new CParameterNode( L"endif", eEndIf );
            XPtr<CParameterNode> xEndifNode( pEndifNode );

            Win4Assert( trueNode.GetNextNode() );
            trueNode.GetEndNode()->SetNextNode( pEndifNode );
            pIfNode->SetTrueNode( trueNode.QueryNextNode() );
            pEndifNode->IncrementRefCount();

            //
            //  If there is a ELSE clause to this tree, attach it's bottom
            //  node to the ENDIF node.
            //
            if ( falseNode.GetNextNode() )
            {
                falseNode.GetEndNode()->SetNextNode( pEndifNode );
                pIfNode->SetFalseNode( falseNode.QueryNextNode() );
            }
            else
            {
                pIfNode->SetFalseNode( pEndifNode );
            }

            pBranch->SetNextNode( xIfNode.Acquire() );
            pBranch = xEndifNode.Acquire();

            break;
        }

        case eElse:
        {
            if ( ifStack.Count() == 0 )
            {
                THROW( CHTXException(MSG_CI_HTX_ELSEENDIF_WITHOUT_IF, 0, 0) );
            }

            int eStackValue = ifStack.Pop();

            if ( eStackValue != eIf )
            {
                THROW( CHTXException(MSG_CI_HTX_ELSEENDIF_WITHOUT_IF, 0, 0) );
            }

            ifStack.Push( eElse );

            return;
            break;
        }

        case eEndIf:
        {
            if ( ifStack.Count() == 0 )
            {
                THROW( CHTXException(MSG_CI_HTX_ELSEENDIF_WITHOUT_IF, 0, 0) );
            }

            int eStackValue = ifStack.Pop();
            if ( (eStackValue != eIf) && (eStackValue != eElse) )
            {
                THROW( CHTXException(MSG_CI_HTX_ELSEENDIF_WITHOUT_IF, 0, 0) );
            }

            return;
            break;
        }

        case eEscapeHTML:
        {
            WCHAR * wcsParameter = scanner.GetToken();
            if ( 0 == wcsParameter )
                THROW( CException( E_INVALIDARG ) );

            pNode = new CParameterNode( wcsParameter, eEscapeHTML );

            pBranch->SetNextNode( pNode );
            pBranch = pNode;
        }
        break;

        case eEscapeURL:
        {
            WCHAR * wcsParameter = scanner.GetToken();

            pNode = new CParameterNode( wcsParameter, eEscapeURL );

            pBranch->SetNextNode( pNode );
            pBranch = pNode;
        }
        break;

        case eEscapeRAW:
        {
            WCHAR * wcsParameter = scanner.GetToken();

            pNode = new CParameterNode( wcsParameter, eEscapeRAW );

            pBranch->SetNextNode( pNode );
            pBranch = pNode;
        }
        break;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\wqcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       wqcache.cxx
//
//  Contents:   WEB Query cache class
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <perfobj.hxx>
#include <params.hxx>

DECLARE_INFOLEVEL(ciGib);

//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityToken
//
//  Synopsis:   Gets the security token handle for the current thread
//
//  History:    96-Jan-18   DwightKr    Created
//
//---------------------------------------------------------------------------

HANDLE GetSecurityToken(TOKEN_STATISTICS & TokenInformation)
{
    HANDLE hToken;
    NTSTATUS status = NtOpenThreadToken( GetCurrentThread(),
                                         TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                                         TRUE,           // OpenAsSelf
                                         &hToken );

    if ( !NT_SUCCESS( status ) )
        return INVALID_HANDLE_VALUE;

    DWORD ReturnLength;
    status = NtQueryInformationToken( hToken,
                                      TokenStatistics,
                                      (LPVOID)&TokenInformation,
                                      sizeof TokenInformation,
                                      &ReturnLength );

    if ( !NT_SUCCESS( status ) )
    {
        NtClose( hToken );
        ciGibDebugOut(( DEB_ERROR,
                       "NtQueryInformationToken failed, 0x%x\n",
                       status ));
        THROW( CException( status ));
    }

    Win4Assert( TokenInformation.TokenType == TokenImpersonation );

    return hToken;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryBookmark::CWQueryBookmark - public constructor
//
//  Synopsis:   Reads the values from a bookmark into the member variables
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CWQueryBookmark::CWQueryBookmark( WCHAR const * wcsBookmark )
{
    Win4Assert( 0 != wcsBookmark );

    //
    //  Bookmarks have the following format:
    //
    //      {S|N}-ptr_to_record-sequence_number-row_number
    //
    //  Eg:
    //
    //      S-1b234a-250-100
    //      0123456789 123456789 1234567
    //
    //      S        = sequential cursor
    //      001b234a = address of CWQueryItem containing query results, in hex
    //      00000250 = sequence number, in hex
    //      00000010 = next row # to display, in hex
    //
    //
    //      N-1b277a-a50-2a000
    //      0123456789 123456789 1234567
    //
    //      N        = non-sequential cursor
    //      001b277a = address of CWQueryItem containing query results, in hex
    //      00000a50 = sequence number, in hex
    //      0002a000 = next row # to display, in hex
    //
    //  Bookmarks are a maximum of 34 characters long, but they may be shorter.
    //  On 32 bit platforms, the maximum length is 28 characters.

    WCHAR * wcsPtr = (WCHAR *)wcsBookmark;

    //
    //  Verify that the bookmark is well formed.  There should be 3 hyphens
    //  and the length must be at least 24 characters; there may be trailing
    //  spaces.
    //
    if ( (*(wcsBookmark+1) != L'-') )
    {
        THROW( CException( DB_E_ERRORSINCOMMAND ) );
    }

    if ( *wcsBookmark == L'S' )
    {
        _fSequential = TRUE;
    }
    else if ( *wcsBookmark == L'N' )
    {
        _fSequential = FALSE;
    }
    else
    {
        THROW( CException( DB_E_ERRORSINCOMMAND ) );
    }

    WCHAR *pwcStart = wcsPtr + 2;

#if defined(_WIN64)
    _pItem = (CWQueryItem *) _wcstoui64( pwcStart, &wcsPtr, 16 );
#else
    _pItem = (CWQueryItem *) wcstoul( pwcStart, &wcsPtr, 16 );
#endif

    if ( ( pwcStart == wcsPtr ) ||
         ( *wcsPtr++ != L'-' ) )
        THROW( CException( DB_E_ERRORSINCOMMAND ) );

    pwcStart = wcsPtr;
    _ulSequenceNumber = wcstoul( wcsPtr, &wcsPtr, 16 );

    if ( ( pwcStart == wcsPtr ) ||
         ( *wcsPtr++ != L'-' ) )
        THROW( CException( DB_E_ERRORSINCOMMAND ) );

    pwcStart = wcsPtr;
    _lRecordNumber   = wcstol( wcsPtr, &wcsPtr, 16 );
    if ( ( pwcStart == wcsPtr ) ||
         ( 0 != *wcsPtr ) )
        THROW( CException( DB_E_ERRORSINCOMMAND ) );

    unsigned cbBmk = (unsigned)(wcsPtr - wcsBookmark + 1) * sizeof (WCHAR);

    if ( cbBmk >= sizeof( _wcsBookmark )  )
        THROW( CException( DB_E_ERRORSINCOMMAND ) );

    RtlCopyMemory( _wcsBookmark,
                   wcsBookmark,
                   cbBmk );

    //Win4Assert( 0 == _wcsBookmark[ cbBmk / ( sizeof WCHAR ) ] );
}

//+---------------------------------------------------------------------------
//
//  Functon:    AppendHex64Number, inline
//
//  Synopsis:   Append a 64 bit hex value to a wide string.
//
//  Arguments:  [pwc] - string to append number to
//              [x]   - value to add to string
//
//  Returns:    Pointer to next character in string to be filled in
//
//  History:    1998 Nov 06   AlanW    Created header; return pwc
//
//----------------------------------------------------------------------------
inline WCHAR * AppendHex64Number( WCHAR * pwc, ULONG_PTR x )
{

#if defined(_WIN64)
    _i64tow( x, pwc, 16 );
#else
    _itow( x, pwc, 16 );
#endif
    pwc += wcslen( pwc );

    return pwc;
}

//+---------------------------------------------------------------------------
//
//  Functon:    AppendHexNumber, inline
//
//  Synopsis:   Append a hex value to a wide string.
//
//  Arguments:  [pwc] - string to append number to
//              [x]   - value to add to string
//
//  Returns:    Pointer to next character in string to be filled in
//
//  History:    96 Apr 09   AlanW    Created header; return pwc
//
//----------------------------------------------------------------------------
inline WCHAR * AppendHexNumber( WCHAR * pwc, ULONG x )
{
    _itow( x, pwc, 16 );
    pwc += wcslen( pwc );

    return pwc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CWQueryBookmark::CWQueryBookmark, public
//
//  Synopsis:   Constructs a query bookmark
//
//  Arguments:  [fSequential]      - TRUE if a sequential query
//              [pItem]            - the query
//              [ulSequenceNumber] - # of queries executed so far
//              [lRecordNumber]    - starting record number of the bookmark
//
//  History:    96          DwightKr  Created
//              97 Apr 20   dlee      Created header
//
//----------------------------------------------------------------------------

CWQueryBookmark::CWQueryBookmark( BOOL fSequential,
                                  CWQueryItem * pItem,
                                  ULONG ulSequenceNumber,
                                  LONG lRecordNumber ) :
    _fSequential( fSequential ),
    _pItem( pItem ),
    _ulSequenceNumber( ulSequenceNumber ),
    _lRecordNumber( lRecordNumber )
{
    WCHAR *pwc = _wcsBookmark;

    *pwc++ = _fSequential ? L'S' : L'N';
    *pwc++ = L'-';

    pwc = AppendHex64Number( pwc, (ULONG_PTR) _pItem );
    *pwc++ = L'-';

    pwc = AppendHexNumber( pwc, _ulSequenceNumber );
    *pwc++ = L'-';

    pwc = AppendHexNumber( pwc, _lRecordNumber );
    *pwc = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CWQueryCache - public constructor
//
//  Synopsis:   Initializes the linked list of query items, and initializes
//              the query sequence counter.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CWQueryCache::CWQueryCache() :
          _ulSignature( LONGSIG( 'q', 'c', 'a', 'c' ) ),
          _cRequestsRejected( 0 ),
          _ulSequenceNumber( 0 ),
          _cActiveRequests( 0 ),
          _pendingQueue( 512 ), // large enough so realloc never happens
#pragma warning( disable : 4355 )       // this used in base initialization
          _threadWatchDog( WatchDogThread, this, TRUE )
#pragma warning( default : 4355 )
{
    //
    // Create a security descriptor for the shared memory. The security
    // descriptor gives full access to the shared memory for the creator
    // and read acccess for everyone else. By default, only the creator
    // can access the shared memory. But we want that anyone will be able
    // to read the performance data. So we must give read access to
    // everyone.
    //

    SECURITY_DESCRIPTOR sd;
    BOOL f = InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION );
    if ( !f )
        THROW( CException() );

    HANDLE hToken;
    f = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken );
    if ( !f )
        THROW( CException() );

    SWin32Handle xHandle( hToken );

    DWORD cbTokenInfo;
    f = GetTokenInformation( hToken, TokenOwner, 0, 0, &cbTokenInfo );
    if ( ( !f ) && ( ERROR_INSUFFICIENT_BUFFER != GetLastError() ) )
        THROW( CException() );

    XArray<BYTE> xTo( cbTokenInfo );
    TOKEN_OWNER *pTO = (TOKEN_OWNER*)(char*) xTo.Get();
    f = GetTokenInformation( hToken, TokenOwner, pTO, cbTokenInfo, &cbTokenInfo );
    if ( !f )
        THROW( CException() );

    SID_IDENTIFIER_AUTHORITY WorldSidAuth = SECURITY_WORLD_SID_AUTHORITY;
    CSid sidWorld( WorldSidAuth, SECURITY_WORLD_RID );

    DWORD cbAcl = sizeof(ACL) +
                  2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                  GetLengthSid( sidWorld.Get() ) + GetLengthSid( pTO->Owner );
    XArray<BYTE> xDacl( cbAcl );
    PACL pDacl = (PACL)(char*) xDacl.Get();

    f = InitializeAcl( pDacl, cbAcl, ACL_REVISION );
    if ( !f )
        THROW( CException() );

    f = AddAccessAllowedAce( pDacl,
                             ACL_REVISION,
                             FILE_MAP_READ,
                             sidWorld.Get() );
    if ( !f )
        THROW( CException() );

    f = AddAccessAllowedAce( pDacl,
                             ACL_REVISION,
                             FILE_MAP_ALL_ACCESS,
                             pTO->Owner );
    if ( !f )
        THROW( CException() );

    f = SetSecurityDescriptorDacl( &sd, TRUE, pDacl, TRUE );
    if ( !f )
        THROW( CException() );

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    _smPerf.CreateForWriteFromSA( CI_ISAPI_PERF_SHARED_MEM,
                                  CI_ISAPI_SIZE_OF_COUNTER_BLOCK,
                                  sa );

    // CreateForWrite throws on failure, so it's OK by this point

    Win4Assert( _smPerf.Ok() );

    //
    // Always write to the "spare" entry, them CopyMemory to the actual
    // perfcounters in the watchdog thread from time to time.
    //

    CI_ISAPI_COUNTERS * pc = &_smSpare;

    _pcCacheItems         = &pc->_cCacheItems;
    _pcCacheHits          = &pc->_cCacheHits;
    _pcCacheMisses        = &pc->_cCacheMisses;
    _pcRunningQueries     = &pc->_cRunningQueries;
    _pcCacheHitsAndMisses = &pc->_cCacheHitsAndMisses;
    _pcTotalQueries       = &pc->_cTotalQueries;
    _pcRequestsQueued     = &pc->_cRequestsQueued;
    _pcRequestsRejected   = (ULONG *) &pc->_cRequestsRejected;
    _pcQueriesPerMinute   = &pc->_cQueriesPerMinute;

    *_pcCacheItems         = 0;
    *_pcCacheHits          = 0;
    *_pcCacheMisses        = 0;
    *_pcRunningQueries     = 0;
    *_pcCacheHitsAndMisses = 0;
    *_pcTotalQueries       = 0;
    *_pcRequestsQueued     = 0;
    *_pcRequestsRejected   = 0;
    *_pcQueriesPerMinute   = 0;

    CopyMemory( _smPerf.GetPointer(), &_smSpare, sizeof _smSpare );

    ULONG ulOffset = 0;

    for (unsigned i=0; i<MAX_QUERY_COLUMNS; i++)
    {
        g_aDbBinding[i].iOrdinal   = i+1;                   // Column #
        g_aDbBinding[i].obValue    = ulOffset;              // Offset of data
        g_aDbBinding[i].obLength   = 0;                     // Offset where length data is stored
        g_aDbBinding[i].obStatus   = 0;                     // Status info for column written
        g_aDbBinding[i].pTypeInfo  = 0;                     // Reserved
        g_aDbBinding[i].pObject    = 0;                     // DBOBJECT structure
        g_aDbBinding[i].pBindExt   = 0;                     // Ignored
        g_aDbBinding[i].dwPart     = DBPART_VALUE;          // Return data
        g_aDbBinding[i].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Memory owner
        g_aDbBinding[i].eParamIO   = 0;                     // eParamIo
        g_aDbBinding[i].cbMaxLen   = sizeof(PROPVARIANT *); // Size of data to return
        g_aDbBinding[i].dwFlags    = 0;                     // Reserved
        g_aDbBinding[i].wType      = DBTYPE_VARIANT | DBTYPE_BYREF;         // Type of return data
        g_aDbBinding[i].bPrecision = 0;                     // Precision to use
        g_aDbBinding[i].bScale     = 0;                     // Scale to use

        ulOffset += sizeof(COutputColumn);
    }

    _threadWatchDog.Resume();
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::~CWQueryCache - public destructor
//
//  Synopsis:   Deletes all query items in the linked list.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CWQueryCache::~CWQueryCache()
{
    Win4Assert( _pendingQueue.Count() == 0 );
    Win4Assert( IsEmpty() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::ThreadWatchDog - private
//
//  Synopsis:   The watchdog thread; it periodically:
//                  moves queries from the pending queue to the active cache
//                  moves queries from the active cache to the done cache
//                  flushes old queries from the done cache
//                  updates values from the registry.
//
//  History:    96-Feb-26   DwightKr    Created
//
//----------------------------------------------------------------------------
DWORD WINAPI CWQueryCache::WatchDogThread( void *self )
{
    CWQueryCache &me = * (CWQueryCache *) self;

    while ( !fTheActiveXSearchShutdown )
    {
        TRY
        {
            me.ProcessCacheEvents();
        }
        CATCH ( CException, e )
        {
            ciGibDebugOut(( DEB_IWARN,
                            "Watchdog thread in CWQueryCache caught exception 0x%x\n",
                            e.GetErrorCode() ));
        }
        END_CATCH
    }

    ciGibDebugOut(( DEB_WARN, "Watchdog thread in CWQueryCache is terminating\n" ));

    //
    // This is only necessary if thread is terminated from DLL_PROCESS_DETACH.
    //
    //TerminateThread( me._threadWatchDog.GetHandle(), 0 );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::ProcessCacheEvents - private
//
//  Synopsis:   Process events such a cache flushes & completed asynchronous
//              queries.
//
//  History:    96-Feb-26   DwightKr    Created
//              96-Mar-06   DwightKr    Added asynchronous query completion
//              86-May-16   DwightKr    Add registry change event
//
//----------------------------------------------------------------------------
void CWQueryCache::ProcessCacheEvents()
{
    //
    // Setup for Queries / Minute
    //

    ULONG  cStartTotal  = Total();
    time_t ttStartTotal = time(0);
    time_t ttLastCachePurge = ttStartTotal;
    ULONG cTicks = GetTickCount();

    CRegChangeEvent regChangeEvent(wcsRegAdminTree);

    HANDLE waitHandles[2];
    waitHandles[0] = _eventCacheWork.GetHandle();
    waitHandles[1] = regChangeEvent.GetEventHandle();

    BOOL fBusy = FALSE;

    while ( !fTheActiveXSearchShutdown )
    {
        ULONG ulWaitTime;

        //
        // Set the wait period depending on the existence of any
        // asynchronous queries.
        //

        if ( fBusy )
        {
            // sleep very little for queries to complete

            ulWaitTime = 10;
        }
        else
        {
            if ( ( _pendingQueue.Count() > 0 ) ||
                 ( TheWebPendingRequestQueue.Any() ) )
            {
                ulWaitTime = 100;
            }
            else
            {
                // If we're only processing sequential queries, we need
                // to wake up often to update perfcounters.

                ulWaitTime = 1000;
            }
        }

        ULONG res = WaitForMultipleObjects( 2,
                                            waitHandles,
                                            FALSE,
                                            ulWaitTime );

        if ( 1 == res )
        {
            TheIDQRegParams.Refresh();
            regChangeEvent.Reset();
        }
        else
        {
            // time() is expensive, GetTickCount() is cheap

            if ( ( GetTickCount() - cTicks ) > 30000 )
            {
                cTicks = GetTickCount();
                time_t ttCurrent = time(0);

                //
                // Compute Queries / Minute
                //

                time_t deltaTime = ttCurrent - ttStartTotal;

                if ( deltaTime >= 30 )
                {
                    ULONG  deltaTotal = Total() - cStartTotal;
                    *_pcQueriesPerMinute = (ULONG)((deltaTotal * 60) / deltaTime);

                    //
                    // Start over every 15 minutes
                    //

                    if ( deltaTime > 15 * 60 )
                    {
                        cStartTotal  = Total();
                        ttStartTotal = time(0);
                    }
                }

                //
                //  Calculate the elapsed time since we deleted old queries.
                //  If sufficient time has elapsed, flush unused old queries
                //  from the cache.
                //

                if ( (ttCurrent - ttLastCachePurge) >=
                     ((time_t) TheIDQRegParams.GetISCachePurgeInterval() * 60) )
                {

                    ciGibDebugOut(( DEB_ITRACE, "Waking up query-cache purge thread\n" ));

                    DeleteOldQueries();
                    _idqFileList.DeleteZombies();
                    _htxFileList.DeleteZombies();
                    TheICommandCache.Purge();
                    TheFormattingCache.Purge();

                    time(&ttLastCachePurge);
                }
            }

            // Check for any completed asynchronous queries
            // Re-check for any completed asynchronous queries

            fBusy = CheckForCompletedQueries();
            fBusy |= CheckForPendingRequests();
            fBusy |= CheckForCompletedQueries();

            _eventCacheWork.Reset();
        }

        // Update perfcounters

        CopyMemory( _smPerf.GetPointer(), &_smSpare, sizeof _smSpare );
    }
} //ProcessCacheEvents

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::UpdatePendingRequestCount - public
//
//  Synopsis:   Updates the pending request statistic
//
//  History:    96-May-14   Alanw    Created
//
//----------------------------------------------------------------------------

void CWQueryCache::UpdatePendingRequestCount()
{
    *_pcRequestsQueued = (ULONG) TheWebPendingRequestQueue.Count();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CheckForPendingRequests - private
//
//  Synopsis:   Check pending for requests and process them
//
//  Returns:    TRUE if any pending requests were processed
//
//  History:    96-Apr-12   dlee    Created
//
//----------------------------------------------------------------------------

BOOL CWQueryCache::CheckForPendingRequests()
{
    // While the pending query queue is getting small in relation to the
    // number of threads processing the queries, move a pending request to
    // the pending query queue (or process it outright if it's synchronous).
    // Only process up to 8 queries -- the thread has other work to do too!

    ULONG cTwiceMaxThreads = 2 * TheIDQRegParams.GetMaxActiveQueryThreads();
    ULONG cProcessed = 0;

    while ( ( cProcessed < 8 ) &&
            ( TheWebPendingRequestQueue.Any() ) &&
            ( cTwiceMaxThreads >= _pendingQueue.Count() ) &&
            ( !fTheActiveXSearchShutdown ) )
    {
        ciGibDebugOut(( DEB_GIB_REQUEST, "Processing a pending request\n" ));

        CWebPendingItem item;

        // any items in the pending request queue?

        if ( !TheWebPendingRequestQueue.AcquireTop( item ) )
            return ( 0 != cProcessed );

        cProcessed++;

        CWebServer webServer( item.GetEcb() );

        Win4Assert( webServer.GetHttpStatus() == HTTP_STATUS_ACCEPTED );
        UpdatePendingRequestCount();

        // Process the request and complete the session if the query
        // was synchronous or if the parsing failed.  If the status is
        // pending, the request is owned by the pending query queue.

        // Impersonate the user specified by the client's browser
        // Note: the constructor of CImpersonateClient cannot throw, or
        //       the ecb will be leaked.

        CImpersonateClient impersonate( item.GetSecurityToken() );

        DWORD hseStatus = ProcessWebRequest( webServer );

        if ( HSE_STATUS_PENDING != hseStatus )
        {
            DecrementActiveRequests();
            ciGibDebugOut(( DEB_GIB_REQUEST,
                            "Released session in CheckForPendingRequests, active: %d\n",
                            _cActiveRequests ));
            ciGibDebugOut(( DEB_ITRACE, "releasing session hse %d http %d\n",
                            hseStatus, HTTP_STATUS_OK ));

            webServer.SetHttpStatus( HTTP_STATUS_OK );
            webServer.ReleaseSession( hseStatus );
        }

        //
        //  The destructor of CImpersonateClient will call RevertToSelf()
        //  thus restoring our privledge level, and the destructor of
        //  CWebPendingItem will close the security token handle.
        //
    }

    return ( 0 != cProcessed );
} //CheckForPendingRequests

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CheckForCompletedQueries - private
//
//  Synopsis:   Check for completed asynchronous queries
//
//  Returns:    TRUE if any completed queries were processed, FALSE otherwise
//
//  History:    96-Mar-04   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CWQueryCache::CheckForCompletedQueries()
{
    // shortcut for all-sequential query case

    if ( 0 == _pendingQueue.Count() )
        return FALSE;

    BOOL fDidWork = FALSE;
    XPtr<CWPendingQueryItem> pendingQuery;

    do
    {
        pendingQuery.Free();

        // Try to find a completed asynchronous query.
        // The snapshot code is necessary so IsQueryDone() isn't called
        // while holding the lock, as it can take a long time.

        {
            CLock shutdownLock( _mutexShutdown );

            // snapshot the pending query list

            XArray<CWPendingQueryItem *> xItems;

            {
                CLock lock( _mutex );

                xItems.Init( _pendingQueue.Count() );

                for ( unsigned i = 0; i < xItems.Count(); i++ )
                    xItems[ i ] = _pendingQueue[ i ];
            }

            unsigned iPos;

            // look for a completed query

            for ( unsigned i = 0;
                  pendingQuery.IsNull() && i < xItems.Count();
                  i++ )
            {
                TRY
                {
                    if ( xItems[i]->IsQueryDone() )
                    {
                        iPos = i;
                        pendingQuery.Set( xItems[i] );
                    }
                }
                CATCH( CException, e )
                {
                    // the query is in an error state.  pass it on below
                    // so that its state will be reported.

                    iPos = i;
                    pendingQuery.Set( xItems[i] );
                }
                END_CATCH
            }

            // Remove the query (if found) from the pending query queue.

            if ( !pendingQuery.IsNull() )
            {
                CLock lock( _mutex );

                // iPos must be accurate since new pending queries are
                // appended to the array, and this is the only place
                // items are removed.

                Win4Assert( _pendingQueue[ iPos ] == pendingQuery.GetPointer() );
                _pendingQueue.Remove( iPos );
            }
        }

        //
        //  If we found a completed query, output its results
        //
        if ( !pendingQuery.IsNull() )
        {
            CWQueryItem * pQueryItem = 0;

            TRY
            {
                ciGibDebugOut(( DEB_ITRACE, "An asynchronous web query has completed\n" ));

                fDidWork = TRUE;
                SCODE status = S_OK;

                CVariableSet  & variableSet  = pendingQuery->GetVariableSet();
                COutputFormat & outputFormat = pendingQuery->GetOutputFormat();

                Win4Assert( HTTP_STATUS_ACCEPTED == outputFormat.GetHttpStatus() );

                BOOL fCanonic = FALSE;

                CVirtualString vString( 16384 );

                TRY
                {
                    // Note: this acquire doesn't acquire the ecb

                    pQueryItem = pendingQuery->GetPendingQueryItem();
                    AddToCache( pQueryItem );
                    pendingQuery->AcquirePendingQueryItem();

                    Win4Assert( !pQueryItem->IsCanonicalOutput() );

                    pQueryItem->OutputQueryResults( variableSet,
                                                    outputFormat,
                                                    vString );
                }
                CATCH( CException, e )
                {
                    status = e.GetErrorCode();
                }
                END_CATCH

                if ( S_OK != status )
                {
                    vString.Empty();

                    GetErrorPageNoThrow( eDefaultISAPIError,
                                         status,
                                         0,
                                         pQueryItem->GetIDQFileName(),
                                         & variableSet,
                                         & outputFormat,
                                         outputFormat.GetLCID(),
                                         outputFormat,
                                         vString );
                }

                if ( !fCanonic )
                    outputFormat.WriteClient( vString );
            }
            CATCH( CException, e )
            {
                // Ignore failures writing to the web server, likely
                // out of memory converting output to narrow string.
            }
            END_CATCH

            Release( pQueryItem );

            // note: the ecb will be released when pendingQuery is freed
            // above in the loop or when we leave scope
        }
        else
        {
            break;
        }
    } while ( !fTheActiveXSearchShutdown );

    return fDidWork;
} //CheckForCompletedQueries

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CreateOrFindQuery - public
//
//  Synopsis:   Locates the query item specified by the variables
//
//  Arguments:  [wcsIDQFile]       - name of the IDQ file containing the query
//              [variableSet]      - parameters describing the query to find
//              [outputFormat]     - format of #'s & dates
//              [securityIdentity] - User session for this query
//              [fAsynchronous]    - was the query asynchronous
//
//  Returns:    query item matching; 0 otherwise
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

CWQueryItem * CWQueryCache::CreateOrFindQuery( WCHAR const * wcsIDQFile,
                                               XPtr<CVariableSet> & variableSet,
                                               XPtr<COutputFormat> & outputFormat,
                                               CSecurityIdentity securityIdentity,
                                               BOOL & fAsynchronous )
{
    XInterface<CWQueryItem> xQueryItem;

    CVariable * pVarBookmark = variableSet->Find( ISAPI_CI_BOOKMARK );

    if ( 0 != pVarBookmark )
    {
        //
        //  Get the bookmark & skipcount if specified
        //
        ULONG cwcValue;
        CWQueryBookmark bookMark( pVarBookmark->GetStringValueRAW() );

        LONG lSkipCount = 0;
        CVariable * pVarSkipCount = variableSet->Find( ISAPI_CI_BOOKMARK_SKIP_COUNT );
        if ( 0 != pVarSkipCount )
        {
            lSkipCount = IDQ_wtol( pVarSkipCount->GetStringValueRAW() );
        }

        xQueryItem.Set( FindItem( bookMark,
                                  lSkipCount,
                                  securityIdentity ) );
    }

    if ( !xQueryItem.IsNull() )
    {
        XArray<WCHAR> wcsLocale;
        LCID lcid = GetQueryLocale( xQueryItem->GetIDQFile().GetLocale(),
                                    variableSet.GetReference(),
                                    outputFormat.GetReference(),
                                    wcsLocale );

        Win4Assert( lcid == xQueryItem->GetLocale() );
        //
        //  Now that we have the appropriate locale information, we can generate
        //  the output format information.
        //
        outputFormat->LoadNumberFormatInfo( lcid );

        Win4Assert( 0 != wcsLocale.GetPointer() );
        variableSet->AcquireStringValue( ISAPI_CI_LOCALE, wcsLocale.GetPointer(), 0 );
        wcsLocale.Acquire();
    }
    else
    {
        //
        // Attempt to find a matching query with the same restriction,
        // scope, sort order, etc.

        xQueryItem.Set( FindItem( variableSet,
                                  outputFormat,
                                  wcsIDQFile,
                                  securityIdentity ) );

        if ( !xQueryItem.IsNull() )
            (*_pcTotalQueries)++;
    }

    // make sure the query isn't in bad shape (e.g. the pipe went away)

    if ( !xQueryItem.IsNull() )
    {
        TRY
        {
            // this will force a GetStatus(), and will throw on problems

            xQueryItem->IsQueryDone();
        }
        CATCH( CException, e )
        {
            // zombify the query before releasing it, so it isn't pulled
            // out of the cache and used again.

            xQueryItem->Zombify();
            Release( xQueryItem.Acquire(), FALSE );
        }
        END_CATCH;
    }

    if ( xQueryItem.IsNull() )
    {
        //
        //  We still haven't found a matching query item.  Build a new one
        //

        xQueryItem.Set( CreateNewQuery( wcsIDQFile,
                                        variableSet,
                                        outputFormat,
                                        securityIdentity,
                                        fAsynchronous ) );

        ciGibDebugOut(( DEB_ITRACE, "Item NOT found in cache\n" ));

        (*_pcTotalQueries)++;
        (*_pcCacheMisses)++;
        (*_pcCacheHitsAndMisses)++;
    }
    else
    {
        (*_pcCacheHits)++;
        (*_pcCacheHitsAndMisses)++;
        fAsynchronous = FALSE;
        ciGibDebugOut(( DEB_ITRACE, "Item found in cache\n" ));

        SetupDefaultCiVariables( variableSet.GetReference() );
        SetupDefaultISAPIVariables( variableSet.GetReference() );
    }

    Win4Assert( (  fAsynchronous &&  xQueryItem.IsNull() ) ||
                ( !fAsynchronous && !xQueryItem.IsNull() ) );

    // If it's asynchronous, CreateNewQuery will have already bumped the
    // count of running queries under lock, so we won't have the problem
    // where the query will be completed, output, and released before this
    // increment is called.

    if ( !fAsynchronous )
        IncrementRunningQueries();

    return xQueryItem.Acquire();
} //CreateOrFindQuery


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::FindItem - private
//
//  Synopsis:   Locates the query item specified by Bookmark.  The
//              bookmark is used to generate the address of the CWQueryItem
//              and the lSkipCount is used when the query is using a sequential
//              cursor to determine if the rowset is positioned at the
//              appropriate row.
//
//  Arguments:  [bookmark]         - bookmark of the item to find
//              [lSkipCount]       - number of records to skip past bookmark
//              [securityIdentity] - security LUID of the browser
//
//  Returns:    query item matching [bookmark]; 0 otherwise
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

CWQueryItem * CWQueryCache::FindItem( CWQueryBookmark & bookmark,
                                      LONG lSkipCount,
                                      CSecurityIdentity securityIdentity )
{
    if ( 0 == *_pcCacheItems )
        return 0;

    CWQueryItem * pQueryItem = 0;

    // ==========================================

    CLock lock( _mutex );

    TRY
    {
        CWQueryItem * pItem = (CWQueryItem *) bookmark.GetQueryItem();

        //
        //  Iterate through the cache looking for this item.
        //
        for ( CWQueryCacheForwardIter iter(*this);
              !AtEnd(iter);
              Advance(iter) )
        {
            if ( iter.Get() == pItem )
            {
                //
                //  Check to verify that all of the following match:
                //
                //      1   If sequential, its not in use
                //      2.  The sequence number matches
                //      3.  The memory block addressed is a CWQueryItem; check signature
                //      4.  We have the same security context
                //      5.  The cached data is still valid
                //      6.  next records # (for sequential queries only) matches
                //      7.  the item isn't a zombie
                //
                if ( (pItem->GetSequenceNumber() == bookmark.GetSequenceNumber()) &&
                     ( pItem->GetSignature() == CWQueryItemSignature ) &&
                     ( !pItem->IsSequential() ||
                        ( (bookmark.GetRecordNumber() + lSkipCount == pItem->GetNextRecordNumber() ) &&
                          (pItem->LokGetRefCount() == 0 )
                        )
                     ) &&
                     ( pItem->LokIsCachedDataValid() ) &&
                     ( !pItem->IsZombie() ) &&
                     ( securityIdentity.IsEqual(pItem->GetSecurityIdentity()) )
                   )
                {
                    pItem->AddRef();
                    LokMoveToFront( pItem );

                    pQueryItem = pItem;

                    break;
                }
            }
        }
    }
    CATCH (CException, e)
    {
    }
    END_CATCH

    return pQueryItem;

    // ==========================================
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::FindItem - private
//
//  Synopsis:   Locates the query item specified in the variables
//
//  Arguments:  [variableSet]      - parameters describing the query to find
//              [outputFormat]     - format of #'s & dates
//              [wcsIDQFile]       - name of the IDQ file containing the query
//              [securityIdentity] - security LUID of the browser
//
//  Returns:    query item matching; 0 otherwise
//
//  History:    96-Jan-18   DwightKr    Created
//              96-Mar-13   DwightKr    Allow output columns to be replaceable
//              97-Jun-11   KyleP       Use web server from output format
//
//----------------------------------------------------------------------------

CWQueryItem * CWQueryCache::FindItem( XPtr<CVariableSet> & variableSet,
                                      XPtr<COutputFormat> & outputFormat,
                                      WCHAR const * wcsIDQFile,
                                      CSecurityIdentity securityIdentity )
{
    // The idq search and parameter replacement need to be done
    // regardless of whether a cached query will be used.

    CIDQFile * pIdqFile = _idqFileList.Find( wcsIDQFile,
                                            outputFormat->CodePage(),
                                            securityIdentity );
    XInterface<CIDQFile> xIDQFile( pIdqFile );

    //
    //  Get string values for all parameters that define the query
    //
    ULONG cwc;
    XPtrST<WCHAR> wcsRestriction( ReplaceParameters( pIdqFile->GetRestriction(),
                                                     variableSet.GetReference(),
                                                     outputFormat.GetReference(),
                                                     cwc ) );

    XPtrST<WCHAR> wcsScope( ReplaceParameters( pIdqFile->GetScope(),
                                               variableSet.GetReference(),
                                               outputFormat.GetReference(),
                                               cwc ) );

    // ConvertSlashToBackSlash( wcsScope.GetPointer() );

    XPtrST<WCHAR> wcsSort( ReplaceParameters( pIdqFile->GetSort(),
                                              variableSet.GetReference(),
                                              outputFormat.GetReference(),
                                              cwc ) );

    XPtrST<WCHAR> wcsTemplate( ReplaceParameters( pIdqFile->GetHTXFileName(),
                                                  variableSet.GetReference(),
                                                  outputFormat.GetReference(),
                                                  cwc ) );

    XPtrST<WCHAR> wcsCatalog( ReplaceParameters( pIdqFile->GetCatalog(),
                                                 variableSet.GetReference(),
                                                 outputFormat.GetReference(),
                                                 cwc ) );

    XPtrST<WCHAR> wcsColumns( ReplaceParameters( pIdqFile->GetColumns(),
                                                 variableSet.GetReference(),
                                                 outputFormat.GetReference(),
                                                 cwc ) );

    XPtrST<WCHAR> wcsCiFlags( ReplaceParameters( pIdqFile->GetCiFlags(),
                                                 variableSet.GetReference(),
                                                 outputFormat.GetReference(),
                                                 cwc ) );

    XPtrST<WCHAR> wcsForceUseCI( ReplaceParameters( pIdqFile->GetForceUseCI(),
                                                    variableSet.GetReference(),
                                                    outputFormat.GetReference(),
                                                    cwc ) );

    XPtrST<WCHAR> wcsDeferTrimming( ReplaceParameters( pIdqFile->GetDeferTrimming(),
                                                       variableSet.GetReference(),
                                                       outputFormat.GetReference(),
                                                       cwc ) );

    LONG lMaxRecordsInResultSet =
            ReplaceNumericParameter( pIdqFile->GetMaxRecordsInResultSet(),
                                     variableSet.GetReference(),
                                     outputFormat.GetReference(),
                                     TheIDQRegParams.GetMaxISRowsInResultSet(),
                                     IS_MAX_ROWS_IN_RESULT_MIN,
                                     IS_MAX_ROWS_IN_RESULT_MAX );

    LONG lFirstRowsInResultSet =
            ReplaceNumericParameter( pIdqFile->GetFirstRowsInResultSet(),
                                     variableSet.GetReference(),
                                     outputFormat.GetReference(),
                                     TheIDQRegParams.GetISFirstRowsInResultSet(),
                                     IS_FIRST_ROWS_IN_RESULT_MIN,
                                     IS_FIRST_ROWS_IN_RESULT_MAX );

    XArray<WCHAR> wcsLocale;
    LCID lcid = GetQueryLocale( pIdqFile->GetLocale(),
                                    variableSet.GetReference(),
                                    outputFormat.GetReference(),
                                    wcsLocale );

    //
    //  Now that we have the appropriate locale information, we can generate
    //  the output format information.
    //
    outputFormat->LoadNumberFormatInfo( lcid );

    Win4Assert( 0 != wcsLocale.GetPointer() );
    variableSet->AcquireStringValue( ISAPI_CI_LOCALE, wcsLocale.GetPointer(), 0 );
    wcsLocale.Acquire();

    XInterface<CWQueryItem> xMatchItem;

    // ======================================
    if ( 0 != *_pcCacheItems )
    {
        CLock lock( _mutex );

        for ( CWQueryCacheForwardIter iter(*this);
              !AtEnd(iter);
              Advance(iter) )
        {
            CWQueryItem * pItem = iter.Get();
            Win4Assert( pItem != 0 );

            //
            //  Two queries are identical if all of the following match:
            //
            //      1.  idq file names & its not a zombie
            //      2.  restriction
            //      3.  scope
            //      4.  sort set
            //      5.  template file
            //      6.  output columns
            //      7.  security context
            //      8.  CiFlags
            //      9.  ForceUseCi
            //     10.  CiDeferNonIndexedTrimming
            //     11.  MaxRecordsInResultSet matches
            //     12.  FirstRowsInResultSet matches
            //     13.  CiLocale
            //     14.  next records # (for sequential queries only)
            //     15.  cached data is still valid
            //

            //
            //  Verify condition #1.
            //
            if ( ( _wcsicmp( wcsIDQFile, pItem->GetIDQFileName() ) != 0 ) &&
                 ( !pItem->IsZombie() )
               )
            {
                continue;
            }

            ciGibDebugOut(( DEB_ITRACE, "Checking cache item: %x\n", pItem ));

            LONG  lFirstSequentialRecord = 0;       // Assume no first record #
            ULONG cMatchedItems = 0;                // # of Matched items

            //
            //  Iterate through the list of parameters the browser passed
            //  to verify conditions #2 - #5 mentioned above.  Stop testing
            //  paramaters as soon as a mismatch is found. Also, save the
            //  BOOKMARK & SKIPCOUNT so that condition #7 can be verified later.
            //

            if ( (wcsRestriction.GetPointer() != 0) &&
                 (_wcsicmp( wcsRestriction.GetPointer(), pItem->GetRestriction() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: restrictions DONT match: %ws != %ws\n",
                                wcsRestriction.GetPointer(),
                                pItem->GetRestriction() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: restrictions match\n" ));

            #if DBG == 1
                #if 0 // NTBUG #114206 - we don't do this anymore
                    //
                    //  If we have a scope, verify that there are no slashes
                    //
                    WCHAR const * wcsSlashTest = wcsScope.GetPointer();
                    if ( 0 != wcsSlashTest )
                    {
                        while ( 0 != *wcsSlashTest )
                        {
                            Win4Assert( L'/' != *wcsSlashTest );
                            wcsSlashTest++;
                        }
                    }
                #endif // 0

                #if 0 // bogus assert due to the slash-flipping browser bug
                    wcsSlashTest = pItem->GetScope();
                    if ( 0 != wcsSlashTest )
                    {
                        while ( 0 != *wcsSlashTest )
                        {
                            Win4Assert( L'/' != *wcsSlashTest );
                            wcsSlashTest++;
                        }
                    }
                #endif // 0
            #endif // DBG == 1

            if ( (wcsScope.GetPointer() != 0) &&
                 (_wcsicmp( wcsScope.GetPointer(), pItem->GetScope() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: scopes DONT match: %ws != %ws\n",
                                wcsScope.GetPointer(),
                                pItem->GetScope() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: scopes match\n" ));


            if ( (wcsSort.GetPointer() != 0) &&
                 (pItem->GetSort() != 0 ) &&
                 (_wcsicmp( wcsSort.GetPointer(), pItem->GetSort() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: sorts DONT match: %ws != %ws\n",
                                wcsSort.GetPointer(),
                                pItem->GetSort() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: sorts match\n" ));


            if ( (wcsTemplate.GetPointer() != 0) &&
                 (_wcsicmp( wcsTemplate.GetPointer(), pItem->GetTemplate() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: templates DONT match: %ws != %ws\n",
                                wcsTemplate.GetPointer(),
                                pItem->GetTemplate() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: templates match\n" ));


            if ( (wcsCatalog.GetPointer() != 0) &&
                 (_wcsicmp( wcsCatalog.GetPointer(), pItem->GetCatalog() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: catalogs DONT match: %ws != %ws\n",
                                wcsCatalog.GetPointer(),
                                pItem->GetCatalog() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: catalogs match\n" ));


            if ( (wcsColumns.GetPointer() != 0) &&
                 (_wcsicmp( wcsColumns.GetPointer(), pItem->GetColumns() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: catalogs DONT match: %ws != %ws\n",
                                wcsColumns.GetPointer(),
                                pItem->GetColumns() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: output columns match\n" ));


            if ( (wcsCiFlags.GetPointer() != 0) &&
                 (pItem->GetCiFlags() != 0) &&
                 (_wcsicmp( wcsCiFlags.GetPointer(), pItem->GetCiFlags() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: CIFlags DONT match: %ws != %ws\n",
                                wcsCiFlags.GetPointer(),
                                pItem->GetCiFlags() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: CiFlags columns match\n" ));


            if ( (wcsForceUseCI.GetPointer() != 0) &&
                 (pItem->GetForceUseCI() != 0) &&
                 (_wcsicmp( wcsForceUseCI.GetPointer(), pItem->GetForceUseCI() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: ForceUseCI DONT match: %ws != %ws\n",
                                wcsForceUseCI.GetPointer(),
                                pItem->GetForceUseCI() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: ForceUseCI match\n" ));

            if ( (wcsDeferTrimming.GetPointer() != 0) &&
                 (pItem->GetDeferTrimming() != 0) &&
                 (_wcsicmp( wcsDeferTrimming.GetPointer(), pItem->GetDeferTrimming() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: CiDeferNonIndexedTrimming DONT match: %ws != %ws\n",
                                wcsDeferTrimming.GetPointer(),
                                pItem->GetDeferTrimming() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: CiDeferNonIndexedTrimming match\n" ));

            if ( lMaxRecordsInResultSet != pItem->GetMaxRecordsInResultSet() )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: MaxRecordsInResultSet DONT match: %d != %d\n",
                                lMaxRecordsInResultSet,
                                pItem->GetMaxRecordsInResultSet() ));
                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: MaxRecordsInResultSet match\n" ));


            if ( lFirstRowsInResultSet != pItem->GetFirstRowsInResultSet() )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: FirstRowsInResultSet DONT match: %d != %d\n",
                                lFirstRowsInResultSet,
                                pItem->GetFirstRowsInResultSet() ));
                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: FirstRowsInResultSet match\n" ));

            if ( lcid != pItem->GetLocale() )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: lcid DONT match: 0x%x != 0x%x\n",
                                lcid,
                                pItem->GetLocale() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: lcid match\n" ));


            if ( pItem->IsSequential() )
            {
                if ( pItem->LokGetRefCount() != 0 )
                {
                    ciGibDebugOut(( DEB_ITRACE,
                                    "Searching cache: Sequential query in use\n" ));
                    continue;
                }

                ULONG cwcValue;
                ULONG ulHash = ISAPIVariableNameHash( ISAPI_CI_BOOKMARK );
                WCHAR const * wcsBookmark = variableSet->GetStringValueRAW( ISAPI_CI_BOOKMARK,
                                                                            ulHash,
                                                                            outputFormat.GetReference(),
                                                                            cwcValue );
                if ( 0 != wcsBookmark )
                {
                    CWQueryBookmark bookMark( wcsBookmark );
                    lFirstSequentialRecord += bookMark.GetRecordNumber();
                }

                ulHash = ISAPIVariableNameHash( ISAPI_CI_BOOKMARK_SKIP_COUNT );
                WCHAR const * wcsBookmarkSkipCount = variableSet->GetStringValueRAW( ISAPI_CI_BOOKMARK_SKIP_COUNT,
                                                                                     ulHash,
                                                                                     outputFormat.GetReference(),
                                                                                     cwcValue );
                if ( 0 != wcsBookmarkSkipCount )
                {
                    lFirstSequentialRecord += IDQ_wtol( wcsBookmarkSkipCount );
                }
            }


            //
            //  We've found a match after examining all of the parameters
            //  passed from the browser.  Now verify conditions #6 - #8 above.
            //

            ciGibDebugOut(( DEB_ITRACE, "Matched %d out of %d parameters\n",
                                         cMatchedItems,
                                         pItem->GetReplaceableParameterCount() ));

            if ( pItem->GetReplaceableParameterCount() > cMatchedItems )
            {
                continue;
            }

            if ( securityIdentity.IsEqual( pItem->GetSecurityIdentity() ) )
            {
                if ( pItem->IsSequential() &&
                     ( lFirstSequentialRecord != pItem->GetNextRecordNumber() )
                   )
                {
                    continue;
                }


                if ( !pItem->LokIsCachedDataValid() )
                {
                    continue;
                }

                //
                //  We've found a match.  Move it to the front of the list and
                //  increment its refcount.  We assume that a query once referenced
                //  will be referenced again, hence the move to the front of the
                //  list.
                //
                pItem->AddRef();
                LokMoveToFront( pItem );

                xMatchItem.Set( pItem );
                break;
            }
        }
    }
    // ======================================


    //
    //  If we got a match, then save away the parameters we've expanded.  They
    //  will be used later as output parameters.
    //

    // Setting ISAPI_CI_MAX_RECORDS_IN_RESULTSET can fail, so we'd
    // leak an addref on the query item without the smart pointer.

    if ( !xMatchItem.IsNull() )
    {
        if ( 0 != wcsRestriction.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_RESTRICTION, wcsRestriction.GetPointer(), 0 );
            wcsRestriction.Acquire();
        }

        if ( 0 != wcsScope.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_SCOPE, wcsScope.GetPointer(), 0 );
            wcsScope.Acquire();
        }


        if ( 0 != wcsSort.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_SORT, wcsSort.GetPointer(), 0 );
            wcsSort.Acquire();
        }

        if ( 0 != wcsTemplate.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_TEMPLATE, wcsTemplate.GetPointer(), 0 );
            wcsTemplate.Acquire();
        }

        if ( 0 != wcsCatalog.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_CATALOG, wcsCatalog.GetPointer(), 0 );
            wcsCatalog.Acquire();
        }

        if ( 0 != wcsColumns.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_COLUMNS, wcsColumns.GetPointer(), 0 );
            wcsColumns.Acquire();
        }

        if ( 0 != wcsCiFlags.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_FLAGS, wcsCiFlags.GetPointer(), 0 );
            wcsCiFlags.Acquire();
        }

        if ( 0 != wcsForceUseCI.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_FORCE_USE_CI, wcsForceUseCI.GetPointer(), 0 );
            wcsForceUseCI.Acquire();
        }

        if ( 0 != wcsDeferTrimming.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_DEFER_NONINDEXED_TRIMMING, wcsDeferTrimming.GetPointer(), 0 );
            wcsDeferTrimming.Acquire();
        }

        PROPVARIANT propVariant;
        propVariant.vt   = VT_I4;
        propVariant.lVal = lMaxRecordsInResultSet;
        variableSet->SetVariable( ISAPI_CI_MAX_RECORDS_IN_RESULTSET, &propVariant, 0 );

        PROPVARIANT propVar;
        propVar.vt   = VT_I4;
        propVar.lVal = lFirstRowsInResultSet;
        variableSet->SetVariable( ISAPI_CI_FIRST_ROWS_IN_RESULTSET, &propVar, 0 );
    }

    return xMatchItem.Acquire();
} //FindItem

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::DeleteOldQueries - public
//
//  Synopsis:   If we haven't checked the query list for at least the maximum
//              time an unused query is allowed to remain in the list, walk
//              the query item list and delete all items whose last access
//              time is greater than the purge time.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::DeleteOldQueries()
{
    time_t ttNow = time(0);
    time_t  oldestAllowableTime = ttNow - (60 * TheIDQRegParams.GetISCachePurgeInterval());

    //
    // Don't free the queries under lock.  It can take a long long time.
    // We don't need an allocation here; delete at most 40 queries.
    //
    //
    // NOTE: the code below can't throw or we'll leak queries!
    //

    const int cAtMost = 40;
    CWQueryItem * aItems[ cAtMost ];
    int iQueries = 0;

    {
        CLock lock( _mutex );
        CWQueryCacheForwardIter iter( *this );

        while ( !AtEnd( iter ) && iQueries < cAtMost )
        {
            //
            // If no one is using this query, and it is old, delete it now.
            //

            CWQueryItem * pItem = iter.Get();

            if ( pItem->LokGetRefCount() == 0 &&
                 ( pItem->LokGetLastAccessTime() < oldestAllowableTime ||
                   pItem->IsZombie() ) )
            {
                Advance( iter );
                pItem->Unlink();
                aItems[ iQueries++ ] = pItem;

                Win4Assert( *_pcCacheItems > 0 );
                (*_pcCacheItems)--;

                ciGibDebugOut(( DEB_ITRACE,
                                "Removing an expired item from the cache, %d queries cached\n",
                                *_pcCacheItems ));
            }
            else
            {
                Advance( iter );
            }
        }
    }

    for ( int i = 0; i < iQueries; i++ )
        Remove( aItems[ i ] );
} //DeleteOldQueries

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::LokMoveToFront - public
//
//  Arguments:  [pItem] - the CWQueryItem to move to the front the of list
//
//  Synopsis:   Moves a query item to the front of the list.  This routine
//              is called whenever a query object is accessed.
//
//  History:    96-Jan-18   DwightKr    Created
//              96-Feb-20   DwightKr    Remove time reset
//
//----------------------------------------------------------------------------
void CWQueryCache::LokMoveToFront( CWQueryItem * pItem )
{
    Win4Assert( pItem != 0 );

    pItem->Unlink();
    Push(pItem);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CreateNewQuery - private
//
//  Synopsis:   Creates a new query and adds it to the linked list of items.
//
//  Arguments:  [wcsIDQFile]   - name of the IDQ file referenced by this query
//              [variableSet]  - variables used to create this new query
//              [outputFormat] - format of numbers & dates
//              [securityIdentity] - security context of this query
//
//  Returns:    a new CWQueryItem, fully constructed with the query results
//              already cached & the item added to the linked list of
//              cached queries ONLY if this is a non-sequential query.
//
//  History:    18-Jan-96   DwightKr    Created
//              11-Jun-97   KyleP       Use web server from output format
//
//----------------------------------------------------------------------------

CWQueryItem * CWQueryCache::CreateNewQuery( WCHAR const * wcsIDQFile,
                                            XPtr<CVariableSet> & variableSet,
                                            XPtr<COutputFormat> & outputFormat,
                                            CSecurityIdentity securityIdentity,
                                            BOOL & fAsynchronous )
{
    LONG lFirstRecordNumber = 1;
    CVariable *pVariable = variableSet->Find( ISAPI_CI_FIRST_RECORD_NUMBER );

    if ( 0 != pVariable )
    {
        lFirstRecordNumber = IDQ_wtol( pVariable->GetStringValueRAW() );
    }

    //
    //  Attempt to find a parsed version of the IDQ file in the IDQ file
    //  list.
    //
    CIDQFile * pIdqFile = _idqFileList.Find( wcsIDQFile,
                                            outputFormat->CodePage(),
                                            securityIdentity );

    XInterface<CIDQFile> xIDQFile( pIdqFile );

    //
    //  Did we parse the IDQ file with the correct local & code page?  Check
    //  to see if we used the wrong one. We attempted to open it with the locale
    //  and code page specified by the browser.  Determine if the IDQ file
    //  overrides this value.
    //
    XArray<WCHAR> wcsLocale;
    LCID locale = GetQueryLocale( pIdqFile->GetLocale(),
                                  variableSet.GetReference(),
                                  outputFormat.GetReference(),
                                  wcsLocale );

    Win4Assert( !pIdqFile->IsCanonicalOutput() );

    if ( outputFormat->GetLCID() != locale )
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Wrong codePage used for loading IDQ file, used 0x%x retrying with 0x%x\n",
                        outputFormat->CodePage(),
                        LocaleToCodepage(locale) ));

        //
        //  We've parsed the IDQ file with the wrong locale.
        //

        _idqFileList.Release( *(xIDQFile.Acquire()) );
        outputFormat->LoadNumberFormatInfo( locale );

        pIdqFile =  _idqFileList.Find( wcsIDQFile,
                                      outputFormat->CodePage(),
                                      securityIdentity );
        xIDQFile.Set( pIdqFile );
    }

    SetupDefaultCiVariables( variableSet.GetReference() );
    SetupDefaultISAPIVariables( variableSet.GetReference() );

    //
    //  Determine which output columns this IDQ file uses
    //
    ULONG cwcOut;
    XPtrST<WCHAR> wcsColumns( ReplaceParameters( pIdqFile->GetColumns(),
                                                 variableSet.GetReference(),
                                                 outputFormat.GetReference(),
                                                 cwcOut ) );

    CDynArray<WCHAR> awcsColumns;

    XPtr<CDbColumns> dbColumns( pIdqFile->ParseColumns( wcsColumns.GetPointer(),
                                                      variableSet.GetReference(),
                                                      awcsColumns ) );

    //
    //  Attempt to find a parsed version of the HTX file in the HTX file
    //  list.
    //


    Win4Assert( !pIdqFile->IsCanonicalOutput() );

    CHTXFile & htxFile = _htxFileList.Find( pIdqFile->GetHTXFileName(),
                           variableSet.GetReference(),
                           outputFormat.GetReference(),
                           securityIdentity,
                           outputFormat->GetServerInstance() );

    XInterface<CHTXFile> xHTXFile( &htxFile );

    CWQueryItem *pNewItem = new CWQueryItem( *pIdqFile,
                                             htxFile,
                                             wcsColumns,
                                             dbColumns,
                                             awcsColumns,
                                             GetNextSequenceNumber(),
                                             lFirstRecordNumber,
                                             securityIdentity );
    XPtr<CWQueryItem> xNewItem( pNewItem);
    xIDQFile.Acquire();
    xHTXFile.Acquire();

    pNewItem->ExecuteQuery( variableSet.GetReference(),
                            outputFormat.GetReference() );

    if ( xNewItem->IsSequential() || xNewItem->IsQueryDone() )
    {
        AddToCache( xNewItem.GetPointer() );

        fAsynchronous = FALSE;

        ciGibDebugOut(( DEB_ITRACE, "Creating a synchronous web query\n" ));
    }
    else
    {
        {
            // ==========================================
            CLock lock( _mutex );

            if ( fTheActiveXSearchShutdown )
                THROW( CException(STATUS_TOO_LATE) );

            // xNewItem is acquired in CWPendingQueryItem's constructor

            CWPendingQueryItem * pItem = new CWPendingQueryItem( xNewItem,
                                                                 outputFormat,
                                                                 variableSet );

            // _pendingQueue's array has been pre-allocated to a large size,
            // so it can't fail.  Even if it could fail we don't want to
            // put CWPendingQueryItem in an xptr since the webServer may
            // be released twice on failure.

            _pendingQueue.Add( pItem, _pendingQueue.Count() );

            IncrementRunningQueries();
            // ==========================================
        }

        fAsynchronous = TRUE;
        ciGibDebugOut(( DEB_ITRACE, "Creating an asynchronous web query\n" ));

        Wakeup();   // wake up thread to check if the query is completed
    }

    Win4Assert( (  fAsynchronous &&  xNewItem.IsNull() ) ||
                ( !fAsynchronous && !xNewItem.IsNull() ) );

    return xNewItem.Acquire();
} //CreateNewQuery

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::AddToCache - public
//
//  Arguments:  [pNewItem] - Item to add to cache
//
//  History:    96-Mar-04   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::AddToCache( CWQueryItem * pNewItem )
{
    // This assert can hit if the user has just lowered
    // IsapiMaxEntriesInQueryCache and the cache was full and a new query
    // was just issued and the cache has not yet been reduced.

    //Win4Assert ( *_pcCacheItems <= TheIDQRegParams.GetMaxISQueryCache() );

    //
    //  If we already have too many query items in the cache, try to
    //  delete some.
    //

    CWQueryItem * pItemToDelete = 0;

    // ==========================================
    if ( pNewItem->CanCache() )
    {
        CLock lock( _mutex );

        CWQueryCacheBackwardIter iter(*this);
        while ( *_pcCacheItems >= TheIDQRegParams.GetMaxISQueryCache() &&
                 !AtEnd(iter) )
        {
            ciGibDebugOut(( DEB_ITRACE, "Too many items in cache, attempting to delete one\n" ));

            CWQueryItem * pItem = iter.Get();

            if ( pItem->LokGetRefCount() == 0 )
            {
                pItemToDelete = pItem;
                pItemToDelete->Unlink();

                Win4Assert( *_pcCacheItems > 0 );
                (*_pcCacheItems)--;

                break;
            }
            else
            {
                BackUp(iter);
            }
        }
    }


    if ( 0 != pItemToDelete )
    {
        Remove( pItemToDelete );
    }

    //  If we STILL have too many queries in the cache, we couldn't delete
    //  any because they were all in use.
    //

    pNewItem->AddRef();

    if ( 0 != TheIDQRegParams.GetMaxISQueryCache() )
    {
        // ==========================================
        CLock lock( _mutex );

        //
        // If we're shutting down, don't attempt to put anything in the cache.
        //
        if ( *_pcCacheItems < TheIDQRegParams.GetMaxISQueryCache() &&
             pNewItem->CanCache() &&
             !fTheActiveXSearchShutdown )
        {
            Push( pNewItem );
            pNewItem->InCache();

            (*_pcCacheItems)++;
        }
        else
        {
            ciGibDebugOut(( DEB_ITRACE, "Still too many items in cache, creating non-cached query\n" ));
        }
        // ==========================================
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Remove - public
//
//  Arguments:  [pItem] - Item to remove from cache
//
//  Synopsis:   Removes from cache and releases IDQ & HTX files.
//
//  History:    96-Mar-28   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::Remove( CWQueryItem * pItem )
{
    Win4Assert( 0 != pItem );

    delete pItem;
} //Remove

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Release - public
//
//  Arguments:  [pItem]              -- Item to release - return to cache
//              [fDecRunningQueries] -- If true, the count of running
//                                      queries should be decremented.
//
//  Synopsis:   Decrements the refcount, and attempts to add it to the
//              cache if it's not already there.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::Release( CWQueryItem * pItem, BOOL fDecRunningQueries )
{
    if ( 0 != pItem )
    {
        pItem->Release();

        if ( fDecRunningQueries )
            DecrementRunningQueries();

        //
        //  The item may not be in the cache, because the cache was full
        //  at the time the query was created.
        //

        if ( ! pItem->IsInCache() )
        {
            //
            //  Don't attempt to add the query item to the cache here.  If
            //  the add operation throws, we won't release the refcount
            //  on the idq & htx files.
            //
            Remove( pItem );
        }
    }
} //Release

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::FlushCache - public
//
//  Synopsis:   Flushes the cache .. waits until the cache is empty
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::FlushCache()
{
    //
    //  Delete each of the pending asynchronous queries. Take the lock so
    //  that the worker thread can't wake up and start processing one of
    //  these items while we're deleting it.
    //

    {
        // ==========================================

        CLock shutdownLock( _mutexShutdown );
        CLock lock( _mutex );
        for ( unsigned i=0; i<_pendingQueue.Count(); i++ )
        {
            delete _pendingQueue.Get(i);
        }

        _pendingQueue.Clear();
        Win4Assert( _pendingQueue.Count() == 0 );

        // ==========================================
    }

    //
    //  Wait for each of the cached queries to be deleted.  We many have to
    //  sleep for a bit to allow a thread to write the results of an
    //  active query.
    //
    while ( *_pcCacheItems > 0 )
    {
        ciGibDebugOut(( DEB_ITRACE, "Flushing the cache\n" ));

        {
            // ==========================================

            CLock lock( _mutex );

            CWQueryCacheForwardIter iter(*this);

            while ( !AtEnd(iter) )
            {
                CWQueryItem * pItem = iter.Get();

                if ( pItem->LokGetRefCount() == 0 )
                {
                    Advance(iter);

                    pItem->Unlink();

                    Remove( pItem );

                    Win4Assert( *_pcCacheItems > 0 );
                    (*_pcCacheItems)--;
                }
                else
                {
                    Advance(iter);
                }
            }

            // ==========================================
        }

        //
        //  If there are more items to delete, release the lock, wait a
        //  bit then try again.
        //
        if ( *_pcCacheItems > 0 )
        {
            ciGibDebugOut(( DEB_ITRACE, "CWQueryCache::FlushCache  waiting for queries to complete\n" ));
            Sleep(1000);
        }
    }
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void SetupDefaultCiVariables( CVariableSet & variableSet )
{
    //
    //  Setup the default Ci variables
    //

    for ( unsigned i=0; i<cCiGlobalVars; i++)
    {
        if ( variableSet.Find( aCiGlobalVars[i].wcsVariableName ) == 0 )
        {
            PROPVARIANT Variant;
            Variant.vt  = aCiGlobalVars[i].vt;
            Variant.uhVal.QuadPart = aCiGlobalVars[i].i64DefaultValue;

            variableSet.SetVariable( aCiGlobalVars[i].wcsVariableName,
                                      &Variant,
                                      aCiGlobalVars[i].flags);
        }
    }
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void SetupDefaultISAPIVariables( CVariableSet & variableSet )
{
    //
    //  Setup the default ISAPI variables
    //

    for ( unsigned i=0; i<cISAPIGlobalVars; i++)
    {
        if ( variableSet.Find( aISAPIGlobalVars[i].wcsVariableName ) == 0 )
        {
            PROPVARIANT Variant;
            Variant.vt  = aISAPIGlobalVars[i].vt;
            Variant.uhVal.QuadPart = aISAPIGlobalVars[i].i64DefaultValue;

            variableSet.SetVariable( aISAPIGlobalVars[i].wcsVariableName,
                                      &Variant,
                                      aISAPIGlobalVars[i].flags);
        }
    }
}


#if (DBG == 1)
//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Dump - public
//
//  Arguments:  [string]       - buffer to send results to
//              [variableSet]  - replaceable parameters
//              [outputFormat] - format of numbers & dates
//
//  Synopsis:   Dumps the state of all queries
//
//  Notes:      The variableSet and outputFormat are for the
//              current request, i.e., the !dump command, not
//              for the individual queries in the cache.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

WCHAR wcsDumpBuffer[500];

void CWQueryCache::Dump( CVirtualString & string,
                         CVariableSet & variableSet,
                         COutputFormat & outputFormat )
{
    // ==========================================

    CLock lock( _mutex );

    string.StrCat( L"<H1>Dump of query cache</H1><P>"
//                 L"<A HREF=\"#stats\">Cache statistics</A><BR>"
//                 L"<A HREF=\"#pending\">Pending queries</A><BR>"
//                 L"<A HREF=\"#cache\">Cached queries</A><BR>"
                   L"<P><H2><A NAME=stats>Cache statistics</H2><P>\n" );

    ULONG cwcDumpBuffer = swprintf( wcsDumpBuffer,
                                L"Unique queries since service startup: %d<BR>"
                                L"Number of items in cache: %d<BR>"
                                L"Number of cache hits: %d<BR>"
                                L"Number of cache misses: %d<BR>"
                                L"Number of cache hits and misses: %d<BR>"
                                L"Number of running queries: %d<BR>"
                                L"Number of queries run thus far: %d<BR>\n",
                                _ulSequenceNumber,
                                *_pcCacheItems,
                                *_pcCacheHits,
                                *_pcCacheMisses,
                                *_pcCacheHitsAndMisses,
                                *_pcRunningQueries,
                                *_pcTotalQueries );

    string.StrCat( wcsDumpBuffer, cwcDumpBuffer );

    string.StrCat( L"<H2><A NAME=pending>Pending Queries</H2><P>" );
    //
    //  Dump the pending query queue
    //
    for (unsigned i=0;
         i<_pendingQueue.Count();
         i++ )
    {
        if ( _pendingQueue[i] )
        {
            cwcDumpBuffer = swprintf( wcsDumpBuffer,
                                  L"<P>\n<H3>Pending query # %d contents:</H3><P>\n",
                                  i+1 );

            string.StrCat( wcsDumpBuffer, cwcDumpBuffer );

            _pendingQueue[i]->LokDump( string /*, variableSet, outputFormat */);
        }
    }

    string.StrCat( L"<H2><HREF NAME=cache>Cached Queries</H2><P>" );
    i = 1;
    for ( CWQueryCacheForwardIter iter(*this);
          !AtEnd(iter);
          Advance(iter), i++ )
    {
        cwcDumpBuffer = swprintf( wcsDumpBuffer,
                              L"<P>\n<H3>Cached query # %d contents:</H3><P>\n",
                              i );

        string.StrCat( wcsDumpBuffer, cwcDumpBuffer );

        iter.Get()->LokDump( string /*, variableSet, outputFormat */);
    }

    // ==========================================
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Internal - public
//
//  Arguments:  [variableSet]  - variable containing command to execute
//              [outputFormat] - format of numbers & dates
//              [string]       - buffer to send results to
//
//  Synopsis:   Executes one of a number of internal commands to the
//              query cache.
//
//  History:    96-Jan-18   DwightKr    Created
//              96-Fen-21   DwightKr    Added help
//
//----------------------------------------------------------------------------
BOOL CWQueryCache::Internal( CVariableSet & variableSet,
                             COutputFormat & outputFormat,
                             CVirtualString & string )
{
    CVariable * pVarRestriction = variableSet.Find(ISAPI_CI_RESTRICTION );

    if ( (0 != pVarRestriction) && (0 != pVarRestriction->GetStringValueRAW()) )
    {
        if (_wcsicmp( pVarRestriction->GetStringValueRAW(), L"!dump") == 0 )

        {
            string.StrCat( L"<HEAD><TITLE>Dump of query cache</TITLE></HEADER>" );
            Dump( string, variableSet, outputFormat );
            return TRUE;
        }
        else if (_wcsicmp( pVarRestriction->GetStringValueRAW(), L"!flush") == 0 )
        {
            string.StrCat( L"<HEAD><TITLE>Cache flush</TITLE></HEADER>Flushing cache...<BR>\n" );

            FlushCache();

            string.StrCat( L"Flush complete<BR>\n" );
            return TRUE;
        }
        else if (_wcsicmp( pVarRestriction->GetStringValueRAW(), L"!?") == 0 )
        {
            string.StrCat( L"<HEAD><TITLE>Help</TITLE></HEADER>" );
            string.StrCat( L"Avaiable commands:<BR>\n");
            string.StrCat( L"!dump  - dumps contents of the query cache<BR>\n" );
            string.StrCat( L"!flush - empties the query cache<BR>\n" );
            string.StrCat( L"!?     - help (this page)<BR>\n" );
            return TRUE;
        }
    }

    return FALSE;
}
#endif // DBG == 1


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::AddToPendingRequestQueue - public
//
//  Synopsis:   Adds the ECB to the pending queue, if we're not shutting down
//
//  History:    96-May-22   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL CWQueryCache::AddToPendingRequestQueue( EXTENSION_CONTROL_BLOCK *pEcb )
{
    // Don't take the query cache lock here -- there is no reason to since
    // reads are atomic and we don't want IIS to make a zillion threads.

    if ( fTheActiveXSearchShutdown ||
         TheWebPendingRequestQueue.IsFull( ) )
    {
        return FALSE;
    }

    TOKEN_STATISTICS TokenInformation;
    HANDLE hToken = GetSecurityToken(TokenInformation);

    //
    //  It must be an impersonation token, hence we must have a valid handle.
    //  Build a pending request using the ECB and the security token,
    //
    Win4Assert( INVALID_HANDLE_VALUE != hToken );
    Win4Assert( TokenInformation.TokenType == TokenImpersonation );

    CWebPendingItem item( pEcb, hToken );

    //
    //  Add the request to the pending queue.
    //
    return TheWebPendingRequestQueue.Add( item );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Shutdown - public
//
//  Synopsis:   Stops and empties the query cache
//
//  History:    96-May-22   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::Shutdown()
{
    //
    //  First set the shutdown flag so that no queues will be added to after
    //  this point.
    //
    {
        CLock lock( _mutex );
        fTheActiveXSearchShutdown = TRUE;
    }

    FlushCache();

    Wakeup();               // wake up thread & wait for death
    WaitForSingleObject( _threadWatchDog.GetHandle(), INFINITE );

    Win4Assert( IsEmpty() && "Query cache must be empty after flush" );
}

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::CICommandCache, public
//
//  Synopsis:   Constructor for the ICommand cache
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

CICommandCache::CICommandCache() : _ulSig( LONGSIG( 'c', 'i', 'c', 'c' ) )
{
    //
    // These registry params are taken at startup and ignored
    // thereafter.  This isn't an issue on big machines where the
    // query cache is turned off, but we might want to fix it.
    // Maybe someday, but IDQ is pretty much a dead technology.
    //

    unsigned cItems = TheIDQRegParams.GetMaxISQueryCache();
    ULONG factor = TheIDQRegParams.GetISRequestThresholdFactor();

    SYSTEM_INFO si;
    GetSystemInfo( &si );

    // # of threads allowed in idq + # pending queries + # queries in cache

    cItems += ( 2 * si.dwNumberOfProcessors * factor );

    _aItems.Init( cItems );

    RtlZeroMemory( _aItems.GetPointer(), _aItems.SizeOf() );

    const CLSID clsidCommandCreator = CLSID_CISimpleCommandCreator;
    HRESULT hr = CoCreateInstance( clsidCommandCreator,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_ISimpleCommandCreator,
                                   xCmdCreator.GetQIPointer() );

    if ( FAILED( hr ) )
        THROW( CException() );
} //CICommandCache

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::Make, public
//
//  Synopsis:   Returns an ICommand, either from the cache or by making one
//
//  Arguments:  [ppCommand]   -- Where the ICommand is returned
//              [depth]       -- deep / shallow, etc.
//              [pwcMachine]  -- The machine
//              [pwcCatalog]  -- The catalog
//              [pwcScope]    -- The comma separated list of scopes
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

SCODE CICommandCache::Make(
    ICommand **   ppCommand,
    DWORD         depth,
    WCHAR const * pwcMachine,
    WCHAR const * pwcCatalog,
    WCHAR const * pwcScope )
{
    *ppCommand = 0;

    // first look for an available item in the cache

    {
        CLock lock( _mutex );

        for ( unsigned x = 0; x < _aItems.Count(); x++ )
        {
            CICommandItem & item = _aItems[ x ];

            if ( ( !item.xCommand.IsNull() ) &&
                 ( !item.fInUse ) &&
                 ( depth == item.depth ) &&
                 ( !wcscmp( pwcMachine, item.aMachine.Get() ) ) &&
                 ( !wcscmp( pwcCatalog, item.aCatalog.Get() ) ) &&
                 ( !wcscmp( pwcScope, item.aScope.Get() ) ) )
            {
                ciGibDebugOut(( DEB_ITRACE, "reusing icommand from cache\n" ));
                item.fInUse = TRUE;
                *ppCommand = item.xCommand.GetPointer();
                Win4Assert( 0 != *ppCommand );
                return S_OK;
            }
        }
    }

    // not found in the cache -- make the item

    ciGibDebugOut(( DEB_ITRACE, "creating icommand\n" ));

    XInterface<ICommand> xCommand;

    SCODE sc = ParseAndMake( xCommand.GetPPointer(),
                             depth,
                             pwcMachine,
                             pwcCatalog,
                             pwcScope );

    if ( FAILED( sc ) )
        return sc;

    // can we put the item in the cache?

    {
        CLock lock( _mutex );

        for ( unsigned x = 0; x < _aItems.Count(); x++ )
        {
            CICommandItem & item = _aItems[ x ];

            if ( item.xCommand.IsNull() )
            {
                // First see if we can add it.

                item.aMachine.ReSize( wcslen( pwcMachine ) + 1 );
                wcscpy( item.aMachine.Get(), pwcMachine );

                item.aCatalog.ReSize( wcslen( pwcCatalog ) + 1 );
                wcscpy( item.aCatalog.Get(), pwcCatalog );

                item.aScope.ReSize( wcslen( pwcScope ) + 1 );
                wcscpy( item.aScope.Get(), pwcScope );

                // Now mark it as owned

                Win4Assert( !item.fInUse );

                item.fInUse = TRUE;
                item.xCommand.Set( xCommand.GetPointer() );
                Win4Assert( 0 != item.xCommand.GetPointer() );
                item.depth = depth;

                break;
            }
        }
    }

    *ppCommand = xCommand.Acquire();
    Win4Assert( 0 != *ppCommand );

    return S_OK;
} //Make

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::Release, public
//
//  Synopsis:   Releases the ICommand to the cache or to be freed
//
//  Arguments:  [pCommand]   -- The ICommand to release.
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

void CICommandCache::Release(
    ICommand * pCommand )
{
    {
        CLock lock( _mutex );

        // first see if it can be returned to the cache

        for ( unsigned x = 0; x < _aItems.Count(); x++ )
        {
            CICommandItem & item = _aItems[ x ];

            if ( item.xCommand.GetPointer() == pCommand )
            {
                Win4Assert( item.fInUse );
                ciGibDebugOut(( DEB_ITRACE, "returning icommand to cache\n" ));
                item.fInUse = FALSE;
                return;
            }
        }
    }

    ciGibDebugOut(( DEB_ITRACE, "icommand not in cache, releasing\n" ));

    // not in the cache -- just release it

    pCommand->Release();
} //Release

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::Remove, public
//
//  Synopsis:   Removes the item from the cache, likely because the ICommand
//              is stale because cisvc went down.
//
//  Arguments:  [pCommand]   -- The ICommand to release.
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

void CICommandCache::Remove(
    ICommand * pCommand )
{
    {
        CLock lock( _mutex );

        // first see if it is in the cache

        for ( unsigned x = 0; x < _aItems.Count(); x++ )
        {
            CICommandItem & item = _aItems[ x ];

            if ( item.xCommand.GetPointer() == pCommand )
            {
                Win4Assert( item.fInUse );
                item.xCommand.Acquire();
                item.fInUse = FALSE;
                break;
            }
        }
    }

    // not in the cache -- just release it

    pCommand->Release();
} //Remove

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::Purge, public
//
//  Synopsis:   Releases all ICommands not currently in use
//
//  Arguments:  [pCommand]   -- The ICommand to release.
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

void CICommandCache::Purge()
{
    CLock lock( _mutex );

    // Remove all non-used items from the cache.

    for ( unsigned x = 0; x < _aItems.Count(); x++ )
    {
        CICommandItem & item = _aItems[ x ];

        if ( ( !item.fInUse ) &&
             ( !item.xCommand.IsNull() ) )
        {
            item.xCommand.Free();
        }
    }
} //Purge

//+---------------------------------------------------------------------------
//
//  Function:   IsAVirtualPath
//
//  Synopsis:   Determines if the path passed is a virtual or physical path.
//              If it's a virtual path, then / are changed to \.
//
//  History:    96-Feb-14   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL IsAVirtualPath( WCHAR * wcsPath )
{
    Win4Assert ( 0 != wcsPath );
    if ( 0 == wcsPath[0] )
        return TRUE;

    if ( ( L':' == wcsPath[1] ) || ( L'\\' == wcsPath[0] ) )
    {
        return FALSE;
    }
    else
    {
        //
        //  Flip slashes to backslashes
        //

        for ( WCHAR *wcsLetter = wcsPath; 0 != *wcsLetter; wcsLetter++ )
        {
            if ( L'/' == *wcsLetter )
                *wcsLetter = L'\\';
        }
    }

    return TRUE;
} //IsAVirtualPath

//+---------------------------------------------------------------------------
//
//  Function:   ParseScopes
//
//  Synopsis:   Translates a string like:
//                  "  /foo ,c:\bar   ,   "/a b , /c " , j:\dog  "
//              into a multisz string like:
//                  "/foo0c:\bar0/a b , /c 0j:\dog00"
//
//              Leading and trailing white space is removed unless the
//              path is quoted, in which case you get exactly what you
//              asked for even though it may be incorrect.
//
//  Arguments:  [pwcIn]  -- the source string
//              [pwcOut] -- the multisz result string, guaranteed to be
//                          no more than 1 WCHAR larger than pwcIn.
//
//  History:    97-Jun-17   dlee    Created
//
//----------------------------------------------------------------------------

ULONG ParseScopes(
    WCHAR const * pwcIn,
    WCHAR *       pwcOut )
{
    ULONG cScopes = 0;

    while ( 0 != *pwcIn )
    {
        // eat space and commas

        while ( L' ' == *pwcIn || L',' == *pwcIn )
            pwcIn++;

        if ( 0 == *pwcIn )
            break;

        // is this a quoted path?

        if ( L'"' == *pwcIn )
        {
            pwcIn++;

            while ( 0 != *pwcIn && L'"' != *pwcIn )
                *pwcOut++ = *pwcIn++;

            if ( L'"' != *pwcIn )
                THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );

            pwcIn++;
            *pwcOut++ = 0;
        }
        else
        {
            while ( 0 != *pwcIn && L',' != *pwcIn )
                *pwcOut++ = *pwcIn++;

            // back up over trailing spaces

            while ( L' ' == * (pwcOut - 1) )
                pwcOut--;

            *pwcOut++ = 0;
        }

        cScopes++;
    }

    if ( 0 == cScopes )
        THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );

    // end the string with a second null

    *pwcOut = 0;

    return cScopes;
} //ParseScopes

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::ParseAndMake, private
//
//  Synopsis:   Parses parameters for an ICommand and creates one
//
//  Arguments:  [ppCommand]   -- Where the ICommand is returned
//              [depth]       -- deep / shallow, etc.
//              [pwcMachine]  -- The machine
//              [pwcCatalog]  -- The catalog
//              [pwcScope]    -- The comma separated list of scopes
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

SCODE CICommandCache::ParseAndMake(
    ICommand **   ppCommand,
    DWORD         depth,
    WCHAR const * pwcMachine,
    WCHAR const * pwcCatalog,
    WCHAR const * pwcScope )
{
    Win4Assert(pwcMachine && pwcCatalog);

#if 0 // This is actually a bogus check.  We don't care how long it is.
    if ( wcslen( pwcMachine ) > MAX_COMPUTERNAME_LENGTH )
        THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );
#endif

    if ( wcslen( pwcCatalog ) > MAX_PATH )
        THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );

    IUnknown * pIUnknown;
    XInterface<ICommand> xCmd;

    if (0 == xCmdCreator.GetPointer())
        return REGDB_E_CLASSNOTREG;

    SCODE sc = xCmdCreator->CreateICommand(&pIUnknown, 0);
    XInterface<IUnknown> xUnk( pIUnknown );

    if ( SUCCEEDED (sc) )
    {
        sc = pIUnknown->QueryInterface(IID_ICommand, xCmd.GetQIPointer());
    }

    if (FAILED(sc))
        return sc;

    TRY
    {
        CDynArrayInPlace<DWORD> aDepths(2);
        CDynArrayInPlace<WCHAR const *> aScopes(2);
        CDynArrayInPlace<WCHAR const *> aMachines(2);
        CDynArrayInPlace<WCHAR const *> aCatalogs(2);

        // allocate +2 for two trailing nulls in the multisz string

        ULONG cwcScope = 2 + wcslen( pwcScope );
        XGrowable<WCHAR> aScope( cwcScope );
        ULONG cScopes = ParseScopes( pwcScope, aScope.Get() );

        Win4Assert( 0 != cScopes );

        if ( cScopes > 1 )
        {
            // Add support for multiple catalogs, and/or machines,
            // and/or depths.  For now, all scopes share a single
            // catalog/machine/depth. (though you can mix virtual and
            // physical).  Maybe someday, but IDQ is dead moving forward.

            WCHAR *pwc = aScope.Get();

            for ( ULONG iScope = 0; iScope < cScopes; iScope++ )
            {
                if ( wcslen( pwc ) >= MAX_PATH )
                    THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );

                aDepths[iScope] = depth;

                if ( IsAVirtualPath( pwc ) )
                    aDepths[iScope] |= QUERY_VIRTUAL_PATH;

                aScopes[iScope] = pwc;

                ciGibDebugOut(( DEB_ITRACE, "scope %d: flags 0x%x '%ws'\n",
                                iScope, aDepths[iScope], pwc ));

                // pwc is a multi-sz string.  Skip to the next scope

                pwc += ( 1 + wcslen( pwc ) );

                aMachines[iScope] = pwcMachine;
                aCatalogs[iScope] = pwcCatalog;
            }
        }
        else
        {
            aMachines[0] = pwcMachine;
            aCatalogs[0] = pwcCatalog;
            aDepths[0] = depth;
            WCHAR *pwc = aScope.Get();
            if ( IsAVirtualPath( pwc ) )
                aDepths[0] |= QUERY_VIRTUAL_PATH;
            aScopes[0] = pwc;
        }

        SetScopeProperties( xCmd.GetPointer(),
                            cScopes,
                            aScopes.GetPointer(),
                            aDepths.GetPointer(),
                            aCatalogs.GetPointer(),
                            aMachines.GetPointer() );

        *ppCommand = xCmd.Acquire();
        Win4Assert( 0 != *ppCommand );
    }
    CATCH ( CException, e )
    {
        sc = GetOleError(e);
    }
    END_CATCH

    return sc;
} //ParseAndMake
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\tokstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       tokstr.cxx
//
//  Contents:   Used to break down a string into its tokens
//
//  History:    96/Feb/13   DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Method:     CTokenizeString::CTokenizeString - public constructor
//
//  History:    96/Jan/23   DwightKr    Created
//
//----------------------------------------------------------------------------
CTokenizeString::CTokenizeString( WCHAR const * wcsString ) :
            _wcsString(wcsString),
            _wcsCurrentToken(wcsString),
            _wcsNextToken(wcsString)
{
    Accept();
}


//+---------------------------------------------------------------------------
//
//  Method:     CTokenizeString::Accept - public
//
//  History:    96/Jan/23   DwightKr    Created
//
//----------------------------------------------------------------------------
void CTokenizeString::Accept()
{
    EatWhiteSpace();

    _wcsCurrentToken = _wcsNextToken;

    switch ( *_wcsCurrentToken )
    {
    case L'"':
        _wcsNextToken++;
        _token = QUOTES_TOKEN;
    break;

    case L'{':
        _wcsNextToken++;
        _token = C_OPEN_TOKEN;
    break;

    case L'}':
        _wcsNextToken++;
        _token = C_CLOSE_TOKEN;
    break;

    case L',':
        _wcsNextToken++;
        _token = COMMA_TOKEN;
    break;

    case 0:
        _token = EOS_TOKEN;
    break;

    default:
        _wcsNextToken = _wcsCurrentToken + wcscspn( _wcsCurrentToken, WORD_STR );
        _token = TEXT_TOKEN;
    break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString:AcqWord, public
//
//  Synopsis:   Copies the word that _wcsCurrentToken is pointing to and
//              returns the new string. Positions _wcsCurrentToken after
//              the word and whitespace. Returns 0 if at the end of a
//              TEXT_TOKEN.
//
//  History:    96-Feb-13    DwightKr   Created.
//
//----------------------------------------------------------------------------
WCHAR * CTokenizeString::AcqWord()
{
    if ( IsEndOfTextToken() )
        return 0;

    WCHAR const * pEnd = _wcsNextToken;

    int cwcToken = (int)(pEnd - _wcsCurrentToken + 1);

    WCHAR * newBuf = new WCHAR [ cwcToken ];
    RtlCopyMemory( newBuf, _wcsCurrentToken, cwcToken * sizeof(WCHAR));
    newBuf[cwcToken-1] = 0;

    _wcsCurrentToken = pEnd;
    while ( iswspace(*_wcsCurrentToken) )
        _wcsCurrentToken++;

    return newBuf;
}



//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the unsigned _int64 from the scanner into number
//              and returns TRUE.
//
//  Arguments:  [number] -- the unsigned _int64 which will be changed and
//                          passed back out as the ULONG from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Feb-13   AmyA        Created
//
//----------------------------------------------------------------------------
BOOL CTokenizeString::GetNumber( unsigned _int64 & number )
{
    ULONG base = 10;
    WCHAR const * wcsCurrentToken = _wcsCurrentToken;

    if ( IsEndOfTextToken() ||
         !iswdigit(*_wcsCurrentToken) ||
        (*_wcsCurrentToken == L'-') )
    {
        return FALSE;
    }


    if ( _wcsCurrentToken[0] == L'0' &&
        (_wcsCurrentToken[1] == L'x' || _wcsCurrentToken[1] == L'X'))
    {
        _wcsCurrentToken += 2;
        base = 16;
    }

    number = _wcstoui64( _wcsCurrentToken, (WCHAR **)(&_wcsCurrentToken), base );

    //
    // looks like a real number?
    //

    if ( ( wcsCurrentToken == _wcsCurrentToken ) ||
         ( L'.' == *_wcsCurrentToken ) )
    {
        _wcsCurrentToken = wcsCurrentToken;
        return FALSE;
    }

    while ( iswspace(*_wcsCurrentToken) )
        _wcsCurrentToken++;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::GetNumber, public
//
//  Synopsis:   If _wcsCurrentToken is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the _int64 from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the _int64 which will be changed and passed back
//                          out as the _int64 from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CTokenizeString::GetNumber( _int64 & number )
{
    WCHAR *text = (WCHAR *) _wcsCurrentToken;
    BOOL IsNegative = FALSE;
    if ( L'-' == _wcsCurrentToken[0] )
    {
        IsNegative = TRUE;
        _wcsCurrentToken++;
    }

    unsigned _int64 ui64Number;
    if ( !GetNumber( ui64Number ) )
    {
        _wcsCurrentToken = text;
        return FALSE;
    }


    if ( IsNegative )
    {
        if ( ui64Number > 0x8000000000000000L )
        {
            _wcsCurrentToken = text;
            return FALSE;
        }

        number = -((_int64) ui64Number);
    }
    else
    {
        number = (_int64) ui64Number;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::GetNumber, public
//
//  Synopsis:   If _wcsCurrentToken is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the LONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the double which will be changed and passed back
//                          out as the double from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CTokenizeString::GetNumber( double & number )
{
    if ( IsEndOfTextToken() ||
         ((L'-' != *_wcsCurrentToken) &&
          (iswdigit(*_wcsCurrentToken) == 0) )
       )
    {
        return FALSE;
    }

    if ( swscanf( _wcsCurrentToken, L"%lf", &number ) != 1 )
    {
        return FALSE;
    }

    while ( iswspace(*_wcsCurrentToken) != 0 )
        _wcsCurrentToken++;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::GetGUID, public
//
//  Synopsis:   If _wcsCurrentToken is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the guid into guid & returns TRUE;
//
//  Arguments:  [guid] -- the guid which will be changed and passed back
//                        out as the output from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CTokenizeString::GetGUID( GUID & guid )
{
    if ( IsEndOfTextToken() || !iswdigit(*_wcsCurrentToken) )
        return FALSE;


    //                              0123456789 123456789 123456789 123456
    //  A guid MUST have the syntax XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    //

    //
    //  Don't use wsscanf.  We're scanning into *bytes*, but wsscanf assumes
    //  result locations are *dwords*. Thus a write to the last few bytes of
    //  the guid writes over other memory!
    //
    WCHAR wcsGuid[37];
    RtlZeroMemory( wcsGuid, sizeof(wcsGuid) );
    wcsncpy( wcsGuid, _wcsCurrentToken, 36 );

    if ( wcsGuid[8] != L'-' )
        return FALSE;

    wcsGuid[8] = 0;
    WCHAR * pwcStart = &wcsGuid[0];
    WCHAR * pwcEnd;
    guid.Data1 = wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[8] )  // Non-digit found before wcsGuid[8]
        return FALSE;

    if ( wcsGuid[13] != L'-' )
        return FALSE;

    wcsGuid[13] = 0;
    pwcStart = &wcsGuid[9];
    guid.Data2 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[13] )
        return FALSE;


    if ( wcsGuid[18] != L'-' )
        return FALSE;

    wcsGuid[18] = 0;
    pwcStart = &wcsGuid[14];
    guid.Data3 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[18] )
        return FALSE;

    WCHAR wc = wcsGuid[21];
    wcsGuid[21] = 0;
    pwcStart = &wcsGuid[19];
    guid.Data4[0] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[21] )
        return FALSE;

    wcsGuid[21] = wc;

    if ( wcsGuid[23] != L'-' )
        return FALSE;

    wcsGuid[23] = 0;
    pwcStart = &wcsGuid[21];
    guid.Data4[1] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[23] )
        return FALSE;

    for ( unsigned i = 0; i < 6; i++ )
    {
        wc = wcsGuid[26+i*2];
        wcsGuid[26+i*2] = 0;
        pwcStart = &wcsGuid[24+i*2];
        guid.Data4[2+i] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
        if ( pwcEnd < &wcsGuid[26+i*2] )
            return FALSE;

        wcsGuid[26+i*2] = wc;
    }

    _wcsCurrentToken += 36;

    _wcsNextToken = _wcsCurrentToken;

    EatWhiteSpace();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::AcqPhrase, public
//
//  Synopsis:   gets all characters up to end-of-line or next quote
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
WCHAR * CTokenizeString::AcqPhrase()
{
    //
    //  Find the closing "
    //

    WCHAR const * wcsClosingQuote = _wcsCurrentToken;

    do
    {
        if ( 0 == *wcsClosingQuote )
            break;

        if ( L'"' == *wcsClosingQuote )
        {
            if ( L'"' == *(wcsClosingQuote+1) )
                wcsClosingQuote++;
            else
                break;
        }

        wcsClosingQuote++;
    } while ( TRUE );

    //
    //  We've found the closing quote.  Build a buffer big enough to
    //  contain the string.
    //
    ULONG cwcToken = (ULONG)(wcsClosingQuote - _wcsCurrentToken + 1);
    XArray<WCHAR> wcsToken( cwcToken );

    //
    // copy the string, but remove the extra quote characters
    //
    WCHAR * pwcNewBuf = wcsToken.GetPointer();
    WCHAR const * pStart = _wcsCurrentToken;

    while ( pStart < wcsClosingQuote )
    {
        *pwcNewBuf++ = *pStart++;
        if ( L'"' == *pStart )
            pStart++;
    }

    *pwcNewBuf = 0;

    _wcsCurrentToken += cwcToken - 1;
    _wcsNextToken = _wcsCurrentToken;

    EatWhiteSpace();

    return wcsToken.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::AcqVector, public
//
//  Synopsis:   Gets each of the vector elements upto the next }
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
void CTokenizeString::AcqVector( PROPVARIANT & propVariant )
{
    //
    //  Determine the VT type of this vector.
    //

    GUID   guid;
    _int64 i64Value;
    double dblValue;

    if ( GetGUID( guid ) )
    {
        propVariant.vt = VT_CLSID | VT_VECTOR;
        propVariant.cauuid.cElems = 0;

        CDynArrayInPlace<GUID> pElems;

        do
        {
            Accept();

            pElems.Add( guid, propVariant.cauuid.cElems );
            propVariant.cauuid.cElems++;

            if ( LookAhead() == COMMA_TOKEN )
            {
                Accept();
            }

        } while ( GetGUID( guid ) );

        propVariant.cauuid.pElems = pElems.Acquire();
    }
    else if ( GetNumber( i64Value ) )
    {
        propVariant.vt = VT_I8 | VT_VECTOR;
        propVariant.cah.cElems = 0;

        CDynArrayInPlace<_int64> pElems;

        do
        {
            Accept();

            pElems.Add( i64Value, propVariant.cah.cElems );
            propVariant.cah.cElems++;

            if ( LookAhead() == COMMA_TOKEN )
            {
                Accept();
            }

        } while ( GetNumber( i64Value ) );

        propVariant.cah.pElems = (LARGE_INTEGER *) pElems.Acquire();
    }
    else if ( GetNumber( dblValue ) )
    {
        propVariant.vt = VT_R8 | VT_VECTOR;
        propVariant.cadbl.cElems = 0;

        CDynArrayInPlace<double> pElems;
        do
        {   Accept();

            pElems.Add( dblValue, propVariant.cadbl.cElems );
            propVariant.cadbl.cElems++;

            if ( LookAhead() == COMMA_TOKEN )
            {
                Accept();
            }

        } while ( GetNumber( dblValue ) );

        propVariant.cadbl.pElems = pElems.Acquire();
    }
    else
    {
        propVariant.vt = VT_LPWSTR | VT_VECTOR;
        CDynArrayInPlace<WCHAR *> pElems;
        propVariant.calpwstr.cElems = 0;

        while ( (LookAhead() != C_CLOSE_TOKEN) &&
                (LookAhead() != EOS_TOKEN)
              )
        {
            //
            //  If its a quoted string, get everything between the quotes.
            //
            if ( LookAhead() == QUOTES_TOKEN )
            {
                Accept();               // Skip over the quote
                pElems.Add(AcqPhrase(), propVariant.calpwstr.cElems );
                Accept();               // Skip over the string

                if ( LookAhead() != QUOTES_TOKEN )
                {
                    THROW( CHTXException(MSG_CI_HTX_MISSING_QUOTE, 0, 0) );
                }
                Accept();               // Skip over the quote
            }
            else
            {
                //
                //  Get the next word
                //

                pElems.Add( AcqWord(), propVariant.calpwstr.cElems );
                Accept();              // Skip over the string
            }

            propVariant.calpwstr.cElems++;
            if ( LookAhead() == COMMA_TOKEN )
            {
                Accept();
            }
        }

        propVariant.calpwstr.pElems = pElems.Acquire();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\wqitem.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       wqitem.cxx
//
//  Contents:   WEB Query item class
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <params.hxx>

static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};

static const GUID guidQueryExt = DBPROPSET_QUERYEXT;
static const GUID guidRowsetProps = DBPROPSET_ROWSET;

static const DBID dbidVirtualPath = { QueryGuid, DBKIND_GUID_PROPID, (LPWSTR) 9 };

DBBINDING g_aDbBinding[ MAX_QUERY_COLUMNS ];


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::CWQueryItem - public constructor
//
//  Arguments:  [idqFile]            - IDQ file corresponding to this query
//              [htxFile]            - HTX file corresponding to this query
//              [wcsColumns]         - string representation of output columns
//              [dbColumns]          - OLE-DB column representation of output
//              [avarColumns]        - Variables from [dbColumns]. Same order.
//              [ulSequenceNumber]   - sequence # to assign this query
//              [lNextRecordNumber]  - # of next available record from query
//                                     results; important for reconstructing
//                                     stale sequential queries
//              [securityIdentity]   - security context of this query
//
//  Synopsis:   Builds a new query object, parses the IDQ file, and parses
//              the HTX file.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

CWQueryItem::CWQueryItem(CIDQFile & idqFile,
                         CHTXFile & htxFile,
                         XPtrST<WCHAR> & wcsColumns,
                         XPtr<CDbColumns> & dbColumns,
                         CDynArray<WCHAR> & awcsColumns,
                         ULONG ulSequenceNumber,
                         LONG lNextRecordNumber,
                         CSecurityIdentity securityIdentity ) :
                              _signature(CWQueryItemSignature),
                              _idqFile(idqFile),
                              _htxFile(htxFile),
                              _ulSequenceNumber(ulSequenceNumber),
                              _refCount(0),
                              _fIsZombie(FALSE),
                              _fInCache(FALSE),
                              _fCanCache(TRUE),
                              _locale(InvalidLCID),
                              _wcsRestriction(0),
                              _wcsDialect(0),
                              _ulDialect(0),
                              _wcsSort(0),
                              _wcsScope(0),
                              _wcsCatalog(0),
                              _wcsCiFlags(0),
                              _wcsForceUseCI(0),
                              _wcsDeferTrimming(0),
                              _wcsColumns(wcsColumns.Acquire()),
                              _wcsQueryTimeZone(0),
                              _pDbColumns(dbColumns.Acquire()),
                              _awcsColumns( awcsColumns ),
                              _pIRowset(0),
                              _pIAccessor(0),
                              _pIRowsetStatus(0),
                              _pICommand(0),
                              _lNextRecordNumber(lNextRecordNumber),
                              _cFilteredDocuments(0),
                              _securityIdentity(securityIdentity)
{
    time ( &_lastAccessTime );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::~CWQueryItem - public destructor
//
//  Synopsis:   Releases storage and interfaces.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

CWQueryItem::~CWQueryItem()
{
    Win4Assert( _refCount == 0 );

    delete _wcsRestriction;
    delete _wcsDialect;
    delete _wcsSort;
    delete _wcsScope;
    delete _wcsCatalog;
    delete _wcsColumns;
    delete _wcsCiFlags;
    delete _wcsForceUseCI;
    delete _wcsDeferTrimming;
    delete _wcsQueryTimeZone;
    delete _pDbColumns;

    if ( 0 != _pIAccessor )
    {
        _pIAccessor->ReleaseAccessor( _hAccessor, 0 );
        _pIAccessor->Release();
    }

    if ( 0 != _pIRowset )
    {
        _pIRowset->Release();
    }

    if ( 0 != _pIRowsetStatus )
    {
        _pIRowsetStatus->Release();
    }

    if ( 0 != _pICommand )
    {
        TheICommandCache.Release( _pICommand );
    }

    _idqFile.Release();
    _htxFile.Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::ExecuteQuery - public
//
//  Synopsis:   Executes the query and builds an IRowset or IRowsetScroll
//              as necessary.
//
//  Arguments:  [variableSet]  - list of replaceable parameters
//              [outputFormat] - format of numbers & dates
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryItem::ExecuteQuery( CVariableSet & variableSet,
                                COutputFormat & outputFormat )
{
    Win4Assert( 0 == _pIRowset );     // Should not have executed query
    Win4Assert( 0 == _pIAccessor );

    _locale = outputFormat.GetLCID();

    //
    //  Setup the variables needed to execute this query; including:
    //
    //      CiRestriction
    //      CiMaxRecordsInResultSet
    //      CiSort
    //      CiScope
    //

    //
    //  Build the final restriction from the existing restriction string
    //  and the additional parameters passed in from the browser.
    //
    ULONG cwcOut;
    _wcsRestriction = ReplaceParameters( _idqFile.GetRestriction(),
                                         variableSet,
                                         outputFormat,
                                         cwcOut );

    variableSet.CopyStringValue( ISAPI_CI_RESTRICTION, _wcsRestriction, 0, cwcOut );
    ciGibDebugOut(( DEB_ITRACE, "Restriction = '%ws'\n", _wcsRestriction ));
    if ( 0 == *_wcsRestriction )
    {
        THROW( CIDQException(MSG_CI_IDQ_MISSING_RESTRICTION , 0) );
    }

    //
    //  Setup CiMaxRecordsInResultSet
    //
    _lMaxRecordsInResultSet =
            ReplaceNumericParameter( _idqFile.GetMaxRecordsInResultSet(),
                                     variableSet,
                                     outputFormat,
                                     TheIDQRegParams.GetMaxISRowsInResultSet(),
                                     IS_MAX_ROWS_IN_RESULT_MIN,
                                     IS_MAX_ROWS_IN_RESULT_MAX );

    PROPVARIANT propVariant;
    propVariant.vt   = VT_I4;
    propVariant.lVal = _lMaxRecordsInResultSet;
    variableSet.SetVariable( ISAPI_CI_MAX_RECORDS_IN_RESULTSET, &propVariant, 0 );
    ciGibDebugOut(( DEB_ITRACE, "CiMaxRecordsInResultSet = %d\n", _lMaxRecordsInResultSet ));

    //  Setup CiFirstRowsInResultSet
    //
    _lFirstRowsInResultSet =
            ReplaceNumericParameter( _idqFile.GetFirstRowsInResultSet(),
                                     variableSet,
                                     outputFormat,
                                     TheIDQRegParams.GetISFirstRowsInResultSet(),
                                     IS_FIRST_ROWS_IN_RESULT_MIN,
                                     IS_FIRST_ROWS_IN_RESULT_MAX );

    PROPVARIANT propVar;
    propVar.vt   = VT_I4;
    propVar.lVal = _lFirstRowsInResultSet;
    variableSet.SetVariable( ISAPI_CI_FIRST_ROWS_IN_RESULTSET, &propVar, 0 );
    ciGibDebugOut(( DEB_ITRACE, "CiFirstRowsInResultSet = %d\n", _lFirstRowsInResultSet ));


    _ulDialect =
            ReplaceNumericParameter( _idqFile.GetDialect(),
                                     variableSet,
                                     outputFormat,
                                     ISQLANG_V2,       // default
                                     ISQLANG_V1,       // min
                                     ISQLANG_V2 );     // max
    Win4Assert( 0 != _ulDialect );

    propVariant.vt   = VT_UI4;
    propVariant.ulVal = _ulDialect;
    variableSet.SetVariable( ISAPI_CI_DIALECT, &propVariant, 0 );
    ciGibDebugOut(( DEB_ITRACE, "CiDialect = %d\n", _ulDialect ));

    //
    //  Build the final sort set from the existing sortset string
    //  and the additional parameters passed in from the browser.
    //

    XPtr<CDbSortNode> xDbSortNode;

    if ( 0 != _idqFile.GetSort() )
    {
        _wcsSort = ReplaceParameters( _idqFile.GetSort(),
                                      variableSet,
                                      outputFormat,
                                      cwcOut );

        variableSet.CopyStringValue( ISAPI_CI_SORT, _wcsSort, 0, cwcOut );

        ciGibDebugOut(( DEB_ITRACE, "Sort = '%ws'\n", _wcsSort ));
        Win4Assert( 0 != _wcsSort );
    }

    //
    //  Build the projection list from the column list.
    //

    CTextToTree textToTree( _wcsRestriction,
                            _ulDialect,
                            _pDbColumns,
                            _idqFile.GetColumnMapper(),
                            _locale,
                            _wcsSort,
                            0,
                            0,
                            _lMaxRecordsInResultSet,
                            _lFirstRowsInResultSet );

    CDbCmdTreeNode * pDbCmdTree = (CDbCmdTreeNode *) (void *) textToTree.FormFullTree();
    XPtr<CDbCmdTreeNode> xDbCmdTree( pDbCmdTree );

    //
    //  Remap the scope from a replaceable parameter
    //
    _wcsScope = ReplaceParameters( _idqFile.GetScope(),
                                   variableSet,
                                   outputFormat,
                                   cwcOut );

    variableSet.CopyStringValue( ISAPI_CI_SCOPE, _wcsScope, 0, cwcOut );

    ciGibDebugOut(( DEB_ITRACE, "Scope = '%ws'\n", _wcsScope ));
    Win4Assert( 0 != _wcsScope );
    if ( 0 == *_wcsScope )
    {
        THROW( CIDQException(MSG_CI_IDQ_MISSING_SCOPE , 0) );
    }

    //
    //  Build the location of the catalog
    //
    ULONG cwcCatalog;
    Win4Assert( 0 != _idqFile.GetCatalog() );
    _wcsCatalog = ReplaceParameters( _idqFile.GetCatalog(),
                                     variableSet,
                                     outputFormat,
                                     cwcCatalog );

    variableSet.CopyStringValue( ISAPI_CI_CATALOG, _wcsCatalog, 0, cwcCatalog );

    ciGibDebugOut(( DEB_ITRACE, "Catalog = '%ws'\n", _wcsCatalog ));
    Win4Assert( 0 != _wcsCatalog );

    if ( !IsAValidCatalog( _wcsCatalog, cwcCatalog ) )
    {
        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_CATALOG, 0) );
    }

    XPtrST<WCHAR> xpCat;
    XPtrST<WCHAR> xpMach;

    if ( ( ! SUCCEEDED( ParseCatalogURL( _wcsCatalog, xpCat, xpMach ) ) ) ||
         ( xpCat.IsNull() ) )
    {
        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_CATALOG, 0) );
    }

    //
    //  Get the query flags.
    //
    ULONG cwcCiFlags;
    _wcsCiFlags = ReplaceParameters( _idqFile.GetCiFlags(),
                                     variableSet,
                                     outputFormat,
                                     cwcCiFlags );

    if ( 0 != _wcsCiFlags )
    {
        variableSet.CopyStringValue( ISAPI_CI_FLAGS, _wcsCiFlags, 0, cwcCiFlags );
    }
    ULONG ulFlags = _idqFile.ParseFlags( _wcsCiFlags );
    ciGibDebugOut(( DEB_ITRACE, "CiFlags = '%ws' (%x)\n", _wcsCiFlags, ulFlags ));

    //
    //  We've setup all the parameters to run the query.  Run the query
    //  now.
    //
    _pICommand = 0;

    //
    // Paths start out as one of:
    //     ?:\...
    //     \\....\....\
    //     /...
    //

    SCODE scIC = S_OK;

    if ( _wcsicmp( _wcsScope, L"VIRTUAL_ROOTS" ) == 0 )
    {
        _fCanCache = FALSE;
        CheckAdminSecurity( xpMach.GetPointer() );
        IUnknown * pIUnknown;
        scIC = MakeMetadataICommand( &pIUnknown,
                                     CiVirtualRoots,
                                     xpCat.GetPointer(),
                                     xpMach.GetPointer() );
        if (SUCCEEDED (scIC))
        {
           XInterface<IUnknown> xUnk( pIUnknown );
           scIC = pIUnknown->QueryInterface(IID_ICommand, (void **)&_pICommand);
        }
    }
    else if ( _wcsicmp( _wcsScope, L"PROPERTIES" ) == 0 )
    {
        _fCanCache = FALSE;
        CheckAdminSecurity( xpMach.GetPointer() );
        IUnknown * pIUnknown;
        scIC = MakeMetadataICommand( &pIUnknown,
                                     CiProperties,
                                     xpCat.GetPointer(),
                                     xpMach.GetPointer() );
        if (SUCCEEDED (scIC))
        {
           XInterface<IUnknown> xUnk( pIUnknown );
           scIC = pIUnknown->QueryInterface(IID_ICommand, (void **)&_pICommand);
        }

    }
    else
    {
        //
        // Verify that the caller has admin security for DontTimeout queries.
        //
        if ( _idqFile.IsDontTimeout() )
            CheckAdminSecurity( xpMach.GetPointer() );

        scIC = TheICommandCache.Make( &_pICommand,
                                      ulFlags,
                                      xpMach.GetPointer(),
                                      xpCat.GetPointer(),
                                      _wcsScope );

    }

    #if CIDBG == 1
        if ( FAILED( scIC ) )
            Win4Assert( 0 == _pICommand );
        else
            Win4Assert( 0 != _pICommand );
    #endif // CIDBG == 1

    if ( 0 == _pICommand )
    {
        ciGibDebugOut(( DEB_ITRACE, "Make*ICommand failed with error 0x%x\n", scIC ));

        // Make*ICommand returns SCODEs, not Win32 error codes

        Win4Assert( ERROR_FILE_NOT_FOUND != scIC );
        Win4Assert( ERROR_SEM_TIMEOUT != scIC );

        // These errors are no longer returned -- the work isn't
        // done until Execute(), and the errors are mapped to
        // the popular E_FAIL.  Leave the code in since now the
        // OLE DB spec allows the errors and we may change the provider.

        if ( ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == scIC ) ||
             ( HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ) == scIC ) )
        {
            THROW( CIDQException( MSG_CI_IDQ_CISVC_NOT_RUNNING, 0 ) );
        }
        else
        {
            THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );
        }
    }

    ICommandTree * pICmdTree = 0;
    SCODE sc = _pICommand->QueryInterface( IID_ICommandTree,
                                           (void **) &pICmdTree );
    if (FAILED (sc) )
    {
        THROW( CException( QUERY_EXECUTE_FAILED ) );
    }

    DBCOMMANDTREE * pDbCommandTree = pDbCmdTree->CastToStruct();
    sc = pICmdTree->SetCommandTree(&pDbCommandTree, DBCOMMANDREUSE_NONE, FALSE);
    pICmdTree->Release();

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    xDbCmdTree.Acquire();

    //
    //  Save the time this query started execution
    //
    GetLocalTime( &_queryTime );

    //
    //  If we should NOT be using a enumerated query, notify pCommand
    //
    const unsigned MAX_PROPS = 5;
    DBPROPSET  aPropSet[MAX_PROPS];
    DBPROP     aProp[MAX_PROPS];
    ULONG      cProp = 0;

    // Set the property that says we accept PROPVARIANTs
    aProp[cProp].dwPropertyID   = DBPROP_USEEXTENDEDDBTYPES;
    aProp[cProp].dwOptions      = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus       = 0;         // Ignored
    aProp[cProp].colid          = dbcolNull;
    aProp[cProp].vValue.vt      = VT_BOOL;
    aProp[cProp].vValue.boolVal = VARIANT_TRUE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = guidQueryExt;

    cProp++;

    ULONG cwc;
    _wcsForceUseCI = ReplaceParameters( _idqFile.GetForceUseCI(),
                                        variableSet,
                                        outputFormat,
                                        cwc );

    if ( 0 != _wcsForceUseCI )
    {
        variableSet.CopyStringValue( ISAPI_CI_FORCE_USE_CI, _wcsForceUseCI, 0, cwc );
    }

    BOOL fForceUseCI = _idqFile.ParseForceUseCI( _wcsForceUseCI );
    ciGibDebugOut(( DEB_ITRACE, "CiForceUseCi = '%ws'\n", _wcsForceUseCI ));

    {
        // Set the property that says we don't want to enumerate
        aProp[cProp].dwPropertyID   = DBPROP_USECONTENTINDEX;
        aProp[cProp].dwOptions      = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus       = 0;         // Ignored
        aProp[cProp].colid          = dbcolNull;
        aProp[cProp].vValue.vt      = VT_BOOL;
        aProp[cProp].vValue.boolVal = fForceUseCI ? VARIANT_TRUE : VARIANT_FALSE;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidQueryExt;

        cProp++;
    }

    PROPVARIANT Variant;
    Variant.vt   = VT_BOOL;
    Variant.boolVal = fForceUseCI ? VARIANT_TRUE : VARIANT_FALSE;
    variableSet.SetVariable( ISAPI_CI_FORCE_USE_CI, &Variant, 0 );

    _wcsDeferTrimming = ReplaceParameters( _idqFile.GetDeferTrimming(),
                                           variableSet,
                                           outputFormat,
                                           cwc );

    if ( 0 != _wcsDeferTrimming )
    {
        variableSet.CopyStringValue( ISAPI_CI_DEFER_NONINDEXED_TRIMMING, _wcsDeferTrimming, 0, cwc );
    }

    BOOL fDeferTrimming = _idqFile.ParseDeferTrimming( _wcsDeferTrimming );
    ciGibDebugOut(( DEB_ITRACE, "CiDeferNonIndexedTrimming = '%ws'\n", _wcsDeferTrimming ));

    {
        // Set the property that says we don't want to enumerate
        aProp[cProp].dwPropertyID   = DBPROP_DEFERNONINDEXEDTRIMMING;
        aProp[cProp].dwOptions      = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus       = 0;         // Ignored
        aProp[cProp].colid          = dbcolNull;
        aProp[cProp].vValue.vt      = VT_BOOL;
        aProp[cProp].vValue.boolVal = fDeferTrimming ? VARIANT_TRUE : VARIANT_FALSE;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidQueryExt;

        cProp++;
    }

    if ( _idqFile.IsDontTimeout() )
    {
        // Set the property that says we don't want to timeout
        aProp[cProp].dwPropertyID = DBPROP_COMMANDTIMEOUT;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_I4;
        aProp[cProp].vValue.lVal  = 0;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidRowsetProps;

        cProp++;
    }

    Win4Assert( Variant.vt == VT_BOOL );
    Variant.boolVal = fDeferTrimming ? VARIANT_TRUE : VARIANT_FALSE;
    variableSet.SetVariable( ISAPI_CI_DEFER_NONINDEXED_TRIMMING, &Variant, 0 );

    //
    //  If this is a non-Sequential query, make it asynchronous
    //
    if (! IsSequential() )
    {
        // Set the property that says we want to use asynch. queries
        aProp[cProp].dwPropertyID = DBPROP_ROWSET_ASYNCH;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_I4;
        aProp[cProp].vValue.lVal  = DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION |
                                    DBPROPVAL_ASYNCH_RANDOMPOPULATION;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidRowsetProps;

        cProp++;
    }

    if ( cProp > 0 )
    {
        Win4Assert( cProp <= MAX_PROPS );

        ICommandProperties * pCmdProp = 0;
        sc = _pICommand->QueryInterface( IID_ICommandProperties,
                                         (void **)&pCmdProp );

        if (FAILED (sc) )
        {
            THROW( CException( QUERY_EXECUTE_FAILED ) );
        }

        sc = pCmdProp->SetProperties( cProp, aPropSet );
        pCmdProp->Release();

        if ( FAILED(sc) || DB_S_ERRORSOCCURRED == sc )
        {
            THROW( CException( QUERY_EXECUTE_FAILED ) );
        }
    }

    //
    //  Execute the query
    //

    sc = _pICommand->Execute( 0,            // No aggr
                              IsSequential() ? IID_IRowset : IID_IRowsetScroll,
                              0,            // disp params
                              0,            // # rowsets returned
                              (IUnknown **) &_pIRowset );

    if ( FAILED(sc) )
    {
        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        SCODE sc2 = GetOleDBErrorInfo(_pICommand,
                                   IID_ICommand,
                                   GetLocale(),
                                   eMostDetailedCIError,
                                   &ErrorInfo,
                                   (IErrorInfo **)xErrorInfo.GetQIPointer());
        // Post IErrorInfo only if we have a valid ptr to it.
        if (SUCCEEDED(sc2) && 0 != xErrorInfo.GetPointer())
        {
            sc = ErrorInfo.hrError;

            // Maybe the ICommand is stale because cisvc was stopped and
            // restarted -- purge it from the cache.

            TheICommandCache.Remove( _pICommand );
            _pICommand = 0;

            THROW( CPostedOleDBException(sc, eDefaultISAPIError, xErrorInfo.GetPointer()) );
        }
        else
        {
            // Maybe the ICommand is stale because cisvc was stopped and
            // restarted -- purge it from the cache.

            TheICommandCache.Remove( _pICommand );
            _pICommand = 0;

            THROW( CException(sc) );
        }
    }

    //
    //  Create an accessor
    //

    _pIAccessor = 0;

    sc = _pIRowset->QueryInterface( IID_IAccessor, (void **)&_pIAccessor);
    if ( FAILED( sc ) || _pIAccessor == 0 )
    {
        THROW( CException( DB_E_ERRORSOCCURRED ) );
    }

    ULONG cCols = _pDbColumns->Count();
    if ( cCols > MAX_QUERY_COLUMNS )
    {
        THROW( CException( DB_E_ERRORSOCCURRED ) );
    }

    sc = _pIAccessor->CreateAccessor( DBACCESSOR_ROWDATA,  // Type of access required
                                      cCols,               // # of bindings
                                      g_aDbBinding,        // Array of bindings
                                      0,                   // reserved
                                      &_hAccessor,
                                      0 );

    if ( FAILED( sc ) )
    {
        THROW( CException(sc) );
    }

    //
    //  Create some of the restriction specific variables.
    //

    //
    // Get _pIRowsetStatus interface
    //
    sc = _pIRowset->QueryInterface( IID_IRowsetQueryStatus,
                                    (void **) &_pIRowsetStatus );

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    Win4Assert( 0 != _pIRowsetStatus );

    //
    // Save the # of filtered documents for this catalog and get the
    // query status.
    //

    DWORD dwStatus = 0;
    DWORD cToFilter;
    DBCOUNTITEM cDen, cNum;
    DBCOUNTITEM iCur, cTotal;
    sc = _pIRowsetStatus->GetStatusEx( &dwStatus,
                                       &_cFilteredDocuments,
                                       &cToFilter,
                                       &cDen,
                                       &cNum,
                                       0,
                                       0,
                                       &iCur,
                                       &cTotal );

    if ( FAILED( sc ) )
    {
        THROW( CException(sc) );
    }

    propVariant.vt   = VT_BOOL;

    if ( QUERY_RELIABILITY_STATUS(dwStatus) &
        (STAT_CONTENT_OUT_OF_DATE | STAT_REFRESH_INCOMPLETE) )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query is out of date\n" ));
    }
    else
    {
        propVariant.boolVal = VARIANT_FALSE;
    }
    variableSet.SetVariable( ISAPI_CI_OUT_OF_DATE, &propVariant, 0 );

    if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_CONTENT_QUERY_INCOMPLETE )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query is incomplete\n" ));
    }
    else
    {
        propVariant.boolVal = VARIANT_FALSE;
    }
    variableSet.SetVariable( ISAPI_CI_QUERY_INCOMPLETE, &propVariant, 0 );

    if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_TIME_LIMIT_EXCEEDED )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query timed out\n" ));
    }
    else
    {
        propVariant.boolVal = VARIANT_FALSE;
    }
    variableSet.SetVariable( ISAPI_CI_QUERY_TIMEDOUT, &propVariant, 0 );

    //
    //  Set CiQueryTimeZone
    //
    TIME_ZONE_INFORMATION TimeZoneInformation;
    DWORD dwResult = GetTimeZoneInformation( &TimeZoneInformation );
    LPWSTR pwszTimeZoneName = 0;

    if ( TIME_ZONE_ID_DAYLIGHT == dwResult )
    {
        pwszTimeZoneName = TimeZoneInformation.DaylightName;
    }
    else if ( 0xFFFFFFFF == dwResult )
    {
#       if CIDBG == 1
           DWORD dwError = GetLastError();
           ciGibDebugOut(( DEB_ERROR, "Error %d from GetTimeZoneInformation.\n", dwError ));
           THROW(CException( HRESULT_FROM_WIN32(dwError) ));
#       else
           THROW( CException() );
#       endif
    }
    else
    {
        pwszTimeZoneName = TimeZoneInformation.StandardName;
    }

    ULONG cchQueryTimeZone = wcslen( pwszTimeZoneName );
    _wcsQueryTimeZone = new WCHAR[ cchQueryTimeZone + 1 ];
    RtlCopyMemory( _wcsQueryTimeZone,
                   pwszTimeZoneName,
                   (cchQueryTimeZone+1) * sizeof(WCHAR) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::GetQueryResultsIterator - private
//
//  Synopsis:   Builds a CBaseQueryResultsIter which can subsequently be used
//              to send the query results back to the web browser. All
//              per-browser data relative to the query is kept in the iterator.
//
//  Returns:    [CBaseQueryResultsIter] - a sequential or non-sequential
//              iterator depending on the paramaters requested in the HTX
//              file.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CBaseQueryResultsIter * CWQueryItem::GetQueryResultsIterator( COutputFormat & outputFormat )
{
    CBaseQueryResultsIter *pIter;

    //
    //  Setup the formatting for the vector types
    //

    _idqFile.GetVectorFormatting( outputFormat );

    if ( IsSequential() )
    {
        Win4Assert( _lNextRecordNumber > 0 );
        pIter = new CSeqQueryResultsIter( *this,
                                          _pIRowset,
                                          _hAccessor,
                                          _pDbColumns->Count(),
                                          _lNextRecordNumber-1 );

        ciGibDebugOut(( DEB_ITRACE, "Using a sequential iterator\n" ));
    }
    else
    {
        IRowsetScroll *pIRowsetScroll = 0;
        HRESULT sc = _pIRowset->QueryInterface(IID_IRowsetScroll, (void **) &pIRowsetScroll);

        if ( FAILED( sc )  )
        {
            THROW( CException(sc) );
        }

        XInterface<IRowsetScroll> xIRowsetScroll(pIRowsetScroll);
        pIter = new CQueryResultsIter( *this,
                                       pIRowsetScroll,
                                       _hAccessor,
                                       _pDbColumns->Count() );

        xIRowsetScroll.Acquire();

        ciGibDebugOut(( DEB_ITRACE, "Using a NON-sequential iterator\n" ));
    }

    return pIter;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::OutputQueryResults - public
//
//  Arguments:  [variableSet]  - list of browser-supplied replaceable parameters
//              [outputFormat] - format of numbers & dates
//              [vString]      - destination buffer for output results
//
//  Synopsis:   Using the parameters passed, build an iterator to walk the
//              query results and buffer output into the vString.
//
//  History:    18-Jan-96   DwightKr    Created
//              11-Jun-97   KyleP       Use web server from output format
//
//----------------------------------------------------------------------------

void CWQueryItem::OutputQueryResults( CVariableSet & variableSet,
                                      COutputFormat & outputFormat,
                                      CVirtualString & vString )
{
    //
    //  Build the query results iterator based on the parameters passed in.
    //

    CBaseQueryResultsIter *pIter = GetQueryResultsIterator( outputFormat );
    XPtr<CBaseQueryResultsIter> iter(pIter);

    iter->Init( variableSet, outputFormat );

    UpdateQueryStatus( variableSet );

    //
    //  Build the HTML pages in three sections:  first the header
    //  section (evenything before the <%begindetail%>), next the detail
    //  section (everything between the <%begindetail%> and <%enddetail%>),
    //  and finally the footer section (everything after the
    //  <%enddetail%> section).
    //

    //
    //  Output the header section.
    //

    _htxFile.GetHeader( vString, variableSet, outputFormat ) ;

    LONG lCurrentRecordNumber = iter->GetFirstRecordNumber();

    if ( _htxFile.DoesDetailSectionExist() )
    {
        //
        //  Output the detail section
        //
        ULONG cCols = iter->GetColumnCount();
        XArray<CVariable *> xVariables( cCols );

        for ( ULONG i=0; i<cCols; i++ )
        {
            xVariables[i] = variableSet.SetVariable( _awcsColumns.Get(i), 0, 0 );
            Win4Assert( 0 != xVariables[i] );
        }

        PROPVARIANT VariantRecordNumber;
        VariantRecordNumber.vt = VT_I4;

        CVariable * pvarRecordNumber = variableSet.SetVariable( ISAPI_CI_CURRENT_RECORD_NUMBER, 0, 0 );
        Win4Assert( 0 != pvarRecordNumber );

        //
        //  Execute the detail section for each row/record in the query results
        //
        for ( ;
             !iter->AtEnd();
              iter->Next(), lCurrentRecordNumber++ )
        {
            COutputColumn * pColumns = iter->GetRowData();

            //
            //  Update the replaceable parameters for each of the columns
            //  in this row.
            //

            for ( i = 0; i < cCols; i++ )
                xVariables[i]->FastSetValue( pColumns[i].GetVariant() );

            VariantRecordNumber.lVal = lCurrentRecordNumber;
            pvarRecordNumber->FastSetValue( &VariantRecordNumber );

            _htxFile.GetDetailSection( vString, variableSet, outputFormat );
        }

        //
        //  The query output columns are no longer defined outside of the
        //  DETAIL section.  Delete these variables here so that any reference
        //  to them will return a NULL string.
        //
        for ( i=0; i<cCols; i++ )
        {
            variableSet.Delete( xVariables[i] );
        }
    }

    //
    //  If we couldn't get the first record #, then the current page #
    //  should be set to 0.
    //

    if ( iter->GetFirstRecordNumber() == lCurrentRecordNumber )
    {
        PROPVARIANT Variant;
        Variant.vt   = VT_I4;
        Variant.lVal = 0;
        variableSet.SetVariable( ISAPI_CI_CURRENT_PAGE_NUMBER, &Variant, 0 );
    }

    //
    //  Output the footer section.
    //

    _htxFile.GetFooter( vString, variableSet, outputFormat );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::UpdateQueryStatus - public
//
//  Synopsis:   Updates variables relating to query status.
//
//  Arguments:  [variableSet] - VariableSet to be updated
//
//  Returns:    Nothing
//
//  Notes:      These are post-execution checks that can change an up-to-date
//              query to an out-of-date query, but not the reverse.  The
//              following variables are set:
//                  CiOutOfDate
//                  CiQueryIncomplete
//                  CiQueryTimedOut
//
//  History:    96 Apr 16    AlanW      Created
//
//----------------------------------------------------------------------------

void CWQueryItem::UpdateQueryStatus( CVariableSet & variableSet )
{
    Win4Assert( 0 != _pIRowsetStatus );

    DWORD dwStatus = 0;
    DWORD cDocsFiltered, cToFilter;
    DBCOUNTITEM cDen, cNum;
    DBCOUNTITEM iCur, cTotal;
    SCODE sc = _pIRowsetStatus->GetStatusEx( &dwStatus,
                                             &cDocsFiltered,
                                             &cToFilter,
                                             &cDen,
                                             &cNum,
                                             0,
                                             0,
                                             &iCur,
                                             &cTotal );

    if ( FAILED( sc ) )
        THROW( CException(sc) );

    PROPVARIANT propVariant;
    propVariant.vt   = VT_BOOL;

    BOOL fUpToDate = ( ( cDocsFiltered == _cFilteredDocuments ) &&
                       ( 0 == cToFilter ) );

    if (( QUERY_RELIABILITY_STATUS(dwStatus) &
          (STAT_CONTENT_OUT_OF_DATE | STAT_REFRESH_INCOMPLETE) ) ||
         ! fUpToDate )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query is out of date\n" ));
        variableSet.SetVariable( ISAPI_CI_OUT_OF_DATE, &propVariant, 0 );
    }

    if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_CONTENT_QUERY_INCOMPLETE )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query is incomplete\n" ));
        variableSet.SetVariable( ISAPI_CI_QUERY_INCOMPLETE, &propVariant, 0 );
    }

    if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_TIME_LIMIT_EXCEEDED )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query timed out\n" ));
        variableSet.SetVariable( ISAPI_CI_QUERY_TIMEDOUT, &propVariant, 0 );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::IsQueryDone - public
//
//  History:    96-Mar-01   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CWQueryItem::IsQueryDone()
{
    Win4Assert( 0 != _pIRowsetStatus );

    DWORD dwStatus = 0;
    SCODE sc = _pIRowsetStatus->GetStatus( &dwStatus );
    if ( FAILED( sc ) )
    {
        THROW( CException(sc) );
    }

    BOOL fQueryDone = FALSE;

    if ( QUERY_FILL_STATUS(dwStatus) == STAT_DONE ||
         QUERY_FILL_STATUS(dwStatus) == STAT_ERROR)
    {
        fQueryDone = TRUE;
    }

    return fQueryDone;
}



#if (DBG == 1)
//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::LokDump - public
//
//  Arguments:  [string] - buffer to send results to
//
//  Synopsis:   Dumps the state of the query
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryItem::LokDump( CVirtualString & string,
                           CVariableSet * pVariableSet,
                           COutputFormat * pOutputFormat )
{
    if ( IsSequential() )
    {
        string.StrCat( L"<I>Sequential cursor</I><BR>\n" );
    }
    else
    {
        string.StrCat( L"<I>Non-Sequential cursor</I><BR>\n" );
    }

    if ( 0 != pVariableSet )
        pVariableSet->Dump( string, *pOutputFormat );

    WCHAR wcsBuffer[80];
    LONG cwcBuffer = swprintf( wcsBuffer, L"Refcount=%d<BR>\n", _refCount );
    string.StrCat( wcsBuffer, cwcBuffer );

    cwcBuffer = swprintf( wcsBuffer, L"NextRecordNumber=%d<BR>\n", _lNextRecordNumber );
    string.StrCat( wcsBuffer, cwcBuffer );

    cwcBuffer = swprintf( wcsBuffer, L"SequenceNumber=%d<BR>\n", _ulSequenceNumber );
    string.StrCat( wcsBuffer, cwcBuffer );

    cwcBuffer = swprintf( wcsBuffer, L"IDQ File name=" );
    string.StrCat( wcsBuffer, cwcBuffer );
    string.StrCat( _idqFile.GetIDQFileName() );
    string.StrCat( L"<BR>\n" );

    cwcBuffer = swprintf( wcsBuffer, L"# documents filtered when query created=%d<BR>\n", _cFilteredDocuments );
    string.StrCat( wcsBuffer, cwcBuffer );

    string.StrCat( L"<P>\n" );
}
#endif // DBG


//+---------------------------------------------------------------------------
//
//  Member:     CWPendingQueryItem::CWPendingQueryItem - public constructor
//
//  Synposis:   Builds a item for use to track an asynchronous query.
//
//  Arguments:  [queryItem]    - query item that is pending
//              [outputFormat] - output format supplied by the browser
//              [variableSet]  - browser supplied variables
//
//  History:    96-Mar-01   DwightKr    Created
//
//----------------------------------------------------------------------------

CWPendingQueryItem::CWPendingQueryItem( XPtr<CWQueryItem> & queryItem,
                                        XPtr<COutputFormat> & outputFormat,
                                        XPtr<CVariableSet> & variableSet ) :

                    _pQueryItem(queryItem.GetPointer()),
                    _pOutputFormat(outputFormat.GetPointer()),
                    _pVariableSet(variableSet.GetPointer())
{
    queryItem.Acquire();
    outputFormat.Acquire();
    variableSet.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWPendingQueryItem::~CWPendingQueryItem - public destructor
//
//  Synposis:   Destrolys a query item
//
//  History:    96-Mar-01   DwightKr    Created
//              96-Nov-25   dlee        added header, moved out of .hxx
//
//----------------------------------------------------------------------------

CWPendingQueryItem::~CWPendingQueryItem()
{
    Win4Assert( 0 != _pOutputFormat );

    if ( _pOutputFormat->IsValid() )
    {
        TheWebQueryCache.DecrementActiveRequests();
        ciGibDebugOut(( DEB_ITRACE, "~cwpendingqueryitem releasing session hse %d http %d\n",
                        HSE_STATUS_SUCCESS, HTTP_STATUS_OK ));

        //
        // Processing the query may not have been successful, but if so
        // we wrote an error message, so from an isapi standpoint this was
        // a success.
        //

        _pOutputFormat->SetHttpStatus( HTTP_STATUS_OK );
        _pOutputFormat->ReleaseSession( HSE_STATUS_SUCCESS );
    }

    delete _pQueryItem;
    delete _pOutputFormat;
    delete _pVariableSet;
}


#if (DBG == 1)
//+---------------------------------------------------------------------------
//
//  Member:     CWPendingQueryItem::LokDump - public
//
//  Arguments:  [string] - buffer to send results to
//
//  Synopsis:   Dumps the state of a pending query
//
//  History:    96 Mar 20   Alanw    Created
//
//----------------------------------------------------------------------------
void CWPendingQueryItem::LokDump( CVirtualString & string )
{
    if ( IsQueryDone() )
    {
        string.StrCat( L"<I>Completed query, </I>" );
    }
    else
    {
        string.StrCat( L"<I>Executing query, </I>" );
    }
    _pQueryItem->LokDump( string, _pVariableSet, _pOutputFormat );
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\variable.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1992-2000.
//
//  File:       variable.cxx
//
//  Contents:   Used to replace variables
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

void RenderSafeArray(
    VARTYPE          vt,
    SAFEARRAY *      psa,
    COutputFormat &  outputFormat,
    CVirtualString & vString,
    BOOL             fFormatted );

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::CVariable - public constructor
//
//  Synopsis:   Builds a single replaceable variable based in a propVariant
//
//  Arguments:  [wcsName]  - friendly name for the variable
//              [pVariant] - the variable's value
//              [ulFlags]  - all flags associated with this variable, for
//                           now this indicates if this variable requires
//                           a IRowsetScroll to access its value.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CVariable::CVariable( WCHAR const * wcsName,
                      PROPVARIANT const * pVariant,
                      ULONG ulFlags ) :
                      _wcsName(0),
                      _wcsRAWValue(0),
                      _cwcRAWValue(0),
                      _eNumType( eNotANumber ),
                      _ulFlags(ulFlags),
                      _pNext(0),
                      _pBack(0)
{
    Win4Assert( wcsName != 0 );

    ULONG cwcName = wcslen(wcsName) + 1;
    _wcsName = new WCHAR[ cwcName ];
    RtlCopyMemory( _wcsName, wcsName, cwcName * sizeof(WCHAR) );

    _variant.vt = VT_EMPTY;
    _variant.pwszVal = 0;

    if ( 0 != pVariant )
    {
        // SetValue cannot raise

        SetValue( pVariant, ulFlags );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::CVariable - public copy constructor
//
//  Synopsis:   Builds a single replaceable variable based in a propVariant
//
//  Arguments:  [variable] - the variable to copy
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CVariable::CVariable( const CVariable & variable ) :
                      _wcsName(0),
                      _cwcRAWValue(0),
                      _eNumType( variable._eNumType ),
                      _ulFlags(0),
                      _pNext(0)

{
    ULONG cwcName = wcslen(variable._wcsName) + 1;

    _wcsName = new WCHAR[ cwcName ];

    RtlCopyMemory( _wcsName, variable._wcsName, cwcName * sizeof(WCHAR) );

    _ulFlags  = variable._ulFlags;
    _variant  = variable._variant;

    if ( VT_LPWSTR == variable._variant.vt )
    {
        _cwcRAWValue = variable._cwcRAWValue;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariable::~CVariable - public destructor
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CVariable::~CVariable()
{
    if ( (_ulFlags & eParamOwnsVariantMemory) != 0 )
    {
        delete _variant.pwszVal;
    }

    //
    //  If we have a RAW string that is not part of the variant, and is
    //  not pointing to the in-line number buffer, delete it.  It's probably
    //  an ASCII string we've converted to WCHAR.
    //
    if ( _wcsRAWValue &&
         _wcsRAWValue != _wcsNumberValue &&
         _wcsRAWValue != _variant.pwszVal )
    {
        delete _wcsRAWValue;
    }

    delete _wcsName;

    if ( 0 != _pNext )
        delete _pNext;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::SetValue - public
//
//  Synopsis:   An assignment operator; allows the value of a variable to
//              be changed.
//
//  Arguments:  [pVariant] -  new value for this variable
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariable::SetValue( PROPVARIANT const * pVariant, ULONG ulFlags )
{
    //
    //  If we've stored a string equivalent for the old value, then
    //  delete it now.
    //
    if ( _wcsRAWValue &&
         _wcsRAWValue != _wcsNumberValue &&
         _wcsRAWValue != _variant.pwszVal )
    {
        delete _wcsRAWValue;
        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
        _eNumType = eNotANumber;
    }

    if ( (_ulFlags & eParamOwnsVariantMemory) != 0 )
    {
        delete _variant.pwszVal;
        _variant.pwszVal = 0;

        _ulFlags &= ~eParamOwnsVariantMemory;
    }

    if ( 0 != pVariant )
        _variant  = *pVariant;
    else
    {
        _variant.vt = VT_EMPTY;
        _variant.pwszVal = 0; // retentive
    }

    //
    //  If its a WCHAR string, we already have a pointer to its RAW value.
    //
    if ( (VT_LPWSTR == _variant.vt) && (0 != _variant.pwszVal) )
    {
        _wcsRAWValue = _variant.pwszVal;
        _cwcRAWValue = wcslen(_wcsRAWValue);
    }
    else
    {
         _wcsRAWValue = 0;
         _cwcRAWValue = 0;
    }

    _ulFlags |= ulFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::FastSetValue - public
//
//  Synopsis:   Special version of SetValue that can be faster because it
//              knows that the variable can't own variant memory, that
//              the variant is non-0, that the flags are 0, and that variant
//              wide strings are non-zero.
//
//  Arguments:  [pVariant] -  new value for this variable
//
//  History:    96/Apr/05   dlee    Created.
//
//----------------------------------------------------------------------------

void CVariable::FastSetValue( PROPVARIANT const * pVariant )
{
    //
    //  If we've stored a string equivalent for the old value, then
    //  delete it now.
    //

    if ( ( _wcsRAWValue != _wcsNumberValue ) &&
         ( _wcsRAWValue != _variant.pwszVal ) )
    {
        delete _wcsRAWValue;
        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
    }
    _eNumType = eNotANumber;

    Win4Assert( (_ulFlags & eParamOwnsVariantMemory) == 0 );
    Win4Assert( 0 != pVariant );
    _variant  = *pVariant;

    if ( VT_LPWSTR == _variant.vt )
    {
        // The caller of FastSetValue can't pass a 0 string variant

        Win4Assert( 0 != _variant.pwszVal );
        _wcsRAWValue = _variant.pwszVal;
        _cwcRAWValue = wcslen(_wcsRAWValue);
    }
    else
    {
         _wcsRAWValue = 0;
         _cwcRAWValue = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::SetValue - public
//
//  Synopsis:   A assignment operator; allows the value of a variable to
//              be changed.  Ownership of the string is transferred to this
//              function
//
//  Arguments:  [wcsValue] -  new value for this variable
//              [cwcValue] -  length of new value string
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariable::SetValue( XPtrST<WCHAR> & wcsValue, ULONG cwcValue )
{
    Win4Assert( VT_LPWSTR == _variant.vt );

    //
    //  If we've stored a string equivalent for the old value, then
    //  delete it now.
    //
    if ( _wcsRAWValue &&
         _wcsRAWValue != _wcsNumberValue &&
         _wcsRAWValue != _variant.pwszVal )
    {
        delete _wcsRAWValue;
        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
        _eNumType = eNotANumber;
    }

    if ( (_ulFlags & eParamOwnsVariantMemory) != 0 )
    {
        delete _variant.pwszVal;
        _variant.pwszVal = 0;
    }

    _ulFlags |= eParamOwnsVariantMemory;

    _wcsRAWValue = wcsValue.Acquire();
    _cwcRAWValue = cwcValue;
}


// Maximum length of a floating point value string
// Big enough for a 1e308 + 9 decimal places + sign + slop

//  Floating point precision.
//  +1 because the numbers in float.h seem to be too small by one digit.

const unsigned fltPrec = FLT_DIG+1;
const unsigned dblPrec = DBL_DIG+1;

//+---------------------------------------------------------------------------
//
//  Function:   SARenderElementFormatted
//
//  Synopsis:   Appends the formatted string form a safearray element to
//              a virtual string.
//              Only the subset of types that are formatted differently
//              when "formatted" vs "raw" are handled in this function.
//
//  Arguments:  [outputFormat] -- The output format to use
//              [vString]      -- Where the result is appended
//              [vt]           -- Type of the element
//              [pv]           -- Pointer to the element
//
//  Notes:      I8 and UI8 aren't allowed in safearrays in NT 5, but they
//              will be someday.
//
//  History:    9-Jun-98   dlee      Created
//
//----------------------------------------------------------------------------

void SARenderElementFormatted(
    COutputFormat &  outputFormat,
    CVirtualString & vString,
    VARTYPE          vt,
    void *           pv )
{
    ciGibDebugOut(( DEB_ITRACE, "vt %#x, pv %#x\n", vt, pv ));

    // Recurse if we have a nested VT_ARRAY in an array element.

    if ( VT_ARRAY & vt )
    {
        SAFEARRAY *psa = *(SAFEARRAY **) pv;
        RenderSafeArray( vt & ~VT_ARRAY, psa, outputFormat, vString, TRUE );
        return;
    }

    WCHAR awcTmp[ maxFloatSize ];
    const ULONG cwcTmp = sizeof awcTmp / sizeof awcTmp[0];
    ULONG cwc = 0;

    switch ( vt )
    {
        case VT_UI1:
        {
            cwc = outputFormat.FormatNumber( (ULONG) * (BYTE *) pv,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_I1:
        {
            cwc = outputFormat.FormatNumber( (LONG) * (signed char *) pv,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_UI2:
        {
            USHORT us;
            RtlCopyMemory( &us, pv, sizeof us );
            cwc = outputFormat.FormatNumber( (ULONG) us,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_I2:
        {
            SHORT s;
            RtlCopyMemory( &s, pv, sizeof s );
            cwc = outputFormat.FormatNumber( (LONG) s,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_UI4:
        case VT_UINT:
        {
            ULONG ul;
            RtlCopyMemory( &ul, pv, sizeof ul );
            cwc = outputFormat.FormatNumber( ul,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_I4:
        case VT_ERROR:
        case VT_INT:
        {
            LONG l;
            RtlCopyMemory( &l, pv, sizeof l );
            cwc = outputFormat.FormatNumber( l,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_UI8:
        {
            unsigned __int64 ui;
            RtlCopyMemory( &ui, pv, sizeof ui );
            cwc = outputFormat.FormatNumber( ui,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_I8:
        {
            __int64 i;
            RtlCopyMemory( &i, pv, sizeof i );
            cwc = outputFormat.FormatNumber( i,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_R4:
        {
            float f;
            RtlCopyMemory( &f, pv, sizeof f );
            cwc = outputFormat.FormatFloat( f,
                                            fltPrec,
                                            awcTmp,
                                            cwcTmp );
            break;
        }
        case VT_R8:
        {
            double d;
            RtlCopyMemory( &d, pv, sizeof d );
            cwc = outputFormat.FormatFloat( d,
                                            dblPrec,
                                            awcTmp,
                                            cwcTmp );
            break;
        }
        case VT_DECIMAL:
        {
            double d;
            VarR8FromDec( (DECIMAL *) pv, &d );
            cwc = outputFormat.FormatFloat( d,
                                            dblPrec,
                                            awcTmp,
                                            cwcTmp );
            break;
        }
        case VT_CY:
        {
            double d;
            VarR8FromCy( * (CY *) pv, &d );
            cwc = outputFormat.FormatFloat( d,
                                            dblPrec,
                                            awcTmp,
                                            cwcTmp );
            break;
        }
        case VT_VARIANT:
        {
            PROPVARIANT & Var = * (PROPVARIANT *) pv;
            SARenderElementFormatted( outputFormat, vString, Var.vt, & Var.lVal );
            break;
        }
        default :
        {
            ciGibDebugOut(( DEB_ERROR, "unexpected numeric sa element type %#x\n", vt ));
            Win4Assert( !"unexpected numeric safearray element type" );
            break;
        }
    }

    vString.StrCat( awcTmp, cwc );
} //SARenderElementFormatted

//+---------------------------------------------------------------------------
//
//  Function:   SARenderElementRaw
//
//  Synopsis:   Appends the "raw" string form a safearray element to
//              a virtual string.  Numbers are raw when they don't have
//              formatting like commas.
//
//  Arguments:  [outputFormat] -- The output format to use
//              [vString]      -- Where the result is appended
//              [vt]           -- Type of the element
//              [pv]           -- Pointer to the element
//
//  Notes:      I8 and UI8 aren't allowed in safearrays in NT 5, but they
//              will be someday.
//
//  History:    9-Jun-98   dlee      Created
//
//----------------------------------------------------------------------------

void SARenderElementRaw(
    COutputFormat &  outputFormat,
    CVirtualString & vString,
    VARTYPE          vt,
    void *           pv )
{
    ciGibDebugOut(( DEB_ITRACE, "vt %#x, pv %#x\n", vt, pv ));

    // Recurse if we have a nested VT_ARRAY in an array element.

    if ( VT_ARRAY & vt )
    {
        SAFEARRAY *psa = *(SAFEARRAY **) pv;
        RenderSafeArray( vt & ~VT_ARRAY, psa, outputFormat, vString, FALSE );
        return;
    }

    WCHAR awcTmp[ maxFloatSize ];
    const ULONG cwcTmp = sizeof awcTmp / sizeof awcTmp[0];
    ULONG cwc = 0;

    switch ( vt )
    {
        case VT_EMPTY:
        case VT_NULL:
        {
            break;
        }
        case VT_BSTR:
        {
            BSTR bstr = *(BSTR *) pv;
            vString.StrCat( bstr );
            break;
        }
        case VT_BOOL:
        {
            VARIANT_BOOL vb;
            RtlCopyMemory( &vb, pv, sizeof vb );
            wcscpy( awcTmp, ( VARIANT_FALSE == vb ) ? L"FALSE" : L"TRUE" );
            cwc = wcslen( awcTmp);
            break;
        }
        case VT_DATE:
        {
            SYSTEMTIME stUTC;
            DATE date;
            RtlCopyMemory( &date, pv, sizeof date );
            if ( VariantTimeToSystemTime( date, &stUTC ) )
                cwc = outputFormat.FormatDateTime( stUTC,
                                                   awcTmp,
                                                   cwcTmp );
            break;
        }
        case VT_UI1:
        {
            IDQ_ultow( (ULONG) * (BYTE *) pv, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_I1:
        {
            IDQ_ltow( (LONG) * (signed char *) pv, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_UI2:
        {
            USHORT us;
            RtlCopyMemory( &us, pv, sizeof us );
            IDQ_ultow( (ULONG) us, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_I2:
        {
            SHORT s;
            RtlCopyMemory( &s, pv, sizeof s );
            IDQ_ltow( (LONG) s, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_UI4:
        case VT_UINT:
        {
            ULONG ul;
            RtlCopyMemory( &ul, pv, sizeof ul );
            IDQ_ultow( ul, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_I4:
        case VT_ERROR:
        case VT_INT:
        {
            LONG l;
            RtlCopyMemory( &l, pv, sizeof l );
            IDQ_ltow( l, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_UI8:
        {
            unsigned __int64 ui;
            RtlCopyMemory( &ui, pv, sizeof ui );
            IDQ_ulltow( ui, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_I8:
        {
            __int64 i;
            RtlCopyMemory( &i, pv, sizeof i );
            IDQ_lltow( i, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_R4:
        {
            float f;
            RtlCopyMemory( &f, pv, sizeof f );
            cwc = outputFormat.FormatFloatRaw( f,
                                               fltPrec,
                                               awcTmp,
                                               cwcTmp );
            break;
        }
        case VT_R8:
        {
            double d;
            RtlCopyMemory( &d, pv, sizeof d );
            cwc = outputFormat.FormatFloatRaw( d,
                                               dblPrec,
                                               awcTmp,
                                               cwcTmp );
            break;
        }
        case VT_DECIMAL:
        {
            double d;
            VarR8FromDec( (DECIMAL *) pv, &d );
            cwc = outputFormat.FormatFloatRaw( d,
                                               dblPrec,
                                               awcTmp,
                                               cwcTmp );
            break;
        }
        case VT_CY:
        {
            double d;
            VarR8FromCy( * (CY *) pv, &d );
            cwc = outputFormat.FormatFloatRaw( d,
                                               dblPrec,
                                               awcTmp,
                                               cwcTmp );
            break;
        }
        case VT_VARIANT:
        {
            PROPVARIANT & Var = * (PROPVARIANT *) pv;
            SARenderElementRaw( outputFormat, vString, Var.vt, & Var.lVal );
            break;
        }
        default :
        {
            ciGibDebugOut(( DEB_ERROR, "unexpected sa element type %#x\n", vt ));
            Win4Assert( !"unexpected safearray element type" );
            break;
        }
    }

    vString.StrCat( awcTmp, cwc );
} //SARenderElementRaw

//+---------------------------------------------------------------------------
//
//  Function:   GetVectorFormatting
//
//  Synopsis:   Retrieves the vector formatting strings for a given type.
//              Only safearray element datatypes are handled here.
//
//  Arguments:  [pwcPre]  -- Returns the vector prefix string
//              [pwcSep]  -- Returns the vector separator string
//              [pwcSuf]  -- Returns the vector suffix string
//
//  History:    9-Jun-98   dlee      Created
//
//----------------------------------------------------------------------------

void GetVectorFormatting(
    WCHAR const * & pwcPre,
    WCHAR const * & pwcSep,
    WCHAR const * & pwcSuf,
    VARTYPE         vt,
    COutputFormat & outputFormat )
{
    Win4Assert( 0 == ( vt & VT_ARRAY ) );

    switch ( vt )
    {
        case VT_CY:
            pwcPre = outputFormat.GetCurrencyVectorPrefix();
            pwcSep = outputFormat.GetCurrencyVectorSeparator();
            pwcSuf = outputFormat.GetCurrencyVectorSuffix();
            break;
        case VT_DATE:
            pwcPre = outputFormat.GetDateVectorPrefix();
            pwcSep = outputFormat.GetDateVectorSeparator();
            pwcSuf = outputFormat.GetDateVectorSuffix();
            break;
        case VT_BOOL:
            pwcPre = outputFormat.GetBoolVectorPrefix();
            pwcSep = outputFormat.GetBoolVectorSeparator();
            pwcSuf = outputFormat.GetBoolVectorSuffix();
            break;
        case VT_BSTR:
            pwcPre = outputFormat.GetStringVectorPrefix();
            pwcSep = outputFormat.GetStringVectorSeparator();
            pwcSuf = outputFormat.GetStringVectorSuffix();
            break;
        case VT_VARIANT:
        case VT_EMPTY:
        case VT_NULL:
        case VT_I1:
        case VT_UI1:
        case VT_I2:
        case VT_UI2:
        case VT_I4:
        case VT_INT:
        case VT_UI4:
        case VT_UINT:
        case VT_I8:
        case VT_UI8:
        case VT_R4:
        case VT_R8:
        case VT_DECIMAL:
        case VT_ERROR:
            pwcPre = outputFormat.GetNumberVectorPrefix();
            pwcSep = outputFormat.GetNumberVectorSeparator();
            pwcSuf = outputFormat.GetNumberVectorSuffix();
            break;
        default:
            ciGibDebugOut(( DEB_ERROR, "GetVectorFormatting unknown type %#x\n", vt ));
            Win4Assert( !"GetVectorFormatting doesn't support type" );
            break;
    }
} //GetVectorFormatting

//+---------------------------------------------------------------------------
//
//  Function:   RenderSafeArray
//
//  Synopsis:   Appends the string form of a safearray to a virtual string.
//
//  Arguments:  [vt]           -- Datatype of the safearray, without VT_ARRAY
//              [psa]          -- The safearray to format
//              [outputFormat] -- How to render the result
//              [vString]      -- The result is appended here
//              [fFormatted]   -- If TRUE, formatted, otherwise raw
//
//  History:    9-Jun-98   dlee      Created
//
//----------------------------------------------------------------------------

void RenderSafeArray(
    VARTYPE          vt,
    SAFEARRAY *      psa,
    COutputFormat &  outputFormat,
    CVirtualString & vString,
    BOOL             fFormatted )
{
    Win4Assert( 0 == ( vt & VT_ARRAY ) );

    //
    // Get the array prefix, separator, and suffix
    //

    WCHAR const * pwcPre;
    WCHAR const * pwcSep;
    WCHAR const * pwcSuf;
    GetVectorFormatting( pwcPre, pwcSep, pwcSuf, vt, outputFormat );

    //
    // Get the dimensions of the array
    //

    CDynArrayInPlace<WCHAR> xOut;
    UINT cDim = SafeArrayGetDim( psa );
    if ( 0 == cDim )
        return;

    XArray<LONG> xDim( cDim );
    XArray<LONG> xLo( cDim );
    XArray<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        SCODE sc = SafeArrayGetLBound( psa, iDim + 1, &xLo[iDim] );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        xDim[ iDim ] = xLo[ iDim ];

        sc = SafeArrayGetUBound( psa, iDim + 1, &xUp[iDim] );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        ciGibDebugOut(( DEB_ITRACE, "dim %d, lo %d, up %d\n",
                        iDim, xLo[iDim], xUp[iDim] ));

        vString.StrCat( pwcPre );
    }

    //
    // Slog through the array
    //

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone )
    {
        // Inter-element formatting if not the first element

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            vString.StrCat( pwcSep );

        // Get the element and render it

        void *pv;
        SCODE sc = SafeArrayPtrOfIndex( psa, xDim.GetPointer(), &pv );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        if ( fFormatted )
            SARenderElementFormatted( outputFormat, vString, vt, pv );
        else
            SARenderElementRaw( outputFormat, vString, vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            vString.StrCat( pwcSuf );

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            vString.StrCat( pwcPre );
    }
} //RenderSafeArray

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::GetStringValueFormattedRAW - public
//
//  Synopsis:   Not all VT types are strings.  Those which are not strings
//              have a string equivalent generated and stored for reuse.
//
//  Arguments:  [outputFormat] - contains formatting information for numbers
//
//  Returns:    A pointer to a string representation of the variable's value.
//              Numbers are formatted.
//
//  History:    26-Aug-96   KyleP       Created (from GetStringValueRAW)
//
//----------------------------------------------------------------------------

WCHAR * CVariable::GetStringValueFormattedRAW( COutputFormat & outputFormat,
                                               ULONG & cwcValue )
{
    Win4Assert( !(_wcsRAWValue == 0 && _cwcRAWValue != 0) );

    //
    // Did we have a real raw value last time?
    //

    if ( _wcsRAWValue && _eNumType == eRawNumber )
    {
        if ( _wcsRAWValue != _wcsNumberValue && _wcsRAWValue != _variant.pwszVal )
            delete _wcsRAWValue;

        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
    }

    if ( 0 == _wcsRAWValue )
    {
        switch ( _variant.vt )
        {
            case VT_UI1:
                _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.bVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_I1:
                _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.cVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_UI2:
                _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.uiVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_I2:
                _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.iVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_UI4:
            case VT_UINT:
                _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.ulVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_I4:
            case VT_INT:
            case VT_ERROR:
                _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.lVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_UI8:
                _cwcRAWValue = outputFormat.FormatNumber( _variant.uhVal.QuadPart,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_I8:
                _cwcRAWValue = outputFormat.FormatNumber( _variant.hVal.QuadPart,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_R4:
            {
                WCHAR awchOutput[maxFloatSize];

                _cwcRAWValue = outputFormat.FormatFloat( _variant.fltVal,
                                                         fltPrec,
                                                         awchOutput,
                                                         maxFloatSize );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awchOutput, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eFormattedNumber;
                break;
            }

            case VT_R8:
            case VT_DECIMAL:
            {
                double dblValue = _variant.dblVal;
                if ( VT_DECIMAL == _variant.vt )
                    VarR8FromDec( &_variant.decVal, &dblValue );

                // Big enough for a 1e308 + 9 decimal places + sign

                WCHAR awchOutput[maxFloatSize];

                _cwcRAWValue = outputFormat.FormatFloat( dblValue,
                                                         dblPrec,
                                                         awchOutput,
                                                         maxFloatSize );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awchOutput, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eFormattedNumber;
                break;
            }

            case VT_CY:
                _cwcRAWValue = outputFormat.FormatCurrency( _variant.cyVal,
                                                            _wcsNumberValue,
                                                            sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_UI1 | VT_VECTOR:
            case VT_I1 | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caub.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_UI1 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.caub.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else
                        _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.cac.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_I2 | VT_VECTOR:
            case VT_UI2 | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caui.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_UI2 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.caui.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else
                        _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.cai.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_R4 | VT_VECTOR:
            case VT_I4 | VT_VECTOR:
            case VT_UI4 | VT_VECTOR:
            case VT_ERROR | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caul.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_R4 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatFloat( _variant.caflt.pElems[iValue],
                                                                 fltPrec,
                                                                 _wcsNumberValue,
                                                                 sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else if ( (VT_UI4 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( _variant.caul.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else
                        _cwcRAWValue = outputFormat.FormatNumber( _variant.cal.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_I8 | VT_VECTOR:
            case VT_UI8 | VT_VECTOR:
            case VT_R8 | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cadbl.cElems;
                      iValue++
                    )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_I8 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( (_int64) _variant.cah.pElems[iValue].QuadPart,
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else if ( (VT_UI8 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( (unsigned _int64) _variant.cauh.pElems[iValue].QuadPart,
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else
                        _cwcRAWValue = outputFormat.FormatFloat( _variant.cadbl.pElems[iValue],
                                                                 dblPrec,
                                                                 _wcsNumberValue,
                                                                 sizeof(_wcsNumberValue) / sizeof(WCHAR) );

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_CY | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetCurrencyVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cacy.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetCurrencyVectorSeparator() );

                    _cwcRAWValue = outputFormat.FormatCurrency( _variant.cacy.pElems[iValue],
                                                                _wcsNumberValue,
                                                                sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetCurrencyVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_ARRAY | VT_I1 :
            case VT_ARRAY | VT_UI1:
            case VT_ARRAY | VT_I2 :
            case VT_ARRAY | VT_UI2 :
            case VT_ARRAY | VT_I4 :
            case VT_ARRAY | VT_INT :
            case VT_ARRAY | VT_UI4 :
            case VT_ARRAY | VT_UINT :
            case VT_ARRAY | VT_CY :
            case VT_ARRAY | VT_DECIMAL :
            case VT_ARRAY | VT_ERROR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );

                RenderSafeArray( _variant.vt & ~VT_ARRAY,
                                 _variant.parray,
                                 outputFormat,
                                 vString,
                                 TRUE );
                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            default:
            {
                Win4Assert( _eNumType == eNotANumber );
                GetStringValueRAW( outputFormat, cwcValue );
                break;
            }
        }
    }

#if (DBG == 1)
    if ( _wcsRAWValue != 0 )
    {
        Win4Assert( wcslen(_wcsRAWValue) == _cwcRAWValue );
    }
#endif // DBG == 1

    Win4Assert( !(_wcsRAWValue == 0 && _cwcRAWValue != 0) );

    cwcValue = _cwcRAWValue;
    return _wcsRAWValue;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::GetStringValueRAW - public
//
//  Synopsis:   Not all VT types are strings.  Those which are not strings
//              have a string equivalent generated and stored for reuse.
//
//  Arguments:  [outputFormat] - contains formatting information for numbers
//
//  Returns:    A pointer to a string representation of the variable's value.
//
//  History:    96/Jan/03   DwightKr    Created.
//              96/Mar/29   DwightKr    Add support for deferred VT_LPWSTR
//                                      values
//
//----------------------------------------------------------------------------
WCHAR * CVariable::GetStringValueRAW( COutputFormat & outputFormat,
                                      ULONG & cwcValue)
{
    Win4Assert( !(_wcsRAWValue == 0 && _cwcRAWValue != 0) );

    //
    // Did we have a formatted raw value last time?
    //

    if ( _wcsRAWValue && _eNumType == eFormattedNumber )
    {
        if ( _wcsRAWValue != _wcsNumberValue && _wcsRAWValue != _variant.pwszVal )
            delete _wcsRAWValue;

        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
    }

    if ( 0 == _wcsRAWValue )
    {
        switch ( _variant.vt )
        {
            case VT_LPWSTR:
                //
                //  if it's a deferred value, load it now
                //
                if ( (_ulFlags & eParamDeferredValue) != 0 )
                {
                    XArray<WCHAR> wcsValue;
                    ULONG         cwcValue;

                    if ( outputFormat.GetCGIVariableW(_wcsName, wcsValue, cwcValue) )
                    {
                        _wcsRAWValue = wcsValue.Acquire();
                        _cwcRAWValue = cwcValue;

                        ciGibDebugOut(( DEB_ITRACE,
                                        "Loading deferred value for %ws=%ws\n",
                                         _wcsName,
                                         _wcsRAWValue ));
                    }
                    else
                    {
                        ciGibDebugOut(( DEB_ITRACE,
                                        "Unable to load deferred value for %ws\n",
                                         _wcsName ));

                        _variant.vt = VT_EMPTY;
                        _wcsRAWValue = _wcsNumberValue;
                       *_wcsRAWValue = 0;
                        _cwcRAWValue = 0;
                    }

                    break;
                }

                // fall through if not a deferred value

            case VT_EMPTY:
                _wcsRAWValue = _wcsNumberValue;
               *_wcsRAWValue = 0;
                _cwcRAWValue = 0;
            break;

            case VT_BSTR:
                _wcsRAWValue = _variant.bstrVal;
                _cwcRAWValue = wcslen( _wcsRAWValue );
            break;

            case VT_LPSTR:
            {
                ULONG cbBuffer = strlen( _variant.pszVal ) + 1;
                XArray<WCHAR> pwBuffer;

                _cwcRAWValue = MultiByteToXArrayWideChar(
                                          (BYTE * const) _variant.pszVal,
                                                          cbBuffer,
                                                          outputFormat.CodePage(),
                                                          pwBuffer );

                _wcsRAWValue = pwBuffer.Acquire();
            }
            break;

            case VT_UI1:
                IDQ_ultow( (ULONG) _variant.bVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_I1:
                IDQ_ltow( (LONG) _variant.cVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_UI2:
                IDQ_ultow( (ULONG) _variant.uiVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_I2:
                IDQ_ltow( (LONG) _variant.iVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_UI4:
            case VT_UINT:
                IDQ_ultow( _variant.ulVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_I4:
            case VT_INT:
            case VT_ERROR:
                IDQ_ltow( _variant.lVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_UI8:
                IDQ_ulltow( _variant.uhVal.QuadPart, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_I8:
                IDQ_lltow( _variant.hVal.QuadPart, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_R4:
            {
                // Big enough for a 1e308 + 9 decimal places + sign

                WCHAR awc[maxFloatSize];

                outputFormat.FormatFloatRaw( _variant.fltVal, fltPrec, awc, maxFloatSize );
                _cwcRAWValue = wcslen( awc );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awc, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eRawNumber;
            }
            break;

            case VT_R8:
            case VT_DECIMAL:
            {
                double dblValue = _variant.dblVal;
                if ( VT_DECIMAL == _variant.vt )
                    VarR8FromDec( &_variant.decVal, &dblValue );

                // Big enough for a 1e308 + 9 decimal places + sign

                WCHAR awc[maxFloatSize];

                outputFormat.FormatFloatRaw( dblValue, dblPrec, awc, maxFloatSize );
                _cwcRAWValue = wcslen( awc );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awc, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eRawNumber;
            }
            break;

            case VT_DATE:
            {
                //
                // variantdate => dosdate => utcfiletime
                //

                SYSTEMTIME stUTC;
                if ( VariantTimeToSystemTime(_variant.date, &stUTC ) )
                {
                    _cwcRAWValue = outputFormat.FormatDateTime( stUTC,
                                                                _wcsNumberValue,
                                                                sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    _wcsRAWValue = _wcsNumberValue;
                }
                else
                {
                    _wcsRAWValue  = _wcsNumberValue;
                    *_wcsRAWValue = 0;
                    _cwcRAWValue  = 0;
                }
            }
            break;

            case VT_FILETIME:
                _cwcRAWValue = outputFormat.FormatDateTime( _variant.filetime,
                                                            _wcsNumberValue,
                                                            sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
            break;

            case VT_BOOL:
                _wcsRAWValue = _wcsNumberValue;
                wcscpy( _wcsRAWValue, _variant.boolVal == VARIANT_FALSE ? L"FALSE" : L"TRUE" );
                _cwcRAWValue = wcslen( _wcsRAWValue );
            break;

            case VT_CLSID:
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = swprintf( _wcsRAWValue,
                               L"%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                               _variant.puuid->Data1,
                               _variant.puuid->Data2,
                               _variant.puuid->Data3,
                               _variant.puuid->Data4[0], _variant.puuid->Data4[1],
                               _variant.puuid->Data4[2], _variant.puuid->Data4[3],
                               _variant.puuid->Data4[4], _variant.puuid->Data4[5],
                               _variant.puuid->Data4[6], _variant.puuid->Data4[7] );
            break;

            case VT_CY:
            {
                double dblValue;
                VarR8FromCy( _variant.cyVal, &dblValue );

                // Big enough for a 1e308 + 9 decimal places + sign

                WCHAR awc[maxFloatSize];

                _cwcRAWValue = swprintf( awc, L"%lf", dblValue );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awc, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eRawNumber;
            }
            break;


            //
            //  Vectors only below this point
            //
            case VT_LPWSTR | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetStringVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.calpwstr.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetStringVectorSeparator() );

                    vString.StrCat( _variant.calpwstr.pElems[iValue] );
                }

                vString.StrCat( outputFormat.GetStringVectorSuffix() );
                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_BSTR | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetStringVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cabstr.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetStringVectorSeparator() );

                    vString.StrCat( _variant.cabstr.pElems[iValue] );
                }

                vString.StrCat( outputFormat.GetStringVectorSuffix() );
                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_LPSTR | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetStringVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.calpstr.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetStringVectorSeparator() );

                    ULONG cbBuffer = strlen( _variant.calpstr.pElems[iValue] ) + 1;
                    XArray<WCHAR> pwBuffer;

                    _cwcRAWValue = MultiByteToXArrayWideChar(
                                              (BYTE * const) _variant.calpstr.pElems[iValue],
                                                              cbBuffer,
                                                              outputFormat.CodePage(),
                                                              pwBuffer );

                    vString.StrCat( pwBuffer.Get(), _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetStringVectorSuffix() );
                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_UI1 | VT_VECTOR:
            case VT_I1 | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caub.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_UI1 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_ultow( (ULONG) _variant.caub.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else
                    {
                        IDQ_ltow( (LONG) _variant.cac.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;


            case VT_I2 | VT_VECTOR:
            case VT_UI2 | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caui.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_UI2 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_ultow( (ULONG) _variant.caui.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else
                    {
                        IDQ_ltow( (LONG) _variant.cai.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_I4 | VT_VECTOR:
            case VT_UI4 | VT_VECTOR:
            case VT_I8 | VT_VECTOR:
            case VT_UI8 | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caul.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_I4 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_ltow( _variant.cal.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else if ( (VT_UI4 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_ultow( _variant.caul.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else if ( (VT_I8 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_lltow( _variant.cah.pElems[iValue].QuadPart, _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else
                    {
                        IDQ_ulltow( _variant.cauh.pElems[iValue].QuadPart, _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_R4 | VT_VECTOR:
            case VT_R8 | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                // Big enough for a 1e308 + 9 decimal places + sign
                WCHAR awc[maxFloatSize];

                for ( unsigned iValue=0;
                      iValue<_variant.cadbl.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_R4 | VT_VECTOR) == _variant.vt )
                    {
                        outputFormat.FormatFloatRaw( _variant.caflt.pElems[iValue], fltPrec, awc, maxFloatSize );
                        _cwcRAWValue = wcslen( awc );
                    }
                    else
                    {
                        outputFormat.FormatFloatRaw( _variant.cadbl.pElems[iValue], dblPrec, awc, maxFloatSize );
                        _cwcRAWValue = wcslen( awc );
                    }

                    vString.StrCat( awc, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_DATE | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetDateVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cadate.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetDateVectorSeparator() );

                    //
                    // variantdate => dosdate => localfiletime => utcfiletime
                    //

                    SYSTEMTIME stUTC;
                    if ( VariantTimeToSystemTime(_variant.cadate.pElems[iValue], &stUTC ) )
                    {
                        _cwcRAWValue = outputFormat.FormatDateTime( stUTC,
                                                                    _wcsNumberValue,
                                                                    sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    }
                    else
                    {
                        *_wcsNumberValue = 0;
                        _cwcRAWValue  = 0;
                    }

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetDateVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_FILETIME | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetDateVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cafiletime.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetDateVectorSeparator() );

                    _cwcRAWValue = outputFormat.FormatDateTime( _variant.cafiletime.pElems[iValue],
                                                                _wcsNumberValue,
                                                                sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetDateVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_BOOL | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetBoolVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cabool.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetBoolVectorSeparator() );

                    vString.StrCat( _variant.cabool.pElems[iValue] == VARIANT_FALSE ? L"FALSE" : L"TRUE" );
                }

                vString.StrCat( outputFormat.GetBoolVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_CLSID | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetStringVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cauuid.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetStringVectorSeparator() );

                    _cwcRAWValue = swprintf( _wcsNumberValue,
                                   L"%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                                   _variant.cauuid.pElems[iValue].Data1,
                                   _variant.cauuid.pElems[iValue].Data2,
                                   _variant.cauuid.pElems[iValue].Data3,
                                   _variant.cauuid.pElems[iValue].Data4[0], _variant.cauuid.pElems[iValue].Data4[1],
                                   _variant.cauuid.pElems[iValue].Data4[2], _variant.cauuid.pElems[iValue].Data4[3],
                                   _variant.cauuid.pElems[iValue].Data4[4], _variant.cauuid.pElems[iValue].Data4[5],
                                   _variant.cauuid.pElems[iValue].Data4[6], _variant.cauuid.pElems[iValue].Data4[7] );
                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetStringVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_CY | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetCurrencyVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cacy.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetCurrencyVectorSeparator() );

                    // Big enough for a 1e308 + 9 decimal places + sign
                    WCHAR awc[maxFloatSize];

                    double dblValue;
                    VarR8FromCy( _variant.cacy.pElems[iValue], &dblValue );

                    _cwcRAWValue = swprintf( awc, L"%lf", dblValue );

                    vString.StrCat( awc, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetCurrencyVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            default:
            {
                if ( VT_ARRAY & _variant.vt )
                {
                    VARTYPE vt = _variant.vt & ~VT_ARRAY;

                    if ( VT_I1    == vt || VT_UI1     == vt ||
                         VT_I2    == vt || VT_UI2     == vt ||
                         VT_I4    == vt || VT_UI4     == vt ||
                         VT_INT   == vt || VT_UINT    == vt ||
                         VT_I8    == vt || VT_UI8     == vt ||
                         VT_R4    == vt || VT_R8      == vt ||
                         VT_CY    == vt || VT_DECIMAL == vt ||
                         VT_ERROR == vt )
                        _eNumType = eRawNumber;

                    CVirtualString vString( 0x200 );

                    RenderSafeArray( vt,
                                     _variant.parray,
                                     outputFormat,
                                     vString,
                                     FALSE );
                    _wcsRAWValue = vString.StrDup();
                    _cwcRAWValue = vString.StrLen();
                }
                else
                {
                    _wcsRAWValue  = _wcsNumberValue;
                    *_wcsRAWValue = 0;
                    _cwcRAWValue  = 0;

                    ciGibDebugOut(( DEB_WARN,
                                    "Type %u not supported in out column",
                                    _variant.vt ));
                }
            }
            break;
        }
    }

#if (DBG == 1)
    if ( _wcsRAWValue != 0 )
    {
        Win4Assert( wcslen(_wcsRAWValue) == _cwcRAWValue );
    }
#endif // DBG == 1

    Win4Assert( !(_wcsRAWValue == 0 && _cwcRAWValue != 0) );

    cwcValue = _cwcRAWValue;
    return _wcsRAWValue;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::DupStringValue - public
//
//  Synopsis:   Makes a copy of the string value of this variable
//
//  Returns:    A pointer to a string representation of the variable's value.
//
//  History:    96/Mar/07   DwightKr    Created.
//
//----------------------------------------------------------------------------
WCHAR * CVariable::DupStringValue( COutputFormat & outputFormat )
{
    ULONG cwcValue;
    WCHAR * wcsValue = GetStringValueRAW( outputFormat, cwcValue );

    WCHAR * wcsCopyOfValue = new WCHAR[ cwcValue + 1 ];
    RtlCopyMemory( wcsCopyOfValue,
                   wcsValue,
                   (cwcValue+1) * sizeof(WCHAR) );

    return wcsCopyOfValue;
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariable::IsDirectlyComparable - public
//
//  Synopsis:   Not all VT types are are numbers.  This is useful when
//              attempting to compare different VT_TYPES.
//
//  Returns:    TRUE if the variable can be represented as a number, FALSE
//              for strings, blobs, etc.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
BOOL CVariable::IsDirectlyComparable() const
{
    switch ( _variant.vt & ( ~VT_VECTOR ) )
    {
    case VT_UI1:
    case VT_I1:
    case VT_UI2:
    case VT_I2:
    case VT_UI4:
    case VT_I4:
    case VT_UINT:
    case VT_INT:
    case VT_R4:
    case VT_R8:
    case VT_I8:
    case VT_UI8:
    case VT_BOOL:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_DECIMAL:
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::SetVariable - public
//
//  Synopsis:   A assignment operator; allows the value of a variable to
//              be changed.
//
//  Arguments:  [wcsName]        - the variable name
//              [pVariant]       - new value for this variable
//              [ulCreateFlags]  - and flags associated with this variable;
//                                 such as requiring an IRowsetScroll
//
//  History:    96/Jan/03   DwightKr    Created.
//              96/Apr/11   DwightKr    Set back link
//
//----------------------------------------------------------------------------
CVariable * CVariableSet::SetVariable( WCHAR const * wcsName,
                                       PROPVARIANT const * pVariant,
                                       ULONG ulCreateFlags )
{
    Win4Assert( 0 != wcsName );

    ULONG ulHash = ISAPIVariableNameHash( wcsName );
    CVariable *pVariable = Find(wcsName, ulHash);

    if ( 0 != pVariable )
    {
        pVariable->SetValue( pVariant, ulCreateFlags );
    }
    else
    {
        pVariable = new CVariable( wcsName,
                                   pVariant,
                                   ulCreateFlags );

        pVariable->SetNext( _variableSet[ ulHash ] );
        if ( 0 != pVariable->GetNext() )
        {
            pVariable->GetNext()->SetBack( pVariable );
        }

        _variableSet[ ulHash ] = pVariable;
    }

    return pVariable;
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::CopyStringValue - public
//
//  Synopsis:   A assignment operator; allows the value of a variable to
//              be changed.
//
//  Arguments:  [wcsName]        - the variable name
//              [wcsValue]       - value of the variable
//              [ulCreateFlags]  - and flags associated with this variable;
//                                 such as requiring an IRowsetScroll
//              [cwcValue]       - # of chars in wcsValue or 0 if unknown
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::CopyStringValue( WCHAR const * wcsName,
                                    WCHAR const * wcsValue,
                                    ULONG         ulCreateFlags,
                                    ULONG         cwcValue )
{
    Win4Assert( 0 != wcsName );
    Win4Assert( 0 != wcsValue );

    if ( 0 == cwcValue )
        cwcValue = wcslen( wcsValue );

    cwcValue++;

    XArray<WCHAR> wcsCopyOfValue( cwcValue );
    RtlCopyMemory( wcsCopyOfValue.Get(), wcsValue, cwcValue * sizeof(WCHAR) );

    PROPVARIANT propVariant;
    propVariant.vt      = VT_LPWSTR;
    propVariant.pwszVal = wcsCopyOfValue.Get();

    SetVariable( wcsName, &propVariant, ulCreateFlags | eParamOwnsVariantMemory );

    wcsCopyOfValue.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::AcquireStringValue - public
//
//  Synopsis:   A assignment operator; allows the value of a variable to
//              be changed. Ownership of wcsValue is transferred.
//
//  Arguments:  [wcsName]        - the variable name
//              [wcsValue]       - value of this variable
//              [ulCreateFlags]  - and flags associated with this variable;
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::AcquireStringValue( WCHAR const * wcsName,
                                       WCHAR * wcsValue,
                                       ULONG ulCreateFlags )
{
    Win4Assert( 0 != wcsName );
    Win4Assert( 0 != wcsValue );

    PROPVARIANT propVariant;
    propVariant.vt      = VT_LPWSTR;
    propVariant.pwszVal = wcsValue;

    SetVariable( wcsName, &propVariant, ulCreateFlags | eParamOwnsVariantMemory );
}


void CVariableSet::SetVariable( WCHAR const *   wcsName,
                                XArray<WCHAR> & xValue )
{
    Win4Assert( 0 != wcsName );
    Win4Assert( 0 != xValue.Get() );

    PROPVARIANT propVariant;
    propVariant.vt      = VT_LPWSTR;
    propVariant.pwszVal = xValue.Get();

    SetVariable( wcsName, &propVariant, eParamOwnsVariantMemory );

    xValue.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::AddVariableSet - public
//
//  Synopsis:   Adds all variables in the variableSet to this variableSet.
//
//  Arguments:  [variableSet]  - the variableSet to add
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::AddVariableSet( CVariableSet & variableSet,
                                   COutputFormat & outputFormat )
{
    for ( CVariableSetIter iter(variableSet);
          !iter.AtEnd();
           iter.Next()
        )
    {
        CVariable * pVariable = iter.Get();

        SetVariable( pVariable->GetName(),
                     pVariable->GetValue(),
                     pVariable->GetFlags() );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::CVariableSet - copy constructor
//
//  Synopsis:   makes a copy of the variableSet
//
//  Arguments:  [variableSet]  - the variableSet to copy
//
//  History:    96/Jan/03   DwightKr    Created.
//              96/Apr/11   DwightKr    Set back link
//
//----------------------------------------------------------------------------
CVariableSet::CVariableSet( const CVariableSet & variableSet )
{
    RtlZeroMemory( _variableSet, sizeof _variableSet );

    for ( CVariableSetIter iter(variableSet);
          !iter.AtEnd();
           iter.Next()
        )
    {
        CVariable * pVariable    = iter.Get();
        CVariable * pNewVariable = new CVariable( *pVariable );

        XPtr<CVariable> xNewVariable(pNewVariable);

        ULONG ulHash = ISAPIVariableNameHash( pNewVariable->GetName() );

        //
        //  Set NEXT & BACK pointers in the hash chain
        //
        pNewVariable->SetNext( _variableSet[ ulHash ] );
        if ( 0 != pNewVariable->GetNext() )
        {
            pNewVariable->GetNext()->SetBack( pNewVariable );
        }

        _variableSet[ ulHash ] = pNewVariable;

        xNewVariable.Acquire();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::GetValue - public
//
//  Synopsis:   Gets the value of the variable whose name is specified.
//
//  Arguments:  [wcsName]  - the variable name to return a value for
//
//  Returns:    PROPVARIANT * to the variable, 0 if no variable with this name.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
PROPVARIANT * CVariableSet::GetValue( WCHAR const * wcsName ) const
{
    CVariable * pVariable = Find( wcsName );

    if ( pVariable )
        return pVariable->GetValue();
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::GetStringValueRAW - public
//
//  Synopsis:   Gets the string value of the variable whose name is specified.
//
//  Arguments:  [wcsName]  - the variable name to return a value for
//
//  Returns:    WCHAR * to the variable's string representation, 0 if no
//              variable with this name.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
WCHAR const * CVariableSet::GetStringValueRAW( WCHAR const * wcsName,
                                               ULONG ulHash,
                                               COutputFormat & outputFormat,
                                               ULONG & cwcValue )
{
    CVariable * pVariable = Find(wcsName, ulHash);

    if ( pVariable )
        return pVariable->GetStringValueRAW( outputFormat, cwcValue );
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::AddExtensionControlBlock
//
//  Synopsis:   Adds QUERY_STRING or STDIN buffer to variable set
//
//  Arguments:  [webServer]  - extension control block to add to variableSet
//
//  History:    03-Jan-96   DwightKr    Created.
//              11-Jun-97   KyleP       Take codepage from web server
//              11-Sep-98   KLam        Assert that method is GET or POST
//
//----------------------------------------------------------------------------
void CVariableSet::AddExtensionControlBlock( CWebServer & webServer )
{
    //
    //  Determine if the user has passed the variables via a GET or POST
    //

    //
    //  We support only the GET and POST methods
    //

    BYTE * pszBuffer;
    ULONG  cbBuffer;

    XArray<BYTE> xTemp;

    if ( strcmp( webServer.GetMethod(), "GET" ) == 0 )
    {
        pszBuffer = (BYTE *) webServer.GetQueryString();
        cbBuffer  = strlen( (char *)pszBuffer );
    }
    else if ( strcmp( webServer.GetMethod(), "POST" ) == 0 )
    {
        pszBuffer = (BYTE *) webServer.GetClientData( cbBuffer );

        // posts aren't null terminated, and we expect them to be.

        xTemp.Init( cbBuffer + 1 );
        RtlCopyMemory( xTemp.GetPointer(), pszBuffer, cbBuffer );
        xTemp[cbBuffer] = 0;
        pszBuffer = xTemp.Get();
    }
    else
    {
        //
        // The validity of the method should have been checked before
        //
        Win4Assert ( strcmp( webServer.GetMethod(), "GET" ) == 0
                     || strcmp( webServer.GetMethod(), "POST" ) == 0);
    }

    ciGibDebugOut(( DEB_ITRACE, "QUERY_STRING = %s\n", pszBuffer ));


    // NOTE:  The pszBuffer is pointing to strings in the ECB.  We
    //        shouldn't modify these strings.
    if ( cbBuffer > 0 )
    {
        //
        //  Strip off trailing control characters, such as \n\r
        //
        while ( (cbBuffer > 0) && (pszBuffer[cbBuffer-1] <= ' ') )
        {
            cbBuffer--;
        }

        //
        //  Setup the QUERY_STRING variable in our variableSet
        //
        XArray<WCHAR> wcsQueryString;
        ULONG cwcBuffer = MultiByteToXArrayWideChar( (BYTE * const) pszBuffer,
                                                     cbBuffer + 1,
                                                     webServer.CodePage(),
                                                     wcsQueryString );

        Win4Assert( cwcBuffer != 0 && cwcBuffer <= (cbBuffer+1) );
        wcsQueryString[ cwcBuffer ] = L'\0';

        PROPVARIANT Variant;
        Variant.vt = VT_LPWSTR;
        Variant.pwszVal = wcsQueryString.Get();
        SetVariable( ISAPI_QUERY_STRING, &Variant, eParamOwnsVariantMemory );

        wcsQueryString.Acquire();
    }

    //
    //  Parse the string, which has the following format:
    //
    //
    //      attr1=Value1&attr2=value2&attr3=value+%7c+0&foo&bar
    //

    CHAR * pszToken = (CHAR *)pszBuffer;
    while ( (0 != pszToken) && (0 != *pszToken) )
    {
        //
        //  Find the value on the right hand side of the equal sign.
        //
        CHAR *pszAttribute = pszToken;
        CHAR *pszValue = strchr( pszAttribute, '=' );

        if ( 0 != pszValue )
        {
            ULONG cchAttribute = (ULONG)(pszValue - pszAttribute);
            pszValue++;

            //  Point to the next attribute.

            pszToken = strchr( pszToken, '&' );

            ULONG cchValue;

            if ( 0 != pszToken )
            {
                if ( pszToken < pszValue )
                {
                    //
                    // We have a construction like foo&bar=value.  Skip the
                    // 'foo' part.
                    //

                    pszToken++;
                    continue;
                }
                cchValue = (ULONG)(pszToken - pszValue);
                pszToken++;
            }
            else
            {
                cchValue = (ULONG)((CHAR *)&pszBuffer[cbBuffer] - pszValue);
            }

            WCHAR wcsAttribute[200];
            if ( cchAttribute >= ( sizeof wcsAttribute / sizeof WCHAR ) )
                THROW( CException( DB_E_ERRORSINCOMMAND ) );

            DecodeURLEscapes( (BYTE *) pszAttribute, cchAttribute, wcsAttribute,
                              webServer.CodePage() );

            if ( 0 == cchAttribute )
                THROW( CException( DB_E_ERRORSINCOMMAND ) );

            DecodeHtmlNumeric( wcsAttribute );

            //
            // We could use Win32 for uppercasing the string, but we're looking for a fixed
            // set of attributes that are known to be in this character set.
            //

            _wcsupr( wcsAttribute );

            XArray<WCHAR> wcsValue( cchValue+2 );

            DecodeURLEscapes( (BYTE *) pszValue, cchValue, wcsValue.Get(), webServer.CodePage() );

            if ( 0 != cchValue )
            {
                DecodeHtmlNumeric( wcsValue.Get() );
            }

            ciGibDebugOut(( DEB_ITRACE, "From browser, setting %ws=%ws\n",
                                         wcsAttribute,
                                         wcsValue.Get() ));

            SetVariable( wcsAttribute, wcsValue );
        }
        else
        {
            //
            // There was an & and no =, so it looked like one of the following:
            // &&&&&&&&&&&&&&&&&&&&&&&&&&&
            // &asdfasdfasdfasdfasdfasdfas
            // Most likely, this is a lame DOS attack.  Just bail on it.
            //

            pszToken = 0;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     ISAPIVariableNameHash - public
//
//  Synopsis:   Generates a hash for the name specified
//
//  Arguments:  [pwcName]  - the variable name to hash
//
//  Returns:    ULONG - hash of the name
//
//  History:    96/Jan/03   DwightKr    Created.
//
//
//----------------------------------------------------------------------------
ULONG ISAPIVariableNameHash( WCHAR const * pwcName )
{
    Win4Assert( 0 != pwcName );
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = 0;

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += (ULONG)( pwcName - pwcStart );

    return ulHash % VARIABLESET_HASH_TABLE_SIZE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::~CVariableSet - public
//
//  Synopsis:   Deletes the variables in the set.
//
//  History:    96/Apr/03   dlee    Created.
//
//
//----------------------------------------------------------------------------

CVariableSet::~CVariableSet()
{
    // Variables delete the next in their chain, so only delete the
    // start of each hash chain.

    for ( unsigned x = 0; x < VARIABLESET_HASH_TABLE_SIZE; x++ )
        delete _variableSet[ x ];
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::Find
//
//  Synopsis:   Locates a variable in the variableSet with the given name
//
//  Arguments:  [wcsName] - name of variable to find
//              [ulHash]  - hashed value of the name
//
//  Returns:    pVariable if found, 0 otherwise
//
//  History:    96/Apr/11   DwightKr    Created.
//
//----------------------------------------------------------------------------

CVariable * CVariableSet::Find( WCHAR const * wcsName, ULONG ulHash ) const
{
    Win4Assert( ulHash == ISAPIVariableNameHash(wcsName) );

    //
    //  Walk down the chain and try to find a match
    //  Note:  Variable names have been converted to upper case before
    //         we got this far.  Hence, the case insensitive string
    //         comparison.
    //
    for ( CVariable * pVariable = _variableSet[ ulHash ];
          pVariable != 0;
          pVariable = pVariable->GetNext()
        )
    {
        Win4Assert( pVariable != 0);

        if ( wcscmp(wcsName, pVariable->GetName() ) == 0 )
        {
            return pVariable;
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::Delete
//
//  Synopsis:   Deletes a single variable from a variableSet
//
//  Arguments:  [pVariable] - pointer to variable to delete
//
//  History:    96/Apr/11   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::Delete( CVariable * pVariable )
{
    Win4Assert ( 0 != pVariable );

    ULONG ulHash = ISAPIVariableNameHash( pVariable->GetName() );
    Win4Assert( Find(pVariable->GetName(), ulHash) == pVariable );

    //
    //  If there is a variable before this one in the hash chain, set its
    //  next pointer.
    //
    if ( 0 != pVariable->GetBack() )
    {
        pVariable->GetBack()->SetNext( pVariable->GetNext() );
    }

    //
    //  If there is a variable after this one in the hash chain, set its
    //  back pointer.
    //
    if ( 0 != pVariable->GetNext() )
    {
        pVariable->GetNext()->SetBack( pVariable->GetBack() );
    }

    //
    //  Update the array
    //
    if ( _variableSet[ulHash] == pVariable )
    {
        _variableSet[ulHash] = pVariable->GetNext();
    }

    pVariable->SetNext(0);
    pVariable->SetBack(0);

    delete pVariable;
}


#if (DBG == 1)
//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::Dump
//
//  Synopsis:   Appends each of the variables to the virtual string supplied
//
//  Arguments:  [string] - string to append data to
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::Dump( CVirtualString & wcsString,
                         COutputFormat & outputFormat )
{
    for (CVariableSetIter iter(*this);
         !iter.AtEnd();
          iter.Next() )
    {
        CVariable *pVariable = iter.Get();

        wcsString.StrCat( pVariable->GetName() );

        wcsString.CharCat( L'=' );

        ULONG cwcValue;
        WCHAR * wcsValue = pVariable->GetStringValueRAW( outputFormat, cwcValue);
        wcsString.StrCat( wcsValue, cwcValue );

        wcsString.StrCat( L"<BR>\n" );
    }
}
#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\weblang.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       WEBLANG.CXX
//
//  Contents:   Language Support
//
//  Classes:    CWebLangLocator
//
//  History:    96-Feb-29   DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Method:     CWebLangLocator::CWebLangLocator
//
//  Arguments:  [locale] -- current locale
//
//  History:    96-Feb-29   DwightKr    Created.
//
//--------------------------------------------------------------------------

CWebLangLocator::CWebLangLocator( LCID locale )
   : _locale( LANGIDFROMLCID(locale) ),
     _localeSys( GetSystemDefaultLangID() ),
     _fLocaleFound( FALSE ),
     _fLangFound( FALSE ),
     _fSysLangFound( FALSE )
{
    _wcsIDQErrorFile[0]         = 0;
    _wcsHTXErrorFile[0]         = 0;
    _wcsRestrictionErrorFile[0] = 0;
    _wcsDefaultErrorFile[0]     = 0;

    EnumLangEntries();
}

//+-------------------------------------------------------------------------
//
//  Method:     CWebLangLocator::EnumLangEntries, private
//
//  Synposis:   Enumerates lang subkeys
//
//  Arguments:  none
//
//  returns:    none
//
//  History:    4/23/98 mohamedn    created
//
//--------------------------------------------------------------------------

void CWebLangLocator::EnumLangEntries(void)
{
    CWin32RegAccess langKey( HKEY_LOCAL_MACHINE, wcsRegAdminLanguage );

    WCHAR           wcsSubKeyName[MAX_PATH+1];
    DWORD           cwcName = sizeof wcsSubKeyName / sizeof WCHAR;

    while ( langKey.Enum( wcsSubKeyName, cwcName ) )
    {
        CWin32RegAccess langSubKey( langKey.GetHKey() , wcsSubKeyName );

        DWORD dwLocaleId = 0;

        if ( langSubKey.Get( L"Locale", dwLocaleId ) )
        {
            GetLangInfo( dwLocaleId, langSubKey );
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CWebLangLocator::GetLangInfo, private
//
//  Synposis:   Get error files if _locale matches.
//
//  Arguments:  [dwLocaleValue] -- value of locale found
//              [regLang]       -- registry lang. subkey accessor.
//
//  returns:    none
//
//  History:    4/23/98 mohamedn    created
//
//--------------------------------------------------------------------------

void CWebLangLocator::GetLangInfo(DWORD dwLocaleValue, CWin32RegAccess & regLang)
{
    if ( _fLocaleFound )
        return;

    //
    // Temporary state
    //

    BOOL fLocaleFound  = _fLocaleFound;
    BOOL fLangFound    = _fLangFound;
    BOOL fSysLangFound = _fSysLangFound;

    DWORD dwLocale = LANGIDFROMLCID( dwLocaleValue );
    BOOL fFetch = FALSE;

    if ( dwLocale == _locale )
    {
        fFetch = TRUE;
        fLocaleFound = TRUE;
    }
    else if ( !fLangFound && PrimaryLangsMatch( dwLocale, _locale ) )
    {
        fFetch = TRUE;
        fLangFound = TRUE;
    }
    else if ( !fLangFound && !fSysLangFound && (dwLocale == _localeSys) )
    {
        fFetch = TRUE;
        fSysLangFound = TRUE;
    }

    if ( fFetch )
    {
        BOOL fRetVal = FALSE;

        fRetVal = regLang.Get( L"ISAPIIDQErrorFile", _wcsIDQErrorFile,
                           sizeof(_wcsIDQErrorFile) / sizeof (WCHAR) );

        if ( fRetVal )
        {
            fRetVal = regLang.Get( L"ISAPIHTXErrorFile", _wcsHTXErrorFile,
                         sizeof(_wcsHTXErrorFile) / sizeof(WCHAR) );
        }

        if ( fRetVal )
        {
            fRetVal = regLang.Get( L"ISAPIRestrictionErrorFile", _wcsRestrictionErrorFile,
                         sizeof(_wcsRestrictionErrorFile) / sizeof(WCHAR) );
        }

        if ( fRetVal )
        {
            fRetVal = regLang.Get( L"ISAPIDefaultErrorFile", _wcsDefaultErrorFile,
                         sizeof(_wcsDefaultErrorFile) / sizeof(WCHAR) );
        }

        //
        // if we fail to retrieve error files, don't update internal state.
        //
        if ( !fRetVal )
        {
            ciGibDebugOut(( DEB_ERROR, "CWebLangLocator::GetLangInfo() Failed\n" ));

            return;
        }
    }

    //
    // Make sure this is done *after* the fetch, which can fail.
    //

    _fLocaleFound = fLocaleFound;
    _fLangFound = fLangFound;
    _fSysLangFound = fSysLangFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    07-Nov-95   DwightKr    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <wininet.h>
#include <httpext.h>

#include <winperf.h>

#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <malloc.h>
#include <math.h>
#include <memory.h>
#include <process.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <cidebnot.h>
#include <ciexcpt.hxx>
#include <cisem.hxx>
#include <tsmem.hxx>
#include <smart.hxx>

#include <cierror.h>

#define _CAIROSTG_
#include <oleext.h>

// #define OLEDBVER 0x250      // enable ICommandTree interface
// #define deprecated          // enable IRowsetExactScroll
#include <oledb.h>
#include <cierror.h>
#include <filterr.h>
#include <dbcmdtre.hxx>
#include <vquery.hxx>
#include <query.h>
#include <ntquery.h>

#include <stgprop.h>
#include <stgvarb.hxx>
#include <restrict.hxx>

#include <oledberr.h>

//
// Debug files from
//

#include <cidebug.hxx>
#include <vqdebug.hxx>

#include <dynarray.hxx>
#include <dynstack.hxx>
#include <tgrow.hxx>
#include <funypath.hxx>
#include <thrd32.hxx>
#include <dblink.hxx>
#include <readwrit.hxx>
#include <regacc.hxx>
#include "idqreg.hxx"
#include <circq.hxx>
#include <regevent.hxx>
#include <codepage.hxx>
#include <imprsnat.hxx>
#include <compare.hxx>

#include <plist.hxx>
#include <lgplist.hxx>
#include <scanner.hxx>
#include <qlibutil.hxx>
#include <parser.hxx>
#include <fmapio.hxx>
#include <mbutil.hxx>

#include <catstate.hxx>
#include <doquery.hxx>

#include "weblang.hxx"
#include <ciregkey.hxx>
#include "tokstr.hxx"

#include "gibdebug.hxx"

#include <ciguid.hxx>
#include <ciintf.h>
#include <string.hxx>
#include <smem.hxx>
#include <cgiesc.hxx>
#include <weblcid.hxx>
#include <gibralt.hxx>
#include "secident.hxx"
#include "idq.hxx"
#include "ida.hxx"
#include <htmlchar.hxx>
#include "wqiter.hxx"
#include <pvarset.hxx>
#include "outfmt.hxx"
#include "variable.hxx"
#include "param.hxx"
#include "htx.hxx"
#include <strrest.hxx>
#include <strsort.hxx>
#include "wqitem.hxx"
#include "wqpend.hxx"
#include <idqperf.hxx>
#include "wqcache.hxx"
#include "wqlocale.hxx"
#include "idqexcpt.hxx"
#include "htxexcpt.hxx"
#include "pdbexcpt.hxx"
#include "idqmsg.h"
#include "express.hxx"
#include "xtow.hxx"
#include "errormsg.hxx"
#include <wcstoi64.hxx>
#include "varutil.hxx"
#include <hash.hxx>
#include <cphash.hxx>
#include <caturl.hxx>
#include <cpid.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\varutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996-1997, Microsoft Corporation.
//
//  File:       varutil.cxx
//
//  Contents:   Utilities for variable replacement
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   IsAReplaceableParameter, public
//
//  Synopsis:   Determines whether parameter replacement needs to be done
//              on a string.
//
//  Arguments:  [wcsString] - string to perform replacement on
//
//  Returns:    eIsSimpleString       - if no replacement needs to be done
//              eIsSimpleReplacement  - if it's a simple string substitution
//              eIsComplexReplacement - it's more complex than simple subst.
//
//  History:    96-Apr-04   AlanW     Created
//
//----------------------------------------------------------------------------

EIsReplaceable IsAReplaceableParameter( WCHAR const * wcsString )
{
    if ( wcsString == 0 || *wcsString == 0 )
        return eIsSimpleString;

    BOOL fStartWithPercent = *wcsString == L'%';
    wcsString++;

    while ( *wcsString )
    {
        if ( *wcsString == L'%' )
        {
            if ( !fStartWithPercent ||
                 wcsString[1] != L'\0' )
                return eIsComplexReplacement;
            else
                return eIsSimpleReplacement;
        }
        if ( fStartWithPercent && iswspace( *wcsString ) )
            break;

        wcsString++;
    }

    return fStartWithPercent ? eIsComplexReplacement : eIsSimpleString;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReplaceNumericParameter, public
//
//  Synopsis:   Returns the value of a numeric parameter.
//
//  Arguments:  [wcsVariableString] - string to perform replacement on
//              [variableSet]       - list of replaceable parameters
//              [outputFormat]      - format of numbers & dates
//              [defaultVal]        - default value for result
//              [minVal]            - minumum value for result
//              [maxVal]            - maxumum value for result
//
//  Returns:    ULONG - parameter value
//
//  History:    96-Apr-04   AlanW     Created
//
//----------------------------------------------------------------------------

ULONG ReplaceNumericParameter( WCHAR const * wcsVariableString,
                               CVariableSet & variableSet,
                               COutputFormat & outputFormat,
                               ULONG defaultVal,
                               ULONG minVal,
                               ULONG maxVal )
{
    ULONG ulValue = defaultVal;

    if ( 0 == wcsVariableString )
        ulValue = defaultVal;
    else if ( IsAReplaceableParameter( wcsVariableString ) == eIsSimpleString )
        ulValue = wcstoul( wcsVariableString, 0, 10 );
    else
    {
        ULONG cchValue;
        XPtrST<WCHAR> xStr( ReplaceParameters( wcsVariableString,
                                               variableSet,
                                               outputFormat,
                                               cchValue ) );

        if ( cchValue > 0 )
            ulValue = wcstoul( xStr.GetPointer(), 0, 10 );
    }

    ulValue = min( max( minVal, ulValue ), maxVal );

    return ulValue;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReplaceParameters - public
//
//  Synopsis:   Generates a new string, replacing the replaceable
//              parameters with their current values
//
//  Arguments:  [wcsVariableString] - string to perform replacement on
//              [variableSet]       - list of replaceable parameters
//              [outputFormat]      - format of numbers & dates
//              [cwcOut]            - returns length of returned string
//
//  Returns:    WCHAR * new string
//
//  History:    96-Feb-14   DwightKr    Created
//              96-Apr-04   AlanW       Added simple string substitution
//
//----------------------------------------------------------------------------

WCHAR * ReplaceParameters( WCHAR const * wcsVariableString,
                           CVariableSet & variableSet,
                           COutputFormat & outputFormat,
                           ULONG & cwcOut )
{
    if ( 0 == wcsVariableString )
    {
        cwcOut = 0;
        return 0;
    }

    switch ( IsAReplaceableParameter( wcsVariableString ) )
    {
    case eIsSimpleString:
        {
            ULONG cwcString   = wcslen( wcsVariableString ) + 1;
            WCHAR * wcsString = new WCHAR[ cwcString ];
            RtlCopyMemory( wcsString,
                           wcsVariableString,
                           cwcString * sizeof(WCHAR) );

            cwcOut = cwcString - 1;
            return wcsString;
        }

    case eIsSimpleReplacement:
        {
            ULONG cwcString = wcslen ( wcsVariableString );
            Win4Assert( wcsVariableString[0] == L'%' &&
                        wcsVariableString[cwcString-1] == L'%' );

            XPtrST<WCHAR> xStr( new WCHAR[ cwcString+1 ] );
            RtlCopyMemory( xStr.GetPointer(),
                           wcsVariableString,
                           cwcString * sizeof(WCHAR) );
            xStr.GetPointer()[ cwcString ] = L'\0';
            //
            // Null out '%' at end of variable name
            //
            xStr.GetPointer()[ cwcString-1 ] = L'\0';

            _wcsupr( xStr.GetPointer() );       // var. lookup requires upper case
            ULONG cwcValue = 0;
            WCHAR const * wcsValue =
                    variableSet.GetStringValueRAW( xStr.GetPointer()+1,
                                 ISAPIVariableNameHash( xStr.GetPointer()+1 ),
                                                   outputFormat,
                                                   cwcValue );

            if ( 0 != wcsValue )
            {
                if (cwcValue > cwcString )
                {
                    // Realloc string buffer for value replacement
                    delete xStr.Acquire();
                    xStr.Set( new WCHAR[ cwcValue+1 ] );
                }

                RtlCopyMemory( xStr.GetPointer(),
                               wcsValue,
                               cwcValue * sizeof(WCHAR) );
                xStr.GetPointer()[ cwcValue ] = L'\0';
                cwcOut = cwcValue;
            }
            else
            {
                //
                //  Restore '%' at end of variable name
                //
                xStr.GetPointer()[ cwcString-1 ] = wcsVariableString[ cwcString-1 ];
                cwcOut = cwcString;
            }
            ciGibDebugOut(( DEB_ITRACE, "Adding %ws as a simple replaceable parameter\n",
                                        xStr.GetPointer() ));
            return xStr.Acquire();
        }

    case eIsComplexReplacement:
        {
            CParameterReplacer varReplacer( wcsVariableString,
                                            L"%",
                                            L"%" );

            varReplacer.ParseString( variableSet );

            CVirtualString wcsVirtualString;
            varReplacer.ReplaceParams( wcsVirtualString,
                                       variableSet,
                                       outputFormat );

            ciGibDebugOut(( DEB_ITRACE, "Adding %ws as a complex replaceable parameter\n",
                                        wcsVirtualString.Get() ));

            cwcOut = wcsVirtualString.StrLen();
            return wcsVirtualString.StrDup();
        }

    default:
        Win4Assert( !"Bad return from IsAReplaceableParameter" );
        return 0;
    }
}

//
// The path given for the catalog should leave room for \Catalog.Wci\8.3
// Leave room for 2 8.3 names with a backslash.
//
const ULONG MAX_CAT_PATH = MAX_PATH - 13*2;

//+---------------------------------------------------------------------------
//
//  Member:     IsAValidCatalog
//
//  Synopsis:   Determines if the catalog specified is valid.
//
//  Arguments:  [wcsCatalog]  - path to catalog or the catalog name
//              [cwc]         - length of the string
//
//  History:    96-Mar-25   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL IsAValidCatalog(
    WCHAR const * wcsCatalog,
    ULONG         cwc )
{
    if ( cwc >= MAX_CAT_PATH ||
         0 == cwc )
    {
        ciGibDebugOut(( DEB_ERROR, "length invalid for catalog (%ws)\n",
                        wcsCatalog ));
        return FALSE;
    }

    // Can't do additional checking since:
    //   1) if the machine is remote, the catalog path is meaningless
    //   2) it's probably a catalog name, not a path anyway

    return TRUE;
} //IsAValidCatalog

//+---------------------------------------------------------------------------
//
//  Function:   IDQ_wtol
//
//  Synopsis:   Super-strict long parser, inspired by Mihai
//
//  Arguments:  [pwcBuf]  -  the string containing the long
//
//  History:    96-Jun-7   dlee    Created
//
//----------------------------------------------------------------------------

LONG IDQ_wtol( WCHAR const * pwcBuf )
{
    WCHAR *pwcEnd = (WCHAR *) pwcBuf;

    LONG l = wcstol( pwcBuf, &pwcEnd, 10 );

    if ( pwcEnd == pwcBuf )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    while ( iswspace( *pwcEnd ) )
        pwcEnd++;

    if ( 0 != *pwcEnd )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    return l;
} // IDQ_wtol
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\xtow.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       xtow.cxx
//
//  Contents:   formats numbers into wide strings
//
//  History:    96/Jan/3    DwightKr    Created
//              96/Apr/3    dlee        optimized and cleaned up
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Note - added to C run-times; remove when new run-times are available.
//  On second thought, just use this one -- it saves an ascii=>wide and
//  radix checking.
//  This routine isn't for real formatting -- it's just for input to
//  Win32's real number formatting routine
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   IDQ_ulltow_format
//
//  Synopsis:   formats an _int64 in a wide string.
//
//  Arguments:  [val]         -  value to format
//              [buf]         -  buffer for the result
//              [fIsNegative] - true if val is negative, false otherwise
//
//  History:    96/Apr/05   dlee    Created.
//
//----------------------------------------------------------------------------

void IDQ_ulltow_format(
    ULONGLONG val,
    WCHAR *   buf,
    int       fIsNegative )
{
    WCHAR *p = buf;

    if ( fIsNegative )
    {
        // negative, so output '-' and negate

        *p++ = L'-';
        val = (ULONGLONG) (-(LONGLONG)val);
    }

    WCHAR *firstdig = p;           // save pointer to first digit

    do
    {
        unsigned digval = (unsigned) (val % 10);
        val /= 10;   // get next digit

        Win4Assert( digval <= 9 );

        // convert to unicode and store

        *p++ = (WCHAR) (digval + L'0');
    } while ( val > 0 );

    // We now have the digit of the number in the buffer, but in reverse
    // order.  Thus we reverse them now.

    *p-- = 0;

    do
    {
        WCHAR temp = *p;
        *p = *firstdig;
        *firstdig = temp;       // swap *p and *firstdig
        --p;
        ++firstdig;             // advance to next two digits
    } while ( firstdig < p );   // repeat until halfway
}

void IDQ_ultow_format(
    ULONG   val,
    WCHAR * buf,
    int     fIsNegative )
{
    WCHAR *p = buf;

    if ( fIsNegative )
    {
        // negative, so output '-' and negate

        *p++ = L'-';
        val = (ULONG) (-(LONG)val);
    }

    WCHAR *firstdig = p;           // save pointer to first digit

    do
    {
        unsigned digval = (unsigned) (val % 10);
        val /= 10;   // get next digit

        Win4Assert( digval <= 9 );

        // convert to unicode and store

        *p++ = (WCHAR) (digval + L'0');
    } while ( val > 0 );

    // We now have the digit of the number in the buffer, but in reverse
    // order.  Thus we reverse them now.

    *p-- = 0;

    do
    {
        WCHAR temp = *p;
        *p = *firstdig;
        *firstdig = temp;       // swap *p and *firstdig
        --p;
        ++firstdig;             // advance to next two digits
    } while ( firstdig < p );   // repeat until halfway
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\wqiter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       wqiter.cxx
//
//  Contents:   WEB Query cache iterators
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CBaseQueryResultsIter::CBaseQueryResultsIter - public constructor
//
//  Arguments:  [item]           - the query results we are iterating over
//              [hAccessor]      - an accessor to the query results
//              [cCols]          - number of output columns
//              [xVariableSet]   - a list of replaceable parameters
//
//  Synopsis:   Initializes common vars between sequential & non-sequential
//              iterators
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CBaseQueryResultsIter::CBaseQueryResultsIter( CWQueryItem & item,
                                              HACCESSOR hAccessor,
                                              ULONG cCols ) :
                                              _item(item),
                                              _hAccessor(hAccessor),
                                              _cColumns(cCols),
                                              _pVariableSet(0),
                                              _cRowsReturnedToCache(0),
                                              _iCurrentCachedRow(0),
                                              _lFirstRecordNumber(1),
                                              _lMaxRecordsPerPage(0),
                                              _lNextRecordNumber(1),
                                              _lRecordsToRetrieve(0),
                                              _lTotalMatchedRecords(LONG_MAX),
                                              _pOutputColumns(_aOutputColumns)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CBaseQueryResultsIter::~CBaseQueryResultsIter - public destructor
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CBaseQueryResultsIter::~CBaseQueryResultsIter()
{
    if ( _pOutputColumns != _aOutputColumns )
    {
        delete _pOutputColumns;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseQueryResultsIter::InitalizeLocalVariables - protected
//
//  Arguments:  [variableSet]  -- local variables from browser
//              [outputFormat] -- Output formatter
//
//  Synopsis:   Sets up the common local variables for this query
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void CBaseQueryResultsIter::InitializeLocalVariables( CVariableSet & variableSet,
                                                      COutputFormat & outputFormat )
{
    //
    //  Setup the following variables:
    //
    //      CiMaxRecordsPerPage
    //      CiBookmark
    //      CiCurrentPageNumber
    //      CiContainsFirstRecord
    //      CiOutOfDate
    //      CiQueryTime
    //      CiQueryDate
    //      CiQueryTimezone
    //      CiColumns
    //      CiTemplate
    //

    _pVariableSet = &variableSet;

    PROPVARIANT Variant;
    CIDQFile const & idqFile = _item.GetIDQFile();



    //
    //  Set CiMaxRecordsPerPage
    //

    _lMaxRecordsPerPage = ReplaceNumericParameter ( idqFile.GetMaxRecordsPerPage(),
                                                     variableSet,
                                                     outputFormat,
                                                     10,
                                                     1,
                                                     0x10000 );

    _lRecordsToRetrieve = _lMaxRecordsPerPage;

    Variant.vt   = VT_I4;
    Variant.lVal = _lMaxRecordsPerPage;

    _pVariableSet->SetVariable( ISAPI_CI_MAX_RECORDS_PER_PAGE, &Variant, 0 );


    //
    //  Calulate the # of the first record to display
    //
    ULONG cwcValue;
    CVariable * pVariable = variableSet.Find(ISAPI_CI_BOOKMARK);


    if ( (0 != pVariable) &&
         (0 != pVariable->GetStringValueRAW(outputFormat, cwcValue)) &&
         (0 != cwcValue) )
    {
        CWQueryBookmark bookMark( pVariable->GetStringValueRAW(outputFormat, cwcValue) );

        _lFirstRecordNumber = bookMark.GetRecordNumber();
    }

    pVariable = variableSet.Find(ISAPI_CI_BOOKMARK_SKIP_COUNT);
    if ( (0 != pVariable) && (0 != pVariable->GetStringValueRAW(outputFormat, cwcValue)) )
    {
        _lFirstRecordNumber += IDQ_wtol( pVariable->GetStringValueRAW(outputFormat, cwcValue) );
    }



    //
    //  Set CiContainsFirstRecord
    //
    Variant.vt   = VT_BOOL;
    Variant.boolVal = VARIANT_FALSE;
    if ( 1 == _lFirstRecordNumber )
    {
        Variant.boolVal = VARIANT_TRUE;
    }
    _pVariableSet->SetVariable( ISAPI_CI_CONTAINS_FIRST_RECORD, &Variant, 0 );


    //
    //  The first record must be at least 1.  If the browser specified a
    //  large negative skipcount, we need to move the first record number
    //  forward to 1.
    //
    _lFirstRecordNumber = max( 1, _lFirstRecordNumber );


    //
    //  For sequential queries, _lTotalMatchedRecords is LONG_MAX, not the
    //  total number of matched records.
    //
    if (_lFirstRecordNumber > _lTotalMatchedRecords)
        _lFirstRecordNumber = (LONG) _lTotalMatchedRecords+1;


    //
    //  Set CiBookmark
    //

    CWQueryBookmark bookMark( _item.IsSequential(),
                             &_item,
                              _item.GetSequenceNumber(),
                              _lFirstRecordNumber );

    ULONG cwcBookmark = wcslen( bookMark.GetBookmark() );
    XArray<WCHAR> wcsCiBookMark( cwcBookmark + 1 );
    RtlCopyMemory( wcsCiBookMark.Get(),
                   bookMark.GetBookmark(),
                   (cwcBookmark+1) * sizeof(WCHAR) );

    Variant.vt = VT_LPWSTR;
    Variant.pwszVal = wcsCiBookMark.Get();
    _pVariableSet->SetVariable( ISAPI_CI_BOOKMARK,
                                &Variant,
                                eParamOwnsVariantMemory );
    wcsCiBookMark.Acquire();


    _lNextRecordNumber = _lFirstRecordNumber;


    //
    //
    //  Set CiCurrentPageNumber
    //
    Variant.vt   = VT_I4;
    Variant.lVal = _lFirstRecordNumber / _lMaxRecordsPerPage;
    if ( (_lFirstRecordNumber % _lMaxRecordsPerPage) != 0 )
    {
        Variant.lVal++;
    }
    _pVariableSet->SetVariable( ISAPI_CI_CURRENT_PAGE_NUMBER, &Variant, 0 );



    SetCGIVariables( *_pVariableSet, outputFormat );


#if 1 //nuke this soon
    //
    //  Set CiQueryTime
    //
    ULONG cwcQueryTime = 40;
    XArray<WCHAR> wcsQueryTime(cwcQueryTime-1);
    cwcQueryTime = outputFormat.FormatTime( _item.GetQueryTime(),
                                            wcsQueryTime.GetPointer(),
                                            cwcQueryTime );

    //
    //  SetCiQueryDate
    //
    ULONG cwcQueryDate = 40;
    XArray<WCHAR> wcsQueryDate(cwcQueryDate-1);
    cwcQueryDate = outputFormat.FormatDate( _item.GetQueryTime(),
                                            wcsQueryDate.GetPointer(),
                                            cwcQueryDate );


    variableSet.AcquireStringValue( ISAPI_CI_QUERY_TIME, wcsQueryTime.GetPointer(), 0 );
    wcsQueryTime.Acquire();

    variableSet.AcquireStringValue( ISAPI_CI_QUERY_DATE, wcsQueryDate.GetPointer(), 0 );
    wcsQueryDate.Acquire();
#endif

    variableSet.CopyStringValue( ISAPI_CI_QUERY_TIMEZONE, _item.GetQueryTimeZone(), 0 );
    variableSet.CopyStringValue( ISAPI_CI_COLUMNS, _item.GetColumns(), 0 );

    variableSet.CopyStringValue( ISAPI_CI_TEMPLATE, _item.GetTemplate(), 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::CQueryResultsIter - public constructor
//
//  Arguments:  [item]           - the query results we are iterating over
//              [pIRowsetScroll] - a IRowsetScroll interface
//              [hAccessor]      - an accessor to the query results
//              [cCols]          - number of output columns
//
//  Synopsis:   Builds an iterator used to access a non-sequential set of
//              query results.
//
//  Notes:      ownership of the xVariableSet is transferred to this class
//              as well as the IRowsetScroll interface
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CQueryResultsIter::CQueryResultsIter( CWQueryItem & item,
                                      IRowsetScroll * pIRowsetScroll,
                                      HACCESSOR hAccessor,
                                      ULONG cCols ) :
                                CBaseQueryResultsIter( item,
                                                      hAccessor,
                                                      cCols ),
                                _pIRowsetScroll(pIRowsetScroll)
{
    Win4Assert( pIRowsetScroll != 0 );
    Win4Assert( hAccessor != 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::~CQueryResultsIter - public destructor
//
//  Synopsis:   Releases storage & IRowsetScroll interface
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CQueryResultsIter::~CQueryResultsIter()
{
    ReleaseRowsetCache();

    _pIRowsetScroll->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::Init - public
//
//  Arguments:  [variableSet]  -- local variables from the user's browser
//              [outputFormat] -- format of $'s & dates
//
//  Synopsis:   Sets up the number & date/time formatting, and fills the
//              cache with the first set of rows.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void CQueryResultsIter::Init( CVariableSet & variableSet,
                              COutputFormat & outputFormat )
{
    //
    //  If the in-line buffer isn't big enough, allocate a new buffer
    //
    if ( _cColumns > NUMBER_INLINE_COLS )
    {
        _pOutputColumns = new COutputColumn[_cColumns];
    }

    InitializeLocalVariables( variableSet, outputFormat );

    FillRowsetCache();
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::Next - public
//
//  Synopsis:   Sets up the next row to be acessed by the GetRowData()
//              method, and fills the cache if necessary.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CQueryResultsIter::Next()
{
    _iCurrentCachedRow++;

    if ( _iCurrentCachedRow >= _cRowsReturnedToCache )
    {
        ReleaseRowsetCache();
        FillRowsetCache();
    }

    Win4Assert( _iCurrentCachedRow <= _cRowsReturnedToCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::InitalizeLocalVariables - private
//
//  Arguments:  [variableSet]  - local variables from browser
//              [outputFormat] - format of numbers & dates
//
//  Synopsis:   Sets up the local variables for this query
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void CQueryResultsIter::InitializeLocalVariables( CVariableSet & variableSet,
                                                  COutputFormat & outputFormat )
{
    //
    //  Set CiMatchedRecordCount
    //
    DBCOUNTITEM ulPosition;
    HRESULT sc = _pIRowsetScroll->GetApproximatePosition(0,0,0,
                                                         &ulPosition,
                                                         (DBCOUNTITEM *) &_lTotalMatchedRecords );

    if ( FAILED( sc ) )
    {
        THROW( CException(sc) );
    }

    PROPVARIANT Variant;
    Variant.vt   = VT_I4;
    Variant.lVal = (LONG) _lTotalMatchedRecords;
    variableSet.SetVariable( ISAPI_CI_MATCHED_RECORD_COUNT, &Variant, 0 );



    //
    //  Setup the following variables:
    //
    //      CiMatchRecordCount
    //      CiContainsLastRecord
    //      CiTotalNumberPages
    //      CiFirstRecordNumber
    //      CiLastRecordNumber
    //

    CBaseQueryResultsIter::InitializeLocalVariables( variableSet, outputFormat );


    CIDQFile const & idqFile = _item.GetIDQFile();

    //
    //  Set CiContainsLastRecord
    //
    Variant.vt   = VT_BOOL;
    Variant.boolVal = VARIANT_FALSE;
    if ( (_lFirstRecordNumber + _lMaxRecordsPerPage) > _lTotalMatchedRecords )
    {
        Variant.boolVal = VARIANT_TRUE;
    }
    _pVariableSet->SetVariable( ISAPI_CI_CONTAINS_LAST_RECORD, &Variant, 0 );


    //
    //  Set CiTotalNumberPages
    //
    Variant.vt   = VT_I4;
    Variant.lVal = (LONG) _lTotalMatchedRecords / _lMaxRecordsPerPage;
    if ( (_lTotalMatchedRecords % _lMaxRecordsPerPage) != 0 )
    {
        Variant.lVal++;
    }
    _pVariableSet->SetVariable( ISAPI_CI_TOTAL_NUMBER_PAGES, &Variant, 0 );


    //
    //  Set CiFirstRecordNumber
    //
    Variant.vt   = VT_I4;
    Variant.lVal = _lFirstRecordNumber;
    _pVariableSet->SetVariable( ISAPI_CI_FIRST_RECORD_NUMBER, &Variant, 0 );


    //
    //  Set CiLastRecordNumber
    //
    LONG lLastRecordNumber = _lFirstRecordNumber + _lMaxRecordsPerPage - 1;
    if ( lLastRecordNumber > _lTotalMatchedRecords )
    {
        lLastRecordNumber = (LONG) _lTotalMatchedRecords;
    }
    Variant.vt   = VT_I4;
    Variant.lVal = lLastRecordNumber;
    _pVariableSet->SetVariable( ISAPI_CI_LAST_RECORD_NUMBER, &Variant, 0 );


    //
    //  Set CiRecordsNextPage
    //
    Variant.vt    = VT_I4;
    if ( (lLastRecordNumber + _lMaxRecordsPerPage) <= _lTotalMatchedRecords )
    {
        Variant.lVal = _lMaxRecordsPerPage;
    }
    else
    {
        Variant.lVal = (LONG) _lTotalMatchedRecords - lLastRecordNumber;
    }
    _pVariableSet->SetVariable( ISAPI_CI_RECORDS_NEXT_PAGE , &Variant, 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::FillRowsetCache - public
//
//  Synopsis:   Fills the cache with the next set of hRows
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CQueryResultsIter::FillRowsetCache()
{
    ULONG ulRecordsToRetrieve = min(ITER_CACHE_SIZE, _lRecordsToRetrieve );

    if ( ulRecordsToRetrieve > 0 )
    {
        BYTE bookMark = DBBMK_FIRST;
        HROW * phCachedRows = _ahCachedRows;
        HRESULT sc = _pIRowsetScroll->GetRowsAt( DBWATCHREGION_NULL,
                                                 NULL,
                                                 1,
                                                 &bookMark,
                                                 _lNextRecordNumber - 1,
                                                 ulRecordsToRetrieve,
                                                 &_cRowsReturnedToCache,
                                                 &phCachedRows );

        if ( DB_E_BADSTARTPOSITION == sc )
        {
            // Requested fetch outside available rows.  Treat as end of rowset.
            Win4Assert(_lNextRecordNumber > 0);

            sc = DB_S_ENDOFROWSET;
            _cRowsReturnedToCache = 0;
        }

        if ( FAILED(sc) )
        {
            THROW( CException(sc) );
        }

        _lNextRecordNumber  += (LONG) _cRowsReturnedToCache;

        if ( 0 == _cRowsReturnedToCache ||
             DB_S_ENDOFROWSET == sc )
        {
            Win4Assert( DB_S_ENDOFROWSET == sc );
            _lRecordsToRetrieve = 0;
        }
        else
        {
            _lRecordsToRetrieve -= (LONG) _cRowsReturnedToCache;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::ReleaseRowsetCache - public
//
//  Synopsis:   Releases the hRows currently in the cache
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CQueryResultsIter::ReleaseRowsetCache()
{
    if ( _cRowsReturnedToCache > 0 )
    {
        _pIRowsetScroll->ReleaseRows( _cRowsReturnedToCache,
                                      _ahCachedRows,
                                      0,
                                      0,
                                      0 );
    }

    _cRowsReturnedToCache = 0;
    _iCurrentCachedRow    = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::GetRowData - public
//
//  Synopsis:   Returns the output columns for the current row.
//
//  Results:    [COutputColumn *] an array of output columns
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
COutputColumn * CQueryResultsIter::GetRowData()
{
    Win4Assert( _iCurrentCachedRow < _cRowsReturnedToCache );

    HRESULT hr = _pIRowsetScroll->GetData( _ahCachedRows[_iCurrentCachedRow],
                                           _hAccessor,
                                           _pOutputColumns );
    if ( FAILED(hr) )
    {
        THROW( CException(hr) );
    }

    return _pOutputColumns;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::CSeqQueryResultsIter - public constructor
//
//  Arguments:  [item]           - the query results we are iterating over
//              [pIRowset]       - an IRowset interface
//              [hAccessor]      - an accessor to the query results
//              [cCols]          - number of output columns
//              [xVariableSet]   - a list of replaceable parameters
//              [ulNextRecordNumnber] - next available rec # in this query
//
//  Synopsis:   Builds an iterator used to access a non-sequential set of
//              query results.
//
//  Notes:      ownership of the pVariableSet is transferred to this class
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CSeqQueryResultsIter::CSeqQueryResultsIter( CWQueryItem & item,
                                            IRowset * pIRowset,
                                            HACCESSOR hAccessor,
                                            ULONG cCols,
                                            ULONG ulNextRecordNumber ) :
                                       CBaseQueryResultsIter( item,
                                                              hAccessor,
                                                              cCols ),
                                       _pIRowset(pIRowset)
{
    Win4Assert( pIRowset != 0 );
    Win4Assert( hAccessor != 0 );

    _lNextRecordNumber = ulNextRecordNumber;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::~CSeqQueryResultsIter - public destructor
//
//  Synopsis:   Releases storage.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CSeqQueryResultsIter::~CSeqQueryResultsIter()
{
    ReleaseRowsetCache();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::Init - public
//
//  Arguments:  [outputFormat] - format of numbers & dates
//              [variableSet]  - local variables from the user's browser
//
//  Synopsis:   Sets up the number & date/time formatting, and fills the
//              cache with the first set of rows.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQueryResultsIter::Init( CVariableSet & variableSet,
                                 COutputFormat & outputFormat )
{
    //
    //  If the in-line buffer isn't big enough, allocate a new buffer
    //
    if ( _cColumns > NUMBER_INLINE_COLS )
    {
        _pOutputColumns = new COutputColumn[_cColumns];
    }

    InitializeLocalVariables( variableSet, outputFormat );

    ULONG cRowsToSkip = _lFirstRecordNumber - _item.GetNextRecordNumber();

    FillRowsetCache( cRowsToSkip  );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::Next - public
//
//  Synopsis:   Sets up the next row to be acessed by the GetRowData()
//              method, and fills the cache if necessary.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQueryResultsIter::Next()
{
    _iCurrentCachedRow++;

    if ( _iCurrentCachedRow >= _cRowsReturnedToCache )
    {
        ReleaseRowsetCache();
        FillRowsetCache(0);
    }

    Win4Assert( _iCurrentCachedRow <= _cRowsReturnedToCache );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::FillRowsetCache - public
//
//  Arguments:  [cRowsToSkip] - number of rows to skip before filling cache
//
//  Synopsis:   Fills the cache with the next set of hRows
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQueryResultsIter::FillRowsetCache( ULONG cRowsToSkip )
{
    ULONG ulRecordsToRetrieve = min(ITER_CACHE_SIZE, _lRecordsToRetrieve);

    if ( ulRecordsToRetrieve > 0 )
    {
        HROW * phCachedRows = _ahCachedRows;
        HRESULT sc = _pIRowset->GetNextRows( NULL,
                                             cRowsToSkip,
                                             ulRecordsToRetrieve,
                                           &_cRowsReturnedToCache,
                                           &phCachedRows );

        if ( DB_E_BADSTARTPOSITION == sc )
            sc = DB_S_ENDOFROWSET;

        if ( FAILED(sc) )
        {
            THROW( CException(sc) );
        }

        _lNextRecordNumber  += (LONG) _cRowsReturnedToCache;
        _lRecordsToRetrieve -= (LONG) _cRowsReturnedToCache;


        //
        //  Set the CiContainsLastRecord variable to TRUE if we have
        //  exhausted the query results.
        //

        PROPVARIANT Variant;
        Variant.vt   = VT_BOOL;
        Variant.boolVal = VARIANT_FALSE;

        if ( 0 == _cRowsReturnedToCache ||
             DB_S_ENDOFROWSET == sc ||
             DB_S_STOPLIMITREACHED == sc )
        {
            Win4Assert( DB_S_ENDOFROWSET == sc || DB_S_STOPLIMITREACHED == sc );
            _lRecordsToRetrieve = 0;
            Variant.boolVal = VARIANT_TRUE;
        }

        _pVariableSet->SetVariable( ISAPI_CI_CONTAINS_LAST_RECORD, &Variant, 0 );

        if ( DB_S_STOPLIMITREACHED == sc )
        {
            Variant.boolVal = VARIANT_TRUE;
            _pVariableSet->SetVariable( ISAPI_CI_QUERY_TIMEDOUT, &Variant, 0 );
        }


        //
        //  Set CiLastRecordNumber
        //
        Variant.vt   = VT_I4;
        Variant.lVal = _lNextRecordNumber - 1;
        _pVariableSet->SetVariable( ISAPI_CI_LAST_RECORD_NUMBER, &Variant, 0 );

        _item.SetNextRecordNumber( _lNextRecordNumber );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::ReleaseRowsetCache - public
//
//  Synopsis:   Releases the hRows currently in the cache
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQueryResultsIter::ReleaseRowsetCache()
{
    if ( _cRowsReturnedToCache > 0 )
    {
        _pIRowset->ReleaseRows( _cRowsReturnedToCache,
                                _ahCachedRows,
                                0,
                                0,
                                0 );
    }

    _cRowsReturnedToCache = 0;
    _iCurrentCachedRow    = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::GetRowData - public
//
//  Synopsis:   Returns the output columns for the current row.
//
//  Results:    [COutputColumn *] an array of output columns
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
COutputColumn * CSeqQueryResultsIter::GetRowData()
{
    Win4Assert( _iCurrentCachedRow < _cRowsReturnedToCache );

    HRESULT hr = _pIRowset->GetData( _ahCachedRows[_iCurrentCachedRow],
                                     _hAccessor,
                                     _pOutputColumns );
    if ( FAILED(hr) )
    {
        THROW( CException(hr) );
    }

    return _pOutputColumns;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::InitalizeLocalVariables - private
//
//  Arguments:  [variableSet]  - local variables from browser
//              [outputFormat] - format of numbers & dates
//
//  Synopsis:   Sets up the local variables for this query
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void CSeqQueryResultsIter::InitializeLocalVariables( CVariableSet & variableSet,
                                                     COutputFormat & outputFormat )
{
    //
    //  Setup the following variables:
    //
    //      CiContainsLastRecord
    //      CiFirstRecordNumber
    //

    CBaseQueryResultsIter::InitializeLocalVariables( variableSet, outputFormat );

    //
    //  Set CiFirstRecordNumber
    //
    PROPVARIANT Variant;
    Variant.vt   = VT_I4;
    Variant.lVal = _lFirstRecordNumber;
    _pVariableSet->SetVariable( ISAPI_CI_FIRST_RECORD_NUMBER, &Variant, 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     SetCGIVariables - public
//
//  History:    96-Mar-04   DwightKr    Created
//
//----------------------------------------------------------------------------

void SetCGIVariables( CVariableSet & variableSet, CWebServer & webServer )
{
    {
        XArray<WCHAR> xValue;
        ULONG         cwcValue;

        if ( webServer.GetCGI_REQUEST_METHOD( xValue, cwcValue ) )
            variableSet.SetVariable( ISAPI_REQUEST_METHOD, xValue );

        if ( webServer.GetCGI_PATH_INFO( xValue, cwcValue ) )
            variableSet.SetVariable( ISAPI_PATH_INFO, xValue );

        if ( webServer.GetCGI_PATH_TRANSLATED( xValue, cwcValue ) )
            variableSet.SetVariable( ISAPI_PATH_TRANSLATED, xValue );

        if ( webServer.GetCGI_CONTENT_TYPE( xValue, cwcValue ) )
            variableSet.SetVariable( ISAPI_CONTENT_TYPE, xValue );
    }

    //
    //  The HTTP variables can be obtained from ALL_HTTP.  attribute/value
    //  pairs are delimited by \n and the attribute is separated from
    //  the value by a colon.  For example:
    //
    //      HTTP_DWIGHT:This is a HTTP_DWIGHT\nHTTP_KRUGER:This is another\n...
    //

    XArray<WCHAR> wcsALLHTTP;
    ULONG         cwcALLHTTP;

    if ( webServer.GetCGIVariable( "ALL_HTTP",
                                    wcsALLHTTP,
                                    cwcALLHTTP ) )
    {
        WCHAR * wcsToken = wcsALLHTTP.Get();
        XArray<WCHAR> wcsCopyOfValue;

        while ( 0 != wcsToken )
        {
            WCHAR * wcsAttribute = wcsToken;
            wcsToken = wcschr( wcsToken, L'\n' );

            WCHAR * wcsValue = wcschr( wcsAttribute, L':' );

            if ( 0 != wcsValue )
            {
                *wcsValue++ = '\0';

                ULONG cwcValue;

                if (wcsToken)
                {
                    if ( wcsValue > wcsToken )
                        THROW( CException( E_INVALIDARG ) );

                    cwcValue = (ULONG)(wcsToken - wcsValue);
                    *wcsToken++ = '\0';
                }
                else
                {
                    cwcValue = wcslen( wcsValue );
                }

                wcsCopyOfValue.Init(cwcValue+1);
                RtlCopyMemory( wcsCopyOfValue.Get(), wcsValue, (cwcValue+1) * sizeof(WCHAR) );

                PROPVARIANT Variant;
                Variant.vt = VT_LPWSTR;
                Variant.pwszVal = wcsCopyOfValue.Get();

                variableSet.SetVariable( wcsAttribute,
                                         &Variant,
                                         eParamOwnsVariantMemory );

                wcsCopyOfValue.Acquire();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\ixsinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       ixsinfo.cxx
//
//  Contents:   Query SSO query information methods
//
//  History:    30 Jan 1997      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "ssodebug.hxx"

#include "ixsso.hxx"
#include "ixsinfo.hxx"

#include <cgiesc.hxx>
#include <string.hxx>
#include <tgrow.hxx>


//-----------------------------------------------------------------------------
// CixssoQuery Methods
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Function:   AddURLTerm - public inline
//
//  Synopsis:   Add a term to a URL QueryString
//
//  Arguments:  [vString]   - virtual string in which the result is accumulated
//              [pwszTerm]  - tag name, assumed to not need encoding
//              [pwszValue] - value part
//              [ulCodepage] - code page for URL encoding
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

inline void AddURLTerm(
    CVirtualString & vString,
    WCHAR * pwszTerm,
    WCHAR * pwszValue,
    ULONG   ulCodepage)
{
    if (vString.StrLen() > 0)
        vString.CharCat( L'&' );
    vString.StrCat(pwszTerm);
    URLEscapeW( pwszValue, vString, ulCodepage, TRUE );
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::QueryToURL - public
//
//  Synopsis:   Produce a URL QueryString from the state of the query object
//
//  Arguments:  [pbstrQueryString] - The URL-encoded query string is
//                                   returned here
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::QueryToURL(BSTR * pbstrQueryString)
{
    _err.Reset();

    SCODE sc = S_OK;
    CVirtualString vString( 512 );

    *pbstrQueryString = 0;
    TRY {

        if (_pwszCatalog)
        {
            AddURLTerm( vString, L"ct=", _pwszCatalog, _ulCodepage );
        }

        if (_pwszDialect)
        {
            AddURLTerm( vString, L"di=", _pwszDialect, _ulCodepage );
        }

        if (_pwszSort)
        {
            AddURLTerm( vString, L"so=", _pwszSort, _ulCodepage );
        }
        if (_pwszGroup)
        {
            AddURLTerm( vString, L"gr=", _pwszGroup, _ulCodepage );
        }
        if (_pwszRestriction)
        {
            AddURLTerm( vString, L"qu=", _pwszRestriction, _ulCodepage );
        }

        if (_maxResults)
        {
            WCHAR awchBuf[20];
            wsprintf(awchBuf, L"%d", _maxResults);
            AddURLTerm( vString, L"mh=", awchBuf, _ulCodepage );
        }

        if (_cFirstRows)
        {
            WCHAR awchBuf[20];
            wsprintf(awchBuf, L"%d", _cFirstRows);
            AddURLTerm( vString, L"fr=", awchBuf, _ulCodepage );
        }

        if (_StartHit.Get())
        {
            XGrowable<WCHAR> awchBuf;

            FormatLongVector( _StartHit.Get(), awchBuf );
            AddURLTerm( vString, L"sh=", awchBuf.Get(), _ulCodepage );
        }

        if (_fAllowEnumeration)
        {
            AddURLTerm( vString, L"ae=", L"1", _ulCodepage );
        }

        // OptimizeFor defaults to Hitcount
        if (_dwOptimizeFlags != eOptHitCount)
        {
            WCHAR awchBuf[4];
            unsigned i = 0;

            if (_dwOptimizeFlags & eOptPerformance)
                awchBuf[i++] = L'x';
            if (_dwOptimizeFlags & eOptRecall)
                awchBuf[i++] = L'r';
            if ( !(_dwOptimizeFlags & eOptHitCount) )
                awchBuf[i++] = L'h';
            awchBuf[i] = L'\0';

            AddURLTerm( vString, L"op=", awchBuf, _ulCodepage );
        }

        //
        // The URL encoded string is assembled.  Copy it into a BSTR for return.
        //
        BSTR bstr = SysAllocStringLen( vString.GetPointer(), vString.StrLen() );
        if (0 == bstr)
            THROW(CException( E_OUTOFMEMORY ) );
        *pbstrQueryString = bstr;
    }
    CATCH (CException, e)
    {
        sc = GetOleError( e );
    }
    END_CATCH

    if (FAILED(sc))
    {
        SetError( sc, OLESTR("QueryToURL") );
    }
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::SetQueryFromURL - public
//
//  Synopsis:   Parse a URL QueryString and update object state accordingly.
//
//  Arguments:  [bstrQueryString] - The input URL-encoded query string
//
//  History:    20 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::SetQueryFromURL(BSTR bstrQueryString)
{
    _err.Reset();

    SCODE sc = S_OK;

    TRY {

        CQueryInfo Info;

        ixssoDebugOut(( DEB_ITRACE, "QUERY_STRING = %ws\n", bstrQueryString ));

        //
        //  Parse the string, which has the following format:
        //
        //
        //      tag1=Value1&tag2=value2&tag3=value+%7c+0&foo&bar
        //

        unsigned cchBuffer = SysStringLen(bstrQueryString);
        WCHAR * pwszToken = (WCHAR *)bstrQueryString;

        while ( pwszToken && (L'\0' != *pwszToken) )
        {
            //
            //  Find the value on the right hand side of the equal sign.
            //
            WCHAR *pwszTag = pwszToken;
            WCHAR *pwszValue = wcschr( pwszTag, L'=' );

            if ( 0 != pwszValue )
            {
                unsigned cchTag = CiPtrToUint( pwszValue - pwszTag );
                pwszValue++;

                //
                //  Point to the next Tag.
                //
                pwszToken = wcschr( pwszToken, L'&' );

                ULONG cchValue;

                if ( 0 != pwszToken )
                {
                    if ( pwszToken < pwszValue )
                    {
                        //
                        // We have a construction like foo&bar=value.  Set
                        // the tag with a null value and go on to the next
                        // tag=value pair.
                        //
                        cchValue = 0;
                    }
                    else 
                        cchValue = CiPtrToUlong( pwszToken - pwszValue );

                    pwszToken++;
                }
                else
                {
                    cchValue = CiPtrToUlong( (WCHAR *)&bstrQueryString[cchBuffer] - pwszValue );
                }


                if ( 0 == cchValue )
                {
                    ixssoDebugOut(( DEB_ITRACE,
                                    "SetQueryFromURL - setting %.*ws=NULL\n",
                                     cchTag, pwszTag ));

                    XPtrST<WCHAR> xpValue( 0 );
                    Info.SetQueryParameter( pwszTag, xpValue );
                }
                else
                {
                    XGrowable<BYTE> achBuf( cchValue );
                    for ( unsigned i=0; i<cchValue; i++ )
                    {
                        Win4Assert( pwszValue[i] < 0x100 );
                        achBuf[i] = (BYTE) pwszValue[i];
                    }
                    XPtrST<WCHAR> xpwchValue( new WCHAR[cchValue+1] );

                    DecodeURLEscapes( achBuf.Get(),
                                      cchValue,
                                      xpwchValue.GetPointer(),
                                      _ulCodepage );

                    ixssoDebugOut(( DEB_ITRACE,
                                    "SetQueryFromURL - setting %.*ws=%ws\n",
                                    cchTag, pwszTag,
                                    xpwchValue.GetPointer() ));

                    Info.SetQueryParameter( pwszTag, xpwchValue );
                }
            }
            else if ( 0 != pwszToken )
            {
                //
                //  There was no tag=value pair found; a lonely '&' was
                //  found.  Skip it and proceed to the next '&'.
                //
                pwszToken = wcschr( pwszToken+1, L'&' );
            }
        }

        Info.MakeFinalQueryString();
        if (Info.GetQuery())
        {
            delete _pwszRestriction;
            _pwszRestriction = Info.AcquireQuery();
        }

        if (Info.GetCatalog())
        {
            delete _pwszCatalog;
            _pwszCatalog = Info.AcquireCatalog();
        }
        if ( Info.GetDialect() )
        {
            delete _pwszDialect;
            _pwszDialect = Info.AcquireDialect();
        }

        if (Info.GetSort())
        {
            delete _pwszSort;
            _pwszSort = Info.AcquireSort();
        }
        if (Info.GetGroup())
        {
            delete _pwszGroup;
            _pwszGroup = Info.AcquireGroup();
        }

        if (Info.GetMaxHits())
        {
            _maxResults = Info.GetMaxHits();
        }

        if (Info.GetFirstRows())
        {
            _cFirstRows = Info.GetFirstRows();
        }

        if (Info.GetStartHit().Count())
        {
            unsigned cHits = Info.GetStartHit().Count();
            SCODE sc;
    
            SAFEARRAY* psa;
            XSafeArray xsa;

            psa = SafeArrayCreateVector(VT_I4, 1, cHits);
            if( ! psa )
                THROW(CException( E_OUTOFMEMORY ));

            xsa.Set(psa);

            for (unsigned i=1; i<=cHits; i++)
            {
                long rgIx[1];
                LONG lVal = Info.GetStartHit().Get(i-1); 
                rgIx[0] = (long)i;
                sc = SafeArrayPutElement( xsa.Get(), rgIx, &lVal );

                if ( FAILED( sc ) )
                    THROW( CException( sc ) );
            }

            _StartHit.Destroy();
            _StartHit.Set( xsa.Acquire() );
        }

        if (Info.WasAllowEnumSet())
        {
            _fAllowEnumeration = Info.GetAllowEnum();
        }

        if (eOptHitCount != Info.GetOptimizeFor())
        {
            _dwOptimizeFlags = Info.GetOptimizeFor();
        }
    }
    CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        Win4Assert( !SUCCEEDED(sc) );
        SetError( sc, OLESTR("SetqueryFromURL"), eIxssoError );
    }
    AND_CATCH( CException, e )
    {
        sc = GetOleError( e );
        SetError( sc, OLESTR("SetQueryFromURL") );
    }
    END_CATCH

    return sc;
}

//-----------------------------------------------------------------------------
// CQueryInfo Methods
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Function:   EncodeTagString - inline
//
//  Synopsis:   Encode a one or two character tag into a DWORD value
//
//  Arguments:  [pwszTag]    - a pointer to the tag
//              [dwCodedTag] - the coded value which is returned
//              [iParam]     - the numeric value for the tag
//
//  Notes:      Tags consisting of one alpha character, two alpha characters
//              or one alpha followed by a numeric character are recognized
//              and converted into a DWORD (whose value just happens to be
//              the same as a one or two character character constant for the
//              alpha characters in the tag).  If the third form is recognized,
//              the iParam parameter gets the value of the numeric character,
//              otherwise iParam is zero.
//
//              dwCodedTag will be zero if pwszTag is not one of the allowed
//              forms.
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

inline void EncodeTagString( WCHAR const * pwszTag,
                             DWORD & dwCodedTag,
                             USHORT & iParam )
{
    dwCodedTag = 0;
    iParam = 0;
    if (0 == pwszTag || L'\0' == *pwszTag)
        return;

    if (isalpha(*pwszTag))
    {
        dwCodedTag = towupper(*pwszTag) & 0xFF;
        if (isalpha(pwszTag[1]))
        {
            dwCodedTag <<= 8;
            dwCodedTag |= (towupper(pwszTag[1]) & 0xFF);
        }
        else if (isdigit(pwszTag[1]))
            iParam = pwszTag[1] - L'0';
        else if (L'=' == pwszTag[1] ||
                 L'&' == pwszTag[1] ||
                 L'\0' == pwszTag[1])
            return;
        else
        {
            dwCodedTag = 0;
            return;
        }

        if ( L'=' != pwszTag[2] &&
             L'&' != pwszTag[2] &&
             L'\0' != pwszTag[2])
            dwCodedTag = 0;
    }
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryInfo::SetQueryParameter - public
//
//  Synopsis:   Process a QueryString parameter
//
//  Arguments:  [pwszTag] - the tag name for the parameter
//              [pwszValue] - the value for the parameter
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void CQueryInfo::SetQueryParameter( WCHAR const * pwszTag,
                                    XPtrST<WCHAR> & pwszValue )
{
    DWORD dwParamCode;
    USHORT iParam;

    EncodeTagString( pwszTag, dwParamCode, iParam );
    if (0 == dwParamCode)
        return;

    for (unsigned i=0; i<cQueryTagTable; i++)
        if (dwParamCode == aQueryTagTable[i].dwTagName)
            break;

    if (i == cQueryTagTable)
        return;

    i = aQueryTagTable[i].qtQueryTagType;

    switch (i)
    {
    case qtQueryFullText:
        AddToParam( _xpQuery, pwszValue );
        break;

    case qtMaxHits:
    {
        LONG cNum = 0;
        if (0 != pwszValue.GetPointer())
            cNum = _wtoi( pwszValue.GetPointer() );

        if (cNum > 0)
        {
            _maxHits = cNum;
        }
        else
        {
            ixssoDebugOut(( DEB_TRACE,
                    "CIxsQueryInfo::SetQueryParameter - invalid numeric %ws\n",
                    pwszValue.GetPointer() ));
        }
    }
        break;

    case qtFirstRows:
    {
        LONG cNum = 0;
        if (0 != pwszValue.GetPointer())
            cNum = _wtoi( pwszValue.GetPointer() );

        if (cNum > 0)
        {
            _cFirstRows = cNum;
        }
        else
        {
            ixssoDebugOut(( DEB_TRACE,
                    "CIxsQueryInfo::SetQueryParameter - invalid numeric %ws\n",
                    pwszValue.GetPointer() ));
        }
    }
        break;

    case qtStartHit:
        ParseNumberVectorString( pwszValue.GetPointer(), GetStartHit() );
        break;

    case qtCatalog:
        AddToParam( _xpCatalog, pwszValue );
        break;

    case qtDialect:
        AddToParam( _xpDialect, pwszValue );
        break;

    case qtSort:
        AddToParam( _xpSort, pwszValue );
        break;

    case qtSortDown:
        if (pwszValue.GetPointer())
            AddToParam( _xpSort, pwszValue, L",", L"[d]" );
        break;

#if IXSSO_CATEGORIZE == 1
    case qtGroup:
        AddToParam( _xpGroup, pwszValue );
        break;

    case qtGroupDown:
        if (pwszValue.GetPointer())
            AddToParam( _xpGroup, pwszValue, L",", L"[d]" );
        break;
#endif // IXSSO_CATEGORIZE == 1

    case qtAllowEnumeration:
        _fAllowEnumeration = 0 != pwszValue.GetPointer() &&
                             iswdigit(*pwszValue.GetPointer()) &&
                             *pwszValue.GetPointer() != L'0';
        _fSetAllowEnumeration = 1;
        break;

    case qtOptimizeFor:
    {
        WCHAR * pwszVal = pwszValue.GetPointer();

        while (pwszVal && *pwszVal)
        {
            WCHAR chKey = towupper(*pwszVal);

            if (chKey == L'X')
            {
                _dwOptimizeFor &= ~eOptRecall;
                _dwOptimizeFor |= eOptPerformance;
            }
            else if (chKey == L'R')
            {
                _dwOptimizeFor &= ~eOptPerformance;
                _dwOptimizeFor |= eOptRecall;
            }
            else if (chKey == L'H')
            {
                _dwOptimizeFor &= ~eOptHitCount;
            }
            // else if (chKey == L'P')
            //     _dwOptimizeFor |= eOptPrecision;

            pwszVal++;
        }
        break;
    }

    case qtColumn:
        Win4Assert( iParam >= 0 && iParam < 10 );
        SetBuiltupQueryTerm( _aQueryCol, iParam, pwszValue );
        break;

    case qtOperator:
        Win4Assert( iParam >= 0 && iParam < 10 );
        SetBuiltupQueryTerm( _aQueryOp, iParam, pwszValue );
        break;

    case qtQuery:
        Win4Assert( iParam >= 0 && iParam < 10 );
        SetBuiltupQueryTerm( _aQueryVal, iParam, pwszValue );
        break;

    default:
        ixssoDebugOut(( DEB_WARN, "SetQueryFromURL - reserved tag %.2ws\n", pwszTag ));
        THROW( CIxssoException(MSG_IXSSO_INVALID_QUERYSTRING_TAG, 0) );
        break;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryInfo::AddToParam - private
//
//  Synopsis:   Append a string to a parameter
//
//  Arguments:  [xpString] - A smart pointer to the string to be appended to
//              [pwszValue] - The value to be added to xpString
//              [pwszPre] - the separator for multiple values in xpString.
//                            Defaults to ','.
//              [pwszPost] - unconditionally appended to pwszValue
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void CQueryInfo::AddToParam( XPtrST<WCHAR> & xpString,
                             XPtrST<WCHAR> & pwszValue,
                             WCHAR const * pwszPre,
                             WCHAR const * pwszPost )
{
    unsigned cch = 0;

    if (0 == xpString.GetPointer())
    {
        if (0 == pwszPost)
        {
            xpString.Set( pwszValue.Acquire() );
        }
        else
        {
            if (pwszValue.GetPointer())
                cch = wcslen(pwszValue.GetPointer());

            xpString.Set( new WCHAR[cch + wcslen(pwszPost) + 1] );
            if (cch)
                wcsncpy(xpString.GetPointer(), pwszValue.GetPointer(), cch);
            wcscpy(xpString.GetPointer() + cch, pwszPost);
        }
        return;
    }

    cch = wcslen(xpString.GetPointer());
    cch += pwszPre ? wcslen(pwszPre) : wcslen(L",");
    if (pwszValue.GetPointer())
        cch += wcslen( pwszValue.GetPointer() );
    if (pwszPost)
        cch += wcslen( pwszPost );

    XPtrST<WCHAR> xpDest( new WCHAR[cch+1] );

    wcscpy(xpDest.GetPointer(), xpString.GetPointer());
    wcscat(xpDest.GetPointer(), pwszPre ? pwszPre : L",");
    if (pwszValue.GetPointer())
        wcscat(xpDest.GetPointer(), pwszValue.GetPointer());
    if (pwszPost)
        wcscat(xpDest.GetPointer(), pwszPost);

    xpString.Free();
    xpString.Set( xpDest.Acquire() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryInfo::SetBuiltupQueryTerm - private
//
//  Synopsis:   Add an individual partial query term to an array of terms.
//
//  Arguments:  [apString]   - A dynamic array of string pointers
//              [iTerm]     - The index of the term to be added
//              [pwszValue] - The value to be added to apString
//
//  Notes:      If the array entry for the term is already set, it is
//              overwritten.
//
//  History:    21 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void CQueryInfo::SetBuiltupQueryTerm( CDynArray<WCHAR> & apString,
                                      unsigned iTerm,
                                      XPtrST<WCHAR> & pwszValue )
{
    Win4Assert( iTerm < 10 );

    delete apString.Acquire(iTerm);
    apString.Add( pwszValue.GetPointer(), iTerm );
    pwszValue.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryInfo::MakeFinalQueryString - public
//
//  Synopsis:   Combine the built-up query terms into the complete query
//              restriction.
//
//  Arguments:  - NONE -
//
//  History:    20 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void CQueryInfo::MakeFinalQueryString( )
{
    //
    //  Add query terms to any pre-existing full query string
    //
    for (unsigned i = 0; i < 10; i++)
    {
        //  Ignore the term if the qn= part was not set.
        if ( _aQueryVal[i] != 0 )
        {
            XPtrST<WCHAR> xpStr(0);
            AddToParam( _xpQuery, xpStr, IMPLIED_QUERY_TERM_OPERATOR, L" ( ");

            if ( _aQueryCol[i] != 0 )
            {
                xpStr.Set( _aQueryCol.Acquire(i) );
                AddToParam( _xpQuery, xpStr, L"", L" ");
                xpStr.Free();
            }
            if ( _aQueryOp[i] != 0 )
            {
                xpStr.Set( _aQueryOp.Acquire(i) );
                AddToParam( _xpQuery, xpStr, L"", L" ");
                xpStr.Free();
            }
            if ( _aQueryVal[i] != 0 )
            {
                xpStr.Set( _aQueryVal.Acquire(i) );
                AddToParam( _xpQuery, xpStr, L"", L" ");
                xpStr.Free();
            }

            AddToParam( _xpQuery, xpStr, L")");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\ixsquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       ixsquery.cxx
//
//  Contents:   Query SSO active query state class
//
//  History:    29 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "ixsso.hxx"
#include "ssodebug.hxx"

#include <strrest.hxx>
#include <strsort.hxx>
#include <qlibutil.hxx>

#if CIDBG
#include <stdio.h>
#endif // CIDBG

#include <initguid.h>
#include <nlimport.h>

static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};

static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

static const GUID guidRowsetProps = DBPROPSET_ROWSET;


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::GetDefaultCatalog - private inline
//
//  Synopsis:   Initializes the _pwszCatalog member with the default catalog.
//
//  Arguments:  NONE
//
//  Notes:      The IS 2.0 implementation of ISCC::GetDefaultCatalog has two
//              flaws that are worked around here.  It should return the size
//              of the required string when zero is passed in as the input
//              length, and it should null terminate the output string.
//
//  History:    18 Dec 1996     AlanW   Created
//              21 Oct 1997     AlanW   Modified to use ISimpleCommandCreator
//
//----------------------------------------------------------------------------

inline void CixssoQuery::GetDefaultCatalog( )
{
    ixssoDebugOut(( DEB_ITRACE, "Using default catalog\n" ));

    ULONG cchRequired = 0;

    SCODE sc = _xCmdCreator->GetDefaultCatalog(0, 0, &cchRequired);

    if ( cchRequired == 0 )
    {
        // IS 2.0 doesn't return required path length
        cchRequired = MAX_PATH;
    }
    else if ( cchRequired > MAX_PATH )
    {
        THROW( CException(E_INVALIDARG) );
    }
    cchRequired++;                // make room for termination

    XArray<WCHAR> pwszCat ( cchRequired );
    sc = _xCmdCreator->GetDefaultCatalog(pwszCat.GetPointer(), cchRequired, &cchRequired);

    if (FAILED(sc))
        THROW( CException(sc) );

    Win4Assert( 0 == _pwszCatalog );
    _pwszCatalog = pwszCat.Acquire();

    // IS 2.0 does not transfer the null character at the end of the string.
    _pwszCatalog[ cchRequired ] = L'\0';

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   ParseCatalogs - public
//
//  Synopsis:   Parse a comma-separated catalog string, return the count
//              of catalogs and the individual catalog and machine names.
//
//  Arguments:  [pwszCatalog] - input catalog string
//              [aCatalogs] - array for returned catalog names
//              [aMachines] - array for returned machine names
//
//  Returns:    ULONG - number of catalogs
//
//  Notes:      
//
//  History:    18 Jun 1997      Alanw    Created
//
//----------------------------------------------------------------------------

ULONG ParseCatalogs( WCHAR * pwszCatalog,
                     CDynArray<WCHAR> & aCatalogs,
                     CDynArray<WCHAR> & aMachines )
{
    ULONG cCatalogs = 0;

    while ( 0 != *pwszCatalog )
    {
        // eat space and commas

        while ( L' ' == *pwszCatalog || L',' == *pwszCatalog )
            pwszCatalog++;

        if ( 0 == *pwszCatalog )
            break;

        WCHAR awchCat[MAX_PATH];
        WCHAR * pwszOut = awchCat;

        // is this a quoted path?

        if ( L'"' == *pwszCatalog )
        {
            pwszCatalog++;

            while ( 0 != *pwszCatalog &&
                    L'"' != *pwszCatalog &&
                    pwszOut < &awchCat[MAX_PATH] )
                *pwszOut++ = *pwszCatalog++;

            if ( L'"' != *pwszCatalog )
                THROW( CIxssoException( MSG_IXSSO_BAD_CATALOG, 0 ) );

            pwszCatalog++;
            *pwszOut++ = 0;
        }
        else
        {
            while ( 0 != *pwszCatalog &&
                    L',' != *pwszCatalog &&
                    pwszOut < &awchCat[MAX_PATH] )
                *pwszOut++ = *pwszCatalog++;

            if ( pwszOut >= &awchCat[MAX_PATH] )
                THROW( CIxssoException( MSG_IXSSO_BAD_CATALOG, 0 ) );

            // back up over trailing spaces

            while ( L' ' == * (pwszOut - 1) )
                pwszOut--;

            *pwszOut++ = 0;
        }

        XPtrST<WCHAR> xpCat;
        XPtrST<WCHAR> xpMach;
        SCODE sc = ParseCatalogURL( awchCat, xpCat, xpMach );
        if (FAILED(sc) || xpCat.IsNull() )
            THROW( CIxssoException( MSG_IXSSO_BAD_CATALOG, 0 ) );

        aCatalogs.Add(xpCat.GetPointer(), cCatalogs);
        xpCat.Acquire();
        aMachines.Add(xpMach.GetPointer(), cCatalogs);
        xpMach.Acquire();

        cCatalogs++;
    }

    if ( 0 == cCatalogs )
        THROW( CIxssoException( MSG_IXSSO_BAD_CATALOG, 0 ) );

    return cCatalogs;
} //ParseCatalogs


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::GetDialect - private
//
//  Synopsis:   Parses the dialect string and returns ISQLANG_V*
//
//  Returns:    The dialect identifier
//
//  History:    19 Nov 1997      dlee       Created
//              03 Dec 1998      KrishnaN   Defaulting to version 2
//
//----------------------------------------------------------------------------
ULONG CixssoQuery::GetDialect()
{
    if ( 0 == _pwszDialect )
        return ISQLANG_V2;

    ULONG ul = _wtoi( _pwszDialect );
    if ( ul < ISQLANG_V1 || ul > ISQLANG_V2 )
        return ISQLANG_V2;

    return ul;
} //GetDialect

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::ExecuteQuery - private
//
//  Synopsis:   Executes the query and builds an IRowset or IRowsetScroll
//              as necessary.
//
//  Arguments:  NONE
//
//  History:    29 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

void CixssoQuery::ExecuteQuery( )
{
    Win4Assert( 0 == _pIRowset );     // Should not have executed query

    //
    //  Setup the variables needed to execute this query; including:
    //
    //      Query
    //      MaxRecords
    //      SortBy
    //

    ixssoDebugOut(( DEB_TRACE, "ExecuteQuery:\n" ));
    ixssoDebugOut(( DEB_TRACE, "\tQuery = '%ws'\n", _pwszRestriction ));
    if ( 0 == _pwszRestriction || 0 == *_pwszRestriction )
    {
        THROW( CIxssoException(MSG_IXSSO_MISSING_RESTRICTION, 0) );
    }


    ixssoDebugOut(( DEB_TRACE, "\tMaxRecords = %d\n", _maxResults ));
    ixssoDebugOut(( DEB_TRACE, "\tFirstRowss = %d\n", _cFirstRows ));

    //
    //  Get the columns in the query
    //
    ixssoDebugOut(( DEB_TRACE, "\tColumns = '%ws'\n", _pwszColumns ));
    if ( 0 == _pwszColumns || 0 == *_pwszColumns )
    {
        THROW( CIxssoException(MSG_IXSSO_MISSING_OUTPUTCOLUMNS, 0) );
    }

    if ( 0 != _pwszGroup && 0 != *_pwszGroup && _fSequential )
    {
        // Grouped queries are always non-sequential.
        _fSequential = FALSE;
    }

    //
    // Convert the textual form of the restriction, output columns and
    // sort columns into a DBCOMMANDTREE.
    //
    if (InvalidLCID == _lcid)
    {
        THROW( CIxssoException(MSG_IXSSO_INVALID_LOCALE, 0) );
    }

    ULONG ulDialect = GetDialect();

    CTextToTree textToTree( _pwszRestriction,
                            ulDialect,
                            _pwszColumns,
                            GetColumnMapper(),
                            _lcid,
                            _pwszSort,
                            _pwszGroup,
                            0,
                            _maxResults,
                            _cFirstRows,
                            TRUE            // Keep the friendly column names
                          );


    CDbCmdTreeNode * pDbCmdTree =  (CDbCmdTreeNode *) (void *) textToTree.FormFullTree();
    XPtr<CDbCmdTreeNode> xDbCmdTree( pDbCmdTree );

    CDynArray<WCHAR>    apCatalog;
    CDynArray<WCHAR>    apMachine;

    //
    //  Get the location of the catalog.  Use the default if the catalog
    //  property is not set.
    //
    if ( 0 == _pwszCatalog )
    {
        GetDefaultCatalog();
        if ( 0 == _pwszCatalog )
            THROW( CIxssoException(MSG_IXSSO_NO_SUCH_CATALOG, 0) );
    }
    
    ixssoDebugOut(( DEB_TRACE, "\tCatalog = '%ws'\n", _pwszCatalog ));
    ULONG cCatalogs = ParseCatalogs( _pwszCatalog, apCatalog, apMachine );

    //
    //  Get the scope specification(s) for the query
    //    CiScope
    //    CiFlags
    //

    Win4Assert( _cScopes <= _apwszScope.Size() );

    for ( unsigned i = 0; i < _cScopes; i++)
    {
#   if CIDBG
        char szIdx[10] = "";
        if (_cScopes > 1)
            sprintf( szIdx, " [%d]", i );
#   endif // CIDBG

        ixssoDebugOut(( DEB_TRACE, "\tCiScope%s = '%ws'\n", szIdx, _apwszScope[i] ));

        //
        //  Get the query flags.
        //

        if (i >= _aulDepth.Count())
            _aulDepth[i] = QUERY_DEEP;
        if ( IsAVirtualPath( _apwszScope[i] ) )
            _aulDepth[i] |= QUERY_VIRTUAL_PATH;

        ixssoDebugOut(( DEB_TRACE, "\tCiFlags%s = '%ws'\n", szIdx,
                                      _aulDepth.Get(i) & QUERY_DEEP ? L"DEEP":L"SHALLOW" ));
    }

    //
    //  We've setup all the parameters to run the query.  Run the query
    //  now.
    //
    IUnknown * pIUnknown;
    ICommand *pCommand = 0;

    SCODE sc = _xCmdCreator->CreateICommand(&pIUnknown, 0);

    if (SUCCEEDED (sc)) 
    {
       XInterface<IUnknown> xUnk( pIUnknown );
       sc = pIUnknown->QueryInterface(IID_ICommand, (void **)&pCommand);
    }

    if ( 0 == pCommand )
    {
        THROW( CIxssoException(sc, 0) );
    }

    XInterface<ICommand> xICommand(pCommand);

    if (0 == _cScopes)
    {
        //
        // Default path: search everywhere
        //

        const WCHAR * pwszPath = L"\\";

        DWORD dwDepth = QUERY_DEEP;

        if ( 1 == cCatalogs )
        {
            SetScopeProperties( pCommand,
                                1,
                                &pwszPath,
                                &dwDepth,
                                apCatalog.GetPointer(),
                                apMachine.GetPointer() );
        }
        else
        {
            SetScopeProperties( pCommand,
                                1,
                                &pwszPath,
                                &dwDepth,
                                0,
                                0 );

            SetScopeProperties( pCommand,
                                cCatalogs,
                                0,
                                0,
                                apCatalog.GetPointer(),
                                apMachine.GetPointer() );
        }
    }
    else
    {
        SetScopeProperties( pCommand,
                            _cScopes,
                            (WCHAR const * const *)_apwszScope.GetPointer(),
                            _aulDepth.GetPointer(),
                            0,
                            0 );

        SetScopeProperties( pCommand,
                            cCatalogs,
                            0,
                            0,
                            apCatalog.GetPointer(),
                            apMachine.GetPointer() );
    }

    ICommandTree * pICmdTree = 0;
    sc = xICommand->QueryInterface(IID_ICommandTree, (void **)&pICmdTree);
    if (FAILED (sc) )
    {
        THROW( CException( QUERY_EXECUTE_FAILED ) );
    }

    DBCOMMANDTREE * pDbCommandTree = pDbCmdTree->CastToStruct();
    sc = pICmdTree->SetCommandTree(&pDbCommandTree, DBCOMMANDREUSE_NONE, FALSE);
    pICmdTree->Release();

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    xDbCmdTree.Acquire();

    //
    //  Set properties on the command object.
    //
    const unsigned MAX_PROPS = 5;
    DBPROPSET  aPropSet[MAX_PROPS];
    DBPROP     aProp[MAX_PROPS];
    ULONG      cProp = 0;
    ULONG      iHitCountProp = MAX_PROPS;

    // Set the property that says whether we want to enumerate

    Win4Assert( cProp < MAX_PROPS );
    ixssoDebugOut(( DEB_TRACE, "\tUseContentIndex = %s\n",
                       _fAllowEnumeration ? "FALSE" : "TRUE" ));

    aProp[cProp].dwPropertyID = DBPROP_USECONTENTINDEX;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = _fAllowEnumeration ? VARIANT_FALSE :
                                                        VARIANT_TRUE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = guidQueryExt;

    cProp++;

    // Set the property for retrieving hit count

    Win4Assert( cProp < MAX_PROPS );
    ixssoDebugOut(( DEB_TRACE, "\tNlHitCount = %s\n",
                    ( _dwOptimizeFlags & eOptHitCount ) ? "TRUE" :
                                                          "FALSE" ));

    aProp[cProp].dwPropertyID = NLDBPROP_GETHITCOUNT;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = 
              ( _dwOptimizeFlags & eOptHitCount ) ? VARIANT_TRUE :
                                                    VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_NLCOMMAND;

    iHitCountProp = cProp;

    cProp++;

    if ( _dwOptimizeFlags & eOptPerformance )
    {
        // Set the property for magically fast queries

        Win4Assert( cProp < MAX_PROPS );
        ixssoDebugOut(( DEB_TRACE, "\tCiDeferNonIndexedTrimming = TRUE\n" ));

        aProp[cProp].dwPropertyID = DBPROP_DEFERNONINDEXEDTRIMMING;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_BOOL;
        aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidQueryExt;

        cProp++;
    }

    // set the start hit property if it is set
    if ( _StartHit.Get() )
    {
        // Set the start hit property
        Win4Assert( cProp < MAX_PROPS );
        ixssoDebugOut(( DEB_TRACE, "\tStartHit = %x\n", _StartHit.Get() ));
        
        aProp[cProp].dwPropertyID           = NLDBPROP_STARTHIT;
        aProp[cProp].dwOptions              = 0;
        aProp[cProp].dwStatus               = 0;         // Ignored
        aProp[cProp].colid                  = dbcolNull;
        V_VT(&(aProp[cProp].vValue))        = VT_ARRAY | VT_I4;
        V_ARRAY(&(aProp[cProp].vValue))     = _StartHit.Get();

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = DBPROPSET_NLCOMMAND;

        cProp++;
    }

    if ( 0 != _iResourceFactor )
    {
        // Set the query timeout in milliseconds

        Win4Assert( cProp < MAX_PROPS );
        aProp[cProp].dwPropertyID = DBPROP_COMMANDTIMEOUT;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_I4;
        aProp[cProp].vValue.lVal  = _iResourceFactor;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidRowsetProps;

        cProp++;
    }

    if ( cProp > 0 )
    {

        ICommandProperties * pCmdProp = 0;
        sc = xICommand->QueryInterface(IID_ICommandProperties,
                                       (void **)&pCmdProp);

        if (FAILED (sc) )
        {
            THROW( CException( QUERY_EXECUTE_FAILED ) );
        }

        sc = pCmdProp->SetProperties( cProp, aPropSet );
        pCmdProp->Release();

        if ( DB_S_ERRORSOCCURRED == sc ||
             DB_E_ERRORSOCCURRED == sc )
        {
            // Ignore an 'unsupported' error trying to set the GetHitCount
            // property.

            unsigned cErrors = 0;
            for (unsigned i = 0; i < cProp; i++)
            {
                if ( i == iHitCountProp &&
                     aProp[i].dwStatus == DBPROPSTATUS_NOTSUPPORTED )
                    continue;

                if (aProp[i].dwStatus != DBPROPSTATUS_OK)
                    cErrors++;
            }
            if ( 0 == cErrors )
                sc = S_OK;
        }

        if ( FAILED(sc) || DB_S_ERRORSOCCURRED == sc )
        {
            THROW( CException( QUERY_EXECUTE_FAILED ) );
        }
    }
    //
    //  Execute the query
    //
    sc = xICommand->Execute( 0,                    // No aggr
                          IsSequential() ? IID_IRowset : IID_IRowsetExactScroll,
                          0,                    // disp params
                          0,            // # rowsets returned
                          (IUnknown **) &_pIRowset );


    if ( FAILED(sc) )
    {
        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        SCODE sc2 = GetOleDBErrorInfo(xICommand.GetPointer(),
                                       IID_ICommand,
                                       _lcid,
                                       eMostDetailedCIError,
                                       &ErrorInfo,
                                       (IErrorInfo **)xErrorInfo.GetQIPointer());
        // Post IErrorInfo only if we have a valid ptr to it
        if (SUCCEEDED(sc2) && 0 != xErrorInfo.GetPointer())
        {
            sc = ErrorInfo.hrError;
            THROW( CPostedOleDBException(sc, xErrorInfo.GetPointer()) );
        }
        else
            THROW( CException(sc) );
    }

    xICommand.Acquire()->Release();

    //
    //  Create some of the restriction specific variables.
    //

    //
    // Get _pIRowsetQueryStatus interface
    //
    sc = _pIRowset->QueryInterface( IID_IRowsetQueryStatus,
                                    (void **) &_pIRowsetQueryStatus );

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    Win4Assert( 0 != _pIRowsetQueryStatus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::GetQueryStatus - private
//
//  Synopsis:   If a query is active, returns the query status
//
//  Arguments:  NONE
//
//  Returns:    DWORD - query status
//
//  History:    15 Nov 1996      Alanw    Created
//
//----------------------------------------------------------------------------

DWORD CixssoQuery::GetQueryStatus( )
{
    DWORD dwStatus = 0;

    SCODE sc;
    if ( ! _pIRowsetQueryStatus )
        THROW( CIxssoException(MSG_IXSSO_NO_ACTIVE_QUERY, 0) );

    sc = _pIRowsetQueryStatus->GetStatus( &dwStatus );
    if ( ! SUCCEEDED(sc) )
        THROW( CException( sc ) );

    return dwStatus;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::IsAVirtualPath - private
//
//  Synopsis:   Determines if the path passed is a virtual or physical path.
//              If it's a virtual path, then / are changed to \.
//
//  History:    96-Feb-14   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL CixssoQuery::IsAVirtualPath( WCHAR * wcsPath )
{
    Win4Assert ( 0 != wcsPath );
    if ( 0 == wcsPath[0] )
    {
        return TRUE;
    }

    if ( (L':' == wcsPath[1]) || (L'\\' == wcsPath[0]) )
    {
        return FALSE;
    }
    else
    {
        //
        //  Flip slashes to backslashes
        //

        for ( WCHAR *wcsLetter = wcsPath;
              *wcsLetter != 0;
              wcsLetter++
            )
        {
            if ( L'/' == *wcsLetter )
            {
                *wcsLetter = L'\\';
            }
        }

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\dll\wqlocale.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       wqlocale.cxx
//
//  Contents:   WEB Query locale parsers
//
//  History:    96/May/2    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   GetBrowserLCID - public
//
//  Synposis:   Determines the locale from the browser's HTTP_ACCEPT_LANGUAGE
//              Note that the browser may not send a language, in which case
//              we will default to the web servers default language.
//
//  Arguments:  [webServer] the web service which can return the environment
//                          variable HTTP_ACCEPT_LANGUAGE.
//              [wcsHttpLanguage] - buffer to accept the language
//
//  History:    20-Jan-96   DwightKr    Created
//              11-Jun-97   KyleP       Initialize ccHttpLanguage!
//
//----------------------------------------------------------------------------

LCID GetBrowserLCID( CWebServer & webServer, XArray<WCHAR> & wcsHttpLanguage )
{
    //
    // Don't look it up twice!
    //

    if ( webServer.IsLCIDValid() )
    {
        wcsHttpLanguage.Init( webServer.LocaleSize() );
        RtlCopyMemory( wcsHttpLanguage.GetPointer(),
                       webServer.GetLocale(),
                       webServer.LocaleSize() * sizeof(WCHAR) );

        return webServer.GetLCID();
    }

    //
    // Try the hard way...
    //

    CHAR  aszHttpLanguage[512];
    ULONG ccHttpLanguage = sizeof(aszHttpLanguage);

    if ( !webServer.GetCGIVariable( "HTTP_ACCEPT_LANGUAGE",
                                    aszHttpLanguage,
                                    &ccHttpLanguage) )
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "GetBrowserLCID: HTTP_ACCEPT_LANGAUGE was not set in the environment; using lcid=0x%x\n",
                        GetSystemDefaultLCID() ));

        LCID locale = GetSystemDefaultLCID();
        WCHAR wcsLocale[100];
        GetStringFromLCID( locale, wcsLocale );
        ULONG cwcLocale = wcslen(wcsLocale) + 1;

        wcsHttpLanguage.Init( cwcLocale );
        RtlCopyMemory( wcsHttpLanguage.GetPointer(),
                       wcsLocale,
                       cwcLocale*sizeof(WCHAR) );

        webServer.SetLCID( locale, wcsLocale, cwcLocale );
        return locale;
    }

    //
    //  Use the system's ANSI code page here since we're trying to figure
    //  out which code page to use.  The default code page is likely
    //  correct since all of the locale names are simple strings containing
    //  only characters A-Z.
    //

    unsigned cwcLocale = MultiByteToXArrayWideChar( (BYTE const *) aszHttpLanguage,
                                                    ccHttpLanguage,
                                                    GetACP(),
                                                    wcsHttpLanguage );

    LCID lcid = GetLCIDFromString( wcsHttpLanguage.GetPointer() );

    if ( InvalidLCID == lcid )
        lcid = GetSystemDefaultLCID();

    webServer.SetLCID( lcid,
                       wcsHttpLanguage.GetPointer(),
                       cwcLocale + 1 );
    return lcid;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetQueryLocale - public
//
//  Synposis:   Determines the locale in both a string and LCID form
//
//  Arguments:  [wcsCiLocale]  - locale string from a IDQ/IDA file
//              [variableSet]  - set of replaceable parameters
//              [outputFormat] - format for replaceable parameters
//              [xLocale]      - the string representation of the locale
//
//  History:    02-May-96   DwightKr    Created
//              11-Jun-97   KyleP       Use web server from output format
//
//----------------------------------------------------------------------------
LCID GetQueryLocale( WCHAR const * wcsCiLocale,
                     CVariableSet & variableSet,
                     COutputFormat & outputFormat,
                     XArray<WCHAR> & xLocale )
{
    ULONG cwcLocale;
    WCHAR * wcsLocale = ReplaceParameters( wcsCiLocale,
                                           variableSet,
                                           outputFormat,
                                           cwcLocale );
    LCID  locale = InvalidLCID;

    //
    //  If a locale was specified by the IDQ file, load its numeric
    //  representation here.
    //
    if ( 0 != wcsLocale )
    {
        xLocale.Set( cwcLocale+1, wcsLocale );
        locale = GetLCIDFromString( xLocale.GetPointer() );

        if ( InvalidLCID == locale )
        {
            delete xLocale.Acquire();
            outputFormat.LoadNumberFormatInfo( GetBrowserLCID( outputFormat, xLocale ) );

            THROW( CIDQException(MSG_CI_IDQ_INVALID_LOCALE, 0) );
        }
    }
    else
    {
        //
        //  If no locale was found in the IDQ file read the locale from
        //  the browser.  If the browser did not specify a locale, we'll
        //  use the system's locale.
        //

        locale = GetBrowserLCID( outputFormat, xLocale );
    }

    return locale;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\ixserror.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997-1998, Microsoft Corporation.
//
//  File:       ixserror.cxx
//
//  Contents:   SSO Error class
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop


//-----------------------------------------------------------------------------
// Include Files
//-----------------------------------------------------------------------------


// debugging macros
#include "ssodebug.hxx"

// class declaration
#include "ixserror.hxx"


//-----------------------------------------------------------------------------
//
//  Member:     CixssoError::SetError - private
//
//  Synopsis:   Save error information
//
//  Arguments:  [scError]   - Error code
//              [iLine]     - (optional) line number where error occurred
//              [pwszFile]  - (optional) file name where error occurred
//              [pwszLoc]   - Location from which error was generated
//              [eErrClass] - error class, indicates error message file
//
//  Notes:
//
//  History:    07 Jan 1997      Alanw    Created
//
//-----------------------------------------------------------------------------

extern HINSTANCE g_hInst;
extern WCHAR * g_pwszErrorMsgFile;

#define ERROR_MESSAGE_SIZE 512

void CixssoError::SetError(
    SCODE scError,
    ULONG iLine,
    WCHAR const * pwszFile,
    WCHAR const * pwszLoc,
    unsigned eErrClass,
    LCID lcid)
{
    // Has the error already been handled? If so, return.
    if ( _sc != 0)
        return;

    if ( QUERY_E_DUPLICATE_OUTPUT_COLUMN == scError  )
    {
        scError =  MSG_IXSSO_DUPLICATE_COLUMN;
        eErrClass = eIxssoError;
    }
    else if ( QUERY_E_INVALID_OUTPUT_COLUMN == scError )
    {
        scError = MSG_IXSSO_NO_SUCH_COLUMN_PROPERTY;
        eErrClass = eIxssoError;
    }

    // Does this error (possibly transalted) already exist on the error stack?
    // If it does, and it has a description, we shouldn't be doing anything else.

    if (FALSE == NeedToSetError(scError))
        return;

    ixssoDebugOut(( DEB_ITRACE, "SetError: sc = %x, loc = %ws\n", scError, pwszLoc ));

    WCHAR awcsErrorMessage[ERROR_MESSAGE_SIZE];
    WCHAR *pwszErrorMessage = awcsErrorMessage;
    ULONG cchAvailMessage = ERROR_MESSAGE_SIZE;

    //
    //  Generate the Win32 error code by removing the facility code (7) and
    //  the error bit.
    //
    ULONG Win32status = scError;
    if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
    {
        Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );
    }

    //
    // Don't pass a specific lang id to FormatMessage since it will
    // fail if there's no message in that language. Instead set
    // the thread locale, which will get FormatMessage to use a search
    // algorithm to find a message of the appropriate language or
    // use a reasonable fallback msg if there's none.
    //
    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale(lcid);

    //  Precede the error message by the file/line if passed.
    if (pwszFile != 0)
    {
        UINT_PTR args [] = {
                         (UINT_PTR) pwszFile,
                         (UINT_PTR) iLine,
                        };

        NTSTATUS MsgNum = MSG_IXSSO_FILE_MESSAGE;
        if (iLine != 0)
        {
            MsgNum = MSG_IXSSO_FILE_LINE_MESSAGE;
        }

        ULONG cchMsg = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      g_hInst,
                                      MsgNum,
                                      0,
                                      pwszErrorMessage,
                                      cchAvailMessage,
                                      (va_list *) args );
        pwszErrorMessage += cchMsg;
        cchAvailMessage -= cchMsg;
    }

    BOOL fSystemError = FALSE;

    switch (eErrClass)
    {
    case eIxssoError:
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              g_hInst,
                              scError,
                              0,
                              pwszErrorMessage,
                              cchAvailMessage,
                              0 ) )
        {
            ixssoDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                      L"Error 0x%x caught while processing query\n",
                      scError );
        }
    break;

    case ePlistError:
    case eParseError:
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle(g_pwszErrorMsgFile),
                              scError,
                              0,
                              pwszErrorMessage,
                              cchAvailMessage,
                              0 ) )
        {
            ixssoDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                      L"Error 0x%x caught while parsing query or other fields\n",
                      scError );
        }
    break;

    case eDefaultError:
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                               g_hInst,
                               scError,
                               0,
                               pwszErrorMessage,
                               cchAvailMessage,
                               0 ) )
        {
            if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                   GetModuleHandle(g_pwszErrorMsgFile),
                                   scError,
                                   0,
                                   pwszErrorMessage,
                                   cchAvailMessage,
                                   0 ) )
            {
                //
                //  Try looking up the error in the Win32 list of error codes
                //
                if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                       GetModuleHandle(L"kernel32.dll"),
                                       Win32status,
                                       0,
                                       pwszErrorMessage,
                                       cchAvailMessage,
                                       0 ) )
                {
                    ixssoDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

                    swprintf( pwszErrorMessage,
                              L"Error 0x%x caught while processing query\n",
                              scError );
                }
                else
                {
                    fSystemError = TRUE;
                }
            }
        }
        break;

    default:
        Win4Assert( !"Unrecognized error class" );
        break;
    }
    SetThreadLocale(SaveLCID);

    SetError( scError, pwszLoc, awcsErrorMessage );
}

//-----------------------------------------------------------------------------
//
//  Member:     CixssoError::SetError - private
//
//  Synopsis:   Save error information
//
//  Arguments:  [scError]         - Error code
//              [pwszLoc]         - Location from which error was generated
//              [pwszDescription] - Error description
//
//  Notes:
//
//  History:    06 May 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------

void CixssoError::SetError( SCODE scError,
                            WCHAR const * pwszLoc,
                            WCHAR const * pwszDescription)
{
    // Has the error on this object already been set?
    if (_sc != 0)
        return;

    // We should be here only if an error has NOT already been set.
    Win4Assert(NeedToSetError(scError));

    Win4Assert(pwszLoc && pwszDescription);

    ixssoDebugOut(( DEB_ITRACE,
                    "SetError: sc = %x, loc = %ws,\n\tdescription = %ws\n",
                    scError, pwszLoc, pwszDescription ));

    _fErr = TRUE;
    _sc = scError;

    //
    //  Create an error info object giving the error message
    //
    ICreateErrorInfo * pErrorInfo;
    SCODE sc = CreateErrorInfo( &pErrorInfo );
    if (SUCCEEDED( sc ))
    {
        XInterface<ICreateErrorInfo> pErr(pErrorInfo);
        pErrorInfo = 0;

        pErr->SetDescription( (LPWSTR) pwszDescription );
        pErr->SetGUID( _iid );
        pErr->SetSource( (LPWSTR) pwszLoc );  // Cast ok.  Never touched by anyone.

        IErrorInfo * pErrInfo = 0;
        sc = pErr->QueryInterface( IID_IErrorInfo, (void **)&pErrInfo);
        if (SUCCEEDED(sc))
        {
            SetErrorInfo(0, pErrInfo);
            pErrInfo->Release();
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     CixssoError::NeedToSetError - private
//
//  Synopsis:   Determine if error needs to be set.
//
//  Arguments:  [scError]         - Error code to look for
//
//  Returns:    TRUE if the error needs to be set. FALSE, if it already
//              exists and has a valid description string.
//
//  Notes:
//
//  History:    15 Jan 1998      KrishnaN    Created
//
//-----------------------------------------------------------------------------

BOOL CixssoError::NeedToSetError(SCODE scError)
{
    BOOL fFound = FALSE;

    //
    // Get the current error object. Return TRUE if none exists.
    //

    XInterface<IErrorInfo> xErrorInfo;

    SCODE sc = GetErrorInfo(0, (IErrorInfo **)xErrorInfo.GetQIPointer());
    if ( S_FALSE == sc )
    {
        Win4Assert(0 == xErrorInfo.GetPointer());
        return TRUE;
    }

    // Get the IErrorRecord interface and get the count of errors.
    XInterface<IErrorRecords> xErrorRecords;
    XBStr xDescription;
    BSTR pDescription = xDescription.GetPointer();

    sc = xErrorInfo->QueryInterface(IID_IErrorRecords, xErrorRecords.GetQIPointer());
    if (0 == xErrorRecords.GetPointer())
    {
        // No error records. Do we at least have the top level description set?
        // If so, that indicates an automation client called SetErrorInfo before us
        // and we should not overwrite them.
        xErrorInfo->GetDescription(&pDescription);
        fFound = ( pDescription != 0 ) ;
    }
    else
    {
        ULONG cErrRecords;
        sc = xErrorRecords->GetRecordCount(&cErrRecords);
        Win4Assert(!fFound);

        // look for the target error code. stop when one is found
        ERRORINFO ErrorInfo;
        for (ULONG i = 0; i < cErrRecords; i++)
        {
            sc = xErrorRecords->GetBasicErrorInfo(i, &ErrorInfo);
            Win4Assert(S_OK == sc);

            if (scError == ErrorInfo.hrError)
            {
                xErrorInfo->GetDescription(&pDescription);
                fFound = ( pDescription != 0 );
                break;
            }
        }
    }

    if (!fFound)
        return TRUE;

    // we found the error code and it has a description.
    // no need to set this error again, but we have to
    // put this error info back so the client can find it.
    SetErrorInfo(0, xErrorInfo.GetPointer());
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\ixsso.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2002.
//
//  File:       ixsso.cxx
//
//  Contents:   Query SSO class
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

//-----------------------------------------------------------------------------
// Include Files
//-----------------------------------------------------------------------------


// debugging macros
#include "ssodebug.hxx"

DECLARE_INFOLEVEL( ixsso )

// class declaration
#include "stdcf.hxx"
#include "ixsso.hxx"
#include <string.hxx>
#include <codepage.hxx>

#include <initguid.h>
#include <adoid.h>          // ADO CLSID and IID definitions
#include <adoint.h>         // ADO interface definition

const WCHAR * pwcDefaultDialect = L"2";

extern WCHAR * g_pwszProgIdQuery;

#if CIDBG
    extern ULONG g_ulObjCount;
    extern LONG  g_lQryCount;
#endif // CIDBG

//-----------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CixssoQuery - public
//
//  Synopsis:   Constructor of CixssoQuery
//
//  Arguments:  [pitlb] - pointer to ITypeLib for ixsso
//              [pIAdoRecordsetCF] - pointer to the class factory for ADO
//                        recordsets
//
//  History:    06 Nov 1996      Alanw    Created
//
//-----------------------------------------------------------------------------

CixssoQuery::CixssoQuery( ITypeLib * pitlb,
                          IClassFactory * pIAdoRecordsetCF,
                          BOOL fAdoV15,
                          const CLSID & ssoClsid) :
    _pwszRestriction( 0 ),
    _pwszSort( 0 ),
    _pwszGroup( 0 ),
    _pwszColumns( 0 ),
    _pwszCatalog( 0 ),
    _pwszDialect( 0 ),
    _cScopes( 0 ),
    _apwszScope( 0 ),
    _aulDepth( 0 ),

    _fAllowEnumeration( FALSE ),
    _dwOptimizeFlags( eOptHitCount | eOptRecall ),
    _maxResults( 0 ),
    _cFirstRows( 0 ),
    _iResourceFactor( 0 ),

    _StartHit( 0 ),

    _lcid( GetSystemDefaultLCID() ),
    _ulCodepage( CP_ACP ),
    _err( IID_IixssoQuery ),
    _pIAdoRecordsetCF( pIAdoRecordsetCF ),
    _fAdoV15( fAdoV15 ),
    _pIRowset( 0 ),
    _pIRowsetQueryStatus( 0 ),
    _fSequential( FALSE ),
    _PropertyList( _ulCodepage )
{
    _cRef = 1;
    Win4Assert(g_pTheGlobalIXSSOVariables);


    SCODE sc;
    
    if ( CLSID_CissoQueryEx == ssoClsid )
    {
        _err = IID_IixssoQueryEx;
        sc = pitlb->GetTypeInfoOfGuid( IID_IixssoQueryEx, &_ptinfo );
    }
    else if ( CLSID_CissoQuery == ssoClsid )
    {
        sc = pitlb->GetTypeInfoOfGuid( IID_IixssoQuery, &_ptinfo );
    }
    else 
        THROW( CException(E_INVALIDARG));

    if (FAILED(sc))
    {
        ixssoDebugOut(( DEB_ERROR, "GetTypeInfoOfGuid failed (%x)\n", sc ));
        Win4Assert(SUCCEEDED(sc));

        THROW( CException(sc) );
    }

#if CIDBG
    LONG cAdoRecordsetRefs =
#endif // CIDBG
        _pIAdoRecordsetCF->AddRef();

    XInterface<IColumnMapper> xColumnMapper;
    ISimpleCommandCreator *pCmdCreator = 0;

    pCmdCreator = g_pTheGlobalIXSSOVariables->xCmdCreator.GetPointer();
    g_pTheGlobalIXSSOVariables->xColumnMapperCreator->GetColumnMapper(
                                LOCAL_MACHINE,
                                INDEX_SERVER_DEFAULT_CAT,
                                (IColumnMapper **)xColumnMapper.GetQIPointer());

    if (0 == pCmdCreator)
        THROW(CException(REGDB_E_CLASSNOTREG));

    _xCmdCreator.Set(pCmdCreator);
#if CIDBG
    LONG cCmdCreatorRefs =
#endif // CIDBG
        pCmdCreator->AddRef();
    Win4Assert(xColumnMapper.GetPointer());
    _PropertyList.SetDefaultList(xColumnMapper.GetPointer());

    INC_OBJECT_COUNT();

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL]: Create query: refcounts: glob %d qry %d AdoRSCF %d CmdCtor %d\n",
                   g_ulObjCount,
                   g_lQryCount,
                   cAdoRecordsetRefs,
                   cCmdCreatorRefs ));

}

CixssoQuery::~CixssoQuery( )
{
    Reset();

    if (_ptinfo)
        _ptinfo->Release();

#if CIDBG
    LONG cAdoRecordsetRefs = -2;
#endif // CIDBG
    if (_pIAdoRecordsetCF)
#if CIDBG
        cAdoRecordsetRefs =
#endif // CIDBG
        _pIAdoRecordsetCF->Release();

    DEC_OBJECT_COUNT();

#if CIDBG
    LONG l = InterlockedDecrement( &g_lQryCount );
    Win4Assert( l >= 0 );
#endif //CIDBG

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL]: Delete query: refcounts: glob %d qry %d AdoRSCF %d\n",
                   g_ulObjCount,
                   g_lQryCount,
                   cAdoRecordsetRefs ));
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::Reset - public
//
//  Synopsis:   Clear any internal state in the object
//
//  Arguments:  - none -
//
//  Notes:      Doesn't currently clear lcid or property list.
//
//  History:    05 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

HRESULT CixssoQuery::Reset(void)
{
    _maxResults = 0;
    _cFirstRows = 0;
    _cScopes = 0;
    _fAllowEnumeration = FALSE;
    _dwOptimizeFlags = eOptHitCount | eOptRecall;

    if (_pIRowset)
    {
        _pIRowset->Release();
        _pIRowset = 0;
    }

    if (_pIRowsetQueryStatus)
    {
        _pIRowsetQueryStatus->Release();
        _pIRowsetQueryStatus = 0;
    }

    delete _pwszRestriction;
    _pwszRestriction = 0;

    delete _pwszSort;
    _pwszSort = 0;

    delete _pwszGroup;
    _pwszGroup = 0;

    delete _pwszColumns;
    _pwszColumns = 0;

    delete _pwszCatalog;
    _pwszCatalog = 0;

    delete _pwszDialect;
    _pwszDialect = 0;

//  Unneeded since cScopes is set to zero.
//    _apwszScope.Clear();

    _StartHit.Destroy();
    return S_OK;
}

//
// ASP Methods
//

#include <asp/asptlb.h>

STDMETHODIMP CixssoQuery::OnStartPage (IUnknown* pUnk)
{
    if ( 0 == pUnk )
        return E_INVALIDARG;

    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        // reset the error structure
        _err.Reset();
        
        SCODE sc;
        IScriptingContext *piContext = 0;
        IRequest* piRequest = 0;
        IRequestDictionary *piRequestDict = 0;
    
        ISessionObject* piSession = 0;
    
        do
        {
            //Get IScriptingContext Interface
            sc = pUnk->QueryInterface(IID_IScriptingContext, (void**)&piContext);
            if (FAILED(sc))
                break;
    
            //Get Request Object Pointer
            sc = piContext->get_Request(&piRequest);
            if (FAILED(sc))
                break;
    
            //Get ServerVariables Pointer
            sc = piRequest->get_ServerVariables(&piRequestDict);
            if (FAILED(sc))
                break;
    
            VARIANT vtOut;
            VariantInit(&vtOut);
    
            //
            // Get the HTTP_ACCEPT_LANGUAGE Item.  Don't need to check the
            // return code; use a default value for the locale ID
            //
            piRequestDict->get_Item(g_vtAcceptLanguageHeader, &vtOut);
    
            //
            //vtOut Contains an IDispatch Pointer.  To fetch the value
            //for HTTP_ACCEPT_LANGUAGE you must get the Default Value for the
            //Object stored in vtOut using VariantChangeType.
            //
            if (V_VT(&vtOut) != VT_BSTR)
                VariantChangeType(&vtOut, &vtOut, 0, VT_BSTR);
    
            if (V_VT(&vtOut) == VT_BSTR)
            {
                ixssoDebugOut((DEB_TRACE, "OnStartPage: HTTP_ACCEPT_LANGUAGE = %ws\n",
                                           V_BSTR(&vtOut) ));
                SetLocaleString(V_BSTR(&vtOut));
            }
            else
            {
                ixssoDebugOut(( DEB_TRACE,
                                "OnStartPage: HTTP_ACCEPT_LANGAUGE was not set in ServerVariables; using lcid=0x%x\n",
                                GetSystemDefaultLCID() ));
    
                put_LocaleID( GetSystemDefaultLCID() );
            }
            VariantClear(&vtOut);
    
            _ulCodepage = LocaleToCodepage( _lcid );
    
            //Get Session Object Pointer
            sc = piContext->get_Session(&piSession);
            if (FAILED(sc))
            {
                // Don't fail request if sessions are not enabled.  This specific
                // error is given when AspAllowSessionState is zero.
                if (TYPE_E_ELEMENTNOTFOUND == sc)
                    sc = S_OK;
    
                break;
            }
    
            LONG cp = CP_ACP;
            sc = piSession->get_CodePage( &cp );
            if (FAILED(sc))
            {
                // sc = S_OK;
                break;
            }
    
            if (cp != CP_ACP)
                _ulCodepage = cp;
    
        } while (FALSE);
    
        if (piSession)
            piSession->Release();
    
        if (piRequestDict)
            piRequestDict->Release();
        if (piRequest)
            piRequest->Release();
        if (piContext)
            piContext->Release();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}

//-----------------------------------------------------------------------------
// CixssoQuery IUnknown Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::QueryInterface(REFIID iid, void * * ppv)
{
    *ppv = 0;

    if (iid == IID_IUnknown || iid == IID_IDispatch)
        *ppv = (IDispatch *) this;
    else if (iid == IID_ISupportErrorInfo )
        *ppv = (ISupportErrorInfo *) this;
    else if (iid == IID_IixssoQuery )
        *ppv = (IixssoQuery *) this;
    else if (iid == IID_IixssoQueryPrivate )
        *ppv = (IixssoQueryPrivate *) this;
    else if ( iid == IID_IixssoQueryEx )
        *ppv = (IixssoQueryEx *) this;
#if 0
    else if ( iid == IID_IObjectSafety )
        *ppv = (IObjectSafety *) this;
#endif
    else if ( iid == IID_IObjectWithSite )
        *ppv = (IObjectWithSite *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CixssoQuery::AddRef(void)
{
    return InterlockedIncrement((long *)&_cRef);
}

STDMETHODIMP_(ULONG)
CixssoQuery::Release(void)
{
    ULONG uTmp = InterlockedDecrement((long *)&_cRef);
    if (uTmp == 0)
    {
        delete this;
        return 0;
    }
    return uTmp;
}


//-----------------------------------------------------------------------------
// CixssoQuery IDispatch Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo * * pptinfo)
{
    _ptinfo->AddRef();
    *pptinfo = _ptinfo;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::GetIDsOfNames(
      REFIID riid,
      OLECHAR * * rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid)
{
    return DispGetIDsOfNames(_ptinfo, rgszNames, cNames, rgdispid);
}

STDMETHODIMP
CixssoQuery::Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pParams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr)
{
    ixssoDebugOut((DEB_IDISPATCH, "Invoking method dispid=%d wFlags=%d\n",
                                   dispidMember, wFlags ));

    _err.Reset();

    SCODE sc = DispInvoke( this, _ptinfo,
                           dispidMember, wFlags, pParams,
                           pvarResult, pexcepinfo, puArgErr );

    if ( _err.IsError() )
        sc = DISP_E_EXCEPTION;

    return sc;
}

STDMETHODIMP
CixssoQuery::InterfaceSupportsErrorInfo(
    REFIID riid)
{
    if (IID_IixssoQueryEx == riid || IID_IixssoQuery == riid )
        return S_OK;
    else
        return S_FALSE;
}


//-----------------------------------------------------------------------------
// CixssoQuery property Methods
//-----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CopyWstrToBstr - private inline
//
//  Synopsis:   Copies a Unicode string to a BSTR
//
//  Arguments:  [pbstr] - destination BSTR
//              [pwstr] - string to be copied
//
//  Returns:    SCODE - status return
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoQuery::CopyWstrToBstr( BSTR * pbstr, WCHAR const * pwstr )
{
    *pbstr = 0;
    if (pwstr)
    {
        *pbstr = SysAllocString( pwstr );
        if (0 == *pbstr)
            return E_OUTOFMEMORY;  
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CopyBstrToWstr - private inline
//
//  Synopsis:   Copies a BSTR to a Unicode string
//
//  Arguments:  [bstr] - string to be copied
//              [rwstr] - destination string
//
//  Returns:    SCODE - status return
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoQuery::CopyBstrToWstr( BSTR bstr, LPWSTR & rwstr )
{
    SCODE sc = S_OK;

    if (rwstr)
    {
        delete rwstr;
        rwstr = 0;
    }

    if (bstr)
    {
        CTranslateSystemExceptions translate;
        TRY
        {
            unsigned cch = SysStringLen( bstr )+1;
            if (cch > 1)
            {
                rwstr = new WCHAR[ cch ];
                RtlCopyMemory( rwstr, bstr, cch*sizeof (WCHAR) );
            }
        }
        CATCH (CException, e)
        {
            if (e.GetErrorCode() == STATUS_ACCESS_VIOLATION)
                sc = E_FAIL;
            else
                sc = E_OUTOFMEMORY;

            SetError( sc, OLESTR("PutProperty") );
        }
        END_CATCH
    }
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CopyBstrToWstr - private inline
//
//  Synopsis:   Copies a BSTR to a Unicode string
//
//  Arguments:  [bstr] - string to be copied
//              [apstr] - destination string array
//              [i] - string array index
//
//  Returns:    SCODE - status return
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoQuery::CopyBstrToWstrArray( BSTR bstr,
                                        CDynArray<WCHAR> &apstr,
                                        unsigned i )
{
    SCODE sc = S_OK;

    if (bstr)
    {
        CTranslateSystemExceptions translate;
        TRY
        {
            unsigned cch = SysStringLen( bstr )+1;
            if (cch > 1)
            {
                XArray<WCHAR> wstr( cch );

                RtlCopyMemory( wstr.GetPointer(), bstr, cch*sizeof (WCHAR) );
                delete apstr.Acquire( i );
                apstr.Add( wstr.GetPointer(), i );
                wstr.Acquire();
            }
            else
                apstr.Add( 0, i );
        }
        CATCH (CException, e)
        {
            if (e.GetErrorCode() == STATUS_ACCESS_VIOLATION)
                sc = E_FAIL;
            else
                sc = E_OUTOFMEMORY;

            SetError( sc, OLESTR("CopyBstrToWstrArray") );
        }
        END_CATCH
    }
    else
        apstr.Add( 0, i );

    return sc;
}

inline
SCODE CixssoQuery::GetBoolProperty( VARIANT_BOOL * pfVal, BOOL fMemberVal )
{
    *pfVal = fMemberVal ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

inline
SCODE CixssoQuery::PutBoolProperty( VARIANT_BOOL fInputVal, BOOL & fMemberVal )
{
    fMemberVal = (fInputVal == VARIANT_TRUE) ? TRUE : FALSE;
    return S_OK;
}


//-----------------------------------------------------------------------------
// CixssoQuery read-write properties
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::get_Query(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr, _pwszRestriction );
}

STDMETHODIMP
CixssoQuery::put_Query(BSTR str)
{
    _err.Reset();
    return CopyBstrToWstr( str, _pwszRestriction );
}


STDMETHODIMP
CixssoQuery::get_GroupBy(BSTR * pstr)
{
    _err.Reset();
#if IXSSO_CATEGORIZE == 1
    return CopyWstrToBstr( pstr, _pwszGroup );
#else // IXSSO_CATEGORIZE
    return E_NOTIMPL;
#endif // IXSSO_CATEGORIZE
}

STDMETHODIMP
CixssoQuery::put_GroupBy(BSTR str)
{
    _err.Reset();
#if IXSSO_CATEGORIZE == 1
    return CopyBstrToWstr( str, _pwszGroup );
#else // IXSSO_CATEGORIZE
    return E_NOTIMPL;
#endif // IXSSO_CATEGORIZE
}


STDMETHODIMP
CixssoQuery::get_Columns(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr, _pwszColumns );
}

STDMETHODIMP
CixssoQuery::put_Columns(BSTR str)
{
    _err.Reset();
    return CopyBstrToWstr( str, _pwszColumns );
}

STDMETHODIMP
CixssoQuery::get_LocaleID(LONG * plVal)
{
    _err.Reset();
    *plVal = _lcid;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_LocaleID(LONG  lVal)
{
    _err.Reset();
    _lcid = lVal;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::get_CodePage(LONG * plVal)
{
    _err.Reset();
    *plVal = _ulCodepage;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_CodePage(LONG  lVal)
{
    _err.Reset();
    if (0 == IsValidCodePage( lVal ) )
    {
        return E_INVALIDARG;
    }
    _ulCodepage = lVal;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::get_SortBy(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr, _pwszSort );
}

STDMETHODIMP
CixssoQuery::put_SortBy(BSTR str)
{
    _err.Reset();
    return CopyBstrToWstr( str, _pwszSort );
}

STDMETHODIMP
CixssoQuery::get_CiScope(BSTR * pstr)
{
    _err.Reset();
    if (_cScopes > 1)
    {
        SetError( E_INVALIDARG, OLESTR("get CiScope") );
        return _err.GetError();
    }

    return CopyWstrToBstr( pstr, _apwszScope.Get(0) );
}

STDMETHODIMP
CixssoQuery::put_CiScope(BSTR str)
{
    _err.Reset();
    if (_cScopes > 1)
    {
        SetError( E_INVALIDARG, OLESTR("set CiScope") );
        return _err.GetError();
    }

    SCODE sc = CopyBstrToWstrArray( str, _apwszScope, 0 );
    if (SUCCEEDED(sc))
    {
        _cScopes = (_apwszScope[0] == 0) ? 0 : 1;
    }

    return sc;
}

STDMETHODIMP
CixssoQuery::get_CiFlags(BSTR * pstr)
{
    _err.Reset();
    if (_cScopes > 1)
    {
        SetError( E_INVALIDARG, OLESTR("get CiFlags") );
        return _err.GetError();
    }
    ULONG ulDepth = QUERY_DEEP;
    if (_aulDepth.Count() > 0)
        ulDepth = _aulDepth[0];
    WCHAR * pwszDepth = ulDepth & QUERY_DEEP ? L"DEEP" : L"SHALLOW";

    return CopyWstrToBstr( pstr, pwszDepth );
}

STDMETHODIMP
CixssoQuery::put_CiFlags(BSTR str)
{
    _err.Reset();
    SCODE sc = S_OK;

    if (_cScopes > 1)
    {
        SetError( E_INVALIDARG, OLESTR("set CiFlags") );
        return _err.GetError();
    }

    CTranslateSystemExceptions translate;
    TRY
    {
        ULONG ulDepth = ParseCiDepthFlag( str );
        _aulDepth[0] = ulDepth;
    }
    CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        Win4Assert( !SUCCEEDED(sc) );
        SetError( sc, OLESTR("set CiFlags"), eIxssoError );
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("set CiFlags") );
    }
    END_CATCH

    return sc;
}

STDMETHODIMP
CixssoQuery::get_Catalog(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr, _pwszCatalog );
}

STDMETHODIMP
CixssoQuery::put_Catalog(BSTR str)
{
    _err.Reset();
    return CopyBstrToWstr( str, _pwszCatalog );
}

STDMETHODIMP
CixssoQuery::get_Dialect(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr,
                           _pwszDialect ? _pwszDialect : pwcDefaultDialect );
}

STDMETHODIMP
CixssoQuery::put_Dialect(BSTR str)
{
    _err.Reset();
    //
    // Do some validation first
    //

    ULONG ulDialect = (ULONG) _wtoi( str );
    if ( ulDialect < ISQLANG_V1 ||
         ulDialect > ISQLANG_V2 )
    {
        SetError( E_INVALIDARG, OLESTR("set Dialect") );
        return _err.GetError();
    }

    return CopyBstrToWstr( str, _pwszDialect );
}

STDMETHODIMP
CixssoQuery::get_OptimizeFor(BSTR * pstr)
{
    _err.Reset();

    WCHAR * pwszChoice = L"recall";

    switch (_dwOptimizeFlags)
    {
    case 0:
        pwszChoice = L"nohitcount";
        break;
    case eOptPerformance:
        pwszChoice = L"performance,nohitcount";
        break;
    case eOptRecall:
        pwszChoice = L"recall,nohitcount";
        break;
    case eOptPerformance|eOptHitCount:
        pwszChoice = L"performance,hitcount";
        break;
    case eOptRecall|eOptHitCount:
        pwszChoice = L"recall,hitcount";
        break;
    case eOptHitCount:
        pwszChoice = L"hitcount";
        break;
    default:
        Win4Assert( !"Invalid value in _dwOptimizeFlags!" );
    }

    return CopyWstrToBstr( pstr, pwszChoice );
}

STDMETHODIMP
CixssoQuery::put_OptimizeFor(BSTR str)
{
    _err.Reset();

    DWORD eChoice;
    SCODE sc = ParseOptimizeFor( str, eChoice );
    if (SUCCEEDED(sc))
    {
        _dwOptimizeFlags = eChoice;
        return sc;
    }
    else
    {
        SetError( sc, OLESTR("set OptimizeFor") );
        return _err.GetError();
    }
}

STDMETHODIMP
CixssoQuery::get_AllowEnumeration(VARIANT_BOOL * pfFlag)
{
    _err.Reset();
    return GetBoolProperty( pfFlag, _fAllowEnumeration );
}

STDMETHODIMP
CixssoQuery::put_AllowEnumeration(VARIANT_BOOL fFlag)
{
    _err.Reset();
    return PutBoolProperty( fFlag, _fAllowEnumeration );
}

STDMETHODIMP
CixssoQuery::get_MaxRecords(LONG * plVal)
{
    _err.Reset();
    *plVal = _maxResults;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_MaxRecords(LONG lVal)
{
    _err.Reset();
    if (lVal < 0)
    {
        SetError( E_INVALIDARG, OLESTR("set MaxRecords") );
        return _err.GetError();
    }
    else if (IsQueryActive())
    {
        SetError( MSG_IXSSO_QUERY_ACTIVE, OLESTR("set MaxRecords") );
        return _err.GetError();
    }

    _maxResults = lVal;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::get_FirstRows(LONG * plVal)
{
    _err.Reset();
    *plVal = _cFirstRows;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_FirstRows(LONG lVal)
{
    _err.Reset();
    if (lVal < 0)
    {
        SetError( E_INVALIDARG, OLESTR("set FirstRows") );
        return _err.GetError();
    }
    else if (IsQueryActive())
    {
        SetError( MSG_IXSSO_QUERY_ACTIVE, OLESTR("set FirstRows") );
        return _err.GetError();
    }

    _cFirstRows = lVal;
    return S_OK;
}


STDMETHODIMP
CixssoQuery::get_StartHit(VARIANT * pvar)
{
    _err.Reset();
    if (_StartHit.Get() != 0)
    {
        XGrowable<WCHAR> awchBuf;

        FormatLongVector( _StartHit.Get(), awchBuf );

        VariantInit( pvar );
        V_BSTR(pvar) = SysAllocString( awchBuf.Get() );
        if ( V_BSTR(pvar) != 0 )
        {
            V_VT(pvar) = VT_BSTR;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        V_VT(pvar) = VT_EMPTY;
    }
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_StartHit(VARIANT* pvar)
{
    _err.Reset();
    //
    // NOTE:  StartHit is not read-only with an active query so it can
    //        be set from the recordset prior to calling QueryToURL.
    //
    SCODE sc;

    SAFEARRAY* psa;
    XSafeArray xsa;

    switch( V_VT(pvar) )
    {

    case VT_DISPATCH:
        //
        //pvar Contains an IDispatch Pointer.  To fetch the value
        //you must get the Default Value for the
        //Object stored in pvar using VariantChangeType.
        //
        VariantChangeType(pvar, pvar, 0, VT_BSTR);

        if (V_VT(pvar) != VT_BSTR)
        {
            return E_INVALIDARG;
        }
   // NOTE: fall through

    case VT_BSTR:
    {
        CDynArrayInPlace<LONG> aStartHit( 0 );

        ParseNumberVectorString( V_BSTR(pvar), aStartHit );
        unsigned cHits = aStartHit.Count();

        psa = SafeArrayCreateVector(VT_I4, 1, cHits);
        if ( ! psa )
            return E_OUTOFMEMORY;

        xsa.Set(psa);

        for (unsigned i=1; i<=cHits; i++)
        {
            long rgIx[1];
            LONG lVal = aStartHit.Get(i-1);
            rgIx[0] = (long)i;
            sc = SafeArrayPutElement( xsa.Get(), rgIx, &lVal );
            if ( FAILED(sc) )
                break;
        }
        if ( FAILED(sc) )
            return sc;
    }
        break;

    case VT_ARRAY | VT_I4:
        sc = SafeArrayCopy(V_ARRAY(pvar),&psa);
        if ( FAILED(sc) )
            return sc;

        xsa.Set(psa);
        if (SafeArrayGetDim(psa) != 1)
            return E_INVALIDARG;
        break;

    case VT_I4:
    case VT_I2:
        psa = SafeArrayCreateVector(VT_I4,1,1);
        if ( ! psa )
            return E_OUTOFMEMORY;

        xsa.Set(psa);
        {
            long rgIx[1];
            rgIx[0] = 1;
            long lVal = (V_VT(pvar) == VT_I4) ? V_I4(pvar) : V_I2(pvar);
            sc = SafeArrayPutElement( xsa.Get(), rgIx, &lVal );

            if ( FAILED( sc ) )
                return sc;
        }
        break;

    default:
        SetError( E_INVALIDARG, OLESTR("set StartHit") );
        return _err.GetError();

    }

    _StartHit.Destroy();
    _StartHit.Set( xsa.Acquire() );

    return S_OK;
}


STDMETHODIMP
CixssoQuery::get_ResourceUseFactor(LONG * plVal)
{
    _err.Reset();
    *plVal = _iResourceFactor;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_ResourceUseFactor(LONG lVal)
{
    _err.Reset();

    if (IsQueryActive())
    {
        SetError( MSG_IXSSO_QUERY_ACTIVE, OLESTR("set ResourceUseFactor") );
        return _err.GetError();
    }

    _iResourceFactor = lVal;
    return S_OK;
}




//-----------------------------------------------------------------------------
// CixssoQuery read-only properties
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CheckQueryStatusBit - private inline
//
//  Synopsis:   Check a specific query status bit, set variant bool accordingly
//
//  Arguments:  [pfVal] - VARIANT_BOOL to be set
//              [dwBit] - bit(s) in query status to be tested
//
//  Returns:    SCODE - status return
//
//  History:    03 Jan 1997      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoQuery::CheckQueryStatusBit( VARIANT_BOOL * pfVal, DWORD dwBit )
{
    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        DWORD dwStatus = GetQueryStatus( );
        *pfVal = (dwStatus & dwBit) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        Win4Assert( !SUCCEEDED(sc) );
        SetError( sc, OLESTR("CheckQueryStatus"), eIxssoError );
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("CheckQueryStatus") );
    }
    END_CATCH

    return sc;
}

STDMETHODIMP
CixssoQuery::get_QueryTimedOut(VARIANT_BOOL * pfFlag)
{
    _err.Reset();
    return CheckQueryStatusBit( pfFlag, STAT_TIME_LIMIT_EXCEEDED );
}

STDMETHODIMP
CixssoQuery::get_QueryIncomplete(VARIANT_BOOL * pfFlag)
{
    _err.Reset();
    return CheckQueryStatusBit( pfFlag, STAT_CONTENT_QUERY_INCOMPLETE );
}

STDMETHODIMP
CixssoQuery::get_OutOfDate(VARIANT_BOOL * pfFlag)
{
    _err.Reset();
    return CheckQueryStatusBit( pfFlag, 
                        (STAT_CONTENT_OUT_OF_DATE | STAT_REFRESH_INCOMPLETE) );
}



//-----------------------------------------------------------------------------
// CixssoQuery Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::AddScopeToQuery( BSTR bstrScope,
                              BSTR bstrDepth)
{
    //
    // This is an internally used method, so don't need to reset error object here.
    //

    if (0 == bstrScope || 0 == SysStringLen(bstrScope) )
    {
        THROW( CException(E_INVALIDARG) );
    }

    SCODE sc = CopyBstrToWstrArray( bstrScope, _apwszScope, _cScopes );

    if (FAILED(sc))
    {
        THROW( CException(sc) );
    }

    ULONG ulDepth = ParseCiDepthFlag( bstrDepth );
    _aulDepth[_cScopes] = ulDepth;

    _cScopes++;

    return S_OK;
}

STDMETHODIMP
CixssoQuery::DefineColumn( BSTR bstrColDefinition)
{
    _err.Reset();

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        CQueryScanner scanner( bstrColDefinition, FALSE );
        XPtr<CPropEntry> xpropentry;
        CPropertyList::ParseOneLine( scanner, 0, xpropentry );

        if (xpropentry.GetPointer())
            sc = _PropertyList.AddEntry( xpropentry, 0 );
    }
    CATCH( CPListException, e )
    {
        sc = e.GetPListError();
        Win4Assert( !SUCCEEDED(sc) );
        SetError( sc, OLESTR("DefineColumn"), ePlistError );
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("DefineColumn") );
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CreateRecordset - public
//
//  Synopsis:   Executes the query and returns a recordset
//
//  Arguments:  [bstrSequential] - one of "SEQUENTIAL" or "NONSEQUENTIAL",
//                      selects whether a nonsequential query is used.
//              [ppDisp] - recordset is returned here.
//
//  History:    06 Nov 1996      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::CreateRecordset( BSTR bstrSequential,
                              IDispatch * * ppDisp)
{
    _err.Reset();

    unsigned eErrorClass = 0;
    BOOL fSetErrorNeeded = TRUE;

    if (IsQueryActive())
    {
        SetError( MSG_IXSSO_QUERY_ACTIVE, OLESTR("CreateRecordset") );
        return _err.GetError();
    }

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        IsSafeForScripting();

        *ppDisp = 0;

        if ( bstrSequential && 0 == _wcsicmp(bstrSequential, L"SEQUENTIAL") )
            _fSequential = TRUE;
        else if ( bstrSequential &&
                  (0 == _wcsicmp(bstrSequential, L"NONSEQUENTIAL") ||
                   0 == _wcsicmp(bstrSequential, L"NON-SEQUENTIAL")) )
            _fSequential = FALSE;
        else
        {
            SetError( E_INVALIDARG, OLESTR("CreateRecordset") );
            return _err.GetError();
        }

        ExecuteQuery();
        Win4Assert( _pIRowset != 0 );
        Win4Assert( _pIRowsetQueryStatus != 0 );

        //
        // Create an empty recordset, and put our rowset in it.
        //

        IDispatch * pRecordset = 0;
        sc = _pIAdoRecordsetCF->CreateInstance( 0,
                                                IID_IDispatch,
                                                (void **)&pRecordset );

        ADORecordsetConstruction * pRecordsetConstruction = 0;
        if ( SUCCEEDED(sc) )
        {
            sc = pRecordset->QueryInterface( IID_IADORecordsetConstruction,
                                             (void **)&pRecordsetConstruction );
        }

        if (SUCCEEDED(sc))
        {
            sc = pRecordsetConstruction->put_Rowset( _pIRowset );
            pRecordsetConstruction->Release();
        }

        if (SUCCEEDED(sc))
        {
            *ppDisp = pRecordset;
        }

        if (FAILED(sc))
        {
            if (pRecordset)
                pRecordset->Release();
            pRecordset = 0;

            _pIRowset->Release();
            _pIRowset = 0;

            _pIRowsetQueryStatus->Release();
            _pIRowsetQueryStatus = 0;
        }

        fSetErrorNeeded = FAILED(sc);
    }
    CATCH( CPListException, e )
    {
        sc = e.GetPListError();
        eErrorClass = ePlistError;
        Win4Assert( !SUCCEEDED(sc) );
    }
    AND_CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        eErrorClass = eIxssoError;
        Win4Assert( !SUCCEEDED(sc) );
    }
    AND_CATCH( CParserException, e )
    {
        sc = e.GetParseError();
        eErrorClass = eParseError;
        Win4Assert( !SUCCEEDED(sc) );
    }
    AND_CATCH( CPostedOleDBException, e )
    {
        //
        // When the execution error was detected, the Ole DB error
        // info was retrieved and stored in the exception object.
        // We retrieve that here and compose the error message.
        //

        sc = e.GetErrorCode();
        Win4Assert( !SUCCEEDED(sc) );

        XInterface <IErrorInfo> xErrorInfo(e.AcquireErrorInfo());

        if (xErrorInfo.GetPointer())
        {
            BSTR bstrErrorDescription = 0;
            xErrorInfo->GetDescription(&bstrErrorDescription);
            if (bstrErrorDescription)
            {
                SetError( sc, OLESTR("CreateRecordset"), (WCHAR const *)bstrErrorDescription);
                SysFreeString(bstrErrorDescription);
                fSetErrorNeeded = FALSE;
            }
            else
                eErrorClass = eDefaultError;
        }
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        eErrorClass = eDefaultError;
        Win4Assert( !SUCCEEDED(sc) );
    }
    END_CATCH

    if (! SUCCEEDED(sc) && fSetErrorNeeded)
        SetError( sc, OLESTR("CreateRecordset"), eErrorClass );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::ParseOptimizeFor - private static
//
//  Synopsis:   Parse the input string for the OptimizeFor property
//
//  Arguments:  [wcsOptString] - input string
//              [eChoice]      - OptimizeFor choice expressed in wcsOptString
//
//  Returns:    SCODE - status return
//
//  History:    05 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

SCODE CixssoQuery::ParseOptimizeFor( WCHAR const * wcsOptString,
                                     DWORD & eChoice )
{
    eChoice = eOptHitCount;

    while (wcsOptString && *wcsOptString)
    {
        WCHAR * wcsNext = wcschr( wcsOptString, ',' );
        ULONG cch = (wcsNext) ? CiPtrToUlong( wcsNext - wcsOptString ) :
                                wcslen( wcsOptString );


        if ( 11 == cch && _wcsnicmp(wcsOptString, L"performance", 11) == 0)
        {
            eChoice |= eOptPerformance;
        }
        else if ( 6 == cch && _wcsnicmp(wcsOptString, L"recall", 6) == 0)
        {
            eChoice |= eOptRecall;
        }
        else if ( 8 == cch && _wcsnicmp(wcsOptString, L"hitcount", 8) == 0)
        {
            eChoice |= eOptHitCount;
        }
        else if ( 10 == cch && _wcsnicmp(wcsOptString, L"nohitcount", 10) == 0)
        {
            eChoice &= ~eOptHitCount;
        }
        else
            return E_INVALIDARG;

        wcsOptString = wcsNext;
        if (wcsOptString)
        {
            wcsOptString++;

            while (iswspace( *wcsOptString ))
                wcsOptString++;
        }
    }

    // 'performance' and 'recall' are mutually exclusive.  Check if both
    // were set.
    if ( (eChoice & (eOptRecall | eOptPerformance)) ==
         (eOptRecall | eOptPerformance) )
            return E_INVALIDARG;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::ParseCiDepthFlag, private
//
//  Synopsis:   Parses the flags attribute
//
//  Arguments:  [bstrFlags] -- flags
//
//  Returns:    ULONG - query scope flags
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------

ULONG CixssoQuery::ParseCiDepthFlag( BSTR bstrFlags )
{
    if ( 0 == bstrFlags || 0 == SysStringLen(bstrFlags) )
    {
        return QUERY_DEEP;
    }

    ULONG ulFlags;

    if ( _wcsicmp(bstrFlags, L"SHALLOW") == 0 )
    {
        ulFlags = QUERY_SHALLOW;
    }
    else if ( _wcsicmp(bstrFlags, L"DEEP") == 0 )
    {
        ulFlags = QUERY_DEEP;
    }
    else
    {
        THROW( CIxssoException(MSG_IXSSO_EXPECTING_SHALLOWDEEP, 0) );
    }

    return ulFlags;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::SetLocaleString - private
//
//  Synopsis:   Parse the input string for a recognizable locale name
//
//  Arguments:  [bstrLocale] - input string
//
//  Returns:    SCODE - status return
//
//  History:    13 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

SCODE CixssoQuery::SetLocaleString(BSTR str)
{
    LCID lcidTemp = GetLCIDFromString( str );
    if (lcidTemp == -1)
    {
        return E_INVALIDARG;
    }

    _lcid = lcidTemp;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseNumberVectorString - public
//
//  Synopsis:   Parses a string consisting of ',' separated numeric values
//              into an array.
//
//  Arguments:  [pwszValue] - input string
//              [aNum]      - dynamic array where numbers are placed.
//
//  History:    10 Jun 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void ParseNumberVectorString( WCHAR * pwszValue, CDynArrayInPlace<LONG> & aNum )
{
    while (pwszValue)
    {
        LONG lNum = _wtoi( pwszValue );
        aNum[aNum.Count()] = lNum;
        pwszValue = wcschr(pwszValue, L',');
        if (pwszValue)
            pwszValue++;
    }
}

void FormatLongVector( SAFEARRAY * psa, XGrowable<WCHAR> & awchBuf )
{
    Win4Assert( SafeArrayGetDim( psa ) == 1 &&
                SafeArrayGetElemsize( psa ) == sizeof (LONG) );

    LONG iLBound = 0;
    LONG iUBound = 0;
    SCODE sc = SafeArrayGetLBound( psa, 1, &iLBound );
    if (SUCCEEDED(sc))
        sc = SafeArrayGetUBound( psa, 1, &iUBound );

    unsigned cch = 0;
    for (int i=iLBound; i<= iUBound; i++)
    {
        LONG lValue;
        LONG ix[1];
        ix[0] = i;
        sc = SafeArrayGetElement( psa, ix, &lValue );

        awchBuf.SetSize(cch + 20);
        if (i != iLBound)
        {
            awchBuf[cch] = L',';
            cch++;
        }
        _itow( lValue, &awchBuf[cch], 10 );
        cch += wcslen( &awchBuf[cch] );
    }

}

// CIXSSOPropertyList methods

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::CIXSSOPropertyList, public
//
//  Synopsis:   Constructs a property mapper for the ixsso's use.
//
//  Parameters: [pDefaultList]  -- The default column mapper.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

CIXSSOPropertyList::CIXSSOPropertyList(ULONG ulCodePage)
    : _cRefs( 1 ),
      _ulCodePage( ulCodePage ),
      _xDefaultList(0)
{
    // default list is not known. Use SetDefaultList to set that
}

// Set the defualt list
void CIXSSOPropertyList::SetDefaultList(IColumnMapper *pDefaultList)
{
    Win4Assert(pDefaultList);

    _xDefaultList.Set(pDefaultList);
    _xDefaultList->AddRef();
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CIXSSOPropertyList::QueryInterface( REFIID ifid, void ** ppiuk )
{
    if (0 == ppiuk)
        return E_INVALIDARG;

    if ( IID_IUnknown == ifid )
    {
        AddRef();
        *ppiuk = (void *)((IUnknown *)this);
        return S_OK;
    }
    else if (IID_IColumnMapper == ifid )
    {
        AddRef();
        *ppiuk = (void *)((IColumnMapper *)this);
        return S_OK;
    }
    else
    {
        *ppiuk = 0;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CIXSSOPropertyList::AddRef(void)
{
    InterlockedIncrement( &_cRefs );
    return( _cRefs );
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CIXSSOPropertyList::Release(void)
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );
    if (0 == uTmp)
    {
        delete this;
    }
    return(uTmp);
}

//
// IColumnMapper methods
//

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::GetPropInfoFromName, public
//
//  Synopsis:   Get property info. from name.
//
//  Parameters: [wcsPropName] -- Property name to look up.
//              [ppPropId]    -- Ptr to return Id of the property.
//              [pPropType]   -- Ptr to return type of the property.
//              [puiWidth]    -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CIXSSOPropertyList::GetPropInfoFromName(const WCHAR  *wcsPropName,
                                             DBID  * *ppPropId,
                                             DBTYPE  *pPropType,
                                             unsigned int  *puiWidth)
{
    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //

    if (0 == wcsPropName || 0 == ppPropId)
        return E_INVALIDARG;

    Win4Assert(_xDefaultList.GetPointer());

    //
    // First check in the default list, then in the override list.
    //

    SCODE sc = _xDefaultList->GetPropInfoFromName(wcsPropName,
                                                  ppPropId,
                                                  pPropType,
                                                  puiWidth);

    if (FAILED(sc) && 0 != _xOverrideList.GetPointer())
    {
        sc = _xOverrideList->GetPropInfoFromName(wcsPropName,
                                                 ppPropId,
                                                 pPropType,
                                                 puiWidth);
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::GetPropInfoFromId, public
//
//  Synopsis:   Get property info. from dbid.
//
//  Parameters: [pPropId]    -- Ptr to prop to look up.
//              [pwcsName]   -- Ptr to return property name.
//              [pPropType]  -- Ptr to return type of the property.
//              [puiWidth]   -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CIXSSOPropertyList::GetPropInfoFromId(const DBID  *pPropId,
                                           WCHAR  * *pwcsName,
                                           DBTYPE  *pPropType,
                                           unsigned int  *puiWidth)
{
    Win4Assert(!"Not available!");
    return E_NOTIMPL;

#if 0  // complete, working implementation, but not needed.
    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //
    if (0 == pwcsName || 0 == pPropId)
        return E_INVALIDARG;

    //
    // First check in the default list, then in the override list.
    //

    SCODE sc = _xDefaultList->GetPropInfoFromId(pPropId,
                                                pwcsName,
                                                pPropType,
                                                puiWidth);

    if (FAILED(sc) && 0 != _xOverrideList.GetPointer())
    {
        sc = _xOverrideList->GetPropInfoFromId(pPropId,
                                               pwcsName,
                                               pPropType,
                                               puiWidth);
    }

    return sc;
#endif // 0
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::EnumPropInfo, public
//
//  Synopsis:   Gets the i-th entry from the list of properties.
//
//  Parameters: [iEntry]    -- i-th entry to retrieve (0-based).
//              [pwcsName]  -- Ptr to return property name.
//              [ppPropId]  -- Ptr to return Id of the property.
//              [pPropType]  -- Ptr to return type of the property.
//              [puiWidth]   -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CIXSSOPropertyList::EnumPropInfo(ULONG iEntry,
                                  const WCHAR  * *pwcsName,
                                  DBID  * *ppPropId,
                                  DBTYPE  *pPropType,
                                  unsigned int  *puiWidth)
{
    Win4Assert(!"Not available!");
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::IsMapUpToDate, public
//
//  Synopsis:   Indicates if the column map is up to date.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CIXSSOPropertyList::IsMapUpToDate()
{
    Win4Assert(_xDefaultList.GetPointer());

    // return the IsMapUpToDate of the default list.
    // the override list is always considered to be
    // upto date.

    return _xDefaultList->IsMapUpToDate();
}

//+---------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::AddEntry, private
//
//  Synopsis:   Adds a CPropEntry to the overriding list.  Verifies that the name
//              isn't already in the default list or the overriding list.
//
//  Arguments:  [xPropEntry] -- CPropEntry to add.  Acquired on success
//              [iLine]      -- line number we're parsing
//
//  Returns:    S_OK on success or S_
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

SCODE CIXSSOPropertyList::AddEntry( XPtr<CPropEntry> & xPropEntry, int iLine )
{
    Win4Assert(_xDefaultList.GetPointer());

    SCODE sc = S_OK;

    // protect _xOverrideList

    CLock lock(_mtxAdd);

    //
    // We do not allow entries in the override list that have the same name
    // as the default list.
    //

    DBID     *pPropId;
    DBTYPE   PropType;
    unsigned uWidth;

    if ( S_OK == GetPropInfoFromName( xPropEntry->GetName(),
                                      &pPropId,
                                      &PropType,
                                      &uWidth ))
    {
        if ( PropType != xPropEntry->GetPropType() ||
             ( uWidth != xPropEntry->GetWidth() &&
               xPropEntry->GetWidth() != PLIST_DEFAULT_WIDTH ) )
        {
            THROW( CPListException( QPLIST_E_DUPLICATE, iLine ) );
        }
        else
            sc = QPLIST_S_DUPLICATE;
    }

    if ( S_OK == sc )
    {
        if (0 == _xOverrideList.GetPointer())
            _xOverrideList.Set(new CPropertyList(_ulCodePage));

        _xOverrideList->AddEntry( xPropEntry.GetPointer(), iLine);

        xPropEntry.Acquire();
    }

    return sc;
} //AddEntry

#if 0

HRESULT CixssoQuery::GetInterfaceSafetyOptions(
    REFIID  riid,
    DWORD * pdwSupportedOptions,
    DWORD * pdwEnabledOptions )
{
    if ( 0 == pdwSupportedOptions ||
         0 == pdwEnabledOptions )
        return E_POINTER;

    ixssoDebugOut(( DEB_ITRACE, "get safety options called...\n" ));

    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    *pdwEnabledOptions = 0;

    return S_OK;
} //GetInterfaceSafetyOptions

HRESULT CixssoQuery::SetInterfaceSafetyOptions(
    REFIID riid,
    DWORD  dwOptionSetMask,
    DWORD  dwEnabledOptions )
{
    ixssoDebugOut(( DEB_ITRACE, "set setmask: %#x\n", dwOptionSetMask ));
    ixssoDebugOut(( DEB_ITRACE, "set enabled: %#x\n", dwEnabledOptions ));

    _dwSafetyOptions = (dwEnabledOptions & dwOptionSetMask);

    return S_OK;
} //SetInterfaceSafetyOptions

#endif

//+-------------------------------------------------------------------------
//
//  Member:     CixssoQuery::SetSite, public
//
//  Synopsis:   Sets the current site (if any).  Called by containers of
//              CixssoQuery like IE.  Not called by other containers like
//              ASP and CScript.
//
//  Arguments:  [pSite] -- The container of this query object
//
//  Returns:    HRESULT
//
//  History:    09-Nov-00   dlee     Created
//
//--------------------------------------------------------------------------

HRESULT CixssoQuery::SetSite( IUnknown * pSite )
{
    _xSite.Free();

    if ( 0 != pSite )
    {
        pSite->AddRef();

        _xSite.Set( pSite );
    }

    ixssoDebugOut(( DEB_ITRACE, "setting site: %#x\n", pSite ));

    return S_OK;
} //SetSite

//+-------------------------------------------------------------------------
//
//  Member:     CixssoQuery::GetSite, public
//
//  Synopsis:   Retrieves the current site (if any)
//
//  Arguments:  [riid]    -- IID requested
//              [ppvSite] -- Where the interface pointer is returned
//
//  Returns:    HRESULT like a QueryInterface()
//
//  History:    09-Nov-00   dlee     Created
//
//--------------------------------------------------------------------------

HRESULT CixssoQuery::GetSite(
    REFIID  riid,
    void ** ppvSite )
{
    ixssoDebugOut(( DEB_ITRACE, "getsite\n" ));

    if ( 0 == ppvSite )
        return E_POINTER;

    *ppvSite = 0;

    if ( _xSite.IsNull() )
        return E_NOINTERFACE;

    return _xSite->QueryInterface( riid, ppvSite );
} //GetSite

//+-------------------------------------------------------------------------
//
//  Member:     CixssoQuery::IsSafeForScripting, private
//
//  Synopsis:   Checks if it's ok to execute in the current context.  Throws
//              an exception if it's not safe or on error.  It's not safe
//              to execute script off a remote machine.
//
//  History:    09-Nov-00   dlee     Created
//
//--------------------------------------------------------------------------

void CixssoQuery::IsSafeForScripting()
{
    XInterface<IServiceProvider> xServiceProvider;
    SCODE sc = GetSite( IID_IServiceProvider,
                        xServiceProvider.GetQIPointer() );

    //
    // When queries are run in IIS the container does not call
    // SetSite, so there is no site and we'll have E_NOINTERFACE
    // at this point.  Same for cscript.exe queries.
    // If that ever changes, the check below for file:// URLs will
    // fail and no IIS queries will ever work.
    //

    if ( E_NOINTERFACE == sc )
        return;

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    XInterface<IWebBrowser2> xWebBrowser;
    sc = xServiceProvider->QueryService( SID_SWebBrowserApp,
                                         IID_IWebBrowser2,
                                         xWebBrowser.GetQIPointer() );
    if ( E_NOINTERFACE == sc )
        return;

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    BSTR bstrURL;
    sc = xWebBrowser->get_LocationURL( &bstrURL );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    XBStr xURL( bstrURL );
    ixssoDebugOut(( DEB_ITRACE, "url: %ws\n", bstrURL ));

    WCHAR buf[32];
    URL_COMPONENTS uc;
    RtlZeroMemory( &uc, sizeof uc );
    uc.dwStructSize = sizeof uc;
    uc.lpszScheme = buf;
    uc.dwSchemeLength = sizeof buf / sizeof WCHAR;

    INTERNET_SCHEME scheme = INTERNET_SCHEME_UNKNOWN;

    if ( InternetCrackUrl( bstrURL, wcslen( bstrURL ), ICU_DECODE, &uc ) )
        scheme = uc.nScheme;

    // The URL has to be a file:/// URL or we won't allow it.

    if ( INTERNET_SCHEME_FILE != scheme )
        THROW( CException( E_ACCESSDENIED ) );

    // OK, now it can't be a UNC path.  Look for a drive letter and a colon

    // file:///c: the length should at least be 10
    if ( wcslen( bstrURL ) <= 9 )
        THROW( CException( E_ACCESSDENIED ) );

    WCHAR const * pwcPath = bstrURL + 8;
    WCHAR const * pwcColon = wcschr( pwcPath, L':' );

    ixssoDebugOut(( DEB_ITRACE, "Path is: %ws\n", pwcPath ));

    if ( ( 0 == pwcColon ) ||
         ( pwcColon > ( pwcPath + 1 ) ) )
        THROW( CException( E_ACCESSDENIED ) );

    WCHAR wcDrive = * ( pwcColon - 1 );

    ixssoDebugOut(( DEB_ITRACE, "wcDrive is: %wc\n", wcDrive ));
    wcDrive = towupper( wcDrive );

    if ( ( wcDrive < L'A' ) || ( wcDrive > L'Z' ) )
        THROW( CException( E_ACCESSDENIED ) );
} //IsSafeForScripting
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\ixssocf.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       ixssocf.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    CStaticClassFactory
//              CIxssoQueryCF
//
//  History:    26-Feb-96    SSanu    adapted from my Forms stuff
//
//----------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stdcf.hxx"
#include "regutil.h"
#include "ssodebug.hxx"
#include "ixsso.hxx"
#include "ixsutil.hxx"

#include <adoid.h>          // ADO CLSID and IID definitions

#include <initguid.h>

// HACKHACK - this is stolen from the old sdk\inc\adoid.h header:
#define DEFINE_ADOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)

// ADO V1.0 recordset class ID
DEFINE_ADOGUID(CLSID_CADORecordset_V1_0,     0x00000281);


#ifndef OLYMPUS_COMPONENT
    #define QUERY_PROG_ID         L"IXSSO.Query"
    #define QUERY_PROG_ID2        L"IXSSO.Query.2"
    #define QUERY_PROG_ID3        L"IXSSO.Query.3"
    #define QUERY_PROG_DESC       L"Indexing Service Query SSO V2."
    #define QUERY_PROG_DESC3      L"Indexing Service Query SSO V3."
extern WCHAR * g_pwszProgIdQuery = QUERY_PROG_ID;

    #define UTIL_PROG_ID          L"IXSSO.Util"
    #define UTIL_PROG_ID2         L"IXSSO.Util.2"
    #define UTIL_PROG_DESC        L"Indexing Service Utility SSO V2."

extern WCHAR * g_pwszProgIdUtil  = UTIL_PROG_ID;

extern WCHAR * g_pwszErrorMsgFile = L"query.dll";

    #define LIBID_ixsso        LIBID_Cisso
    #define CLSID_ixssoQuery   CLSID_CissoQuery
    #define CLSID_ixssoQueryEx CLSID_CissoQueryEx
    #define CLSID_ixssoUtil    CLSID_CissoUtil

#else
    #define NLQUERY_PROG_ID       L"MSSEARCH.Query"
    #define NLQUERY_PROG_ID1      L"MSSEARCH.Query.1"
    #define NLQUERY_PROG_DESC     L"Microsoft Site Server Search Query SSO V1."
extern WCHAR * g_pwszProgIdQuery = NLQUERY_PROG_ID;

    #define NLUTIL_PROG_ID        L"MSSEARCH.Util"
    #define NLUTIL_PROG_ID1       L"MSSEARCH.Util.1"
    #define NLUTIL_PROG_DESC      L"Microsoft Site Server Search Utility SSO V1."

extern WCHAR * g_pwszProgIdUtil  = NLUTIL_PROG_ID;

extern WCHAR * g_pwszErrorMsgFile = L"oquery.dll";

    #define LIBID_ixsso      LIBID_Nlsso
    #define CLSID_ixssoQuery CLSID_NlssoQuery
    #define CLSID_ixssoUtil  CLSID_NlssoUtil

#endif  // OLYMPUS_COMPONENT


//+------------------------------------------------------------------------
//
//  CStaticClassFactory Implementation
//
//-------------------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     CStaticClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CStaticClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        return E_INVALIDARG;

    if (riid == IID_IUnknown ||
        riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CStaticClassFactory::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CStaticClassFactory::AddRef(void)
{
    Win4Assert(_ulRefs);

    INC_OBJECT_COUNT();
    IXIncrement(_ulRefs);
    ixssoDebugOut((DEB_REFCOUNTS, "[DLL] CF::AddRef: refcounts: glob %d obj %d\n",
                   GET_OBJECT_COUNT(), _ulRefs ));
    return _ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     CStaticClassFactory::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CStaticClassFactory::Release(void)
{
    Win4Assert(_ulRefs > 1);

    IXDecrement(_ulRefs);
    DEC_OBJECT_COUNT();

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL] CF::Release: refcounts: glob %d obj %d\n",
                   GET_OBJECT_COUNT(), _ulRefs ));
    return _ulRefs;
}

//+---------------------------------------------------------------
//
//  Member:     CStaticClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface
//
//  Notes:      Since class factories based on this class are global static
//              objects, this method doesn't serve much purpose.
//
//----------------------------------------------------------------

STDMETHODIMP
CStaticClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
        INC_OBJECT_COUNT();
    else
        DEC_OBJECT_COUNT();
    ixssoDebugOut((DEB_REFCOUNTS, "[DLL] CF::LockServer( %x ) ==> %d\n", fLock, GET_OBJECT_COUNT() ));
    return NOERROR;
}



//-----------------------------------------------------------------------------
// CIxssoQueryCF Class Definition
//-----------------------------------------------------------------------------
class CIxssoQueryCF : public CStaticClassFactory
{
public:
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID iid, LPVOID FAR* ppv);

    void TryInit();
    
    void SetClsid( CLSID ssoClsid ) { _ssoClsid = ssoClsid; }

    static ITypeLib *       _pITypeLibIxsso;
    static IClassFactory *  _pIAdoRecordsetCF;
    static BOOL             _fAdoV15;
    static CLSID            _ssoClsid;
} IxssoQueryCF; //The global factory

//-----------------------------------------------------------------------------
// CIxssoUtilCF Class Definition
//-----------------------------------------------------------------------------
class CIxssoUtilCF : public CStaticClassFactory
{
public:
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID iid, LPVOID FAR* ppv);
} IxssoUtilCF; //The global factory


//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------

CRITICAL_SECTION g_cs;
HINSTANCE g_hInst;

ULONG            g_ulObjCount = 0;  // extern to keep track of object instances

LONG             g_lQryCount = 0;   // BUGBGUG - debugging for obj. ref. count
LONG             g_lUtlCount = 0;   // BUGBGUG - debugging for obj. ref. count


ITypeLib *       CIxssoQueryCF::_pITypeLibIxsso = 0;

IClassFactory *  CIxssoQueryCF::_pIAdoRecordsetCF = 0;
BOOL             CIxssoQueryCF::_fAdoV15 = FALSE;
CLSID            CIxssoQueryCF::_ssoClsid = CLSID_ixssoQueryEx;

CTheGlobalIXSSOVariables * g_pTheGlobalIXSSOVariables = 0;

//-----------------------------------------------------------------------------
//
//  Class:      CLockCritSec
//
//  Synopsis:   Like CLock, but takes a bare CRITICAL_SECTION, not a CMutexSem
//
//-----------------------------------------------------------------------------

class CLockCritSec : INHERIT_UNWIND
{
    INLINE_UNWIND(CLockCritSec);

public:
    CLockCritSec( CRITICAL_SECTION & cs ) :
       _cs( cs )
    {
        EnterCriticalSection( &_cs );
        END_CONSTRUCTION( CLockCritSec );
    }

    ~CLockCritSec( )
    {
        LeaveCriticalSection( &_cs );
    }

private:
    CRITICAL_SECTION &  _cs;
};


//-----------------------------------------------------------------------------
// CIxssoQueryCF Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CIxssoQueryCF::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    // NTRAID#DB-NTBUG9-84743-2000/07/31-dlee IXSSO class factory object does not support COM aggregation

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    SCODE sc = E_OUTOFMEMORY;

    //
    // Guard against a race between TryInit and DllCanUnloadNow...
    //
    INC_OBJECT_COUNT();
    CixssoQuery * pObj = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        TryInit();

        Win4Assert( 0 != _pITypeLibIxsso && 0 != _pIAdoRecordsetCF );

        // create an instance of our CixssoQuery object
        pObj = new CixssoQuery( _pITypeLibIxsso,
                                _pIAdoRecordsetCF,
                                _fAdoV15,
                                _ssoClsid );
    }
    CATCH( CException, e )
    {
        ixssoDebugOut(( DEB_ERROR,
                        "Creation of CixssoQuery failed (%x)\n",
                        e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    Win4Assert( 0 != _pITypeLibIxsso && 0 != _pIAdoRecordsetCF );
    DEC_OBJECT_COUNT();

    if (0 == pObj)
    {
        Win4Assert( !SUCCEEDED(sc) );
        return sc;
    }

#if CIDBG
    LONG l = InterlockedIncrement( &g_lQryCount );
    Win4Assert( l >= 1 );
#endif //CIDBG

    // fetch the interface and return
    sc = pObj->QueryInterface(riid, ppvObj);

    pObj->Release(); // on failure, this will release our IXSSO object
                     // otherwise, object will have a ref count of 1

    return sc;
}

//+---------------------------------------------------------------
//
//  Member:     CIxssoQueryCF::TryInit, public
//
//  Synopsis:   Do static initialization
//
//  Notes:      Do any required initialization of global objects.
//
//----------------------------------------------------------------

void CIxssoQueryCF::TryInit()
{
    Win4Assert (0 != g_ulObjCount);

    // Initialize any global variables needed
    if ( 0 == _pITypeLibIxsso ||
         0 == _pIAdoRecordsetCF ||
         0 == g_pTheGlobalIXSSOVariables )
    {
        CLockCritSec Lock(g_cs);

        // get the Type lib
        if (0 == _pITypeLibIxsso)
        {
            SCODE sc = LoadRegTypeLib(LIBID_ixsso, 1, 0, 0x409, &_pITypeLibIxsso);
            if (FAILED(sc))
                sc = LoadTypeLib( OLESTR("ixsso.tlb"), &_pITypeLibIxsso);

            if (FAILED(sc))
            {
                Win4Assert( 0 == _pITypeLibIxsso );
                ixssoDebugOut(( DEB_ERROR, "Type library load failed (%x)\n", sc));

                THROW(CException(sc));
            }
        }

        // Get the ADO recordset class factory
        if ( 0 == _pIAdoRecordsetCF )
        {
            SCODE sc = CoGetClassObject( CLSID_CADORecordset,
                                         CLSCTX_INPROC_HANDLER |
                                             CLSCTX_INPROC_SERVER,
                                         0,
                                         IID_IClassFactory,
                                         (void **)&_pIAdoRecordsetCF );

            _fAdoV15 = TRUE;
            if (REGDB_E_CLASSNOTREG == sc)
            {
                //
                // The class ID for the recordset changed in ADO V1.5.  Try
                // the ADO V1.0 class ID.
                //
                sc = CoGetClassObject( CLSID_CADORecordset_V1_0,
                                       CLSCTX_INPROC_HANDLER |
                                           CLSCTX_INPROC_SERVER,
                                       0,
                                       IID_IClassFactory,
                                       (void **)&_pIAdoRecordsetCF );

                if (SUCCEEDED(sc))
                    _fAdoV15 = FALSE;
            }

            if (FAILED(sc))
            {
                Win4Assert( 0 == _pIAdoRecordsetCF );
                ixssoDebugOut(( DEB_ERROR, "CoGetClassObject for ADO recordset failed (%x)\n", sc));

                THROW(CException(sc));
            }

            _pIAdoRecordsetCF->LockServer( TRUE );
        }

        // Initialize global variables needed by the IXSSO objects
        if ( 0 == g_pTheGlobalIXSSOVariables )
        {
            g_pTheGlobalIXSSOVariables = new CTheGlobalIXSSOVariables();
        }
    }
}

//-----------------------------------------------------------------------------
// CIxssoUtilCF Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CIxssoUtilCF::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    // NTRAID#DB-NTBUG9-84743-2000/07/31-dlee IXSSO class factory object does not support COM aggregation

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    SCODE sc = E_OUTOFMEMORY;

    //
    // Guard against a race between TryInit and DllCanUnloadNow...
    //
    INC_OBJECT_COUNT();
    CixssoUtil * pObj = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        IxssoQueryCF.TryInit();

        Win4Assert( 0 != CIxssoQueryCF::_pITypeLibIxsso );

        // create an instance of our CixssoUtil object
        pObj = new CixssoUtil( CIxssoQueryCF::_pITypeLibIxsso );
    }
    CATCH( CException, e )
    {
        ixssoDebugOut(( DEB_ERROR,
                        "Creation of CixssoUtil failed (%x)\n",
                        e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    Win4Assert( 0 != CIxssoQueryCF::_pITypeLibIxsso );
    DEC_OBJECT_COUNT();

    if (0 == pObj)
    {
        Win4Assert( !SUCCEEDED(sc) );
        return sc;
    }

#if CIDBG
    LONG l = InterlockedIncrement( &g_lUtlCount );
    Win4Assert( l >= 1 );
#endif //CIDBG

    // fetch the interface and return
    sc = pObj->QueryInterface(riid, ppvObj);

    pObj->Release(); // on failure, this will release our IXSSO object
                     // otherwise, object will have a ref count of 1

    return sc;
}


//-----------------------------------------------------------------------------
// Global Scope
//-----------------------------------------------------------------------------

#ifndef OLYMPUS_COMPONENT
const CLSID clsidCommandCreator = CLSID_CISimpleCommandCreator;

#else

//0b63e347-9ccc-11d0-bcdb-00805fccce04
extern "C" CLSID CLSID_NlCommandCreator;

#define clsidCommandCreator CLSID_NlCommandCreator

#endif // OLYMPUS_COMPONENT



CTheGlobalIXSSOVariables::CTheGlobalIXSSOVariables()
{
    VariantInit(&_vtAcceptLanguageHeader);

    V_VT(&_vtAcceptLanguageHeader) = VT_BSTR;
    V_BSTR(&_vtAcceptLanguageHeader) = SysAllocString(OLESTR("HTTP_ACCEPT_LANGUAGE"));

    HRESULT hr = CoCreateInstance( clsidCommandCreator,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_ISimpleCommandCreator,
                                   xCmdCreator.GetQIPointer() );

    if ( SUCCEEDED( hr ) && xCmdCreator.GetPointer() )
        xCmdCreator->QueryInterface(IID_IColumnMapperCreator,
                                  xColumnMapperCreator.GetQIPointer());
}


//-----------------------------------------------------------------------------
// OLE and DLL Methods
//-----------------------------------------------------------------------------

void FreeResources(void)
{
    CLockCritSec Lock(g_cs);

    if (0 == g_ulObjCount && CIxssoQueryCF::_pIAdoRecordsetCF)
    {
        CIxssoQueryCF::_pIAdoRecordsetCF->LockServer( FALSE );
        CIxssoQueryCF::_pIAdoRecordsetCF->Release();
        CIxssoQueryCF::_pIAdoRecordsetCF = 0;
    }
    if (0 == g_ulObjCount && CIxssoQueryCF::_pITypeLibIxsso)
    {
        CIxssoQueryCF::_pITypeLibIxsso->Release();
        CIxssoQueryCF::_pITypeLibIxsso = 0;
    }
    if (0 == g_ulObjCount && g_pTheGlobalIXSSOVariables )
    {
        delete g_pTheGlobalIXSSOVariables;
        g_pTheGlobalIXSSOVariables = 0;
    }

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL] FreeResources -> %s\n",
                         (0 == g_ulObjCount) ? "S_OK" : "S_FALSE" ));
}

extern "C"
STDAPI DllCanUnloadNow(void)
{
    //Our answer is whether there are any object or locks

    ixssoDebugOut((DEB_REFCOUNTS,"[DLL] DllCanUnloadNow\n"));
    if (0 == g_ulObjCount)
    {
        FreeResources();
    }
    return (0 == g_ulObjCount) ? S_OK : S_FALSE;
}


extern "C"
STDAPI DllRegisterServer()
{
    ixssoDebugOut((DEB_TRACE,"[DLL] DllRegisterServer\n"));

    SCODE sc = S_OK;

#ifndef OLYMPUS_COMPONENT
    sc = _DllRegisterServer(g_hInst, QUERY_PROG_ID, CLSID_CissoQueryEx, QUERY_PROG_DESC3, QUERY_PROG_ID3);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, QUERY_PROG_ID3, CLSID_CissoQueryEx, QUERY_PROG_DESC3);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, QUERY_PROG_ID2, CLSID_CissoQuery, QUERY_PROG_DESC);

    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, UTIL_PROG_ID, CLSID_CissoUtil, UTIL_PROG_DESC, UTIL_PROG_ID2);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, UTIL_PROG_ID2, CLSID_CissoUtil, UTIL_PROG_DESC);
#else
    sc = _DllRegisterServer(g_hInst, NLQUERY_PROG_ID, CLSID_NlssoQuery, NLQUERY_PROG_DESC, NLQUERY_PROG_ID1);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, NLQUERY_PROG_ID1, CLSID_NlssoQuery, NLQUERY_PROG_DESC);

    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, NLUTIL_PROG_ID, CLSID_NlssoUtil, NLUTIL_PROG_DESC, NLUTIL_PROG_ID1);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, NLUTIL_PROG_ID1, CLSID_NlssoUtil, NLUTIL_PROG_DESC);
#endif

    if (SUCCEEDED(sc))
    {
        // Register the type library
        WCHAR   wcsProgram[MAX_PATH+1];
        ULONG cchPath = GetModuleFileName(g_hInst, wcsProgram, MAX_PATH);
        XInterface<ITypeLib> xpITypeLibIxsso;

        if ( 0 != cchPath )
            sc = LoadTypeLib( wcsProgram, xpITypeLibIxsso.GetPPointer());
        else
            sc = E_FAIL;

        if (SUCCEEDED(sc))
            sc = RegisterTypeLib(xpITypeLibIxsso.GetPointer(), wcsProgram, 0);
        if (FAILED(sc))
        {
            ixssoDebugOut(( DEB_ERROR, "Type library load or registration failed (%x)\n", sc));

        #ifndef OLYMPUS_COMPONENT
            _DllUnregisterServer(QUERY_PROG_ID3, CLSID_CissoQueryEx);
            _DllUnregisterServer(QUERY_PROG_ID2, CLSID_CissoQuery);
            _DllUnregisterServer(QUERY_PROG_ID, CLSID_CissoQueryEx);
            _DllUnregisterServer(UTIL_PROG_ID2, CLSID_CissoUtil);
            _DllUnregisterServer(UTIL_PROG_ID, CLSID_CissoUtil);
        #else //OLYMPUS_COMPONENT
            _DllUnregisterServer(NLQUERY_PROG_ID1, CLSID_NlssoQuery);
            _DllUnregisterServer(NLQUERY_PROG_ID, CLSID_NlssoQuery);
            _DllUnregisterServer(NLUTIL_PROG_ID1, CLSID_NlssoUtil);
            _DllUnregisterServer(NLUTIL_PROG_ID, CLSID_NlssoUtil);
        #endif //OLYMPUS_COMPONENT
        }
    }

    return sc;
}

extern "C"
STDAPI DllUnregisterServer()
{
    ixssoDebugOut((DEB_TRACE,"[DLL] DllUnregisterServer\n"));

    SCODE sc;

    #ifndef OLYMPUS_COMPONENT
    sc = _DllUnregisterServer(QUERY_PROG_ID, CLSID_CissoQueryEx);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(QUERY_PROG_ID3, CLSID_CissoQueryEx);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(QUERY_PROG_ID2, CLSID_CissoQuery);

    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(UTIL_PROG_ID, CLSID_CissoUtil);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(UTIL_PROG_ID2, CLSID_CissoUtil);

    #else //OLYMPUS_COMPONENT
    sc = _DllUnregisterServer(NLQUERY_PROG_ID, CLSID_NlssoQuery);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(NLQUERY_PROG_ID1, CLSID_NlssoQuery);

    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(NLUTIL_PROG_ID, CLSID_NlssoUtil);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(NLUTIL_PROG_ID1, CLSID_NlssoUtil);
    #endif  //OLYMPUS_COMPONENT

    return sc;
}

extern "C"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID  * ppv)
{
    // get the class factory object
    if ( CLSID_ixssoQueryEx == rclsid || CLSID_ixssoQuery == rclsid )
    {
        IxssoQueryCF.SetClsid( rclsid );
        return IxssoQueryCF.QueryInterface( riid, ppv );
    }
    else if ( CLSID_ixssoUtil == rclsid )
    {
        // NOTE: There is no difference in the behavior of the Util object.
        return IxssoUtilCF.QueryInterface( riid, ppv );
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
}


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lbv)
{
    BOOL fRetval = TRUE;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        switch (dwReason)
        {
    
        case DLL_PROCESS_ATTACH:
            //DbgPrint("IXSSO: [DLL] Process Attached\n");
            g_hInst = hInst;
            InitializeCriticalSection( &g_cs );
            break;
    
        case DLL_THREAD_DETACH:
            //
            // This is an opportunity to release resources; necessary since
            // ASP doesn't call CoFreeUnusedLibraries.
            //
            ixssoDebugOut((DEB_REFCOUNTS, "[DLL] Thread detached\n"));
            if (0 == g_ulObjCount)
            {
                FreeResources();
            }
            break;
    
        case DLL_PROCESS_DETACH:
    
            // NOTE:  We can get called here without having freed resources
            //        if the client application is single-threaded, or if
            //        thread detach calls are disabled.  In this case, it's
            //        too late to free the ADO recordset class factory because
            //        the ADO DLL may have already been unloaded.
    #if CIDBG
            if ( 0 != CIxssoQueryCF::_pIAdoRecordsetCF && 0 != g_ulObjCount )
            {
                ixssoDebugOut((DEB_WARN, "WARNING - %d unreleased objects\n", g_ulObjCount ));
            }
    #endif //CIDBG
    
            if (CIxssoQueryCF::_pITypeLibIxsso)
            {
                CIxssoQueryCF::_pITypeLibIxsso->Release();
                CIxssoQueryCF::_pITypeLibIxsso = 0;
            }
    
            if (g_pTheGlobalIXSSOVariables)
            {
                delete g_pTheGlobalIXSSOVariables;
                g_pTheGlobalIXSSOVariables = 0;
            }
    
            DeleteCriticalSection( &g_cs );
            // DbgPrint("IXSSO: [DLL] Process Detached\n");
            break;
        }
    }
    CATCH( CException, e )
    {
        // About the only thing this could be is STATUS_NO_MEMORY which
        // can be thrown by InitializeCriticalSection.

        ixssoDebugOut(( DEB_ERROR,
                        "IXSSO: Exception %#x in DllMain\n",
                        e.GetErrorCode()));

#if CIDBG == 1  // for debugging NTRAID 340297
        if (e.GetErrorCode() == STATUS_NO_MEMORY)
            DbgPrint( "IXSSO: STATUS_NO_MEMORY exception in DllMain\n");
        else
            DbgPrint( "IXSSO: ??? Exception in DllMain\n");
#endif // CIDBG == 1

        fRetval = FALSE;
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return fRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\ci\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

$(O)\ixsso.def: ixsso.def ..\ixsso.org

$(O)\ixsso.tlb $(O)\ixssoifc.h $(O)\ixsso_i.c: ..\ixsso.odl

$(O)\ixsso.res: $(O)\ixsso.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    07-Nov-95   DwightKr    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windows.h>
#include <objsafe.h>
#include <ocidl.h>
#include <comdef.h>
#include <shlguid.h>
#include <wininet.h>

#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <stdio.h>

#include <cidebnot.h>
#include <ciexcpt.hxx>
#include <cisem.hxx>
#include <tsmem.hxx>
#include <smart.hxx>
#include <ci64.hxx>

#include <cierror.h>

// #define OLEDBVER 0x0250     // enable ICommandTree interface
#define deprecated          // enable IRowsetExactScroll
#include <oledb.h>
#include <query.h>
#include <dbcmdtre.hxx>

#include <stgprop.h>
#include <stgvarb.hxx>
#include <restrict.hxx>

#define _CAIROSTG_

#include <oledberr.h>

#include <vquery.hxx>
#include <dynarray.hxx>
#include <regacc.hxx>
#include <caturl.hxx>
#include <parser.hxx>
#include <plist.hxx>
#include <scanner.hxx>
#include <doquery.hxx>
#include <weblcid.hxx>
#include "ixsexcpt.hxx"
#include "ixssomsg.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\regutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       regutil.h
//
//  Contents:   Utility funcitons for manipulating the registry
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

#ifndef _regutil_H_
#define _regutil_H_

// functions to aid in DllRegisterServer() and DllUnregisterServer()
STDAPI _DllRegisterServer(HINSTANCE hInst,
                          LPWSTR pwszProgId,
                          REFCLSID clsid,
                          LPWSTR pwszDescription,
                          LPWSTR pwszCurVer = 0);

STDAPI _DllUnregisterServer(LPWSTR pwszProgID, REFCLSID clsid);

#endif // _regutil_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\asp\asptlb.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Sun Nov 16 14:31:59 1997
 */
/* Compiler settings for asp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef ___asptlb_h__
#define ___asptlb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IStringList_FWD_DEFINED__
#define __IStringList_FWD_DEFINED__
typedef interface IStringList IStringList;
#endif 	/* __IStringList_FWD_DEFINED__ */


#ifndef __IRequestDictionary_FWD_DEFINED__
#define __IRequestDictionary_FWD_DEFINED__
typedef interface IRequestDictionary IRequestDictionary;
#endif 	/* __IRequestDictionary_FWD_DEFINED__ */


#ifndef __IRequest_FWD_DEFINED__
#define __IRequest_FWD_DEFINED__
typedef interface IRequest IRequest;
#endif 	/* __IRequest_FWD_DEFINED__ */


#ifndef __Request_FWD_DEFINED__
#define __Request_FWD_DEFINED__

#ifdef __cplusplus
typedef class Request Request;
#else
typedef struct Request Request;
#endif /* __cplusplus */

#endif 	/* __Request_FWD_DEFINED__ */


#ifndef __IReadCookie_FWD_DEFINED__
#define __IReadCookie_FWD_DEFINED__
typedef interface IReadCookie IReadCookie;
#endif 	/* __IReadCookie_FWD_DEFINED__ */


#ifndef __IWriteCookie_FWD_DEFINED__
#define __IWriteCookie_FWD_DEFINED__
typedef interface IWriteCookie IWriteCookie;
#endif 	/* __IWriteCookie_FWD_DEFINED__ */


#ifndef __IResponse_FWD_DEFINED__
#define __IResponse_FWD_DEFINED__
typedef interface IResponse IResponse;
#endif 	/* __IResponse_FWD_DEFINED__ */


#ifndef __Response_FWD_DEFINED__
#define __Response_FWD_DEFINED__

#ifdef __cplusplus
typedef class Response Response;
#else
typedef struct Response Response;
#endif /* __cplusplus */

#endif 	/* __Response_FWD_DEFINED__ */


#ifndef __IVariantDictionary_FWD_DEFINED__
#define __IVariantDictionary_FWD_DEFINED__
typedef interface IVariantDictionary IVariantDictionary;
#endif 	/* __IVariantDictionary_FWD_DEFINED__ */


#ifndef __ISessionObject_FWD_DEFINED__
#define __ISessionObject_FWD_DEFINED__
typedef interface ISessionObject ISessionObject;
#endif 	/* __ISessionObject_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __IApplicationObject_FWD_DEFINED__
#define __IApplicationObject_FWD_DEFINED__
typedef interface IApplicationObject IApplicationObject;
#endif 	/* __IApplicationObject_FWD_DEFINED__ */


#ifndef __Application_FWD_DEFINED__
#define __Application_FWD_DEFINED__

#ifdef __cplusplus
typedef class Application Application;
#else
typedef struct Application Application;
#endif /* __cplusplus */

#endif 	/* __Application_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __IScriptingContext_FWD_DEFINED__
#define __IScriptingContext_FWD_DEFINED__
typedef interface IScriptingContext IScriptingContext;
#endif 	/* __IScriptingContext_FWD_DEFINED__ */


#ifndef __ScriptingContext_FWD_DEFINED__
#define __ScriptingContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScriptingContext ScriptingContext;
#else
typedef struct ScriptingContext ScriptingContext;
#endif /* __cplusplus */

#endif 	/* __ScriptingContext_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 



DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0,0xA85C,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IStringList,0xD97A6DA0,0xA85D,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8")
    IStringList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStringList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in][optional] */ VARIANT i,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0,0xA85F,0x11df,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85F-11df-83AE-00A0C90C2BD8")
    IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequestDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IRequestDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IRequestDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Count_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IRequestDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Key_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IRequestDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IRequest,0xD97A6DA0,0xA861,0x11cf,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A861-11cf-93AE-00A0C90C2BD8")
    IRequest : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBytes( 
            /* [retval][out] */ long __RPC_FAR *pcbTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryRead( 
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalBytes )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcbTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryRead )( 
            IRequest __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#define IRequest_get_TotalBytes(This,pcbTotal)	\
    (This)->lpVtbl -> get_TotalBytes(This,pcbTotal)

#define IRequest_BinaryRead(This,pvarCountToRead,pvarReturn)	\
    (This)->lpVtbl -> BinaryRead(This,pvarCountToRead,pvarReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_TotalBytes_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcbTotal);


void __RPC_STUB IRequest_get_TotalBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequest_BinaryRead_Proxy( 
    IRequest __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);


void __RPC_STUB IRequest_BinaryRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Request,0x920c25d0,0x25d9,0x11d0,0xa5,0x5f,0x00,0xa0,0xc9,0x0c,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("920c25d0-25d9-11d0-a55f-00a0c90c2091")
Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IReadCookie,0x71EAF260,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EAF260-0CE0-11D0-A53E-00A0C90C2091")
    IReadCookie : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReadCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IReadCookie_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IReadCookie_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Count_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IReadCookie_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Key_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IReadCookie_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0,0xA862,0x11cf,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A862-11cf-84AE-00A0C90C2BD8")
    IWriteCookie : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrDomain);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWriteCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWriteCookie_put_Item(This,key,bstrValue)	\
    (This)->lpVtbl -> put_Item(This,key,bstrValue)

#define IWriteCookie_put_Expires(This,dtExpires)	\
    (This)->lpVtbl -> put_Expires(This,dtExpires)

#define IWriteCookie_put_Domain(This,bstrDomain)	\
    (This)->lpVtbl -> put_Domain(This,bstrDomain)

#define IWriteCookie_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IWriteCookie_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT key,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrDomain);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IResponse,0xD97A6DA0,0xA864,0x11cf,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A864-11cf-83BE-00A0C90C2BD8")
    IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Buffer( 
            /* [in] */ VARIANT_BOOL fIsBuffering) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContentType( 
            /* [in] */ BSTR bstrContentType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ long lExpiresMinutes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpiresAbsolute( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ BSTR bstrStatus) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryWrite( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsClientConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CharSet( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CharSet( 
            /* [in] */ BSTR bstrCharSet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pics( 
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CacheControl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CacheControl( 
            /* [in] */ BSTR bstrCacheControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIsBuffering);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrContentType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ long lExpiresMinutes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrStatus);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClientConnected )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCharSet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pics )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCacheControl);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,bstrContentType)	\
    (This)->lpVtbl -> put_ContentType(This,bstrContentType)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,lExpiresMinutes)	\
    (This)->lpVtbl -> put_Expires(This,lExpiresMinutes)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,dtExpires)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,dtExpires)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,bstrStatus)	\
    (This)->lpVtbl -> put_Status(This,bstrStatus)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,varInput)	\
    (This)->lpVtbl -> BinaryWrite(This,varInput)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#define IResponse_IsClientConnected(This,pfIsClientConnected)	\
    (This)->lpVtbl -> IsClientConnected(This,pfIsClientConnected)

#define IResponse_get_CharSet(This,pbstrCharSetRet)	\
    (This)->lpVtbl -> get_CharSet(This,pbstrCharSetRet)

#define IResponse_put_CharSet(This,bstrCharSet)	\
    (This)->lpVtbl -> put_CharSet(This,bstrCharSet)

#define IResponse_Pics(This,bstrHeaderValue)	\
    (This)->lpVtbl -> Pics(This,bstrHeaderValue)

#define IResponse_get_CacheControl(This,pbstrCacheControl)	\
    (This)->lpVtbl -> get_CacheControl(This,pbstrCacheControl)

#define IResponse_put_CacheControl(This,bstrCacheControl)	\
    (This)->lpVtbl -> put_CacheControl(This,bstrCacheControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrContentType);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ long lExpiresMinutes);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrStatus);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_IsClientConnected_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);


void __RPC_STUB IResponse_IsClientConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);


void __RPC_STUB IResponse_get_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCharSet);


void __RPC_STUB IResponse_put_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Pics_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_Pics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);


void __RPC_STUB IResponse_get_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCacheControl);


void __RPC_STUB IResponse_put_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Response,0x46E19BA0,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("46E19BA0-25DD-11D0-A55F-00A0C90C2091")
Response;
#endif

#ifndef __IVariantDictionary_INTERFACE_DEFINED__
#define __IVariantDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVariantDictionary
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IVariantDictionary,0x4a7deb90,0xb069,0x11d0,0xb3,0x73,0x00,0xa0,0xc9,0x0c,0x2b,0xd8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7deb90-b069-11d0-b373-00a0c90c2bd8")
    IVariantDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariantDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IVariantDictionaryVtbl;

    interface IVariantDictionary
    {
        CONST_VTBL struct IVariantDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariantDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariantDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariantDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariantDictionary_get_Item(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Item(This,VarKey,pvar)

#define IVariantDictionary_put_Item(This,VarKey,var)	\
    (This)->lpVtbl -> put_Item(This,VarKey,var)

#define IVariantDictionary_putref_Item(This,VarKey,var)	\
    (This)->lpVtbl -> putref_Item(This,VarKey,var)

#define IVariantDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#define IVariantDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IVariantDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_put_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_putref_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Key_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Count_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IVariantDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get__NewEnum_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IVariantDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantDictionary_INTERFACE_DEFINED__ */


#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][oleautomation][dual][uuid] */ 



DEFINE_GUID(IID_ISessionObject,0xD97A6DA0,0xA865,0x11cf,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A865-11cf-83AF-00A0C90C2BD8")
    ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Timeout( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodePage( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CodePage( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LCID( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LCID( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISessionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define ISessionObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,lvar)	\
    (This)->lpVtbl -> put_Timeout(This,lvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#define ISessionObject_get_CodePage(This,plvar)	\
    (This)->lpVtbl -> get_CodePage(This,plvar)

#define ISessionObject_put_CodePage(This,lvar)	\
    (This)->lpVtbl -> put_CodePage(This,lvar)

#define ISessionObject_get_LCID(This,plvar)	\
    (This)->lpVtbl -> get_LCID(This,plvar)

#define ISessionObject_put_LCID(This,lvar)	\
    (This)->lpVtbl -> put_LCID(This,lvar)

#define ISessionObject_get_StaticObjects(This,ppTaggedObjects)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppTaggedObjects)

#define ISessionObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_StaticObjects_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);


void __RPC_STUB ISessionObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Contents_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ISessionObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Session,0x509F8F20,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("509F8F20-25DE-11D0-A55F-00A0C90C2091")
Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0,0xA866,0x11cf,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A866-11cf-83AE-10A0C90C2BD8")
    IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnLock( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IApplicationObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define IApplicationObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#define IApplicationObject_get_StaticObjects(This,ppProperties)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppProperties)

#define IApplicationObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_StaticObjects_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Contents_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Application,0x7C3BAF00,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("7C3BAF00-25DE-11D0-A55F-00A0C90C2091")
Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IServer,0xD97A6DA0,0xA867,0x11cf,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A867-11cf-83AE-01A0C90C2BD8")
    IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ScriptTimeout( 
            /* [in] */ long lTimeoutSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLPathEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long lTimeoutSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLPathEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,lTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,lTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#define IServer_URLPathEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLPathEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long lTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLPathEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLPathEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Server,0xA506D160,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("A506D160-25E0-11D0-A55F-00A0C90C2091")
Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A868-11cf-83AE-00B0C90C2BD8")
    IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptingContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus

class DECLSPEC_UUID("D97A6DA0-A868-11cf-83AE-11B0C90C2BD8")
ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\regutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:       regutil.cxx
//
//  Contents:   Functions supporting class registration
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "regutil.h"

#define GUID_SIZE 128

//+---------------------------------------------------------------------------
//
//  Function:   _DllRegisterServer - public
//
//  Synopsis:   Installs a class registration for an inproc server
//
//  Arguments:  [hInst] --           HINSTANCE of DLL to be installed
//              [pwszProgId] --      program ID (class name)
//              [clsid] --           Class ID of class
//              [pwszDescription] -- description of class
//              [pwszCurVer]      -- if non-NULL, current version
//
//  Returns:    SCODE - status of registration
//
//  History:    03 Jan 1997      Alanw    Added header
//
//  NTRAID#DB-NTBUG9-84747-2000/07/31-dlee No transaction / Rollback semantics for DLL registration of IXSSO
//
//----------------------------------------------------------------------------

STDAPI _DllRegisterServer(HINSTANCE hInst,
                          LPWSTR pwszProgId,
                          REFCLSID clsid,
                          LPWSTR pwszDescription,
                          LPWSTR pwszCurVer)
{
    HKEY    hKey;
    WCHAR   wcsSubKey[MAX_PATH+1];
    WCHAR   wcsClsId[GUID_SIZE+1];
    
    StringFromGUID2(clsid, wcsClsId, sizeof(wcsClsId) / sizeof WCHAR);
     
    LONG r = RegCreateKey(HKEY_CLASSES_ROOT, pwszProgId, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    r = RegSetValue(hKey, NULL, REG_SZ,
                    pwszDescription, wcslen(pwszDescription) * sizeof (WCHAR));
    RegCloseKey(hKey);

    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    wsprintf(wcsSubKey, L"%ws\\CLSID", pwszProgId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    r = RegSetValue(hKey, NULL, REG_SZ,
                    wcsClsId, wcslen(wcsClsId) * sizeof (WCHAR));
    RegCloseKey(hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    if ( pwszCurVer )
    {
        wsprintf(wcsSubKey, L"%ws\\CurVer", pwszProgId);
        r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
        if ( ERROR_SUCCESS != r )
            return HRESULT_FROM_WIN32( r );
        r = RegSetValue(hKey, NULL, REG_SZ,
                    pwszCurVer, wcslen(pwszCurVer) * sizeof (WCHAR));
        RegCloseKey(hKey);
        if ( ERROR_SUCCESS != r )
            return HRESULT_FROM_WIN32( r );
    }

    wsprintf(wcsSubKey, L"CLSID\\%ws", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    r = RegSetValue(hKey, NULL, REG_SZ,
                pwszDescription, wcslen(pwszDescription) * sizeof (WCHAR));
    RegCloseKey(hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    wsprintf(wcsSubKey, L"CLSID\\%ws\\InProcServer32", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    GetModuleFileName(hInst, wcsSubKey, MAX_PATH);
    r = RegSetValue(hKey, NULL, REG_SZ,
                wcsSubKey, wcslen(wcsSubKey) * sizeof (WCHAR));
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    wcscpy(wcsSubKey, L"Both");
    r = RegSetValueEx(hKey, L"ThreadingModel", NULL, REG_SZ,
                   (BYTE*)wcsSubKey, wcslen(wcsSubKey) * sizeof (WCHAR));
    RegCloseKey(hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    wsprintf(wcsSubKey, L"CLSID\\%ws\\ProgID", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    r = RegSetValue(hKey, NULL, REG_SZ,
                pwszProgId, wcslen(pwszProgId) * sizeof (WCHAR));
    RegCloseKey(hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    //
    // Indicate the object is 'safely' initializable and scriptable
    //

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    RegCloseKey(hKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories\\{7DD95801-9882-11CF-9FA9-00AA006C42C4}", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    RegCloseKey(hKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories\\{7DD95802-9882-11CF-9FA9-00AA006C42C4}", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    RegCloseKey(hKey);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   _DllUnregisterServer - public
//
//  Synopsis:   Uninstalls a class registration for an inproc server
//
//  Arguments:  [pwszProgId] --      program ID (class name)
//              [clsid] --           Class ID of class
//
//  Returns:    SCODE - status of de-registration
//
//  History:    03 Jan 1997      Alanw    Added header
//
//----------------------------------------------------------------------------


STDAPI _DllUnregisterServer(LPWSTR pwszProgID, REFCLSID clsid)
{
    //
    // Ignore errors -- do a best effort to uninstall since we don't know
    // what shape the registry is in.
    //

    WCHAR wcsClsId[GUID_SIZE+1];

    StringFromGUID2(clsid, wcsClsId, sizeof(wcsClsId) / sizeof WCHAR);

    WCHAR wcsSubKey[256];

    wsprintf(wcsSubKey, L"%ws\\CLSID", pwszProgID);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"%ws\\CurVer", pwszProgID);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    RegDeleteKey(HKEY_CLASSES_ROOT, pwszProgID);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\InProcServer32", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\ProgID", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories\\{7DD95801-9882-11CF-9FA9-00AA006C42C4}", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories\\{7DD95802-9882-11CF-9FA9-00AA006C42C4}", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\web\ixsso\ixsutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       ixsutil.cxx
//
//  Contents:   Utility SSO class
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop


//-----------------------------------------------------------------------------
// Include Files
//-----------------------------------------------------------------------------

// debugging macros
#include "ssodebug.hxx"

// class declaration
#include "stdcf.hxx"
#include "ixsso.hxx"
#include "ixsutil.hxx"

#include <string.hxx>
#include <htmlchar.hxx>

extern WCHAR * g_pwszProgIdUtil;

#if CIDBG
    extern ULONG g_ulObjCount;
    extern LONG  g_lUtlCount;
#endif // CIDBG

//-----------------------------------------------------------------------------
//
//  Member:     CixssoUtil::CixssoUtil - public
//
//  Synopsis:   Constructor of CixssoUtil
//
//  Arguments:  [pitlb] - pointer to ITypeLib for ixsso
//
//  History:    04 Apr 1997      Alanw    Created
//
//-----------------------------------------------------------------------------

CixssoUtil::CixssoUtil( ITypeLib * pitlb ) :
    _ptinfo( 0 ),
    _err( IID_IixssoUtil )
{
    _cRef = 1;

    SCODE sc = pitlb->GetTypeInfoOfGuid( IID_IixssoUtil, &_ptinfo );
    if (FAILED(sc))
    {
        ixssoDebugOut(( DEB_ERROR, "Util - GetTypeInfoOfGuid failed (%x)\n", sc ));
        Win4Assert(SUCCEEDED(sc));

        THROW( CException(sc) );
    }

    INC_OBJECT_COUNT();

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL]: Create util: refcounts: glob %d util %d\n",
          g_ulObjCount,
          g_lUtlCount ));
} //CixssoUtil

//-----------------------------------------------------------------------------
//
//  Member:     CixssoUtil::~CixssoUtil - public
//
//  Synopsis:   Destructor of CixssoUtil
//
//  History:    04 Apr 1997      Alanw    Created
//
//-----------------------------------------------------------------------------

CixssoUtil::~CixssoUtil( )
{
    if (_ptinfo)
        _ptinfo->Release();
    DEC_OBJECT_COUNT();
#if CIDBG
    extern LONG g_lUtlCount;
    LONG l = InterlockedDecrement( &g_lUtlCount );
    Win4Assert( l >= 0 );
#endif //CIDBG

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL]: Delete util: refcounts: glob %d util %d\n",
          g_ulObjCount,
          g_lUtlCount ));
} //~CixssoUtl


#if 0 // NOTE: OnStartPage and OnEndPage are unneeded
//
// ASP Methods
//

#include <asp/asptlb.h>

STDMETHODIMP CixssoUtil::OnStartPage (IUnknown* pUnk)
{
    if ( 0 == pUnk )
        return E_INVALIDARG;

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        // reset the error structure
        _err.Reset();
    
        IScriptingContext *piContext;
    
        //Get IScriptingContext Interface
        sc = pUnk->QueryInterface(IID_IScriptingContext, (void**)&piContext);
        if (FAILED(sc))
            return E_FAIL;
    
        //Get Request Object Pointer
        IRequest* piRequest = NULL;
        sc = piContext->get_Request(&piRequest);
    
        //Get ServerVariables Pointer
        IRequestDictionary *piRequestDict = NULL;
        sc = piRequest->get_ServerVariables(&piRequestDict);
    
        VARIANT vtOut;
        VariantInit(&vtOut);
    
        //Get the HTTP_ACCEPT_LANGUAGE Item
        sc = piRequestDict->get_Item(g_vtAcceptLanguageHeader, &vtOut);
    
        //vtOut Contains an IDispatch Pointer.  To fetch the value
        //for HTTP_ACCEPT_LANGUAGE you must get the Default Value for the
        //Object stored in vtOut using VariantChangeType.
        if (V_VT(&vtOut) != VT_BSTR)
            VariantChangeType(&vtOut, &vtOut, 0, VT_BSTR);
    
        if (V_VT(&vtOut) == VT_BSTR)
        {
            ixssoDebugOut((DEB_TRACE, "OnStartPage: HTTP_ACCEPT_LANGUAGE = %ws\n",
                                       V_BSTR(&vtOut) ));
            SetLocaleString(V_BSTR(&vtOut));
        }
        else
        {
            ixssoDebugOut(( DEB_TRACE,
                            "OnStart: HTTP_ACCEPT_LANGAUGE was not set is ServerVariables; using lcid=0x%x\n",
                            GetSystemDefaultLCID() ));
    
            put_LocaleID( GetSystemDefaultLCID() );
        }
    
        VariantClear(&vtOut);
    
        piRequestDict->Release();
        piRequest->Release();
        piContext->Release();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("OnStartPage"), eIxssoError );
    }
    END_CATCH

    return sc;
}


HRESULT CixssoUtil::OnEndPage(void)
{

    return S_OK;
}
#endif  // 0 NOTE: OnStartPage and OnEndPage are unneeded


//-----------------------------------------------------------------------------
// CixssoUtil IUnknown Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::QueryInterface(REFIID iid, void * * ppv)
{
    *ppv = 0;

    if (iid == IID_IUnknown || iid == IID_IDispatch)
        *ppv = (IDispatch *)this;
    else if (iid == IID_ISupportErrorInfo )
        *ppv = (ISupportErrorInfo *) this;
    else if (iid == IID_IixssoUtil )
        *ppv = (IixssoUtil *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
} //QueryInterface

STDMETHODIMP_(ULONG)
CixssoUtil::AddRef(void)
{
    return InterlockedIncrement((long *)&_cRef);
}

STDMETHODIMP_(ULONG)
CixssoUtil::Release(void)
{
    ULONG uTmp = InterlockedDecrement((long *)&_cRef);
    if (uTmp == 0)
    {
        delete this;
        return 0;
    }
    return uTmp;
}


//-----------------------------------------------------------------------------
// CixssoUtil IDispatch Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP
CixssoUtil::GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo * * pptinfo)
{
    _ptinfo->AddRef();
    *pptinfo = _ptinfo;
    return S_OK;
}

STDMETHODIMP
CixssoUtil::GetIDsOfNames(
      REFIID riid,
      OLECHAR * * rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid)
{
    return DispGetIDsOfNames(_ptinfo, rgszNames, cNames, rgdispid);
}

STDMETHODIMP
CixssoUtil::Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pParams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr)
{
    ixssoDebugOut((DEB_IDISPATCH, "Util - Invoking method dispid=%d wFlags=%d\n",
                                   dispidMember, wFlags ));


    _err.Reset();

    SCODE sc = DispInvoke( this, _ptinfo,
                           dispidMember, wFlags, pParams,
                           pvarResult, pexcepinfo, puArgErr );

    if ( _err.IsError() )
        sc = DISP_E_EXCEPTION;

    return sc;
}

STDMETHODIMP
CixssoUtil::InterfaceSupportsErrorInfo(
    REFIID riid)
{
    if (riid == IID_IixssoUtil)
        return S_OK;
    else
        return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CopyWstrToBstr - private inline
//
//  Synopsis:   Copies a Unicode string to a BSTR
//
//  Arguments:  [pbstr] - destination BSTR
//              [pwstr] - string to be copied
//
//  Returns:    SCODE - status return
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoUtil::CopyWstrToBstr( BSTR * pbstr, WCHAR const * pwstr )
{
    *pbstr = 0;
    if (pwstr)
    {
        *pbstr = SysAllocString( pwstr );
        if (0 == *pbstr)
            return E_OUTOFMEMORY;
    }
    return S_OK;
}


//-----------------------------------------------------------------------------
// CixssoUtil Methods
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::ISOToLocaleID - public
//
//  Synopsis:   Parse the input string for a recognizable locale name
//
//  Arguments:  [bstrLocale] - input string
//              [pLcid]      - pointer where corresponding LCID is returned
//
//  Returns:    SCODE - status return
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::ISOToLocaleID(BSTR bstrLocale, LONG *pLcid)
{
    _err.Reset();

    if ( 0 == pLcid )
        return E_INVALIDARG;

    *pLcid = GetLCIDFromString( bstrLocale );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::LocaleIDToISO - public
//
//  Synopsis:   Return the ISO locale name for an LCID
//
//  Arguments:  [Lcid] - input LCID
//              [pstr] - pointer where output string is returned
//
//  Returns:    SCODE - status return
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::LocaleIDToISO(LONG lcid, BSTR * pstr)
{
    _err.Reset();

    if ( 0 == pstr )
        return E_INVALIDARG;

    WCHAR awc[100];

    GetStringFromLCID( lcid, awc );

    return CopyWstrToBstr( pstr, awc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::AddScopeToQuery - public
//
//  Synopsis:   Parse the input string for a recognizable locale name
//
//  Arguments:  [pDisp]     - an IDispatch for the query object
//              [bstrScope] - input scope
//              [bstrDepth] - input depth (optional)
//
//  Returns:    SCODE - status return
//
//  Notes:      In the future, this will operate by modifying the query
//              property to include a scope restriction.
//              For now, it just adds the scope and depth via a private
//              interface.
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::AddScopeToQuery( IDispatch * pDisp,
                             BSTR bstrScope,
                             BSTR bstrDepth)
{
    _err.Reset();

    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        if ( 0 == pDisp )
            THROW( CException( E_INVALIDARG ) );

        IixssoQueryPrivate * pIQueryPvt = 0;
        sc = pDisp->QueryInterface( IID_IixssoQueryPrivate, (void **)&pIQueryPvt );

        if (FAILED(sc))
        {
            THROW(CException(sc));
        }

        XInterface<IixssoQueryPrivate> pQry(pIQueryPvt);
        pQry->AddScopeToQuery( bstrScope, bstrDepth );
    }
    CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("AddScopeToQuery"), eIxssoError );
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("AddScopeToQuery") );
    }
    END_CATCH

    return sc;
} //AddScopeToQuery

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::TruncateToWhitespace - public
//
//  Synopsis:   Truncate a string, preferably at a white space character.
//
//  Arguments:  [bstrIn]   - input string
//              [maxLen]   - maximum number of characters in output string
//              [pbstrOut] - pointer where output string is returned
//
//  Returns:    SCODE - status return
//
//  Notes:      The implementation does not take into account real word breaks.
//              This may not work too well on far eastern languages.
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::TruncateToWhitespace(BSTR bstrIn, LONG maxLen, BSTR * pbstrOut)
{
    _err.Reset();

    ULONG cchString = 0;
    if (maxLen <= 0)
        return E_INVALIDARG;

    if (0 != bstrIn)
        cchString = SysStringLen(bstrIn);

    if (cchString > (unsigned)maxLen)
    {
        cchString = maxLen;
        for (unsigned i=0; i <= (unsigned)maxLen; i++)
        {
            if (iswspace(bstrIn[i]))
                cchString = i;
        }
    }

    *pbstrOut = SysAllocStringLen( bstrIn, cchString );

    if (0 == *pbstrOut)
        return E_OUTOFMEMORY;

    return S_OK;
} //TruncateToWhitespace

class XVariant
{
public:
    XVariant() : _pVar( 0 ) {}
    XVariant( VARIANT & var ) : _pVar( &var ) {}
    ~XVariant() { if ( 0 != _pVar ) VariantClear( _pVar ); }
    void Set( VARIANT & var ) { Win4Assert( 0 == _pVar ); _pVar = &var; }
private:
    VARIANT * _pVar;
};

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::GetArrayElement - public
//
//  Synopsis:   Returns an element in an array as a variant
//
//  Arguments:  [pVarIn]   - The input array (IDispatch or VT_ARRAY)
//              [iElement] - The element to retrieve
//              [pVarOut]  - Where the array element result is written
//
//  Returns:    SCODE - status return
//
//  History:    10 Sep 1997      dlee    Created
//              18 Jan 2000      KLam    DECIMAL needs to fit into a VARIANT
//                                       on Win64 VARIANT is bigger than DECIMAL
//
//----------------------------------------------------------------------------

STDMETHODIMP CixssoUtil::GetArrayElement(
    VARIANT * pVarIn,
    LONG      iElement,
    VARIANT * pVarOut )
{
    _err.Reset();

    //
    // Validate the variant arguments.
    //

    if ( ( 0 == pVarIn ) || ( 0 == pVarOut ) )
        return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

    //
    // Get the source array, either from the IDispatch or just copy it.
    //

    XVariant xvar;
    VARIANT varArray;
    VariantInit( &varArray );

    if ( VT_DISPATCH == pVarIn->vt )
    {
        //
        // The first argument is an IDispatch, not the array value, so we
        // have to invoke it to get the value out.
        //

        if ( 0 == pVarIn->pdispVal )
            return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

        SCODE sc = pVarIn->pdispVal->Invoke( DISPID_VALUE,
                                             IID_NULL,
                                             GetSystemDefaultLCID(),
                                             DISPATCH_PROPERTYGET,
                                             &dispparamsNoArgs,
                                             &varArray,
                                             0,
                                             0 );
        ixssoDebugOut(( DEB_ITRACE, "result of invoke: 0x%x\n", sc ));
        if ( FAILED( sc ) )
            return SetError( sc, OLESTR( "GetArrayElement" ) );

        xvar.Set( varArray );
    }
    else
    {
        varArray = *pVarIn;
    }

    ixssoDebugOut(( DEB_ITRACE, "value vt: 0x%x\n", varArray.vt ));

    //
    // Check for a valid variant array argument.
    //

    if ( ( 0 == ( VT_ARRAY & varArray.vt ) ) ||
         ( 0 == varArray.parray ) )
        return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

    SAFEARRAY *psa = varArray.parray;

    //
    // This function only deals with 1-dimensional safearrays.
    //

    if ( 1 != SafeArrayGetDim( psa ) )
        return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

    //
    // Make sure iElement is in the bounds of the array.
    //

    long lLowBound;
    SCODE sc = SafeArrayGetLBound( psa, 1, &lLowBound );
    if ( FAILED( sc ) )
        return SetError( sc, OLESTR( "GetArrayElement" ) );

    long lUpBound;
    sc = SafeArrayGetUBound( psa, 1, &lUpBound );
    if ( FAILED( sc ) )
        return SetError( sc, OLESTR( "GetArrayElement" ) );

    if ( ( iElement < lLowBound ) || ( iElement > lUpBound ) )
        return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

    //
    // Get a pointer to the element.
    //

    void * pvData;
    sc = SafeArrayPtrOfIndex( psa, &iElement, &pvData );
    if ( FAILED( sc ) )
        return SetError( sc, OLESTR( "GetArrayElement" ) );

    //
    // Put the element in a local variant so it can be copied.
    //

    VARIANT var;
    VariantInit( &var );
    var.vt = varArray.vt & (~VT_ARRAY);
    unsigned cbElem = SafeArrayGetElemsize( psa );

    if ( VT_VARIANT == var.vt )
    {
        Win4Assert( sizeof( VARIANT ) == cbElem );
        RtlCopyMemory( &var, pvData, cbElem );
    }
    else if ( VT_DECIMAL == var.vt )
    {
        Win4Assert( sizeof( VARIANT ) >= cbElem &&
                    sizeof( DECIMAL ) == cbElem );
        RtlCopyMemory( &var, pvData, cbElem );
        var.vt = VT_DECIMAL;
    }
    else
    {
        Win4Assert( cbElem <= 8 );
        RtlCopyMemory( &var.lVal, pvData, cbElem );
    }

    //
    // Make a copy of the value into another local variant.
    //

    VARIANT varCopy;
    VariantInit( &varCopy );
    sc = VariantCopy( &varCopy, &var );
    if ( FAILED( sc ) )
        return SetError( sc, OLESTR( "GetArrayElement" ) );

    //
    // Free anything still allocated in the output variant, and transfer
    // the value to the output variant.
    //

    VariantClear( pVarOut );
    *pVarOut = varCopy;

    return S_OK;
} //GetArrayElement

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::HTMLEncode - public
//
//  Synopsis:   Encode a string for use in HTML.  Take the output code page
//              into account so that unicode characters not representable in
//              the code page are output as HTML numeric entities.
//
//  Arguments:  [bstrIn]   - input string
//              [codepage] - code page for output string
//              [pbstrOut] - pointer where output string is returned
//
//  Returns:    SCODE - status return
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::HTMLEncode(BSTR bstrIn, LONG codepage, BSTR * pbstrOut)
{
    _err.Reset();

    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        if ( ( codepage < 0 ) || ( 0 == pbstrOut ) )
            THROW( CException( E_INVALIDARG ) );

        CVirtualString vString( 512 );

        if ( 0 != bstrIn )
            HTMLEscapeW( bstrIn, vString, codepage );

        BSTR bstr = SysAllocStringLen( vString.GetPointer(), vString.StrLen() );
        if ( 0 == bstr )
            THROW( CException( E_OUTOFMEMORY ) );

        *pbstrOut = bstr;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("HTMLEncode"), eIxssoError );
    }
    END_CATCH;

    return sc;
} //HTMLEncode

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::URLEncode - public
//
//  Synopsis:   Encode a string for use in a URL.  Take the output code page
//              into account so that unicode characters not representable in
//              the code page are output as %uxxxx escapes.
//
//  Arguments:  [bstrIn]   - input string
//              [codepage] - code page for output string
//              [pbstrOut] - pointer where output string is returned
//
//  Returns:    SCODE - status return
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::URLEncode(BSTR bstrIn, LONG codepage, BSTR * pbstrOut)
{
    _err.Reset();

    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        if ( ( codepage < 0 ) || ( 0 == pbstrOut ) )
            THROW( CException( E_INVALIDARG ) );

        CVirtualString vString( 512 );

        if ( 0 != bstrIn )
            URLEscapeW( bstrIn, vString, codepage, FALSE );

        BSTR bstr = SysAllocStringLen( vString.GetPointer(), vString.StrLen() );
        if ( 0 == bstr )
            THROW( CException( E_OUTOFMEMORY ) );

        *pbstrOut = bstr;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("URLEncode"), eIxssoError );
    }
    END_CATCH;

    return sc;
} //URLEncode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\fa.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2001.
//
//  File:       FA.cxx
//
//  Contents:   Non-deterministic finite automata
//
//  Classes:    CNFA
//
//  History:    01-20-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#pragma optimize( "", off )

#include <fa.hxx>
#include <strategy.hxx>
#include <codepage.hxx>

#include "stateset.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CFA::CFA, public
//
//  Synopsis:   Copy constructor
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CFA::CFA( CFA const & src )
        : _cTotal( src._cTotal ),
          _ppState( 0 )
{
    _ppState = new CFAState * [ _cTotal ];

    unsigned i = 0;

    TRY
    {
        for ( ; i < _cTotal; i++ )
        {
            if ( 0 == src._ppState[i] )
                _ppState[i] = 0;
            else
                _ppState[i] = new CFAState( *src._ppState[i] );
        }
    }
    CATCH( CException, e )
    {
        for ( ;i > 0; i-- )
            delete _ppState[i-1];

        delete _ppState;

        RETHROW();
    }
    END_CATCH
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::~CFA, protected
//
//  Synopsis:   Frees automata.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CFA::~CFA()
{
    if( _ppState )
    {
        for ( unsigned i = 0; i < _cTotal; i++ )
        {
            delete _ppState[i];
        }

        delete _ppState;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::Add, protected
//
//  Synopsis:   Adds new state to automata.
//
//  Arguments:  [pState] -- New state.  State number is member data.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CFA::Add( CFAState * pState )
{
    if ( pState->StateNumber() > _cTotal )
    {
        for( unsigned newTotal = (_cTotal) ? _cTotal * 2 : 1;
             pState->StateNumber() > newTotal;
             newTotal *= 2 );

        CFAState ** oldState = _ppState;

        _ppState = new CFAState * [ newTotal ];

        memcpy( _ppState, oldState,
                _cTotal * sizeof( CFAState * ) );
        memset( _ppState + _cTotal,
                0,
                (newTotal - _cTotal) * sizeof( CFAState * ) );

        _cTotal = newTotal;
    }

    _ppState[pState->StateNumber() - 1] = pState;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::Get, protected
//
//  Arguments:  [iState] -- State to fetch.
//
//  Returns:    State [iState].
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CFAState * CFA::Get( unsigned iState )
{
    vqAssert( iState <= _cTotal );
{
#   if (CIDBG == 1)
        if ( _ppState[ iState - 1 ]->StateNumber() != iState )
            vqDebugOut(( DEB_ERROR, "CFA::Get() -- Error\n" ));
#   endif // (CIDBG == 1)

    return( _ppState[ iState - 1 ] );
}
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::CNFA, public
//
//  Synopsis:   Converts regular expression string to NFA.
//
//  Arguments:  [pwcs]      -- Regular expression.
//              [fCaseSens] -- TRUE if case sensitive search.
//
//  History:    20-Jan-92 Kyleap    Created
//
//--------------------------------------------------------------------------

CNFA::CNFA( WCHAR const * pwcs, BOOLEAN fCaseSens )
        : _iNextState( 1 ),
          _iStart( 0 ),
          _chars( fCaseSens )
{
    unsigned iEnd;

    //
    // _aState initially contains room for 2 * #chars in regex.  According
    // to the Dragon Book pg. 121 this is guaranteed to be sufficient space.
    // Of course the dragon book doesn't completely take DOS or CMS into
    // account. For DOS, we need to treat beginning (and end) of line as
    // 'characters' in the string. For CMS, I agreed to support the
    // {m,n} construct, which clearly violates this rule.
    //

    if ( 0 == pwcs )
    {
        vqDebugOut(( DEB_ERROR, "ERROR: regex string value of 0 " ));

        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

    unsigned cState = wcslen( pwcs ) * 2 + 2*2;  // 2*2 for beginning & end of line
    _aState.Init( cState );

    for ( unsigned i = 1 ; i <= _aState.Count(); i++ )
        Get(i)->Init(i);

    FindCharClasses( pwcs );
    Parse( pwcs, &_iStart, &iEnd );

    Get( iEnd )->MakeFinal();
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::CNFA, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 Kylep    Created
//
//--------------------------------------------------------------------------

CNFA::CNFA( CNFA const & src )
        : _iNextState( src.NumStates() ),
          _iStart( src._iStart ),
          _chars( src._chars ),
          _aState( src._aState.Count() )
{
    for ( unsigned i = 0; i < _aState.Count(); i++ )
        _aState[i] = src._aState[i];
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::~CNFA, public
//
//  Synopsis:   Free state table.
//
//  History:    13-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

CNFA::~CNFA()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::EpsClosure, public
//
//  Synopsis:   Computes the epsilon closure for state [StateNum]
//
//  Effects:    States in the epsilon closure of state [StateNum]
//              are added to the state set [ssOut].
//
//  Arguments:  [StateNum] -- Initial state.
//              [ssOut]    -- Output state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::EpsClosure( unsigned StateNum, CStateSet & ssOut )
{
    CStateSet ssTraversed;

    ssOut.Add( StateNum );

    BOOLEAN changed = TRUE;

    while ( changed )
    {
        changed = FALSE;

        for ( unsigned i = ssOut.Count(); i > 0; i-- )
        {
            if ( !ssTraversed.IsMember( ssOut.State( i ) ) )
            {
                ssTraversed.Add( ssOut.State( i ) );

                Get( ssOut.State( i ) )->Move( ssOut, symEpsilon );

                changed = TRUE;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::EpsClosure, public
//
//  Synopsis:   Computes the epsilon closure for state set [ssIn]
//
//  Effects:    States in the epsilon closure of [ssIn]
//              are added to the state set [ssOut].
//
//  Arguments:  [ssIn]  -- Initial state set.
//              [ssOut] -- Output state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::EpsClosure( CStateSet & ssIn, CStateSet & ssOut )
{
    for ( unsigned i = ssIn.Count(); i > 0; i-- )
    {
        EpsClosure( ssIn.State( i ), ssOut );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::IsFinal, public
//
//  Arguments:  [ss] -- State set
//
//  Returns:    TRUE if some state in [ss] is final.
//
//  History:    20-Jan-92 Kyleap    Created
//
//--------------------------------------------------------------------------

BOOLEAN CNFA::IsFinal( CStateSet & ss )
{
    BOOLEAN fFinal = FALSE;

    for ( unsigned i = ss.Count(); i > 0 && !fFinal; i-- )
    {
        fFinal = (BYTE)(Get( ss.State( i ) )->IsFinal());
    }

    return( fFinal );
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::Move, public
//
//  Effects:    Performs a non-deterministic move from every state
//              in [ssIn] on [symbol].  The new state set is in
//              [ssOut].
//
//  Arguments:  [ssIn]   -- Initial state set.
//              [ssOut]  -- Final state set.
//              [symbol] -- Transition symbol.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::Move( CStateSet & ssIn, CStateSet & ssOut, unsigned symbol )
{
    for ( unsigned i = ssIn.Count(); i > 0; i-- )
    {
        Get( ssIn.State( i ) )->Move( ssOut, symbol );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::FindCharClasses, private
//
//  Effects:    Partitions the UniCode character space (2^16 characters)
//              into equivalence classes such that all characters in
//              a given class will have identical transitions in the NFA.
//
//  Arguments:  [wcs] -- Original regular expression string.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      If case sensitivity is turned off, two ranges will be
//              added for characters with upper/lower case.  Even though
//              both ranges react identically the mapping algorithm can
//              only deal with contiguous ranges of characters.
//
//--------------------------------------------------------------------------

void CNFA::FindCharClasses( WCHAR const * wcs )
{
    //
    // Scan the regex looking for characters with (potentially)
    // different transitions.
    //

    while ( *wcs )
    {
        switch ( *wcs )
        {
        case wcAnySingle:
        case wcAnyMultiple:
        case wcDOSDot:
            break;

        case wcEscape:
        {
            wcs++;

            switch ( *wcs )
            {
            case 0:
                vqDebugOut(( DEB_WARN, "Invalid regex (%wc at end of string\n", wcEscape ));
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                break;

            case wcAnySingle:
            case wcRepeatZero:
            case wcRepeatOne:
            case wcOr:
            case wcBeginParen:
            case wcEndParen:
                break;

            case wcBeginRepeat:
                for ( wcs++; *wcs; wcs++ )
                {
                    if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
                    {
                        wcs++;
                        break;
                    }
                }
                break;

            case wcBeginRange:
                wcs++;

                //
                // Check the special cases of ^ and ]
                //

                if ( *wcs == wcInvertRange )
                    wcs++;

                if ( *wcs == wcEndRange )
                {
                    _chars.AddRange( *wcs, *wcs );
                    wcs++;
                }

                for ( ; *wcs && *wcs != wcEndRange; wcs++ )
                {
                    if ( *(wcs + 1) == wcRangeSep )
                    {
                        _chars.AddRange( *wcs, *(wcs+2) );
                    }
                    else
                    {
                        _chars.AddRange( *wcs, *wcs );
                    }
                }

                if ( *wcs != wcEndRange )
                {
                    vqDebugOut(( DEB_WARN, "Invalid regex.  Missing %wc\n", wcEndRange ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }

                break;

            default:
                _chars.AddRange( *wcs, *wcs );
                break;
            }

            break;
        }

        default:
            _chars.AddRange( *wcs, *wcs );
            break;
        }

        wcs++;
    }

    _chars.Prepare();
}

WCHAR * CNFA::_wcsNull = (WCHAR*)"";

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::Parse, private
//
//  Synopsis:   Creates a NFA from [wcs]
//
//  Effects:    Parses [wcs] until end of string or character wcHalt is
//              encountered.  On exit, [iStart] and [iEnd] contain the
//              starting and ending states of the NFA, respectively.
//              [pwcsEnd] points to the last character of [wcs] that was
//              parsed.
//
//  Arguments:  [wcs]     -- Regular expression.
//              [iStart]  -- Starting state of NFA.
//              [iEnd]    -- Ending state of NFA
//              [pwcsEnd] -- Last character of [wcs] that was parsed.
//              [wcHalt]  -- Stop parsing if this character encountered.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::Parse( WCHAR const *   wcs,
                  unsigned *      iStart,
                  unsigned *      iEnd,
                  WCHAR const * * pwcsEnd,
                  WCHAR           wcHalt )
{
    unsigned iCurrent;
    unsigned iNext;

    unsigned iLocalStart;               // Used for */+/? repositioning
    BOOLEAN fRepeat = FALSE;            // Used for +
    BOOLEAN fTopLevel = (*iStart == 0); // TRUE if at top level;

    *iEnd = 0;

    //
    // Get a starting state.  *iStart == 0 implies this is the 'top-level'
    // parse of the regular expression (e.g. we're not parsing a
    // parenthesized subexpression.
    //

    if ( fTopLevel )
    {
        iCurrent = _iNextState;
        *iStart = _iNextState++;
        iLocalStart = 0;

        //
        // non-EGREP (DOS) regex match entire string.
        //

        if ( *wcs != wcAnyMultiple )
        {
            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symBeginLine, _iNextState );
            _iNextState++;
            iCurrent = iNext;
        }
        else
        {
            //
            // Add a 'special' transition on the very first state to
            // eat up characters until we actually jump into the
            // regular expresion.
            //

            Get( iCurrent )->AddTransition( symAny, Get( iCurrent )->StateNumber() );
        }
    }
    else
    {
        iCurrent = *iStart;
        iLocalStart = *iStart;
    }

    unsigned iOrStart = Get( iCurrent )->StateNumber();

    //
    // Original start of string.
    //

    WCHAR const * wcsBeginning = wcs;

    //
    // wcsLocalStart tracks the piece of string to be repeated for wcZeroOrOne, etc.
    //

    WCHAR const * wcsLocalStart = wcs;

    //
    // Parse the regular expression until there is no more or a
    // termination character is hit.
    //

    for ( ; *wcs && *wcs != wcHalt; wcs++ )
    {
        switch ( *wcs )
        {
        case wcAnySingle:
            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symAny, _iNextState );
            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;
            break;

        case wcAnyMultiple:
            //
            // Any single
            //

            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symAny, _iNextState );
            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;

            //
            // Repeat zero or more
            //

            Get( iLocalStart )->AddTransition( symEpsilon,
                                               Get( iCurrent )->StateNumber() );
            Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
            break;

        case wcEscape:
        {
            wcs++;

            switch ( *wcs )
            {
            case wcBeginParen:
            {
                unsigned iLocalEnd;

                iLocalStart = Get( iCurrent )->StateNumber();
                wcsLocalStart = wcs - 1;
                wcs++;                      // Eat '('.
                Parse( wcs, &iLocalStart, &iLocalEnd, &wcs, wcEndParen );
                wcs--;                      // Provide character for loop to eat.
                iCurrent = iLocalEnd;

                break;
            }

            case wcEndParen:
                //
                // Taken care of at outer level.  Just backup so we hit the end.
                //

                wcs--;
                break;

            case wcBeginRepeat:
            {
                if ( wcHalt == wcBeginRepeat )
                {
                    //
                    // Taken care of at outer level.  Just backup so we hit the end.
                    //

                    wcs--;
                }
                else
                {
                    //
                    // Setup: Bounds of repeated regex
                    //

                    WCHAR const * wcsStartRepeat = wcsLocalStart;
                    WCHAR const * wcsEndRepeat = wcs + 1;

                    //
                    // Setup: Repeat parameters.
                    //

                    unsigned cRepeat1, cRepeat2;
                    wcs++;

                    ParseRepeat( wcs, cRepeat1, cRepeat2 );

                    unsigned iLocalEnd;

                    //
                    // The minimum set has no epsilon transitions.
                    //

                    if ( cRepeat1 > 1 )
                    {
                        iLocalStart = Get( iCurrent )->StateNumber();
                        iLocalEnd = iLocalStart;

                        for ( unsigned i = 1; i < cRepeat1; i++ )
                        {
                            WCHAR const * wcsEnd;

                            iLocalStart = iLocalEnd;
                            iLocalEnd = 0;  // Must be zero!

                            Parse( wcsLocalStart, &iLocalStart, &iLocalEnd, &wcsEnd, wcBeginRepeat );

                            if ( wcsEnd != wcsEndRepeat )
                            {
                                vqDebugOut(( DEB_ERROR, "Invalid regex: Nested repeats?\n" ));
                                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                            }
                        }
                    }
                    else
                        iLocalEnd = Get( iCurrent )->StateNumber();

                    if ( cRepeat1 == cRepeat2 )
                    {
                        vqDebugOut(( DEB_REGEX, "REPEAT: Exactly %u times\n", cRepeat1 ));
                    }
                    else if ( cRepeat2 == 0 )
                    {
                        vqDebugOut(( DEB_REGEX, "REPEAT: At least %u times\n", cRepeat1 ));

                        Get( iLocalEnd )->AddTransition( symEpsilon, iLocalStart );
                    }
                    else if ( cRepeat2 > cRepeat1 )
                    {
                        for ( unsigned i = cRepeat1; i < cRepeat2; i++ )
                        {
                            WCHAR const * wcsEnd;

                            iLocalStart = iLocalEnd;
                            iLocalEnd = 0;  // Must be zero!

                            Parse( wcsLocalStart, &iLocalStart, &iLocalEnd, &wcsEnd, wcBeginRepeat );
                            Get( iLocalStart )->AddTransition( symEpsilon, iLocalEnd );

                            if ( wcsEnd != wcsEndRepeat )
                            {
                                vqDebugOut(( DEB_ERROR, "Invalid regex: Nested repeats?\n" ));
                                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                            }
                        }
                    }
                    else
                    {
                        vqDebugOut(( DEB_ERROR, "Invalid regex: End repeat count %d < start %d\n",
                                     cRepeat2, cRepeat1 ));
                        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                    }

                    iCurrent = iLocalEnd;
                    iLocalStart = 0;
                    wcsLocalStart = _wcsNull;
                }
                break;
            }

            case wcOr:
                if ( *iEnd == 0 )
                {
                    //
                    // First part of OR clause.
                    //

                    if ( fTopLevel )
                    {
                        iNext = _iNextState;
                        Get( iCurrent )->AddTransition( symEndLine, _iNextState );
                        _iNextState++;
                        iCurrent = iNext;
                    }

                    *iEnd = Get( iCurrent )->StateNumber();
                }
                else
                {
                    //
                    // Subsequent OR clause.  Epsilon link to end
                    //

                    Get( iCurrent )->AddTransition( symEpsilon, *iEnd );
                }
                iCurrent = iOrStart;
                wcsLocalStart = _wcsNull;
                iLocalStart = 0;
                break;

            case wcBeginRange:
            {
                BOOLEAN fReverse = FALSE;

                vqDebugOut(( DEB_REGEX, "RANGE\n" ));
                wcsLocalStart = wcs-1;
                iNext = _iNextState;
                wcs++;                      // Eat '['.  ']' eaten by loop.

                //
                // Check the special cases of ^ and ]
                //

                if ( *wcs == wcInvertRange )
                {
                    wcs++;

                    fReverse = TRUE;

                    //
                    // Add all transitions, they will be removed later.
                    //

                    for ( unsigned uiNext = _chars.TranslateRange( 1,
                                                               wcLastValidChar );
                          uiNext != 0;
                          uiNext = _chars.TranslateRange( 0, wcLastValidChar ) )
                    {
                        Get( iCurrent )->AddTransition( uiNext,
                                                  _iNextState );
                    }

                }

                if ( *wcs == wcEndRange )
                {
                    if ( fReverse )
                    {
                        Get( iCurrent )->RemoveTransition( _chars.Translate( *wcs++ ),
                                                     _iNextState );
                    }
                    else
                    {
                        Get( iCurrent )->AddTransition( _chars.Translate( *wcs++ ),
                                                  _iNextState );
                    }
                }

                for ( ; *wcs && *wcs != wcEndRange; wcs++ )
                {
                    if ( *(wcs + 1) == wcRangeSep )
                    {
                        vqDebugOut(( DEB_REGEX,
                                     "Range %u to %u\n", *wcs, *(wcs+2) ));

                        for ( unsigned uiNext = _chars.TranslateRange( *wcs,
                                                                   *(wcs+2) );
                              uiNext != 0;
                              uiNext = _chars.TranslateRange( 0, *(wcs+2) ) )
                        {
                            if ( fReverse )
                            {
                                Get( iCurrent )->RemoveTransition( uiNext,
                                                                   _iNextState );
                            }
                            else
                            {
                                Get( iCurrent )->AddTransition( uiNext,
                                                                _iNextState );
                            }
                        }

                        wcs += 2;
                    }
                    else
                    {
                        vqDebugOut(( DEB_REGEX, "Singleton = %u\n", *wcs ));

                        if ( fReverse )
                        {
                            Get( iCurrent )->RemoveTransition(
                                    _chars.Translate( *wcs ),
                                    _iNextState );
                        }
                        else
                        {
                            Get( iCurrent )->AddTransition(
                                    _chars.Translate( *wcs ),
                                    _iNextState );
                        }
                    }
                }

                if ( *wcs != wcEndRange )
                {
                    vqDebugOut(( DEB_WARN, "Invalid regex.  Missing %wc\n", wcEndRange ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }

                iLocalStart = Get( iCurrent )->StateNumber();
                _iNextState++;
                iCurrent = iNext;
                break;
            }

            case wcRepeatOne:
                if ( iLocalStart == 0 )
                {
                    vqDebugOut(( DEB_ERROR, "Invalid regex. Nothing to repeat\n" ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }

                Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
                iNext = _iNextState;

                Get( iCurrent )->AddTransition( symEpsilon, _iNextState );

                wcsLocalStart = wcs - 1;
                _iNextState++;
                iCurrent = iNext;
                break;

            case wcRepeatZero:
                if ( iLocalStart == 0 )
                {
                    vqDebugOut(( DEB_ERROR, "Invalid regex. Nothing to repeat.\n" ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }
                Get( iLocalStart )->AddTransition( symEpsilon,
                                                   Get( iCurrent )->StateNumber() );
                Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
                
                iNext = _iNextState;

                Get( iCurrent )->AddTransition( symEpsilon, _iNextState );

                wcsLocalStart = wcs - 1;
                _iNextState++;
                iCurrent = iNext;
                break;

            case wcRepeatZeroOrOne:
            {
                if ( iLocalStart == 0 )
                {
                    vqDebugOut(( DEB_ERROR, "Invalid regex.  Nothing to repeat.\n" ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }
                Get( iLocalStart )->AddTransition( symEpsilon,
                                                   Get( iCurrent )->StateNumber() );
                break;
            }

            default:
                iNext = _iNextState;

                Get( iCurrent )->AddTransition( _chars.Translate( *wcs ),
                                          _iNextState );

                iLocalStart = Get( iCurrent )->StateNumber();
                wcsLocalStart = wcs - 1;
                _iNextState++;
                iCurrent = iNext;
                break;
            }

            break;  // switch for wcEscape
        }

        default:
            iNext = _iNextState;

            Get( iCurrent )->AddTransition( _chars.Translate( *wcs ),
                                      _iNextState );

            //
            // In non-EGREP (DOS) syntax dot '.' is funny.  It will match
            // a dot, but if you're at the end of string it will also match
            // end.  So *.txt will look for strings with zero or more
            // characters followed by '.txt' but *. will find any names
            // without an extension and with no trailing dot.
            //

            if ( *wcs == wcDOSDot )
            {
                Get( iCurrent )->AddTransition( symEndLine, _iNextState );
            }

            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;
            break;
        }
    }

    //
    // non-EGREP (DOS) regex match entire string.
    //

    if ( wcHalt == 0 &&
         ( ( wcsBeginning+1 <= wcs && *(wcs-1) != wcAnyMultiple ) ||
           ( wcsBeginning+2 <= wcs && *(wcs-2) == wcEscape ) ) )
    {
        iNext = _iNextState;
        Get( iCurrent )->AddTransition( symEndLine, _iNextState );
        iLocalStart = 0;
        wcsLocalStart = _wcsNull;
        _iNextState++;
        iCurrent = iNext;
    }

    //
    // If we haven't had an OR clause yet, then set iEnd
    //

    if ( *iEnd == 0 )
    {
        //
        // First part of OR clause.
        //

        *iEnd = Get( iCurrent )->StateNumber();
    }
    else
    {
        //
        // Subsequent OR clause.  Epsilon link to end
        //

        Get( iCurrent )->AddTransition( symEpsilon, *iEnd );
    }

    if ( pwcsEnd )
    {
        *pwcsEnd = wcs + 1;             // Eat halt character.
    }

    if( *wcs != wcHalt )
    {
        vqDebugOut(( DEB_WARN, "Invalid regex.  Missing %wc\n", wcHalt ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }
}

void CNFA::ParseRepeat( WCHAR const * & wcs, unsigned & cRepeat1, unsigned & cRepeat2 )
{
    cRepeat1 = 0;
    cRepeat2 = 0;

    for ( ; *wcs && isdigit(*wcs); wcs++ )
    {
        cRepeat1 *= 10;
        cRepeat1 += *wcs - '0';
    }

    if ( cRepeat1 == 0 || cRepeat1 > 255 )
    {
        vqDebugOut(( DEB_ERROR, "Invalid regex: Repeat count %d out of bounds.\n", cRepeat1 ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

    if ( *wcs == ',' )
    {
        wcs++;

        if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
        {
            wcs++;
        }
        else
        {
            for ( ; *wcs && isdigit(*wcs); wcs++ )
            {
                cRepeat2 *= 10;
                cRepeat2 += *wcs - '0';
            }

            if ( cRepeat2 == 0 || cRepeat2 > 255 )
            {
                vqDebugOut(( DEB_ERROR, "Invalid regex: Repeat count %d too big.\n", cRepeat2 ));
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
            }

            if ( *wcs != wcEscape || *(wcs+1) != wcEndRepeat )
            {
                vqDebugOut(( DEB_ERROR, "Invalid regex: No end to repeat specification.\n" ));
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
            }
            else
            {
                wcs++;
            }
        }
    }
    else if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
    {
        wcs++;
        cRepeat2 = cRepeat1;
    }
    else
    {
        vqDebugOut(( DEB_ERROR, "Invalid regex: No end to repeat specification.\n" ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CDFA, public
//
//  Synopsis:   Constructs a DFA from a NFA.
//
//  Arguments:  [pwcs]      -- Regular expression (passed to NFA)
//              [timeLimit] -- Execution time limit
//              [fCaseSens] -- TRUE if case-sensitive search
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::CDFA( WCHAR const * pwcs, CTimeLimit & timeLimit, BOOLEAN fCaseSens )
        : _nfa( pwcs, fCaseSens ),
          _xs( _nfa.NumStates() ),
          _cState( _nfa.NumStates() ),
          _timeLimit( timeLimit )
{
    CommonCtor();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CDFA, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [pwcs]      -- Regular expression (passed to NFA)
//              [fCaseSens] -- TRUE if case-sensitive search
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::CDFA( CDFA const & src )
        : _nfa( src._nfa ),
          _xs( src._nfa.NumStates() ),
          _cState( src._nfa.NumStates() ),
          _timeLimit( (CTimeLimit &) src._timeLimit )
{
    CommonCtor();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CommonCtor, private
//
//  Synopsis:   Code common to both constructors.
//
//  History:    13-Jul-95 KyleP     Snarfed from constructor
//
//--------------------------------------------------------------------------

void CDFA::CommonCtor()
{
    //
    // Add initial state.
    //

    CStateSet ss;

    _nfa.EpsClosure( _nfa.StartState(), ss );

    _stateStart = _xs.XlatToOne( ss );

    //
    // Intialize translation table.
    //

    int cEntries = (_cState + 1) * ( _nfa.Translate().NumClasses() + 1 );

    _xStateTrans.Init( cEntries );
    _xStateFinal.Init( _cState + 1 );

    Win4Assert( stateUncomputed == 0xFFFFFFFF );
    memset( _xStateTrans.GetPointer(), 0xFF, cEntries * sizeof( unsigned ) );
    RtlZeroMemory( _xStateFinal.GetPointer(), (_cState + 1) * sizeof( BOOLEAN ) );

    for ( int i = _cState; i >= 0; i-- )
    {
        AddTransition( i, 0, stateUndefined );
    }

    Add( _stateStart, _nfa.IsFinal( ss ) );

#   if (CIDBG == 1)

        vqDebugOut(( DEB_REGEX, "Character translation:\n" ));
        _nfa.Translate().Display();

        vqDebugOut(( DEB_REGEX, "NFA:\n" ));
        _nfa.Display();

        vqDebugOut(( DEB_REGEX, "DFA state %u = NFA states ", _stateStart ));
        ss.Display();
        vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
        vqDebugOut(( DEB_REGEX, "DFA start state = %u\n", _stateStart ));

#   endif // (CIDBG == 1)

}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::~CDFA, public
//
//  Synopsis:   Clean up DFA.  Free state tables.
//
//  History:    20-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::~CDFA()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::Recognize, public
//
//  Arguments:  [wcs] -- Input string.
//
//  Returns:    TRUE if [wcs] is matched by the regular expression.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOLEAN CDFA::Recognize( WCHAR const * wcs )
{
#   if CIDBG == 1
        ValidateStateTransitions();
#   endif // CIDBG == 1

    unsigned CurrentState = _stateStart;
    unsigned LastState    = CurrentState;
    BOOLEAN fFinal        = IsFinal( CurrentState );
    WCHAR wcCurrent       = symBeginLine;

    while ( !fFinal )
    {
        unsigned NextState;

        {
            CReadAccess lock( _rwa );

            //
            // Casting is to guarantee this method doesn't modify anything (e.g. read lock ok).
            //
            #if CIDBG == 1
              NextState = ((CDFA const *)this)->Move( CurrentState, wcCurrent );
            #else
              NextState = Move( CurrentState, wcCurrent );
            #endif
        }

        vqDebugOut(( DEB_REGEX,
                     "DFA move[ %u, %u ] = %u\n",
                     CurrentState, wcCurrent, NextState ));

        if ( stateUncomputed == NextState )
        {
            CWriteAccess lock( _rwa );

            //
            // Did someone else get here first?
            //

            NextState = Move( CurrentState, wcCurrent );

            if ( stateUncomputed != NextState )
                continue;

            //
            // Build the new state
            //

            CStateSet ssCurrent;
            CStateSet ssNew;
            CStateSet ssClosed;

            _xs.XlatToMany( CurrentState, ssCurrent );

#           if (CIDBG == 1)
                vqDebugOut(( DEB_REGEX,
                             "DFA state %u = NFA states ", CurrentState ));
                ssCurrent.Display();
                if ( _nfa.IsFinal( ssCurrent ) )
                {
                    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, " FINAL" ));
                }
                vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
#           endif // (CIDBG == 1)

            _nfa.Move( ssCurrent, ssNew, wcCurrent );

            if ( ssNew.Count() == 0 )
            {
                NextState = stateUndefined;
                AddTransition( CurrentState, wcCurrent, NextState );
                vqDebugOut(( DEB_REGEX, "Undefined transition from %u on %u\n",
                             CurrentState,
                             wcCurrent ));
            }
            else
            {
                _nfa.EpsClosure( ssNew, ssClosed );

#               if (CIDBG == 1)
                    vqDebugOut(( DEB_REGEX, "NFA move FROM " ));
                    ssCurrent.Display();
                    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                                 " ON %d TO ", wcCurrent ));
                    ssClosed.Display();
                    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
#               endif // (CIDBG == 1)

                NextState = _xs.XlatToOne( ssClosed );

                if ( !IsComputed( NextState ) )
                {
                    Add( NextState, _nfa.IsFinal( ssClosed ) );
                }
#               if (CIDBG == 1)
                    vqDebugOut(( DEB_REGEX,
                                 "DFA state %u = NFA states ", NextState ));
                    ssClosed.Display();
                    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
#               endif // (CIDBG == 1)

                AddTransition( CurrentState, wcCurrent, NextState );

                vqDebugOut(( DEB_REGEX,
                             "Adding transition from %u on %u to %u\n",
                             CurrentState,
                             wcCurrent,
                             NextState ));
            }

            if ( _timeLimit.CheckExecutionTime() )
            {
                vqDebugOut(( DEB_WARN,
                             "CDFA::Recognize: aborting because execution time limit has been exceeded\n" ));
                THROW( CException( QUERY_E_TIMEDOUT ) );
            }
        }

        if ( NextState == stateUndefined )
        {
            return( FALSE );
        }

        //
        // The following are to find a specific condition detected on
        // JHavens' machine.
        //

        Win4Assert( LastState <= _cState );
        Win4Assert( CurrentState <= _cState );
        Win4Assert( NextState <= _cState );

        LastState    = CurrentState;
        CurrentState = NextState;

        fFinal = IsFinal( CurrentState );


        //
        // If we ran out of string then just keep going, appending
        // end-of-string symbols.  Unfortunately the string is conceptually
        // a set of characters followed by an arbitrary number of
        // end-of-string symbols.  In non-EGREP the end-of-string symbol
        // may actually cause multiple state transitions before reaching
        // a final state.  In non-EGREP (DOS) mode we stop only when we
        // are no longer 'making progress' (moving to new states) on
        // end-of-string.  I haven't completely convinced myself this
        // algorithm is guaranteed to terminate.
        //

        if ( wcCurrent == symEndLine )
        {
            if ( LastState == CurrentState )
                break;
        }
        else
        {
            wcCurrent = *wcs++;

            //
            // After we've exhausted the string, append the special
            // end-of-line character.
            //

            if ( wcCurrent == 0 )
            {
                wcCurrent = symEndLine;
            }
            else
            {
                vqDebugOut(( DEB_REGEX, "\"%c\" --> ", wcCurrent ));

                //
                // Casting is to guarantee this method doesn't modify anything (e.g. read lock ok).
                //

                #if CIDBG == 1
                  wcCurrent = (WCHAR) ((CNFA const *)&_nfa)->Translate().Translate( wcCurrent );
                #else
                  wcCurrent = (WCHAR) _nfa.Translate().Translate( wcCurrent );
                #endif

                vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "%u\n", wcCurrent ));
            }
        }

    }

#   if CIDBG == 1
       ValidateStateTransitions();
#   endif // CIDBG == 1

    return( fFinal );
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::Add, private
//
//  Synopsis:   Adds a new state the the DFA.
//
//  Arguments:  [state]  -- State number
//              [fFinal] -- TRUE if state is a final state.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      All transitions for the new state are initially uncomputed.
//
//--------------------------------------------------------------------------

void CDFA::Add( unsigned state, BOOLEAN fFinal )
{
    if ( state > _cState )
    {
        vqDebugOut(( DEB_ITRACE, "Growing DFA state array.\n" ));

        //
        // Since the number of states required will probably grow at
        // a slow rate, increase the size of the array in a linear
        // fashion.

        unsigned const DeltaState = 10;

        XPtrST<unsigned> xOldStateTrans( _xStateTrans.Acquire() );
        XPtrST<BOOLEAN> xOldStateFinal( _xStateFinal.Acquire() );

        unsigned   oldcState = _cState;
        unsigned   oldcEntries = (_cState + 1) *
            ( _nfa.Translate().NumClasses() + 1 );

        _cState += DeltaState;
        unsigned cEntries = (_cState + 1) * ( _nfa.Translate().NumClasses() + 1 );

        _xStateTrans.Init( cEntries );
        _xStateFinal.Init( _cState + 1 );

        //
        // Initilize new state tables...
        //

        memcpy( _xStateTrans.GetPointer(),
                xOldStateTrans.GetPointer(),
                oldcEntries * sizeof( unsigned ) );
        memcpy( _xStateFinal.GetPointer(),
                xOldStateFinal.GetPointer(),
                oldcState * sizeof( BOOLEAN ) );

        Win4Assert( stateUncomputed == 0xFFFFFFFF );
        memset( _xStateTrans.GetPointer() + oldcEntries, 0xFF, (cEntries - oldcEntries)*sizeof(unsigned ) );
        RtlZeroMemory( _xStateFinal.GetPointer() + oldcState, (_cState + 1 - oldcState)*sizeof(BOOLEAN) );


        for ( unsigned i = _cState - DeltaState + 1; i <= _cState; i++ )
        {
            AddTransition( i, 0, stateUndefined );
        }
    }

    //
    // All states are set to stateUncomputed above, except the 'undefined' flag-state.
    //

#   if CIDBG == 1
        for ( int i = _nfa.Translate().NumClasses(); i > 0; i-- )
            Win4Assert( Move( state, i ) == stateUncomputed );
#   endif

    AddTransition( state, 0, stateUncomputed );
    _xStateFinal[state] = fFinal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegXpr::CRegXpr, public
//
//  Synopsis:   Create an expression used to match <prop> with a regex.
//
//  Arguments:  [prel]      -- Property restriction.
//              [timeLimit] -- Execution time limit
//
//  History:    15-Apr-92   KyleP       Created.
//
//----------------------------------------------------------------------------

CRegXpr::CRegXpr( CInternalPropertyRestriction * prst, CTimeLimit& timeLimit )
        : CXpr( CXpr::NTRegex ),
          _pxpval( prst->Pid() ),
          _xrstContentHelper( prst->AcquireContentHelper() ),
//
//  Feature decision: Make all regular expressions case insensitive.
//
          _dfa( prst->Value(), timeLimit, FALSE ),
          _ulCodePage( LocaleToCodepage( GetSystemDefaultLCID() ))
{

    //
    // Existence of _prstContentHelper implies a fixed starting prefix.
    //

    if ( !_xrstContentHelper.IsNull() )
    {
        //
        // Find fixed prefix, and add it as a view value
        //

        unsigned i = wcscspn( prst->Value().GetLPWSTR(),
                              awcSpecialRegex );

        if ( i > 0 )
        {
            WCHAR wcs[50];

            if ( i > sizeof(wcs)/sizeof(WCHAR) - 2 )
                i = sizeof(wcs)/sizeof(WCHAR) - 2;

            //
            // If "foo" is the prefix, we want all values from "foo" to "fop",
            // but I'm going to be lazy.  If the trailing letter of the prefix is
            // 0xFFFF then I just won't set bounds.
            //

            if ( prst->Value().GetLPWSTR()[i-1] != 0xFFFF )
            {
                memcpy( wcs, prst->Value().GetLPWSTR(), i*sizeof(WCHAR) );
                wcs[i] = 0;

                _varPrefix.SetLPWSTR( wcs );
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegXpr::CRegXpr, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source expression
//
//  History:    13-Jul-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CRegXpr::CRegXpr( CRegXpr const & src )
        : CXpr( CXpr::NTRegex ),
          _pxpval( src._pxpval ),
          _varPrefix( src._varPrefix ),
          _dfa( src._dfa ),
          _ulCodePage( src._ulCodePage )
{
    if ( !src._xrstContentHelper.IsNull() )
        _xrstContentHelper.Set( src._xrstContentHelper->Clone() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegXpr::Clone, public
//
//  Returns:    A copy of this node.
//
//  Derivation: From base class CXpr, Always override in subclasses.
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXpr * CRegXpr::Clone()
{
    return new CRegXpr( *this );
}

void CRegXpr::SelectIndexing( CIndexStrategy & strategy )
{
    if ( _pxpval.Pid() == pidPath ||
         _pxpval.Pid() == pidDirectory ||
         _pxpval.Pid() == pidVirtualPath )
    {
        strategy.SetUnknownBounds( _pxpval.Pid() );
        return;
    }

    if ( _varPrefix.Type() == VT_LPWSTR )
    {
        strategy.SetLowerBound( _pxpval.Pid(), _varPrefix );

        WCHAR * wcs = (WCHAR *)_varPrefix.GetLPWSTR();

        unsigned cc = wcslen( wcs );
        Win4Assert( wcs[cc-1] != 0xFFFF );
        wcs[cc-1] = wcs[cc-1] + 1;

        strategy.SetUpperBound( _pxpval.Pid(), _varPrefix, TRUE );
    }

    if ( !_xrstContentHelper.IsNull() )
    {
        strategy.SetContentHelper( _xrstContentHelper.GetPointer() );
        _xrstContentHelper.Acquire();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegXpr::IsMatch, public
//
//  Arguments:  [obj] -- The objects table.  [obj] is already positioned
//                       to the record to test.
//
//  Returns:    TRUE if the current record satisfies the regex.
//
//  History:    15-Apr-92   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CRegXpr::IsMatch( CRetriever & obj )
{
    // Make this big enough for most paths

    const cbGuess = ( MAX_PATH * sizeof WCHAR ) + sizeof PROPVARIANT;
    XGrowable<BYTE,cbGuess> xBuffer;
    PROPVARIANT * ppv = (PROPVARIANT *) xBuffer.Get();
    ULONG cb = xBuffer.SizeOf();

    GetValueResult rc = _pxpval.GetValue( obj, ppv, &cb );

    //
    // If the object is too big for the stack then allocate heap (sigh).
    //

    if ( rc == GVRNotEnoughSpace )
    {
        xBuffer.SetSize( cb );
        ppv = (PROPVARIANT *) xBuffer.Get();
        rc = _pxpval.GetValue( obj, ppv, &cb );
    }

    if ( rc != GVRSuccess )
        return FALSE;

    // MAX_PATH here is just a heuristic

    XGrowable<WCHAR, MAX_PATH> xConvert;

    //
    // Cast LPSTR to LPWSTR
    //

    if ( ppv->vt == VT_LPSTR )
    {
        cb = strlen( ppv->pszVal );
        ULONG cwcOut = cb + cb / 4 + 1;
        xConvert.SetSize( cwcOut );

        ULONG cwcActual = 0;
        do
        {
            cwcActual = MultiByteToWideChar( _ulCodePage,
                                             0,
                                             ppv->pszVal,
                                             cb + 1,
                                             xConvert.Get(),
                                             cwcOut );
            if ( cwcActual == 0 )
            {
                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    cwcOut *= 2;
                    xConvert.SetSize( cwcOut );
                }
                else
                    THROW( CException() );
            }
        } while ( 0 == cwcActual );

        ppv->vt = VT_LPWSTR;
        ppv->pwszVal = xConvert.Get();
    }
    else if ( ppv->vt == VT_LPWSTR || ppv->vt == VT_BSTR )
    {
        //
        // Normalize to precomposed Unicode
        //
        ULONG cwcIn;
        WCHAR *pwcIn;

        if ( ppv->vt == VT_LPWSTR )
        {
            pwcIn = ppv->pwszVal;
            cwcIn = wcslen(pwcIn) + 1;
        }
        else  // ppv->vt == VT_BSTR
        {
            pwcIn = ppv->bstrVal;
            cwcIn = SysStringLen( pwcIn ) + 1;
        }

        xConvert.SetSize( cwcIn );

        ULONG cwcFolded = FoldStringW( MAP_PRECOMPOSED,
                                       pwcIn,
                                       cwcIn,
                                       xConvert.Get(),
                                       cwcIn );
        if ( cwcFolded == 0 )
        {
            Win4Assert( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
            THROW( CException() );
        }

        ppv->vt = VT_LPWSTR;
        ppv->pwszVal = xConvert.Get();
    }

    //
    // But any other types are illegal
    //

    if ( ppv->vt != VT_LPWSTR )
    {
        vqDebugOut(( DEB_ITRACE,
                     "CRegXpr::IsMatch -- Type mismatch. Got 0x%x\n",
                     ppv->vt ));
        return FALSE;
    }

    return _dfa.Recognize( ppv->pwszVal );
}

#if (CIDBG == 1)

//
// Debug methods
//

void CNFA::Display()
{
    vqDebugOut(( DEB_REGEX, "NFA contains %d states.\n", _iNextState-1 ));

    for ( unsigned i = 1; i < _iNextState; i++ )
    {
        Get(i)->Display();
        vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
    }
}

void CDFA::ValidateStateTransitions()
{
    //
    // Valid states are numbers < _cState, plus a few special states.
    //

    for ( int i = _cState * (_nfa.Translate().NumClasses() + 1);
          i >= 0;
          i-- )
    {
        if ( _xStateTrans[i] > _cState &&
             _xStateTrans[i] != stateUncomputed &&
             _xStateTrans[i] != stateUninitialized &&
             _xStateTrans[i] != stateUndefined )
        {
            vqDebugOut(( DEB_ERROR, "Bogus state 0x%x in DFA. pDFA = 0x%x\n",
                         _xStateTrans[i], this ));
            Win4Assert( !"Bogus state in DFA" );
        }
    }
}

#endif // (CIDBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\parse.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       Parse.cxx
//
//  Contents:   Converts restrictions into expressions
//
//  Functions:  Parse
//
//  History:    15-Oct-91   KyleP    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <parse.hxx>
#include <fa.hxx>

#include "notxpr.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   Parse, public
//
//  Synopsis:   Convert a restriction into an expression
//
//  Arguments:  [prst]      -- Restriction to convert
//              [timeLimit] -- Execution time limit
//
//  Returns:    A pointer to the expression which will resolve [prst]
//
//  History:    15-Oct-91   KyleP       Created.
//              27-Nov-93   KyleP       Added RTNot
//
//----------------------------------------------------------------------------

CXpr * Parse( CRestriction const * prst, CTimeLimit& timeLimit )
{
    XXpr pxp;

    CNodeXpr * pnxpr;
    int cres;

    switch ( prst->Type() )
    {
    case RTNot:
    {
        CNotRestriction * pnRst = (CNotRestriction *)prst;

        XXpr pTemp( Parse( pnRst->GetChild(), timeLimit ) );

        pxp.Set( new CNotXpr( pTemp.Acquire() ) );

        break;
    }

    case RTAnd:
    case RTOr:
    {
        CNodeRestriction * pnRst = prst->CastToNode();
        CXpr::NodeType nt = (prst->Type() == RTAnd) ?
            CXpr::NTAnd : CXpr::NTOr;

        cres = pnRst->Count();
        pnxpr = new CNodeXpr( nt, cres );

        pxp.Set( pnxpr );

        vqDebugOut(( DEB_ITRACE,
                     "Parse: %s node, %d restrictions\n",
                     (prst->Type() == RTAnd) ? "AND" : "OR", cres ));

        for ( cres--; cres >= 0; cres-- )
        {
            pnxpr->AddChild( Parse( pnRst->GetChild(cres), timeLimit ) );
        }
        break;
    }

    case RTInternalProp:
    {
        CInternalPropertyRestriction * pRst =
            (CInternalPropertyRestriction *)prst;

#if CIDBG == 1
        vqDebugOut(( DEB_ITRACE, "Parse: PROPERTY, prop = %d, op = %ld, value = ",
                     pRst->Pid(),
                     pRst->Relation() ));

        pRst->Value().DisplayVariant(DEB_ITRACE | DEB_NOCOMPNAME, 0);
        vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "\n" ));
#endif // DBG == 1

        if ( pRst->Relation() == PRRE )
            pxp.Set( new CRegXpr( pRst, timeLimit ) );
        else
        {
            pxp.Set( new CXprPropertyRelation( pRst->Pid(),
                                                pRst->Relation(),
                                                pRst->Value(),
                                                pRst->AcquireContentHelper() ) );
        }
        break;
    }

    default:
        vqDebugOut(( DEB_ERROR, "Unhandled expression type %d\n", prst->Type() ));
        //Win4Assert( !"Unhandled expression type" );
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        break;
    }


    return( pxp.Acquire() );
}

//+-------------------------------------------------------------------------
//
//  Function:   MoveFullyIndexableNode, public
//
//  Effects:    Splits out any components of [pnrSource] which are
//              *completely* resolved by content index.  In practice,
//              this is boolean trees of CONTENT nodes.
//
//  Arguments:  [pnrSource]          -- Original restriction
//              [pnrFullyResolvable] -- Fully resolvable portions of
//                                      [pnrSource]
//
//  Modifies:   Nodes may be removed from [pnrSource]
//
//  History:    10-Feb-92 KyleP     Created
//
//--------------------------------------------------------------------------

void MoveFullyIndexable( CNodeRestriction & pnrSource,
                           CNodeRestriction & pnrFullyResolvable )
{
    for ( int i = pnrSource.Count()-1; i >= 0; i-- )
    {
        if ( IsFullyIndexable( pnrSource.GetChild(i) ) )
        {
            unsigned pos;

            pnrFullyResolvable.AddChild( pnrSource.RemoveChild(i), pos );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IsFullyIndexable, public
//
//  Synopsis:   Determines of node (or tree) is fully resolved by content
//              index.
//
//  Arguments:  [pRst] -- Restriction to test
//
//  Returns:    TRUE if node is fully indexable
//
//  History:    10-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL IsFullyIndexable( CRestriction * pRst )
{
    switch ( pRst->Type() )
    {
    case RTContent:
    case RTWord:
    case RTSynonym:
    case RTPhrase:
    case RTRange:
    case RTProperty:
    case RTNone:         // null-node from noise word in vector query
        return( TRUE );

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    {
        CNodeRestriction * pnRst = pRst->CastToNode();

        for( int i = pnRst->Count()-1; i >= 0; i-- )
        {
            if ( !IsFullyIndexable( pnRst->GetChild(i) ) )
                return FALSE;
        }

        return( TRUE );
    }

    case RTNot:
    {
        CNotRestriction * pnRst = (CNotRestriction *)pRst;

        return( IsFullyIndexable( pnRst->GetChild() ) );
        break;
    }

    default:
        vqDebugOut(( DEB_ITRACE,
                     "Restriction type %d is not fully indexable\n",
                     pRst->Type() ));

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\notxpr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       NotXpr.cxx
//
//  Contents:   Negation expression
//
//  Classes:    CNotXpr
//
//  History:    27-Nov-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "notxpr.hxx"

CNotXpr::~CNotXpr()
{
    delete _pxpr;
}

CXpr * CNotXpr::Clone()
{
    return( new CNotXpr( _pxpr->Clone() ) );
}

BOOL CNotXpr::IsMatch( CRetriever & obj )
{
    return( !_pxpr->IsMatch( obj ) );
}

BOOL CNotXpr::IsLeaf() const
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\compare.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       Compare.cxx
//
//  Contents:   Comparator class for property sets.
//
//  Classes:    CComparePropSets
//
//  History:    07-Jun-92 KyleP     Created
//              07-Apr-93 KyleP     Convert to CairOle
//              02-Nov-93 KyleP     Added allmost all VT_ types
//
//  Notes:      The following comparisons are suppored
//
//              Variant     Equality    Relational  Bitwise
//              ----------- ----------- ----------  -------
//
//              VT_EMPTY        X
//              VT_NULL         X
//              VT_I2           X           X           X
//              VT_I4           X           X           X
//              VT_R4           X           X
//              VT_R8           X           X
//              VT_CY           X           X
//              VT_DATE         X           X
//              VT_BSTR         X           X
//              VT_DISPATCH     -
//              VT_ERROR        X           X           X
//              VT_BOOL         X
//              VT_VARIANT      X           X
//              VT_UNKNOWN      -
//              VT_DECIMAL      X           X
//              VT_I1           X           X           X
//              VT_UI1          X           X           X
//              VT_UI2          X           X           X
//              VT_UI4          X           X           X
//              VT_I8           X           X           X
//              VT_UI8          X           X           X
//              VT_INT          X           X           X
//              VT_UINT         X           X           X
//              VT_VOID         -
//              VT_HRESULT      X           X           X
//              VT_PTR          -
//              VT_SAFEARRAY    -
//              VT_CARRAY       -
//              VT_USERDEFINED  -
//              VT_LPSTR        X           X
//              VT_LPWSTR       X           X
//              VT_FILETIME     X           X
//              VT_BLOB         X           X
//              VT_STREAM
//              VT_STORAGE
//              VT_STREAMED_OBJECT
//              VT_STORED_OBJECT
//              VT_BLOB_OBJECT  X           X
//              VT_CF           X           X
//              VT_CLSID        X
//
//
//              The following are OLE-DB datatypes.
//
//              Variant     Equality    Vector
//              ----------- ----------- ------
//
//              DBTYPE_EMPTY    X
//              DBTYPE_NULL     X
//              DBTYPE_I1       X           X
//              DBTYPE_UI1      X           X
//              DBTYPE_I2       X           X
//              DBTYPE_UI2      X           X
//              DBTYPE_I4       X           X
//              DBTYPE_UI4      X           X
//              DBTYPE_R4       X           X
//              DBTYPE_R8       X           X
//              DBTYPE_CY       X           X
//              DBTYPE_DATE     X           X
//              DBTYPE_BSTR     X
//              DBTYPE_DISPATCH
//              DBTYPE_ERROR    X
//              DBTYPE_BOOL     X
//              DBTYPE_VARIANT  X           X
//              DBTYPE_UNKNOWN  X
//              DBTYPE_I8       X           X
//              DBTYPE_GUID     X
//              DBTYPE_BYTES    X           X
//              DBTYPE_STR      X           X
//              DBTYPE_WSTR     X           X
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <compare.hxx>
#include <coldesc.hxx>
#include <propvar.h>

CComparators VariantCompare;

DBTYPEENUM dbVector(DBTYPEENUM vt)
{
    return (DBTYPEENUM) (DBTYPE_VECTOR | vt);
}

//
// DEFAULT.  Used for optimization in looped comparisons.  If we can't
//           determine the way to compare, then use this default.
//

int VT_DEFAULT_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

//
// VT_EMPTY
//

int VT_EMPTY_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

BOOL VT_EMPTY_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( TRUE );
}

BOOL VT_EMPTY_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( FALSE );
}

//
// VT_NULL
//

int VT_NULL_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

BOOL VT_NULL_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( TRUE );
}

BOOL VT_NULL_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( FALSE );
}

//
// VT_I2
//

int VT_I2_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal - v2.iVal );
}

BOOL VT_I2_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal < v2.iVal );
}

BOOL VT_I2_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal <= v2.iVal );
}

BOOL VT_I2_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal >= v2.iVal );
}

BOOL VT_I2_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal > v2.iVal );
}

BOOL VT_I2_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal == v2.iVal );
}

BOOL VT_I2_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal != v2.iVal );
}

BOOL VT_I2_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.iVal & v2.iVal) == v2.iVal );
}

BOOL VT_I2_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.iVal & v2.iVal) != 0 );
}

//
// VT_I4
//

int VT_I4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( v1.lVal > v2.lVal ) ? 1 : ( v1.lVal < v2.lVal ) ? -1 : 0;
}

BOOL VT_I4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal < v2.lVal );
}

BOOL VT_I4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal <= v2.lVal );
}

BOOL VT_I4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal >= v2.lVal );
}

BOOL VT_I4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal > v2.lVal );
}

BOOL VT_I4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal == v2.lVal );
}

BOOL VT_I4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal != v2.lVal );
}

BOOL VT_I4_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.lVal & v2.lVal) == v2.lVal );
}

BOOL VT_I4_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.lVal & v2.lVal) != 0 );
}

//
// VT_R4
//

//
// We can't use floating point in the kernel.  Luckily, it's easy to
// fake comparisons on floating point.  The format of an IEEE floating
// point number is:
//
//     <sign bit> <biased exponent> <normalized mantissa>
//
// Because the exponent is biased, after flipping the sign bit we can
// make all comparisons as if the numbers were unsigned long.
//

ULONG const R4_SignBit = 0x80000000;

int VT_R4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    // axp (not x86) generates exceptions when floating point numbers
    // don't look like ieee floating point numbers.  This can happen
    // with bogus queries or bogus values stored in properties or the
    // property store.

    #if (_X86_ == 1)
        return ( v1.fltVal > v2.fltVal ) ? 1 :
               ( v1.fltVal < v2.fltVal ) ? -1 : 0;
    #else
        ULONG u1 = v1.ulVal ^ R4_SignBit;
        ULONG u2 = v2.ulVal ^ R4_SignBit;

        if ( (v1.ulVal & v2.ulVal & R4_SignBit) != 0 )
            return ( ( u1 > u2 ) ? -1 : ( u1 < u2 ) ?  1 : 0 );
        else
            return ( ( u1 > u2 ) ?  1 : ( u1 < u2 ) ? -1 : 0 );
    #endif
}

BOOL VT_R4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) < 0;
}

BOOL VT_R4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) <= 0;
}

BOOL VT_R4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) >= 0;
}

BOOL VT_R4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) > 0;
}

BOOL VT_R4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal == v2.ulVal );
}

BOOL VT_R4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal != v2.ulVal );
}

//
// VT_R8
//

LONGLONG const R8_SignBit = 0x8000000000000000;

int VT_R8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    // axp (not x86) generates exceptions when floating point numbers
    // don't look like ieee floating point numbers.  This can happen
    // with bogus queries or bogus values stored in properties or the
    // property store.

    #if (_X86_ == 1)
        return ( v1.dblVal > v2.dblVal ) ? 1 :
               ( v1.dblVal < v2.dblVal ) ? -1 : 0;

    #else
        if ( (v1.uhVal.QuadPart & v2.uhVal.QuadPart & R8_SignBit) != 0 )
            return( (v1.uhVal.QuadPart ^ R8_SignBit) < (v2.uhVal.QuadPart ^ R8_SignBit) ? 1 :
                    (v1.uhVal.QuadPart ^ R8_SignBit) == (v2.uhVal.QuadPart ^ R8_SignBit) ? 0 :
                    -1 );
        else
            return( (v1.uhVal.QuadPart ^ R8_SignBit) > (v2.uhVal.QuadPart ^ R8_SignBit) ? 1 :
                    (v1.uhVal.QuadPart ^ R8_SignBit) == (v2.uhVal.QuadPart ^ R8_SignBit) ? 0 :
                    -1 );
    #endif // 0
}

BOOL VT_R8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) < 0;
}

BOOL VT_R8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) <= 0;
}

BOOL VT_R8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) >= 0;
}

BOOL VT_R8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) > 0;
}

BOOL VT_R8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart == v2.uhVal.QuadPart );
}

BOOL VT_R8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart != v2.uhVal.QuadPart );
}

//
// VT_BSTR
//

int VT_BSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    ULONG len = BSTRLEN(pxv1);
    if ( BSTRLEN(pxv2) < len )
        len = BSTRLEN(pxv2);

    int iCmp = _wcsnicmp( pxv1, pxv2, len / sizeof (OLECHAR) );

    if ( iCmp != 0 || BSTRLEN(pxv1) == BSTRLEN(pxv2) )
        return( iCmp );

    if ( BSTRLEN(pxv1) > BSTRLEN(pxv2) )
        return( 1 );
    else
        return( -1 );
}

BOOL VT_BSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) < 0 );
}

BOOL VT_BSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) <= 0 );
}

BOOL VT_BSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) >= 0 );
}

BOOL VT_BSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) > 0 );
}

BOOL VT_BSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    return( BSTRLEN(pxv1) == BSTRLEN(pxv2) &&
            _wcsnicmp( pxv1, pxv2, BSTRLEN(pxv1) / sizeof (OLECHAR) ) == 0 );
}

BOOL VT_BSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    return( BSTRLEN(pxv1) != BSTRLEN(pxv2) ||
            _wcsnicmp( pxv1, pxv2, BSTRLEN(pxv1) / sizeof (OLECHAR) ) != 0 );
}

//
// VT_BOOL
//

int VT_BOOL_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if (v1.boolVal == 0)
        if (v2.boolVal == 0)
            return( 0 );
        else
            return( -1 );
    else
        if (v2.boolVal == 0)
            return( 1 );
        else
            return( 0 );
}

BOOL VT_BOOL_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( ((v1.boolVal==0) && (v2.boolVal==0))  ||
            ((v1.boolVal!=0) && (v2.boolVal!=0)) );
}

BOOL VT_BOOL_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( !VT_BOOL_EQ( v1, v2 ) );
}

//
// VT_VARIANT
//

int VT_VARIANT_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.vt != v2.vt )
        return v1.vt - v2.vt;

    FCmp comp = VariantCompare.GetComparator( (VARENUM) v1.vt );

    if (0 == comp)
        return 0;
    else
        return comp( v1, v2 );
}

BOOL VT_VARIANT_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) < 0;
}

BOOL VT_VARIANT_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) <= 0;
}

BOOL VT_VARIANT_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) >= 0;
}

BOOL VT_VARIANT_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) > 0;
}

BOOL VT_VARIANT_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) == 0;
}

BOOL VT_VARIANT_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) != 0;
}

//
// VT_DECIMAL
//

int VT_DEC_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.decVal.sign  == v2.decVal.sign  &&
         v1.decVal.scale == v2.decVal.scale &&
         v1.decVal.Hi32  == v2.decVal.Hi32  &&
         v1.decVal.Lo64  == v2.decVal.Lo64)
        return 0;

    int iSign = v1.decVal.sign == DECIMAL_NEG ? -1 : 1;

    if ( v1.decVal.sign != v2.decVal.sign )
        return iSign;

    if ( v1.decVal.scale == v2.decVal.scale )
    {
        int iRet = 0;
        if (v1.decVal.Hi32 != v2.decVal.Hi32)
            iRet = (v1.decVal.Hi32 < v2.decVal.Hi32) ? -1 : 1;
        else if (v1.decVal.Lo64 != v2.decVal.Lo64)
            iRet = (v1.decVal.Lo64 < v2.decVal.Lo64) ? -1 : 1;
        return iRet * iSign;
    }

    double d1;
    VarR8FromDec( (DECIMAL*)&v1.decVal, &d1 );
    double d2;
    VarR8FromDec( (DECIMAL*)&v2.decVal, &d2 );

    return (( d1 > d2 ) ? 1 : ( d1 < d2 ) ? -1 : 0);
}

BOOL VT_DEC_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) < 0;
}

BOOL VT_DEC_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) <= 0;
}

BOOL VT_DEC_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) >= 0;
}

BOOL VT_DEC_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) > 0;
}

BOOL VT_DEC_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) == 0;
}

BOOL VT_DEC_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) != 0;
}

//
// VT_I1
//

int VT_I1_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal - v2.cVal );
}

BOOL VT_I1_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal < v2.cVal );
}

BOOL VT_I1_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal <= v2.cVal );
}

BOOL VT_I1_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal >= v2.cVal );
}

BOOL VT_I1_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal > v2.cVal );
}

BOOL VT_I1_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal == v2.cVal );
}

BOOL VT_I1_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal != v2.cVal );
}

BOOL VT_I1_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.cVal & v2.cVal) == v2.cVal );
}

BOOL VT_I1_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.cVal & v2.cVal) != 0 );
}


//
// VT_UI1
//

int VT_UI1_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal - v2.bVal );
}

BOOL VT_UI1_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal < v2.bVal );
}

BOOL VT_UI1_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal <= v2.bVal );
}

BOOL VT_UI1_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal >= v2.bVal );
}

BOOL VT_UI1_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal > v2.bVal );
}

BOOL VT_UI1_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal == v2.bVal );
}

BOOL VT_UI1_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal != v2.bVal );
}

BOOL VT_UI1_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.bVal & v2.bVal) == v2.bVal );
}

BOOL VT_UI1_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.bVal & v2.bVal) != 0 );
}

//
// VT_UI2
//

int VT_UI2_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal - v2.uiVal );
}

BOOL VT_UI2_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal < v2.uiVal );
}

BOOL VT_UI2_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal <= v2.uiVal );
}

BOOL VT_UI2_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal >= v2.uiVal );
}

BOOL VT_UI2_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal > v2.uiVal );
}

BOOL VT_UI2_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal == v2.uiVal );
}

BOOL VT_UI2_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal != v2.uiVal );
}

BOOL VT_UI2_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uiVal & v2.uiVal) == v2.uiVal );
}

BOOL VT_UI2_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uiVal & v2.uiVal) != 0 );
}
//
// VT_UI4
//

int VT_UI4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( v1.ulVal > v2.ulVal ) ? 1 : ( v1.ulVal < v2.ulVal ) ? -1 : 0;
}

BOOL VT_UI4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal < v2.ulVal );
}

BOOL VT_UI4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal <= v2.ulVal );
}

BOOL VT_UI4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal >= v2.ulVal );
}

BOOL VT_UI4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal > v2.ulVal );
}

BOOL VT_UI4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal == v2.ulVal );
}

BOOL VT_UI4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal != v2.ulVal );
}

BOOL VT_UI4_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.ulVal & v2.ulVal) == v2.ulVal );
}

BOOL VT_UI4_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.ulVal & v2.ulVal) != 0 );
}

//
// VT_I8
//

int VT_I8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart >  v2.hVal.QuadPart ? 1 :
            v1.hVal.QuadPart == v2.hVal.QuadPart ? 0 :
            -1 );
}

BOOL VT_I8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart < v2.hVal.QuadPart );
}

BOOL VT_I8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart <= v2.hVal.QuadPart );

}

BOOL VT_I8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart >= v2.hVal.QuadPart );
}

BOOL VT_I8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart > v2.hVal.QuadPart );
}

BOOL VT_I8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart == v2.hVal.QuadPart );
}

BOOL VT_I8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart != v2.hVal.QuadPart );
}

BOOL VT_I8_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.hVal.QuadPart & v2.hVal.QuadPart) == v2.hVal.QuadPart );
}

BOOL VT_I8_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.hVal.QuadPart & v2.hVal.QuadPart) != 0 );
}

//
// VT_UI8
//

int VT_UI8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart >  v2.uhVal.QuadPart ? 1 :
            v1.uhVal.QuadPart == v2.uhVal.QuadPart ? 0 :
            -1 );
}

BOOL VT_UI8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart < v2.uhVal.QuadPart );
}

BOOL VT_UI8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart <= v2.uhVal.QuadPart );

}

BOOL VT_UI8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart >= v2.uhVal.QuadPart );
}

BOOL VT_UI8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart > v2.uhVal.QuadPart );
}

BOOL VT_UI8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart == v2.uhVal.QuadPart );
}

BOOL VT_UI8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart != v2.uhVal.QuadPart );
}

BOOL VT_UI8_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uhVal.QuadPart & v2.uhVal.QuadPart) == v2.uhVal.QuadPart );
}

BOOL VT_UI8_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uhVal.QuadPart & v2.uhVal.QuadPart) != 0 );
}

//
// VT_LPSTR
//

int VT_LPSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( _stricmp( v1.pszVal, v2.pszVal ) );
}

BOOL VT_LPSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = _stricmp( v1.pszVal, v2.pszVal );

    return( rc < 0 );
}

BOOL VT_LPSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = _stricmp( v1.pszVal, v2.pszVal );

    return( rc <= 0 );
}

BOOL VT_LPSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = _stricmp( v1.pszVal, v2.pszVal );

    return( rc >= 0 );
}

BOOL VT_LPSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = _stricmp( v1.pszVal, v2.pszVal );

    return( rc > 0 );
}

BOOL VT_LPSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( _stricmp( v1.pszVal, v2.pszVal ) == 0 );
}

BOOL VT_LPSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( _stricmp( v1.pszVal, v2.pszVal ) != 0 );
}


//
// VT_LPWSTR
//

int VT_LPWSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             v1.pwszVal,
                             -1,
                             v2.pwszVal,
                             -1 );
    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

BOOL VT_LPWSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) < 0 );
}

BOOL VT_LPWSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) <= 0 );
}

BOOL VT_LPWSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) >= 0 );
}

BOOL VT_LPWSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) > 0 );
}

BOOL VT_LPWSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) == 0 );
}

BOOL VT_LPWSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) != 0 );
}

//
// VT_BLOB
//

int VT_BLOB_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    ULONG len = v1.blob.cbSize;
    if ( v2.blob.cbSize < len )
        len = v2.blob.cbSize;

    int iCmp = memcmp( v1.blob.pBlobData,
                       v2.blob.pBlobData,
                       len );

    if ( iCmp != 0 || v1.blob.cbSize == v2.blob.cbSize )
        return( iCmp );

    if ( v1.blob.cbSize > v2.blob.cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VT_BLOB_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) < 0 );
}

BOOL VT_BLOB_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) <= 0 );
}

BOOL VT_BLOB_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) >= 0 );
}

BOOL VT_BLOB_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) > 0 );
}

BOOL VT_BLOB_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.blob.cbSize == v2.blob.cbSize &&
            memcmp( v1.blob.pBlobData,
                    v2.blob.pBlobData,
                    v1.blob.cbSize ) == 0 );
}

BOOL VT_BLOB_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.blob.cbSize != v2.blob.cbSize ||
            memcmp( v1.blob.pBlobData,
                      v2.blob.pBlobData,
                      v1.blob.cbSize ) != 0 );
}

//
// VT_CF
//

int VT_CF_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.pclipdata->ulClipFmt != v2.pclipdata->ulClipFmt )
    {
        return( v1.pclipdata->ulClipFmt - v2.pclipdata->ulClipFmt );
    }

    ULONG len = CBPCLIPDATA(*v1.pclipdata);

    if ( CBPCLIPDATA(*v2.pclipdata) < len )
        len = CBPCLIPDATA(*v2.pclipdata);

    int iCmp = memcmp( v1.pclipdata->pClipData,
                       v2.pclipdata->pClipData,
                       len );

    if ( iCmp != 0 || v1.pclipdata->cbSize == v2.pclipdata->cbSize )
        return( iCmp );

    if ( v1.pclipdata->cbSize > v2.pclipdata->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VT_CF_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) < 0 );
}

BOOL VT_CF_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) <= 0 );
}

BOOL VT_CF_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) >= 0 );
}

BOOL VT_CF_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) > 0 );
}

BOOL VT_CF_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.pclipdata->ulClipFmt == v2.pclipdata->ulClipFmt &&
            v1.pclipdata->cbSize == v2.pclipdata->cbSize &&
            memcmp( v1.pclipdata->pClipData,
                    v2.pclipdata->pClipData,
                    CBPCLIPDATA(*v1.pclipdata) ) == 0 );
}

BOOL VT_CF_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.pclipdata->ulClipFmt != v2.pclipdata->ulClipFmt ||
            v1.pclipdata->cbSize != v2.pclipdata->cbSize ||
            memcmp( v1.pclipdata->pClipData,
                    v2.pclipdata->pClipData,
                    CBPCLIPDATA(*v1.pclipdata) ) != 0 );
}

//
// VT_CLSID
//

int VT_CLSID_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) );
}

BOOL VT_CLSID_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) == 0 );
}

BOOL VT_CLSID_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) != 0 );
}

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

//
// VTP_EMPTY
//

int VTP_EMPTY_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_EMPTY_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_EMPTY_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( FALSE );
}

//
// VTP_NULL
//

int VTP_NULL_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_NULL_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_NULL_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( FALSE );
}

//
// VTP_I2
//

int VTP_I2_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) - (* (short *) pv2) );
}

BOOL VTP_I2_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) < (* (short *) pv2) );
}

BOOL VTP_I2_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) <= (* (short *) pv2) );
}

BOOL VTP_I2_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) >= (* (short *) pv2) );
}

BOOL VTP_I2_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) > (* (short *) pv2) );
}

BOOL VTP_I2_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) == (* (short *) pv2) );
}

BOOL VTP_I2_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) != (* (short *) pv2) );
}

BOOL VTP_I2_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (short *) pv1) & (* (short *) pv2)) == (* (short *) pv2) );
}

BOOL VTP_I2_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (short *) pv1) & (* (short *) pv2)) != 0 );
}

//
// VTP_I4
//

int VTP_I4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    long l1 = * (long *) pv1;
    long l2 = * (long *) pv2;

    return ( l1 > l2 ) ? 1 : ( l1 < l2 ) ? -1 : 0;
}

BOOL VTP_I4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) < (* (long *) pv2) );
}

BOOL VTP_I4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) <= (* (long *) pv2) );
}

BOOL VTP_I4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) >= (* (long *) pv2) );
}

BOOL VTP_I4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) > (* (long *) pv2) );
}

BOOL VTP_I4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) == (* (long *) pv2) );
}

BOOL VTP_I4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) != (* (long *) pv2) );
}

BOOL VTP_I4_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (long *) pv1) & (* (long *) pv2)) == (* (long *) pv2) );
}

BOOL VTP_I4_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (long *) pv1) & (* (long *) pv2)) != 0 );
}

//
// VTP_R4
//

//
// We can't use floating point in the kernel.  Luckily, it's easy to
// fake comparisons on floating point.  The format of an IEEE floating
// point number is:
//
//     <sign bit> <biased exponent> <normalized mantissa>
//
// Because the exponent is biased, after flipping the sign bit we can
// make all comparisons as if the numbers were unsigned long.
//

int VTP_R4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
#if 0
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;
    ULONG u1 = ul1 ^ R4_SignBit;
    ULONG u2 = ul2 ^ R4_SignBit;

    if ( (ul1 & ul2 & R4_SignBit) != 0 )
        return ( ( u1 > u2 ) ? -1 : ( u1 < u2 ) ?  1 : 0 );
    else
        return ( ( u1 > u2 ) ?  1 : ( u1 < u2 ) ? -1 : 0 );
#else // 0
    float f1 = * (float *) pv1;
    float f2 = * (float *) pv2;
    return ( f1 > f2 ) ? 1 : ( f1 < f2 ) ? -1 : 0;
#endif // 0
}

BOOL VTP_R4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) < 0;
}

BOOL VTP_R4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) <= 0;
}

BOOL VTP_R4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) >= 0;
}

BOOL VTP_R4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) > 0;
}

BOOL VTP_R4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) == 0;
}

BOOL VTP_R4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) != 0;
}

//
// VTP_R8
//

int VTP_R8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
#if 0
    ULONGLONG uh1 = * (ULONGLONG *) pv1;
    ULONGLONG uh2 = * (ULONGLONG *) pv2;

    if ( (uh1 & uh2 & R8_SignBit) != 0 )
        return( (uh1 ^ R8_SignBit) < (uh2 ^ R8_SignBit) ? 1 :
                (uh1 ^ R8_SignBit) == (uh2 ^ R8_SignBit) ? 0 :
                -1 );
    else
        return( (uh1 ^ R8_SignBit) > (uh2 ^ R8_SignBit) ? 1 :
                (uh1 ^ R8_SignBit) == (uh2 ^ R8_SignBit) ? 0 :
                -1 );
#else // 0
    double d1 = * (double *) pv1;
    double d2 = * (double *) pv2;
    return ( d1 > d2 ) ? 1 : ( d1 < d2 ) ? -1 : 0;
#endif // 0
}

BOOL VTP_R8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) < 0;
}

BOOL VTP_R8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) <= 0;
}

BOOL VTP_R8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) >= 0;
}

BOOL VTP_R8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) > 0;
}

BOOL VTP_R8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) == 0;
}

BOOL VTP_R8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) != 0;
}

//
// VTP_BSTR
//

int VTP_BSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    ULONG len = BSTRLEN(pxv1);
    if ( BSTRLEN(pxv2) < len )
        len = BSTRLEN(pxv2);

    int iCmp = _wcsnicmp( pxv1, pxv2, len / sizeof (OLECHAR) );

    if ( iCmp != 0 || BSTRLEN(pxv1) == BSTRLEN(pxv2) )
        return( iCmp );

    if ( BSTRLEN(pxv1) > BSTRLEN(pxv2) )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_BSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_BSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_BSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_BSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_BSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    return( BSTRLEN(pxv1) == BSTRLEN(pxv2) &&
            _wcsnicmp( pxv1, pxv2, BSTRLEN(pxv1) / sizeof (OLECHAR) ) == 0 );
}

BOOL VTP_BSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    return( BSTRLEN(pxv1) != BSTRLEN(pxv2) ||
            _wcsnicmp( pxv1, pxv2, BSTRLEN(pxv1) / sizeof (OLECHAR) ) != 0 );
}

//
// VTP_BOOL
//

int VTP_BOOL_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    if ((*(VARIANT_BOOL *) pv1) == 0)
        if ((*(VARIANT_BOOL *) pv2) == 0)
            return( 0 );
        else
            return( -1 );
    else
        if ((*(VARIANT_BOOL *) pv2) == 0)
            return( 1 );
        else
            return( 0 );
}

BOOL VTP_BOOL_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( ( ((*(VARIANT_BOOL *) pv1)==0) && ((*(VARIANT_BOOL *) pv2)==0) ) ||
            ( ((*(VARIANT_BOOL *) pv1)!=0) && ((*(VARIANT_BOOL *) pv2)!=0) ) );

}

BOOL VTP_BOOL_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( !VTP_BOOL_EQ( pv1, pv2 ) );
}

//
// VTP_VARIANT
//

int VTP_VARIANT_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_Compare( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_LT( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_LE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_GE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_GT( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_EQ( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_NE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

//
// VTP_DECIMAL
//

int VTP_DEC_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    PROPVARIANT v1;
    RtlCopyMemory( &v1, pv1, sizeof DECIMAL );
    v1.vt = VT_DECIMAL;

    PROPVARIANT v2;
    RtlCopyMemory( &v2, pv2, sizeof DECIMAL );
    v2.vt = VT_DECIMAL;

    return VT_DEC_Compare( v1, v2 );
}

BOOL VTP_DEC_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_DEC_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_DEC_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_DEC_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_DEC_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) == 0 );
}

BOOL VTP_DEC_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) != 0 );
}

//
// VTP_I1
//

int VTP_I1_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) - (*(signed char *) pv2) );
}

BOOL VTP_I1_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) < (*(signed char *) pv2) );
}

BOOL VTP_I1_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) <= (*(signed char *) pv2) );
}

BOOL VTP_I1_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) >= (*(signed char *) pv2) );
}

BOOL VTP_I1_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) > (*(signed char *) pv2) );
}

BOOL VTP_I1_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) == (*(signed char *) pv2) );
}

BOOL VTP_I1_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) != (*(signed char *) pv2) );
}

BOOL VTP_I1_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(signed char *) pv1) & (*(signed char *) pv2)) == (*(signed char *) pv2) );
}

BOOL VTP_I1_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(signed char *) pv1) & (*(signed char *) pv2)) != 0 );
}

//
// VTP_UI1
//

int VTP_UI1_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) - (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) < (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) <= (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) >= (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) > (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) == (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) != (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(unsigned char *) pv1) & (*(unsigned char *) pv2)) == (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(unsigned char *) pv1) & (*(unsigned char *) pv2)) != 0 );
}

//
// VTP_UI2
//

int VTP_UI2_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) - (*(USHORT *) pv2) );
}

BOOL VTP_UI2_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) < (*(USHORT *) pv2) );
}

BOOL VTP_UI2_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) <= (*(USHORT *) pv2) );
}

BOOL VTP_UI2_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) >= (*(USHORT *) pv2) );
}

BOOL VTP_UI2_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) > (*(USHORT *) pv2) );
}

BOOL VTP_UI2_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) == (*(USHORT *) pv2) );
}

BOOL VTP_UI2_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) != (*(USHORT *) pv2) );
}

BOOL VTP_UI2_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(USHORT *) pv1) & (*(USHORT *) pv2)) == (*(USHORT *) pv2) );
}

BOOL VTP_UI2_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(USHORT *) pv1) & (*(USHORT *) pv2)) != 0 );
}

//
// VTP_UI4
//

int VTP_UI4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;

    return ( ul1 > ul2 ) ? 1 : ( ul1 < ul2 ) ? -1 : 0;
}

BOOL VTP_UI4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) < (*(ULONG *) pv2) );
}

BOOL VTP_UI4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) <= (*(ULONG *) pv2) );
}

BOOL VTP_UI4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) >= (*(ULONG *) pv2) );
}

BOOL VTP_UI4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) > (*(ULONG *) pv2) );
}

BOOL VTP_UI4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) == (*(ULONG *) pv2) );
}

BOOL VTP_UI4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) != (*(ULONG *) pv2) );
}

BOOL VTP_UI4_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONG *) pv1) & (*(ULONG *) pv2)) == (*(ULONG *) pv2) );
}

BOOL VTP_UI4_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONG *) pv1) & (*(ULONG *) pv2)) != 0 );
}

//
// VTP_I8
//

int VTP_I8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) >  (*(LONGLONG *) pv2) ? 1 :
            (*(LONGLONG *) pv1) == (*(LONGLONG *) pv2) ? 0 :
            -1 );
}

BOOL VTP_I8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) < (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) <= (*(LONGLONG *) pv2) );

}

BOOL VTP_I8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) >= (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) > (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) == (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) != (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(LONGLONG *) pv1) & (*(LONGLONG *) pv2)) == (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(LONGLONG *) pv1) & (*(LONGLONG *) pv2)) != 0 );
}

//
// VTP_UI8
//

int VTP_UI8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) >  (*(ULONGLONG *) pv2) ? 1 :
            (*(ULONGLONG *) pv1) == (*(ULONGLONG *) pv2) ? 0 :
            -1 );
}

BOOL VTP_UI8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) < (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) <= (*(ULONGLONG *) pv2) );

}

BOOL VTP_UI8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) >= (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) > (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) == (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) != (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONGLONG *) pv1) & (*(ULONGLONG *) pv2)) == (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONGLONG *) pv1) & (*(ULONGLONG *) pv2)) != 0 );
}

//
// VTP_LPSTR
//

int VTP_LPSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return ( _stricmp( (*(char **) pv1), (*(char **) pv2) ) );
}

BOOL VTP_LPSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = _stricmp( (*(char **) pv1), (*(char **) pv2) );

    return( rc < 0 );
}

BOOL VTP_LPSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = _stricmp( (*(char **) pv1), (*(char **) pv2) );

    return( rc <= 0 );
}

BOOL VTP_LPSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = _stricmp( (*(char **) pv1), (*(char **) pv2) );

    return( rc >= 0 );
}

BOOL VTP_LPSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = _stricmp( (*(char **) pv1), (*(char **) pv2) );

    return( rc > 0 );
}

BOOL VTP_LPSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( _stricmp( (*(char **) pv1), (*(char **) pv2) ) == 0 );
}

BOOL VTP_LPSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( _stricmp( (*(char **) pv1), (*(char **) pv2) ) != 0 );
}


//
// VTP_LPWSTR
//

int VTP_LPWSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             (*(WCHAR **) pv1),
                             -1,
                             (*(WCHAR **) pv2),
                             -1 );

    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

BOOL VTP_LPWSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_LPWSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_LPWSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_LPWSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_LPWSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) == 0 );
}

BOOL VTP_LPWSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) != 0 );
}

//
// VTP_BLOB
//

int VTP_BLOB_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    ULONG len = (*(BLOB **) pv1)->cbSize;
    if ( (*(BLOB **) pv2)->cbSize < len )
        len = (*(BLOB **) pv2)->cbSize;

    int iCmp = memcmp( (*(BLOB **) pv1)->pBlobData,
                       (*(BLOB **) pv2)->pBlobData,
                       len );

    if ( iCmp != 0 || (*(BLOB **) pv1)->cbSize == (*(BLOB **) pv2)->cbSize )
        return( iCmp );

    if ( (*(BLOB **) pv1)->cbSize > (*(BLOB **) pv2)->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_BLOB_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_BLOB_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_BLOB_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_BLOB_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_BLOB_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(BLOB **) pv1)->cbSize == (*(BLOB **) pv2)->cbSize &&
            memcmp( (*(BLOB **) pv1)->pBlobData,
                    (*(BLOB **) pv2)->pBlobData,
                    (*(BLOB **) pv1)->cbSize ) == 0 );
}

BOOL VTP_BLOB_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(BLOB **) pv1)->cbSize != (*(BLOB **) pv2)->cbSize ||
            memcmp( (*(BLOB **) pv1)->pBlobData,
                      (*(BLOB **) pv2)->pBlobData,
                      (*(BLOB **) pv1)->cbSize ) != 0 );
}

//
// VTP_CF
//

int VTP_CF_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    if ( (* (CLIPDATA **) pv1)->ulClipFmt != (* (CLIPDATA **) pv2)->ulClipFmt )
    {
        return( (* (CLIPDATA **) pv1)->ulClipFmt - (* (CLIPDATA **) pv2)->ulClipFmt );
    }

    ULONG len = CBPCLIPDATA( **(CLIPDATA **) pv1 );

    if ( CBPCLIPDATA( **(CLIPDATA **) pv2 ) < len )
        len = CBPCLIPDATA( **(CLIPDATA **) pv2 );

    int iCmp = memcmp( (* (CLIPDATA **) pv1)->pClipData,
                       (* (CLIPDATA **) pv2)->pClipData,
                       len );

    if ( iCmp != 0 || (* (CLIPDATA **) pv1)->cbSize == (* (CLIPDATA **) pv2)->cbSize)
        return( iCmp );

    if ( (* (CLIPDATA **) pv1)->cbSize > (* (CLIPDATA **) pv2)->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_CF_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_CF_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_CF_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_CF_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_CF_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (CLIPDATA **) pv1)->ulClipFmt == (* (CLIPDATA **) pv2)->ulClipFmt &&
            (* (CLIPDATA **) pv1)->cbSize == (* (CLIPDATA **) pv2)->cbSize &&
            memcmp( (* (CLIPDATA **) pv1)->pClipData,
                    (* (CLIPDATA **) pv2)->pClipData,
                    CBPCLIPDATA( **(CLIPDATA **) pv1 )) == 0 );
}

BOOL VTP_CF_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (CLIPDATA **) pv1)->ulClipFmt != (* (CLIPDATA **) pv2)->ulClipFmt &&
            (* (CLIPDATA **) pv1)->cbSize != (* (CLIPDATA **) pv2)->cbSize ||
            memcmp( (* (CLIPDATA **) pv1)->pClipData,
                    (* (CLIPDATA **) pv2)->pClipData,
                    CBPCLIPDATA( **(CLIPDATA **) pv1 )) != 0 );
}

//
// VTP_CLSID.  V means vector ( a pointer to a guid )
//             S meand singleton ( a pointer to a pointer to a guid )
//

int VTP_VV_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) );
}

int VTP_VS_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) );
}

int VTP_SV_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) );
}

int VTP_SS_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) );
}

BOOL VTP_SS_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) == 0 );
}

BOOL VTP_SS_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) != 0 );
}

BOOL VTP_VV_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) == 0 );
}

BOOL VTP_VV_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) != 0 );
}

BOOL VTP_VS_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) == 0 );
}

BOOL VTP_VS_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) != 0 );
}

BOOL VTP_SV_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) == 0 );
}

BOOL VTP_SV_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) != 0 );
}

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

ULONG const CComparators::_iStart = VT_EMPTY;

CComparators::SComparators const CComparators::_aVariantComparators[] = {
    // VT_EMPTY
    { VT_EMPTY_Compare, VTP_EMPTY_Compare,
      { 0,
        0,
        0,
        0,
        VT_EMPTY_EQ,
        VT_EMPTY_NE,
        0,
        0,
        0 },
      { 0,
        0,
        0,
        0,
        VTP_EMPTY_EQ,
        VTP_EMPTY_NE,
        0,
        0,
        0 },
    },

    // VT_NULL
    { VT_NULL_Compare, VTP_NULL_Compare,
      { 0,
        0,
        0,
        0,
        VT_NULL_EQ,
        VT_NULL_NE,
        0,
        0,
        0 },
      { 0,
        0,
        0,
        0,
        VTP_NULL_EQ,
        VTP_NULL_NE,
        0,
        0,
        0 },
    },

    // VT_I2
    { VT_I2_Compare, VTP_I2_Compare,
      { VT_I2_LT,
        VT_I2_LE,
        VT_I2_GT,
        VT_I2_GE,
        VT_I2_EQ,
        VT_I2_NE,
        0,
        VT_I2_AllBits,
        VT_I2_SomeBits
      },
      { VTP_I2_LT,
        VTP_I2_LE,
        VTP_I2_GT,
        VTP_I2_GE,
        VTP_I2_EQ,
        VTP_I2_NE,
        0,
        VTP_I2_AllBits,
        VTP_I2_SomeBits
      },
    },

    // VT_I4
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_R4
    { VT_R4_Compare, VTP_R4_Compare,
      { VT_R4_LT,
        VT_R4_LE,
        VT_R4_GT,
        VT_R4_GE,
        VT_R4_EQ,
        VT_R4_NE,
        0,
        0,
        0,
      },
      { VTP_R4_LT,
        VTP_R4_LE,
        VTP_R4_GT,
        VTP_R4_GE,
        VTP_R4_EQ,
        VTP_R4_NE,
        0,
        0,
        0,
      },
    },

    // VT_R8
    { VT_R8_Compare, VTP_R8_Compare,
      { VT_R8_LT,
        VT_R8_LE,
        VT_R8_GT,
        VT_R8_GE,
        VT_R8_EQ,
        VT_R8_NE,
        0,
        0,
        0,
      },
      { VTP_R8_LT,
        VTP_R8_LE,
        VTP_R8_GT,
        VTP_R8_GE,
        VTP_R8_EQ,
        VTP_R8_NE,
        0,
        0,
        0,
      },
    },

    // VT_CY
    { VT_I8_Compare, VTP_I8_Compare,
      { VT_I8_LT,
        VT_I8_LE,
        VT_I8_GT,
        VT_I8_GE,
        VT_I8_EQ,
        VT_I8_NE,
        0,
        0,
        0
      },
      { VTP_I8_LT,
        VTP_I8_LE,
        VTP_I8_GT,
        VTP_I8_GE,
        VTP_I8_EQ,
        VTP_I8_NE,
        0,
        0,
        0
      },
    },

    // VT_DATE
    { VT_R8_Compare, VTP_R8_Compare,
      { VT_R8_LT,
        VT_R8_LE,
        VT_R8_GT,
        VT_R8_GE,
        VT_R8_EQ,
        VT_R8_NE,
        0,
        0,
        0,
      },
      { VTP_R8_LT,
        VTP_R8_LE,
        VTP_R8_GT,
        VTP_R8_GE,
        VTP_R8_EQ,
        VTP_R8_NE,
        0,
        0,
        0,
      },
    },

    // VT_BSTR
    { VT_BSTR_Compare, VTP_BSTR_Compare,
      { VT_BSTR_LT,
        VT_BSTR_LE,
        VT_BSTR_GT,
        VT_BSTR_GE,
        VT_BSTR_EQ,
        VT_BSTR_NE,
        0,
        0,
        0
      },
      { VTP_BSTR_LT,
        VTP_BSTR_LE,
        VTP_BSTR_GT,
        VTP_BSTR_GE,
        VTP_BSTR_EQ,
        VTP_BSTR_NE,
        0,
        0,
        0
      },
    },

    // VT_DISPATCH
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_ERROR
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_BOOL
    { VT_BOOL_Compare, VTP_BOOL_Compare,
      { 0,
        0,
        0,
        0,
        VT_BOOL_EQ,
        VT_BOOL_NE,
        0,
        0,
        0
      },
      { 0,
        0,
        0,
        0,
        VTP_BOOL_EQ,
        VTP_BOOL_NE,
        0,
        0,
        0
      },
    },

    // VT_VARIANT
    { VT_VARIANT_Compare, VTP_VARIANT_Compare,
      { VT_VARIANT_LT,
        VT_VARIANT_LE,
        VT_VARIANT_GT,
        VT_VARIANT_GE,
        VT_VARIANT_EQ,
        VT_VARIANT_NE,
        0,
        0,
        0,
      },
      { VTP_VARIANT_LT,
        VTP_VARIANT_LE,
        VTP_VARIANT_GT,
        VTP_VARIANT_GE,
        VTP_VARIANT_EQ,
        VTP_VARIANT_NE,
        0,
        0,
        0,
      },
    },

    // VT_UNKNOWN
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_DECIMAL
    { VT_DEC_Compare, VTP_DEC_Compare,
      { VT_DEC_LT,
        VT_DEC_LE,
        VT_DEC_GT,
        VT_DEC_GE,
        VT_DEC_EQ,
        VT_DEC_NE,
        0,
        0,
        0
      },
      { VTP_DEC_LT,
        VTP_DEC_LE,
        VTP_DEC_GT,
        VTP_DEC_GE,
        VTP_DEC_EQ,
        VTP_DEC_NE,
        0,
        0,
        0
      },
    },

    // VARENUM value 15 unused
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_I1
    { VT_I1_Compare, VTP_I1_Compare,
      { VT_I1_LT,
        VT_I1_LE,
        VT_I1_GT,
        VT_I1_GE,
        VT_I1_EQ,
        VT_I1_NE,
        0,
        VT_I1_AllBits,
        VT_I1_SomeBits
      },
      { VTP_I1_LT,
        VTP_I1_LE,
        VTP_I1_GT,
        VTP_I1_GE,
        VTP_I1_EQ,
        VTP_I1_NE,
        0,
        VTP_I1_AllBits,
        VTP_I1_SomeBits
      },
    },

    // VT_UI1
    { VT_UI1_Compare, VTP_UI1_Compare,
      { VT_UI1_LT,
        VT_UI1_LE,
        VT_UI1_GT,
        VT_UI1_GE,
        VT_UI1_EQ,
        VT_UI1_NE,
        0,
        VT_UI1_AllBits,
        VT_UI1_SomeBits
      },
      { VTP_UI1_LT,
        VTP_UI1_LE,
        VTP_UI1_GT,
        VTP_UI1_GE,
        VTP_UI1_EQ,
        VTP_UI1_NE,
        0,
        VTP_UI1_AllBits,
        VTP_UI1_SomeBits
      },
    },

    // VT_UI2
    { VT_UI2_Compare, VTP_UI2_Compare,
      { VT_UI2_LT,
        VT_UI2_LE,
        VT_UI2_GT,
        VT_UI2_GE,
        VT_UI2_EQ,
        VT_UI2_NE,
        0,
        VT_UI2_AllBits,
        VT_UI2_SomeBits
      },
      { VTP_UI2_LT,
        VTP_UI2_LE,
        VTP_UI2_GT,
        VTP_UI2_GE,
        VTP_UI2_EQ,
        VTP_UI2_NE,
        0,
        VTP_UI2_AllBits,
        VTP_UI2_SomeBits
      },
    },

    // VT_UI4
    { VT_UI4_Compare, VTP_UI4_Compare,
      { VT_UI4_LT,
        VT_UI4_LE,
        VT_UI4_GT,
        VT_UI4_GE,
        VT_UI4_EQ,
        VT_UI4_NE,
        0,
        VT_UI4_AllBits,
        VT_UI4_SomeBits
      },
      { VTP_UI4_LT,
        VTP_UI4_LE,
        VTP_UI4_GT,
        VTP_UI4_GE,
        VTP_UI4_EQ,
        VTP_UI4_NE,
        0,
        VTP_UI4_AllBits,
        VTP_UI4_SomeBits
      },
    },

    // VT_I8
    { VT_I8_Compare, VTP_I8_Compare,
      { VT_I8_LT,
        VT_I8_LE,
        VT_I8_GT,
        VT_I8_GE,
        VT_I8_EQ,
        VT_I8_NE,
        0,
        VT_I8_AllBits,
        VT_I8_SomeBits
      },
      { VTP_I8_LT,
        VTP_I8_LE,
        VTP_I8_GT,
        VTP_I8_GE,
        VTP_I8_EQ,
        VTP_I8_NE,
        0,
        VTP_I8_AllBits,
        VTP_I8_SomeBits
      },
    },

    // VT_UI8
    { VT_UI8_Compare, VTP_UI8_Compare,
      { VT_UI8_LT,
        VT_UI8_LE,
        VT_UI8_GT,
        VT_UI8_GE,
        VT_UI8_EQ,
        VT_UI8_NE,
        0,
        VT_UI8_AllBits,
        VT_UI8_SomeBits
      },
      { VTP_UI8_LT,
        VTP_UI8_LE,
        VTP_UI8_GT,
        VTP_UI8_GE,
        VTP_UI8_EQ,
        VTP_UI8_NE,
        0,
        VTP_UI8_AllBits,
        VTP_UI8_SomeBits
      },
    },

    // VT_INT
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_UINT
    { VT_UI4_Compare, VTP_UI4_Compare,
      { VT_UI4_LT,
        VT_UI4_LE,
        VT_UI4_GT,
        VT_UI4_GE,
        VT_UI4_EQ,
        VT_UI4_NE,
        0,
        VT_UI4_AllBits,
        VT_UI4_SomeBits
      },
      { VTP_UI4_LT,
        VTP_UI4_LE,
        VTP_UI4_GT,
        VTP_UI4_GE,
        VTP_UI4_EQ,
        VTP_UI4_NE,
        0,
        VTP_UI4_AllBits,
        VTP_UI4_SomeBits
      },
    },

    // VT_VOID
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_HRESULT
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_PTR
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_SAFEARRAY
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_CARRAY
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_USERDEFINED
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_LPSTR
    { VT_LPSTR_Compare, VTP_LPSTR_Compare,
      { VT_LPSTR_LT,
        VT_LPSTR_LE,
        VT_LPSTR_GT,
        VT_LPSTR_GE,
        VT_LPSTR_EQ,
        VT_LPSTR_NE,
        0,
        0,
        0
      },
      { VTP_LPSTR_LT,
        VTP_LPSTR_LE,
        VTP_LPSTR_GT,
        VTP_LPSTR_GE,
        VTP_LPSTR_EQ,
        VTP_LPSTR_NE,
        0,
        0,
        0
      },
    },

    // VT_LPWSTR
    { VT_LPWSTR_Compare, VTP_LPWSTR_Compare,
      { VT_LPWSTR_LT,
        VT_LPWSTR_LE,
        VT_LPWSTR_GT,
        VT_LPWSTR_GE,
        VT_LPWSTR_EQ,
        VT_LPWSTR_NE,
        0,
        0,
        0
      },
      { VTP_LPWSTR_LT,
        VTP_LPWSTR_LE,
        VTP_LPWSTR_GT,
        VTP_LPWSTR_GE,
        VTP_LPWSTR_EQ,
        VTP_LPWSTR_NE,
        0,
        0,
        0
      },
    }
};

ULONG const CComparators::_cVariantComparators =
    sizeof(CComparators::_aVariantComparators) /
    sizeof(CComparators::_aVariantComparators[0]);

ULONG const CComparators::_iStart2 = VT_FILETIME;

CComparators::SComparators const CComparators::_aVariantComparators2[] = {
    // VT_FILETIME
    { VT_UI8_Compare, VTP_UI8_Compare,
      { VT_UI8_LT,
        VT_UI8_LE,
        VT_UI8_GT,
        VT_UI8_GE,
        VT_UI8_EQ,
        VT_UI8_NE,
        0,
        0,
        0
      },
      { VTP_UI8_LT,
        VTP_UI8_LE,
        VTP_UI8_GT,
        VTP_UI8_GE,
        VTP_UI8_EQ,
        VTP_UI8_NE,
        0,
        0,
        0
      },
    },

    // VT_BLOB
    { VT_BLOB_Compare, VTP_BLOB_Compare,
      { VT_BLOB_LT,
        VT_BLOB_LE,
        VT_BLOB_GT,
        VT_BLOB_GE,
        VT_BLOB_EQ,
        VT_BLOB_NE,
        0,
        0,
        0
      },
      { VTP_BLOB_LT,
        VTP_BLOB_LE,
        VTP_BLOB_GT,
        VTP_BLOB_GE,
        VTP_BLOB_EQ,
        VTP_BLOB_NE,
        0,
        0,
        0
      },
    },

    // VT_STREAM
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STORAGE
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STREAMED_OBJECT
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STORED_OBJECT
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_BLOB_OBJECT
    { VT_BLOB_Compare, VTP_BLOB_Compare,
      { VT_BLOB_LT,
        VT_BLOB_LE,
        VT_BLOB_GT,
        VT_BLOB_GE,
        VT_BLOB_EQ,
        VT_BLOB_NE,
        0,
        0,
        0
      },
      { VTP_BLOB_LT,
        VTP_BLOB_LE,
        VTP_BLOB_GT,
        VTP_BLOB_GE,
        VTP_BLOB_EQ,
        VTP_BLOB_NE,
        0,
        0,
        0
      },
    },

    // VT_CF
    { VT_CF_Compare, VTP_CF_Compare,
      { VT_CF_LT,
        VT_CF_LE,
        VT_CF_GT,
        VT_CF_GE,
        VT_CF_EQ,
        VT_CF_NE,
        0,
        0,
        0
      },
      { VTP_CF_LT,
        VTP_CF_LE,
        VTP_CF_GT,
        VTP_CF_GE,
        VTP_CF_EQ,
        VTP_CF_NE,
        0,
        0,
        0
      },
    },

    // VT_CLSID
    { VT_CLSID_Compare, 0, // Vector special-cased in GetPointerComparator
      { 0,
        0,
        0,
        0,
        VT_CLSID_EQ,
        VT_CLSID_NE,
        0,
        0,
        0
      },
      { 0,
        0,
        0,
        0,
        0,     // Special-cased in GetPointerRelop
        0,     // Special-cased in GetPointerRelop
        0,
        0,
        0
      },
    }
};


ULONG const CComparators::_cVariantComparators2 =
    sizeof(CComparators::_aVariantComparators2) /
    sizeof(CComparators::_aVariantComparators2[0]);

ULONG const CComparators::_iStart3 = DBTYPE_BYTES;

CComparators::SComparators const CComparators::_aVariantComparators3[] = {
    // DBTYPE_BYTES
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // DBTYPE_STR
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // DBTYPE_WSTR
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    }
};

ULONG const CComparators::_cVariantComparators3 =
    sizeof(CComparators::_aVariantComparators3) /
    sizeof(CComparators::_aVariantComparators3[0]);

ULONG const SortDescend = 1;
ULONG const SortNullFirst = 2;

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::Init, public
//
//  Synopsis:   [Re] Initializes property comparator to use a different
//              sort order.
//
//  Arguments:  [cCols]     -- Count of columns
//              [aKey]      -- Sort keys
//              [aColIndex] -- Index of column in sort key
//
//  History:    16-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CComparePropSets::Init( int cCols,
                             CSortSet const * pSort,
                             int aColIndex[] )
{
    Win4Assert( QUERY_SORTASCEND == 0 );
    Win4Assert( QUERY_SORTDESCEND == SortDescend );
    Win4Assert( (QUERY_SORTXASCEND & SortNullFirst) == SortNullFirst );
    Win4Assert( (QUERY_SORTXDESCEND & SortNullFirst) == SortNullFirst );

    delete _aColComp;
    _aColComp = 0;

    if ( cCols > 0 )
    {
        _cColComp = cCols;
        _aColComp = new SColCompare[ _cColComp ];

        for ( UINT i = 0; i < _cColComp; i++ )
        {
            if (0 == aColIndex)
                _aColComp[i]._iCol = i;
            else
                _aColComp[i]._iCol = aColIndex[i];

            _aColComp[i]._dir = pSort->Get(i).dwOrder;
            _aColComp[i]._DirMult =
                ( ( _aColComp[i]._dir & SortDescend ) != 0 ) ? -1 : 1;
            _aColComp[i]._pt = VT_EMPTY;
            _aColComp[i]._comp = VT_EMPTY_Compare;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::Init, public
//
//  Synopsis:   [Re] Initializes property comparator to use a different
//              sort order.  Assumes ascending order.  Mostly useful for
//              equality testing.
//
//  Arguments:  [pCols]     -- Columns
//              [aColIndex] -- Index of column in sort key
//
//  History:    02-Nov-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CComparePropSets::Init( CColumnSet const & cols )
{
    Win4Assert( cols.Size() > 0 );

    delete _aColComp;
    _aColComp = 0;

    _cColComp = cols.Size();
    _aColComp = new SColCompare[ _cColComp ];

    for ( UINT i = 0; i < _cColComp; i++ )
    {
        _aColComp[i]._iCol = i;
        _aColComp[i]._dir = 0;
        _aColComp[i]._DirMult = 1;
        _aColComp[i]._pt = VT_EMPTY;
        _aColComp[i]._comp = VT_EMPTY_Compare;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::Compare, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    Column # where row1 > row2 or negative column # where row1
//              < row2 or 0 if row1 = row2.
//              This odd return code is useful for categorization, so it
//              knows the column at which the rows differ.
//
//  History:    27-Jun-96 dlee     Created
//
//--------------------------------------------------------------------------

int CComparePropSets::Compare( PROPVARIANT ** row1, PROPVARIANT ** row2 )
{
    Win4Assert( !IsEmpty() );
    Win4Assert( VT_EMPTY == 0 );
    Win4Assert( VT_NULL == 1 );

    int idiff = 0;

    for ( UINT i = 0; i < _cColComp; i++ )
    {
        ULONG ptRow1 = row1[_aColComp[i]._iCol]->vt;
        ULONG ptRow2 = row2[_aColComp[i]._iCol]->vt;

        //
        // If the property types are incompatible, then 'sort' according
        // to type.  VT_EMPTY and VT_NULL will sort to beginning.
        //

        if ( ptRow1 != ptRow2 )
        {
            idiff = ptRow2 - ptRow1;
            break;
        }

        if ( ptRow1 != _aColComp[i]._pt )
            _UpdateCompare( i, (VARENUM) ptRow1 );

        Win4Assert( _aColComp[i]._comp != 0 );

        idiff = _aColComp[i]._comp( *row1[_aColComp[i]._iCol],
                                    *row2[_aColComp[i]._iCol] ) *
                _aColComp[i]._DirMult;

        if ( 0 != idiff )
            break;
    }

    if ( idiff < 0 )
        return - (int) ( i + 1 );

    if ( idiff > 0 )
        return i + 1;

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::IsLT, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if row1 < row2, FALSE otherwise
//
//  History:    16-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CComparePropSets::IsLT( PROPVARIANT ** row1, PROPVARIANT ** row2 )
{
    int idiff = Compare( row1, row2 );

    return ( idiff < 0 );
}


//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::IsGT, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if row1 > row2, FALSE otherwise
//
//  History:    16-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CComparePropSets::IsGT( PROPVARIANT ** row1, PROPVARIANT ** row2 )
{
    int idiff = Compare( row1, row2 );

    return ( idiff > 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::IsEQ, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if [row1] == [row2].
//
//  History:    02-Nov-93 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CComparePropSets::IsEQ( PROPVARIANT ** row1, PROPVARIANT ** row2 )
{
    int idiff = Compare( row1, row2 );

    return ( 0 == idiff );
}

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::_UpdateCompare, private
//
//  Effects:    Adds the appropriate comparator for column [iCol].
//
//  Arguments:  [iCol] -- Column to modify.
//              [pt]   -- New property type.
//
//  History:    16-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CComparePropSets::_UpdateCompare( UINT iCol, VARENUM vt )
{
    _aColComp[iCol]._pt = vt;
    _aColComp[iCol]._comp = VariantCompare.GetComparator( vt );

    if ( 0 == _aColComp[iCol]._comp )
        _aColComp[iCol]._comp = VT_DEFAULT_Compare;
}

inline void ConvertArrayToVector ( PROPVARIANT const & vIn, PROPVARIANT & vOut )
{
    Win4Assert( vIn.vt & VT_ARRAY );
    SAFEARRAY * pSa = vIn.parray;

    ULONG cDataElements = 1;

    for ( unsigned i = 0; i < pSa->cDims; i++ )
    {
        cDataElements *= pSa->rgsabound[i].cElements;
    }
    vOut.vt = (vIn.vt & VT_TYPEMASK) | VT_VECTOR;
    vOut.caub.cElems = cDataElements;
    vOut.caub.pElems = (BYTE *)pSa->pvData;
}


BYTE * _GetNth( PROPVARIANT const & v, unsigned i )
{
    Win4Assert( isVector(v) );
    switch ( getBaseType( v ) )
    {
    case VT_I1 : 
        return (BYTE *) & (v.caub.pElems[i]);
    case VT_UI1 :
        return (BYTE *) & (v.caub.pElems[i]);
    case VT_I2 :
        return (BYTE *) & (v.cai.pElems[i]);
    case VT_UI2 :
        return (BYTE *) & (v.caui.pElems[i]);
    case VT_BOOL :
        return (BYTE *) & (v.cabool.pElems[i]);
    case VT_I4 :
    case VT_INT :
        return (BYTE *) & (v.cal.pElems[i]);
    case VT_UI4 :
    case VT_UINT :
        return (BYTE *) & (v.caul.pElems[i]);
    case VT_R4 :
        return (BYTE *) & (v.caflt.pElems[i]);
    case VT_ERROR :
        return (BYTE *) & (v.cascode.pElems[i]);
    case VT_I8 :
        return (BYTE *) & (v.cah.pElems[i]);
    case VT_UI8 :
        return (BYTE *) & (v.cauh.pElems[i]);
    case VT_R8 :
        return (BYTE *) & (v.cadbl.pElems[i]);
    case VT_CY :
        return (BYTE *) & (v.cacy.pElems[i]);
    case VT_DATE :
        return (BYTE *) & (v.cadate.pElems[i]);
    case VT_FILETIME :
        return (BYTE *) & (v.cafiletime.pElems[i]);
    case VT_CLSID :
        return (BYTE *) & (v.cauuid.pElems[i]);
    case VT_CF :
        return (BYTE *) & (v.caclipdata.pElems[i]);
    case VT_BSTR :
        return (BYTE *) & (v.cabstr.pElems[i]);
    case VT_LPSTR :
        return (BYTE *) & (v.calpstr.pElems[i]);
    case VT_LPWSTR :
        return (BYTE *) & (v.calpwstr.pElems[i]);
    case VT_VARIANT :
        return (BYTE *) & (v.capropvar.pElems[i]);
    case VT_DECIMAL :
        // NOTE: not valid in a vector, but it could occur due to the
        //       simplistic conversion of arrays to vectors.
        DECIMAL * paDec = (DECIMAL *) v.caub.pElems;
        return (BYTE *) (paDec + i);
    }

    Win4Assert(!"illegal base variant type in vector compare");
    return 0;
} //_GetNth

//+-------------------------------------------------------------------------
//
//  Member:     VT_VECTOR_Compare, public
//
//  Effects:    Compares two property values, intended to be called when
//              at least one of the arguments is a vector
//
//  Arguments:  [v1]   -- 1st variant to compare
//              [v2]   -- 2nd variant to compare
//
//  History:    1-May-95 dlee     Created
//
//--------------------------------------------------------------------------

int VT_VECTOR_Compare( PROPVARIANT const & v1In, PROPVARIANT const & v2In )
{
    // must be the same datatype, or just sort on type

    if ( ( v1In.vt != v2In.vt ) )
        return v1In.vt - v2In.vt;

    PROPVARIANT v1 = v1In;
    PROPVARIANT v2 = v2In;

    if ( isArray(v1In) )
    {
        Win4Assert( isArray(v2In) );

        SAFEARRAY * pSa1 = v1In.parray;
        SAFEARRAY * pSa2 = v2In.parray;

        if (pSa1->cDims != pSa2->cDims)
            return pSa1->cDims - pSa2->cDims;

        ULONG cDataElements = 1;

        for ( unsigned i = 0; i < pSa1->cDims; i++ )
        {
            if ( pSa1->rgsabound[i].lLbound != pSa2->rgsabound[i].lLbound )
                return pSa1->rgsabound[i].lLbound - pSa2->rgsabound[i].lLbound;
            if ( pSa1->rgsabound[i].cElements != pSa2->rgsabound[i].cElements )
                return pSa1->rgsabound[i].cElements - pSa2->rgsabound[i].cElements;
            cDataElements *= pSa1->rgsabound[i].cElements;
        }

        //
        // arrays match in type, total size and dimensions.  Compare as vectors.
        //
        v1.vt = v2.vt = (v1In.vt & VT_TYPEMASK) | VT_VECTOR;
        v1.caub.cElems = v2.caub.cElems = cDataElements;
        v1.caub.pElems = (BYTE *)pSa1->pvData;
        v2.caub.pElems = (BYTE *)pSa2->pvData;
    }

    Win4Assert( isVector(v1) );

    FPCmp cmp = VariantCompare.GetPointerComparator( v1, v2 );
    if (0 == cmp)
    {
        // vector of an unhandled type

        ciDebugOut(( DEB_ERROR,
                     "Unknown property type %d (%x) used in comparison.\n",
                     v1.vt, v1.vt ));

        Win4Assert(! "VT_VECTOR_Compare: vector compare of unhandled type" );
        return 0;
    }

    unsigned cMin = __min( v1.cal.cElems, v2.cal.cElems );

    for ( unsigned x = 0; x < cMin; x++ )
    {
        int r = cmp( _GetNth( v1, x), _GetNth( v2, x ) );

        if (0 != r)
            return r;
    }

    // All equal so far up to the minimum cardinality of the vectors.
    // Any difference now would be due to the cardinality.

    return v1.cal.cElems - v2.cal.cElems;
} //VT_VECTOR_Compare

int VTP_VECTOR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VECTOR_Compare( ** (PROPVARIANT **) pv1,
                              ** (PROPVARIANT **) pv2 );
} //VTP_VECTOR_Compare

BOOL VT_VECTOR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) < 0;
} //VT_VECTOR_LT

BOOL VT_VECTOR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) <= 0;
} //VT_VECTOR_LE

BOOL VT_VECTOR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ! VT_VECTOR_LE( v1, v2 );
} //VT_VECTOR_GT

BOOL VT_VECTOR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ! VT_VECTOR_LT( v1, v2 );
} //VT_VECTOR_GE

BOOL VT_VECTOR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) == 0;
} //VT_VECTOR_EQ

BOOL VT_VECTOR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return !VT_VECTOR_EQ( v1, v2 );
} //VT_VECTOR_NE

BOOL VT_VECTOR_Common(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2,
    ULONG relop )
{
    // must be the same datatype and a vector or it doesn't compare.

    if ( ( v1.vt != v2.vt ) || ! isVector( v1 ) )
        return FALSE;

    // must be same cardinality, or it doesn't compare

    if ( v1.cal.cElems != v2.cal.cElems )
        return FALSE;

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    unsigned cElems = v1.cal.cElems;

    for ( unsigned x = 0; x < cElems; x++ )
    {
        if ( !cmp( _GetNth( v1, x), _GetNth( v2, x ) ) )
            return FALSE;
    }

    return TRUE;
} //VT_VECTOR_Common

BOOL VT_VECTOR_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Common( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits

BOOL VT_VECTOR_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Common( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

BOOL VT_VECTOR_Any(
    PROPVARIANT const & v1In,
    PROPVARIANT const & v2In,
    ULONG relop )
{
    //
    // Note: first parameter (v1) is the object's property value
    //       second parameter (v2) is the query restriction
    //
    // return TRUE if any element in v1 holds the relation to any v2 element
    //

    // base type of variant must be the same

    if ( getBaseType( v1In ) != getBaseType( v2In ) )
        return FALSE;

    //
    //  If either argument is a safearray, convert it to a vector
    //
    PROPVARIANT v1 = v1In;
    if (isArray(v1))
        ConvertArrayToVector( v1In, v1 );

    PROPVARIANT v2 = v2In;
    if (isArray(v2))
        ConvertArrayToVector( v2In, v2 );

    // first check for two singletons

    if ( ! isVector( v1 ) && ! isVector( v2 ) )
    {
        FRel cmp = VariantCompare.GetRelop( (VARENUM) v1.vt, relop );

        if ( 0 == cmp )
            return FALSE;
        else
            return cmp( v1, v2 );
    }

    // two vectors or singleton+vector -- get a pointer comparator

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    // check for two vectors

    if ( isVector( v1 ) && isVector( v2 ) )
    {
        for ( unsigned x1 = 0; x1 < v1.cal.cElems; x1++ )
        {
            for ( unsigned x2 = 0; x2 < v2.cal.cElems; x2++ )
            {
                if ( cmp( _GetNth( v1, x1), _GetNth( v2, x2 ) ) )
                    return TRUE;
            }
        }
    }
    else
    {
        // must be a singleton and a vector

        if ( isVector( v1 ) )
        {
            BYTE * pb2 = (BYTE *) &(v2.lVal);
            if ( VT_DECIMAL == v2.vt )
                pb2 = (BYTE *) &(v2.decVal);

            for ( unsigned i = 0; i < v1.cal.cElems; i++ )
            {
                if ( cmp( _GetNth( v1, i ), pb2 ) )
                    return TRUE;
            }
        }
        else
        {
            BYTE * pb1 = (BYTE *) &(v1.lVal);
            if ( VT_DECIMAL == v1.vt )
                pb1 = (BYTE *) &(v1.decVal);

            for ( unsigned i = 0; i < v2.cal.cElems; i++ )
            {
                if ( cmp( pb1, _GetNth( v2, i ) ) )
                    return TRUE;
            }
        }
    }

    return FALSE;
} //VT_VECTOR_Any

BOOL VT_VECTOR_LT_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRLT );
} //VT_VECTOR_LT_Any

BOOL VT_VECTOR_LE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRLE );
} //VT_VECTOR_LE_Any

BOOL VT_VECTOR_GT_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRGT );
} //VT_VECTOR_GT_Any

BOOL VT_VECTOR_GE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRGE );
} //VT_VECTOR_GE_Any

BOOL VT_VECTOR_EQ_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PREQ );
} //VT_VECTOR_EQ_Any

BOOL VT_VECTOR_NE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRNE );
} //VT_VECTOR_NE_Any

BOOL VT_VECTOR_AllBits_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits_Any

BOOL VT_VECTOR_SomeBits_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits_Any

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

BOOL VT_VECTOR_All(
    PROPVARIANT const & v1In,
    PROPVARIANT const & v2In,
    ULONG relop )
{
    //
    // Note: first parameter (v1) is the object's property value
    //       second parameter (v2) is the query restriction
    //
    // each element in v2 must hold the relation to each element v1
    // (not necessarily vice-versa)
    //

    // base type of variant must be the same

    if ( getBaseType( v1In ) != getBaseType( v2In ) )
        return FALSE;

    //
    //  If either argument is a safearray, convert it to a vector
    //
    PROPVARIANT v1 = v1In;
    if (isArray(v1))
        ConvertArrayToVector( v1In, v1 );

    PROPVARIANT v2 = v2In;
    if (isArray(v2))
        ConvertArrayToVector( v2In, v2 );

    // first check for two singletons

    if ( ! isVector( v1 ) && ! isVector( v2 ) )
    {
        FRel cmp = VariantCompare.GetRelop( (VARENUM) v1.vt, relop );

        if ( 0 == cmp )
            return FALSE;
        else
            return cmp( v1, v2 );
    }

    // two vectors or singleton+vector -- get a pointer comparator

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    // check for two vectors

    if ( isVector( v1 ) && isVector( v2 ) )
    {
        // Don't match empty vectors in queries.

        if ( 0 == v2.cal.cElems )
            return FALSE;

        //
        // Make sure the relation holds true for each element in the query
        // paired with each element in the file's value.
        //

        for ( unsigned x2 = 0; x2 < v2.cal.cElems; x2++ )
        {
            for ( unsigned x1 = 0; x1 < v1.cal.cElems; x1++ )
            {
                if ( ! cmp( _GetNth( v1, x1), _GetNth( v2, x2 ) ) )
                    return FALSE;
            }
        }
    }
    else
    {
        // must be a singleton and a vector

        if ( isVector( v1 ) )
        {
            BYTE * pb2 = (BYTE *) &(v2.lVal);
            if ( VT_DECIMAL == v2.vt )
                pb2 = (BYTE *) &(v2.decVal);

            for ( unsigned i = 0; i < v1.cal.cElems; i++ )
            {
                if ( ! cmp( _GetNth( v1, i ), pb2 ) )
                    return FALSE;
            }
        }
        else
        {
            BYTE * pb1 = (BYTE *) &(v1.lVal);
            if ( VT_DECIMAL == v1.vt )
                pb1 = (BYTE *) &(v1.decVal);

            for ( unsigned i = 0; i < v2.cal.cElems; i++ )
            {
                if ( ! cmp( pb1, _GetNth( v2, i ) ) )
                    return FALSE;
            }
        }
    }

    return TRUE;
} //VT_VECTOR_All

BOOL VT_VECTOR_LT_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRLT );
} //VT_VECTOR_LT_All

BOOL VT_VECTOR_LE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRLE );
} //VT_VECTOR_LE_All

BOOL VT_VECTOR_GT_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRGT );
} //VT_VECTOR_GT_All

BOOL VT_VECTOR_GE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRGE );
} //VT_VECTOR_GE_All

BOOL VT_VECTOR_EQ_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PREQ );
} //VT_VECTOR_EQ_All

BOOL VT_VECTOR_NE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRNE );
} //VT_VECTOR_NE_All

BOOL VT_VECTOR_AllBits_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits_All

BOOL VT_VECTOR_SomeBits_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits_All

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

FRel const CComparators::_aVectorComparators[] =
{
    VT_VECTOR_LT,
    VT_VECTOR_LE,
    VT_VECTOR_GT,
    VT_VECTOR_GE,
    VT_VECTOR_EQ,
    VT_VECTOR_NE,
    0,
    VT_VECTOR_AllBits,
    VT_VECTOR_SomeBits
};

ULONG const CComparators::_cVectorComparators =
    sizeof CComparators::_aVectorComparators /
    sizeof CComparators::_aVectorComparators[0];

FRel const CComparators::_aVectorComparatorsAll[] =
{
    VT_VECTOR_LT_All,
    VT_VECTOR_LE_All,
    VT_VECTOR_GT_All,
    VT_VECTOR_GE_All,
    VT_VECTOR_EQ_All,
    VT_VECTOR_NE_All,
    0,
    VT_VECTOR_AllBits_All,
    VT_VECTOR_SomeBits_All
};

ULONG const CComparators::_cVectorComparatorsAll =
    sizeof CComparators::_aVectorComparatorsAll /
    sizeof CComparators::_aVectorComparatorsAll[0];

FRel const CComparators::_aVectorComparatorsAny[] =
{
    VT_VECTOR_LT_Any,
    VT_VECTOR_LE_Any,
    VT_VECTOR_GT_Any,
    VT_VECTOR_GE_Any,
    VT_VECTOR_EQ_Any,
    VT_VECTOR_NE_Any,
    0,
    VT_VECTOR_AllBits_Any,
    VT_VECTOR_SomeBits_Any
};

ULONG const CComparators::_cVectorComparatorsAny =
    sizeof CComparators::_aVectorComparatorsAny /
    sizeof CComparators::_aVectorComparatorsAny[0];

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

FCmp CComparators::GetComparator( VARENUM vt )
{
    if ( isVectorOrArray( vt ) )
    {
        return VT_VECTOR_Compare;
    }
    else if ( vt >= _iStart && vt < _iStart + _cVariantComparators )
    {
        return( _aVariantComparators[vt].comparator );
    }
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 )
    {
        return( _aVariantComparators2[vt - _iStart2].comparator );
    }
    else if ( vt >= _iStart3 && vt < _iStart3 + _cVariantComparators3 )
    {
        return( _aVariantComparators3[vt - _iStart3].comparator );
    }
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetComparator Unknown property type %d in comparison.\n",
                     vt ));
        Win4Assert( !"Unknown property type used in comparison." );
        return( 0 );
    }
} //GetComparator

FRel CComparators::GetRelop( VARENUM vt, ULONG relop )
{
    if ( ( ( isVectorOrArray( vt ) ) ||
           ( isVectorRelop( relop ) ) ) &&
         ( getBaseRelop( relop ) < _cVectorComparators ) )
    {
        if ( isRelopAny( relop ) )
            return _aVectorComparatorsAny[ getBaseRelop( relop ) ];
        else if ( isRelopAll( relop ) )
            return _aVectorComparatorsAll[ getBaseRelop( relop ) ];
        else
            return _aVectorComparators[ relop ];
    }
    else if ( vt >= _iStart && vt < _cVariantComparators &&
         relop < sizeof(_aVariantComparators[0].relops)/
                 sizeof(_aVariantComparators[0].relops[0] ) )
    {
        return( _aVariantComparators[vt].relops[relop] );
    }
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 &&
         relop < sizeof(_aVariantComparators2[0].relops)/
                 sizeof(_aVariantComparators2[0].relops[0] ) )
    {
        return( _aVariantComparators2[vt - _iStart2].relops[relop] );
    }
    else if ( vt >= _iStart3 && vt < _iStart3 + _cVariantComparators3 &&
         relop < sizeof(_aVariantComparators3[0].relops)/
                 sizeof(_aVariantComparators3[0].relops[0] ) )
    {
        return( _aVariantComparators3[vt - _iStart3].relops[relop] );
    }
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetRelop Unknown property type %d or relation %d used in comparison.\n",
                     vt, relop ));
        Win4Assert( !"Unknown property type or relop used in comparison." );
        return( 0 );
    }
} //GetRelop

FPCmp CComparators::GetPointerComparator(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2 )
{
    VARENUM vt = getBaseType( v1 );

    if ( VT_CLSID == vt )
    {
        // GUIDs are the only case of variants where the data inside
        // a singleton is different from an element in a vector.
        // Data in a singleton is a pointer to a guid.
        // Data in the element of a vector is the guid itself.
        // The vector compare code assumes that the layout of singletons
        // and vectors is the same, so we need special-case comparators
        // for GUIDs.

        if ( isVector( v1 ) && isVector( v2 ) )
            return VTP_VV_CLSID_Compare;
        else if ( isVector( v1 ) )
            return VTP_VS_CLSID_Compare;
        else if ( isVector( v2 ) )
            return VTP_SV_CLSID_Compare;
        else
            return VTP_SS_CLSID_Compare;

        Win4Assert( !"unanticipated clsid / vector code path" );
    }

    if ( vt >= _iStart && vt < _iStart + _cVariantComparators )
        return( _aVariantComparators[vt].pointercomparator );
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 )
        return( _aVariantComparators2[vt - _iStart2].pointercomparator );
    else if ( vt >= _iStart3 && vt < _iStart3 + _cVariantComparators3 )
        return( _aVariantComparators3[vt - _iStart3].pointercomparator );
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetPointerComparator Unknown property type %d in comparison.\n",
                     vt ));
        Win4Assert( !"Unknown property type used in pointer comparison." );
        return( 0 );
    }
} //GetPointerComparator

FPRel CComparators::GetPointerRelop(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2,
    ULONG relop )
{
    VARENUM vt = getBaseType( v1 );

    if ( VT_CLSID == vt )
    {
        // GUIDs are the only case of variants where the data inside
        // a singleton is different from an element in a vector.
        // Data in a singleton is a pointer to a guid.
        // Data in the element of a vector is the guid itself.
        // The vector compare code assumes that the layout of singletons
        // and vectors is the same, so we need special-case comparators
        // for GUIDs.

        if ( isVector( v1 ) && isVector( v2 ) )
        {
            if ( PREQ == relop )
                return VTP_VV_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_VV_CLSID_NE;
            else
                return 0;
        }
        else if ( isVector( v1 ) )
        {
            if ( PREQ == relop )
                return VTP_VS_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_VS_CLSID_NE;
            else
                return 0;
        }
        else if ( isVector( v2 ) )
        {
            if ( PREQ == relop )
                return VTP_SV_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_SV_CLSID_NE;
            else
                return 0;
        }
        else
        {
            if ( PREQ == relop )
                return VTP_SS_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_SS_CLSID_NE;
            else
                return 0;
        }
    }

    if ( vt >= _iStart && vt < _cVariantComparators &&
         relop < sizeof(_aVariantComparators[0].pointerrelops)/
                 sizeof(_aVariantComparators[0].pointerrelops[0] ) )
        return( _aVariantComparators[vt].pointerrelops[relop] );
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 &&
         relop < sizeof(_aVariantComparators2[0].pointerrelops)/
                 sizeof(_aVariantComparators2[0].pointerrelops[0] ) )
        return( _aVariantComparators2[vt - _iStart2].pointerrelops[relop] );
    else if ( vt >= _iStart3 && vt < _iStart3 + _cVariantComparators3 &&
         relop < sizeof(_aVariantComparators3[0].pointerrelops)/
                 sizeof(_aVariantComparators3[0].pointerrelops[0] ) )
        return( _aVariantComparators3[vt - _iStart3].pointerrelops[relop] );
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetPointerRelop Unknown property type %d or relation %d used in comparison.\n",
                     vt, relop ));
        Win4Assert( !"Unknown property type or relop used in pointer comparison." );
        return( 0 );
    }
} //GetPointerRelop

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

int DBVector_Compare( DBTYPEENUM type, BYTE const * p1, BYTE const * p2 )
{
    //
    // Convert to variants and use the normal variant vector comparator.
    // This is a little bit slow, but it is an odd case and the code size
    // otherwise would be greatly increased.
    //

    PROPVARIANT v1,v2;

    Win4Assert( isVector(type) );

    v1.vt = v2.vt = (VARENUM) type;

    v1.cal = *(CAL *) p1;
    v2.cal = *(CAL *) p2;

    return VT_VECTOR_Compare( v1, v2 );
} //DBVector_Compare

int DBTYPE_EMPTY_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( 0 );
}

int DBTYPE_NULL_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( 0 );
}

int DBTYPE_I1_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(signed char *)pv1 - *(signed char *)pv2 );
}

int DBTYPE_I1_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_I1 ), pv1, pv2);
}

int DBTYPE_UI1_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(unsigned char *)pv1 - *(unsigned char *)pv2 );
}

int DBTYPE_UI1_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_UI1 ), pv1, pv2);
}

int DBTYPE_I2_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(short *)pv1 - *(short *)pv2 );
}

int DBTYPE_I2_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_I2 ), pv1, pv2);
}

int DBTYPE_UI2_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(unsigned short *)pv1 - *(unsigned short *)pv2 );
}

int DBTYPE_UI2_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_UI2 ), pv1, pv2);
}

int DBTYPE_I4_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    long l1 = * (long *) pv1;
    long l2 = * (long *) pv2;

    return ( l1 > l2 ) ? 1 : ( l1 < l2 ) ? -1 : 0;
}

int DBTYPE_I4_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_I4 ), pv1, pv2);
}

int DBTYPE_UI4_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;

    return ( ul1 > ul2 ) ? 1 : ( ul1 < ul2 ) ? -1 : 0;
}

int DBTYPE_UI4_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_UI4 ), pv1, pv2);
}

int DBTYPE_R4_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return VTP_R4_Compare( pv1, pv2 );
}

int DBTYPE_R4_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_R4 ), pv1, pv2);
}

int DBTYPE_R8_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return VTP_R8_Compare( pv1, pv2 );
}

int DBTYPE_R8_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_R8 ), pv1, pv2);
}

int DBTYPE_I8_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(LONGLONG *)pv1 > *(LONGLONG *)pv2 ? 1 :
            *(LONGLONG *)pv1 == *(LONGLONG *)pv2 ? 0 :
            -1 );
}

int DBTYPE_I8_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_I8 ), pv1, pv2);
}

int DBTYPE_UI8_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(ULONGLONG *)pv1 > *(ULONGLONG *)pv2 ? 1 :
            *(ULONGLONG *)pv1 == *(ULONGLONG *)pv2 ? 0 :
            -1 );
}

int DBTYPE_UI8_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_UI8 ), pv1, pv2);
}

int DBTYPE_BOOL_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( (*(USHORT *)pv1 == 0) == (*(USHORT *)pv2 == 0) );
}

int DBTYPE_BOOL_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_BOOL ), pv1, pv2);
}

int DBTYPE_VARIANT_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return VT_VARIANT_Compare( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

int DBTYPE_GUID_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( memcmp( pv1, pv2, sizeof(GUID) ) );
}

int DBTYPE_GUID_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_GUID ), pv1, pv2);
}

int DBTYPE_BYTES_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    ULONG mincb = __min( cb1, cb2 );

    int result = memcmp( pv1, pv2, mincb );

    if (result == 0)
        result = cb1 - cb2;

    return result;
}

int DBTYPE_STR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    int cMin = __min( cb1, cb2 );

    int ret = _strnicmp( (char *) pv1, (char *) pv2, cMin );

    if (0 == ret)
        return cb1 - cb2;
    else
        return ret;
}

int DBTYPE_WSTR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    int cMin = __min( cb1, cb2 );

    int ret = _wcsnicmp( (WCHAR *) pv1, (WCHAR *) pv2, cMin );

    if (0 == ret)
        return cb1 - cb2;
    else
        return ret;
}

int DBTYPE_BSTR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return VTP_BSTR_Compare( pv1, pv2 );
}

int DBTYPE_BSTR_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( (DBTYPEENUM) VT_BSTR ), pv1, pv2);
}

int DBTYPE_LPSTR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return _stricmp( (*(char **) pv1), (*(char **) pv2) );
}

int DBTYPE_LPSTR_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( (DBTYPEENUM) VT_LPSTR ), pv1, pv2);
}


int DBTYPE_LPWSTR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             (*(WCHAR **) pv1),
                             -1,
                             (*(WCHAR **) pv2),
                             -1 );
    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

int DBTYPE_LPWSTR_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( (DBTYPEENUM) VT_LPWSTR ), pv1, pv2);
}

CComparators::SDBComparators const CComparators::_aDBComparators[] = {
    // VT_EMPTY, DBTYPE_EMPTY
    { DBTYPE_EMPTY_Compare,
      0,
    },

    // VT_NULL, DBTYPE_NULL
    { DBTYPE_NULL_Compare,
      0,
    },

    // VT_I2, DBTYPE_I2
    { DBTYPE_I2_Compare,
      DBTYPE_I2_VectorCompare,
    },

    // VT_I4, DBTYPE_I4
    { DBTYPE_I4_Compare,
      DBTYPE_I4_VectorCompare,
    },

    // VT_R4, DBTYPE_R4
    { DBTYPE_R4_Compare,
      DBTYPE_R4_VectorCompare,
    },

    // VT_R8, DBTYPE_R8
    { DBTYPE_R8_Compare,
      DBTYPE_R8_VectorCompare,
    },

    // VT_CY, DBTYPE_CY
    { DBTYPE_I8_Compare,
      DBTYPE_I8_VectorCompare,
    },

    // VT_DATE, DBTYPE_DATE
    { DBTYPE_R8_Compare,
      DBTYPE_R8_VectorCompare,
    },

    // VT_BSTR, DBTYPE_BSTR
    { DBTYPE_BSTR_Compare,
      DBTYPE_BSTR_VectorCompare,
    },

    // VT_DISPATCH
    { 0,
      0,
    },

    // VT_ERROR
    { DBTYPE_I4_Compare,
      DBTYPE_I4_VectorCompare,
    },

    // VT_BOOL
    { DBTYPE_BOOL_Compare,
      DBTYPE_BOOL_VectorCompare,
    },

    // VT_VARIANT
    { DBTYPE_VARIANT_Compare,
      DBTYPE_VARIANT_Compare,
    },

    // VT_UNKNOWN
    { 0,
      0,
    },

    // VARENUM value 14 unused
    { 0,
      0,
    },

    // VARENUM value 15 unused
    { 0,
      0,
    },

    // VT_I1 undefined in PROPVARIANT union
    { DBTYPE_I1_Compare,
      DBTYPE_I1_VectorCompare,
    },

    // VT_UI1
    { DBTYPE_UI1_Compare,
      DBTYPE_UI1_VectorCompare,
    },

    // VT_UI2
    { DBTYPE_UI2_Compare,
      DBTYPE_UI2_VectorCompare,
    },

    // VT_UI4
    { DBTYPE_UI4_Compare,
      DBTYPE_UI4_VectorCompare,
    },

    // VT_I8
    { DBTYPE_I8_Compare,
      DBTYPE_I8_VectorCompare,
    },

    // VT_UI8
    { DBTYPE_UI8_Compare,
      DBTYPE_UI8_VectorCompare,
    },

    // VT_INT undefined in PROPVARIANT union
    { 0,
      0,
    },

    // VT_UINT undefined in PROPVARIANT union
    { 0,
      0,
    },

    // VT_VOID
    { 0,
      0,
    },

    // VT_HRESULT
    { 0,
      0,
    },

    // VT_PTR
    { 0,
      0,
    },

    // VT_SAFEARRAY
    { 0,
      0,
    },

    // VT_CARRAY
    { 0,
      0,
    },

    // VT_USERDEFINED
    { 0,
      0,
    },

    // VT_LPSTR  (translated form of DBTYPE_STR | DBTYPE_BYREF)
    { DBTYPE_LPSTR_Compare,
      DBTYPE_LPSTR_VectorCompare,
    },

    // VT_LPWSTR  (translated form of DBTYPE_WSTR | DBTYPE_BYREF)
    { DBTYPE_LPWSTR_Compare,
      DBTYPE_LPWSTR_VectorCompare,
    }
};

ULONG const CComparators::_iDBStart = VT_EMPTY;

ULONG const CComparators::_cDBComparators =
    sizeof(CComparators::_aDBComparators) /
    sizeof(CComparators::_aDBComparators[0]);

ULONG const CComparators::_iDBStart2 = VT_FILETIME;

CComparators::SDBComparators const CComparators::_aDBComparators2[] = {
    // VT_FILETIME
    { DBTYPE_UI8_Compare,
      DBTYPE_UI8_VectorCompare,
    },

    // VT_BLOB
    { 0,
      0,
    },

    // VT_STREAM
    { 0,
      0,
    },

    // VT_STORAGE
    { 0,
      0,
    },

    // VT_STREAMED_OBJECT
    { 0,
      0,
    },

    // VT_STORED_OBJECT
    { 0,
      0,
    },

    // VT_BLOB_OBJECT
    { 0,
      0,
    },

    // VT_CF
    { 0,
      0,
    },

    // VT_CLSID, DBTYPE_GUID
    { DBTYPE_GUID_Compare,
      DBTYPE_GUID_VectorCompare,
    }
};

ULONG const CComparators::_cDBComparators2 =
    sizeof(CComparators::_aDBComparators2) /
    sizeof(CComparators::_aDBComparators2[0]);

ULONG const CComparators::_iDBStart3 = DBTYPE_BYTES;

CComparators::SDBComparators const CComparators::_aDBComparators3[] = {
    // DBTYPE_BYTES
    { DBTYPE_BYTES_Compare,
      0,
    },

    // DBTYPE_STR
    { DBTYPE_STR_Compare,
      0,
    },

    // DBTYPE_WSTR
    { DBTYPE_WSTR_Compare,
      0,
    }
};

ULONG const CComparators::_cDBComparators3 =
    sizeof(CComparators::_aDBComparators3) /
    sizeof(CComparators::_aDBComparators3[0]);

//+-------------------------------------------------------------------------
//
//  Member:     CComparators::_RationalizeDBByRef, private
//
//  Synopsis:   Converts BYREF oledb string types to variant equivalents
//
//  Arguments:  [vt] -- Data type to be converted.
//
//  Returns:    A VARENUM equivalent for oledb string types
//
//  Notes:      DBTYPE_BYREF | DBTYPE_WSTR and the vector version of the
//              same are idential in meaning to the corresponding VT_LPWSTR
//              VARENUM type.
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

DBTYPEENUM CComparators::_RationalizeDBByRef( DBTYPEENUM vt )
{
    // convert these types to something usable as an index

    if ( 0 != ( DBTYPE_BYREF & vt ) )
    {
        if ( (DBTYPE_BYREF | DBTYPE_WSTR) == vt )
            return (DBTYPEENUM) VT_LPWSTR;
        else if ( (DBTYPE_BYREF | DBTYPE_STR) == vt )
            return (DBTYPEENUM) VT_LPSTR;
        if ( (DBTYPE_VECTOR | DBTYPE_BYREF | DBTYPE_WSTR) == vt )
            return (DBTYPEENUM) (VT_VECTOR | VT_LPWSTR);
        else if ( (DBTYPE_VECTOR | DBTYPE_BYREF | DBTYPE_STR) == vt )
             return (DBTYPEENUM) (VT_VECTOR | VT_LPSTR);
    }

    return vt;
} //_RationalizeByRef

//+-------------------------------------------------------------------------
//
//  Member:     CComparators::GetDBComparator, public
//
//  Synopsis:   Returns a comparison function for a given data type.
//
//  Arguments:  [vt] -- Data type of returned comparator.
//
//  Returns:    Pointer to an FDBCmp function
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

FDBCmp CComparators::GetDBComparator( DBTYPEENUM vt )
{
    vt = _RationalizeDBByRef( vt );

    if ( 0 != ( DBTYPE_VECTOR & vt ) )
    {
        vt = (DBTYPEENUM) ( vt & ( ~ DBTYPE_VECTOR ) );

        if ( vt >= _iDBStart && vt < _iDBStart + _cDBComparators )
        {
            return( _aDBComparators[vt].dbvectorcomparator );
        }
        else if ( vt >= _iDBStart2 && vt < _iDBStart2 + _cDBComparators2 )
        {
            return( _aDBComparators2[vt - _iDBStart2].dbvectorcomparator );
        }
        else if ( vt >= _iDBStart3 && vt < _iDBStart3 + _cDBComparators3 )
        {
            return( _aDBComparators3[vt - _iDBStart3].dbvectorcomparator );
        }
        else
        {
            ciDebugOut(( DEB_ERROR,
                         "CComparators::GetDBComparator Unknown property type %d in comparison.\n",
                         vt ));
            Win4Assert( !"Unknown property type used in comparison." );
            return( 0 );
        }
    }
    else if ( vt >= _iDBStart && vt < _iDBStart + _cDBComparators )
    {
        return( _aDBComparators[vt].dbcomparator );
    }
    else if ( vt >= _iDBStart2 && vt < _iDBStart2 + _cDBComparators2 )
    {
        return( _aDBComparators2[vt - _iDBStart2].dbcomparator );
    }
    else if ( vt >= _iDBStart3 && vt < _iDBStart3 + _cDBComparators3 )
    {
        return( _aDBComparators3[vt - _iDBStart3].dbcomparator );
    }
    else
    {
        // This will be hit if someone has a binding like
        // DBTYPE_I2 | DBTYPE_BYREF, which means that instead
        // of writing 2 bytes into their data, we allocate 2
        // bytes from OLE and write that pointer into 4 bytes
        // of the client data.  There is a bug against oledb
        // to not allow the client to do something so ill-advised.
        //
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetDBComparator Unknown property type %d in comparison.\n",
                     vt ));
        Win4Assert( !"Unknown property type used in comparison." );
        return( 0 );
    }
} //GetDBComparator
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\pvalxpr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
// File:        PValXpr.cxx
//
// Contents:    Property value expression class
//
// Classes:     CXpr
//
// History:     11-Sep-91       KyleP   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <objcur.hxx>
#include <pvalxpr.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyValue::CXprPropertyValue, public
//
//  Synopsis:   Constructs a property value expression.
//
//  Arguments:  [pcxpr]    -- Expression to evaluate.
//              [propinfo] -- Used to query statistics of specific property
//
//  Requires:   [cxpr] Must be just a property name in Win 4.0
//
//  Returns:    GVRSuccess if successful
//
//  History:    14-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyValue::CXprPropertyValue( PROPID pid )
        : _pid( pid )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyValue::~CXprPropertyValue, public
//
//  Synopsis:   Virtual destructor required.
//
//  History:    15-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyValue::~CXprPropertyValue()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyValue::GetValue, public
//
//  Synopsis:   Computes the value of the expression for the current row.
//
//  Arguments:  [obj] -- Objects table to retrieve values from.  It is
//                       assumed to be positioned on the object whose
//                       property values are to be extracted.
//              [p]   -- Storage for the returned property value.  On
//                       return this will contain a PROPVARIANT at its head.
//              [pcb] -- Size allocated for p. Space after the PROPVARIANT
//                       structure itself can be used by GetValue to
//                       append structures which are sometimes pointed
//                       at by an PROPVARIANT.
//
//  Returns:    GVRSuccess if successful
//              *[pcb] contains the size required for p.
//
//  History:    16-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

GetValueResult CXprPropertyValue::GetValue( CRetriever & obj,
                                            PROPVARIANT * p,
                                            ULONG * pcb )
{
    return( obj.GetPropertyValue( _pid, p, pcb ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyValue::ValueType, public
//
//  Returns:    The property type of the property.
//
//  History:    26-Nov-91   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG CXprPropertyValue::ValueType() const
{
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\prelxpr.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1991-1998.
//
// File:        PRelXpr.cxx
//
// Contents:    Property relation expression
//
// Classes:     CXprPropertyRelation
//
// History:     11-Sep-91       KyleP   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <parse.hxx>
#include <objcur.hxx>
#include <compare.hxx>
#include <xpr.hxx>
#include <strategy.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::CXprPropertyRelation, public
//
//  Synopsis:   Create an expression used to test <prop> <relop> <const>
//
//  Arguments:  [pid]   -- Property ID to be compared
//              [relop] -- Relational operator
//              [prval] -- Constant value to be compared against
//              [prstContentHelper] -- Content index helper
//
//  History:    30-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyRelation::CXprPropertyRelation( PROPID pid,
                                            ULONG relop,
                                            CStorageVariant const & prval,
                                            CRestriction * prstContentHelper )
        : CXpr( CXpr::NTProperty ),
          _xpval( pid ),
          _rel( relop ),
          _cval( prval ),
          _xrstContentHelper( prstContentHelper )
{
    Win4Assert( getBaseRelop( _rel ) <= PRSomeBits );

    if ( ! _cval.IsValid() )
    {
        vqDebugOut(( DEB_ERROR, "ERROR: restriction with pointer value of 0\n" ));

        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

    _relop = VariantCompare.GetRelop( _cval.Type(), _rel );

    if ( 0 == _relop )
    {
        vqDebugOut(( DEB_ERROR,
                     "ERROR: Unsupported relational operator %d "
                     "on type 0x%x\n",
                     _rel,
                     _cval.Type() ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::CXprPropertyRelation, public
//
//  Synopsis:   Copy contstructor
//
//  Arguments:  [propxpr] -- Expression to copy
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyRelation::CXprPropertyRelation( CXprPropertyRelation & propxpr )
    : CXpr( propxpr.NType(), propxpr.GetWeight() ),
      _xpval( propxpr._xpval ),
      _relop( propxpr._relop ),
      _cval( propxpr._cval ),
      _rel( propxpr._rel )
{
    if ( !propxpr._xrstContentHelper.IsNull() )
        _xrstContentHelper.Set( propxpr._xrstContentHelper->Clone() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::~CXprPropertyRelation, public
//
//  Synopsis:   Destroys the expression
//
//  History:    30-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyRelation::~CXprPropertyRelation()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::Clone, public
//
//  Returns:    A copy of this node.
//
//  Derivation: From base class CXpr, Always override in subclasses.
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXpr * CXprPropertyRelation::Clone()
{
    return( new CXprPropertyRelation( *this ) );
}

void CXprPropertyRelation::SelectIndexing( CIndexStrategy & strategy )
{
    //
    // Bounds checking is for index selection.  Query properties are not
    // in any index.
    //

    if ( IS_CIQUERYPROPID(_xpval.Pid()) && _xpval.Pid() != pidUnfiltered )
    {
        strategy.SetUnknownBounds( _xpval.Pid() );
        return;
    }

    if ( ! _xrstContentHelper.IsNull() &&
         _xpval.Pid() != pidPath &&
         _xpval.Pid() != pidDirectory &&
         _xpval.Pid() != pidVirtualPath )
    {
        Win4Assert( _rel == PREQ || _rel == (PREQ|PRAny) || _rel == (PREQ|PRAll) );

        strategy.SetContentHelper( _xrstContentHelper.Acquire() );
    }

    switch ( _rel )
    {
    case PRLT:
    case PRLE:
        strategy.SetUpperBound( _xpval.Pid(), _cval );
        break;

    case PRGT:
    case PRGE:
    case PRAllBits:
        strategy.SetLowerBound( _xpval.Pid(), _cval );
        break;

    case PREQ:
        strategy.SetBounds( _xpval.Pid(), _cval, _cval );
        break;

    case PRSomeBits:
        //
        // Value must be at least as large as lowest set bit.
        //

        if ( _cval.Type() == VT_I4 )
        {
            long l = _cval;

            for ( unsigned lowbit = 0; l != 0; lowbit++ )
                l <<= 1;
            lowbit = 32 - lowbit;

            if ( lowbit > 0 )
            {
                CStorageVariant var( (long)(1 << lowbit) );

                strategy.SetLowerBound( _xpval.Pid(), var );
            }
        }
        break;

    case PRNE:
    default:
        strategy.SetUnknownBounds( _xpval.Pid() );
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::IsMatch, public
//
//  Arguments:  [obj] -- The object retriever.  [obj] is already positioned
//                       to the record to test.
//
//  Returns:    TRUE if the current record satisfies the relation.
//
//  History:    30-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CXprPropertyRelation::IsMatch( CRetriever & obj )
{
    // this is an array of LONGLONGs to force 8-byte alignment
    LONGLONG allBuffer[ 10 ];
    ULONG cb = sizeof allBuffer;
    PROPVARIANT * ppv = (PROPVARIANT *) allBuffer;

    GetValueResult rc = _xpval.GetValue( obj, ppv, &cb );

    //
    // If the object is too big for the stack then allocate heap (sigh).
    //

    XArray<BYTE> xTemp;

    if ( rc == GVRNotEnoughSpace )
    {
        xTemp.Init( cb );
        ppv = (PROPVARIANT *) xTemp.GetPointer();
        rc = _xpval.GetValue( obj, ppv, &cb );
    }

    if ( rc != GVRSuccess )
    {
        vqDebugOut(( DEB_TRACE,
                     "CXprPropertyRelation::IsMatch -- Can't get value.\n" ));
        return FALSE;
    }

    //
    //  In general, the types must match for values to match.
    //  There are exceptions for the vector case, and for != comparisons.
    // 

    if ( ppv->vt != _cval.Type() )
    {
        // If != comparison and value is VT_EMPTY, it matches
        if ( PRNE == _rel && VT_EMPTY == _cval.Type() )
            return TRUE;

        // Could be a vector compare iff ppv is a vector and the
        // relop is any/all.
        // Otherwise, return that there is no match.

        if ( ! ( isVectorOrArray( *ppv ) && isVectorRelop( _rel ) ) )
            return FALSE;
    }

    Win4Assert( 0 != _relop );

    return _relop( *ppv, (PROPVARIANT &)_cval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\nodexpr.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1991 - 2000.
//
// File:        NodeXpr.cxx
//
// Contents:    Internal expression classes
//
// Classes:     CXpr
//
// History:     11-Sep-91       KyleP     Created
//              23-Jan-95       t-colinb  Added Support for RTVector in
//                                        CNodeXpr::IsMatch
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xpr.hxx>
#include <parse.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::CNodeXpr, public
//
//  Synopsis:   Initialze an empty node.
//
//  Arguments:  [type]  -- Type of node (AND, OR, etc.)
//              [cInit] -- A hint about the number of expressions which
//                         will be added to this node.
//
//  Signals:    ???
//
//  History:    05-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CNodeXpr::CNodeXpr ( CXpr::NodeType type, unsigned cInit )
    : CXpr ( type ),
      _cXpr( 0 ),
      _size( cInit )
{
    _aXpr = new CXpr* [cInit];
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::CNodeXpr, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [nxpr] -- Node to copy from.
//
//  Signals:    ???
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CNodeXpr::CNodeXpr( CNodeXpr & nxpr )
    : CXpr ( nxpr.NType() )
{
    _cXpr   = nxpr._cXpr;
    _size   = nxpr._cXpr;
    _weight = nxpr._weight;

    _aXpr = new CXpr * [ _size ];
    RtlZeroMemory( _aXpr, _size * sizeof( CXpr * ) );

    TRY
    {
        for ( int i = _cXpr-1; i >= 0; i-- )
            _aXpr[i] = nxpr._aXpr[i]->Clone();
    }
    CATCH( CException, e )
    {
        for ( unsigned i = 0; i < _cXpr; i++ )
            delete _aXpr[i];

        delete _aXpr;
        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::~CNodeXpr, public
//
//  Synopsis:   Destroy subexpressions and cursor (if any)
//
//  Signals:    ???
//
//  History:    05-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CNodeXpr::~CNodeXpr ()
{
    for ( unsigned i = 0; i < _cXpr; i++ )
        delete _aXpr[i];

    delete _aXpr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::Clone, public
//
//  Returns:    A copy of this node.
//
//  Signals:    ???
//
//  Derivation: From base class CXpr, Always override in subclasses.
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXpr * CNodeXpr::Clone()
{
    return( new CNodeXpr( *this ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::SelectIndexing, public
//
//  Effects:    Selects indexing for children.
//
//  History:    03-Nov-94   KyleP       Created.
//
//  Notes:      Index selection is only applicable for AND nodes.
//
//----------------------------------------------------------------------------

void CNodeXpr::SelectIndexing( CIndexStrategy & strategy )
{
    BOOL fModeChange;

    if ( NType() == NTAnd )
        fModeChange = strategy.SetAndMode();
    else if ( NType() == NTOr )
        fModeChange = strategy.SetOrMode();
    else
    {
        strategy.SetUnknownBounds();
        return;
    }

    for ( unsigned i = 0; i < _cXpr; i++ )
        _aXpr[i]->SelectIndexing( strategy );

    if ( fModeChange )
        strategy.DoneWithBoolean();
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::IsLeaf, public
//
//  Returns:    FALSE.  Nodes are never leaf expressions.
//
//  Derivation: From base class CXpr, Frequently override in subclasses.
//
//  History:    12-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CNodeXpr::IsLeaf() const
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::AddChild, public
//
//  Synopsis:   Add an expression to the node.
//
//  Arguments:  [child] -- Expression to add.
//
//  Signals:    ???
//
//  History:    12-Dec-91   KyleP       Created.
//
//  Notes:      Once an expression has been added to a node it is owned
//              by that node.  (e.g., no one else should delete it)
//
//----------------------------------------------------------------------------

void CNodeXpr::AddChild ( CXpr* child )
{
    Win4Assert( child );

    if ( _cXpr < _size )
    {
        _aXpr[_cXpr++] = child;
    }
    else
    {
        CXpr ** newArray = new CXpr * [ 2 * _size ];
        memcpy( newArray, _aXpr, _cXpr * sizeof( CXpr * ) );

        Win4Assert( _cXpr == _size );
        newArray[_cXpr++] = child;

        delete _aXpr;
        _size *= 2;
        _aXpr = newArray;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::HitCount, public
//
//  Returns:    Sum for OR, Min for AND
//
//  History:    01-May-91   KyleP       Created.
//
//  Notes:      HitCount only makes sense for content clauses.  If there
//              are any non-content clauses then HitCount will return 0.
//
//----------------------------------------------------------------------------

ULONG CNodeXpr::HitCount( CRetriever & obj )
{
    ULONG result;

    switch ( NType() )
    {
    case NTAnd:
        {
            result = 0;

            for (int i = Count()-1; i >= 0; i--)
            {
                ULONG thisChild = GetChild( i )->HitCount( obj );
                result = (thisChild) ? min( result, thisChild ) : result;
            }
        }
        break;

    case NTOr:
        {
            result = 0;

            for (int i = Count()-1; i >= 0; i--)
            {
                ULONG thisChild = GetChild( i )->HitCount( obj );
                if ( 0 != thisChild )
                {
                    result += GetChild( i )->HitCount( obj );
                }
                else
                {
                    result = 0;
                    break;
                }
            }
        }
        break;

    default:
        result = 0;
        break;
    }

    return( result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::Rank, public
//
//  Returns:    Sum for OR, Min for AND
//
//  History:    01-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

LONG CNodeXpr::Rank( CRetriever & obj )
{
    LONG result;

    switch ( NType() )
    {
    case NTAnd:
        {
            result = MAX_QUERY_RANK;

            for (int i = Count()-1; i >= 0; i--)
            {
                result = min( result, GetChild( i )->Rank( obj ) );
            }
        }
        break;

    case NTOr:
        {
            result = 0;

            for (int i = Count()-1; i >= 0; i--)
            {
                result += GetChild( i )->Rank( obj );
            }

            result /= Count();
        }
        break;

    default:
        result = 0;
        break;
    }

    return( result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::IsMatch, public
//
//  Arguments:  [obj] -- The objects table.  [obj] is already positioned
//                       to the record to test.
//              [wid] -- Workid of object to which [obj] is positioned.
//
//  Returns:    TRUE if the current record satisfies the relation.
//
//  Signals:    ???
//
//  History:    20-Nov-91   KyleP       Created.
//              23-Jan-95   t-colinb    Added Support for RTVector in
//
//
//----------------------------------------------------------------------------

BOOL CNodeXpr::IsMatch( CRetriever & obj )
{
    Win4Assert( NType() == NTAnd ||
                NType() == NTOr  ||
                NType() == NTVector  );

    //
    // If some portion of the node has been indexed, adjust the cursor to
    // the wid we're looking for.
    //

    WORKID widCur = widInvalid;
    BOOL result;

    switch ( NType() )
    {
    case NTAnd:
        result = TRUE;
        {
            for (int i = Count()-1; result && i >= 0; i--)
            {
                result = GetChild( i )->IsMatch( obj );
            }
        }
        break;

    case NTOr:
    case NTVector:
        result = FALSE;
        {
            for (int i = Count()-1; !result && i >= 0; i--)
            {
                result = GetChild( i )->IsMatch( obj );
            }
        }
        break;

    default:
        result = FALSE;
        break;
    }

    return result;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::RemoveChild, public
//
//  Synopsis:   Removes a node.
//
//  Arguments:  [iPos] -- Position of node to remove.
//
//  Requires:   [iPos] is a valid node.
//
//  Returns:    The child node which was removed.
//
//  History:    19-Nov-91   KyleP       Created.
//
//  Notes:      CNodeXpr does not guarantee the position of nodes across
//              calls to RemoveChild.
//
//----------------------------------------------------------------------------

CXpr* CNodeXpr::RemoveChild ( unsigned iPos )
{
    Win4Assert ( iPos <= _cXpr );

    CXpr * pxp = _aXpr[iPos];
    _aXpr[iPos] = _aXpr[ _cXpr - 1 ];
    _cXpr--;

#if (CIDBG == 1)
    _aXpr[ _cXpr ] = 0;
#endif

    return( pxp );
}


//+-------------------------------------------------------------------------
//
//  Member:     CVectorXpr::CVectorXpr, public
//
//  Synopsis:   Constructs a vector expression.
//
//  Arguments:  [type]       -- Type of node (AND, OR, etc.)
//              [cInit]      -- A hint about the number of expressions
//                              which will be added.
//              [RankMethod] -- Method used to compute rank.
//
//  History:    24-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

CVectorXpr::CVectorXpr( unsigned cInit,
                        ULONG RankMethod )
        : CNodeXpr( CXpr::NTVector, cInit ),
          _ulRankMethod( RankMethod )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\state.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       State.cxx
//
//  Contents:   Finite automata state classes
//
//  Classes:
//
//  History:    01-21-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <state.hxx>

#include "stateset.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::CNFAState, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CNFAState::CNFAState( CNFAState const & src )
        : CFAState( src ),
          _pmoveRest( 0 ),
          _cmoveRest( src._cmoveRest ),
          _cMove( src._cMove )
{
    if ( _cmoveRest > 0 )
    {
        _pmoveRest = new CMove [_cmoveRest];
        RtlCopyMemory( _pmoveRest, src._pmoveRest, _cmoveRest * sizeof(_pmoveRest[0]) );
    }

    RtlCopyMemory( _moveFirst, src._moveFirst, sizeof(_moveFirst) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::Init, public
//
//  Synopsis:   Copy initializer
//
//  Arguments:  [src] -- Source
//
//  History:    15-Jul-96 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::Init( CNFAState & src )
{
    CFAState::Init( src.StateNumber() );

    if ( src.IsFinal() )
        MakeFinal();

    _cMove = src._cMove;
    RtlCopyMemory( _moveFirst, src._moveFirst, sizeof(_moveFirst) );

    _cmoveRest = src._cmoveRest;
    _pmoveRest = src._pmoveRest;

    src._cMove = 0;
    src._cmoveRest = 0;
    src._pmoveRest = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::operator =, public
//
//  Synopsis:   Assignment operator
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

inline void * operator new( size_t, CNFAState * pthis )
{
    return pthis;
}

#if _MSC_VER >= 1200
inline void operator delete( void * p, CNFAState * pthis ) {}
#endif

CNFAState & CNFAState::operator =( CNFAState const & src )
{
    CNFAState::~CNFAState();

    new (this) CNFAState( src );

    return *this;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::AddTransition, public
//
//  Synopsis:   Add new state transition.
//
//  Arguments:  [symbol]   -- On this symbol to...
//              [StateNum] --   this state.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::AddTransition( UINT symbol, UINT StateNum )
{
    //
    // First look for an exact match.  If this transition exists
    // then don't add it again.
    //

    for ( int i = CNFAState_cFirst-1; i >= 0; i--)
    {
        if ( _moveFirst[i]._symbol == symbol &&
             _moveFirst[i]._iState == StateNum )
        {
            return;
        }
    }

    if ( _cMove > CNFAState_cFirst )
    {
        for ( int i = _cMove - CNFAState_cFirst - 1; i >= 0; i--)
        {
            if ( _pmoveRest[i]._symbol == symbol &&
                 _pmoveRest[i]._iState == StateNum )
            {
                return;
            }
        }
    }

    //
    // New transition.  Add it.
    //

    if ( _cMove < CNFAState_cFirst )
    {
        //
        // Fits in the first (object based) set of moves.
        //

        _moveFirst[_cMove] = CMove( symbol, StateNum );
    }
    else
    {
        //
        // Overflow set of moves.
        //

        if ( _cMove - CNFAState_cFirst >= _cmoveRest )
        {
            vqDebugOut(( DEB_ITRACE,
                         "Growing NFA State transition array.\n" ));
            CMove * oldpmoveRest = _pmoveRest;
            UINT    oldcmoveRest = _cmoveRest;

            _cmoveRest = (_cmoveRest == 0) ? 2 : _cmoveRest + 5;

            _pmoveRest = (CMove *) new char [ _cmoveRest * sizeof( CMove ) ];

            memcpy( _pmoveRest, oldpmoveRest, oldcmoveRest * sizeof( CMove ) );
            delete oldpmoveRest;
        }

        _pmoveRest[_cMove - CNFAState_cFirst] = CMove( symbol, StateNum );
    }

    ++_cMove;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::RemoveTransition, public
//
//  Synopsis:   Removes a transition.
//
//  Arguments:  [symbol]   -- On this symbol to...
//              [StateNum] --   this state.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::RemoveTransition( UINT symbol, UINT StateNum )
{
    //
    // Find the transition
    //

    for ( int i = CNFAState_cFirst-1; i >= 0; i--)
    {
        if ( _moveFirst[i]._symbol == symbol &&
             _moveFirst[i]._iState == StateNum )
        {
            //
            // Move the last transition to this place.
            //

            if ( _cMove > CNFAState_cFirst )
            {
                _moveFirst[i] = _pmoveRest[_cMove - CNFAState_cFirst - 1];
            }
            else
            {
                _moveFirst[i] = _moveFirst[ _cMove - 1 ];
            }

            _cMove--;

            return;
        }
    }

    if ( _cMove > CNFAState_cFirst )
    {
        for ( int i = _cMove - CNFAState_cFirst - 1; i >= 0; i--)
        {
            if ( _pmoveRest[i]._symbol == symbol &&
                 _pmoveRest[i]._iState == StateNum )
            {
                _pmoveRest[i] = _pmoveRest[ _cMove - CNFAState_cFirst - 1 ];

                _cMove--;

                return;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::Move, public
//
//  Effects:    Adds to [ss] the set of states that can be reached from
//              this state on [symbol].
//
//  Arguments:  [ss]     -- Output state set.
//              [symbol] -- Input symbol.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::Move( CStateSet & ss, UINT symbol )
{
    for ( int i = (_cMove <= CNFAState_cFirst) ? _cMove-1 : CNFAState_cFirst-1;
            i >= 0;
            i--)
    {
        if ( _moveFirst[i]._symbol == symbol ||
             ( _moveFirst[i]._symbol == symAny &&
               symbol != symEpsilon ))
        {
            ss.Add( _moveFirst[i]._iState );
        }
    }

    for ( i = _cMove - CNFAState_cFirst - 1; i >= 0; i-- )
    {
        if ( _pmoveRest[i]._symbol == symbol ||
             ( _pmoveRest[i]._symbol == symAny &&
               symbol != symEpsilon &&
               symbol != symDot ))
        {
            ss.Add( _pmoveRest[i]._iState );
        }
    }
}

//
// Debug methods
//

#if (CIDBG == 1)

void CFAState::Display()
{
    vqDebugOut(( DEB_REGEX,
                 "State: %u, Final = %c", _iState, _fFinal ? 'T' : 'F' ));
}

void CNFAState::Display()
{
    CFAState::Display();
    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, " -- %u transitions\n", _cMove ));

    for ( int i = (_cMove <= CNFAState_cFirst) ? _cMove-1 : CNFAState_cFirst-1;
            i >= 0;
            i--)
    {
        if ( _moveFirst[i]._symbol == symEpsilon)
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\tEpsilon " ));
        }
        else if ( _moveFirst[i]._symbol == symAny )
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\tAny " ));
        }
        else
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                         "\t%u ", _moveFirst[i]._symbol ));
        }

        vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                     "--> %u\n", _moveFirst[i]._iState ));
    }

    for ( i = _cMove - CNFAState_cFirst - 1; i >= 0; i-- )
    {
        if ( _pmoveRest[i]._symbol == symEpsilon)
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\tEpsilon " ));
        }
        else if ( _pmoveRest[i]._symbol == symAny )
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\tAny " ));
        }
        else
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                         "\t%u ", _pmoveRest[i]._symbol ));
        }

        vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                     "--> %u\n", _pmoveRest[i]._iState ));
    }
}

#endif // (CIDBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\stateset.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       StateSet.hxx
//
//  Contents:
//
//  Classes:
//
//  History:    01-20-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "stateset.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::Clear, public
//
//  Synopsis:   Re-initializes a state set to empty.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CStateSet::Clear()
{
    delete _puiRest;

    _cStates = 0;
    _cRest = 0;
    _puiRest = 0;
    _cuiRest = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::Add, public
//
//  Synopsis:   Adds a state to the state set.
//
//  Arguments:  [state] -- State to add.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CStateSet::Add( UINT state )
{
    if ( IsMember( state ) )
        return;

    if ( _cStates < CStateSet_cFirst )
    {
        _auiFirst[ _cStates ] = state;
    }
    else
    {
        if ( _cRest >= _cuiRest )
        {
            UINT * oldpuiRest = _puiRest;
            UINT   oldcuiRest = _cuiRest;

            _cuiRest += 10;
            _puiRest = new UINT [ _cuiRest ];
            memcpy( _puiRest, oldpuiRest, oldcuiRest * sizeof( UINT ) );

            delete oldpuiRest;
        }

        _puiRest[ _cRest ] = state;
        ++_cRest;
    }

    ++_cStates;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::State, public
//
//  Arguments:  [iState] -- Index of state to return.
//
//  Returns:    The [iState] state in the state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CStateSet::State( UINT iState ) const
{
    if ( iState <= CStateSet_cFirst )
    {
        return( _auiFirst[ iState - 1 ] );
    }
    else
    {
        return( _puiRest[ iState - CStateSet_cFirst - 1 ] );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::IsMember, public
//
//  Arguments:  [state] -- State to look for.
//
//  Returns:    TRUE if [state] is in set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CStateSet::IsMember( UINT state )
{
    if ( _cStates == 0 )
        return( FALSE );

    //
    // Naive implementation.  As long as state sets are small this
    // will work fine.
    //

    for ( int i = min( _cStates, CStateSet_cFirst) - 1;
          i >= 0;
          i-- )
    {
        if( _auiFirst[ i ] == state )
            return( TRUE );
    }

    if ( _cStates > CStateSet_cFirst )
    {
        for ( int i = _cStates - CStateSet_cFirst - 1;
              i >= 0;
              i-- )
        {
            if( _puiRest[ i ] == state )
                return( TRUE );
        }
    }

    return( FALSE );
}

//
// Debug methods
//

int compare( void const * p1, void const * p2 )
{
    return( *(UINT*)p1 - *(UINT*)p2 );
}

#if (CIDBG == 1)

void CStateSet::Display()
{
#if 0
    //
    // Just to always print something close to sorted.
    //

    qsort( _auiFirst,
           ( _cStates < CStateSet_cFirst ) ? _cStates : CStateSet_cFirst,
           sizeof(UINT),
           compare );
#endif
    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "(" ));

    for (UINT i = 0; i < _cStates; i++)
    {
        if ( i <= CStateSet_cFirst-1 )
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, " %u", _auiFirst[ i ] ));
        else
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, 
                         " %u", _puiRest[ i - CStateSet_cFirst ] ));
    }

    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, " )" ));
}

#endif // (CIDBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\xlatchar.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2000.
//
//  File:       XlatChar.cxx
//
//  Contents:   Character translation class.
//
//  Classes:    CXlatChar
//
//  History:    02-13-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

// Local includes:
#include <xlatchar.hxx>

inline WCHAR CiToUpper( WCHAR c )
{
    return ( c < L'a' ) ? c : ( c <= L'z' ) ? ( c - (L'a' - L'A') ) :
           RtlUpcaseUnicodeChar( c );
} //CiToUpper

#define TOUPPER CiToUpper

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::CXlatChar, public
//
//  Synopsis:   Initializes character mapping (no char classes).
//
//  Arguments:  [fCaseSens] -- TRUE if case sensitive mapping.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

CXlatChar::CXlatChar( BOOLEAN fCaseSens )
        : _cAllocation( 31 ),
          _cRange( 1 ),
          _iPrevRange( 0 ),
          _fCaseSens( fCaseSens )
{
    _pwcRangeEnd = new WCHAR [ _cAllocation ];

    *_pwcRangeEnd = (WCHAR)-1;  // Largest possible character.

#if (CIDBG == 1)
    _fPrepared = FALSE;
#endif
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::CXlatChar, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatChar::CXlatChar( CXlatChar const & src )
        : _cRange( src._cRange ),
          _cAllocation( src._cAllocation ),
          _iPrevRange( src._iPrevRange ),
          _fCaseSens( src._fCaseSens )
#if (CIDBG == 1)
         ,_fPrepared( src._fPrepared )
#endif
{
    _pwcRangeEnd = new WCHAR [ _cAllocation ];
    RtlCopyMemory( _pwcRangeEnd, src._pwcRangeEnd, _cAllocation*sizeof(_pwcRangeEnd[0]) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::AddRange, public
//
//  Synopsis:   Adds range as a new equivalance class.
//
//  Arguments:  [wcStart] -- Start of range.
//              [wcEnd]   -- End of range.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

void CXlatChar::AddRange( WCHAR wcStart, WCHAR wcEnd )
{
    vqAssert( !_fPrepared );

    if ( !_fCaseSens )
    {
        wcStart = TOUPPER( wcStart );
        wcEnd = TOUPPER( wcEnd );
    }

    //
    // Make sure there's room for start and end of range in array.
    //

    if ( _cAllocation - _cRange < 2 )
        _Realloc();

    _pwcRangeEnd[_cRange++] = wcStart - 1;
    _pwcRangeEnd[_cRange++] = wcEnd;
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Translate, public
//
//  Synopsis:   Maps character to its equivalence class.
//
//  Arguments:  [wc] -- Character to map.
//
//  Returns:    The equivalence class of character.
//
//  Algorithm:  Binary search array until the correct bin is found.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

UINT CXlatChar::Translate( WCHAR wc ) const
{
    vqAssert( _fPrepared );

    if ( !_fCaseSens )
        wc = TOUPPER( wc );

    if ( wc == '.' )
        return( symDot );

    UINT i    = _cAllocation / 2;
    UINT step = (_cAllocation + 3) / 4;
    WCHAR wcCurrent = _pwcRangeEnd[i];

    while ( step != 0 )
    {
        if ( wcCurrent == wc )
            break;

        if ( wcCurrent < wc )
            i += step;
        else
            i -= step;

        step = step / 2;

        wcCurrent = _pwcRangeEnd[i];
    }

    //
    // If we can't go anywhere, then either i or i + 1 is correct.
    //

    if ( wcCurrent < wc )
        i++;

    return( i + 1 + cSpecialCharClasses );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::TranslateRange, public
//
//  Synopsis:   Iterator mapping character range to set of equivalence
//              classes.
//
//  Arguments:  [wcStart] -- Start of range.
//              [wcEnd]   -- End of range.
//
//  Returns:    If [wcStart] is 0 then the next class in the most
//              recently specified range is returned.  Otherwise the
//              first class in the new range is returned.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

UINT CXlatChar::TranslateRange( WCHAR wcStart, WCHAR wcEnd )
{
    if ( !_fCaseSens )
    {
        if ( 0 != wcStart )
            wcStart = TOUPPER( wcStart );

        wcEnd = TOUPPER( wcEnd );
    }

    if ( wcStart > wcEnd )
    {
        vqDebugOut(( DEB_ERROR, "Invalid regex.\n" ));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    if ( wcStart != 0 )
    {
        _iPrevRange = Translate( wcStart );

        vqDebugOut(( DEB_REGEX, "First range = " ));
    }
    else
    {
        if ( _iPrevRange - cSpecialCharClasses >= _cRange )
            return 0;

        if ( _pwcRangeEnd[_iPrevRange-1-cSpecialCharClasses] >= wcEnd )
            _iPrevRange = 0;
        else
            _iPrevRange++;

        vqDebugOut(( DEB_REGEX, "Secondary range = " ));
    }

    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "%u\n", _iPrevRange ));
    return _iPrevRange;
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Prepare, public
//
//  Synopsis:   Prepares class for translation.
//
//  Requires:   All equivalance classes must be added before prepare is
//              called.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

int _cdecl CompareFn( void const * Elt1, void const * Elt2 )
{
    return( *(WCHAR *)Elt1 - *(WCHAR *)Elt2 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Prepare, public
//
//  Synopsis:   Called after ranges added to prepare for searching.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatChar::Prepare()
{
    //
    // Sort and then remove duplicates from the array.
    //

    qsort( _pwcRangeEnd, _cRange, sizeof( *_pwcRangeEnd ), CompareFn );

    UINT iGood, iCurrent;

    for ( iGood = 0, iCurrent = 1; iCurrent < _cRange; iCurrent++ )
    {
        if ( _pwcRangeEnd[iGood] != _pwcRangeEnd[iCurrent] )
        {
            _pwcRangeEnd[++iGood] = _pwcRangeEnd[iCurrent];
        }
    }

    _cRange = iGood + 1;

    //
    // Make all the extra entries at the end look like the maximum
    // possible character so the binary search works.
    //

    memset( _pwcRangeEnd + _cRange,
            0xFF,
            (_cAllocation - _cRange) * sizeof( WCHAR ) );

#if (CIDBG == 1)
    _fPrepared = TRUE;
#endif

}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::_Realloc, private
//
//  Synopsis:   Grows the character array.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatChar::_Realloc()
{
    WCHAR * oldRangeEnd = _pwcRangeEnd;
    UINT    oldcAllocation = _cAllocation;

    _cAllocation = (_cAllocation + 1) * 2 - 1;
    _pwcRangeEnd = new WCHAR [ _cAllocation ];
    memcpy( _pwcRangeEnd, oldRangeEnd, oldcAllocation * sizeof( WCHAR ) );
    delete oldRangeEnd;
}

//
// Debug methods
//

#if (CIDBG == 1)

void CXlatChar::Display() const
{
    vqDebugOut(( DEB_REGEX, "Range\tStart - End\n"
            "-----\t-----   ---\n" ));

    vqDebugOut(( DEB_REGEX, "%s\t\t%u\n", "Any", symAny ));
    vqDebugOut(( DEB_REGEX, "%s\t\t%u\n", "<bol>", symBeginLine ));
    vqDebugOut(( DEB_REGEX, "%s\t\t%u\n", "<eol>", symEndLine ));
    vqDebugOut(( DEB_REGEX, "%s\t%u\n", "Invalid", symInvalid ));
    vqDebugOut(( DEB_REGEX, "%s\t%u\n", "Epsilon", symEpsilon ));
    vqDebugOut(( DEB_REGEX, "%s\t%u\n", "Dot (.)", symDot ));

    vqDebugOut(( DEB_REGEX, "%u\t1\t%u\n",
                 1+cSpecialCharClasses,
                 _pwcRangeEnd[0] ));

    for ( UINT i = 1; i < _cRange; i++ )
    {
        if ( _pwcRangeEnd[i-1]+1 < ' ' ||
             _pwcRangeEnd[i-1]+1 > '~' ||
             _pwcRangeEnd[i]     < ' ' ||
             _pwcRangeEnd[i]     > '~' )
            vqDebugOut(( DEB_REGEX,
                         "%u\t%u\t%u\n",
                         i+1+cSpecialCharClasses,
                         _pwcRangeEnd[i-1]+1,
                         _pwcRangeEnd[i] ));
        else
            vqDebugOut(( DEB_REGEX,
                         "%u\t\"%c\"\t\"%c\"\n",
                         i+1+cSpecialCharClasses,
                         _pwcRangeEnd[i-1]+1,
                         _pwcRangeEnd[i] ));
    }
}

#endif // (CIDBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\xpr.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1991 - 2000.
//
// File:        Xpr.cxx
//
// Contents:    Internal expression classes
//
// Classes:     CXpr
//
// History:     11-Sep-91       KyleP   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xpr.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::IsMatch, public
//
//  Arguments:  [obj] -- Objects table
//
//  Returns:    FALSE (default)
//
//  History:    01-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CXpr::IsMatch( CRetriever & )
{
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::HitCount, public
//
//  Returns:    0 (default)
//
//  History:    01-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG CXpr::HitCount( CRetriever & )
{
    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::Rank, public
//
//  Returns:    MaxRank (default)
//
//  History:    01-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

LONG CXpr::Rank( CRetriever & )
{
    return( MAX_QUERY_RANK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::ValueType, public
//
//  Returns:    Default value type (PTNone).
//
//  History:    26-Nov-91   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG CXpr::ValueType() const
{
    return( VT_EMPTY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::Clone(), public
//
//  Returns:    A new copy of the expression.
//
//  Signals:    ???
//
//  History:    11-Dec-91   KyleP       Created.
//
//  Notes:      This must be subclassed by every node type which will
//              actually be cloned.
//
//----------------------------------------------------------------------------

CXpr * CXpr::Clone()
{
    //
    // It is illegal to clone an expression which hasn't over-ridden this.
    //

    Win4Assert( 0 );

    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::IsLeaf, public
//
//  Synopsis:   Determines if an expression is a leaf node.
//
//  Returns:    TRUE for this default implementation.
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CXpr::IsLeaf() const
{
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::GetValue, public
//
//  Synopsis:   Calculates the value of the expression for the current object.
//
//  Arguments:  [obj] -- Objects table.  Positioned to current object.
//              [p]   -- Buffer to store value.
//              [pcb] -- On input, size of p, on output, return size if
//                       successful, else required size.
//
//  Returns:    GVRNotSupported for this default implementation.
//
//  History:    11-Dec-91   KyleP       Created.
//
//  Notes:      This is a virtual method of CXpr to make it a simple
//              transformation to allow *any* expression to return a
//              value instead of just property value expressions.
//
//----------------------------------------------------------------------------

GetValueResult CXpr::GetValue(CRetriever &, PROPVARIANT *, ULONG *)
{
    return( GVRNotSupported );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\query\xpr\xlatstat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       XlatStat.cxx
//
//  Contents:   State translation class.
//
//  Classes:    CXlatState
//
//  History:    01-20-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xlatstat.hxx>

#include "stateset.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::CXlatState, public
//
//  Synopsis:   Initialize state translator (no states)
//
//  Arguments:  [MaxState] -- Largest ordinal of any state that may
//                            appear in an equivalence class.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatState::CXlatState( UINT MaxState )
        : _cUsed( 0 ),
          _pulStates( 0 ),
          _cStates( 0 )
{
    //
    // Compute the number of DWords / state, assuring at least 1 dword is
    // always allocated.
    //

    _StateSize = (MaxState + sizeof(ULONG) * 8 ) / (sizeof( ULONG ) * 8);
    _Realloc();
};

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::~CXlatState, public
//
//  Synopsis:   Destroys class.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatState::~CXlatState()
{
    delete _pulStates;
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::XlatToOne, public
//
//  Synopsis:   Maps a state set to its single state equivalent. If
//              there is no mapping, then one is created.
//
//  Arguments:  [ss] -- State set to search for.
//
//  Returns:    The single state equivalent.
//
//  History:    20-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CXlatState::XlatToOne( CStateSet const & ss )
{
    UINT state = _Search( ss );

    if ( state == 0 )
    {
        state = _Create( ss );
    }

    return( state );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::XlatToMany, public
//
//  Synopsis:   Maps a state to its matching state set.
//
//  Arguments:  [iState] -- State to map.
//              [ss]     -- On return contains the mapped state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatState::XlatToMany( UINT iState, CStateSet & ss )
{
    if ( iState > _cUsed )
    {
        vqAssert( FALSE ); 
        return;     // Don't know about this state.
    }

    ULONG * pState = _pulStates + iState * _StateSize;

    for ( int i = _StateSize * sizeof(ULONG) * 8 - 1; i >= 0; i-- )
    {
        if ( pState[i / (sizeof(ULONG) * 8) ] &
                ( 1L << i % (sizeof(ULONG) * 8 ) ) )
        {
            ss.Add( i+1 );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Search, private
//
//  Arguments:  [ss] -- State set to search for.
//
//  Returns:    Single state mapping for [ss] or 0 if none.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      The first state set is used as temp space.
//
//--------------------------------------------------------------------------

UINT CXlatState::_Search( CStateSet const & ss )
{
    memset( _pulStates, 0, _StateSize * sizeof(ULONG) );
    _BuildState( _pulStates, ss );

    UINT cState = 1;

    while ( cState <= _cUsed )
    {
        if ( memcmp( _pulStates + cState * _StateSize,
                     _pulStates,
                     _StateSize * sizeof(ULONG) ) == 0 )
        {
            return( cState );
        }
        else
        {
            ++cState;
        }
    }

    return( 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Create, private
//
//  Synopsis:   Adds new state set to array.
//
//  Arguments:  [ss] -- State set to add.
//
//  Returns:    Single state mapping for [ss]
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CXlatState::_Create( CStateSet const & ss )
{
    //
    // _cStates-1 because the first state is temp space.
    //

    if ( _cStates-1 == _cUsed )
        _Realloc();

    ++_cUsed;
    _BuildState( _pulStates + _cUsed * _StateSize, ss );

    return( _cUsed );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_BuildState, private
//
//  Synopsis:   Formats state set.
//
//  Arguments:  [ss]     -- Format state set...
//              [pState] --   into this memory.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatState::_BuildState( ULONG * pState, CStateSet const & ss )
{
    for ( UINT i = ss.Count(); i > 0; i-- )
    {
        UINT StateNum = ss.State( i ) - 1;
        pState[ StateNum / (sizeof(ULONG) * 8) ] |=
                1L << StateNum % (sizeof(ULONG) * 8);
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Realloc, private
//
//  Synopsis:   Grows state set array.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      Grows linearly, since the number of state sets is likely
//              to be small and we don't want to waste space.
//
//--------------------------------------------------------------------------

void CXlatState::_Realloc()
{
    UINT    oldcStates   = _cStates;
    ULONG * oldpulStates = _pulStates;

    _cStates += 10;
    _pulStates = new ULONG [ _cStates * _StateSize ];

    memcpy( _pulStates,
            oldpulStates,
            oldcStates * _StateSize * sizeof( ULONG ) );

    memset( _pulStates + oldcStates * _StateSize,
            0,
            (_cStates - oldcStates) * _StateSize * sizeof(ULONG) );

    delete [] oldpulStates;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\help\ui\default\makefile.inc ===
createwebconfig: $(UDDIHELPWEBCONFIGFILE)
	copy $(UDDIHELPWEBCONFIGFILE) $(O)\web.config
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\setup\bootstrap\core\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

MISCFILES = \
	01.uddi-org-types.bootstrap.xml			\
	02.v1-canonical.bootstrap.xml			\
	03.v2-canonical.bootstrap.xml			\
	04.uddi-org-general_keywords.bootstrap.xml	\
	05.uddi-org-owningBusiness.bootstrap.xml	\
	06.uddi-org-relationships.bootstrap.xml		\
	07.uddi-org-operators.bootstrap.xml		\
	08.uddi-core-other.bootstrap.xml		\
	09.ms-com-vstudio.bootstrap.xml			\
	04a.ms-com-authmodels.bootstrap.xml		\
	04b.ms-com-extensions.bootstrap.xml		\
	04c.ms-com.catbrowse.bootstrap.xml		

BINPLACE_PLACEFILE=..\placefil.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\setup\bootstrap\core\makefile.inc ===
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the components of NT OS/2
#
!INCLUDE $(NTMAKEENV)\makefile.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\addwebreference\makefile.inc ===
foo.cs:
	..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\addwebreference\addwebreference.cs ===
using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Data;
using System.Globalization;
using System.Collections.Specialized;

using UDDI.Web;
using UDDI.API;
using UDDI.API.Service;
using UDDI.API.Business;

namespace UDDI.VisualStudio
{		
	/// <summary>
	/// This class represents the default page that is displayed in the Add Web Reference
	/// Dialog in Visual Studio .NET.  This page will display the inital search options to 
	/// the user.
	/// </summary>
	public class AddWebReferencePage : Page
	{	
		//
		// These controls are bound to elements on our .aspx page.  We do not need to instantiate
		// these objects, ASP.NET will assign values to them for us.
		// 
		protected UddiButton			     aspnet_searchByService;
		protected UddiButton			     aspnet_searchByProvider;
		protected UddiButton				 aspnet_searchFromBrowse;		
		protected UddiButton				 aspnet_cancelBrowse;
		protected UddiTextBox			     aspnet_serviceName;
		protected UddiTextBox			     aspnet_providerName;
		protected Label				     aspnet_serviceErrorMessage;		
		protected Label				     aspnet_providerErrorMessage;		
		protected Label					 aspnet_noCategoriesMessage;
		protected HelpLinkControl		 aspnet_helpLink;
		protected HtmlGenericControl	 html_browseSearchButtons;
		protected HtmlGenericControl	 html_searchButtons;
		protected CategoryBrowserControl uddi_categoryBrowser;		
				
		/// <summary>
		/// Event handler for the aspnet_searchByService button click.
		/// </summary>
		/// <param name="sender">Passed by ASP.NET, we don't use it.</param>
		/// <param name="args">Passed by ASP.NET, we don't use it.</param>
		public void SearchByService_Click( object sender, EventArgs args )
		{			
			//
			// We are searching by service name.  Make sure we have a name first.
			// 
			string searchName = aspnet_serviceName.Text;

			if( null == searchName || searchName.Equals( string.Empty ) || searchName.Length == 0 )
			{
				ShowErrorMessage( SearchType.SearchByService );
			}
			else
			{					
				string url = string.Format( "search.aspx?{0}={1}&{2}={3}",  StateParamNames.SearchType, 
																			(int)SearchType.SearchByService,
																			StateParamNames.SearchParams,
																			Server.UrlEncode( searchName ) );		

				Response.Redirect( url );
			}		
		}
		
		/// <summary>
		/// Event handler for the aspnet_searchByProvider button click.
		/// </summary>
		/// <param name="sender">Passed by ASP.NET, we don't use it.</param>
		/// <param name="args">Passed by ASP.NET, we don't use it.</param>
		public void SearchByProvider_Click( object sender, EventArgs args )
		{
			//
			// We are searching by business name.  Make sure we have a name first.
			// 
			string searchName = aspnet_providerName.Text;
			if( null == searchName || searchName.Equals( string.Empty ) || searchName.Length == 0 )
			{
				ShowErrorMessage( SearchType.SearchByProvider );
			}
			else
			{	
				string url = string.Format( "search.aspx?{0}={1}&{2}={3}",  StateParamNames.SearchType, 
																			(int)SearchType.SearchByProvider,
																			StateParamNames.SearchParams,
																			Server.UrlEncode( searchName ) );		
				Response.Redirect( url );
			}
		}

		private void SearchFromBrowse_Click( object sender, EventArgs args )
		{																		
			string searchID = ( string ) ViewState[ StateParamNames.SearchID ];
			string url = string.Format( "search.aspx?{0}={1}&{2}={3}&{4}={5}",  StateParamNames.SearchType, 
																				(int)SearchType.SearchFromBrowse,
																				Server.UrlEncode( StateParamNames.TModelKey ),
																				Server.UrlEncode( uddi_categoryBrowser.TModelKey ), 
																				StateParamNames.KeyValue,
																				Server.UrlEncode( uddi_categoryBrowser.KeyValue ) );
			Response.Redirect( url );
		}

		/// <summary>
		/// Displays an error message to the user.
		/// </summary>
		/// <param name="searchType">The type of search determines what message to show.</param>
		private void ShowErrorMessage( SearchType searchType )
		{
			switch( searchType )
			{
				case SearchType.SearchByService:
				{					
					aspnet_serviceErrorMessage.Text    = Localization.GetString( "AWR_SEARCH_SERVICE_ERROR" );
					aspnet_serviceErrorMessage.Visible = true;
					break;
				}
				case SearchType.SearchByProvider:
				{					
					aspnet_providerErrorMessage.Text    = Localization.GetString( "AWR_SEARCH_PROVIDER_ERROR" );
					aspnet_providerErrorMessage.Visible = true;

					break;
				}						
			}
		}
		
		protected void CancelBrowse_Click( object sender, EventArgs args )
		{	
			string searchID = ViewState[ StateParamNames.SearchID ] as string;			
			
			if( null != searchID && searchID.Length > 0 )
			{
				SessionCache.Discard( searchID );
			}
			Response.Redirect( "default.aspx" );
		}

		protected override void OnLoad( EventArgs args )
		{
			//
			// Whenever we load this page, we want to make sure our session state is cleared out and that
			// the default search options are visible.
			Session.Clear();

			//
			// Reset the state of our search and browse buttons
			//
			html_searchButtons.Visible       = true;
			html_browseSearchButtons.Visible = false;
			
			//
			// Set our help link based on the current culture.
			//
			// -- this control is not localizable, replacing with localizable version
			//aspnet_helpLink.NavigateUrl = string.Format(@"javascript:OnNavigate('{0}/addwebreference/{1}/help.htm')", Request.ApplicationPath, CultureInfo.CurrentCulture.TwoLetterISOLanguageName );				
			aspnet_helpLink.NavigateUrl = string.Format(@"javascript:OnNavigate('{0}/addwebreference/{1}/help.htm')", Request.ApplicationPath, Localization.GetCulture().LCID );				
			
			// We don't use the CacheObject, but the CategoryBrowser control won't work unless this object
			// is properly instantiated.
			//
			CacheObject cacheObject;

			if( !this.IsPostBack )
			{								
				string searchID = Guid.NewGuid().ToString();
				ViewState[ StateParamNames.SearchID ] = searchID;

				cacheObject  = new CacheObject();

				cacheObject.FindBusiness               = new FindBusiness();
				cacheObject.FindBusiness.CategoryBag   = new KeyedReferenceCollection();
				cacheObject.FindBusiness.IdentifierBag = new KeyedReferenceCollection();
				cacheObject.FindBusiness.TModelBag     = new StringCollection();

				cacheObject.FindService             = new FindService();
				cacheObject.FindService.CategoryBag = new KeyedReferenceCollection();
				cacheObject.FindService.TModelBag   = new StringCollection();

				cacheObject.FindTModel	             = new UDDI.API.ServiceType.FindTModel();
				cacheObject.FindTModel.CategoryBag   = new KeyedReferenceCollection();
				cacheObject.FindTModel.IdentifierBag = new KeyedReferenceCollection();
				
				SessionCache.Save( searchID, cacheObject );						
			}
			else
			{
				// 
				// Get our search ID
				//
				string searchID = ( string ) ViewState[ StateParamNames.SearchID ];

				cacheObject = SessionCache.Get( searchID );

				//
				// We want to peek in the ASP.NET event pipeline to see if the CategoryBrowser has been invoked.  If it
				// has, then we want to hide the rest of the search page.  The reason is that the CategoryBrowser control
				// can't be redirected to another page, so we want to give the appearance that its on a dedicated page.
				//
				if( null != Request[ "__EVENTTARGET" ] && Request[ "__EVENTTARGET" ].Length > 0 )
				{
					html_searchButtons.Visible       = false;
					html_browseSearchButtons.Visible = true;		
				}				
			}

			//
			// A null cacheObject at this point is a fatal error because we can't initialize our CategoryBrowser
			// without it.
			//
			if( null == cacheObject )
			{
				Response.Redirect( "error.aspx" );				
			}
			
			uddi_categoryBrowser.Initialize( new KeyedReferenceCollection(), cacheObject );			
			uddi_categoryBrowser.ShowNoCategoriesMessage = false;			
		}

		/// <summary>
		/// This is our last chance to manipulate the page.  All we want to do is see if our category browser is going to
		/// show any taxonomies.  If it isn't, we'll output a message instead of an empty control.
		/// </summary>
		/// <param name="args"></param>
		protected override void OnPreRender( EventArgs args )
		{				
			//
			// If we are not in a postback, and there are no taxonomies being shown,
			// display a message
			//
			if( 0 == uddi_categoryBrowser.TaxonomyCount && !IsPostBack )
			{
				aspnet_noCategoriesMessage.Text    = Localization.GetString( "AWR_NO_CATEGORIES" );
				aspnet_noCategoriesMessage.Visible = true;
				uddi_categoryBrowser.Visible       = false;
			}
			
			//
			// Only enable our search button if we are looking at a categorization scheme that is
			// valid for categorization.
			//
			string taxonomyID = uddi_categoryBrowser.TaxonomyID;
			string tModelKey  = uddi_categoryBrowser.TModelKey;
			string keyValue   = uddi_categoryBrowser.KeyValue;

			if( null != taxonomyID && taxonomyID.Length > 0 && 
				null != keyValue && keyValue.Length > 0		&&
				Taxonomy.IsValidForClassification( Convert.ToInt32( taxonomyID ), keyValue ) )
			{
				aspnet_searchFromBrowse.Enabled = true;
			}
			else
			{
				aspnet_searchFromBrowse.Enabled = false;
			}
	
			base.OnPreRender( args );
		}

		/// <summary>
		/// Override OnInit to set up our event handlers 
		/// </summary>
		/// <param name="args">Passed by ASP.NET, we dont' use it.</param>		
		protected override void OnInit( EventArgs args )
		{			
			//
			// Hook up our event handlers
			//			
			aspnet_searchByService.Click  += new EventHandler( SearchByService_Click );
			aspnet_searchByProvider.Click += new EventHandler( SearchByProvider_Click );
			aspnet_searchFromBrowse.Click += new EventHandler( SearchFromBrowse_Click );
			aspnet_cancelBrowse.Click	  += new EventHandler( CancelBrowse_Click );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\addwebreference\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("uddi.addwebreference.dll")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly:PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile( "" )]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\addwebreference\visualstudio.cs ===
using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Data;
using System.Collections.Specialized;

using UDDI.API;
using UDDI.API.Service;
using UDDI.API.Business;

namespace UDDI.VisualStudio
{		
	internal struct StateParamNames
	{
		public static string SearchID		= "searchID";		
		public static string SearchType		= "searchType";
		public static string TModelKey		= "tModelKey";
		public static string ServiceKey		= "serviceKey";
		public static string SearchParams   = "searchParams";
		public static string CacheObject    = "cacheObject";
		public static string Results		= "results";
		public static string CurrentPage	= "currentPage";
		public static string KeyValue		= "keyValue";
	}

	internal struct Constants
	{
		//
		// Number of results to show per page
		//
		public static int NumResultsPerPage = 3;
		public static int MaxPagesToShow	= 5;
	}

	public enum SearchType
	{
		SearchByService   = 0,
		SearchByProvider  = 1,
		SearchFromBrowse  = 2,		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("uddi.api.dll")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly:PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\address.cs ===
/// ************************************************************************
///   Microsoft UDDI version 2.0
///   Copyright (c) 2000-2001 Microsoft Corporation
///   All Rights Reserved
/// ------------------------------------------------------------------------
///   <summary>
///   </summary>
/// ************************************************************************
/// 

using System;
using System.Data;
using System.Collections;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API.Business
{
	/// ********************************************************************
	///   public class Address
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class Address 
	{
		//
		// Attribute: useType
		//		
		[XmlAttribute( "sortCode" )]
		public string SortCode;

		//
		// Attribute: useType
		//
		[XmlAttribute( "useType" )]
		public string UseType;

		//
		// Attribute: tModelKey
		//
		[XmlAttribute( "tModelKey" )]
		public string TModelKey;
		
		// 
		// Element: addressLines
		//
		private AddressLineCollection addressLines;
		
		[XmlElement( "addressLine" )]
		public AddressLineCollection AddressLines
		{
			get
			{
				if( null == addressLines )
					addressLines = new AddressLineCollection();

				return addressLines;
			}

			set { addressLines = value; }
		}
		
		/// ****************************************************************
		///   public Address [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public Address()
		{					
		}

		/// ****************************************************************
		///   public Address [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="sortCode">
		///   </param>
		///   
		///   <param name="useType">
		///   </param>
		///   
		///   <param name="tModelKey">
		///   </param>
		/// ****************************************************************
		/// 
		public Address( string sortCode, string useType, string tModelKey )
		{
			this.SortCode = sortCode;
			this.UseType = useType;
			this.TModelKey = tModelKey;
		}

		/// ****************************************************************
		///   public Address [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="sortCode">
		///   </param>
		///   
		///   <param name="useType">
		///   </param>
		/// ****************************************************************
		/// 
		public Address( string sortCode, string useType )
			: this( sortCode, useType, null )
		{
		}

		internal void Validate()
		{
			Debug.Enter();
			
			Utility.ValidateLength( ref UseType, "useType", UDDI.Constants.Lengths.UseType );
			Utility.ValidateLength( ref SortCode, "sortCode", UDDI.Constants.Lengths.SortCode );
			Utility.ValidateLength( ref TModelKey, "tModelKey", UDDI.Constants.Lengths.TModelKey );

			//
			// Verify that if the address is adorned with a tModelKey, each
			// of the address lines specifies a key name and value.
			//
			if( null != TModelKey )
			{
				if( Utility.StringEmpty( TModelKey ) )
				{
					//
					// trying to save a business with empty tModelKey attribute 
					// in the address element should return E_invalidKeyPassed
					//
					throw new UDDIException( 
						ErrorType.E_invalidKeyPassed, 
						"UDDI_ERROR_INVALIDKEYPASSED_ADDRESS_BLANKTMODELKEY" );
				}
				else
				{
					foreach( AddressLine addressLine in AddressLines )
					{
						if( Utility.StringEmpty( addressLine.KeyName ) || 
							Utility.StringEmpty( addressLine.KeyValue ) )
						{
							throw new UDDIException( 
								ErrorType.E_fatalError, 
								"UDDI_ERROR_FATALERROR_ADDRESS_MISSINGKEYNAMEKEYVALUE" );
						}
					}

					//
					// call net_key_validate
					//
					SqlCommand cmd = new SqlCommand( "net_key_validate", ConnectionManager.GetConnection() );
				
					cmd.Transaction = ConnectionManager.GetTransaction();
					cmd.CommandType = CommandType.StoredProcedure;			
				
					cmd.Parameters.Add( new SqlParameter( "@entityTypeID", SqlDbType.TinyInt ) ).Direction = ParameterDirection.Input;
					cmd.Parameters.Add( new SqlParameter( "@entityKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			
					SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
					//
					// TODO: Need enumeration for the entityTypeID
					//
					paramacc.SetInt( "@entityTypeID", 0 );
					paramacc.SetGuidFromKey( "@entityKey", TModelKey );

					cmd.ExecuteNonQuery();
				}
			}

			AddressLines.Validate();

			Debug.Leave();			
		}
		
		public void Get( long addressID )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_address_addressLines_get";

			sp.Parameters.Add( "@addressID", SqlDbType.BigInt );
		    sp.Parameters.SetLong( "@addressID", addressID );
 
			//
			// Run the stored procedure
			//
			SqlDataReaderAccessor reader = sp.ExecuteReader();
			
			try
			{
				if( 1 == Context.ApiVersionMajor )
				{
					while( reader.Read() )
						AddressLines.Add( reader.GetString( "addressLine" ) );
				}
				else
				{
					while( reader.Read() )
					{
						AddressLines.Add(
							reader.GetString( "addressLine" ),
							reader.GetString( "keyName" ),
							reader.GetString( "keyValue" ) );
					}
				}
			}
			finally
			{
				reader.Close();
			}
		}

		public void Save( long contactID )
		{
			Debug.Enter();
			
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_contact_address_save";

			sp.Parameters.Add( "@contactID", SqlDbType.BigInt );
			sp.Parameters.Add( "@sortCode", SqlDbType.NVarChar, UDDI.Constants.Lengths.SortCode );
			sp.Parameters.Add( "@useType", SqlDbType.NVarChar, UDDI.Constants.Lengths.UseType );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@addressID", SqlDbType.BigInt, ParameterDirection.Output );

			sp.Parameters.SetLong( "@contactID", contactID );
			sp.Parameters.SetString( "@sortCode", SortCode );
			sp.Parameters.SetString( "@useType", UseType );
			sp.Parameters.SetGuidFromKey( "@tModelKey", TModelKey );

			sp.ExecuteNonQuery();

			long addressID = sp.Parameters.GetLong( "@addressID" );

			//
			// Call save on individual address line instances
			//
			AddressLines.Save( addressID );
			
			Debug.Leave();
		}
	}
	
	/// ********************************************************************
	///   public class AddressCollection
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class AddressCollection : CollectionBase
	{
		internal void Validate()
		{
			//
			// Walk collection and call Validate on individual address 
			// instances.
			//
			foreach( Address address in this )
				address.Validate();
		}
		
		public void Save( long contactID )
		{
			//
			// Walk collection and call save on individual address
			// instances.
			//
			foreach( Address address in this )
				address.Save( contactID );
		}
		
		public void Get( long contactID )
		{
			ArrayList addressIDs = new ArrayList();
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_contact_addresses_get" );

			sp.Parameters.Add( "@contactID", SqlDbType.BigInt );
			sp.Parameters.SetLong( "@contactID", contactID );

			SqlDataReaderAccessor reader = sp.ExecuteReader();
			
			try
			{
				addressIDs = Read( reader );
			}
			finally
			{
				reader.Close();
			}

			Populate( addressIDs );

#if never
			ArrayList addressIDs = new ArrayList();
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_contact_addresses_get";

			sp.Parameters.Add( "@contactID", SqlDbType.BigInt );
			sp.Parameters.SetLong( "@contactID", contactID );

			SqlDataReaderAccessor reader = sp.ExecuteReader();
			
			try
			{
				if( 1 == Context.ApiVersionMajor )
				{
					while( reader.Read() )
					{
						addressIDs.Add( reader.GetLong( "addressID" ) );
						Add( reader.GetString( "sortCode" ), reader.GetString( "useType" ) );
					}
				}
				else
				{
					while( reader.Read() )
					{
						addressIDs.Add( reader.GetLong( "addressID" ) );
						Add( reader.GetString( "sortCode" ), reader.GetString( "useType" ), reader.GetKeyFromGuid( "tModelKey" ) );
					}
				}
			}
			finally
			{
				reader.Close();
			}

			//
			// Retrieve the addressLines for this address
			//
			int index = 0;

			foreach( Address address in this )
			{
				address.Get( (long)addressIDs[ index ] );
				index ++;
			}
#endif
		}

		public ArrayList Read( SqlDataReaderAccessor reader )
		{
			ArrayList addressIDs = new ArrayList();

			if( 1 == Context.ApiVersionMajor )
			{
				while( reader.Read() )
				{
					addressIDs.Add( reader.GetLong( "addressID" ) );
					Add( reader.GetString( "sortCode" ), reader.GetString( "useType" ) );
				}
			}
			else
			{
				while( reader.Read() )
				{
					addressIDs.Add( reader.GetLong( "addressID" ) );
					Add( reader.GetString( "sortCode" ), reader.GetString( "useType" ), reader.GetKeyFromGuid( "tModelKey" ) );
				}
			}

			return addressIDs;
		}

		public void Populate( ArrayList addressIDs )
		{
			//
			// Retrieve the addressLines for this address
			//
			int index = 0;
			foreach( Address address in this )
			{
				address.Get( (long)addressIDs[ index ] );
				index ++;
			}
		}

		public Address this[ int index ]
		{
			get 
			{ return ( Address)List[index]; }
			set 
			{ List[ index ] = value; }
		}

		public int Add( string sortCode, string useType  )
		{
			return List.Add( new Address( sortCode, useType  ) );
		}

		public int Add( string sortCode, string useType, string tModelKey )
		{
			return List.Add( new Address( sortCode, useType, tModelKey ) );
		}

		public int Add( Address value )
		{
			return List.Add( value );
		}

		public void Insert( int index, Address value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( Address value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( Address value )
		{
			return List.Contains( value );
		}

		public void Remove( Address value )
		{
			List.Remove( value );
		}

		public void CopyTo( Address[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}

	/// ********************************************************************
	///   public class AddressLine
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class AddressLine
	{
		//
		// Attribute: keyName
		//
		[XmlAttribute( "keyName" )]
		public string KeyName;

		//
		// Attribute: keyValue
		//
		[XmlAttribute( "keyValue" )]
		public string KeyValue;

		//
		// InnerText
		//
		[XmlText]
		public string Value;
		
		public AddressLine()
		{
		}

		public AddressLine( string addressLine )
			: this( addressLine, null, null )
		{
		}

		public AddressLine( string addressLine, string keyName, string keyValue )
		{
			this.Value = addressLine;
			this.KeyName = keyName;
			this.KeyValue = keyValue;
		}

		internal void Validate()
		{
			Utility.ValidateLength( ref Value, "addressLine", UDDI.Constants.Lengths.AddressLine );
			Utility.ValidateLength( ref KeyName, "keyName", UDDI.Constants.Lengths.KeyName );
			Utility.ValidateLength( ref KeyValue, "keyValue", UDDI.Constants.Lengths.KeyValue );
		}

		public void Save( long addressID )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_address_addressLine_save";

			sp.Parameters.Add( "@addressID", SqlDbType.BigInt );
			sp.Parameters.Add( "@addressLine", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine );
			sp.Parameters.Add( "@keyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyName );
			sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );

			sp.Parameters.SetLong( "@addressID", addressID );
			sp.Parameters.SetString( "@addressLine", Value );
			sp.Parameters.SetString( "@keyName", KeyName );
			sp.Parameters.SetString( "@keyValue", KeyValue );

			sp.ExecuteNonQuery();
		}
	}

	/// ********************************************************************
	///   public class AddressLineCollection
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class AddressLineCollection : CollectionBase
	{
		internal void Validate()
		{
			//
			// Walk the collection and call Validate on each individual 
			// address line.
			//
			foreach( AddressLine addressLine in this )
				addressLine.Validate();
		}
		
		public void Save( long addressID )
		{
			//
			// Walk the collection and save each individual address
			// line.
			//
			foreach( AddressLine addressLine in this )
				addressLine.Save( addressID );
		}

		public void Get( long addressID )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_address_addressLines_get";

			sp.Parameters.Add( "@addressID", SqlDbType.BigInt );
			sp.Parameters.SetLong( "@addressID", addressID );

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				while( reader.Read() )
				{
					Add(
						reader.GetString( "addressLine" ),
						reader.GetString( "keyName" ),
						reader.GetString( "keyValue" ) );
				}
			}
			finally
			{
				reader.Close();
			}
		}

		public AddressLine this[ int index ]
		{
			get 
			{ return (AddressLine)List[index]; }
			set 
			{ List[ index ] = value; }
		}

		public int Add( string addressLine, string keyName, string keyValue )
		{
			return List.Add( new AddressLine( addressLine, keyName, keyValue ) );
		}

		public int Add( string addressLine )
		{
			return List.Add( new AddressLine( addressLine ) );
		}

		public int Add( AddressLine addressLine )
		{
			return List.Add( addressLine );
		}

		public void Insert( int index, AddressLine addressLine )
		{
			List.Insert( index, addressLine );
		}

		public int IndexOf( AddressLine addressLine )
		{
			return List.IndexOf( addressLine );
		}

		public bool Contains( AddressLine addressLine )
		{
			return List.Contains( addressLine );
		}

		public void Remove( AddressLine addressLine )
		{
			List.Remove( addressLine );
		}

		public void CopyTo( AddressLine[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\addwebreference\paging.cs ===
using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Data;
using System.Collections;
using System.Collections.Specialized;

namespace UDDI.VisualStudio
{			
	internal struct PageInfo
	{ 
		public PageInfo( bool showEllipses, bool isCurrentPage, int pageNumber )
		{
			this.showEllipses  = showEllipses;
			this.isCurrentPage = isCurrentPage;
			this.pageNumber    = pageNumber;
		}

		public bool showEllipses;
		public bool isCurrentPage;
		public int  pageNumber;		
	}

	
	internal class PagingRenderer
	{
		private ArrayList pageRange;
		private int       numResults;
		private int       currentPage;
		private string	  parentUrl;

		public PagingRenderer( int numResults, int currentPage, string parentUrl )
		{
			this.numResults  = numResults;
			this.currentPage = currentPage;
			this.parentUrl	 = parentUrl;

			pageRange = new ArrayList();

			//
			// Get the number of pages of results we have
			//
			int numPages = ( int ) Math.Ceiling( ( double ) Decimal.Divide( ( Decimal )numResults, ( Decimal )Constants.NumResultsPerPage ) );
							
			//
			// Start our loop at the current page.  Add the current page, the move forward adding pages.  We will keep adding
			// pages until we have added the number of pages specified by Constants.MaxPagesToShow or we run out of pages to add.			
			// If we have more pages to add after we reach Constants.MaxPagesToShow, we'll start working our way back from the current
			// page.
			//
			int forwardIndex  = 0;
			int backIndex     = currentPage - 1;			
			int numPagesAdded = 0;

			while( numPagesAdded < Constants.MaxPagesToShow && numPagesAdded < numPages)
			{	
				if( currentPage + forwardIndex <= numPages )
				{
					//
					// The first page added will always be the current page
					//
					pageRange.Add( new PageInfo(false, forwardIndex == 0 , currentPage + forwardIndex ) );
					forwardIndex++;					
				}
				else
				{
					pageRange.Insert( 0, new PageInfo( false, false, backIndex ) );
					backIndex--;
				}				
				numPagesAdded++;
			}
			
			if( pageRange.Count > 0 )
			{
				PageInfo lastPage = ( PageInfo )pageRange[ pageRange.Count - 1];		
				if( lastPage.pageNumber != numPages )
				{
					pageRange.Add( new PageInfo( true, false, lastPage.pageNumber + 1 ) );
				}	

				PageInfo firstPage = ( PageInfo )pageRange[ 0 ];
				if( firstPage.pageNumber != 1 )
				{
					pageRange.Insert( 0, new PageInfo( true, false, firstPage.pageNumber - 1 ) );
				}
			}
		}		

		/// <summary>
		/// This method will render the row of page numbers that link to the pages of our request.  This method assumes it is 
		/// being called in the context of a HTML table.  It will add rows to that table.
		/// </summary>
		/// <param name="writer">Writer to use to write out our HTML.</param>
		public void Render( HtmlTextWriter writer )
		{					
			writer.RenderBeginTag( HtmlTextWriterTag.Table );
			writer.RenderBeginTag( HtmlTextWriterTag.Tr );	

			foreach( PageInfo pageInfo in pageRange )
			{
				if( true == pageInfo.showEllipses )
				{
					writer.RenderBeginTag( HtmlTextWriterTag.Td );	
					RenderEllipses( pageInfo.pageNumber, writer );
					writer.RenderEndTag();
				}
				else
				{					
					writer.RenderBeginTag( HtmlTextWriterTag.Td );			

					if( true == pageInfo.isCurrentPage )
					{
						RenderCurrentPageLink( writer );
					}
					else
					{
						RenderPageLink( pageInfo.pageNumber, writer );
					}
					writer.RenderEndTag();
				}		
			}
			
			writer.RenderEndTag();	
			writer.RenderEndTag();			
		}

		/// <summary>
		/// This method will render a previous or next ellipses in our row of page numbers.  This is done so we can limit the number
		/// of pages to show in that row.
		/// </summary>
		/// <param name="pageNumber">The page number to link the ellipses to.</param>
		/// <param name="writer">Writer to use to write our HTML.</param>
		private void RenderEllipses( int pageNumber, HtmlTextWriter writer)
		{
			string pageLink = string.Format( "{0}?{1}={2}", parentUrl, StateParamNames.CurrentPage, pageNumber );

			pageLink += GetKeyedRefData();

			writer.AddAttribute( HtmlTextWriterAttribute.Href, pageLink );
			writer.RenderBeginTag( HtmlTextWriterTag.A );
			writer.Write( "..." );
			writer.RenderEndTag();
		}

		/// <summary>
		/// This method will render a page number.
		/// </summary>
		/// <param name="pageNumber">Page number to render.</param>
		/// <param name="writer">Writer to use to write our HTML.</param>
		private void RenderPageLink( int pageNumber, HtmlTextWriter writer )
		{
			string pageLink = string.Format( "{0}?{1}={2}",  parentUrl, StateParamNames.CurrentPage, pageNumber );
			
			pageLink += GetKeyedRefData();
			
			writer.AddAttribute( HtmlTextWriterAttribute.Class, "boldBlue" );
			writer.AddAttribute( HtmlTextWriterAttribute.Href, pageLink );
			writer.RenderBeginTag( HtmlTextWriterTag.A );
			writer.Write( pageNumber );
			writer.RenderEndTag();
		}

		/// <summary>
		/// Renders the 'current' page.  This page number will not be a link.		
		/// </summary>
		/// <param name="writer">Writer to use to write our HTML.</param>
		private void RenderCurrentPageLink( HtmlTextWriter writer )
		{
			writer.AddAttribute( HtmlTextWriterAttribute.Class, "A.navbold" );
			writer.RenderBeginTag( HtmlTextWriterTag.Span );
			writer.Write( currentPage );
			writer.RenderEndTag();
		}
		
		private string GetKeyedRefData()
		{
			if( !Utility.StringEmpty( HttpContext.Current.Request[ StateParamNames.TModelKey ] ) )
			{
				string urlext = "&{0}={1}&{2}={3}";
				return string.Format( 
							urlext, 
							StateParamNames.TModelKey,
							HttpContext.Current.Request[ StateParamNames.TModelKey ],
							StateParamNames.KeyValue,
							HttpContext.Current.Request[ StateParamNames.KeyValue ]
						);
				
			}
			else
			{
				return string.Empty;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\addwebreference\results.cs ===
using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Data;
using System.Collections;
using System.Collections.Specialized;

using UDDI.API;
using UDDI.API.ServiceType;
using UDDI.API.Binding;
using UDDI.API.Service;
using UDDI.API.Business;

namespace UDDI.VisualStudio
{			
	//
	// Simple internal class to hold information about a Service.
	//
	internal class ServiceResultInfo
	{
		public string serviceName;
		public string serviceKey;		
	}

	//
	// Simple internal class to hold information about a Business. 
	//
	internal class BusinessResultInfo
	{
		public string businessName;
		public ArrayList serviceResultInfos;

		public BusinessResultInfo()
		{
			serviceResultInfos = new ArrayList();
		}
	}

	/// <summary>
	/// ResultsList is a ASP.NET control that will display the results of our search.
	/// TODO this class does a lot of work, consider moving some of the rendering out into a separate classs
	/// </summary>
	public class ResultsList : UserControl
	{
		//
		// This function is defined in search.aspx.
		//
		private static string EXPAND_JSCRIPT = "toggle(this, '{0}');";		
		private static string PLUS_SRC       = "../images/plus.gif";

		private ArrayList results;
		private int currentPage;
	
		/// <summary>
		/// Use this function to populate a ResultsList instance with raw values from the database.
		/// The results from the database must be returned in the following order:
		/// 
		/// businessName
		/// businessKey
		/// serviceName
		/// serviceKey
		/// 
		/// ParseResults will use indexes to read these values from the SqlDataReaderAccessor so this 
		/// order must be maintained from the database.
		/// </summary>
		/// <param name="values">Reader returned from the database.</param>
		/// <returns></returns>
		public int ParseResults( SqlDataReaderAccessor values )
		{
			results = new ArrayList();

			string currentBusinessName		= null;
			string lastBusinessName			= null;			
			BusinessResultInfo businessInfo = new BusinessResultInfo();
			
			while( values.Read() )
			{		
				currentBusinessName = values.GetString( 0 );			
		
				ServiceResultInfo serviceInfo = new ServiceResultInfo();
				serviceInfo.serviceName       = values.GetString( 2 );
				serviceInfo.serviceKey        = values.GetString( 3 );

				if (null != lastBusinessName && false == lastBusinessName.Equals( currentBusinessName ) )
				{						
					results.Add( businessInfo );		
					businessInfo = new BusinessResultInfo();					
				}	

				businessInfo.businessName = currentBusinessName;
				businessInfo.serviceResultInfos.Add( serviceInfo );

				lastBusinessName = currentBusinessName;				
			}

			//
			// Add our last one.
			//
			if( businessInfo.serviceResultInfos.Count > 0 )
			{
				results.Add( businessInfo );
			}

			return results.Count;
		}
	
		/// <summary>
		/// Overridden from UserControl.  This method will get called when its time to render our control.
		/// </summary>
		/// <param name="writer">Passed in from ASP.NET, use it to write our HTML</param>
		protected override void Render( HtmlTextWriter writer )
		{
			//
			// Figure out our current page and number of results
			//
			try
			{				
				currentPage = Int32.Parse( Request[ StateParamNames.CurrentPage ] );
			}
			catch
			{
				currentPage = 1;
			}

			RenderResults( writer );							
		}
		
		/// <summary>
		/// This method actually does the work of rendering our results.
		/// </summary>
		/// <param name="writer">Passed from Render()</param>
		private void RenderResults( HtmlTextWriter writer )
		{
			//
			// TODO should this be in the PagingControl?
			//
			//
			// Determine the start and end indexes of the results that we'll display.  These values are based
			// on the current page that we are displaying.
			// 
			int startIndex;
			int endIndex;

			GetStartIndex( out startIndex, out endIndex );

			if( endIndex > results.Count )
			{
				endIndex = results.Count;
			}
			
			if( startIndex < endIndex )
			{
				//
				// Render everything in table.
				//							
				writer.AddAttribute( HtmlTextWriterAttribute.Width, "95%" );
				writer.RenderBeginTag( HtmlTextWriterTag.Table );						

				//
				// Render the range of results.
				//
				RenderRange( writer, startIndex, endIndex );	

				//
				// Render our paging information
				// 
				RenderPaging( writer );

				writer.RenderEndTag();	// TABLE
			}
		}
		
		private void RenderPaging( HtmlTextWriter writer )
		{
			writer.RenderBeginTag( HtmlTextWriterTag.Tr );		
			writer.AddAttribute( HtmlTextWriterAttribute.Class, "pagesCell" );
			writer.AddAttribute( HtmlTextWriterAttribute.Colspan, "3");
			writer.RenderBeginTag( HtmlTextWriterTag.Td );							

			PagingRenderer paging = new PagingRenderer( results.Count, currentPage , Request.Path);			
			paging.Render( writer );				

			writer.RenderEndTag();	// Td
			writer.RenderEndTag();	// Tr
		}

		/// <summary>
		/// Renders a range of businesses.
		/// </summary>
		/// <param name="writer">Writer to use to write our HTML.</param>
		/// <param name="startIndex">The beginning of our range of businesses to render.</param>
		/// <param name="endIndex">The end of our range of businesses to render.</param>
		private void RenderRange( HtmlTextWriter writer, int startIndex, int endIndex )
		{
			while( startIndex < endIndex )
			{
				BusinessResultInfo businessResultInfo = ( BusinessResultInfo )results[startIndex];
				
				//
				// Render the business name.
				//
				writer.RenderBeginTag( HtmlTextWriterTag.Tr );
				writer.AddAttribute( HtmlTextWriterAttribute.Colspan, "3" );
				writer.RenderBeginTag( HtmlTextWriterTag.Td );	
				writer.RenderBeginTag( HtmlTextWriterTag.B );
				writer.Write( Server.HtmlEncode( businessResultInfo.businessName ) );
				writer.RenderEndTag();
				writer.RenderEndTag();
				writer.RenderEndTag();
					
				foreach( ServiceResultInfo serviceResultInfo in businessResultInfo.serviceResultInfos )
				{
					writer.RenderBeginTag( HtmlTextWriterTag.Tr );
					
					//
					// Write a placeholder cell so we can indent each service info under its
					// business name.
					//
					writer.AddAttribute( HtmlTextWriterAttribute.Class, "space_cell" );
					writer.RenderBeginTag( HtmlTextWriterTag.Td );						
					writer.Write( "&nbsp;" );	
					writer.RenderEndTag();

					//
					// Render the service.
					//					
					RenderServiceInfo( serviceResultInfo, writer );
					
					writer.RenderEndTag();
				}

				startIndex++;
			}		
		}
		
		/// <summary>
		/// This method renders an individual service.
		/// </summary>
		/// <param name="serviceInfo">The service to render.</param>
		/// <param name="writer">Writer to use to write our HTML.</param>
		private void RenderServiceInfo( ServiceResultInfo serviceInfo, HtmlTextWriter writer )
		{
			//
			// Render a plus/minus tag.  We will use the service key of this service to name
			// our hidden details panel.
			//
			writer.AddAttribute( HtmlTextWriterAttribute.Class, "expand_cell" );
			writer.AddAttribute( HtmlTextWriterAttribute.Align, "center" );
			writer.RenderBeginTag( HtmlTextWriterTag.Td );						
			RenderExpandTag( writer, serviceInfo.serviceKey );
			writer.RenderEndTag();		
		
			//
			// Render the name of the service.  Use the first name that is registered with the service.
			//
			writer.AddAttribute( HtmlTextWriterAttribute.Width, "100%" );
			writer.RenderBeginTag( HtmlTextWriterTag.Td );
			writer.Write( Server.HtmlEncode( serviceInfo.serviceName ) );
			writer.RenderEndTag();					
			writer.RenderEndTag();

			//
			// Render a details panel for the service that is initially hidden.
			//
			writer.AddAttribute( HtmlTextWriterAttribute.Id, serviceInfo.serviceKey );
			writer.AddAttribute( HtmlTextWriterAttribute.Style, "display:none" );																							
			writer.RenderBeginTag( HtmlTextWriterTag.Tr );
			
			//
			// Skip 2 cells
			// 
			writer.RenderBeginTag( HtmlTextWriterTag.Td );		
			writer.RenderEndTag();
			writer.RenderBeginTag( HtmlTextWriterTag.Td );		
			writer.RenderEndTag();

			writer.AddAttribute( HtmlTextWriterAttribute.Id, serviceInfo.serviceKey + "_detailsPanel" );			
			writer.RenderBeginTag( HtmlTextWriterTag.Td );
			RenderServiceDetail( serviceInfo.serviceKey, writer );				
			writer.RenderEndTag();			
		}
		
		/// <summary>
		/// Renders the +/- sign used to show or hide the details of a service.
		/// </summary>
		/// <param name="writer">Writer to use to write our HTML.</param>
		/// <param name="serviceKey">The service key is used to uniquely identify this HTML component.  We need to do this for the script
		/// that is located in search.aspx.
		/// </param>
		private void RenderExpandTag( HtmlTextWriter writer, string serviceKey)
		{			
			string jscript = EXPAND_JSCRIPT.Replace( "{0}", serviceKey );			
			writer.AddAttribute( HtmlTextWriterAttribute.Style, "cursor:hand" );
			writer.AddAttribute( HtmlTextWriterAttribute.Src, ResultsList.PLUS_SRC );
			writer.AddAttribute( HtmlTextWriterAttribute.Onclick, jscript );
			writer.RenderBeginTag( HtmlTextWriterTag.Img );
			writer.RenderEndTag();
		}

		private void RenderServiceDetail( string serviceKey, HtmlTextWriter writer )
		{
			//
			// Get details for this service
			//
			StringCollection serviceKeys =  new StringCollection();
			serviceKeys.Add( serviceKey );

			ServiceDetail serviceDetail = new ServiceDetail();
			serviceDetail.Get( serviceKeys );

			//
			// We will only get the first one
			//			
			BusinessService businessService = serviceDetail.BusinessServices[ 0 ];								
			
			writer.AddAttribute( HtmlTextWriterAttribute.Width, "100%" );
			writer.AddAttribute( HtmlTextWriterAttribute.Class, "serviceDetailOuterTable" );
			writer.RenderBeginTag( HtmlTextWriterTag.Table );
			
			//
			// Render the business descriptions if there is one
			//
			writer.RenderBeginTag( HtmlTextWriterTag.Tr );
			writer.RenderBeginTag( HtmlTextWriterTag.Td );
			writer.RenderBeginTag( HtmlTextWriterTag.B );
			writer.Write( Localization.GetString( "AWR_SERVICE_DESCRIPTION" ) );
			writer.RenderEndTag();		// B
			writer.RenderEndTag();		// Td
			writer.RenderEndTag();		// Tr

			foreach( Description description in businessService.Descriptions )			
			{
				writer.RenderBeginTag( HtmlTextWriterTag.Tr );
				writer.RenderBeginTag( HtmlTextWriterTag.Td );				
				writer.Write( Server.HtmlEncode( description.Value ) );
				writer.RenderEndTag();		// Td
				writer.RenderEndTag();		// Tr
			}
		
			//
			// Render each binding in the service that has a WSDL file associated with it
			//
			writer.RenderBeginTag( HtmlTextWriterTag.Tr );
			writer.RenderBeginTag( HtmlTextWriterTag.Td );
			writer.RenderBeginTag( HtmlTextWriterTag.B );
			writer.Write( Localization.GetString( "AWR_BINDINGS" ) );
			writer.RenderEndTag();		// B
			writer.RenderEndTag();		// Td
			writer.RenderEndTag();		// Tr
			
			foreach( BindingTemplate bindingTemplate in businessService.BindingTemplates )
			{				
				//
				// Render each binding in a row
				//
				writer.RenderBeginTag( HtmlTextWriterTag.Tr );
				writer.RenderBeginTag( HtmlTextWriterTag.Td );
			
				writer.AddAttribute( HtmlTextWriterAttribute.Width, "100%" );	
				writer.AddAttribute( HtmlTextWriterAttribute.Class, "accessPointTable" );
				writer.RenderBeginTag( HtmlTextWriterTag.Table );
				
				//
				// Render the access point
				//
				writer.RenderBeginTag( HtmlTextWriterTag.Tr );
				writer.RenderBeginTag( HtmlTextWriterTag.Td );
				writer.RenderBeginTag( HtmlTextWriterTag.B );
				writer.Write( Localization.GetString( "AWR_ACCESS_POINT" ) );
				writer.RenderEndTag();		// B
				writer.RenderEndTag();		// Td
				writer.RenderEndTag();		// Tr
			
				writer.RenderBeginTag( HtmlTextWriterTag.Tr );
				writer.RenderBeginTag( HtmlTextWriterTag.Td );						
				writer.Write( Server.HtmlEncode( bindingTemplate.AccessPoint.Value ) );
				writer.RenderEndTag();	// Td
				writer.RenderEndTag();	// Tr

				//
				// Render the descriptions.
				//
				writer.RenderBeginTag( HtmlTextWriterTag.Tr );
				writer.RenderBeginTag( HtmlTextWriterTag.Td );
				writer.RenderBeginTag( HtmlTextWriterTag.B );
				writer.Write( Localization.GetString( "AWR_DESCRIPTION" ) );
				writer.RenderEndTag();	// B
				writer.RenderEndTag();	// Td
				writer.RenderEndTag();	// Tr
								
				foreach( Description description in bindingTemplate.Descriptions )
				{
					writer.RenderBeginTag( HtmlTextWriterTag.Tr );
					writer.RenderBeginTag( HtmlTextWriterTag.Td );						
					writer.Write( Server.HtmlEncode( description.Value ) );
					writer.RenderEndTag();	// Td
					writer.RenderEndTag();	// Tr

					//
					// Render an empty row between descriptions
					//
					writer.RenderBeginTag( HtmlTextWriterTag.Tr );
					writer.RenderBeginTag( HtmlTextWriterTag.Td );													
					writer.RenderEndTag();	// Tr
					writer.RenderEndTag();	// Td					
				}
				
				//
				// Render the WSDL files.  We are assuming that any overview doc urls are urls to WSDL files
				//
				writer.RenderBeginTag( HtmlTextWriterTag.Tr );
				writer.RenderBeginTag( HtmlTextWriterTag.Td );
				writer.RenderBeginTag( HtmlTextWriterTag.B );				
				writer.Write( Localization.GetString( "AWR_ID" ) );
				writer.RenderEndTag();	// B
				writer.RenderEndTag();	// Td
				writer.RenderEndTag();	// Tr

				int wsdlCount = 0;

				foreach( TModelInstanceInfo instanceInfo in bindingTemplate.TModelInstanceInfos )
				{
					//
					// Get the tModel related to this instance.
					//
					TModel tModel = new TModel( instanceInfo.TModelKey );
					
					//
					// We don't want any exceptions ruining the rest of our display
					// 
					try
					{
						//
						// Get details for this tModel.
						//
						tModel.Get();
										
						bool isWsdlSpec = false;
						foreach( KeyedReference keyedReference in tModel.CategoryBag )
						{							
							if( true == keyedReference.KeyValue.Equals( UDDI.Constants.UDDITypeTaxonomyWSDLSpecKeyValue ) &&
								true == keyedReference.TModelKey.ToLower().Equals( UDDI.Constants.UDDITypeTaxonomyTModelKey ) )
							{
								isWsdlSpec = true;
								break;
							}
						}

						//
						// If this tModel has an overview doc, then consider that document as the link to the 
						// WSDL file.
						//
						if( true == isWsdlSpec &&
							null != tModel.OverviewDoc.OverviewURL && 
							tModel.OverviewDoc.OverviewURL.Length > 0 )
						{						
							// 
							// Render the WSDL link
							//
							writer.RenderBeginTag( HtmlTextWriterTag.Tr );
							writer.RenderBeginTag( HtmlTextWriterTag.Td );

							// 
							// Render the arrow image.
							//
							writer.AddAttribute( HtmlTextWriterAttribute.Src, "../images/orange_arrow_right.gif" );					
							writer.RenderBeginTag( HtmlTextWriterTag.Img );
							writer.Write("&nbsp;");
							writer.RenderEndTag();	// Img

							//
							// Make the overview URL a hyper link
							//
							writer.AddAttribute( HtmlTextWriterAttribute.Href, tModel.OverviewDoc.OverviewURL );					
							writer.RenderBeginTag( HtmlTextWriterTag.A );
							writer.Write( tModel.OverviewDoc.OverviewURL );
							writer.RenderEndTag();	// A

							//
							// Render the first description if there is one
							//						
							if( tModel.OverviewDoc.Descriptions.Count > 0 )
							{
								writer.Write( "&nbsp;-&nbsp;" );
								writer.Write( tModel.OverviewDoc.Descriptions[0].Value );
							}		
							
							wsdlCount++;

							writer.RenderEndTag();	// Td
							writer.RenderEndTag();	// Tr			
						}		
					}		
					catch
					{
						//
						// Intentionally empty.
						//
					}
				}

				//
				// If there were no WSDL files registered, render a message saying so.
				//
				if( 0 == wsdlCount )
				{									
					writer.RenderBeginTag( HtmlTextWriterTag.Tr );
					writer.RenderBeginTag( HtmlTextWriterTag.Td );
					writer.Write( Localization.GetString( "AWR_NO_WSDLS" ) );
					writer.RenderEndTag();	// Td
					writer.RenderEndTag();	// Tr								
				}
				
				writer.RenderEndTag();	// TABLE
				writer.RenderEndTag();	// Td
				writer.RenderEndTag();	// Tr
			}	
			writer.RenderEndTag();	// TABLE
		}

		/// <summary>
		/// Returns the start index of the result we are supposed to show, taking into account paging.
		/// </summary>
		/// <param name="startIndex">The start index.</param>
		/// <param name="rawEndIndex">The 'raw' end index; that is not taking into account whether this value exceeds the number of pages we have.</param>
		private void GetStartIndex( out int startIndex, out int rawEndIndex )
		{								
			startIndex = ( currentPage - 1) * Constants.NumResultsPerPage;			
			rawEndIndex = startIndex + Constants.NumResultsPerPage;			
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\addwebreference\search.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Collections;

using UDDI.Web;
using UDDI.API;
using UDDI.API.Service;
using UDDI.API.Business;

namespace UDDI.VisualStudio
{	
	//
	// Just a simple class to help us keep track of our results.
	//
	public class ResultsCache
	{
		public ResultsCache()
		{}

		public ResultsCache( SearchType searchType, string searchParams )
		{  
			this.searchType    = searchType;
			this.searchParams  = searchParams;			
		}

		public string		searchParams;
		public SearchType	searchType;		
		public int			numResults;
	}

	public class SearchPage : Page
	{
		//
		// These controls are bound to elements on our .aspx page.  We do not need to instantiate
		// these objects, ASP.NET will assign values to them for us.
		// 
		protected HtmlGenericControl html_hasResultsLabel;
		protected HtmlGenericControl html_noResultsLabel;
		protected HtmlGenericControl html_searchResultsMsg;
		protected HtmlGenericControl html_browseResultsMsg;
		protected HtmlGenericControl html_hasResultsMsg;
		protected ResultsList        uddi_resultsList;
				
		//
		// These values will be displayed in search.aspx using <%= tags
		// 
		protected ResultsCache results;
		
		/// <summary>
		/// Override OnLoad to do our initialization.
		/// </summary>
		/// <param name="args">Passed by ASP.NET, we don't use it.</param>
		protected override void OnLoad( EventArgs args )
		{			
			//
			// See if we already have a cached search, if we do, we'll use it.  We only cache search params, 
			// result count and the search type, we'll get values from our database all the time.
			// 
			results = Session[ StateParamNames.Results ] as ResultsCache;		
	
			//
			// If we don't have search results, get them
			// 
			if( null == results )
			{				
				//
				// Instantiate our results cache
				//
				results = new ResultsCache();

				//
				// Run our query based on the search type and display the results
				//
				string temp = Request[ StateParamNames.SearchType ];
				if( null == temp || temp.Length == 0 )
				{
					Response.Redirect( "error.aspx" );
				}		
		
				results.searchType = ( SearchType ) Int32.Parse( temp );	

				if( results.searchType == SearchType.SearchByService || results.searchType == SearchType.SearchByProvider )
				{
					results.searchParams = GetSearchParams();
				}
			}
			
			//
			// Search type determines what sproc to run.
			//
			SqlStoredProcedureAccessor	searchCommand = new SqlStoredProcedureAccessor();
			switch( results.searchType )
			{
				case SearchType.SearchByService:
				{						
					searchCommand.ProcedureName = "VS_AWR_services_get";
					searchCommand.Parameters.Add( "@serviceName", SqlDbType.NVarChar, 450 );
					searchCommand.Parameters.SetString( "@serviceName", results.searchParams );

					break;
				}
				case SearchType.SearchByProvider:
				{							
					searchCommand.ProcedureName = "VS_AWR_businesses_get";
					searchCommand.Parameters.Add( "@businessName", SqlDbType.NVarChar, 450 );
					searchCommand.Parameters.SetString( "@businessName", results.searchParams );

					break;
				}
				case SearchType.SearchFromBrowse:
				{									
					searchCommand.ProcedureName = "VS_AWR_categorization_get";
					searchCommand.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
					searchCommand.Parameters.Add( "@keyValue",	SqlDbType.NVarChar, 255 );

					searchCommand.Parameters.SetGuidFromString( "@tModelKey", GetTModelKey() );
					searchCommand.Parameters.SetString( "@keyValue", GetKeyValue() );

					break;
				}					
			}

			//
			// Get the results that we are supposed to display.
			//	
			SqlDataReaderAccessor resultsReader = searchCommand.ExecuteReader();
			results.numResults = uddi_resultsList.ParseResults( resultsReader );
			resultsReader.Close();
					
			//
			// Store our results in session state
			//				
			Session[ StateParamNames.Results ] = results;				
					
			DisplaySearchMessages( results.numResults );
		}		

		private void DisplaySearchMessages(int numResults )
		{
			//
			// Depending on whether we have results or not, show or hide the panel that will show our results.
			//
			if( numResults > 0 )
			{				
				if( results.searchType == SearchType.SearchFromBrowse )
				{
					html_browseResultsMsg.Visible = true;
					html_searchResultsMsg.Visible = false;				
				}
				else
				{
					html_browseResultsMsg.Visible = false;
					html_searchResultsMsg.Visible = true;
				}

				html_hasResultsLabel.Visible = true;
				html_noResultsLabel.Visible  = false;
			}
			else
			{
				html_hasResultsLabel.Visible = false;
				html_noResultsLabel.Visible  = true;
			}
		}
	
		private string GetKeyValue()
		{
			string keyValue = Request[ StateParamNames.KeyValue ];
			if( null == keyValue || keyValue.Length == 0 )
			{
				return "%";
			}	

			return Server.UrlDecode( keyValue );
		}

		private string GetTModelKey()
		{
			//
			// Get the tModel key to search on
			//
			string tModelKey = Request[ StateParamNames.TModelKey ];
			if( null == tModelKey || tModelKey.Length == 0 )
			{
				Response.Redirect( "error.aspx" );				
			}	

			return Server.UrlDecode( tModelKey );			
		}

		private string GetSearchParams()
		{
			//
			// Make sure we have search params
			//
			string searchParams = Request[ StateParamNames.SearchParams ];	
			if( null == searchParams || searchParams.Length == 0 )
			{
				Response.Redirect( "error.aspx" );				
			}			

			return searchParams;
		}				
	}
	///**********************************************************************************
	/// <summary>
	///		Class to help manage help link localization.
	/// </summary>
	///**********************************************************************************
	public class HelpLinkControl : UserControl
	{
		
		private string helpstring;
		/// *****************************************************************************
		/// <summary>
		///		Text for the Help Message.
		///
		///		If a localization key is provided, then a the string will be set to the 
		///		Localized value.
		/// </summary>
		/// *****************************************************************************
		public string HelpString
		{
			get{ return helpstring; }
			set
			{ 
				if( Localization.IsKey( (string)value ) )
					helpstring=Localization.GetString( Localization.StripMarkup( (string)value ) );
				else
					helpstring=value; 
			}
		}
		
		private string helplinktext;
		/// *****************************************************************************
		/// <summary>
		///		Text for the Link inside the help Message.
		///
		///		If a localization key is provided, then a the string will be set to the 
		///		Localized value.
		/// </summary>
		/// *****************************************************************************
		public string HelpLinkText
		{
			get{ return helplinktext; }
			set
			{ 
				if( Localization.IsKey( (string)value ) )
					helplinktext=Localization.GetString( Localization.StripMarkup( (string)value ) );
				else
					helplinktext=value; 
			}
		}

		private string navigateurl;
		/// *****************************************************************************
		/// <summary>
		///		Url that the HelpLink will navigate too.
		/// </summary>
		/// *****************************************************************************
		public string NavigateUrl
		{
			get{ return navigateurl; }
			set{ navigateurl=value; }
		}

		private string navigatetarget;
		/// *****************************************************************************
		/// <summary>
		///		Url Target of the Help Link
		/// </summary>
		/// *****************************************************************************
		public string NavigateTarget
		{	
			get{ return navigatetarget; }
			set{ navigatetarget=value; }
		}

		private string cssclass;
		public string CssClass
		{
			get{ return cssclass; }
			set{ cssclass=value; }
		}
		
		/// <summary>
		///		method to write content to the Response Stream
		/// </summary>
		/// <param name="output">Stream to write output too.</param>
		protected override void Render( HtmlTextWriter output )
		{
			UDDI.Diagnostics.Debug.Verify( null!=HelpLinkText,"UDDI_ERROR_FATALERROR_AWR_NULLHELPLINKTEXT" );
			UDDI.Diagnostics.Debug.Verify( null!=HelpString,"UDDI_ERROR_FATALERROR_AWR_NULLHELPSTRING" );


			string hyperlink = "";
			if( null!=NavigateUrl )
			{
				//build the hyperlink.
				hyperlink="<a href=\"" + NavigateUrl + "\"" + 
					((null!=NavigateTarget )?" target=\"" + NavigateTarget + "\" " : "" ) + " >{0}</a>";

				hyperlink = string.Format( hyperlink, HelpLinkText );
			}

			if( null!=CssClass ) //if a stylesheet class was provided add it to the stream to be rendered
				output.AddAttribute( HtmlTextWriterAttribute.Class,CssClass ) ;
			
			output.RenderBeginTag( HtmlTextWriterTag.Span );
			
			//format the help string with the hyperlink string.
			output.Write( HelpString, ((""!=hyperlink)?hyperlink:HelpLinkText ) );
		
			output.RenderEndTag();
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\authentication.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Principal;
using System.Security.Cryptography;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API.Authentication
{
	/// ********************************************************************
	///   public DiscardAuthToken
	/// --------------------------------------------------------------------  
	///   <summary>
	///     Represents a discard_authToken message.
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute("discard_authToken", Namespace=UDDI.API.Constants.Namespace)]
	public class DiscardAuthToken : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		[XmlElement("authInfo")]
		public string AuthInfo = "";
	}

	/// ********************************************************************
	///   public GetAuthToken
	/// --------------------------------------------------------------------  
	///   <summary>
	///     Represents a get_authToken message.
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute("get_authToken", Namespace=UDDI.API.Constants.Namespace)]
	public class GetAuthToken : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}
		
		//
		// Attribute: userID
		//
		[XmlAttribute("userID")]
		public string UserID = "";
		
		//
		// Attribute: cred
		//
		[XmlAttribute("cred")]
		public string Cred = "";
	}		

	/// ********************************************************************
	///   public AuthToken
	/// --------------------------------------------------------------------  
	///   <summary>
	///     Represents an authToken.
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute("authToken", Namespace=UDDI.API.Constants.Namespace)]
	public class AuthToken
	{
		//
		// Attribute: operator
		//
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );

		//
		// Attribute: generic
		//
		[XmlAttribute("generic")]
		public string Generic = Constants.Version;

		//
		// Element: authInfo
		//
		[XmlElement("authInfo")]
		public string AuthInfo;
	}

	public interface IAuthenticator
	{
		bool GetAuthenticationInfo( string userid, string password, out string ticket );
		bool Authenticate( string strTicket, int timeWindow );
	}

	public class WindowsAuthenticator : IAuthenticator
	{
		public bool GetAuthenticationInfo( string userid, string password, out string ticket )
		{
			try
			{
				//
				// Verify that a userid and password were not specifed
				//
				Debug.Verify( Utility.StringEmpty( userid ) && Utility.StringEmpty( password ), "UDDI_ERROR_FATALERROR_USERIDANDPASSINWINAUTH" );

				//
				// This form of authentication requires the impersonation of the caller
				// on the current thread of activity. 
				//

				//
				// The ticket will not be used for this form of authentication
				//
				ticket = "";

				//
				// Setup the user credentials so we can verify that the user is a publisher
				//
				IPrincipal principal = System.Threading.Thread.CurrentPrincipal;
				Context.User.SetRole( principal );
			}
			catch( Exception exception )
			{
				//
				// Log the real exception
				//
				Debug.Write( SeverityType.FailAudit, CategoryType.Authorization, exception.ToString() );				

				//
				// Preserve the error number if it was a UDDIException; but DO NOT preserve the error
				// message.  We want the error message in the log, but not shown to the user for security
				// reasons.
				//
				UDDIException uddiException = exception as UDDIException;
				if( null != uddiException )
				{
					throw new UDDIException( uddiException.Number, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
				else
				{
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
			}
			return true;
		}

		public bool Authenticate( string strTicket, int timeWindow )
		{
			try
			{
				//
				// TODO: Verify strTicket is empty
				//

				//
				// No timeout check is possible for Windows Authentication
				//
				IPrincipal principal = System.Threading.Thread.CurrentPrincipal;
				Context.User.SetRole( principal );
			}
			catch( Exception exception )
			{
				//
				// Log the real exception
				//
				Debug.Write( SeverityType.FailAudit, CategoryType.Authorization, exception.ToString() );				

				//
				// Preserve the error number if it was a UDDIException; but DO NOT preserve the error
				// message.  We want the error message in the log, but not shown to the user for security
				// reasons.
				//
				UDDIException uddiException = exception as UDDIException;
				if( null != uddiException )
				{
					throw new UDDIException( uddiException.Number, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
				else
				{
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
			}
			return true;
		}
	}

	public class UDDIAuthenticator : IAuthenticator
	{
		const string ResetKeyDateFormat = "MM/dd/yyyy HH:mm:ss";

		[DllImport("advapi32.dll", SetLastError=true)]
		public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword, 
			int dwLogonType, int dwLogonProvider, out int phToken);

		private string DomainFromUserID( string userid )
		{
			return userid.Substring( 0, userid.IndexOf( '\\' ) );
		}

		private string BaseUserNameFromUserID( string userid )
		{
			return userid.Substring( userid.IndexOf( '\\' ) + 1 );
		}

		public bool GetAuthenticationInfo( string userid, string password, out string ticket )
		{
			try
			{
				Debug.VerifySetting( "Security.Key" );
				Debug.VerifySetting( "Security.IV" );

				ticket = null;

				//
				// TODO: Need to support UPN formed user names
				//

				//
				// TODO: Need to look at use of this call on Domain controllers
				//

				//
				// The user account must have Log On Locally permission on the local computer. 
				// This permission is granted to all users on workstations and servers, 
				// but only to administrators on domain controllers. 
				//

				//
				// Check userid and password by logging in
				//
				int windowstoken;							// The Windows NT user token.
				string baseName = BaseUserNameFromUserID( userid );
				string domain = DomainFromUserID( userid );

				bool loggedOn = LogonUser( baseName,// User name.
					domain,							// Domain name.
					password,						// Password.
					3,								// Logon type = LOGON32_LOGON_NETWORK
					0,								// Logon provider = LOGON32_PROVIDER_DEFAULT
					out windowstoken );				// The user token for the specified user is returned here.
      
				if( !loggedOn )
				{
					Debug.Write( SeverityType.FailAudit, CategoryType.Authorization, userid + " failed logon. Error code was " + Marshal.GetLastWin32Error().ToString() );
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_LOGINFAILED" );
				}

				WindowsIdentity wi = new WindowsIdentity( new IntPtr( windowstoken ) );
				WindowsPrincipal principal = new WindowsPrincipal( wi );
				Context.User.SetRole( principal );
			
				//
				// Generate the ticket
				//
				MemoryStream strm = new MemoryStream();
				Context.User.Serialize( strm );
				
				//
				// Get a key and initialization vector.
				//
				byte[] key = null;
				byte[] iv =  null;
				GetSecurityPair( out key, out iv );
				
				//
				// Encrypt the ticket information
				//
				MemoryStream strmEncrypted = new MemoryStream();
				EncryptData( strm, strmEncrypted, key, iv );
				ticket = Convert.ToBase64String( strmEncrypted.GetBuffer(), 0, (int) strmEncrypted.Length );	
#if DEBUG
				Debug.Write( SeverityType.Info, CategoryType.Soap, "Ticket Out:----------\n" + ticket );
#endif
			}
			catch( Exception exception )
			{
				//
				// Log the real exception
				//
				Debug.Write( SeverityType.FailAudit, CategoryType.Authorization, exception.ToString() );				

				//
				// Preserve the error number if it was a UDDIException; but DO NOT preserve the error
				// message.  We want the error message in the log, but not shown to the user for security
				// reasons.
				//
				UDDIException uddiException = exception as UDDIException;
				if( null != uddiException )
				{
					throw new UDDIException( uddiException.Number, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
				else
				{
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
			}

			return true;
		}

		public bool Authenticate( string strTicket, int timeWindow )
		{
			try
			{
				Debug.VerifySetting( "Security.Key" );
				Debug.VerifySetting( "Security.IV" );
				Debug.Verify( null != strTicket && strTicket.Length > 0, "UDDI_ERROR_AUTHTOKENREQUIRED_NOTOKENPUBLISHATTEMPT", ErrorType.E_authTokenRequired );
#if DEBUG
				Debug.Write( SeverityType.Info, CategoryType.Soap, "Ticket In:----------\n" + strTicket );
#endif

				//
				// Get a key and initialization vector.
				//
				byte[] key = null;
				byte[] iv =  null;
				GetSecurityPair( out key, out iv );

				//
				// If the ticket cannot be decoded or decrypted throw an E_authTokenRequired
				//
				MemoryStream strm = new MemoryStream();
				try
				{
					byte[] ticket = Convert.FromBase64String( strTicket );

					//
					// Decrypt the ticket into a stream
					//
					MemoryStream strmEncrypted = new MemoryStream( ticket );
					DecryptData( strmEncrypted, strm, key, iv );
				}
				catch( Exception )
				{
					throw new UDDIException( UDDI.ErrorType.E_authTokenRequired, "UDDI_ERROR_AUTHTOKENREQUIRED_INVALIDOREXPIRED" );				
				}
				
				//
				// Deserialize the stream into the user class
				// and setup the context's user information
				//				
				XmlSerializer serializer = XmlSerializerManager.GetSerializer( typeof( UserInfo ) );

				Context.User = (UserInfo) serializer.Deserialize( strm );

				//
				// Check the age of the token
				//
				Context.User.CheckAge( timeWindow );
			}
			catch( Exception exception )
			{
				//
				// Log the real exception
				//
				Debug.Write( SeverityType.FailAudit, CategoryType.Authorization, exception.ToString() );				

				//
				// Preserve the error number if it was a UDDIException; but DO NOT preserve the error
				// message.  We want the error message in the log, but not shown to the user for security
				// reasons.
				//
				UDDIException uddiException = exception as UDDIException;
				if( null != uddiException )
				{
					throw new UDDIException( uddiException.Number, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
				else
				{
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
			}

			return true;
		}

		//
		// This method returns a security key and initialization vector to be used in decryption or encryption
		// algorithms.  If the key has timed out, a new one is created.  This method was added as part of the changes needed to remove our dependency on SQLAgent.
		//
		private void GetSecurityPair( out byte[] key, out byte[] iv )
		{
			//
			// Make sure we have the settings that we need.
			//
			Debug.VerifySetting( "Security.KeyAutoReset" );
			Debug.VerifySetting( "Security.KeyLastResetDate" );
			Debug.VerifySetting( "Security.KeyTimeout" );
			Debug.VerifySetting( "Security.Key" );
			Debug.VerifySetting( "Security.IV" );
			
			key = null;
			iv  = null;

			//
			// If we aren't supposed to automatically generate keys, then we don't care if the key has expired, so 
			// just use the current values.
			//
			if( 1 == Config.GetInt( "Security.KeyAutoReset" ) )
			{
				//
				// Since we are allowed to generate keys, see if we need to.
				//

				//
				// Get the current date
				//
				DateTime current = DateTime.Now;

				//
				// Get the last time the key was reset.
				//
				// DateTime lastReset = DateTime.Parse( Config.GetString( "Security.KeyLastResetDate" ) );

				//
				// 739955 - Make sure date is parsed in the same format it was written.
				//				
				DateTime lastReset = UDDILastResetDate.Get();

				//
				// Get the timeout (days)
				//
				int timeOutDays = Config.GetInt( "Security.KeyTimeout" );

				//
				// Has the key expired?
				// 
				DateTime expiration = lastReset.AddDays( timeOutDays );
				
				if( current > expiration )
				{
					try
					{
						//
						// Generate new security information.
						//
						SymmetricAlgorithm sa = SymmetricAlgorithm.Create();

						sa.GenerateKey();
						key = sa.Key; 

						sa.GenerateIV();
						iv = sa.IV; 

						//
						// Store the new key, initialization vector, and current time.
						//

						//
						// 739955 - Make sure date is parsed in the same format it was written.
						//		
						UDDILastResetDate.Set( current );
						Config.SetString( "Security.Key",			   Convert.ToBase64String( key ) );
						Config.SetString( "Security.IV",			   Convert.ToBase64String( iv ) );

						//
						// Make sure our current configuration is reading these values.  TODO AddSetting is not
						// public, so we have to Refresh, this is pretty expensive, but it should only happen
						// once a week (by default).
						//
						Config.Refresh();		
					}
					catch( Exception exception )
					{
						//
						// Don't let any exceptions propogate here, we'll catch them
						// and just throw a generic one.  We don't want to reveal too much
						// information if we don't have to.
						//
						key = null;
						iv  = null;

						//
						// Log the real exception
						//
						Debug.Write( SeverityType.FailAudit, CategoryType.Authorization, exception.ToString() );				

						//
						// Preserve the error number if it was a UDDIException; but DO NOT preserve the error
						// message.  We want the error message in the log, but not shown to the user for security
						// reasons.
						//
						UDDIException uddiException = exception as UDDIException;
						if( null != uddiException )
						{
							throw new UDDIException( uddiException.Number, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
						}
						else
						{
							throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
						}
					}
				}							
			}
			
			//
			// If we don't have a value for the pair at this point, use the original values.
			//
			if( key == null && iv == null )
			{
				key = Convert.FromBase64String( Config.GetString( "Security.Key" ) );
				iv  = Convert.FromBase64String( Config.GetString( "Security.IV" ) );									
			}
		}

		private static void EncryptData( Stream input, Stream output, byte[] key, byte[] iv )
		{   
			byte[] buffer = new byte[100];
			long bytesRead = 0;
			long bytesTotal = input.Length;
		 
			//
			// Creates the default implementation, which is RijndaelManaged (AES).         
			//
			SymmetricAlgorithm sa = SymmetricAlgorithm.Create();
			CryptoStream encodingStream = new CryptoStream( output, sa.CreateEncryptor( key, iv ), CryptoStreamMode.Write );
		            
			//
			// Encrypt the bytes in the buffer in 100 bytes at a time
			//
			while( bytesRead < bytesTotal )
			{
				int n = input.Read( buffer, 0, 100 );
				encodingStream.Write( buffer, 0, n );
				bytesRead = bytesRead + n;
			}

			encodingStream.FlushFinalBlock();
			input.Position = 0;
			output.Position = 0;
		}

		private static void DecryptData( Stream input, Stream output, byte[] key, byte[] iv )
		{   
			byte[] buffer = new byte[100];
			long bytesRead = 0;
			long bytesTotal = input.Length;
	 
			//
			// Creates the default implementation, which is RijndaelManaged.         
			//
			SymmetricAlgorithm sa = SymmetricAlgorithm.Create();
			CryptoStream decodingStream = new CryptoStream( output, sa.CreateDecryptor( key, iv ), CryptoStreamMode.Write );
	            
			//
			// Encrypt the bytes in the buffer in 100 bytes at a time
			//
			while( bytesRead < bytesTotal )
			{
				int n = input.Read( buffer, 0, 100 );
				decodingStream.Write( buffer, 0, n );
				bytesRead = bytesRead + n;
			}

			decodingStream.FlushFinalBlock();
			input.Position = 0;
			output.Position = 0;
		}
	}

	public class PassportAuthenticator : IAuthenticator
	{
		public bool GetAuthenticationInfo( string userid, string password, out string ticket )
		{
			try
			{
				//
				// TODO: Should we generate and use our own ticket?
				//
				PassportAuthenticationHelper helper = new PassportAuthenticationHelper();
				ticket = helper.AuthenticateUser( userid, password, false );
				Context.User.SetPublisherRole( userid );
			}
			catch( Exception exception )
			{
				//
				// Log the real exception
				//
				Debug.Write( SeverityType.FailAudit, CategoryType.Authorization, exception.ToString() );				

				//
				// Preserve the error number if it was a UDDIException; but DO NOT preserve the error
				// message.  We want the error message in the log, but not shown to the user for security
				// reasons.
				//
				UDDIException uddiException = exception as UDDIException;
				if( null != uddiException )
				{
					throw new UDDIException( uddiException.Number, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
				else
				{
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
			}

			return true;
		}

		public bool Authenticate( string strTicket, int timeWindow )
		{
			try
			{
				PassportAuthenticationHelper helper = new PassportAuthenticationHelper();
				helper.ValidateAuthInfo( strTicket, timeWindow );

				string userID;
				string email;
				helper.GetUserInfo( strTicket, out userID, out email );
				Context.User.SetPublisherRole( userID );
				Context.User.Email = email;
			}
			catch( Exception exception )
			{
				//
				// Log the real exception
				//
				Debug.Write( SeverityType.FailAudit, CategoryType.Authorization, exception.ToString() );				

				//
				// Preserve the error number if it was a UDDIException; but DO NOT preserve the error
				// message.  We want the error message in the log, but not shown to the user for security
				// reasons.
				//
				UDDIException uddiException = exception as UDDIException;
				if( null != uddiException )
				{
					throw new UDDIException( uddiException.Number, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
				else
				{
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_LOGINFAILED" );				
				}
			}

			return true;
		}
	}

	/// ****************************************************************
	///   class PassportAuthenticationHelper
	///	----------------------------------------------------------------
	///	  <summary>
	///		Methods for authenticating users against the Passport
	///		authentication site.
	///	  </summary>
	/// ****************************************************************
	/// 
	class PassportAuthenticationHelper
	{
		private const int PassportEmailValidated = 0x0001;

		//
		// SECURITY: This interval should be configurable
		//
		private readonly TimeSpan refreshInterval = TimeSpan.FromDays( 1 );

		private PassportLib.Manager passport = null;
		private XmlDocument clientXml = null;
		private int keyVersion = 0;

		/// ****************************************************************
		///   public Authenticator [constructor]
		///	----------------------------------------------------------------
		///	  <summary>
		///	    Constructs a new authentication object.
		///	  </summary>
		/// ****************************************************************
		/// 
		public PassportAuthenticationHelper()
		{
			Debug.Enter();

			//
			// Retrieve Passport key version.
			//
			RegistryKey key = Registry.LocalMachine.OpenSubKey( @"Software\Microsoft\Passport" );
			
			try
			{
				keyVersion = Convert.ToInt32( key.GetValue( "CurrentKey", 1 ) ); 
			}
			finally
			{
				key.Close();
			}

			//
			// Create an instance of the Passport Manager for this object.
			//
			passport = new PassportLib.Manager();		

			//
			// TODO: Need to centralize default values such as 100 for connection limit
			//

			//
			// Set the connection limit for the webclient.
			//
			ServicePointManager.DefaultConnectionLimit = 
				Config.GetInt( "Passport.ConnectionLimit", 100 );

			Debug.Leave();
		}

		/// ****************************************************************
		///   public AuthenticateUser
		///	----------------------------------------------------------------
		///	  <summary>
		///		Authenticates a user by sending the specified userId and 
		///		password to the appropriate Passport authentication site.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="userId">
		///		The full user id for the user to be verified.  This must be 
		///		of the form user@domain.
		///	  </param>
		///	  
		///   <param name="password">
		///		The password of the user to authenticate.
		///	  </param>
		///	 
		///   <param name="savePassword">
		///     Specifies whether the user should remain logged into the
		///     site.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns an authorization token, if successful.
		///	  </returns>
		///	----------------------------------------------------------------
		///	  <remarks>
		///	    An authorization token is simply a concatenation of the
		///	    passport ticket and profile, separated by a semicolon.
		///	  </remarks>
		/// ****************************************************************
		/// 
		public string AuthenticateUser( string userId, string password, bool savePassword )
		{
			Debug.Enter();
			Debug.Verify( !Utility.StringEmpty( userId ), "UDDI_ERROR_FATALERROR_NULLUSERID" );
			Debug.Verify( !Utility.StringEmpty( password ), "UDDI_ERROR_FATALERROR_NULLPASSWORD" );		
			Debug.VerifySetting( "Passport.SiteID" );
			Debug.VerifySetting( "Passport.ReturnURL" );
			
			string domain = "";
			string authUrl = "";
			string authInfo = "";

			try
			{
				//
				// The authentication URL depends on the user's domain.  First parse off the 
				// domain (i.e. user@domain) using the Passport manager.
				//
				try
				{
					domain = passport.DomainFromMemberName( userId );			
				}
				catch( Exception )
				{
					Debug.OperatorMessage(
						SeverityType.FailAudit,
						CategoryType.Authorization,
						OperatorMessageType.InvalidUserId,
						"Invalid format for user ID.  Must be in the form of user@domain: " + userId );
					
					throw new UDDIException( 
						ErrorType.E_unknownUser,
						"UDDI_ERROR_UNKNOWNUSER_BADFORMAT" );
				}

				Debug.Write( 
					SeverityType.Info, 
					CategoryType.Authorization, 
					"Got domain=" + domain + " for user=" + userId );
					
				//
				// Lookup the URL we should use to authenticate users from this
				// domain.
				//				
				authUrl = GetLoginURL( domain );

				Debug.Write(
					SeverityType.Info, 
					CategoryType.Authorization, 
					"Obtained authorization URL=" + authUrl );
				
				//
				// Append the site id and return url to the authorization url.
				//				
				authUrl += "?id=" + Config.GetInt( "Passport.SiteID" ).ToString() 
					+ "&ru=" + Config.GetString( "Passport.ReturnURL" ) + "&kv=" + keyVersion.ToString();

				//
				// Create the login message.
				//
				string loginMessage = 
					"<LoginRequest>" +
						"<ClientInfo name=\"Client\" version=\"1.35\"/>" +
						"<User>" +
							"<SignInName>" + userId + "</SignInName>" +
							"<Password>" + password + "</Password>" +
							"<SavePassword>" + ( true == savePassword ? "true" : "false" ) + "</SavePassword>" +
						"</User>" +
					"</LoginRequest>";
				
				byte[] requestData = Encoding.ASCII.GetBytes( loginMessage );
				
				//
				// Prepare the web request.
				//
				WebRequest webRequest = WebRequest.Create( authUrl );
				
				string proxy = Config.GetString( "Proxy", null );

				if( !Utility.StringEmpty( proxy ) )
					webRequest.Proxy = new WebProxy( proxy, true );
				
				webRequest.Method = "POST";
				webRequest.ContentType = "text/xml";
				webRequest.ContentLength = requestData.Length;
				webRequest.Timeout = Config.GetInt( "Passport.Timeout", 30000 );

				Stream stream;

				stream = webRequest.GetRequestStream();
				stream.Write( requestData, 0, requestData.Length );
				stream.Close();

				//
				// Post the data to the server.
				//				
#if DEBUG
				Debug.Write(
					SeverityType.Info, 
					CategoryType.Authorization, 
					"Posting XML login message: " + loginMessage );
#endif

				//
				// SECURITY: try/finally for managing the stream
				// and webrequest in cases of failure
				//
				WebResponse webResponse = webRequest.GetResponse();
				stream = webResponse.GetResponseStream();
				
				//
				// Retrieve the response.
				//
				StreamReader reader = new StreamReader( stream );
				string response = reader.ReadToEnd();
				reader.Close();

				stream.Close();
				webResponse.Close();

				//
				// Process the response.  If the response data contains Success="true", 
				// then the user has been authenticated
				//				
				if( "true" != Utility.ParseDelimitedToken( "Success=\"", "\"", response ) )
				{
					//
					// SECURITY: FailAudit this login failure
					// 
					Debug.Write(
						SeverityType.Info,
						CategoryType.Authorization,
						"Login failed for user " + userId + "; response did not include attribute Success=true.\r\n" + response );

					throw new UDDIException(
						ErrorType.E_unknownUser,
						"UDDI_ERROR_UNKNOWNUSER_FAILED" );
				}

				//
				// Retrieve the associated ticket and profile.
				//					
				string redirectUrl = Utility.ParseDelimitedToken( "<Redirect>", "</Redirect>", response );
				string ticket = Utility.ParseDelimitedToken( "&amp;t=", "&amp;p=", redirectUrl );
				string profile = Utility.ParseDelimitedToken( "&amp;p=", null, redirectUrl );
		
				if( null == ticket || null == profile )
				{
					Debug.Write(
						SeverityType.FailAudit,
						CategoryType.Authorization,
						"Login failed for user " + userId + "; response did not include Success=true.\r\n" + response );

					throw new UDDIException(
						ErrorType.E_unknownUser,
						"UDDI_ERROR_UNKNOWNUSER_FAILED" );
				}

				//
				// Build the authInfo from the ticket and profile.
				//						
				authInfo = ticket + ";" + profile;

				Debug.Write(
					SeverityType.PassAudit,
					CategoryType.Authorization,
					"User " + userId + " authenticated.\r\nauthInfo=" + authInfo );

				Debug.Leave();

				return authInfo;
			}
			catch( UDDIException )
			{		
				throw;
			}
			catch( WebException e )
			{
				//
				// A web exception is thrown when the Passport server is 
				// unavailable or returns an error message.
				//
				string message = "Error authenticating user\r\n\r\n";

				if( null != e.Response )
				{
					StreamReader reader = new StreamReader( e.Response.GetResponseStream(), Encoding.UTF8 );					
					string response = reader.ReadToEnd();
					reader.Close();

					string errorCode = Utility.ParseDelimitedToken( "Error Code=\"", "\"", response );
					
					//
					// Check to make sure an error code was returned.  If it was,
					// we can provide a little more fidelity in our error
					// reporting.
					//
					if( null != errorCode )
						message += "Passport error: " + ParsePassportErrorCode( errorCode ) + "\r\n\r\n";

					message += "Response stream:\r\n" + response + "\r\n\r\n";
				}
				else
				{
					message += "Passport error: unknown error communicating with Passport\r\n\r\n";
				}
				
				Debug.OperatorMessage( 
					SeverityType.Error,
					CategoryType.Authorization,
					OperatorMessageType.PassportSiteUnavailable,
					message + e.ToString() );				
				
				throw new UDDIException(
					ErrorType.E_unknownUser,
					"UDDI_ERROR_UNKNOWNUSER_AUTHENTICATIONFAILED" );
			}
			catch( Exception e )
			{
				//
				// General exception handling.
				//
				Debug.OperatorMessage( 
					SeverityType.Error,
					CategoryType.Authorization,
					OperatorMessageType.PassportSiteUnavailable,
					"Error authenticating user.\r\n\r\n" + e.ToString() );
				
				throw new UDDIException(
					ErrorType.E_unknownUser,
					"UDDI_ERROR_UNKNOWNUSER_AUTHENTICATIONFAILED" );
			}
		}

		/// ****************************************************************
		///   public ValidateAuthInfo
		///	----------------------------------------------------------------
		///	  <summary>
		///		Validates an authorization token.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="authInfo">
		///		The authorization token.
		///   </param>
		///   
		///   <param name="timeWindow">
		///     Time in seconds since login after which an authorization 
		///     token is considered expired.
		///   </param>
		/// ****************************************************************
		/// 
		public void ValidateAuthInfo( string authInfo, int timeWindow )
		{
			Debug.Enter();
			Debug.Verify( null != authInfo, "UDDI_ERROR_FATALERROR_NULLAUTHINFO" );

			//
			// Parse the ticket and profile from the authInfo string.
			//
			int separator = authInfo.IndexOf( ";" );

			if( -1 == separator )
			{
				Debug.OperatorMessage(
					SeverityType.FailAudit,
					CategoryType.Authorization,
					OperatorMessageType.InvalidTicketFormat,
					"Invalid ticket format: " + authInfo );

				throw new UDDIException(
					ErrorType.E_authTokenRequired,
					"UDDI_ERROR_AUTHTOKENREQUIRED_INVALIDOREXPIRED" );
			}

			string ticket = authInfo.Substring( 0, separator );
			string profile = authInfo.Substring( separator + 1 );

			//
			// Attempt to authenticate the ticket and profile.
			//			
			try
			{
				passport.OnStartPageManual( ticket, null, null, null, null, null );
				
				if( false == passport.IsAuthenticated( timeWindow, false, false ) )
				{
					Debug.Write(
						SeverityType.Info,
						CategoryType.Authorization,
						"Authentication failed; ticket is invalid or has expired" );

					throw new UDDIException(
						ErrorType.E_authTokenExpired,
						"UDDI_ERROR_AUTHTOKENREQUIRED_INVALIDOREXPIRED" );
				}		

				Debug.Write(
					SeverityType.PassAudit,
					CategoryType.Authorization,
					"Authentication successful" );

				Debug.Leave();
			}
			catch( UDDIException )
			{
				throw;
			}
			catch( Exception e )
			{
				Debug.Write(
					SeverityType.Error,
					CategoryType.Authorization,
					"Authentication failed; " + e.Message );

				throw new UDDIException(
					ErrorType.E_unknownUser,
					"UDDI_ERROR_UNKNOWNUSER_AUTHENTICATIONFAILED" );
			}
		}

		/// ****************************************************************
		///   public GetUserInfo
		///	----------------------------------------------------------------
		///	  <summary>
		///		Gets the user information associated with a specified 
		///		authorization token.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="authInfo">
		///		The authorization token.
		///   </param>
		///   
		///   <param name="puid">
		///     [out] The member id for the user.  This is different than
		///     the user id which was used to login.
		///   </param>
		///   
		///   <param name="userEmail">
		///		[out] The user's preferred email address.
		///   </param>
		/// ****************************************************************
		/// 
		public void GetUserInfo( string authInfo, out string puid, out string userEmail )
		{
			Debug.Enter();			
			Debug.Verify( null != authInfo, "UDDI_ERROR_FATALERROR_NULLAUTHINFO" );

			//
			// Parse the ticket and profile from the authInfo string.
			//
			int separator = authInfo.IndexOf( ";" );

			if( -1 == separator )
			{
				Debug.OperatorMessage(
					SeverityType.FailAudit,
					CategoryType.Authorization,
					OperatorMessageType.InvalidTicketFormat,
					"Invalid ticket format: " + authInfo );

				throw new UDDIException(
					ErrorType.E_authTokenRequired,
					"UDDI_ERROR_AUTHTOKENREQUIRED_INVALIDFORMAT" );
			}

			string ticket = authInfo.Substring( 0, separator );
			string profile = authInfo.Substring( separator + 1 );

			//
			// Get the user's preferred email.  This could change over time
			// since the user could change this on the Passport site, so
			// we'll always get the most recent value from the user's profile.
			//
			userEmail = (string)GetPropertyFromProfile( ticket, profile, "PreferredEmail" );

			//
			// Get the user's PUID.  Since the PUID is a 64-bit value, we'll need
			// to build this from the low and high 32-bit values (Passport doesn't
			// store it as a single 64-bit value).
			//	
			/*
			object idHigh = GetPropertyFromProfile( ticket, profile, "MemberIDHigh" );
			Debug.Verify( null != idHigh, "Unable to retrieve Passport member ID." );			
						
			object idLow = GetPropertyFromProfile( ticket, profile, "MemberIDLow" );
			Debug.Verify( null != idLow, "Unable to retrieve Passport member ID." );

			puid = ((int)idHigh).ToString( "X8" ) + ((int)idLow).ToString( "X8" );
			*/
			
			//
			// they now provide a single property to get the PUID
			//
			puid = passport.HexPUID;
			
			Debug.Leave();
		}

		/// ****************************************************************
		///   private GetPropertyFromProfile
		///	----------------------------------------------------------------
		///	  <summary>
		///		Retrieves a property from the given user profile.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="ticket">
		///		Ticket for the authenticated user.
		///   </param>
		///   
		///   <param name="profile">
		///		Profile for the authenticated user.
		///   </param>
		///   
		///   <param name="propertyName">
		///     The name of the property to retrieve.
		///   </param>
		///	----------------------------------------------------------------
		///   <returns>
		///     The value of the property.
		///   </returns>
		/// ****************************************************************
		/// 
		private object GetPropertyFromProfile( string ticket, string profile, string propertyName )
		{
			Debug.Assert( null != ticket, "ticket cannot be null" );
			Debug.Assert( null != profile, "profile cannot be null" );
			Debug.Assert( null != propertyName, "propertyName cannot be null" );

			object val = null;

			try
			{
				passport.OnStartPageManual( ticket, profile, null, null, null, null );
				val = passport[ propertyName ];

				Debug.Write( 
						SeverityType.Info, 
						CategoryType.Authorization,
							"Current Property: " + propertyName + "\r\n" +
							"Current Value: " + ((null!=val)?val:"(null)" ) + "\r\n" +
							"MemberIDHigh: " + passport[ "MemberIDHigh" ] + "\r\n" +
							"MemberIDLow: " + passport[ "MemberIDLow" ] + "\r\n" +
							"PreferredEmail: " + passport[ "PreferredEmail" ] + "\r\n" +
							"ProfileVersion: " + passport[ "ProfileVersion" ] + "\r\n" 
						);
				
				return val;
			}
			catch( Exception )
			{
				throw new UDDIException(
					ErrorType.E_fatalError,
					"UDDI_ERROR_FATALERROR_ERRORRETRIEVINGPROFILEDATA",
					propertyName 
				);
			}
		}

		/// ****************************************************************
		///   public GetLoginURL
		/// ----------------------------------------------------------------
		///   <summary>
		///     Retrieves the XML Login URL for the given domain.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="domain">
		///     The domain name.
		///   </param>
		/// ----------------------------------------------------------------
		///   <returns>
		///     The XML Login URL.
		///   </returns>
		/// ****************************************************************
		/// 
		public string GetLoginURL( string domain )
		{
			Debug.VerifySetting( "Passport.ClientXmlFile" );

			string location = Config.GetString( "Passport.ClientXmlFile" );

			//
			// Make sure the Client.xml file exists and is loaded.
			//
			if( !File.Exists( location ) )
			{
				UpdateClientXml();
			}

			//
			// Check to see if it is time for a periodic refresh
			// of the Client.xml file.
			//
			TimeSpan age = DateTime.Now.Subtract( File.GetLastWriteTime( location ) );

			if( age >= refreshInterval )
			{
				UpdateClientXml();
			}

			//
			// If the Client.xml file is still not loaded, load it now.
			//
			if( null == clientXml )
			{
				clientXml = new XmlDocument();
				clientXml.Load( location );
			}

			//
			// Make sure the Client.xml hasn't expired.
			//
			DateTime validUntil = DateTime.Parse( clientXml.DocumentElement.Attributes.GetNamedItem( "ValidUntil" ).Value );

			if( validUntil < DateTime.Now )
				UpdateClientXml();

			//
			// Retrieve the XMLLogin element text for the specified domain.
			// 
			if( clientXml.HasChildNodes )
			{
				XmlNode node = clientXml.SelectSingleNode( "//Domain[@Name=\"" + domain + "\"]/XMLLogin" );

				if( null != node )
					return node.InnerText;

				//
				// We couldn't find the specified domain, so ll try the default
				// XML login URL.
				//
				node = clientXml.SelectSingleNode( "//Domain[@Name=\"default\"]/XMLLogin" );

				if( null != node )
					return node.InnerText;
			}

			//
			// We were unable to find a login URL for the domain.
			//

			Debug.OperatorMessage(
				SeverityType.FailAudit,
				CategoryType.Authorization,
				OperatorMessageType.UnknownLoginURL,
				"Could not find login URL for user from domain '" + domain + "'" );

			throw new UDDIException(
				ErrorType.E_fatalError,
				"UDDI_ERROR_FATALERROR_ERRORAUTHENTICATINGINDOMAIN",
				domain);
		}

		/// ****************************************************************
		///   public UpdateClientXml
		/// ----------------------------------------------------------------
		///   <summary>
		///     Retrieves a fresh copy of the Client.xml file from 
		///     Passport.
		///   </summary>
		/// ****************************************************************
		/// 
		public void UpdateClientXml()
		{
			Debug.VerifySetting( "Passport.ClientXmlURL" );
			Debug.VerifySetting( "Passport.ClientXmlFile" );
			
			string url = Config.GetString( "Passport.ClientXmlURL" );
			
			try
			{
				WebRequest request = WebRequest.Create( url );
			
				string proxy = Config.GetString( "Proxy", null );

				if( !Utility.StringEmpty( proxy ) )
					request.Proxy = new WebProxy( proxy, true );
				
				request.Timeout = Config.GetInt( "Passport.Timeout", 30000 );
				
				WebResponse response = request.GetResponse();
						
				try
				{
					clientXml = new XmlDocument();
			
					clientXml.Load( response.GetResponseStream() );
					clientXml.Save( Config.GetString( "Passport.ClientXmlFile" ) );
				}
				finally
				{
					response.Close();
				}
			}
			catch( Exception e )
			{
				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.Authorization,
					OperatorMessageType.CannotRetrieveClientXml,
					"Error retrieving Client.xml from '" + url + "'\n\nDetails:\n" + e.ToString() );

				throw new UDDIException(
					ErrorType.E_fatalError,
					"UDDI_ERROR_FATALERROR_ERRORCOMMUNICATINGWITHPASSPORT" );
			}
		}

		/// ****************************************************************
		///   private ParsePassportErrorCode [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Returns an appropriate message for the Passport error
		///     code.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="errorCode">
		///     The error code returned by Passport.
		///   </param>
		/// ----------------------------------------------------------------
		///   <returns>
		///     The error message.
		///   </returns>
		/// ****************************************************************
		/// 
		private static string ParsePassportErrorCode( string errorCode )
		{
			//
			// Check for a general network error.  This indicates the service 
			// is unavailable.
			//
			if( 'n' == errorCode[0] )
				return "Service unavailable";

			//
			// Return an appropriate message for the error code.
			//
			switch( errorCode )
			{
				case "e1":
					return "Missing member name and password";

				case "e2":
					return "Missing member name";

				case "e3":
					return "Missing password";

				case "e5a":
					return "Incorrect password for given member name";
					
				case "e5b":
					return "Member name does not exist";

				case "e5d":
					return "Member name incomplete";

				case "e8":
					return "Missing Passport site ID (configuration error)";

				case "e8a":
					return "Missing Passport return URL (configuration error)";

				case "e6":
					goto case "e9";

				case "e9":
					return "Member has a KIDS Passport that does not have parental consent";

				case "e10":
					return "Password lockout.  Several incorrect password attempted for member in a short time duration";

				case "e11":
					return "Member name or domain exceed 64 characters or password exceeded 16 characters";

				case "e13":
					return "General XML parsing or validation failure";

				case "e13a":
					return "Login sent to wrong domain authority (see referral tag)";

				case "e14":
					return "Malformed request (missing LoginRequest element)";

				case "g1":
					return "Malformed request (missing ClientInfo element)";

				case "p1":
					return "Invalid version attribute specified in ClientInfo element";

				default:
					return "Unknown Passport error code '" + errorCode + "'.";
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\changerecord.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using UDDI;
using UDDI.API;
using UDDI.API.Binding;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.Replication
{
	public abstract class ChangeRecordBase
	{
		public abstract UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType { get; }
		public abstract void Process( long LSN );
	}

	[ XmlRoot( "changeRecord", Namespace="urn:uddi-org:repl" ) ]
    public class ChangeRecord
	{
		//
		// Attribute: acknowledgementRequested
		//
		[ XmlAttribute( "acknowledgementRequested" ) ]
		public bool AcknowledgementRequested = false;

		//
		// Element: changeID
		//
		private ChangeRecordVector changeID;

		[ XmlElement( "changeID" ) ]
		public ChangeRecordVector ChangeID
		{
			get 
			{ 
				if( null == changeID )
					changeID = new ChangeRecordVector();

				return changeID; 
			}
			
			set { changeID = value; }
		}

		//
		// Element: changeRecordAcknowledgement		|
		//			changeRecordCorrection			|
		//			changeRecordCustodyTransfer		|
		//			changeRecordDelete				|
		//			changeRecordDeleteAssertion		|
		//			changeRecordHide				|
		//			changeRecordNewData				|
		//			changeRecordNull				|
		//			changeRecordPublisherAssertion	|
		//			changeRecordSetAssertions
		//
		private ChangeRecordBase payload;

		[ XmlElement( "changeRecordAcknowledgement", typeof( ChangeRecordAcknowledgement ) ) ]
		[ XmlElement( "changeRecordCorrection", typeof( ChangeRecordCorrection ) ) ]
		[ XmlElement( "changeRecordCustodyTransfer", typeof( ChangeRecordCustodyTransfer ) ) ]
		[ XmlElement( "changeRecordDelete", typeof( ChangeRecordDelete ) ) ]
		[ XmlElement( "changeRecordDeleteAssertion", typeof( ChangeRecordDeleteAssertion ) ) ]
		[ XmlElement( "changeRecordHide", typeof( ChangeRecordHide ) ) ]
		[ XmlElement( "changeRecordNewData", typeof( ChangeRecordNewData ) ) ]
		[ XmlElement( "changeRecordNull", typeof( ChangeRecordNull ) ) ]
		[ XmlElement( "changeRecordPublisherAssertion", typeof( ChangeRecordPublisherAssertion ) ) ]
		[ XmlElement( "changeRecordSetAssertions", typeof( ChangeRecordSetAssertions ) ) ]
		public ChangeRecordBase Payload
		{
			get { return payload; }
			set { payload = value; }
		}

		public ChangeRecord()
		{
            ChangeID.NodeID = null;
            ChangeID.OriginatingUSN = 0;
            Payload = null;
        }

		public ChangeRecord( ChangeRecordBase payload )
		{
			ChangeID.NodeID = null;
            ChangeID.OriginatingUSN = 0;
            Payload = payload;
		}

		public ChangeRecord( ChangeRecordVector changeID, ChangeRecordBase payload )
		{
			ChangeID = changeID;
			Payload = payload;
		}

		/// ****************************************************************
		///   public Process
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public void Process()
		{
			//
			// Add the change record to our change log as a foreign change.
			//
			long LSN = Log();
			
			//
			// Process the change record payload.
			//
			Payload.Process( LSN );

			//
			// If an acknowledgement was requested, generate a 
			// acknowledgement change record.
			//
			if( AcknowledgementRequested )
			{
                //
                // Save the log entry as our local system account, not the
                // current user.
                //
                string puid = Context.User.ID;
                Context.User.ID = null;

				ChangeRecord changeRecord = new ChangeRecord();
				
				changeRecord.Payload = new ChangeRecordAcknowledgement( ChangeID );
				changeRecord.Log();

                Context.User.ID = puid;
			}
		}

		public long Log()
		{
			string changeData;

			//
			// Serialize the change data.
			//
			Type type = Payload.GetType();

			//XmlSerializer serializer = new XmlSerializer( type );		
			XmlSerializer serializer = XmlSerializerManager.GetSerializer( type );
			XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces();
			UTF8EncodedStringWriter stringWriter = new UTF8EncodedStringWriter();
			
			try
			{
				namespaces.Add( "", "urn:uddi-org:repl" );

				serializer.Serialize( stringWriter, Payload, namespaces );
				changeData = stringWriter.ToString();
			}
			finally
			{
				stringWriter.Close();
			}

			//
			// Store the record in the change log.
			//
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_changeRecord_save" );

			sp.Parameters.Add( "@USN", SqlDbType.BigInt );
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@delegatePUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@operatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@entityKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@entityTypeID", SqlDbType.TinyInt );			
			sp.Parameters.Add( "@changeTypeID", SqlDbType.TinyInt );
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@contextTypeID", SqlDbType.TinyInt );
			sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );
			sp.Parameters.Add( "@changeData", SqlDbType.NText );
			sp.Parameters.Add( "@flag", SqlDbType.Int );
			sp.Parameters.Add( "@seqNo", SqlDbType.BigInt, ParameterDirection.Output );

			if( Utility.StringEmpty( ChangeID.NodeID ) || 
				0 == String.Compare( Config.GetString( "OperatorKey" ), ChangeID.NodeID, true ) )
			{
				sp.Parameters.SetNull( "@USN" );
				sp.Parameters.SetString( "@PUID", Context.User.ID );
				sp.Parameters.SetString( "@delegatePUID", Context.User.ImpersonatorID );
				sp.Parameters.SetNull( "@operatorKey" );
			}
			else
			{
				sp.Parameters.SetLong( "@USN", changeID.OriginatingUSN );
				sp.Parameters.SetNull( "@PUID" );
				sp.Parameters.SetNull( "@delegatePUID" );
				sp.Parameters.SetGuidFromString( "@operatorKey", changeID.NodeID );
			}

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetInt( "@flag", AcknowledgementRequested ? 0x1 : 0x0 );
			sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );					
			sp.Parameters.SetShort( "@contextTypeID", (short)Context.ContextType );
			sp.Parameters.SetShort( "@changeTypeID", (short)Payload.ChangeRecordPayloadType );

			if( Payload is ChangeRecordNewData )
			{
				ChangeRecordNewData payload = (ChangeRecordNewData)Payload;
				
				sp.Parameters.SetShort( "@entityTypeID", (short)payload.EntityType );
				
				if( EntityType.TModel == payload.EntityType )
					sp.Parameters.SetGuidFromKey( "@entityKey", payload.Entity.EntityKey );
				else
					sp.Parameters.SetGuidFromString( "@entityKey", payload.Entity.EntityKey );
			}
			else if( Payload is ChangeRecordDelete )
			{
				ChangeRecordDelete payload = (ChangeRecordDelete)Payload;

				sp.Parameters.SetShort( "@entityTypeID", (short)payload.EntityType );
				
				if( EntityType.TModel == payload.EntityType )
					sp.Parameters.SetGuidFromKey( "@entityKey", payload.EntityKey );
				else
					sp.Parameters.SetGuidFromString( "@entityKey", payload.EntityKey );
			}
			else if( Payload is ChangeRecordHide )
			{
				sp.Parameters.SetShort( "@entityTypeID", (short)EntityType.TModel );
				sp.Parameters.SetGuidFromKey( "@entityKey", ((ChangeRecordHide)Payload).TModelKey );
			}
			else
			{
				sp.Parameters.SetNull( "@entityTypeID" );
				sp.Parameters.SetNull( "@entityKey" );
			}
			
			sp.Parameters.SetString( "@changeData", changeData );

			sp.ExecuteNonQuery();

			return sp.Parameters.GetLong( "@seqNo" );
		}

		public override string ToString()
		{
			// XmlSerializer serializer = new XmlSerializer( GetType() );
			XmlSerializer serializer = XmlSerializerManager.GetSerializer( GetType() );
			UTF8EncodedStringWriter stringWriter = new UTF8EncodedStringWriter ();

			try
			{
				serializer.Serialize( stringWriter, this );
				return stringWriter.ToString();
			}
			finally
			{
				stringWriter.Close();
			}
		}
	}
	
	[ XmlRoot( "changeRecordAcknowledgement", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordAcknowledgement : ChangeRecordBase
	{
		//
		// Element: acknowledgedChange
		//
		[ XmlElement( "acknowledgedChange" ) ]
		public ChangeRecordVector AcknowledgedChange;
		
		public ChangeRecordAcknowledgement()
		{
		}

		public ChangeRecordAcknowledgement( ChangeRecordVector acknowledgedChange )
		{
			this.AcknowledgedChange = acknowledgedChange;
		}

		public override void Process( long LSN )
		{
		}

		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordAcknowledgement; }
		}
	}

	[ XmlRoot( "changeRecordCorrection", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordCorrection : ChangeRecordBase
	{
		//
		// Element: changeRecord
		//
		[ XmlElement( "changeRecord" ) ]
		public ChangeRecord ChangeRecord;
		
		public override void Process( long LSN )
		{
			//
			// Annotate the change record in our database with this 
			// correction's LSN.  The correction's payload will be
			// used as the updated data on future get_changeRecords
			// requests.
			//
            SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_changeRecord_update";

			sp.Parameters.Add( "@seqNo", SqlDbType.BigInt );
			sp.Parameters.Add( "@USN", SqlDbType.BigInt );
			sp.Parameters.Add( "@operatorKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@newSeqNo", SqlDbType.BigInt );
			sp.Parameters.Add( "@flag", SqlDbType.Int );
			
			if( true == ChangeRecord.ChangeID.NodeID.ToLower().Equals( Config.GetString( "OperatorKey" ).ToLower() ) )
			{
				//
				// We are correcting a local change
				// 
				sp.Parameters.SetLong( "@seqNo", ChangeRecord.ChangeID.OriginatingUSN );
				sp.Parameters.SetNull( "@USN" );
			}
			else
			{	
				//
				// We are correcting a foreign change
				// 
				sp.Parameters.SetLong( "@USN", ChangeRecord.ChangeID.OriginatingUSN );
				sp.Parameters.SetNull( "@seqNo" );
			}

			sp.Parameters.SetGuidFromString( "@operatorKey", ChangeRecord.ChangeID.NodeID );
			sp.Parameters.SetLong( "@newSeqNo", LSN );
			
			sp.ExecuteNonQuery();
		}

		[ XmlIgnore ]
		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordCorrection; }
		}
	}

	[ XmlRoot( "changeRecordCustodyTransfer", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordCustodyTransfer : ChangeRecordBase
	{
		public override void Process( long LSN )
		{

		}

		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordCustodyTransfer; }
		}
	}

	[ XmlRoot( "changeRecordDelete", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordDelete : ChangeRecordBase
	{
		private string entityKey;
		private EntityBase entity;

		//
		// Element: businessKey
		//
		[ XmlElement( "businessKey", Namespace=UDDI.API.Constants.Namespace ) ]
		public string BusinessKey
		{
			get
			{
				if( entity is BusinessEntity )
					return entityKey;

				return null;
			}

			set
			{
				Debug.Verify( Utility.StringEmpty( entityKey ), "UDDI_ERROR_FATALERROR_DELETE_MULTIPLEKEYS" );

				entity = new BusinessEntity( value );
				entityKey = value;
			}
		}

		//
		// Element: serviceKey
		//
		[ XmlElement( "serviceKey", Namespace=UDDI.API.Constants.Namespace ) ]
		public string ServiceKey
		{
			get
			{
				if( entity is BusinessService )
					return entityKey;

				return null;
			}

			set
			{
				Debug.Verify( Utility.StringEmpty( entityKey ), "UDDI_ERROR_FATALERROR_DELETE_MULTIPLEKEYS" );

				entity = new BusinessService( value );
				entityKey = value;
			}
		}

		//
		// Element: bindingKey
		//
		[ XmlElement( "bindingKey", Namespace=UDDI.API.Constants.Namespace ) ]
		public string BindingKey
		{
			get
			{
				if( entity is BindingTemplate )
					return entityKey;

				return null;
			}

			set
			{
				Debug.Verify( Utility.StringEmpty( entityKey ), "UDDI_ERROR_FATALERROR_DELETE_MULTIPLEKEYS" );

				entity = new BindingTemplate( value );
				entityKey = value;
			}
		}

		//
		// Element: tModelKey
		//
		[ XmlElement( "tModelKey", Namespace=UDDI.API.Constants.Namespace ) ]
		public string TModelKey
		{
			get
			{
				if( entity is TModel )
					return entityKey;

				return null;
			}

			set
			{
				Debug.Verify( Utility.StringEmpty( entityKey ), "UDDI_ERROR_FATALERROR_DELETE_MULTIPLEKEYS" );

				// TODO: since tModels should normally not be deleted (they 
				// should be hidden), put a warning in the event log.

				entity = new TModel( value );
				entityKey = value;
			}
		}

		[ XmlIgnore ]
		public UDDI.EntityType EntityType
		{
			get { return entity.EntityType; }
		}

		[ XmlIgnore ]
		public string EntityKey
		{
			get { return entityKey; }
		}

		[ XmlIgnore ]
		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordDelete; }
		}

		public ChangeRecordDelete()
		{
		}

		public ChangeRecordDelete( EntityType entityType, string entityKey )
		{
			this.entityKey = entityKey;

			switch( entityType )
			{
				case EntityType.BusinessEntity:
					this.entity = new BusinessEntity( entityKey );
					break;

				case EntityType.BusinessService:
					this.entity = new BusinessService( entityKey );
					break;

				case EntityType.BindingTemplate:
					this.entity = new BindingTemplate( entityKey );
					break;

				case EntityType.TModel:
					this.entity = new TModel( entityKey );
					break;
			}
		}
		
		public override void Process( long LSN )
		{
			//
			// Process a change record delete by deleting the entity.
			//
			entity.Delete();
		}
	}

	[ XmlRoot( "changeRecordDeleteAssertion", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordDeleteAssertion : ChangeRecordBase
	{			
		[ XmlElement( "publisherAssertion", Namespace=UDDI.API.Constants.Namespace ) ]		
		public PublisherAssertion Assertion;

		[ XmlElement( "fromBusinessCheck" ) ]
		public bool FromBusinessCheck;

		[ XmlElement( "toBusinessCheck" ) ]
		public bool ToBusinessCheck;

		public override void Process( long LSN )
		{
			//
			// Process a change record delete assertion by deleting the assertion.
			//
			if( !FromBusinessCheck && !ToBusinessCheck )
			{				
				Debug.OperatorMessage( SeverityType.Warning, 
					CategoryType.Replication, 
					OperatorMessageType.None, 
					"FromBusinessCheck and ToBusinessCheck cannot both be false in a ChangeRecordDeleteAssertion message" );
			}
			else
			{
				CompletionStatusType status;
			
				status = (CompletionStatusType)
					( ( FromBusinessCheck ? 0x02 : 0x00 ) |
					( ToBusinessCheck ? 0x01 : 0x00 ) );

				Assertion.Delete( status );
			}
		}

		[ XmlIgnore ]
		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordDeleteAssertion; }
		}

		public ChangeRecordDeleteAssertion()
		{
		}

		public ChangeRecordDeleteAssertion( PublisherAssertion assertion, CompletionStatusType completion )
		{
			Assertion = assertion;

			FromBusinessCheck = ( 0x02 == ( (int)completion & 0x02 ) );
			ToBusinessCheck = ( 0x01 == ( (int)completion & 0x01 ) );
		}
	}

	[ XmlRoot( "changeRecordHide", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordHide : ChangeRecordBase
	{
		[ XmlElement( "tModelKey", Namespace=UDDI.API.Constants.Namespace ) ]
		public string TModelKey;

		public override void Process( long LSN )
		{
			//
			// Process change record hide by deleting the specified tModel.
			//
			TModel tModel = new TModel( TModelKey );
			tModel.Hide();
		}

		[ XmlIgnore ]
		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordHide; }
		}

		public ChangeRecordHide()
		{
		}

		public ChangeRecordHide( string tModelKey )
		{
			TModelKey = tModelKey;
		}
	}

	[ XmlRoot( "changeRecordNewData", Namespace="urn:uddi-org:repl" ) ]
	[ XmlInclude( typeof( BusinessEntity ) ) ]
	[ XmlInclude( typeof( BusinessService ) ) ]
	[ XmlInclude( typeof( BindingTemplate ) ) ]
	[ XmlInclude( typeof( TModel ) ) ]
	public class ChangeRecordNewData : ChangeRecordBase
	{
		//
		// Element: businessEntity	|
		//			businessService	|
		//			bindingTemplate	|
		//			tModel
		//
		[ XmlElement( "businessEntity", typeof( BusinessEntity ), Namespace=UDDI.API.Constants.Namespace ) ]
		[ XmlElement( "businessService", typeof( BusinessService ), Namespace=UDDI.API.Constants.Namespace ) ]
		[ XmlElement( "bindingTemplate", typeof( BindingTemplate ), Namespace=UDDI.API.Constants.Namespace ) ]
		[ XmlElement( "tModel", typeof( TModel ), Namespace=UDDI.API.Constants.Namespace ) ]
		public EntityBase Entity;

		public ChangeRecordNewData()
		{
		}

		public ChangeRecordNewData( EntityBase entity )
		{
			this.Entity = entity;
		}

		[ XmlIgnore ]
		public UDDI.EntityType EntityType
		{
			get { return Entity.EntityType; }
		}

		[ XmlIgnore ]
		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordNewData; }
		}

		/// ****************************************************************
		///   public Process
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public override void Process( long LSN )
		{
			//
			// We process a new data change record by saving the entity to
			// the registry.
			//
            Entity.Save();
		}
	}

	[ XmlRoot( "changeRecordNull", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordNull : ChangeRecordBase
	{
		public override void Process( long LSN )
		{
			//
			// Nothing to do for a null change record.
			//
		}
		
		[ XmlIgnore ]
		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordNull; }
		}
	}

	[ XmlRoot( "changeRecordPublisherAssertion", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordPublisherAssertion : ChangeRecordBase
	{		
		[ XmlElement( "publisherAssertion", Namespace=UDDI.API.Constants.Namespace ) ]
		public PublisherAssertion Assertion;

		[ XmlElement( "fromBusinessCheck" ) ]
		public bool FromBusinessCheck;

		[ XmlElement( "toBusinessCheck" ) ]
		public bool ToBusinessCheck;

		public override void Process( long LSN )
		{
			//
			// Process a change record assertion by saving the assertion.
			//

			if( !FromBusinessCheck && !ToBusinessCheck )
			{				
				Debug.OperatorMessage( SeverityType.Warning, 
									   CategoryType.Replication, 
					                   OperatorMessageType.None, 
								       "FromBusinessCheck and ToBusinessCheck cannot both be false in a ChangeRecordPublisherAssertion message" );
			}
			else
			{
				CompletionStatusType status;
			
				status = (CompletionStatusType)
					( ( FromBusinessCheck ? 0x02 : 0x00 ) |
					( ToBusinessCheck ? 0x01 : 0x00 ) );
		

				Assertion.Save( status );
			}
		}

		[ XmlIgnore ]
		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordPublisherAssertion; }
		}

		public ChangeRecordPublisherAssertion()
		{
		}

		public ChangeRecordPublisherAssertion( PublisherAssertion assertion, CompletionStatusType status )
		{
			Assertion = assertion;

			FromBusinessCheck = ( 0x02 == ( (int)status & 0x02 ) );
			ToBusinessCheck = ( 0x01 == ( (int)status & 0x01 ) );
		}
	}

	[ XmlRoot( "changeRecordSetAssertions", Namespace="urn:uddi-org:repl" ) ]
	public class ChangeRecordSetAssertions : ChangeRecordBase
	{
		[ XmlElement( "changeRecordPublisherAssertion" ) ]
		public ChangeRecordPublisherAssertionCollection Assertions;

		public override void Process( long LSN )
		{
			foreach( ChangeRecordPublisherAssertion assertion in Assertions )
				assertion.Process( LSN );
		}

		[ XmlIgnore ]
		public override UDDI.API.ChangeRecordPayloadType ChangeRecordPayloadType
		{
			get { return ChangeRecordPayloadType.ChangeRecordSetAssertions; }
		}
	}

	public class ChangeRecordCollection : CollectionBase
	{
		public ChangeRecord this[ int index ]
		{
			get{ return (ChangeRecord)List[ index ]; }
			set{ List[ index ] = value; }
		}
		
		public int Add( ChangeRecord changeRecord )
		{
			return List.Add( changeRecord );
		}
		
		public int Add()
		{
			return List.Add( new ChangeRecord() );
		}
		
		public void Insert( int index, ChangeRecord changeRecord )
		{
			List.Insert( index, changeRecord );
		}
	
		public int IndexOf( ChangeRecord changeRecord )
		{
			return List.IndexOf( changeRecord );
		}
		public bool Contains( ChangeRecord changeRecord )
		{
			return List.Contains( changeRecord );
		}
		public void Remove( ChangeRecord changeRecord )
		{
			List.Remove( changeRecord );
		}
		public void CopyTo( ChangeRecord[  ] array, int index )
		{
			InnerList.CopyTo( array, index );
		}
	}

	//
	// TODO: Consider renaming this class, the ChangeRecord... convention has become a bit confusing. 
	// Are things prefixed with "ChangeRecord" change records or is this just a prefix for
	// association of these classes into a collective group.
	//
	// Consider the use of a <ChangeRecord> namespace, maybe turning the semantic into
	// ChangeRecord.Correction
	// ChangeRecord.NewData
	// and maybe event ChangeRecord.Vector, which is a little better than current.
	//
	// The spec uses the terms HighWaterMark and HightWaterMarkVector 
	// I think these might be better choices.
	//

	public class ChangeRecordVector
	{
		//
		// Element: nodeID
		//
		[ XmlElement( "nodeID" ) ]
		public string NodeID;

		//
		// Element: originatingUSN
		//
		[ XmlElement( "originatingUSN" ) ]
		public long OriginatingUSN;

		public ChangeRecordVector()
		{
		}

		public ChangeRecordVector( string nodeID, long originatingUSN )
		{
			this.NodeID = nodeID;
			this.OriginatingUSN = originatingUSN;
		}
	}

	public class ChangeRecordVectorCollection : CollectionBase
	{
		public ChangeRecordVector this[ int index ]
		{
			get{ return (ChangeRecordVector)List[ index ]; }
			set{ List[ index ] = value; }
		}
		
		public int Add()
		{
			return List.Add( new ChangeRecordVector() );
		}
		
		public int Add( ChangeRecordVector vector )
		{
			return List.Add( vector );
		}

		public int Add( string nodeID, long originatingUSN )
		{
			return List.Add( new ChangeRecordVector( nodeID, originatingUSN ) );
		}

		public void Insert( int index, ChangeRecordVector vector )
		{
			List.Insert( index, vector );
		}
	
		public int IndexOf( ChangeRecordVector vector )
		{
			return List.IndexOf( vector );
		}
		
		public bool Contains( ChangeRecordVector vector )
		{
			return List.Contains( vector );
		}
		
		public void Remove( ChangeRecordVector vector )
		{
			List.Remove( vector );
		}
		
		public void CopyTo( ChangeRecordVector[  ] array, int index )
		{
			InnerList.CopyTo( array, index );
		}

		public bool IsProcessed( ChangeRecordVector changeID )
		{
			//
			// TODO: Consider. If you find Node id and OriginatingUSNs are not equal return false
			// avoiding checking the rest of the list
			//
			foreach( ChangeRecordVector vector in this )
			{
				if( 0 == String.Compare( changeID.NodeID, vector.NodeID, true ) && 
					changeID.OriginatingUSN <= vector.OriginatingUSN )
					return true;
			}

			return false;
		}

		public void MarkAsProcessed( ChangeRecordVector changeID )
		{
			foreach( ChangeRecordVector vector in this )
			{
				if( 0 == String.Compare( changeID.NodeID, vector.NodeID, true )  )
				{
					vector.OriginatingUSN = changeID.OriginatingUSN;
					return;
				}
			}
			
			this.Add( changeID );
		}
	}

	public class ChangeRecordPublisherAssertionCollection : CollectionBase
	{
		public ChangeRecordPublisherAssertion this[ int index ]
		{
			get{ return (ChangeRecordPublisherAssertion)List[ index ]; }
			set{ List[ index ] = value; }
		}
		
		public int Add()
		{
			return List.Add( new ChangeRecordPublisherAssertion() );
		}
		
		public int Add( ChangeRecordPublisherAssertion changeRecord )
		{
			return List.Add( changeRecord );
		}

		public void Insert( int index, ChangeRecordPublisherAssertion changeRecord )
		{
			List.Insert( index, changeRecord );
		}
	
		public int IndexOf( ChangeRecordPublisherAssertion changeRecord )
		{
			return List.IndexOf( changeRecord );
		}
		
		public bool Contains( ChangeRecordPublisherAssertion changeRecord )
		{
			return List.Contains( changeRecord );
		}
		
		public void Remove( ChangeRecordPublisherAssertion changeRecord )
		{
			List.Remove( changeRecord );
		}

		public void CopyTo( ChangeRecordPublisherAssertion[  ] array, int index )
		{
			InnerList.CopyTo( array, index );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\binding.cs ===
using System;
using System.Data;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;
using UDDI.Replication;
using UDDI.API.ServiceType;

namespace UDDI.API.Binding
{
	/// ****************************************************************
	///   class BindingTemplate
	///	----------------------------------------------------------------
	///	  <summary>
	///	  </summary>
	/// ****************************************************************
	/// 
	[XmlRootAttribute( "bindingTemplate", Namespace=UDDI.API.Constants.Namespace )]
	public class BindingTemplate : EntityBase
	{
		//
		// Attribute: bindingKey
		//
		[XmlAttribute("bindingKey")]
		public string BindingKey = "";

		//
		// Attribute: serviceKey
		// 
		[XmlAttribute("serviceKey")]
		public string ServiceKey = "";

		//
		// Element: description
		//		
		private DescriptionCollection descriptions;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		//
		// Element: accessPoint
		//		
		private AccessPoint accessPoint;

		[XmlElement("accessPoint")]
		public AccessPoint AccessPointSerialize
		{
			get
			{
				if( null != accessPoint && accessPoint.ShouldSerialize )
					return accessPoint;

				return null;
			}

			set	{ accessPoint = value; }
		}

		[XmlIgnore]
		public AccessPoint AccessPoint
		{
			get
			{
				if( null == accessPoint )
					accessPoint = new AccessPoint();

				return accessPoint;
			}
		}

		//
		// Element: hostingRedirector
		//		
		private HostingRedirector hostingRedirector;

		[XmlElement("hostingRedirector")]
		public HostingRedirector HostingRedirectorSerialize
		{
			get
			{
				if( null != hostingRedirector && hostingRedirector.ShouldSerialize )
					return hostingRedirector;

				return null;
			}

			set
			{
				hostingRedirector = value;
			}
		}

		[XmlIgnore]
		public HostingRedirector HostingRedirector
		{
			get
			{
				if( null == hostingRedirector )
					hostingRedirector = new HostingRedirector();

				return hostingRedirector;
			}
		}
		
		//
		// Element: tModelInstanceDetails
		//		
		private TModelInstanceInfoCollection tModelInstanceInfos;

		[ XmlArray( "tModelInstanceDetails" ), XmlArrayItem( "tModelInstanceInfo" ) ]
		public TModelInstanceInfoCollection TModelInstanceInfos
		{
			get 
			{
				if( null == tModelInstanceInfos )
					tModelInstanceInfos = new TModelInstanceInfoCollection();

				return tModelInstanceInfos;
			}

			set { tModelInstanceInfos = value; }
		}

		[XmlIgnore]
		public override UDDI.EntityType EntityType
		{
			get { return EntityType.BindingTemplate; }
		}

		[XmlIgnore]
		public override string EntityKey
		{
			get { return BindingKey; }
		}

		/// ****************************************************************
		///   public BindingTemplate [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public BindingTemplate()
		{
		}

		/// ****************************************************************
		///   public BindingTemplate [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="bindingKey">
		///   </param>
		/// ****************************************************************
		/// 
		public BindingTemplate( string bindingKey )
		{
			BindingKey = bindingKey;				
		}
		
		/// ****************************************************************
		///   public Delete
		///	----------------------------------------------------------------
		///	  <summary>
		///		Removes the specified bindingTemplate from the database.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <returns>
		///	  </returns>
		///	----------------------------------------------------------------
		///	  <remarks>
		///	    The bindingKey must be set prior to execution of this call.
		///	  </remarks>
		/// ****************************************************************
		/// 
		public override void Delete()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_bindingTemplate_delete" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@bindingKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );

			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetGuidFromString( "@bindingKey", BindingKey );
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			
			sp.ExecuteNonQuery();

			//
			// Save the change log entry.
			//
			if( Context.LogChangeRecords )
			{
				ChangeRecord changeRecord = new ChangeRecord();
				changeRecord.Payload = new ChangeRecordDelete( EntityType.BindingTemplate, BindingKey );
				changeRecord.Log();
			}
		}

		/// ****************************************************************
		///   public Get
		///	----------------------------------------------------------------
		///	  <summary>
		///		Retrieves the bindingTemplate details from the database.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <returns>
		///	  </returns>
		///	----------------------------------------------------------------
		///	  <remarks>
		///	    The bindingKey must be set prior to execution of this call.
		///	  </remarks>
		/// ****************************************************************
		/// 
		public override void Get()
		{			
			Debug.Enter();
			
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_bindingTemplate_get_batch" );
	
			sp.Parameters.Add( "@bindingKey",		 SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@serviceKey",		 SqlDbType.UniqueIdentifier,							 ParameterDirection.Output );
			sp.Parameters.Add( "@URLTypeID",		 SqlDbType.TinyInt,										 ParameterDirection.Output );
			sp.Parameters.Add( "@accessPoint",		 SqlDbType.NVarChar, UDDI.Constants.Lengths.AccessPoint, ParameterDirection.Output );
			sp.Parameters.Add( "@hostingRedirector", SqlDbType.UniqueIdentifier,							 ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@bindingKey", BindingKey );

			SqlDataReaderAccessor reader = null;
			ArrayList instanceIds = new ArrayList();

			try
			{
				//
				// net_bindingTemplate_get will return the objects contained in a business in the following order:
				//
				//	- descriptions
				//  - tmodel instance infos				
				reader = sp.ExecuteReader();

				//
				// Read the descriptions
				//
				Descriptions.Read( reader );
							
				//
				// Read the tmodel instance infos	
				//
				if( true == reader.NextResult() )
				{										
					instanceIds = TModelInstanceInfos.Read( reader );							
				}
			}
			finally
			{
				if( null != reader )
				{
					reader.Close();
				}
			}

			//
			// These calls will make separate sproc calls, so we have to close our reader first.
			//
			TModelInstanceInfos.Populate( instanceIds );
			
			//
			// Get output parameters
			//			
			ServiceKey					 = sp.Parameters.GetGuidString( "@serviceKey" );
			AccessPoint.URLType			 = (URLType)sp.Parameters.GetInt( "@URLTypeID" );
			AccessPoint.Value			 = sp.Parameters.GetString( "@accessPoint" );
			HostingRedirector.BindingKey = sp.Parameters.GetGuidString( "@hostingRedirector" );

#if never
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_bindingTemplate_get" );
	
			sp.Parameters.Add( "@bindingKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier, ParameterDirection.Output );
			sp.Parameters.Add( "@URLTypeID", SqlDbType.TinyInt, ParameterDirection.Output );
			sp.Parameters.Add( "@accessPoint", SqlDbType.NVarChar, UDDI.Constants.Lengths.AccessPoint, ParameterDirection.Output );
			sp.Parameters.Add( "@hostingRedirector", SqlDbType.UniqueIdentifier, ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@bindingKey", BindingKey );

			sp.ExecuteNonQuery();

			ServiceKey = sp.Parameters.GetGuidString( "@serviceKey" );
			AccessPoint.URLType = (URLType)sp.Parameters.GetInt( "@URLTypeID" );
			AccessPoint.Value = sp.Parameters.GetString( "@accessPoint" );
			HostingRedirector.BindingKey = sp.Parameters.GetGuidString( "@hostingRedirector" );

			//
			// Get all contained objects.
			//
			Descriptions.Get( BindingKey, EntityType.BindingTemplate );
			TModelInstanceInfos.Get( BindingKey );
#endif

			QueryLog.Write( QueryType.Get, EntityType.BindingTemplate );
		}

		/// ****************************************************************
		///   public InnerSave
		///	----------------------------------------------------------------
		///	  <summary>
		///		Stores the bindingTemplate details into the database.
		///	  </summary>
		/// ****************************************************************
		/// 
		internal void InnerSave( string serviceKey )
		{
			if( 0 == ServiceKey.Length )
				ServiceKey = serviceKey;
			else
				Debug.Verify( 0 == String.Compare( ServiceKey, serviceKey, true ), "UDDI_ERROR_INVALIDKEYPASSED_BINDINGPROJECTION", ErrorType.E_invalidKeyPassed );
			
			if( Utility.StringEmpty( BindingKey ) )
			{
				//
				// This is an insert so, generate a bindingkey
				//
				BindingKey = Guid.NewGuid().ToString();
			}

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_bindingTemplate_save" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@bindingKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@generic", SqlDbType.VarChar, UDDI.Constants.Lengths.generic );
			sp.Parameters.Add( "@URLTypeID", SqlDbType.TinyInt );
			sp.Parameters.Add( "@accessPoint", SqlDbType.NVarChar, UDDI.Constants.Lengths.AccessPoint );
			sp.Parameters.Add( "@hostingRedirector", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );

			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetGuidFromString( "@bindingKey", BindingKey );
			sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
			sp.Parameters.SetString( "@generic", Constants.Version );
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );

			if( null != AccessPoint )
			{
				sp.Parameters.SetShort( "@URLTypeID", (short)AccessPoint.URLType );
				sp.Parameters.SetString( "@accessPoint", AccessPoint.Value );
			}

			if( null != HostingRedirector )
				sp.Parameters.SetGuidFromString( "@hostingRedirector", HostingRedirector.BindingKey );

			sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );
			sp.ExecuteNonQuery();

			//
			// Save all contained objects.
			//
			Descriptions.Save( BindingKey, EntityType.BindingTemplate );
			TModelInstanceInfos.Save( BindingKey );
		}


		/// ****************************************************************
		///   internal Validate
		///	----------------------------------------------------------------
		///	  <summary>
		///	  </summary>
		/// ****************************************************************
		/// 
		internal void Validate()
		{
			//
			// Check to make sure that either the hosting redirector or the accessPoint were specified
			//
			if( Utility.StringEmpty( AccessPoint.Value ) && Utility.StringEmpty( HostingRedirector.BindingKey ) )
				throw new UDDIException( ErrorType.E_fatalError,"UDDI_ERROR_FATALERROR_BINDING_APVALUEMISSING"  );

			//
			// Check for a circular reference
			//
			if( 0 == String.Compare( BindingKey, HostingRedirector.BindingKey, true ) )
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_BINDING_HRSELFREFERENCE" );

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_bindingTemplate_validate" );
			
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@bindingKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@hostingRedirector", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@flag", SqlDbType.Int );
		
			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetGuidFromString( "@bindingKey", BindingKey );
			sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
			sp.Parameters.SetGuidFromString( "@hostingRedirector", HostingRedirector.BindingKey );
			if( Context.User.AllowPreassignedKeys )
				sp.Parameters.SetInt( "@flag", 1 );
			else
				sp.Parameters.SetInt( "@flag", 0 );

			sp.ExecuteNonQuery();

			//
			// Validate field length for AccessPoint.Value
			//
			Utility.ValidateLength( ref AccessPoint.Value, "accessPoint", UDDI.Constants.Lengths.AccessPoint );
			
			Descriptions.Validate();
			TModelInstanceInfos.Validate();
		}
		
		/// ****************************************************************
		///   public Save
		///	----------------------------------------------------------------
		///	  <summary>
		///		Stores the bindingTemplate details into the database, as a
		///		child of the service specified by the key.
		///	  </summary>
		/// ****************************************************************
		/// 
		public override void Save()
		{
			Validate();			
			InnerSave( this.ServiceKey );

			//
			// Save the change log entry.
			//
			if( Context.LogChangeRecords )
			{
				ChangeRecord changeRecord = new ChangeRecord();
				changeRecord.Payload = new ChangeRecordNewData( this );
				changeRecord.Log();
			}
		}
	}
	
	/// ********************************************************************
	///   public class BindingTemplateCollection
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class BindingTemplateCollection : CollectionBase
	{
		/// ****************************************************************
		///   public Get
		///	----------------------------------------------------------------
		///	  <summary>
		///		Populates the collection with all binding templates related to 
		///		the specified service.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="serviceKey">
		///		Key of the parent service. A Guid formatted as a string.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		
		///	  </returns>
		///	----------------------------------------------------------------
		///	  <remarks>
		///	    
		///	  </remarks>
		/// ****************************************************************
		/// 
		public void Get( string serviceKey )
		{
			//
			// Get all the bindings associated with the specified service
			// 
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_businessService_bindingTemplates_get" );
			
			cmd.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier, ParameterDirection.Input );
			cmd.Parameters.SetGuidFromString( "@serviceKey", serviceKey );
			
			SqlDataReaderAccessor reader = cmd.ExecuteReader();
			try
			{
				Read( reader );
#if never
				//
				// Get the keys of the services for this business ID
				//
				while( rdr.Read() )
				{
					Add( rdr.GetGuid(0).ToString() ); 
				}
#endif
			}
			finally
			{
				reader.Close();
			}

			Populate();
#if never
			//
			// Populate each binding
			//
			foreach( BindingTemplate bt in this )
			{
				bt.Get();
			}
#endif
		}

		public void Read( SqlDataReaderAccessor reader )
		{
			//
			// Get the keys of the services for this business ID
			//
			while( reader.Read() )
			{
				Add( reader.GetGuidString(0) ); 
			}
		}

		public void Populate()
		{
			//
			// Populate each binding
			//
			foreach( BindingTemplate bt in this )
			{
				bt.Get();
			}
		}

		/// ****************************************************************
		///   internal Validate
		///	----------------------------------------------------------------
		///	  <summary>
		///	  </summary>
		///	----------------------------------------------------------------
		///	  <remarks>
		///	  </remarks>
		/// ****************************************************************
		/// 
		internal void Validate()
		{
			foreach( BindingTemplate bt in this )
			{
				bt.Validate();
			}
		}
		
		/// ****************************************************************
		///   public Save
		///	----------------------------------------------------------------
		///	  <summary>
		///		Saves the contained binding templates. Relates them to 
		///		the service specified by the serviceKey argument.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="serviceKey">
		///		Key of the parent service. A Guid formatted as a string.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///	  </returns>
		///	----------------------------------------------------------------
		///	  <remarks>
		///	  This method simply calls the Save() method on all contained
		///	  BindingTemplates.
		///	  </remarks>
		/// ****************************************************************
		/// 
		public void Save( string serviceKey )
		{
			foreach( BindingTemplate bt in this )
			{
				bt.InnerSave( serviceKey );
			}
		}

		public void Save()
		{
			foreach( BindingTemplate bt in this )
			{
				bt.Save();
			}
		}

		public BindingTemplate this[ int index ]
		{
			get 
			{ return (BindingTemplate)List[index]; }
			set 
			{ List[index] = value; }
		}

		public int Add( BindingTemplate value )
		{
			return List.Add(value);
		}

		public int Add( string bindingKey )
		{
			return List.Add( new BindingTemplate( bindingKey ) );
		}

		public int Add()
		{
			return List.Add( new BindingTemplate() );
		}

		public void Insert(int index, BindingTemplate value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(BindingTemplate value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(BindingTemplate value)
		{
			return List.Contains(value);
		}

		public void Remove(BindingTemplate value)
		{
			List.Remove(value);
		}

		public void CopyTo( BindingTemplate[] array )
		{
			foreach( BindingTemplate binding in array )
				Add( binding );
		}

		public BindingTemplate[] ToArray()
		{
			return (BindingTemplate[])InnerList.ToArray( typeof( BindingTemplate ) );
		}
	}

	/// ****************************************************************
	///   class AccessPoint
	///	----------------------------------------------------------------
	///	  <summary>
	///		An AccessPoint describes the URL where services are available.
	///	  </summary>
	/// ****************************************************************
	/// 
	public class AccessPoint
	{
		// ----[Attribute: URLType]-----------------------------------------
		
		[XmlAttribute("URLType")]
		public URLType URLType;

		// ----[Element Text]-----------------------------------------------
				
		[XmlText]
		public string Value;

		public AccessPoint()
		{
			URLType = UDDI.API.URLType.Http;
		}

		public AccessPoint( string accessPointValue )
		{
			Value = accessPointValue;
		}

		[XmlIgnore]
		public bool ShouldSerialize
		{
			get
			{
				if( null != Value )
					return true;

				return false;
			}
		}
	}

	/// ****************************************************************
	///   class HostingRedirector
	///	----------------------------------------------------------------
	///	  <summary>
	///		A HostingRedirector describes a service location using another
	///		bindingTemplate.
	///	  </summary>
	/// ****************************************************************
	/// 
	public class HostingRedirector
	{
		// ----[Attribute: bindingKey]--------------------------------------------

		[XmlAttribute("bindingKey")]
		public string BindingKey;

		[XmlIgnore]
		public bool ShouldSerialize
		{
			get
			{
				if( null != BindingKey )
					return true;

				return false;
			}
		}
	}

	/// ****************************************************************
	///   class DeleteBinding
	///	----------------------------------------------------------------
	///	  <summary>
	///		The DeleteBinding class contains data and methods associated 
	///		with the delete_binding message. It is typically populated 
	///		via deserialization by the .NET runtime as part of the 
	///		message processing interface.
	///		
	///		As part of the publisher API, this message implements 
	///		IAuthenticateable. This allows the enclosed authInfo to be 
	///		authorized prior to processing
	///	  </summary>
	/// ****************************************************************
	/// 
	[XmlRootAttribute( "delete_binding", Namespace=UDDI.API.Constants.Namespace )]
	public class DeleteBinding : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
	
		//
		// Element: bindingKey
		//
		[XmlElement("bindingKey")]
		public StringCollection BindingKeys;

		public DeleteBinding()
		{
			Generic = UDDI.API.Constants.Version;
		}

		public void Delete()
		{
			foreach( string key in BindingKeys )
			{
				BindingTemplate bt = new BindingTemplate( key );
				bt.Delete();
			}
		}
	}

	[XmlRootAttribute("find_binding", Namespace=UDDI.API.Constants.Namespace)]
	public class FindBinding : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Attribute: maxRows
		//
		private int maxRows = -1;

		[XmlAttribute( "maxRows" ), DefaultValue( -1 )]
		public int MaxRows
		{
			get	{ return maxRows; }
			set	
			{
				if( value < 0 )
				{
					throw new UDDIException( 
						ErrorType.E_fatalError, 
						"UDDI_ERROR_FATALERROR_FINDBINDING_MAXROWSLESSTHANZERO" );
				}

				maxRows = value; 
			}
		}
	
		//
		// Attribute: serviceKey
		//
		[XmlAttribute("serviceKey")]
		public string ServiceKey;

		//
		// Element: findQualifiers/findQualifier
		//
		[XmlArray("findQualifiers"), XmlArrayItem("findQualifier")]
		public FindQualifierCollection FindQualifiers;

		//
		// Element: tModelBag/tModelKey
		//
		[XmlArray("tModelBag"), XmlArrayItem("tModelKey")]
		public StringCollection TModelBag;

		public FindBinding()
		{
			Generic = UDDI.API.Constants.Version;
		}

		public BindingDetail Find()
		{
			BindingDetail bindingDetail = new BindingDetail();

			QueryLog.Write( QueryType.Find, EntityType.BindingTemplate );

			//
			// Validate find parameters.
			//
			Utility.IsValidKey( EntityType.BusinessService, ServiceKey );

			//
			// Process each find constraint.
			//
			FindBuilder find = new FindBuilder( EntityType.BindingTemplate, FindQualifiers, ServiceKey );

			//
			// If no search arguments are specified, return an empty result
			// set.
			//
			if( Utility.CollectionEmpty( TModelBag ) )
				return bindingDetail;
			
			try
			{
				int rows = 1;

				//
				// Find entities with matching parent key.
				//
				if( !Utility.StringEmpty( ServiceKey ) )
					rows = find.FindByParentKey( ServiceKey );
				
				//
				// Find entities with matching TModel bag items.
				//
				if( !Utility.CollectionEmpty( TModelBag ) )
					rows = find.FindByTModelBag( TModelBag );
				
				//
				// Process the find result set.
				//
				if( 0 == rows )
				{
					//
					// Cleanup any temporary tables.
					//
					find.Abort();
				}
				else if( 0 == MaxRows )
				{
					bindingDetail.Truncated = Truncated.True;
					return bindingDetail;
				}
				else
				{
					//
					// Read in the find results.
					//
					SqlDataReaderAccessor reader;
					SqlStoredProcedureAccessor sp;
					sp = find.RetrieveResults( MaxRows );

					reader = sp.ExecuteReader();

					try
					{
						while( reader.Read() )
							bindingDetail.BindingTemplates.Add( reader.GetGuidString( "entityKey" ) );
					}
					finally
					{
						reader.Close();
					}

					if( sp.Parameters.GetBool( "@truncated" ) )
						bindingDetail.Truncated = Truncated.True;
					else
						bindingDetail.Truncated = Truncated.False;			

					foreach( BindingTemplate bindingTemplate in bindingDetail.BindingTemplates )
						bindingTemplate.Get();
				}
			}
			catch( Exception )
			{
				find.Abort();
				throw;
			}

			return bindingDetail;
		}
	}

	/// ********************************************************************
	///   public class GetBindingDetail
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "get_bindingDetail", Namespace=UDDI.API.Constants.Namespace )]
	public class GetBindingDetail : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: bindingKey
		//
		[XmlElement("bindingKey")]
		public StringCollection BindingKeys;

		public GetBindingDetail()
		{
		}
	}

	/// ********************************************************************
	///   public class SaveBinding
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "save_binding", Namespace=UDDI.API.Constants.Namespace )]
	public class SaveBinding : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
	
		//
		// Element: bindingTemplate
		//
		[XmlElement("bindingTemplate")]
		public BindingTemplateCollection BindingTemplates;

		/// ****************************************************************
		///   public Save
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public void Save()
		{
			BindingTemplates.Save();
		}
	}

	[XmlRoot("bindingDetail", Namespace=UDDI.API.Constants.Namespace)]
	public class BindingDetail
	{
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;

		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );

		[XmlAttribute("truncated")]
		public Truncated Truncated;

		[XmlElement("bindingTemplate")]
		public BindingTemplateCollection BindingTemplates = new BindingTemplateCollection();
		
		public void Get( StringCollection bindingKeys )
		{
			foreach( string key in bindingKeys )
			{
				int n = BindingTemplates.Add( key );
				BindingTemplates[ n ].Get();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\description.cs ===
using System;
using System.Data;
using System.Collections;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API
{
	public class Description
	{
		//
		// Attribute: xml:lang
		//
		private string isoLangCode;

		[XmlAttribute("xml:lang")]
		public string IsoLangCode
		{
			get { return isoLangCode; }
			set { isoLangCode = value; }
		}

		//
		// Text
		//
		[XmlText]
		public string Value;

		public Description()
		{
		}

		//
		// 741019 - use the UDDI site language if one is not specified.
		//
		public Description( string description ) : this( Config.GetString( "Setup.WebServer.ProductLanguage", "en" ) , description )
		{
		}

		public Description( string isoLangCode, string description )
		{
			IsoLangCode = isoLangCode;
			Value = description;
		}

		public void Save( long parentID, EntityType parentType )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			switch( parentType )
			{
				case EntityType.Contact:
					sp.ProcedureName = "net_contact_description_save";

					sp.Parameters.Add( "@contactID", SqlDbType.BigInt );
					sp.Parameters.SetLong( "@contactID", parentID );
					
					break;

				case EntityType.TModelInstanceInfo:
					sp.ProcedureName = "net_bindingTemplate_tModelInstanceInfo_description_save";

					sp.Parameters.Add( "@instanceID", SqlDbType.BigInt );
					sp.Parameters.SetLong( "@instanceID", parentID );
					
					break;

				case EntityType.InstanceDetail:
					sp.ProcedureName = "net_bindingTemplate_instanceDetails_description_save";

					sp.Parameters.Add( "@instanceID", SqlDbType.BigInt );
					sp.Parameters.SetLong( "@instanceID", parentID );

					break;

				case EntityType.InstanceDetailOverviewDoc:
					sp.ProcedureName = "net_bindingTemplate_instanceDetails_overviewDoc_description_save";

					sp.Parameters.Add( "@instanceID", SqlDbType.BigInt );
					sp.Parameters.SetLong( "@instanceID", parentID );

					break;
				
				default:
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_DESCRPTION_INVALIDPARENTTYPE" , parentType.ToString() );
			}

			sp.Parameters.Add( "@isoLangCode", SqlDbType.VarChar, UDDI.Constants.Lengths.IsoLangCode );
			sp.Parameters.Add( "@description", SqlDbType.NVarChar, UDDI.Constants.Lengths.Description );

			sp.Parameters.SetString( "@isoLangCode", IsoLangCode );
			sp.Parameters.SetString( "@description", Value );

			sp.ExecuteNonQuery();

			Debug.Leave();
		}

		public void Save( string parentKey, EntityType parentType )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			switch( parentType )
			{
				case EntityType.BusinessEntity:
					sp.ProcedureName = "net_businessEntity_description_save";

					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@businessKey", parentKey );

					break;

				case EntityType.BusinessService:
					sp.ProcedureName = "net_businessService_description_save";

					sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@serviceKey", parentKey );
					
					break;

				case EntityType.BindingTemplate:
					sp.ProcedureName = "net_bindingTemplate_description_save";

					sp.Parameters.Add( "@bindingKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@bindingKey", parentKey );
					
					break;

				case EntityType.TModel:
					sp.ProcedureName = "net_tModel_description_save";

					sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromKey( "@tModelKey", parentKey );
					
					break;

				case EntityType.TModelOverviewDoc:
					sp.ProcedureName = "net_tModel_overviewDoc_description_save";

					sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromKey( "@tModelKey", parentKey );
					
					break;

				default:
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_DESCRPTION_INVALIDPARENTTYPE" , parentType.ToString() );
			}

			sp.Parameters.Add( "@isoLangCode", SqlDbType.VarChar, UDDI.Constants.Lengths.IsoLangCode );
			sp.Parameters.Add( "@description", SqlDbType.NVarChar, UDDI.Constants.Lengths.Description );

			sp.Parameters.SetString( "@isoLangCode", IsoLangCode );
			sp.Parameters.SetString( "@description", Value );

			sp.ExecuteNonQuery();
			
			Debug.Leave();
		}
	}

	public class DescriptionCollection : CollectionBase
	{
		public DescriptionCollection()
		{
		}

		public void Get( int parentID, EntityType parentType )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			switch( parentType )
			{
				case EntityType.Contact:
					sp.ProcedureName = "net_contact_descriptions_get";

					sp.Parameters.Add( "@contactID", SqlDbType.BigInt );
					sp.Parameters.SetLong( "@contactID", parentID );
					
					break;

				case EntityType.TModelInstanceInfo:
					sp.ProcedureName = "net_bindingTemplate_tModelInstanceInfo_descriptions_get";

					sp.Parameters.Add( "@instanceID", SqlDbType.BigInt );
					sp.Parameters.SetLong( "@instanceID", parentID );
					
					break;

				case EntityType.InstanceDetail:
					sp.ProcedureName = "net_bindingTemplate_instanceDetails_descriptions_get";

					sp.Parameters.Add( "@instanceID", SqlDbType.BigInt );
					sp.Parameters.SetLong( "@instanceID", parentID );
					
					break;

				case EntityType.InstanceDetailOverviewDoc:
					sp.ProcedureName = "net_bindingTemplate_instanceDetails_overviewDoc_descriptions_get";

					sp.Parameters.Add( "@instanceID", SqlDbType.BigInt );
					sp.Parameters.SetLong( "@instanceID", parentID );
					
					break;
				
				default:
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_DESCRPTION_INVALIDPARENTTYPE" , parentType.ToString() );
			}
			
			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				Read( reader );
#if never
				while( reader.Read() )
				{
					Add( reader.GetString( "isoLangCode" ), 
						reader.GetString( "description" ) );
				}
#endif
			}
			finally
			{
				reader.Close();
			}

			Debug.Leave();
		}

		public void Get( string parentKey, EntityType parentType )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			switch( parentType )
			{
				case EntityType.BusinessEntity:
					sp.ProcedureName = "net_businessEntity_descriptions_get";

					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@businessKey", parentKey );

					break;

				case EntityType.BusinessService:
					sp.ProcedureName = "net_businessService_descriptions_get";

					sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@serviceKey", parentKey );
					
					break;

				case EntityType.BindingTemplate:
					sp.ProcedureName = "net_bindingTemplate_descriptions_get";

					sp.Parameters.Add( "@bindingKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@bindingKey", parentKey );
					
					break;

				case EntityType.TModel:
					sp.ProcedureName = "net_tModel_descriptions_get";

					sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromKey( "@tModelKey", parentKey );
					
					break;

				case EntityType.TModelOverviewDoc:
					sp.ProcedureName = "net_tModel_overviewDoc_descriptions_get";

					sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromKey( "@tModelKey", parentKey );
					
					break;

				default:
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_DESCRPTION_INVALIDPARENTTYPE", parentType.ToString() );
			}

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				Read( reader );
#if never
				while( reader.Read() )
				{
					Add( reader.GetString( "isoLangCode" ), 
						reader.GetString( "description" ) );
				}
#endif
			}
			finally
			{
				reader.Close();
			}

			Debug.Leave();
		}

		public void Read( SqlDataReaderAccessor reader )
		{
			while( reader.Read() )
			{
				Add( reader.GetString( "isoLangCode" ), 
					reader.GetString( "description" ) );
			}
		}

		internal void Validate()
		{
			int maxLength = UDDI.Constants.Lengths.Description;
			int count = this.Count;
			bool languageAssigned = false;

			for( int i = 0; i < count; i ++ )
			{
				//
				// Validate the description string length.
				//
				Utility.ValidateLength( ref this[ i ].Value, "description", maxLength );
				
				//
				// Validate the language code.  If one was not specified,
				// we'll use the publisher's default language.
				//
				if( Utility.StringEmpty( this[ i ].IsoLangCode ) )
				{
					//
					// Only one description can have an unassigned language.
					//
					if( languageAssigned )
					{
						throw new UDDIException( 
							ErrorType.E_languageError, 
							"UDDI_ERROR_LANGUAGEERROR_MULTIPLEBLANKLANG" );
					}

					languageAssigned = true;

					//
					// Fix: Bug 2340 9/9/2002, creeves
					//

					//					if( i > 0 )
					//					{
					//						throw new UDDIException( 
					//							ErrorType.E_languageError, 
					//							"Only the first description can have a blank or missing xml:lang attribute.  All other descriptions must have a valid xml:lang attribute." );
					//					}

					this[ i ].IsoLangCode = Context.User.IsoLangCode;
				}
			}

			//
			// Fix: Bug 2397, 9/16/2002, a-kirkma
			//
			// Split loops and fill in default IsoLangCode first (if needed), 
			// then look for repeated languages
			//
			for( int i = 0; i < count; i ++ )
			{
				//
				// Check to make sure there is only one description
				// per language.
				//
				string isoLangCode = this[ i ].IsoLangCode;

				Debug.Write( SeverityType.Info, CategoryType.Data, "Description[" + i + "]: " + this[ i ].Value + ", IsoLangCode: " + isoLangCode );

				for( int j = i + 1; j < count; j ++ )
				{
					if (false == Utility.StringEmpty(this[ j ].IsoLangCode)
					 && isoLangCode.ToLower() == this[ j ].IsoLangCode.ToLower() )
					{
						Debug.Write( SeverityType.Info, CategoryType.Data, "Error: Description[" + j + "]: " + this[ j ].Value + ", IsoLangCode " + this[ j ].IsoLangCode + " matches IsoLangCode[" + i + "]: " + isoLangCode );

						throw new UDDIException( 
							ErrorType.E_languageError, 
							"UDDI_ERROR_LANGUAGEERROR_MULTIPLESAMELANG",isoLangCode );
					}
				}
			}
		}
		
		public void Save( long ID, EntityType parentType )
		{
			Debug.Enter();

			foreach( Description desc in this )
				desc.Save( ID, parentType );

			Debug.Leave();
		}

		public void Save( string key, EntityType parentType )
		{
			Debug.Enter();

			foreach( Description desc in this )
				desc.Save( key, parentType );

			Debug.Leave();
		}

		public Description this[int index]
		{
			get 
			{ return (Description)List[index]; }
			set 
			{ List[index] = value; }
		}

		public int Add(Description value)
		{
			return List.Add(value);
		}

		public int Add(string value)
		{
			return List.Add( new Description(value) );
		}

		public int Add(string isoLangCode, string description)
		{
			return List.Add( new Description(isoLangCode, description) );
		}

		public void Insert(int index, Description value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf(Description value)
		{
			return List.IndexOf(value);
		}
		
		public bool Contains(Description value)
		{
			return List.Contains(value);
		}
		
		public void Remove(Description value)
		{
			List.Remove(value);
		}
		
		public void CopyTo(Description[] array, int index)
		{
			List.CopyTo(array, index);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\assertion.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI.Replication;
using UDDI;
using UDDI.API;
using UDDI.Diagnostics;

namespace UDDI.API.Business
{
	/// ********************************************************************
	///   public class PublisherAssertion
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class PublisherAssertion
	{
		[XmlElement( "fromKey" )]
		public string FromKey
		{
			get
			{
				return fromkey;
			}
			set
			{
				if( null == value )
					fromkey = null;
				else
					fromkey = value.Trim();
			}
		}
		string fromkey;

		[XmlElement( "toKey" )]
		public string ToKey
		{
			get
			{
				return tokey;
			}
			set
			{
				if( null == value )
					tokey = null;
				else
					tokey = value.Trim();
			}
		}
		string tokey;


		//
		// Element: keyedReference
		//
		private KeyedReference keyedReference;
 
		[XmlElement( "keyedReference" )]
		public KeyedReference KeyedReference
		{
			get 
			{ 
				if( null == keyedReference )
					keyedReference = new KeyedReference();

				return keyedReference; 
			}

			set { keyedReference = value; }
		}

		/// ****************************************************************
		///   public PublisherAssertion [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public PublisherAssertion()
		{
		}

		/// ****************************************************************
		///   public PublisherAssertion [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="assertion">
		///   </param>
		/// ****************************************************************
		/// 
		public PublisherAssertion( PublisherAssertion assertion )
		{
			this.FromKey = assertion.FromKey;
			this.ToKey = assertion.ToKey;
			this.KeyedReference = assertion.KeyedReference;
		}

		/// ****************************************************************
		///   public PublisherAssertion [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="fromKey">
		///   </param>
		///   
		///   <param name="toKey">
		///   </param>
		///   
		///   <param name="keyedReference">
		///   </param>
		/// ****************************************************************
		/// 
		public PublisherAssertion( string fromKey, string toKey, KeyedReference keyedReference )
		{
			this.FromKey = fromKey;
			this.ToKey = toKey;
			this.KeyedReference = keyedReference;
		}

		/// ****************************************************************
		///   public PublisherAssertion [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="fromKey">
		///   </param>
		///   
		///   <param name="toKey">
		///   </param>
		///   
		///   <param name="keyedReference">
		///   </param>
		/// ****************************************************************
		/// 
		public PublisherAssertion( string fromKey, string toKey, string keyName, string keyValue, string tModelKey )
		{
			this.FromKey = fromKey;
			this.ToKey = toKey;
			this.KeyedReference = new KeyedReference( keyName, keyValue, tModelKey );
		}

		public void Save()
		{
			Save( CompletionStatusType.Uninitialized );
		}

		public void Save( CompletionStatusType status )
		{
			Debug.Enter();

			Validate();
			
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_publisher_assertion_save" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@fromKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@toKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@keyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyName );
			sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@flag", SqlDbType.Int, ParameterDirection.InputOutput );

			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetGuidFromString( "@fromKey", FromKey );
			sp.Parameters.SetGuidFromString( "@toKey", ToKey );
			sp.Parameters.SetString( "@keyName", KeyedReference.KeyName );
			sp.Parameters.SetString( "@keyValue", KeyedReference.KeyValue );
			sp.Parameters.SetGuidFromKey( "@tModelKey", KeyedReference.TModelKey );

			if( CompletionStatusType.Uninitialized == status )
				sp.Parameters.SetNull( "@flag" );
			else
				sp.Parameters.SetInt( "@flag", (int)status );

			try
			{
				sp.ExecuteNonQuery();

				int flag = sp.Parameters.GetInt( "@flag" );

				if( Context.LogChangeRecords )
				{
					ChangeRecord changeRecord = new ChangeRecord();

					changeRecord.Payload = new ChangeRecordPublisherAssertion( this, (CompletionStatusType)flag );
					changeRecord.Log();
				}
			}
			catch( SqlException sqlException )
			{
				//
				// As per IN 60, we have to silently ignore assertions that reference keys to businesses that no longer
				// exist.
				//					
				if( sqlException.Number - UDDI.Constants.ErrorTypeSQLOffset == ( int ) ErrorType.E_invalidKeyPassed &&					
					Context.ContextType == ContextType.Replication )
				{
					//
					// Set our exception source
					//
					Context.ExceptionSource = ExceptionSource.PublisherAssertion;
				}
				else
				{
					Context.ExceptionSource = ExceptionSource.Other;
				}

				//
				// Re-throw the exception so replication can properly log it.
				//
				throw sqlException;				
			}

			Debug.Leave();
		}

		public void Delete()
		{
			Delete( CompletionStatusType.Uninitialized );
		}

		public void Delete( CompletionStatusType status )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_publisher_assertion_delete" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@fromKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@toKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@keyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyName );
			sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@flag", SqlDbType.Int, ParameterDirection.InputOutput );
			
			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetGuidFromString( "@fromKey", FromKey );
			sp.Parameters.SetGuidFromString( "@toKey", ToKey );
			sp.Parameters.SetString( "@keyName", KeyedReference.KeyName );
			sp.Parameters.SetString( "@keyValue", KeyedReference.KeyValue );
			sp.Parameters.SetGuidFromKey( "@tModelKey", KeyedReference.TModelKey );

			if( CompletionStatusType.Uninitialized == status )
				sp.Parameters.SetNull( "@flag" );
			else
				sp.Parameters.SetInt( "@flag", (int)status );

			try
			{
				sp.ExecuteNonQuery();

				int flag = sp.Parameters.GetInt( "@flag" );

				if( Context.LogChangeRecords )
				{
					ChangeRecord changeRecord = new ChangeRecord();

					changeRecord.Payload = new ChangeRecordDeleteAssertion( this, (CompletionStatusType)flag );
					changeRecord.Log();
				}
			}
			catch( SqlException sqlException )
			{
				//
				// As per IN 60, we have to silently ignore assertions that reference keys to businesses that no longer
				// exist, or assertions that don't exist at all.
				//					
				int exceptionNumber = sqlException.Number - UDDI.Constants.ErrorTypeSQLOffset;
				if( ( exceptionNumber == ( int ) ErrorType.E_invalidKeyPassed || exceptionNumber == ( int ) ErrorType.E_assertionNotFound ) &&		
					  Context.ContextType == ContextType.Replication )
				{
					//
					// Set our exception source
					//
					Context.ExceptionSource = ExceptionSource.PublisherAssertion;
				}
				else
				{
					Context.ExceptionSource = ExceptionSource.Other;
				}

				//
				// Re-throw the exception so replication can properly log it.
				//
				throw sqlException;			
			}
			Debug.Leave();
		}

		internal void Validate()
		{
			//
			// Check to make sure publisher's limit allows save of this
			// entity.  If this is an update, we won't check since they
			// are simply replacing an existing entity.  We also won't
			// check if the limit is 0, since this indicates unlimited
			// publishing rights.
			//
			int limit = Context.User.AssertionLimit;
			int count = Context.User.AssertionCount;

			if( 0 != limit && Utility.StringEmpty( FromKey ) )
			{				
				//
				// Verify that the publisher has not exceeded their limit.
				//
				if( count >= limit )
				{
					throw new UDDIException( 
						ErrorType.E_accountLimitExceeded,
						"UDDI_ERROR_ACCOUNTLIMITEXCEEDED_ASSERTION",
						limit,
						count 
					);
				}
			}

			KeyedReference.Validate( null, KeyedReferenceType.Assertion );
		}
	}

	/// ********************************************************************
	///   public class PublisherAssertionCollection
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class PublisherAssertionCollection : CollectionBase
	{
		public string Get()
		{
			string AuthorizedName;
			
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_publisher_assertions_get" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@authorizedName", SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName, ParameterDirection.Output);

			sp.Parameters.SetString( "@PUID", Context.User.ID );

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				while( reader.Read() )
				{
					Add(
						reader.GetGuidString( "fromKey" ),
						reader.GetGuidString( "toKey" ),
						reader.GetGuidString( "keyName" ),
						reader.GetGuidString( "keyValue" ),
						reader.GetKeyFromGuid( "tModelKey" ) );
				}
			}
			finally
			{
				reader.Close();
			}
			AuthorizedName =  sp.Parameters.GetString( "@authorizedName" );
			return AuthorizedName;
		}
		
		public void Delete()
		{
			Debug.Enter();

			foreach( PublisherAssertion assertion in this )
				assertion.Delete();

			Debug.Leave();
		}
		
		public void Save()
		{
			Debug.Enter();

			Validate();

			foreach( PublisherAssertion assertion in this )
				assertion.Save();

			Debug.Leave();
		}

		internal void Validate()
		{
			foreach( PublisherAssertion assertion in this )
				assertion.Validate();
		}

		public PublisherAssertion this[ int index ]
		{
			get { return (PublisherAssertion)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new PublisherAssertion() );
		}

		public int Add( PublisherAssertion value )
		{
			return List.Add( value );
		}

		public int Add( string fromKey, string toKey, KeyedReference keyedReference )
		{
			return List.Add( new PublisherAssertion( fromKey, toKey, keyedReference ) );
		}
		
		public int Add( string fromKey, string toKey, string keyName, string keyValue, string tModelKey )
		{
			return List.Add( new PublisherAssertion( fromKey, toKey, keyName, keyValue, tModelKey ) );
		}
		
		public void Insert( int index, PublisherAssertion value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( PublisherAssertion value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( PublisherAssertion value )
		{
			return List.Contains( value );
		}

		public void Remove( PublisherAssertion value )
		{
			List.Remove( value );
		}

		public void CopyTo( PublisherAssertion[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}

	/// ********************************************************************
	///   public class PublisherAssertionDetail
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "publisherAssertions", Namespace=UDDI.API.Constants.Namespace )]
	public class PublisherAssertionDetail
	{
		//
		// Attribute: generic
		//
		private string generic = Constants.Version;

		[XmlAttribute( "generic" )]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}
	
		//
		// Attribute: operator
		//
		[XmlAttribute( "operator" )]
		public string OperatorName = Config.GetString( "Operator" );

		//
		// Attribute: authorizedName
		//
		[XmlAttribute( "authorizedName" )]
		public string AuthorizedName;

		//
		// Element: publisherAssertion
		//
		private PublisherAssertionCollection publisherAssertions;

		[XmlElement( "publisherAssertion" )]
		public PublisherAssertionCollection PublisherAssertions
		{
			get
			{
				if( null == publisherAssertions )
					publisherAssertions = new PublisherAssertionCollection();

				return publisherAssertions;
			}

			set { publisherAssertions = value; }
		}

		public PublisherAssertionDetail()
		{
		}

		public void Get()
		{
			AuthorizedName = PublisherAssertions.Get();
		}
	}
	
	/// ********************************************************************
	///   public class AssertionStatusReport
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "assertionStatusReport", Namespace=UDDI.API.Constants.Namespace )]
	public class AssertionStatusReport
	{
		//
		// Attribute: generic
		//
		private string generic = Constants.Version;
		
		[XmlAttribute( "generic" )]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Attribute: operator
		//
		[XmlAttribute( "operator" )]
		public string OperatorName = Config.GetString( "Operator" );

		//
		// Element: assertionStatusItem
		//
		private AssertionStatusItemCollection assertionStatusItems;

		[XmlElement( "assertionStatusItem" )]
		public AssertionStatusItemCollection AssertionStatusItems
		{
			get
			{
				if( null == assertionStatusItems )
					assertionStatusItems = new AssertionStatusItemCollection();

				return assertionStatusItems;
			}

			set { assertionStatusItems = value; }
		}

		public AssertionStatusReport()
		{
		}

		public void Get( CompletionStatusType completionStatus )
		{
			AssertionStatusItems.Get( completionStatus );
		}
	}

	/// ********************************************************************
	///   public class AssertionStatusItem
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class AssertionStatusItem
	{
		//
		// Attribute: completionStatus
		//
		[XmlAttribute( "completionStatus" )]
		public CompletionStatusType CompletionStatus;

		//
		// Element: fromKey
		//
		[XmlElement( "fromKey" )]
		public string FromKey;
	
		//
		// Element: toKey
		//
		[XmlElement( "toKey" )]
		public string ToKey;
	
		//
		// Element: keyedReference
		//
		private KeyedReference keyedReference;

		[XmlElement( "keyedReference" )]
		public KeyedReference KeyedReference
		{
			get { return keyedReference; }
			set { keyedReference = value; }
		}

		//
		// Element: keysOwned
		//
		private KeysOwned keysOwned;

		[XmlElement( "keysOwned" )]
		public KeysOwned KeysOwned
		{
			get
			{
				if( null == keysOwned )
					keysOwned = new KeysOwned();

				return keysOwned;
			}

			set { keysOwned = value; }
		}

		public AssertionStatusItem()
		{
		}

		public AssertionStatusItem( CompletionStatusType completionStatus, string fromKey, string toKey, KeyedReference keyedReference, KeysOwned keysOwned )
		{
			this.CompletionStatus = completionStatus;
			this.FromKey = fromKey;
			this.ToKey = toKey;
			this.KeyedReference = keyedReference;
			this.KeysOwned = keysOwned;
		}
	}

	/// ********************************************************************
	///   public class AssertionStatusItemCollection
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class AssertionStatusItemCollection : CollectionBase
	{
		public void Get( CompletionStatusType completionStatus )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_publisher_assertionStatus_get" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.SetString( "@PUID", Context.User.ID );

			if( CompletionStatusType.Uninitialized != completionStatus )
			{
				//
				// If the completion status was not specified get all
				// of the assertions by not specifying a completionStatus value
				// in the stored procedure.
				//
				sp.Parameters.Add( "@completionStatus", SqlDbType.Int );
				sp.Parameters.SetInt( "@completionStatus", (int)completionStatus );
			}

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				while( reader.Read() )
				{
					KeyedReference keyedReference = new KeyedReference(
						reader.GetString( "keyName" ), 
						reader.GetString( "keyValue" ), 
						reader.GetKeyFromGuid( "tModelKey" ) );

					CompletionStatusType status =
						(CompletionStatusType)reader.GetInt( "flag" );

					string fromKey = reader.GetGuidString( "fromKey" );
					string toKey = reader.GetGuidString( "toKey" );

					int ownerFlag = reader.GetInt( "ownerFlag" );
					
					KeysOwned keysOwned = new KeysOwned();

					if( 0x02 == ( ownerFlag & 0x02 ) )
						keysOwned.FromKey = fromKey;
					
					if( 0x01 == ( ownerFlag & 0x01 ) )
						keysOwned.ToKey = toKey;

					this.Add(
						new AssertionStatusItem(
						status,
						fromKey,
						toKey,
						keyedReference,
						keysOwned ) );
				}
			}
			finally
			{
				reader.Close();
			}
		}

		public AssertionStatusItem this[ int index ]
		{
			get { return (AssertionStatusItem)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new AssertionStatusItem() );
		}

		public int Add( AssertionStatusItem value )
		{
			return List.Add( value );
		}
	
		public void Insert( int index, AssertionStatusItem value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( AssertionStatusItem value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( AssertionStatusItem value )
		{
			return List.Contains( value );
		}

		public void Remove( AssertionStatusItem value )
		{
			List.Remove( value );
		}

		public void CopyTo( AssertionStatusItem[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}

	/// ********************************************************************
	///   public class KeysOwned
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class KeysOwned
	{
		//
		// Element: fromKey
		//
		[XmlElement( "fromKey" )]
		public string FromKey;
		
		//
		// Element: toKey
		//
		[XmlElement( "toKey" )]
		public string ToKey;

		public KeysOwned()
		{
		}

		public KeysOwned( string fromKey, string toKey )
		{
			this.FromKey = fromKey;
			this.ToKey = toKey;
		}
	}

	public enum DirectionType
	{
		[XmlEnum( "fromKey" )]
		FromKey,
		[XmlEnum( "toKey" )]
		ToKey
	}

	public class RelatedBusinessInfo
	{
		//
		// Element: businessKey
		//
		[XmlElement( "businessKey" )]
		public string BusinessKey;

		//
		// Element: name
		//
		private NameCollection names;

		[XmlElement( "name" )]
		public NameCollection Names
		{
			get
			{
				if( null == names )
					names = new NameCollection();

				return names;
			}

			set { names = value; }
		}

		//
		// Element: description
		//
		private DescriptionCollection descriptions;

		[XmlElement( "description" )]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		//
		// Element: sharedRelationships
		//

		[XmlIgnore()]
		public SharedRelationships SharedRelationshipsFrom = new SharedRelationships();

		[XmlIgnore()]
		public SharedRelationships SharedRelationshipsTo = new SharedRelationships();

		[XmlElement( "sharedRelationships" )]
		public string sharedRelationshipEmptyTag
		{
			get
			{ 
				if( 0 == SharedRelationshipsSerialize.Count )
					return "";
				else
					return null;
			}
		}

		[XmlElement( "sharedRelationships" )]
		public SharedRelationshipsCollection SharedRelationshipsSerialize
		{
			get
			{
				SharedRelationshipsCollection col = new SharedRelationshipsCollection();

				if( !SharedRelationshipsFrom.IsEmpty() )
					col.Add( SharedRelationshipsFrom );

				if( !SharedRelationshipsTo.IsEmpty() )
					col.Add( SharedRelationshipsTo );

				return col;
			}
			set
			{
				foreach( SharedRelationships sr in value )
				{
					switch( sr.Direction )
					{
						case DirectionType.FromKey:
							SharedRelationshipsFrom = sr;
							break;
						case DirectionType.ToKey:
							SharedRelationshipsTo = sr;
							break;
					}
				}
			}
		}

		public RelatedBusinessInfo()
		{
		}

		public RelatedBusinessInfo( string businessKey )
		{
			this.BusinessKey = businessKey;
		}

		public void Get( string otherKey )
		{
			Names.Get( BusinessKey, EntityType.BusinessEntity );
			Descriptions.Get( BusinessKey, EntityType.BusinessEntity );

			//
			// Get the shared relationships.
			//
			SharedRelationshipsFrom.Direction = DirectionType.FromKey;
			SharedRelationshipsFrom.Get( otherKey, BusinessKey );

			SharedRelationshipsTo.Direction = DirectionType.ToKey;
			SharedRelationshipsTo.Get( BusinessKey, otherKey );
		}
	}

	public class RelatedBusinessInfoCollection : CollectionBase
	{
		public RelatedBusinessInfo this[ int index ]
		{
			get { return (RelatedBusinessInfo)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new RelatedBusinessInfo() );
		}

		public int Add( RelatedBusinessInfo relatedBusinessInfo )
		{
			return List.Add( relatedBusinessInfo );
		}
	
		public int Add( string businessKey )
		{
			return List.Add( new RelatedBusinessInfo( businessKey ) );
		}

		public void Insert( int index, RelatedBusinessInfo relatedBusinessInfo )
		{
			List.Insert( index, relatedBusinessInfo );
		}

		public int IndexOf( RelatedBusinessInfo relatedBusinessInfo )
		{
			return List.IndexOf( relatedBusinessInfo );
		}

		public bool Contains( RelatedBusinessInfo relatedBusinessInfo )
		{
			return List.Contains( relatedBusinessInfo );
		}

		public void Remove( RelatedBusinessInfo relatedBusinessInfo )
		{
			List.Remove( relatedBusinessInfo );
		}

		public void CopyTo( RelatedBusinessInfo[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}

	public class SharedRelationshipsCollection : CollectionBase
	{
		public SharedRelationships this[ int index ]
		{
			get { return (SharedRelationships)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new SharedRelationships() );
		}

		public int Add( SharedRelationships SharedRelationships )
		{
			return List.Add( SharedRelationships );
		}
	
		public int Add( string businessKey )
		{
			return List.Add( new SharedRelationships() );
		}

		public void Insert( int index, SharedRelationships SharedRelationships )
		{
			List.Insert( index, SharedRelationships );
		}

		public int IndexOf( SharedRelationships SharedRelationships )
		{
			return List.IndexOf( SharedRelationships );
		}

		public bool Contains( SharedRelationships SharedRelationships )
		{
			return List.Contains( SharedRelationships );
		}

		public void Remove( SharedRelationships SharedRelationships )
		{
			List.Remove( SharedRelationships );
		}

		public void CopyTo( SharedRelationships[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}
	
	public class SharedRelationships
	{
		//
		// Attribute: direction
		//
		[XmlAttribute( "direction" )]
		public DirectionType Direction;

		//
		// Element: keyedReference
		//
		private KeyedReferenceCollection keyedReferences;

		[XmlIgnore]
		public KeyedReferenceCollection KeyedReferences
		{
			get 
			{
				if( null == keyedReferences )
					keyedReferences = new KeyedReferenceCollection();

				return keyedReferences;
			}
			set { keyedReferences = value; }
		}

		[XmlElement( "keyedReference" )]
		public KeyedReferenceCollection KeyedReferencesSerialize
		{
			get 
			{
				return keyedReferences;
			}
			set { keyedReferences = value; }
		}

		public bool IsEmpty()
		{
			return (keyedReferences == null);
		}
		
		public SharedRelationships()
		{
		}

		public void Get( string fromKey, string toKey )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_businessEntity_assertions_get";

			sp.Parameters.Add( "@fromKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@toKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@completionStatus", SqlDbType.Int );

			sp.Parameters.SetGuidFromString( "@fromKey", fromKey );
			sp.Parameters.SetGuidFromString( "@toKey", toKey );
			sp.Parameters.SetInt( "@completionStatus", (int)CompletionStatusType.Complete );

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				while( reader.Read() )
				{
					KeyedReferences.Add(
						reader.GetString( "keyName" ),
						reader.GetString( "keyValue" ),
						reader.GetKeyFromGuid( "tModelKey" ) );
				}
			}
			finally
			{
				reader.Close();
			}
		}
	}

	[XmlRoot( "relatedBusinessesList", Namespace=UDDI.API.Constants.Namespace )]
	public class RelatedBusinessList
	{
		//
		// Attribute: generic
		//
		[XmlAttribute( "generic" )]
		public string Generic = Constants.Version;
	
		//
		// Attribute: operator
		//
		[XmlAttribute( "operator" )]
		public string OperatorName = Config.GetString( "Operator" );

		//
		// Attribute: truncated
		//
		[XmlAttribute( "truncated" )]
		public Truncated Truncated;

		//
		// Element: businessKey
		//
		[XmlElement( "businessKey" )]
		public string BusinessKey;

		//
		// Element: relatedBusinessInfos
		//
		private RelatedBusinessInfoCollection relatedBusinessInfos;

		[ XmlArray( "relatedBusinessInfos" ), XmlArrayItem( "relatedBusinessInfo" ) ]
		public RelatedBusinessInfoCollection RelatedBusinessInfos
		{
			get
			{
				if( null == relatedBusinessInfos )
					relatedBusinessInfos = new RelatedBusinessInfoCollection();

				return relatedBusinessInfos;
			}

			set { relatedBusinessInfos = value; }
		}
	}

	/// ********************************************************************
	///   public class AddPublisherAssertions
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "add_publisherAssertions", Namespace=UDDI.API.Constants.Namespace )]
	public class AddPublisherAssertions : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute( "generic" )]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;
	
		[XmlElement( "authInfo" )]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}

		//
		// Element: publisherAssertion
		//
		private PublisherAssertionCollection publisherAssertions;
	
		[XmlElement( "publisherAssertion" )]
		public PublisherAssertionCollection PublisherAssertions
		{
			get
			{
				if( null == publisherAssertions )
					publisherAssertions = new PublisherAssertionCollection();

				return publisherAssertions;
			}

			set { publisherAssertions = value; }
		}

		public AddPublisherAssertions()
		{
		}

		public void Save()
		{
			PublisherAssertions.Save();
		}
	}

	/// ********************************************************************
	///   public class DeletePublisherAssertions
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "delete_publisherAssertions", Namespace=UDDI.API.Constants.Namespace )]
	public class DeletePublisherAssertions : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute( "generic" )]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;
	
		[XmlElement( "authInfo" )]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}

		//
		// Element: publisherAssertion
		//
		private PublisherAssertionCollection publisherAssertions;

		[XmlElement( "publisherAssertion" )]
		public PublisherAssertionCollection PublisherAssertions
		{
			get 
			{ 
				if( null == publisherAssertions )
					publisherAssertions = new PublisherAssertionCollection();

				return publisherAssertions;
			}

			set { publisherAssertions = value; }
		}

		public DeletePublisherAssertions()
		{
		}

		public void Delete()
		{
			PublisherAssertions.Delete();
		}
	}
	
	/// ********************************************************************
	///   public class FindRelatedBusinesses
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "find_relatedBusinesses", Namespace=UDDI.API.Constants.Namespace )]
	public class FindRelatedBusinesses : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute( "generic" )]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Attribute: maxRows
		//
		private int maxRows = Config.GetInt( "Find.MaxRowsDefault" );

		[XmlAttribute("maxRows")]
		public int MaxRows
		{
			get 
			{
				return maxRows;
			}
			
			set 
			{ 
				maxRows = Math.Min( Config.GetInt( "Find.MaxRowsDefault" ), value );
			}
		}

		//
		// Element: findQualifiers/findQualifier
		//
		private FindQualifierCollection findQualifiers;

		[XmlArray( "findQualifiers" ), XmlArrayItem( "findQualifier" )]
		public FindQualifierCollection FindQualifiers
		{
			get
			{
				if( null == findQualifiers )
					findQualifiers = new FindQualifierCollection();

				return findQualifiers;
			}

			set { findQualifiers = value; }
		}

		//
		// Element: businessKey
		//
		[XmlElement( "businessKey" )]
		public string BusinessKey;

		//
		// Element: keyedReference
		//
		[XmlElement( "keyedReference" )]
		public KeyedReference KeyedReference;

		/// ****************************************************************
		///   public FindRelatedBusinesses [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public FindRelatedBusinesses()
		{
		}
		
		/// ****************************************************************
		///   public Find
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public RelatedBusinessList Find()
		{
			if( MaxRows < 0 )
			{
				throw new UDDIException( 
					ErrorType.E_fatalError, 
					"UDDI_ERROR_FATALERROR_FINDRELATEDBE_MAXROWSLESSTHANZERO" );
			}

			RelatedBusinessList relatedBusinessList = new RelatedBusinessList();

			//
			// Process each find constraint.
			//
			FindBuilder find = new FindBuilder( EntityType.BusinessEntity, FindQualifiers );

			//
			// If no search arguments are specified, return an empty result
			// set.
			//

			//
			// Validate find parameters.
			//
			Utility.IsValidKey( EntityType.BusinessEntity, BusinessKey );

			// TODO: Override may be better for these calls to KeyedReference.Validate because no parent key is used
			
			//
			// TODO: This not an Assertion so we should not pass KeyedReferenceType.Assertion.
			//
			if( null != KeyedReference )				
				KeyedReference.Validate( "", KeyedReferenceType.IdentifierBag );

			try
			{
				//
				// Read in the find results.
				//
				SqlDataReaderAccessor reader;
				SqlStoredProcedureAccessor sp;

				sp = find.FindRelatedBusinesses( 
					BusinessKey, 
					KeyedReference, 
					MaxRows);
				
				reader = sp.ExecuteReader();

				try
				{
					while( reader.Read() )
					{
						relatedBusinessList.RelatedBusinessInfos.Add( 
							reader.GetString( "entityKey" ) );
					}
				}
				finally
				{
					reader.Close();
				}			
				
				if( sp.Parameters.GetBool( "@truncated" ) )
					relatedBusinessList.Truncated = Truncated.True;
				else
					relatedBusinessList.Truncated = Truncated.False;			

				relatedBusinessList.BusinessKey = BusinessKey;

				foreach( RelatedBusinessInfo relatedBusinessInfo in relatedBusinessList.RelatedBusinessInfos )
					relatedBusinessInfo.Get( BusinessKey );
			}
			catch( Exception )
			{
				find.Abort();
				throw;
			}

			return relatedBusinessList;
		}
	}

	/// ********************************************************************
	///   public class GetAssertionStatusReport
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "get_assertionStatusReport", Namespace=UDDI.API.Constants.Namespace )]
	public class GetAssertionStatusReport : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute( "generic" )]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;
	
		[XmlElement( "authInfo" )]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}

		//
		// Element: completionStatus
		//
		private CompletionStatusType completionStatus;

		[XmlElement( "completionStatus" )]
		public CompletionStatusType CompletionStatus
		{
			get { return completionStatus; }
			set 
			{
				try
				{
					completionStatus = value;
				}
				catch( ArgumentException )
				{
					throw new UDDIException(
						ErrorType.E_invalidCompletionStatus,
						"UDDI_ERROR_INVALIDCOMPLETIONSTATUS_GETASSERTIONSTATUSREPORT" );
				}
			}
		}

		public GetAssertionStatusReport()
		{
		}
	}

	/// ********************************************************************
	///   public class GetPublisherAssertions
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "get_publisherAssertions", Namespace=UDDI.API.Constants.Namespace )]
	public class GetPublisherAssertions : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute( "generic" )]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;
	
		[XmlElement( "authInfo" )]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}

		public GetPublisherAssertions()
		{
		}
	}

	/// ********************************************************************
	///   public class SetPublisherAssertions
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRoot( "set_publisherAssertions", Namespace=UDDI.API.Constants.Namespace )]
	public class SetPublisherAssertions : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute( "generic" )]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;
	
		[XmlElement( "authInfo" )]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}

		//
		// Element: publisherAssertion
		//
		private PublisherAssertionCollection publisherAssertions;

		[XmlElement( "publisherAssertion" )]
		public PublisherAssertionCollection PublisherAssertions
		{
			get
			{
				if( null == publisherAssertions )
					publisherAssertions = new PublisherAssertionCollection();

				return publisherAssertions;
			}

			set { publisherAssertions = value; }
		}

		public SetPublisherAssertions()
		{
		}

		public PublisherAssertionDetail Set()
		{
			//
			// Remove all existing assertions for the publisher.
			//
			PublisherAssertionCollection existing = new PublisherAssertionCollection();
	
			//
			// TODO: This Get() call is unecessary. A stored proc that accepts the PUID could do this easily.
			// In a scenario where a large number of assertions are used, returning all the assertions could get expensive.
			//

			//
			// We need to save this to use it in the PublisherAssertionDetail return structure
			//
			string authorizedName = existing.Get();
			existing.Delete();

			//
			// Save each of the assertions specified by the set_publisherAssertions
			// message.
			//
			PublisherAssertions.Save();

			//
			// Get a list of all the current assertions for this publisher.
			//
			PublisherAssertionDetail detail = new PublisherAssertionDetail();
			detail.AuthorizedName = authorizedName;
			detail.PublisherAssertions = PublisherAssertions;

			return detail;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\business.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;
using UDDI.API;
using UDDI.Replication;
using UDDI.API.Service;
using UDDI.API.ServiceType;

namespace UDDI.API.Business
{
	/// ********************************************************************
	///   class BusinessEntity
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute( "businessEntity", Namespace=UDDI.API.Constants.Namespace )]
	public class BusinessEntity : EntityBase
	{
		//
		// Attribute: businessKey
		//
		[XmlAttribute("businessKey")]
		public string BusinessKey;

		//
		// Attribute: operator
		//
		[XmlAttribute("operator")]
		public string Operator;

		//
		// Attribute: authorizedName
		//
		[XmlAttribute("authorizedName")]
		public string AuthorizedName;

		//
		// Element: discoveryURLs
		//
		[ XmlIgnore ]
		public DiscoveryUrlCollection DiscoveryUrls = new DiscoveryUrlCollection();

		[ XmlArray( "discoveryURLs" ), XmlArrayItem( "discoveryURL" ) ]
		public DiscoveryUrl[] DiscoveryUrlsSerialize
		{
			get
			{
				if( Utility.CollectionEmpty( DiscoveryUrls ) )
					return null;

				return DiscoveryUrls.ToArray();
			}

			set 
			{
				DiscoveryUrls.Clear();
				DiscoveryUrls.CopyTo( value ); 
			}
		}

		//
		// Element: name
		//
		private NameCollection names;
		
		[XmlElement("name")]
		public NameCollection Names
		{
			get
			{
				if( null == names )
					names = new NameCollection();
				
				return names; 
			}

			set { names = value; }
		}

		//
		// Element: description
		//
		private DescriptionCollection descriptions;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		//
		// Element: contacts
		//
		[ XmlIgnore ]
		public ContactCollection Contacts = new ContactCollection();

		[ XmlArray( "contacts" ), XmlArrayItem( "contact" ) ]
		public Contact[] ContactsSerialize
		{
			get
			{
				if( Utility.CollectionEmpty( Contacts ) )
					return null;

				return Contacts.ToArray();
			}

			set 
			{ 
				Contacts.Clear();
				Contacts.CopyTo( value );
			}
		}

		//
		// Element: businessServices
		//
		[ XmlIgnore ]
		public BusinessServiceCollection BusinessServices = new BusinessServiceCollection();

		[ XmlArray( "businessServices" ), XmlArrayItem( "businessService" ) ]
		public BusinessService[] BusinessServicesSerialize
		{
			get
			{
				if( Utility.CollectionEmpty( BusinessServices ) )
					return null;

				return BusinessServices.ToArray();
			}

			set 
			{
				BusinessServices.Clear();
				BusinessServices.CopyTo( value ); 
			}
		}

		//
		// Element: identifierBag
		//
		[ XmlIgnore ]
		public KeyedReferenceCollection IdentifierBag = new KeyedReferenceCollection();

		[ XmlArray( "identifierBag" ), XmlArrayItem( "keyedReference" ) ]
		public KeyedReference[] IdentifierBagSerialize
		{
			get
			{
				if( Utility.CollectionEmpty( IdentifierBag ) )
					return null;

				return IdentifierBag.ToArray();
			}

			set 
			{ 
				IdentifierBag.Clear();
				IdentifierBag.CopyTo( value );
			}
		}

		//
		// Element: categoryBag
		//
		[ XmlIgnore ]
		public KeyedReferenceCollection CategoryBag = new KeyedReferenceCollection();

		[ XmlArray( "categoryBag" ), XmlArrayItem( "keyedReference" ) ]
		public KeyedReference[] CategoryBagSerialize
		{
			get
			{
				if( Utility.CollectionEmpty( CategoryBag ) )
					return null;

				return CategoryBag.ToArray();
			}

			set 
			{ 
				CategoryBag.Clear();
				CategoryBag.CopyTo( value );
			}
		}

		[XmlIgnore]
		public override UDDI.EntityType EntityType
		{
			get { return EntityType.BusinessEntity; }
		}

		[XmlIgnore]
		public override string EntityKey
		{
			get { return BusinessKey; }
		}

		/// ****************************************************************
		///   public BusinessEntity [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public BusinessEntity()
		{
		}

		/// ****************************************************************
		///   public BusinessEntity [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="businessKey">
		///   </param>
		/// ****************************************************************
		/// 
		public BusinessEntity( string businessKey )
		{
			BusinessKey = businessKey;
		}

		/// ****************************************************************
		///   public Delete
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public override void Delete()
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_delete" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );

			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			
			sp.ExecuteNonQuery();

			//
			// Save the change log entry.
			//
			if( Context.LogChangeRecords )
			{
				ChangeRecord changeRecord = new ChangeRecord();

				changeRecord.Payload = new ChangeRecordDelete( EntityType.BusinessEntity, BusinessKey );
				changeRecord.Log();
			}

			Debug.Leave();
		}

		/// ****************************************************************
		///   internal Validate
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		internal void Validate()
		{
			Debug.Enter();

			//
			// Check to make sure publisher's limit allows save of this 
			// entity.  If this is an update, we won't check since they are 
			// simply replacing an existing entity.  We also won't check if 
			// the limit is 0, since this indicates unlimited publishing 
			// rights.
			//
			int limit = Context.User.BusinessLimit;
			int count = Context.User.BusinessCount;

			if( Utility.StringEmpty( BusinessKey ) && 0 != limit )
			{				
				//
				// Verify that the publisher has not exceeded their limit.
				//
				if( count >= limit )
				{
					throw new UDDIException( ErrorType.E_accountLimitExceeded, "UDDI_ERROR_ACCOUNTLIMITEXCEEDED_BUSINESS", limit , count );
				}
			}

			//
			// Check to see if this is an update of an existing businessEntity.  If
			// it is, we'll need to perform further validation in the database.
			//
			if( !Utility.StringEmpty( BusinessKey ) )
			{
				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_validate" );
	
				sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
				sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@flag", SqlDbType.Int );
				
				sp.Parameters.SetString( "@PUID", Context.User.ID );
				sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );
				if( Context.User.AllowPreassignedKeys )
					sp.Parameters.SetInt( "@flag", 1 );
				else
					sp.Parameters.SetInt( "@flag", 0 );


				sp.ExecuteNonQuery();
			}

			//
			// Validate the contained elements.
			//
			DiscoveryUrls.Validate();
			Names.Validate();
			Descriptions.Validate();
			Contacts.Validate();
			BusinessServices.Validate( BusinessKey );
			IdentifierBag.Validate( BusinessKey, KeyedReferenceType.IdentifierBag );
			CategoryBag.Validate( BusinessKey, KeyedReferenceType.CategoryBag);
			
			Debug.Leave();
		}
		
		/// **********************************************************************
		///   public Save
		/// ----------------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// **********************************************************************
		/// 
		public override void Save()
		{
			Debug.Enter();
			
			//
			// Validate the business entity.
			//
			Validate();

			//
			// Check to see if a business key was specified.  If not, this is a new
			// record and a business key will have to be generated.
			//
			if( Utility.StringEmpty( BusinessKey ) )
				BusinessKey = Guid.NewGuid().ToString();

			//
			// Save the entity to the database.
			//
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_save" );

			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@generic", SqlDbType.VarChar, UDDI.Constants.Lengths.generic );
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );
			sp.Parameters.Add( "@authorizedName", SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName, ParameterDirection.InputOutput );
			sp.Parameters.Add( "@operatorName", SqlDbType.NVarChar, UDDI.Constants.Lengths.Operator, ParameterDirection.InputOutput );
					
			sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );
			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetString( "@generic", Constants.Version );
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );			
			sp.Parameters.SetString( "@authorizedName", AuthorizedName );
			sp.Parameters.SetString( "@operatorName", this.Operator );

			//
			// We won't set the operatorName since this will be derived from the PUID
			//

			sp.ExecuteNonQuery();

			AuthorizedName = sp.Parameters.GetString( "@authorizedName" );
			Operator = sp.Parameters.GetString( "@operatorName" );

			//
			// Save all the contained objects.
			//
			DiscoveryUrls.Save( BusinessKey );

			if( Operator == Config.GetString( "Operator" ) )
			{
				//
				// Only add the default discovery Url to this business
				// If it was published at this site.
				//
				DiscoveryUrls.AddDefaultDiscoveryUrl( BusinessKey );
			}

			Names.Save( BusinessKey, EntityType.BusinessEntity );
			Descriptions.Save( BusinessKey, EntityType.BusinessEntity );
			Contacts.Save( BusinessKey );
			BusinessServices.Save( BusinessKey );
			IdentifierBag.Save( BusinessKey, EntityType.BusinessEntity, KeyedReferenceType.IdentifierBag );
			CategoryBag.Save( BusinessKey, EntityType.BusinessEntity, KeyedReferenceType.CategoryBag );
			
			//
			// Save the change log entry for replication
			//
			if( Context.LogChangeRecords )
			{
				//
				// If we used a V1 API message, make sure to add in language codes for the names.  We will
				// then take these names out after we save the change record.
				// 
				if( 1 == Context.ApiVersionMajor )
				{
					foreach( Name name in Names )
					{
						name.IsoLangCode = Context.User.IsoLangCode;
					}
				}

				ChangeRecord changeRecord = new ChangeRecord();
				changeRecord.Payload = new ChangeRecordNewData( this );
				changeRecord.Log();

				//
				// Take out language names if we are using V1.
				//
				if( 1 == Context.ApiVersionMajor )
				{
					foreach( Name name in Names )
					{
						name.IsoLangCode = null;
					}
				}
			}
			
			Debug.Leave();
		}

		/// ****************************************************************
		///   public Get
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public override void Get()
		{
			Debug.Enter();
			
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_get_batch" );

			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@operatorName", SqlDbType.NVarChar, UDDI.Constants.Lengths.OperatorName, ParameterDirection.Output );
			sp.Parameters.Add( "@authorizedName", SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName, ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );
			
			SqlDataReaderAccessor reader = null;
			ArrayList contactIds = new ArrayList();

			try
			{
				//
				// net_businessEntity_get will return the objects contained in a business in the following order:
				//
				//	- descriptions
				//	- names
				//	- discoveryURLs
				//  - contacts
				//  - identifier bags
				//  - category bags
				//  - services
				//
				reader = sp.ExecuteReader();

				//
				// Read the descriptions
				//
				Descriptions.Read( reader );
				
				//
				// Read the names
				//
				if ( true == reader.NextResult() )
				{
					Names.Read( reader );
				}

				//
				//
				// Read the discoveryURLs
				//
				if( true == reader.NextResult() )
				{
					DiscoveryUrls.Read( reader );					
				}

				//
				// Read the contacts
				//
				if( true == reader.NextResult() )
				{				
					contactIds = Contacts.Read( reader );					
				}

				//
				// Read the identifier bags
				//
				if( true == reader.NextResult() )
				{
					IdentifierBag.Read( reader );					
				}

				//
				// Read the category bags
				//
				if( true == reader.NextResult() )
				{
					CategoryBag.Read( reader );					
				}

				//
				// Read the services
				//
				if( true == reader.NextResult() )
				{
					BusinessServices.Read( reader );
				}
			}
			finally
			{
				if( null != reader )
				{
					reader.Close();
				}
			}

			//
			// These calls will make separate sproc calls, so we have to close our reader first.
			//
			BusinessServices.Populate();
			Contacts.Populate( contactIds );
			
			//
			// Get our output parameters.
			//
			Operator       = sp.Parameters.GetString( "@operatorName" );
			AuthorizedName = sp.Parameters.GetString( "@authorizedName" );
				
			//
			// If this entity was published to this node than add the
			// default discoveryURL.
			//
			if( Operator == Config.GetString( "Operator" ) )
			{
				//
				// Only add the default discovery Url to this business
				// if it was published at this site.
				//
				DiscoveryUrls.AddDefaultDiscoveryUrl( BusinessKey );
			}

#if never
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_get" );

			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@operatorName", SqlDbType.NVarChar, UDDI.Constants.Lengths.OperatorName, ParameterDirection.Output );
			sp.Parameters.Add( "@authorizedName", SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName, ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );

			sp.ExecuteNonQuery();

			Operator = sp.Parameters.GetString( "@operatorName" );
			AuthorizedName = sp.Parameters.GetString( "@authorizedName" );

			//
			// Retrieve contained objects.
			//
			Descriptions.Get( BusinessKey, EntityType.BusinessEntity );
			Names.Get( BusinessKey, EntityType.BusinessEntity );
			DiscoveryUrls.Get( BusinessKey );

			//
			// If this entity was published to this node than add the
			// default discoveryURL.
			//
			if( Operator == Config.GetString( "Operator" ) )
			{
				//
				// Only add the default discovery Url to this business
				// if it was published at this site.
				//
				DiscoveryUrls.AddDefaultDiscoveryUrl( BusinessKey );
			}

			Contacts.Get( BusinessKey );
			BusinessServices.Get( BusinessKey );
			IdentifierBag.Get( BusinessKey, EntityType.BusinessEntity, KeyedReferenceType.IdentifierBag );
			CategoryBag.Get( BusinessKey, EntityType.BusinessEntity, KeyedReferenceType.CategoryBag );
#endif
			QueryLog.Write( QueryType.Get, EntityType.BusinessEntity );

			Debug.Leave();
		}
	}
	
	public class BusinessInfoCollection : CollectionBase
	{
		public void GetForCurrentPublisher()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_publisher_businessInfos_get" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.SetString( "@PUID", Context.User.ID );

			SqlDataReaderAccessor reader = sp.ExecuteReader();
			
			try
			{
				while( reader.Read() )
					Add( reader.GetGuidString( "businessKey" ) );
			}
			finally
			{
				reader.Close();
			}

			foreach( BusinessInfo businessInfo in this )
				businessInfo.Get( true );
		}

		public BusinessInfo this[ int index ]
		{
			get { return (BusinessInfo)List[index]; }
			set { List[index] = value; }
		}

		public int Add()
		{
			return List.Add( new BusinessInfo() );
		}

		public int Add( string businessKey )
		{
			return List.Add( new BusinessInfo( businessKey ) );
		}

		public int Add( BusinessInfo businessInfo )
		{
			return List.Add( businessInfo );
		}

		public void Insert( int index, BusinessInfo businessInfo )
		{
			List.Insert( index, businessInfo );
		}

		public int IndexOf( BusinessInfo businessInfo )
		{
			return List.IndexOf( businessInfo );
		}

		public bool Contains( BusinessInfo businessInfo )
		{
			return List.Contains( businessInfo );
		}

		public void Remove( BusinessInfo businessInfo )
		{
			List.Remove( businessInfo );
		}

		public void CopyTo( BusinessInfo[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public void Sort()
		{
			InnerList.Sort( new BusinessInfoComparer() );
		}

		internal class BusinessInfoComparer : IComparer
		{
			public int Compare( object x, object y )
			{
				BusinessInfo entity1 = (BusinessInfo)x;
				BusinessInfo entity2 = (BusinessInfo)y;

				return string.Compare( entity1.Names[ 0 ].Value, entity2.Names[ 0 ].Value, true );
			}
		}
	}

	public class BusinessEntityCollection : CollectionBase
	{
		public void Save()
		{
			foreach( BusinessEntity business in this )
			{
				business.Save();
			}
		}

		public BusinessEntity this[int index]
		{
			get { return (BusinessEntity)List[index]; }
			set { List[index] = value; }
		}

		public int Add()
		{
			
			return List.Add( new BusinessEntity() );
		}
		
		public int Add( string businessKey )
		{
			return List.Add( new BusinessEntity( businessKey ) );
		}

		public int Add( BusinessEntity value )
		{
			return List.Add( value );
		}
		
		public void Insert( int index, BusinessEntity value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( BusinessEntity value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( BusinessEntity value )
		{
			return List.Contains( value );
		}

		public void Remove( BusinessEntity value )
		{
			List.Remove( value );
		}

		public void CopyTo( BusinessEntity[] array, int index )
		{
			List.CopyTo( array, index );
		}
		public void Sort()
		{
			InnerList.Sort( new BusinessEntityComparer() );
		}

		internal class BusinessEntityComparer : IComparer
		{
			public int Compare( object x, object y )
			{
				BusinessEntity entity1 = (BusinessEntity)x;
				BusinessEntity entity2 = (BusinessEntity)y;

				return string.Compare( entity1.Names[ 0 ].Value, entity2.Names[ 0 ].Value, true );
			}
		}
	}

	public class BusinessEntityExtCollection : CollectionBase
	{
		public BusinessEntityExt this[ int index ]
		{
			get { return ( BusinessEntityExt)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new BusinessEntityExt() );
		}

		public int Add( BusinessEntityExt value )
		{
			return List.Add( value );
		}

		public int Add( string businessKey )
		{
			return List.Add( new BusinessEntityExt( businessKey ) );
		}
		
		public void Insert( int index, BusinessEntityExt value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( BusinessEntityExt value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( BusinessEntityExt value )
		{
			return List.Contains( value );
		}

		public void Remove( BusinessEntityExt value )
		{
			List.Remove( value );
		}

		public void CopyTo( BusinessEntityExt[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}

	public class BusinessEntityExt
	{
		public BusinessEntityExt()
		{
		}

		public BusinessEntityExt( string businessKey )
		{
			BusinessEntity = new BusinessEntity( businessKey );
		}

		public void Get()
		{
			BusinessEntity.Get();
		}

		[XmlElement("businessEntity")]
		public BusinessEntity BusinessEntity;
	}

	public class BusinessInfo
	{
		//
		// Attribute: businessKey
		//
		[XmlAttribute("businessKey")]
		public string BusinessKey;

		//
		// Element: name
		//
		[XmlElement("name")]
		public NameCollection Names = new NameCollection();

		//
		// Element: description
		//
		[XmlElement("description")]
		public DescriptionCollection Descriptions = new DescriptionCollection();

		//
		// Element: serviceInfos
		//
		private ServiceInfoCollection serviceInfos;

		[ XmlArray( "serviceInfos" ), XmlArrayItem( "serviceInfo" ) ]
		public ServiceInfoCollection ServiceInfos
		{
			get
			{
				if( null == serviceInfos )
					serviceInfos = new ServiceInfoCollection();

				return serviceInfos;
			}

			set { serviceInfos = value; }
		}

		public BusinessInfo()
		{
		}

		public BusinessInfo( string businessKey )
		{
			BusinessKey = businessKey;
		}

		public void Get( bool getServiceInfos )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessInfo_get_batch" );

			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@getServiceInfos", SqlDbType.Bit );
			
			sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );
			sp.Parameters.SetBool( "@getServiceInfos", getServiceInfos );
			
			SqlDataReaderAccessor reader = null;
			ArrayList contactIds = new ArrayList();
			bool readServiceInfos = false;

			try
			{
				//
				// net_businessInfo_get_batch will return the objects contained in a business in the following order:
				//
				//	- descriptions
				//	- names
				//	- serviceInfos (if specified)
				reader = sp.ExecuteReader();

				//
				// Read the descriptions
				//
				Descriptions.Read( reader );
				
				//
				// Read the names
				//
				if ( true == reader.NextResult() )
				{
					Names.Read( reader );
				}	
			
				//
				// Read the service infos, maybe
				//
				if( true == getServiceInfos )
				{
					if ( true == reader.NextResult() )
					{
						ServiceInfos.Read( reader );
						readServiceInfos = true;
					}
				}
			}
			finally
			{
				if( null != reader )
				{
					reader.Close();
				}
			}

			if( true == getServiceInfos && true == readServiceInfos )
			{
				ServiceInfos.Populate();
			}
#if never
			Names.Get( BusinessKey, EntityType.BusinessEntity );
			Descriptions.Get( BusinessKey, EntityType.BusinessEntity );
			
			if( getServiceInfos )
				ServiceInfos.Get( BusinessKey );
#endif
		}
	}

	/// ****************************************************************
	///   class DeleteBusiness
	///	----------------------------------------------------------------
	///	  <summary>
	///		The DeleteBusiness class contains data and methods 
	///		associated with the delete_business message. It is typically 
	///		populated via deserialization by the .NET runtime as part of 
	///		the message processing interface.
	///		
	///		As part of the publisher API, this message implements 
	///		IAuthenticateable. This allows the enclosed authInfo to be 
	///		authorized prior to processing
	///	  </summary>
	/// ****************************************************************
	/// 
	[XmlRootAttribute( "delete_business", Namespace=UDDI.API.Constants.Namespace )]
	public class DeleteBusiness : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
		
		//
		// Element: businessKey
		//
		[XmlElement("businessKey")]
		public StringCollection BusinessKeys;

		public DeleteBusiness()
		{
			Generic = UDDI.API.Constants.Version;
		}

		public void Delete()
		{
			foreach( string key in BusinessKeys )
			{
				BusinessEntity be = new BusinessEntity( key );
				be.Delete();
			}
		}
	}

	/// ********************************************************************
	///   public class FindBusiness
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute("find_business", Namespace=UDDI.API.Constants.Namespace)]
	public class FindBusiness : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Attribute: maxRows
		//
		private int maxRows = -1;

		[XmlAttribute( "maxRows" ), DefaultValue( -1 )]
		public int MaxRows
		{
			get	{ return maxRows; }
			set	
			{
				if( value < 0 )
				{
					throw new UDDIException( 
						ErrorType.E_fatalError, 
						"UDDI_ERROR_FATALERROR_FINDBE_MAXROWSLESSTHANZERO" );
				}

				maxRows = value; 
			}
		}

		//
		// Element: findQualifiers/findQualifier
		//
		[XmlArray( "findQualifiers" ), XmlArrayItem( "findQualifier" )]
		public FindQualifierCollection FindQualifiers = new FindQualifierCollection();

		//
		// Element: name
		//
		[XmlElement( "name" )]
		public NameCollection Names = new NameCollection();

		//
		// Element: identifierBag/keyedReference
		//
		[XmlArray( "identifierBag" ), XmlArrayItem( "keyedReference" ) ]
		public KeyedReferenceCollection IdentifierBag;

		//
		// Element: categoryBag/keyedReference
		//
		[XmlArray( "categoryBag" ), XmlArrayItem( "keyedReference" )]
		public KeyedReferenceCollection CategoryBag;

		//
		// Element: tModelBag/tModelKey
		//
		[XmlArray( "tModelBag" ), XmlArrayItem( "tModelKey" )]
		public StringCollection TModelBag;

		//
		// Element: discoveryURLs/discoveryURL
		//	
		[XmlArray( "discoveryURLs" ), XmlArrayItem( "discoveryURL" )]
		public DiscoveryUrlCollection DiscoveryUrls;

		public BusinessList Find()
		{
			BusinessList businessList = new BusinessList();
			
			QueryLog.Write( QueryType.Find, EntityType.BusinessEntity );

			//
			// Process each find constraint.
			//
			FindBuilder find = new FindBuilder( EntityType.BusinessEntity, FindQualifiers );

			//
			// If no search arguments are specified, return an empty result
			// set.
			//
			if( Utility.CollectionEmpty( Names ) &&
				Utility.CollectionEmpty( DiscoveryUrls ) &&
				Utility.CollectionEmpty( IdentifierBag ) &&
				Utility.CollectionEmpty( CategoryBag ) &&
				Utility.CollectionEmpty( TModelBag ) )
				return businessList;
			
			//
			// Validate find parameters.
			// 

			if( !Utility.CollectionEmpty( Names ) )
			{
				Names.ValidateForFind();
			}
			else
			{
				Debug.Verify( !find.CaseSensitiveMatch && !find.ExactNameMatch,
						 "UDDI_ERROR_UNSUPPORTED_FINDBE_NAMEFQNONAMES", ErrorType.E_unsupported );
			}


			//
			// TODO: Override may be better for these calls to KeyedReference.Validate because no parent key is used
			//
			if( !Utility.CollectionEmpty( IdentifierBag ) )
				IdentifierBag.Validate( "", KeyedReferenceType.IdentifierBag );

			if( !Utility.CollectionEmpty( CategoryBag ) )
				CategoryBag.Validate( "", KeyedReferenceType.CategoryBag );

			try
			{
				int rows = 1;

				//
				// Find entities with matching identifier bag items.
				//
				if( !Utility.CollectionEmpty( IdentifierBag ) )
					rows = find.FindByKeyedReferences( KeyedReferenceType.IdentifierBag, IdentifierBag );

				//
				// Find entities with matching category bag items.
				//
				if( rows > 0 && !Utility.CollectionEmpty( CategoryBag ) )
					rows = find.FindByKeyedReferences( KeyedReferenceType.CategoryBag, CategoryBag );

				//
				// Find entities with matching TModel bag items.
				//
				if( rows > 0 && !Utility.CollectionEmpty( TModelBag ) )
					rows = find.FindByTModelBag( TModelBag );
				
				//
				// Find entities with matching discovery URLs
				//
				if( rows > 0 && !Utility.CollectionEmpty( DiscoveryUrls ) )
					rows = find.FindByDiscoveryUrls( DiscoveryUrls );

				//
				// Find entities with matching names
				//
				if( rows > 0 && !Utility.CollectionEmpty( Names ) )
					rows = find.FindByNames( Names );

				//
				// Process the find result set.
				//
				if( 0 == rows )
				{
					//
					// Cleanup any temporary tables.
					//
					find.Abort();
				} // TODO: review
				else if( 0 == MaxRows )
				{
					businessList.Truncated = Truncated.True;
					return businessList;
				}
				else
				{
					//
					// Read in the find results.
					//
					SqlDataReaderAccessor reader;
					SqlStoredProcedureAccessor sp;
					sp = find.RetrieveResults( MaxRows);
//
// TODO: return reader, not the whole SPA
//
					reader = sp.ExecuteReader();
				
					try
					{
						if( find.ServiceSubset )
						{
							//
							// For a service subset search, we limit the result set
							// to those services that matched the category bag
							// search criteria.
							//
							BusinessInfo businessInfo = null;								
							string prevKey = null;

							while( reader.Read() )
							{
								string businessKey = reader.GetString( "entityKey" );

								if( prevKey != businessKey )
								{ 
									businessInfo = new BusinessInfo( businessKey );									
									businessList.BusinessInfos.Add( businessInfo );
								}

								businessInfo.ServiceInfos.Add(
									reader.GetString( "subEntityKey" ),
									businessKey );

								prevKey = businessKey;
							}
						}
						else
						{
							//
							// For non-service subset searches, we will simply
							// return a list of businesses with all services.
							//
							while( reader.Read() )
								businessList.BusinessInfos.Add( reader.GetString( "entityKey" ) );
						}
					}
					finally
					{
						reader.Close();
					}

					if( sp.Parameters.GetBool( "@truncated" ) )
						businessList.Truncated = Truncated.True;
					else
						businessList.Truncated = Truncated.False;			
						
					//
					// Get the actual business info and service info data.  For 
					// a service subset, we'll grab just those services that we
					// populated.  For all other searches, we'll get all service
					// infos.
					//
					if( find.ServiceSubset )
					{
						foreach( BusinessInfo businessInfo in businessList.BusinessInfos )
						{
							businessInfo.Get( false );

							foreach( ServiceInfo serviceInfo in businessInfo.ServiceInfos )
								serviceInfo.Get();
						}
					}
					else
					{
						foreach( BusinessInfo businessInfo in businessList.BusinessInfos )
							businessInfo.Get( true );
					}
				}
			}
			catch( Exception )
			{
				find.Abort();
				throw;
			}

			return businessList;
		}
	}

	/// ********************************************************************
	///   public class GetBusinessDetail
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute( "get_businessDetail", Namespace=UDDI.API.Constants.Namespace )]
	public class GetBusinessDetail : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: businessKey
		//
		[XmlElement("businessKey")]
		public StringCollection BusinessKeys;

		public GetBusinessDetail()
		{
			Generic = UDDI.API.Constants.Version;
		}
	}

	[XmlRootAttribute("businessDetail", Namespace=UDDI.API.Constants.Namespace)]
	public class BusinessDetail
	{
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;
	
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );
	
		[XmlAttribute("truncated")]
		public Truncated Truncated;
	
		[XmlElement("businessEntity")]
		public BusinessEntityCollection BusinessEntities = new BusinessEntityCollection();

		public void Get( StringCollection businessKeys )
		{
			int n = 0;
			foreach( string key in businessKeys )
			{
				n = BusinessEntities.Add( key );
				BusinessEntities[ n ].Get();
			}
		}
	}

	/// ********************************************************************
	///   public class SaveBusiness
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute( "save_business", Namespace=UDDI.API.Constants.Namespace )]
	public class SaveBusiness : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
		
		//
		// Element: businessEntity
		//
		[XmlElement("businessEntity")]
		public BusinessEntityCollection BusinessEntities;
		
		//
		// Element: uploadRegister
		//
		[XmlElement("uploadRegister")]
		public StringCollection UploadRegisters;

		/// ****************************************************************
		///   public Save
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public void Save()
		{
			//
			// This is outside of replication so any attempt to specify
			// an upload register URL will force an E_unsupported response
			//
			if( 0 != UploadRegisters.Count )
				throw new UDDIException( ErrorType.E_unsupported, "UDDI_ERROR_UNSUPPORTED_UPLOADREGISTER" );

			BusinessEntities.Save();
		}
	}

	/// ********************************************************************
	///   public class GetBusinessDetailExt 
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ******************************************************************** 
	/// 
	[XmlRootAttribute( "get_businessDetailExt", Namespace=UDDI.API.Constants.Namespace )]
	public class GetBusinessDetailExt : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: businessKey
		//
		[XmlElement("businessKey")]
		public StringCollection BusinessKeys;

		public GetBusinessDetailExt()
		{
		}
	}

	[XmlRootAttribute("businessDetailExt", Namespace=UDDI.API.Constants.Namespace)]
	public class BusinessDetailExt
	{
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;
		
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );
		
		[XmlAttribute("truncated")]
		public Truncated Truncated;
		
		[XmlElement("businessEntityExt")]
		public BusinessEntityExtCollection BusinessEntityExts = new BusinessEntityExtCollection();

		public void Get( StringCollection businessKeys )
		{
			int n = 0;
			foreach( string key in businessKeys )
			{
				n = BusinessEntityExts.Add( key );
				BusinessEntityExts[ n ].Get();
			}
		}
	}

	[XmlRootAttribute("businessList", Namespace=UDDI.API.Constants.Namespace)]
	public class BusinessList
	{
		//
		// Attribute: generic
		//
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;
		
		//
		// Attribute: operator
		//
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );
		
		//
		// Attribute: truncated
		//
		[XmlAttribute("truncated")]
		public Truncated Truncated;
		
		//
		// Element: businessInfos
		//
		private BusinessInfoCollection businessInfos;

		[ XmlArray( "businessInfos" ), XmlArrayItem( "businessInfo" ) ]
		public BusinessInfoCollection BusinessInfos
		{
			get
			{
				if( null == businessInfos )
					businessInfos = new BusinessInfoCollection();

				return businessInfos;
			}

			set { businessInfos = value; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\contact.cs ===
using System;
using System.Data;
using System.Collections;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API.Business
{
	public class Contact
	{
		//
		// Attribute: useType
		//		
		[ XmlAttribute( "useType" ) ]
		public string UseType;

		//
		// Element: description
		//
		private DescriptionCollection descriptions;

		[ XmlElement( "description" ) ]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		//
		// Element: personName
		//		
		[ XmlElement( "personName" ) ]
		public string PersonName
		{
			get{ return personName; }
			set{ personName = value; }
		}
		private string personName;

		//
		// Element: phone
		//
		private PhoneCollection phones;

		[ XmlElement( "phone" ) ]
		public PhoneCollection Phones
		{
			get
			{
				if( null == phones )
					phones = new PhoneCollection();

				return phones;
			}

			set { phones = value; }
		}

		//
		// Element: email
		//
		private EmailCollection emails;

		[ XmlElement( "email" ) ]
		public EmailCollection Emails
		{
			get
			{
				if( null == emails )
					emails = new EmailCollection();

				return emails;
			}

			set { emails = value; }
		}

		//
		// Element: address
		//
		private AddressCollection addresses;
	
		[ XmlElement( "address" ) ]
		public AddressCollection Addresses
		{
			get
			{
				if( null == addresses )
					addresses = new AddressCollection();

				return addresses;
			}

			set { addresses = value; }
		}

		public Contact()
		{
		}
		
		public Contact( string personName, string useType )
		{
			PersonName = personName;
			UseType = useType;
		}

		internal void Validate()
		{
			Debug.Enter();
			
			Utility.ValidateLength( ref UseType, "useType", UDDI.Constants.Lengths.UseType );
			Utility.ValidateLength( ref personName, "personName", UDDI.Constants.Lengths.PersonName );
			
			Descriptions.Validate();
			Emails.Validate();
			Phones.Validate();
			Addresses.Validate();
			
			Debug.Leave();
		}
		
		public void Save( string businessKey )
		{				
			//
			// Create a command object to invoke the stored procedure
			//
			SqlCommand cmd = new SqlCommand( "net_businessEntity_contact_save", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;
			
			//
			// Parameters
			//
			cmd.Parameters.Add( new SqlParameter( "@businessKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@useType", SqlDbType.NVarChar, UDDI.Constants.Lengths.UseType ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@personName", SqlDbType.NVarChar, UDDI.Constants.Lengths.PersonName ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@contactID", SqlDbType.BigInt ) ).Direction = ParameterDirection.Output;

			//
			// Set parameter values and execute query
			//
			SqlParameterAccessor parmacc = new SqlParameterAccessor( cmd.Parameters );
			parmacc.SetGuidFromString( "@businessKey", businessKey );
			parmacc.SetString( "@personName", PersonName );
			parmacc.SetString( "@useType", UseType );

			cmd.ExecuteScalar();

			//
			// Move out parameters into local variables
			//
			long ContactID = parmacc.GetLong( "@contactID" );

			//
			// Save sub-objects
			//
			Descriptions.Save( ContactID, EntityType.Contact );
			Phones.Save( ContactID );
			Emails.Save( ContactID );
			Addresses.Save( ContactID );
		}

		public void Get( int contactId )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_contact_get_batch" );
			
			sp.Parameters.Add( "@contactId", SqlDbType.BigInt );
			sp.Parameters.SetLong( "@contactId", contactId );

			SqlDataReaderAccessor reader = null;
			ArrayList addressIDs = new ArrayList();

			try
			{
				//
				// net_businessEntity_contact_get_batch will return the objects contained in a business in the following order:
				//
				//	- descriptions
				//	- phones
				//	- emails
				//  - addresses
				reader = sp.ExecuteReader();

				//
				// Read the descriptions
				//
				Descriptions.Read( reader );

				//
				// Read the phones
				//
				if ( true == reader.NextResult() )
				{
					Phones.Read( reader );
				}

				//
				// Read the emails
				//
				if ( true == reader.NextResult() )
				{
					Emails.Read( reader );
				}

				//
				// Read the addresses
				//
				if ( true == reader.NextResult() )
				{
					addressIDs = Addresses.Read( reader );
				}
			}
			finally
			{
				if( reader != null )
				{
					reader.Close();
				}
			}

			//
			// These calls will make separate sproc calls, so we have to close our reader first.
			//
			Addresses.Populate( addressIDs );

#if never
			//
			// Call get method on sub-objects personName and UseType
			// should have been populate by contacts.get() method;
			//
			Descriptions.Get( contactId, EntityType.Contact );
			Phones.Get( contactId );
			Emails.Get( contactId );
			Addresses.Get( contactId );
#endif
		}
	}

	public class ContactCollection : CollectionBase
	{
		internal void Validate()
		{
			foreach( Contact c in this )
			{
				c.Validate();
			}
		}
		
		public void Save( string businessKey )
		{
			//
			// Walk collection and call save on individual contact instances
			//
			foreach( Contact c in this )
			{
				c.Save( businessKey );
			}
		}
		
		public void Get( string businessKey )
		{						
			//
			// Create a command object to invoke the stored procedure net_get_contacts
			//
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_businessEntity_contacts_get" );
						
			//
			// Input parameters
			//
			cmd.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier, ParameterDirection.Input );
			cmd.Parameters.SetGuidFromString( "@businessKey", businessKey );
			
			//
			// Run the stored procedure
			//
			SqlDataReaderAccessor reader = cmd.ExecuteReader();
			ArrayList contactIds = null;
			try
			{
				contactIds = Read( reader );
			}
			finally
			{
				reader.Close();
			}			

			Populate( contactIds );	
#if never
			const int ContactIdIndex = 0;
			const int UseTypeIndex = 1;
			const int PersonNameIndex = 2;
			ArrayList contactIds = new ArrayList();

			//
			// Create a command object to invoke the stored procedure net_get_contacts
			//
			SqlCommand cmd = new SqlCommand( "net_businessEntity_contacts_get", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;

			//
			// Input parameters
			//
			cmd.Parameters.Add( new SqlParameter( "@businessKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;

			//
			// Set parameter values
			//
			SqlParameterAccessor populator = new SqlParameterAccessor( cmd.Parameters );
			populator.SetGuidFromString( "@businessKey", businessKey );

			//
			// Run the stored procedure
			//
			SqlDataReader rdr = cmd.ExecuteReader();
			try
			{
				SqlDataReaderAccessor dracc	= new SqlDataReaderAccessor( rdr );

				//
				// The contacts will be contained in the result set
				//
				while( rdr.Read() )
				{
					//
					// construct a new contact from the data in this row, fully populate contact and add to collection
					//
					Add( new Contact( dracc.GetString( PersonNameIndex ), dracc.GetString( UseTypeIndex ) ) );
					contactIds.Add( dracc.GetInt( ContactIdIndex ) );
				}
			}
			finally
			{
				rdr.Close();
			}

			int i = 0;
			foreach( Contact contact in this )
			{
				contact.Get( (int) contactIds[ i++ ] );
			}
#endif
		}

		public ArrayList Read( SqlDataReaderAccessor reader )
		{
			const int ContactIdIndex = 0;
			const int UseTypeIndex = 1;
			const int PersonNameIndex = 2;
			ArrayList contactIds = new ArrayList();

			//
			// The contacts will be contained in the result set
			//
			while( reader.Read() )
			{
				//
				// construct a new contact from the data in this row, fully populate contact and add to collection
				//
				contactIds.Add( reader.GetInt( ContactIdIndex ) );
				Add( new Contact( reader.GetString( PersonNameIndex ), reader.GetString( UseTypeIndex ) ) );				
			}

			return contactIds;			
		}

		public void Populate( ArrayList contactIds )
		{
			int i = 0;
			foreach( Contact contact in this )
			{
				contact.Get( (int) contactIds[ i++ ] );
			}		
		}
	
		public Contact this[ int index ]
		{
			get { return ( Contact)List[index]; }
			set { List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new Contact() );
		}

		public int Add( string personName )
		{
			return List.Add( new Contact( personName, null ) );
		}

		public int Add( string personName, string useType )
		{
			return List.Add( new Contact( personName, useType ) );
		}

		public int Add( Contact value )
		{
			return List.Add( value );
		}

		public void Insert( int index, Contact value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( Contact value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( Contact value )
		{
			return List.Contains( value );
		}

		public void Remove( Contact value )
		{
			List.Remove( value );
		}

		public void CopyTo( Contact[] array )
		{
			foreach( Contact contact in array )
				Add( contact );
		}

		public Contact[] ToArray()
		{
			return (Contact[])InnerList.ToArray( typeof( Contact ) );
		}

		public void Sort()
		{
			InnerList.Sort( new ContactComparer() );
		}

		internal class ContactComparer : IComparer
		{
			public int Compare( object x, object y )
			{
				Contact entity1 = (Contact)x;
				Contact entity2 = (Contact)y;
				

				//
				// Check for null PersonName.
				//
				if( null==entity1.PersonName && null==entity2.PersonName )
					return 0;
			
				else if( null==entity1.PersonName )
					return -1;

				else if( null==entity2.PersonName )
					return 1;

				else
					return string.Compare( entity1.PersonName, entity2.PersonName, true );
					
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\category.cs ===
﻿using System;
using System.Web;
using System.Data;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Collections;
using System.Web.Services;
using System.Data.SqlClient;
using System.Xml.Serialization;
using System.Web.Services.Protocols;

using UDDI;
using UDDI.API;
using UDDI.Diagnostics;
using UDDI.API.Binding;
using UDDI.API.Service;
using UDDI.API.Business;
using UDDI.API.ServiceType;


namespace UDDI.API.Extensions
{
	public class Constants
	{
		public const string Namespace = "urn:uddi-microsoft-com:api_v2_extensions";
	}

	[XmlRoot( "resources", Namespace=UDDI.API.Extensions.Constants.Namespace )]
	public class Resources
	{
		[XmlElement( "tModelDetail", Namespace=UDDI.API.Constants.Namespace )]
		public TModelDetail TModelDetail;

		[XmlArray( "categorizationSchemes" ), XmlArrayItem( "categorizationScheme" )]
		public CategorizationSchemeCollection CategorizationSchemes = new CategorizationSchemeCollection();

		[XmlElement( "businessDetail", Namespace=UDDI.API.Constants.Namespace )]
		public BusinessDetail BusinessDetail;

		[XmlElement( "serviceDetail", Namespace=UDDI.API.Constants.Namespace )]
		public ServiceDetail ServiceDetail;

		[XmlElement( "bindingDetail", Namespace=UDDI.API.Constants.Namespace )]
		public BindingDetail BindingDetail;

		public Resources()
		{
		}

		public static void Validate( Stream strm )
		{
			Debug.VerifySetting( "InstallRoot" );

			string installRoot = Config.GetString( "InstallRoot" );
            
            string apiSchema = installRoot + "uddi_v2.xsd";
			string resourceSchema = installRoot + "extensions.xsd";

			Debug.Verify( File.Exists( apiSchema ), "TUDDI_ERROR_FATALERROR_UDDISCHEMANOTFOUND" );
			Debug.Verify( File.Exists( resourceSchema ), "UDDI_ERROR_FATALERROR_UDDIRESOURCESCHEMANOTFOUND" );

			XmlSchemaCollection xsc = new XmlSchemaCollection();
			
			xsc.Add( UDDI.API.Constants.Namespace, apiSchema );
			xsc.Add( UDDI.API.Extensions.Constants.Namespace, resourceSchema );

			//
			// Rewind stream (to be safe) and validate
			//
			strm.Seek( 0, SeekOrigin.Begin );

			//
			// Construct a validating reader to verify the document is kosher
			//
			XmlTextReader reader = new XmlTextReader( strm );
			XmlValidatingReader vreader = new XmlValidatingReader( reader );
			vreader.Schemas.Add( xsc );
			while( vreader.Read()){}
			
			//
			// Rewind stream again, so someone else can use it
			//
			strm.Seek( 0, SeekOrigin.Begin );

		}

		public void Save()
		{
			UDDI.Diagnostics.Debug.Enter();

			if( null != TModelDetail )
			{
				Debug.Write( SeverityType.Info, CategoryType.Data, "Importing tModels..." );
				foreach( TModel tm in TModelDetail.TModels )
				{
					tm.AuthorizedName = null;
					tm.Save();
				}
			}

			if( null != CategorizationSchemes )
			{
				Debug.Write( SeverityType.Info, CategoryType.Data, "Importing Categorization schemes..." );
				foreach( CategorizationScheme cs in CategorizationSchemes )
				{
					cs.Save();
				}
			} 

			if( null != BusinessDetail )
			{
				Debug.Write( SeverityType.Info, CategoryType.Data, "Importing Providers..." );
				foreach( BusinessEntity be in BusinessDetail.BusinessEntities )
				{
					be.AuthorizedName = null;
					be.Save();
				}
			}

			if( null != ServiceDetail )
			{
				Debug.Write( SeverityType.Info, CategoryType.Data, "Importing Services..." );
				foreach( BusinessService bs in ServiceDetail.BusinessServices )
				{
					bs.Save();
				}
			}

			if( null != BindingDetail )
			{
				Debug.Write( SeverityType.Info, CategoryType.Data, "Importing bindings..." );
				foreach( BindingTemplate bind in BindingDetail.BindingTemplates )
				{
					bind.Save();
				}
			}
		}
	}

	[SoapDocumentService( ParameterStyle=SoapParameterStyle.Bare, RoutingStyle=SoapServiceRoutingStyle.RequestElement )]
	[WebService( Namespace=UDDI.API.Extensions.Constants.Namespace )]
	public class CategoryMessages
	{
		public CategoryMessages(){}

		[WebMethod, SoapDocumentMethod( Action="\"\"", RequestElementName="get_relatedCategories" )]
		[UDDIExtension( messageType="get_relatedCategories" )]
		public CategoryList GetRelatedCategories( GetRelatedCategories message )
		{
			Debug.Enter();
			CategoryList list = null;

			try
			{
				list = message.Get();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}
			
			Debug.Leave();

			return list;
		}
	}
	
	[XmlType( Namespace=UDDI.API.Extensions.Constants.Namespace )]
	[XmlRoot( "get_relatedCategories", Namespace=UDDI.API.Extensions.Constants.Namespace )]
	public class GetRelatedCategories 
	{
		public GetRelatedCategories(){}

		[XmlIgnore]
		public CategoryCollection Categories = new CategoryCollection();

		[XmlElement( "category" )]
		public Category[] CategoriesSerialize
		{
			get
			{
				return Categories.ToArray();
			}
			set
			{
				Categories.CopyTo( value );
			}
		}

		public CategoryList Get()
		{
			//
			// For each category retrieve 
			// the request stuff ( root, children, parents )
			//
			CategoryList list = new CategoryList();
			foreach( Category cat in Categories )
			{
				CategoryInfo info = new CategoryInfo( cat.TModelKey, cat.KeyValue );
				info.Get( cat.RelationshipQualifiers );

				list.CategoryInfos.Add( info );
			}
			
			return list;
		}
	}

	public class CategorizationScheme
	{
		//
		// TODO: Must tModel element must be optional with tModelKey element
		//

		private int CategorizationSchemeFlag = 1;

		[XmlAttribute( "checked" )]
		public XmlBoolType Checked
		{
			get { return ( 1 == CategorizationSchemeFlag ) ? XmlBoolType.True : XmlBoolType.False; }
			set	
			{ 
				if( XmlBoolType.True == value )
					CategorizationSchemeFlag = 1;
				else
					CategorizationSchemeFlag = 0;//changed from 2 to 0 to correctly implement bit flags
			}
		}

		[XmlElement( "tModel", Namespace=UDDI.API.Constants.Namespace )]
		public TModel TModel = null;

		[XmlElement( "tModelKey" )]
		public string TModelKey
		{
			get
			{ 
				return tModelKey; 
			}
			set
			{ 
				if( null == value )
					tModelKey = null;
				else
					tModelKey = value.Trim(); 
			}
		}
		private string tModelKey = "";

		[XmlElement( "categoryValue" )]
		public CategoryValueCollection CategoryValues
		{
			get
			{
				if( null == categoryvalues )
					categoryvalues = new CategoryValueCollection();
				
				return categoryvalues; 
			}

			set 
			{ 
				categoryvalues = value; 
			}
		}
		private CategoryValueCollection categoryvalues;

		public CategorizationScheme(){}

		public void Delete()
		{
			Debug.Enter();
			
			SqlCommand cmd = new SqlCommand( "net_taxonomy_delete", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Transaction = ConnectionManager.GetTransaction();

			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;

			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetGuidFromKey( "@tModelKey", tModelKey );

			cmd.ExecuteNonQuery();

			Debug.Leave();
		}

		public void Save()
		{
			string tmodelkey;

			Debug.Enter();

			Debug.Write( SeverityType.Info, CategoryType.Data, "Importing categorization scheme..." );

			if( null != TModel )
			{
				TModel.AuthorizedName = null;
				TModel.Save();
			}
			else
			{
				TModel = new TModel( TModelKey );
				TModel.Get();
			}

			//
			// If the TModel Provided is categorized with 'Browsing Intended'
			// Set the flag (0x0002) 
			//
			//if( TModel.CategoryBag.Contains( new KeyedReference( "Browsing Intended","1","uuid:BE37F93E-87B4-4982-BF6D-992A8E44EDAB" ) ) )
			foreach( KeyedReference kr in TModel.CategoryBag )
			{
				if( kr.KeyValue=="1" && kr.TModelKey.ToUpper()=="UUID:BE37F93E-87B4-4982-BF6D-992A8E44EDAB" )
					CategorizationSchemeFlag = CategorizationSchemeFlag | 0x0002;
			}

			//
			// Store the TModelKey
			//
			tmodelkey = TModel.TModelKey;
			
			//
			// Save the categorization scheme
			//

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_taxonomy_save";
			
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@flag", SqlDbType.Int );
			sp.Parameters.Add( "@taxonomyID", SqlDbType.BigInt, ParameterDirection.InputOutput );
			
			sp.Parameters.SetGuidFromKey( "@tModelKey", tmodelkey );
			sp.Parameters.SetInt( "@flag", CategorizationSchemeFlag );

			sp.ExecuteNonQuery();

			int taxonomyID = sp.Parameters.GetInt( "@taxonomyID" );

			//
			// Save the category values
			//

			foreach( CategoryValue cv in CategoryValues )
			{
				cv.Save( tmodelkey );
			}

			Debug.Leave();
		}

		public void Get()
		{
			Debug.Enter();
			
			//
			// Retrieve the taxonomy
			//

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_taxonomy_get" );

			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@flag", SqlDbType.Int, ParameterDirection.InputOutput );

			sp.Parameters.SetGuidFromKey( "@tModelKey", tModelKey );
			sp.Parameters.SetNull( "@flag" );

			sp.ExecuteScalar();

			//
			// Set the flag value
			//

			CategorizationSchemeFlag = sp.Parameters.GetInt( "@flag" );

			//
			// Retrieve the taxonomy values
			//

			CategoryValues.Clear();
				
			SqlStoredProcedureAccessor sp2 = new SqlStoredProcedureAccessor( "net_taxonomyValues_get" );
			sp2.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp2.Parameters.SetGuidFromKey( "@tModelKey", tModelKey );
			SqlDataReaderAccessor reader = sp2.ExecuteReader();

			try
			{
				while( reader.Read() )
				{
					CategoryValues.Add( reader.GetString( "keyName" ), reader.GetString( "keyValue" ), reader.GetString( "parentKeyValue"), ( ( reader.GetInt( "valid" ) == 1 ) ? true : false ) );
				}
			}
			finally
			{
				reader.Close();
			}

			Debug.Leave();
		}
	}

	public enum ValidForCategorization
	{
		[XmlEnumAttribute( "false" )]
		False	= 0,
		[XmlEnumAttribute( "true" )]
		True	= 1,
	}

	public class CategorizationSchemeCollection : CollectionBase
	{
		public CategorizationSchemeCollection()
		{
		}
		public void Save()
		{
			Debug.Enter();

			foreach( CategorizationScheme tax in this )
			{
				tax.Save();
			}

			Debug.Leave();
		}

		public CategorizationScheme this[int index]
		{
			get	{ return (CategorizationScheme)List[index]; }
			set	{ List[index] = value; }
		}

		public int Add(CategorizationScheme value)
		{
			return List.Add(value);
		}

		public void Insert(int index, CategorizationScheme value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( CategorizationScheme value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( CategorizationScheme value )
		{
			return List.Contains( value );
		}
		
		public void Remove( CategorizationScheme value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(CategorizationScheme[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public void CopyTo( CategorizationScheme[] array )
		{
			foreach( CategorizationScheme tax in array )
				Add( tax );
		}

		public CategorizationScheme[] ToArray()
		{
			return (CategorizationScheme[]) InnerList.ToArray( typeof( CategorizationScheme ) );
		}
	}

	public class Category
	{
		[XmlElement( "relationshipQualifier" )]
		public RelationshipQualifier[] RelationshipQualifiers;
	    
		[XmlAttribute( "tModelKey" )]
		public string TModelKey;
	    
		[XmlAttribute( "keyValue" )]
		public string KeyValue;
	}

	public enum RelationshipQualifier
	{
		root = 1, parent = 2, child = 3
	}

	[XmlRoot( "categoryList", Namespace=UDDI.API.Extensions.Constants.Namespace )]
	public class CategoryList 
	{
		[XmlAttribute( "truncated" )]
		public bool Truncated = false;
	    
		[XmlAttribute( "operator" )]
		public string Operator = Config.GetString( "Operator" );

		[XmlIgnore]
		public CategoryInfoCollection CategoryInfos = new CategoryInfoCollection();

		[XmlElement( "categoryInfo" )]
		public CategoryInfo[] CategoryInfosSerialize
		{
			get
			{
				return CategoryInfos.ToArray();
			}
			set
			{
				CategoryInfos.CopyTo( value );
			}
		}

		public CategoryList(){}
	}

	public class CategoryInfo : CategoryValue
	{
		const int KeyValueIndex = 0;
		const int ParentKeyValueIndex = 1;
		const int KeyNameIndex = 2;
		const int IsValidIndex = 3;

		// -- 0 - Root information requested
		// -- 1 - Child information requested
		// -- 2 - Parent information requested
		// -- 3 - Current information requested

		public enum RelationType : int
		{
			Root = 0,
			Child = 1,
			Parent = 2,
			Current = 3
		}

		[XmlArray( "rootRelationship" ), XmlArrayItem( "categoryValue" )]
		public CategoryValueCollection Roots = null;

		[XmlArray( "parentRelationship" ), XmlArrayItem( "categoryValue" )]
		public CategoryValueCollection Parents = null;

		[XmlArray( "childRelationship" ), XmlArrayItem( "categoryValue" )]
		public CategoryValueCollection Children = null;

		public CategoryInfo( string tmodelkey, string keyvalue )
			: base( tmodelkey, keyvalue )
		{
		}

		public SqlDataReader GetValues( RelationType relation )
		{
			SqlCommand cmd = new SqlCommand( "net_taxonomyValue_get", ConnectionManager.GetConnection() );
						
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;

			//
			// Add parameters and set values
			//
			SqlParameterAccessor populator = new SqlParameterAccessor( cmd.Parameters );
			
			cmd.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			cmd.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
			cmd.Parameters.Add( "@relation", SqlDbType.Int );

			populator.SetGuidFromKey( "@tModelKey", TModelKey );
			populator.SetString( "@keyValue", KeyValue );
			populator.SetInt( "@relation", (int) relation );

			return cmd.ExecuteReader();
		}

		public void Get( RelationshipQualifier[] relations )
		{
			if( null != KeyValue )
			{
				//
				// The request can ask for Root stuff with just the TModelKey
				//
				SqlDataReader rdr = GetValues( RelationType.Current );

				try
				{
					SqlDataReaderAccessor dracc	= new SqlDataReaderAccessor( rdr );

					if( rdr.Read() )
					{
						this.KeyName = dracc.GetString( KeyNameIndex );
						this.IsValid = ( 1 == dracc.GetInt( IsValidIndex ) );
					}
					else
					{
						throw new UDDIException( UDDI.ErrorType.E_invalidValue, "UDDI_ERROR_INVALIDVALUE_VALUENOTFOUND" );
					}
				}
				finally
				{
					rdr.Close();
				}
			}

			if( null != relations )
			{
				foreach( RelationshipQualifier rq in relations )
				{
					switch( rq )
					{
						case RelationshipQualifier.root:
							GetRoots();
							break;

						case RelationshipQualifier.child:
							GetChildren();
							break;

						case RelationshipQualifier.parent:
							GetParents();
							break;
					}
				}
			}
		}

		public void GetRoots()
		{
			Roots = new CategoryValueCollection();
			SqlDataReader rdr = GetValues( RelationType.Root );

			try
			{
				SqlDataReaderAccessor dracc	= new SqlDataReaderAccessor( rdr );

				while( rdr.Read() )
				{
					Roots.Add( dracc.GetString( KeyNameIndex ),
						dracc.GetString( KeyValueIndex ),
						dracc.GetString( ParentKeyValueIndex ),
						( 1 == dracc.GetInt( IsValidIndex ) ) );
				}
			}
			finally
			{
				rdr.Close();
			}
		}

		public void GetChildren()
		{
			Children = new CategoryValueCollection();
			SqlDataReader rdr = GetValues( RelationType.Child );

			try
			{
				SqlDataReaderAccessor dracc	= new SqlDataReaderAccessor( rdr );

				while( rdr.Read() )
				{
					Children.Add( dracc.GetString( KeyNameIndex ),
						dracc.GetString( KeyValueIndex ),
						dracc.GetString( ParentKeyValueIndex ),
						( 1 == dracc.GetInt( IsValidIndex ) ) );
				}
			}
			finally
			{
				rdr.Close();
			}
		}

		public void GetParents()
		{
			Parents = new CategoryValueCollection();
			SqlDataReader rdr = GetValues( RelationType.Parent );

			try
			{
				SqlDataReaderAccessor dracc	= new SqlDataReaderAccessor( rdr );

				while( rdr.Read() )
				{
					Parents.Add( dracc.GetString( KeyNameIndex ),
						dracc.GetString( KeyValueIndex ),
						dracc.GetString( ParentKeyValueIndex ),
						( 1 == dracc.GetInt( IsValidIndex ) ) );
				}
			}
			finally
			{
				rdr.Close();
			}
		}

		public CategoryInfo(){}
	}
	
	[XmlInclude( typeof( CategoryInfo ) )]
	public class CategoryValue
	{
		[XmlAttribute( "tModelKey" )]
		public string TModelKey = null;

		[XmlAttribute( "keyName" )]
		public string KeyName = null;
	    
		[XmlAttribute( "keyValue" )]
		public string KeyValue = null;
	    
		[XmlAttribute( "parentKeyValue" )]
		public string ParentKeyValue = null;
	    
		[XmlAttribute( "isValid" )]
		public bool IsValid = false;

		public CategoryValue()
		{
		}

		public CategoryValue( string tmodelkey, string keyvalue )
		{
			TModelKey = tmodelkey;
			KeyValue = keyvalue;
		}

		public CategoryValue( string keyname, string keyvalue, string parent, bool isvalid )
		{
			KeyName = keyname;
			KeyValue = keyvalue;
			ParentKeyValue = parent;
			IsValid = isvalid;
		}
	
		public void Save( string TModelKey )
		{
			Debug.Enter();

			if( !Utility.StringEmpty( ParentKeyValue ) )
				Debug.Verify( KeyValue != ParentKeyValue, "UDDI_ERROR_FATALERROR_PARENTKEYEQUALSVALUE", ErrorType.E_fatalError );

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_taxonomyValue_save" );
			
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
			sp.Parameters.Add( "@parentKeyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
			sp.Parameters.Add( "@keyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyName );
			sp.Parameters.Add( "@valid", SqlDbType.Bit );
			
			sp.Parameters.SetGuidFromKey( "@tModelKey", TModelKey );
			sp.Parameters.SetString( "@keyValue", KeyValue );
			sp.Parameters.SetString( "@parentKeyValue", ParentKeyValue );
			sp.Parameters.SetString( "@keyName", KeyName );
			sp.Parameters.SetBool( "@valid" , IsValid );

			sp.ExecuteNonQuery();

			Debug.Leave();
		}
	}

	public class CategoryValueCollection : CollectionBase
	{
		public CategoryValueCollection()
		{
		}

		public CategoryValue this[int index]
		{
			get 
			{ return (CategoryValue)List[index]; }
			set 
			{ List[index] = value; }
		}
		public int Add( string keyname, string keyvalue, string parent, bool isvalid )
		{
			return List.Add( new CategoryValue( keyname, keyvalue, parent, isvalid ) );
		}

		public int Add(CategoryValue value)
		{
			return List.Add(value);
		}

		public void Insert(int index, CategoryValue value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( CategoryValue value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( CategoryValue value )
		{
			return List.Contains( value );
		}
		
		public void Remove( CategoryValue value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(CategoryValue[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public void CopyTo( CategoryValue[] array )
		{
			foreach( CategoryValue tax in array )
				Add( tax );
		}

		public CategoryValue[] ToArray()
		{
			return (CategoryValue[]) InnerList.ToArray( typeof( CategoryValue ) );
		}
	}

	public class CategoryCollection : CollectionBase
	{
		public CategoryCollection()
		{
		}

		public Category this[int index]
		{
			get { return (Category)List[index]; }
			set { List[index] = value; }
		}

		public int Add(Category value)
		{
			return List.Add(value);
		}

		public void Insert(int index, Category value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( Category value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( Category value )
		{
			return List.Contains( value );
		}
		
		public void Remove( Category value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(Category[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public void CopyTo( Category[] array )
		{
			foreach( Category tax in array )
				Add( tax );
		}

		public Category[] ToArray()
		{
			return (Category[]) InnerList.ToArray( typeof( Category ) );
		}
	}

	public class CategoryInfoCollection : CollectionBase
	{
		public CategoryInfoCollection()
		{
		}

		public CategoryInfo this[int index]
		{
			get 
			{ return (CategoryInfo)List[index]; }
			set 
			{ List[index] = value; }
		}

		public int Add(CategoryInfo value)
		{
			return List.Add(value);
		}

		public void Insert(int index, CategoryInfo value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( CategoryInfo value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( CategoryInfo value )
		{
			return List.Contains( value );
		}
		
		public void Remove( CategoryInfo value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(CategoryInfo[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public void CopyTo( CategoryInfo[] array )
		{
			foreach( CategoryInfo tax in array )
				Add( tax );
		}

		public CategoryInfo[] ToArray()
		{
			return (CategoryInfo[]) InnerList.ToArray( typeof( CategoryInfo ) );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\makefile.inc ===
foo.cs:
	..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\email.cs ===
using System;
using System.Data;
using System.Collections;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;

namespace UDDI.API.Business
{
	public class Email
	{
		[XmlAttribute("useType")]
		public string UseType;

		[XmlText()]
		public string Value;

		public Email()
		{		
		}

		public Email( string email, string useType )
		{
			Value = email;
			UseType = useType;
		}

		internal void Validate()
		{
			Utility.ValidateLength( ref UseType, "useType", UDDI.Constants.Lengths.UseType );
			Utility.ValidateLength( ref Value, "email", UDDI.Constants.Lengths.Email );
		}
		
		public void Save( long contactID )
		{
			//
			// Create a command object to invoke the stored procedure
			//
			SqlCommand cmd = new SqlCommand( "net_contact_email_save", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;
			
			//
			// Input parameters
			//
			cmd.Parameters.Add( new SqlParameter( "@contactID", SqlDbType.BigInt ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@email", SqlDbType.NVarChar, UDDI.Constants.Lengths.Email ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@useType", SqlDbType.NVarChar, UDDI.Constants.Lengths.UseType ) ).Direction = ParameterDirection.Input;

			//
			// Set parameter values
			//
			SqlParameterAccessor parmacc = new SqlParameterAccessor( cmd.Parameters );
			parmacc.SetLong( "@contactID", contactID );
			parmacc.SetString( "@email", Value );
			parmacc.SetString( "@useType", UseType );

			cmd.ExecuteNonQuery();
		}
	}
	
	public class EmailCollection : CollectionBase
	{
		internal void Validate()
		{
			foreach( Email email in this)
			{
				email.Validate();
			}
		}
		
		public void Save( long contactID )
		{
			//
			// Walk collection and call save on individual contact instances
			//
			foreach( Email email in this)
				email.Save( contactID );
		}
		
		public void Get( long contactID )
		{		
			//
			// Create a command object to invoke the stored procedure net_get_contacts
			//
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_contact_emails_get" );
						
			//
			// Add parameters and set values
			//				
			cmd.Parameters.Add( "@contactID", SqlDbType.BigInt, ParameterDirection.Input );
			cmd.Parameters.SetLong( "@contactID", contactID );

			//
			// Run the stored procedure
			//
			SqlDataReaderAccessor reader = cmd.ExecuteReader();
			try
			{		
#if never		
				while( reader.Read() )
				{
					//
					// Construct a new Email from the data in this row
					//
					this.Add( dracc.GetString( EmailIndex ), dracc.GetString( UseTypeIndex ) );
				}
#endif
			}
			finally
			{
				reader.Close();
			}
		}

		public void Read( SqlDataReaderAccessor reader )
		{
			const int UseTypeIndex = 0;
			const int EmailIndex = 1;

			while( reader.Read() )
			{
				//
				// Construct a new Email from the data in this row
				//
				this.Add( reader.GetString( EmailIndex ), reader.GetString( UseTypeIndex ) );
			}
		}

		public Email this[ int index ]
		{
			get { return (Email)List[index]; }
			set	{ List[ index ] = value; }
		}

		public int Add()
		{
			return List.Add( new Email() );
		}

		public int Add( Email emailObject )
		{
			return List.Add( emailObject );
		}

		public int Add( string email )
		{
			return ( Add( email, null ) );
		}

		public int Add( string email, string useType )
		{
			return List.Add( new Email( email, useType ) );
		}

		public void Insert( int index, Email value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( Email value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( Email value )
		{
			return List.Contains( value );
		}

		public void Remove( Email value )
		{
			List.Remove( value );
		}

		public void CopyTo( Email[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\discoveryurl.cs ===
using System;
using System.Web;
using System.IO;
using System.Data;
using System.Text;
using System.Collections;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API.Business
{
	public class DiscoveryUrl
	{
		[XmlAttribute("useType")]
		public string UseType;

		[XmlText]
		public string Value;

		public DiscoveryUrl()
		{
		}

		public DiscoveryUrl( string url )
		{
			this.Value = url;
			this.UseType = "";
		}

		public DiscoveryUrl( string url, string useType )
		{
			this.Value = url;
			this.UseType = useType;
		}

		internal void Validate()
		{
			if( null == UseType )
				UseType = "";

			Utility.ValidateLength( ref UseType, "useType", UDDI.Constants.Lengths.UseType );
			Utility.ValidateLength( ref Value, "discoveryURL", UDDI.Constants.Lengths.DiscoveryURL );
		}

		public void Save( string businessKey )
		{
			//
			// Create a command object to invoke the stored procedure
			//
			SqlCommand cmd = new SqlCommand( "net_businessEntity_discoveryUrl_save", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;
		
			//
			// Input parameters
			//
			cmd.Parameters.Add( new SqlParameter( "@businessKey", SqlDbType.UniqueIdentifier ) );
			cmd.Parameters.Add( new SqlParameter( "@useType", SqlDbType.NVarChar, UDDI.Constants.Lengths.UseType ) );
			cmd.Parameters.Add( new SqlParameter( "@discoveryUrl", SqlDbType.NVarChar, UDDI.Constants.Lengths.DiscoveryURL ) );

			//
			// Set parameters
			//
			SqlParameterAccessor parmacc = new SqlParameterAccessor( cmd.Parameters );
			parmacc.SetGuidFromString( "@businessKey", businessKey );
			parmacc.SetString( "@useType", UseType );
			parmacc.SetString( "@discoveryUrl", Value );

			//
			// Execute save
			//
			cmd.ExecuteNonQuery();
		}

        public bool IsDefault( string businessKey )
        {
            Debug.VerifySetting( "DefaultDiscoveryURL" );

            string defaultDiscoveryUrl = Config.GetString( "DefaultDiscoveryURL" ) + businessKey;

			return ( null != UseType )							&& 
				   ( "businessentity" == UseType.ToLower() )	&& 
				   ( string.Compare( defaultDiscoveryUrl, Value, true ) == 0 );			
        }
	}

	public class DiscoveryUrlCollection : CollectionBase
	{
		public DiscoveryUrl this[int index]
		{
			get 
			{ return (DiscoveryUrl)List[index]; }
			set 
			{ List[index] = value; }
		}

		public void Get( string businessKey )
		{
			//
			// This procedure add the discoveryURLs that were persisted to the database
			// this does not include the default discoveryURL, it is added by the the businessEntity.Get()
			// method since it has the visibility of the operator name who owns the entity.
			//
			
			//
			// Create a command object to invoke the stored procedure
			//
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_businessEntity_discoveryURLs_get" );
						
			//
			// Add parameters
			//
			cmd.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );			
			cmd.Parameters.SetGuidFromString( "@businessKey", businessKey );

			//
			// Execute query
			//
			SqlDataReaderAccessor reader = cmd.ExecuteReader();
			try
			{
				Read( reader );
			}
			finally
			{
				reader.Close();
			}

#if never
			//
			// This procedure add the discoveryURLs that were persisted to the database
			// this does not include the default discoveryURL, it is added by the the businessEntity.Get()
			// method since it has the visibility of the operator name who owns the entity.
			//
			const int UseTypeIndex = 0;
			const int UrlIndex = 1;

			//
			// Create a command object to invoke the stored procedure
			//
			SqlCommand cmd = new SqlCommand( "net_businessEntity_discoveryURLs_get", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();		
			cmd.CommandType = CommandType.StoredProcedure;

			//
			// Add parameters
			//
			cmd.Parameters.Add( new SqlParameter( "@businessKey", SqlDbType.UniqueIdentifier ) );
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
			paramacc.SetGuidFromString( "@businessKey", businessKey );

			//
			// Execute query
			//
			SqlDataReader rdr = cmd.ExecuteReader();
			try
			{
				SqlDataReaderAccessor rdracc = new SqlDataReaderAccessor( rdr );

				//
				// The discoveryUrls will be contained in the result set
				//
				while( rdr.Read() )
				{
					string useType = rdracc.GetString( UseTypeIndex );

					if( null == useType )
						useType = "";

					Add( rdracc.GetString( UrlIndex ), useType );
				}
			}
			finally
			{
				rdr.Close();
			}
#endif
		}
	
		public void Read( SqlDataReaderAccessor reader )
		{
			const int UseTypeIndex = 0;
			const int UrlIndex = 1;

			//
			// The discoveryUrls will be contained in the result set
			//
			while( reader.Read() )
			{
				string useType = reader.GetString( UseTypeIndex );

				if( null == useType )
					useType = "";

				Add( reader.GetString( UrlIndex ), useType );
			}
		}

		internal void Validate()
		{
			foreach( DiscoveryUrl discoveryUrl in this )
			{
				discoveryUrl.Validate();
			}
		}
		
		public void Save( string businessKey )
		{			
			//
			// Keep a separate remove list.
			//
			DiscoveryUrlCollection duplicateUrls = null;

			foreach( DiscoveryUrl discoveryUrl in this )
			{
				//
				// If we are not doing replication, then we want to check to make sure that we don't persist the
				// default discovery url.				
				//
				if( ContextType.Replication != Context.ContextType )
				{
					//
					// Make sure we don't persist the default discoveryURL
					//
					if( !discoveryUrl.IsDefault( businessKey ) )
					{
						discoveryUrl.Save( businessKey );
					}
					else
					{
						if( null == duplicateUrls )
						{
							duplicateUrls = new DiscoveryUrlCollection();
						}

						duplicateUrls.Add( discoveryUrl );
					}
				}
				else
				{
					discoveryUrl.Save( businessKey );
				}
			}

			//
			// Remove duplicates if we have any.
			//
			if( null != duplicateUrls )
			{	
				foreach( DiscoveryUrl duplicateUrl in duplicateUrls )
				{
					this.Remove( duplicateUrl );
				}		
			}			
		}

		internal void AddDefaultDiscoveryUrl( string businessKey )
		{
            Debug.VerifySetting( "DefaultDiscoveryURL" );

            string defaultDiscoveryUrl = Config.GetString( "DefaultDiscoveryURL" ) + businessKey;
            
            //
			// Check to see if the collection already contains the default
			// discovery URL.  If so, we don't need to add one.
			// This check is needed since some of the legacy code used to
			// permit the persistence of the default discovery URL.
			//
			foreach( DiscoveryUrl discoveryUrl in this )
			{
				if( discoveryUrl.IsDefault( businessKey ) )
					return;
			}

			Add( defaultDiscoveryUrl, "businessEntity" );
		}

		public int Add()
		{	
			return List.Add( new DiscoveryUrl() );
		}
		
		public int Add( DiscoveryUrl value )
		{
			return List.Add( value );
		}
		
		public int Add( string strUrl )
		{
			return List.Add( new DiscoveryUrl( strUrl ) );	
		}
		
		public int Add( string strUrl, string strUseType )
		{
			return List.Add( new DiscoveryUrl( strUrl, strUseType ) );
		}
		
		public void Insert( int index, DiscoveryUrl value )
		{
			List.Insert( index, value );
		}
		
		public int IndexOf( DiscoveryUrl value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( DiscoveryUrl value )
		{
			return List.Contains( value );
		}
		
		public void Remove( DiscoveryUrl value )
		{
			List.Remove(value);
		}
		
		public void CopyTo( DiscoveryUrl[] array )
		{
			foreach( DiscoveryUrl discoveryUrl in array )
				Add( discoveryUrl );
		}

		public DiscoveryUrl[] ToArray()
		{
			return (DiscoveryUrl[])InnerList.ToArray( typeof( DiscoveryUrl ) );
		}
	}

	/// ****************************************************************
	///   public class DiscoveryUrlHandler
	///	----------------------------------------------------------------
	///	  <summary>
	///		DiscoveryUrlHandler implements the IHttpHandler interface.
	///		It is designed to retrieve businessEntity details for a businessKey
	///		specified as part of the HTTP query string
	///		e.g. http://uddi.microsoft.com/discovery?businessKey=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
	///	  </summary>
	/// ****************************************************************
	/// 
	public class DiscoveryUrlHandler : IHttpHandler 
	{
		public void ProcessRequest( HttpContext ctx ) 
		{			
			try
			{
				//
				// Verify the GET verb was used and that a query string is 
				// specified.
				//
				if( "GET" != ctx.Request.RequestType.ToUpper() )
				{
					ctx.Response.AddHeader( "Allow", "GET" );
					ctx.Response.StatusCode = 405; // Method Not Allowed

					return;
				}

				if( null == ctx.Request.QueryString[ "businessKey" ] )
				{
					ctx.Response.StatusCode = 400; // Bad Request
					ctx.Response.Write( "<h1>400 Bad Request</h1>Missing required argument 'businessKey'" );

					return;
				}

				//
				// Attempt to retrieve the business entity.
				//
				ConnectionManager.Open( false, false );
				string businessKey = ctx.Request.QueryString[ "businessKey" ];
				BusinessEntity be = new BusinessEntity( businessKey );
				be.Get();

				//
				// Serialize the business Entity to the response stream
				// using UTF-8 encoding
				//
				// XmlSerializer serializer = new XmlSerializer( be.GetType() );
				XmlSerializer serializer = XmlSerializerManager.GetSerializer( be.GetType() );

				UTF8Encoding utf8 = new UTF8Encoding( false );
				StreamWriter sr = new StreamWriter( ctx.Response.OutputStream, utf8 );
				serializer.Serialize( sr, be );

				ctx.Response.AddHeader( "Content-Type", "text/xml; charset=utf-8" );
			}
			catch( FormatException e )
			{
				//
				// We get a FormatException when passed a bad GUID.
				//
				ctx.Response.StatusCode = 400; // Bad Request
				ctx.Response.Write( "<h1>400 Bad Request</h1>" + e.Message );
			}
			catch( SqlException e )
			{
				//
				// We get a SqlException when we could not get the data.
				//
				ctx.Response.StatusCode = 400; // Bad Request
				ctx.Response.Write( "<h1>400 Bad Request</h1>" + e.Message );
			}
			catch( UDDIException e )
			{
				ctx.Response.StatusCode = 400; // Bad Request
				ctx.Response.Write( "<h1>400 Bad Request</h1>" + e.Message );
			}
			catch( Exception e )
			{
				ctx.Response.StatusCode = 500; // Internal Server Error
				ctx.Response.Write( "<h1>500 Internal Server Error</h1>" );

				Debug.OperatorMessage( SeverityType.Error, CategoryType.None, OperatorMessageType.None, e.ToString() );
			}
			finally
			{
				ConnectionManager.Close();
			}
		}

		public bool IsReusable 
		{
			get 
			{
				return true;
			}
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\extension.cs ===
using System;
using System.IO;
using System.Web;
using System.Data;
using System.Text;
using System.Xml;
using System.Data.SqlClient;
using System.Xml.Serialization;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using System.Web.Services.Protocols;
using System.Web.Security;
using UDDI;
using UDDI.Diagnostics;
using UDDI.API.Authentication;

namespace UDDI.API
{
	public class UDDIExtension : SoapExtension 
	{
		Data data;
		DateTime begin;

		private class Data
		{
			public bool log = true;
			public bool https = false;
			public bool validate = true;
			public bool performance = true;
			public bool authenticate = false;
			public bool transaction = false;
			public bool certificate = false;
			public string messageType = "";

			public Data( 
						bool log, 
						bool validate,
						bool performance,
						bool authenticate,
						bool transaction,
						bool https,
						bool certificate,
						string messageType )
			{
				this.log = log;
				this.https = https;
				this.validate = validate;
				this.performance = performance;
				this.authenticate = authenticate;
				this.transaction = transaction;
				this.certificate = certificate;
				this.messageType = messageType;
			}
		}

		static UDDIExtension()
		{
			Context.ContextType = ContextType.SOAP;
		}

		private void CheckForHttps( SoapMessage message )
		{
			Debug.Enter();
			
			if( 1 == Config.GetInt( "Security.HTTPS", 1 ) )
			{
				Debug.Write( SeverityType.Info, CategoryType.Soap, "URL: " + message.Url );
				Debug.Verify( message.Url.ToLower().StartsWith( "https" ), "UDDI_ERROR_FATALERROR_HTTPSREQUIREDFORPUBLISH" );
			}
			else
			{
				Debug.Write( SeverityType.Warning, CategoryType.Soap, "HTTPS check is turned off. Content may be published without SSL. To turn this check on remove or modify the Security.HTTPS configuration setting" );
			}

			Debug.Leave();
		}

		private void CheckCertificate( SoapMessage message )
		{
			HttpClientCertificate httpCert = HttpContext.Current.Request.ClientCertificate;
			X509Certificate requestCert = new X509Certificate( httpCert.Certificate );

			Debug.Verify( !Utility.StringEmpty( httpCert.Issuer ), "UDDI_ERROR_FATALERROR_CLIENTCERTREQUIRED" );
			Debug.Verify( !Utility.StringEmpty( httpCert.Subject ), "UDDI_ERROR_FATALERROR_CLIENTCERTREQUIRED" );

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_operatorCert_get" );

			sp.Parameters.Add( "@certSerialNo", SqlDbType.NVarChar, UDDI.Constants.Lengths.CertSerialNo );

			sp.Parameters.SetString( "@certSerialNo", requestCert.GetSerialNumberString() );

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				if( reader.Read() )
				{
					Context.RemoteOperator = reader.GetGuidString( "operatorKey" );

					byte[] operatorCertRaw = reader.GetBinary( "certificate" );
					byte[] requestCertRaw = httpCert.Certificate;

					Debug.Verify( 
						null != operatorCertRaw, 
							"UDDI_ERROR_FATALERROR_CLIENTCERTNOTSTORED", 
							ErrorType.E_fatalError,
							Context.RemoteOperator );
					
					if( operatorCertRaw.Length != requestCertRaw.Length )
					{
						throw new UDDIException(
							ErrorType.E_unknownUser,
							"UDDI_ERROR_UNKNOWNUSER_UNKOWNCERT" );
					}

					for( int i = 0; i < operatorCertRaw.Length; i ++ )
					{
						if( operatorCertRaw[ i ] != requestCertRaw[ i ] )
						{
							throw new UDDIException(
								ErrorType.E_unknownUser,
								"UDDI_ERROR_UNKNOWNUSER_UNKOWNCERT" );
						}
					}
					
					/*
					 * TODO: Check to see if this works instead
					 * 
					  
					X509Certificate operatorCert = new X509Certificate( operatorCertRaw );
					X509Certificate requestCert = new X509Certificate( requestCertRaw );

					if( !requestCert.Equals( operatorCert ) )
					{
						throw new UDDIException(
							ErrorType.E_unknownUser,
							"Unknown certificate" );
					}
					*/
				}
				else
				{
					throw new UDDIException(
						ErrorType.E_unknownUser,
						"UDDI_ERROR_UNKNOWNUSER_UNKOWNCERT" );
				}
			}
			finally
			{
				reader.Close();
			}
		}

		private void Validate( SoapMessage message )
		{
			Debug.Enter();

			StreamReader srdr = new StreamReader( message.Stream, System.Text.Encoding.UTF8 );		
#if DEBUG
			Debug.Write( SeverityType.Verbose, CategoryType.None, srdr.ReadToEnd() );
			message.Stream.Seek( 0,System.IO.SeekOrigin.Begin );
#endif 
			//
			// Validate incoming XML, ValidateStream will rewind stream when finished 
			// so I don't have to.
			//
			SchemaCollection.Validate( message.Stream );

			Debug.Leave();
		}

		private void PublishMethodBegin( SoapMessage message )
		{
			Debug.Enter();
			begin = DateTime.Now;
			Debug.Leave();
		}

		private void PublishMethodEnd( SoapMessage message )
		{
			Debug.Enter();

			TimeSpan duration = DateTime.Now - begin;
			Debug.Write( SeverityType.Info, CategoryType.Soap, "Message took " + duration.TotalMilliseconds.ToString() + " ms" );
			
			Performance.PublishMessageData( data.messageType, duration );
			
			Debug.Leave();
		}

		//
		// What follows is the logic for selection of the authentication algorithm
		// Enjoy boys and girls
		//		
		//	    Bit 3 - Anonymous User
		//	     Bit 2 - UDDI Authentication Mode
		//	      Bit 1 - Windows Authentication Mode
		//		   Bit 0 - Ticket Present
		//         |
		//		   |		Authentication Module Used
		//		0000		X
		//		0001		X
		//		0010		Windows
		//		0011		Exception ( UDDI authentication turned off )
		//		0100		UDDI ( will fail authentication due to invalid credentials )
		//		0101		UDDI
		//		0110		Windows
		//		0111		UDDI
		//		1000		X
		//		1001		X
		//		1010		Exception UDDI authentication turned off
		//		1011		Exception ""
		//		1100		UDDI ( will fail authentication due to invalid credentials )
		//		1101		UDDI
		//		1110		UDDI ( will fail authentication due to invalid credentials )
		//		1111		UDDI
		//		
		//
		// Reduction Work
		//
		// A - Anonymous User
		// B - UDDI Authentication Mode
		// C - Windows Authentication Mode
		// D - Ticket Present
		//
		// Key
		//		e - throw exception invalid configuration
		//		x - invalid state
		//      w - windows authentication
		//		u - uddi authentication
		//
		//		CD
		//	AB	00 01 11 10
		//	00  x  x  e  w
		//	01  u  u  u  w
		//	11  u  u  u  u
		//	10  x  x  e  e
		//
		// if( !A && C && !D )
		//		w - windows authentication
		// else if( B )
		//		u - uddi authentication
		// else
		//		throw exception
		//

		private void Authenticate( SoapMessage message )
		{
			Debug.Enter();

			IAuthenticateable authenticate = (IAuthenticateable) message.GetInParameterValue(0);
			//WindowsIdentity identity = (WindowsIdentity)HttpContext.Current.User.Identity;
			IIdentity identity = HttpContext.Current.User.Identity;
			int mode = Config.GetInt( "Security.AuthenticationMode", (int) AuthenticationMode.Both );

			if( mode == (int) AuthenticationMode.Passport )
			{
				if( identity is PassportIdentity )
				{
					string ticket = authenticate.AuthInfo.Trim();

					//
					// Authentication the user using the attached passport ticket
					//
					PassportAuthenticator pa = new PassportAuthenticator();
					pa.Authenticate( ticket, Config.GetInt( "Security.TimeOut", 60 ) );
				}
				else
				{
					throw new UDDIException( ErrorType.E_fatalError, 
						"UDDI_ERROR_FATALERROR_PASSPORTBADCONFIG" ) ;
				}
				Debug.Write( SeverityType.Info, CategoryType.Soap, "Authenticated user: using Passport based authentication Identity is " + identity.Name );
				
			}
			else if( !( (WindowsIdentity)identity ).IsAnonymous && 
				( ( mode & (int) AuthenticationMode.Windows ) != 0 ) &&
				Utility.StringEmpty( authenticate.AuthInfo ) )
			{
				/* 0X10 Case */
				//
				// Authenticate the user using the currently impersonated credentials
				//
				WindowsAuthenticator wa = new WindowsAuthenticator();
				wa.Authenticate( authenticate.AuthInfo, Config.GetInt( "Security.TimeOut", 60 ) );

				Debug.Write( SeverityType.Info, CategoryType.Soap, "Authenticated user: using Windows based authentication Identity is " + identity.Name );
			}
			else if( ( mode & (int) AuthenticationMode.Uddi ) != 0 )
			{
				/* X1XX Case for leftovers */
				//
				// If windows authentication is turned off or the 
				Debug.Write( SeverityType.Info, CategoryType.Soap, "Anonymous user: using UDDI authentication" );

				//
				// Authenticate the user using the authToken 
				//
				UDDIAuthenticator ua = new UDDIAuthenticator();
				ua.Authenticate( authenticate.AuthInfo, Config.GetInt( "Security.TimeOut", 60 ) );
			}
			else
			{
				//
				// Throw exception for the rest
				//
				throw new UDDIException( UDDI.ErrorType.E_unsupported,
					"UDDI_ERROR_UNSUPPORTED_BADAUTHENTICATIONCONFIG" );
			}

			//
			// Check to make sure the authenticated user has publisher credentials
			//
			Debug.Verify( Context.User.IsPublisher, 
				"UDDI_ERROR_FATALERROR_USERNOPUBLISHERCRED",
				UDDI.ErrorType.E_fatalError,
				Context.User.ID  );

			//
			// The server can be configured for automatic registration of publishers with credentials
			// 
			if( !Context.User.IsRegistered )
			{
				if( 1 == Config.GetInt( "Security.AutoRegister", 0 ) )
				{
					//
					// Mark the user as verified.
					//
					Context.User.TrackPassport = false;
					Context.User.Verified = true;

					Context.User.Register();
				}
				else
				{
					throw new UDDIException( UDDI.ErrorType.E_unknownUser,
						"UDDI_ERROR_UNKNOWNUSER_NOTREGISTERED" );
				}
			}

			Context.User.Login();
#if DEBUG
			Debug.Write( SeverityType.Info, CategoryType.Soap, "Windows Identity is " + WindowsIdentity.GetCurrent().Name );
			Debug.Write( SeverityType.Info, CategoryType.Soap, "Thread Identity is " + System.Threading.Thread.CurrentPrincipal.Identity.Name );
			Debug.Write( SeverityType.Info, CategoryType.Soap, "HttpContext Identity is " + identity.Name );
			Debug.Write( SeverityType.Info, CategoryType.Soap, "IsAdministrator = " + Context.User.IsAdministrator );
			Debug.Write( SeverityType.Info, CategoryType.Soap, "IsCoordinator = " + Context.User.IsCoordinator );
			Debug.Write( SeverityType.Info, CategoryType.Soap, "IsPublisher = " + Context.User.IsPublisher );
			Debug.Write( SeverityType.Info, CategoryType.Soap, "IsUser = " + Context.User.IsUser );
#endif
			Debug.Leave();
		}


		public override object GetInitializer( Type t )
		{
			return null;
		}

		public override object GetInitializer( LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute ) 
		{
			UDDIExtensionAttribute attr = (UDDIExtensionAttribute) attribute;
			return new Data( attr.log, attr.validate, attr.performance, attr.authenticate, attr.transaction, attr.https, attr.certificate, attr.messageType );
		}

		public override void Initialize( object initializer ) 
		{
			data = (UDDIExtension.Data) initializer;
		}

		public override void ProcessMessage(SoapMessage message) 
		{
			Debug.Enter();

#if DEBUG
			string info = "log: " + data.log.ToString() +
						"; https: " + data.https.ToString() +
						"; validate: " + data.validate.ToString() +
						"; performance: " + data.performance.ToString() +
						"; authenticate: " + data.authenticate.ToString() +
						"; transaction: " + data.transaction.ToString() +
						"; messageType: " + data.messageType;

			Debug.Write( SeverityType.Info, CategoryType.Soap, info );
#endif
			try
			{
				switch( message.Stage ) 
				{
					//
					// First Event
					//
					case SoapMessageStage.BeforeDeserialize:
						//
						// Initialize our context.
						//
						Context.Current.Initialize();

						Config.CheckForUpdate();

						//
						// TODO: Since we are using DispositionReport.ThrowFinal() I don't think this is
						// needed anymore.
						//

						//
						// Check to make sure the authenticated user has user credentials
						//
						Debug.Verify( "1" != HttpContext.Current.Request.ServerVariables[ "Exception" ], 
							"UDDI_ERROR_FATALERROR_VERSIONCHECKERROR",
							UDDI.ErrorType.E_fatalError );

						Debug.Write( SeverityType.Info, CategoryType.Soap, "URL: " + message.Url );
						Debug.Write( SeverityType.Info, CategoryType.Soap, "SOAPAction: " + HttpContext.Current.Request.Headers[ "SOAPAction" ] );
						
						string contentType = HttpContext.Current.Request.ContentType.ToLower();

						bool validEncoding = ( contentType.IndexOf( "charset=\"utf-8\"" ) >= 0 ) || 
								( contentType.IndexOf( "charset=utf-8" ) >= 0 );

						Debug.Verify( validEncoding, "UDDI_ERROR_UNSUPPORTED_CONTENTTYPEHEADERMISSING", ErrorType.E_unsupported );

						if( data.performance )
							PublishMethodBegin( message );

						if( data.https )
							CheckForHttps( message );

						//
						// Validation has been moved into the other SOAP extension
						//
//						if( data.validate )
//							Validate( message );
						
						break;

					//
					// Second Event
					//
					case SoapMessageStage.AfterDeserialize:

						ConnectionManager.Open( data.transaction, data.transaction );

						if( data.certificate )
							CheckCertificate( message );

						if( data.authenticate )
							Authenticate( message );
						else if( 0 != ( Config.GetInt( "Security.AuthenticationMode", (int) AuthenticationMode.Both )
									& (int) AuthenticationMode.AuthenticatedRead ) )
						{
							//
							// Authenticated reads are turned on and this is a read request
							// Make sure the caller is authenticated using Windows and is at least a user
							//
							WindowsIdentity identity = (WindowsIdentity) HttpContext.Current.User.Identity;
							WindowsAuthenticator wa = new WindowsAuthenticator();
							wa.Authenticate( "", 0 /* not used */ );

							Debug.Write( SeverityType.Info, CategoryType.Soap, "Authenticated user: using Windows based authentication Identity is " + identity.Name );

							//
							// Check to make sure the authenticated user has user credentials
							//
							Debug.Verify( Context.User.IsUser, 
								"UDDI_ERROR_FATALERROR_NOUSERCREDS",
								UDDI.ErrorType.E_fatalError,
								Context.User.ID );
						}

						break;

					//
					// Third Event
					//
					case SoapMessageStage.BeforeSerialize:
						break;

					//
					// Last Event
					//
					case SoapMessageStage.AfterSerialize:

						//
						// Cleanup the connection and commit the database activity
						//
						if( data.transaction && 
							( null != (object) ConnectionManager.GetConnection() ) && 
							( null != (object) ConnectionManager.GetTransaction() ) )
						{
							if( null == (object) message.Exception )
							{
								ConnectionManager.Commit();
							}
							else
							{
								ConnectionManager.Abort();
							}
						}

						ConnectionManager.Close();

						try
						{
							if( data.performance )
								PublishMethodEnd( message );
						}
						catch
						{
							Debug.OperatorMessage(
								SeverityType.Warning,
								CategoryType.None,
								OperatorMessageType.UnableToPublishCounter,
								"An error occurred while trying to publish a performance counter, the system will continue"	);
						}

						break;

					default:
						throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_UNKNOWNEXTSTAGE" );
				}
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			Debug.Leave();
		}

		public override Stream ChainStream( Stream stream )
		{
			return base.ChainStream( stream );
		}
	}

	[AttributeUsage(AttributeTargets.Method, AllowMultiple=false)]
	public class UDDIExtensionAttribute : SoapExtensionAttribute 
	{
		private int priority;

		//
		// The default constructor should be configured for the inquire API set
		//
		public UDDIExtensionAttribute() : this( true, true, true, false, false, false, false, "" ){}
		public UDDIExtensionAttribute( 
						bool log, 
						bool validate, 
						bool performance,
						bool authenticate,
						bool transaction, 
						bool https,
						bool certificate,
						string messageType )
		{
			this.log = log;
			this.https = https;
			this.validate = validate;
			this.performance = performance;
			this.authenticate = authenticate;
			this.transaction = transaction;
			this.certificate = certificate;
			this.messageType = messageType;
		}

		public override Type ExtensionType 
		{
			get { return typeof(UDDIExtension); }
		}

		public override int Priority 
		{
			get { return priority; }
			set { priority = value; }
		}

		public bool log;
		public bool https;
		public bool validate;
		public bool performance;
		public bool authenticate;
		public bool transaction;
		public bool certificate;
		public string messageType;
	}

	/// ********************************************************************
	///   public class VersionSupportExtension
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class VersionSupportExtension : SoapExtension 
	{
		Stream oldStream;
		Stream newStream;
		
		public override object GetInitializer( LogicalMethodInfo methodInfo, SoapExtensionAttribute attribute ) 
		{
			return null;
		}

		public override object GetInitializer( Type type ) 
		{
			return null;
		}

		public override void Initialize( object initializer ) 
		{			
		}

		public override void ProcessMessage(SoapMessage message) 
		{						
			try
			{
				switch( message.Stage ) 
				{
					case SoapMessageStage.BeforeDeserialize:		
						//
						// Check to see if the server has been manually stopped.
						//
						if( 0 == Config.GetInt( "Run", 1 ) )
						{
							DispositionReport.ThrowFinal( new UDDIException( ErrorType.E_busy, "UDDI_ERROR_BUSY_SERVICENOTAVAILABLE" ) );

							//
							// DispositionReport.ThrowFinal will close the HTTP stream so there is no point going on in this method
							//
							return;
						}
													
						try
						{
							// 
							// Validate against the UDDI schemas
							//
							SchemaCollection.Validate( oldStream );							
						}
						catch( Exception e )
						{
							DispositionReport.ThrowFinal( new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_SCHEMAVALIDATIONFAILED", e.Message ) );
							
							//
							// DispositionReport.ThrowFinal will close the HTTP stream so there is no point going on in this method
							//
							return;
						}

						// 
						// Make sure we only have 1 UDDI request in the SOAP body.  This method will also set the versionMajor
						// member.
						//
						CheckForSingleRequest( oldStream );
						
						//
						// If this is a v1 message, we'll first map it to the v2
						// namespace so that it can be processed by the new
						// library.
						//
						if( 1 == Context.ApiVersionMajor || 2 == Context.ApiVersionMajor)
						{
							TextReader reader = new StreamReader( oldStream );
							TextWriter writer = new StreamWriter( newStream, new System.Text.UTF8Encoding( false ) );
							string xml = reader.ReadToEnd();
									
							if( 1 == Context.ApiVersionMajor )
							{
								xml = xml.Replace( "=\"urn:uddi-org:api\"", "=\"urn:uddi-org:api_v2\"" );
								xml = xml.Replace( "='urn:uddi-org:api'",   "=\"urn:uddi-org:api_v2\"" );
							}
							writer.Write( xml );
							writer.Flush();

							newStream.Position = 0;
						}

						break;
					
					case SoapMessageStage.AfterDeserialize:					
						//
						// After the message is deserialized is the earliest place where we 
						// have access to our SOAP headers.  
						//
						CheckSOAPHeaders( message );

						//
						// Now that the message has been deserialized, make
						// sure that the generic and xmlns attributes agree.
						//
						IMessage obj = message.GetInParameterValue( 0 ) as IMessage;						
						if( null != obj )
						{
							//
							// We only need to do this if the deserialized object supports IMessage
							//
							string expected = Context.ApiVersionMajor + ".0";
							string actual = obj.Generic.Trim();

							if( expected != actual )
								throw new UDDIException( ErrorType.E_unrecognizedVersion, "UDDI_ERROR_UNKNOWNVERSION_GENERICNAMESPACEMISMATCH" );							
						}
						
						break;
					
					case SoapMessageStage.BeforeSerialize:
						break;

					case SoapMessageStage.AfterSerialize:					

						//
						// There may have been exceptions thrown during serialization.
						//
						if( null != message.Exception && 
							( null == message.Exception.Detail || 
							0 == message.Exception.Detail.ChildNodes.Count ) )
						{
							DispositionReport.ThrowFinal( new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_FAILEDDESERIALIZATION" ) );

							//
							// DispositionReport.ThrowFinal will close the HTTP stream so there is no point going on in this method
							//
							return;
						}
									
						//
						// If the original request was v1, then we'll need to
						// remap the output to use the v1 namespace.
						//
						if( 1 == Context.ApiVersionMajor || 2 == Context.ApiVersionMajor )
						{
							newStream.Position = 0;

							TextReader reader = new StreamReader( newStream );
							TextWriter writer = new StreamWriter( oldStream, new System.Text.UTF8Encoding( false ) );
								
							string xml = reader.ReadToEnd();

							//
							// We don't have to use the same 'loose' replacement as we did on the incoming request
							// because our response will be serialized such that the default namespace is our UDDI
							// namespace.
							//

							if( 1 == Context.ApiVersionMajor )
							{
								xml = xml.Replace( "xmlns=\"urn:uddi-org:api_v2\"", "xmlns=\"urn:uddi-org:api\"" );
								xml = xml.Replace( "generic=\"2.0\"", "generic=\"1.0\"" );
							}
							writer.Write( xml );
							writer.Flush();
						}

						break;

					default:
						throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_UNKNOWNEXTSTAGE" );
				}
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}
		}

		public override Stream ChainStream( Stream stream )
		{			
			oldStream = stream;			
			newStream = new MemoryStream();
			
			return newStream;				
		}

		private void CheckSOAPHeaders( SoapMessage message )
		{
			// We want to check the following:						
			//
			// - no SOAP Actor attribute exists						
			// - no SOAP headers can have a must_understand attribute set to true
			//
			// Go through each header in our message
			//
			foreach( SoapHeader header in message.Headers )
			{	
				if( header.MustUnderstand )
				{
					//
					// No headers can have this attribute set.
					//
					DispositionReport.ThrowFinal( new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_SOAP_MUSTUNDERSTANDATT" ) );

					return;
				}
										
				if( header.Actor.Length > 0 )
				{
					//
					// Can't have a SOAP Actor attribute set, generate a SOAP fault with 
					// no detail element and a 'Client' fault code
					//
					DispositionReport.ThrowFinal( new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_SOAP_ACTORATT" ) );
								
					return;
				}							
			}
		}
		
		//
		// TODO: see if there is a way to better modularize this method and rename it.
		//
		private void CheckForSingleRequest( Stream stream )
		{
			try
			{
				//
				// Move to the start of our stream
				//
				stream.Position = 0;
				XmlTextReader requestReader = new XmlTextReader( oldStream );
				requestReader.MoveToContent();

				//
				// TODO: should not hard-code SOAP names and namespaces
				//

				//
				// Move to the beginning of the SOAP envelope
				//
				requestReader.ReadStartElement( "Envelope", "http://schemas.xmlsoap.org/soap/envelope/" );

				//
				// Move to the SOAP body
				//
				while( !requestReader.IsStartElement( "Body", "http://schemas.xmlsoap.org/soap/envelope/" ) && !requestReader.EOF )
				{				
					requestReader.Skip();
				}
				
				//
				// Advance the current node to the first child of Body.  This is presumably the UDDI message
				//
				requestReader.ReadStartElement( "Body", "http://schemas.xmlsoap.org/soap/envelope/" );
				requestReader.MoveToContent();
			
				//
				// This element MUST have a UDDI namespace
				//
				string uddiNamespace = requestReader.LookupNamespace( requestReader.Prefix );
					
				switch( uddiNamespace )
				{					
					case "urn:uddi-org:api":
					{
						Context.ApiVersionMajor = 1;
						break;
					}					
					case "urn:uddi-org:api_v2":
					{
						Context.ApiVersionMajor = 2;
						break;
					}
					case "urn:uddi-microsoft-com:api_v2_extensions":
					{
						Context.ApiVersionMajor = 2;
						break;
					}
					case "urn:uddi-org:repl":
					{
						Context.ApiVersionMajor = 2;
						break;
					}
					default:
					{
						//
						// This is a problem, we don't have a UDDI namespace.  Throw an exception and get out of here.  The 
						// exception will be caught in our outer catch and sent to our client using DispositionReport.ThrowFinal.
						//

						throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_MISSINGUDDINS" );						
					}
				}				

				//
				// Skip the children of this node
				//
				requestReader.Skip();
				requestReader.MoveToContent();

				// 
				// Reset our stream so someone else can use it.
				//
				stream.Position = 0;

				//
				// If we are not at the end of the Body tag, then we have multiple requests, we should reject the message.
				// 
				if( false == requestReader.LocalName.Equals( "Body" ) )
				{					
					DispositionReport.ThrowFinal( new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_SOAP_MULTIPLEREQUEST" ) );
				}	
			}
			catch( UDDIException uddiException )
			{
				DispositionReport.ThrowFinal( uddiException );
			}
			catch
			{
				//
				// We'll get this exception if the message contains any invalid elements
				//
				DispositionReport.ThrowFinal( new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_SOAP_INVALIDELEMENT" ) );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\logs.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API
{
	public class QueryLog
	{
		public static void Write( QueryType queryType, EntityType entityType )
		{
			//
			// This can sometimes be an expensive call, so avoid it if possible.
			//
			if( 1 == Config.GetInt( "Audit.LogQueries", 0 ) )
			{
				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_queryLog_save" );

				sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );
				sp.Parameters.Add( "@contextTypeID", SqlDbType.TinyInt );
				sp.Parameters.Add( "@entityKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@queryTypeID", SqlDbType.TinyInt );
				sp.Parameters.Add( "@entityTypeID", SqlDbType.TinyInt );

				//
				// TODO: add the entityKey
				//
				sp.Parameters.SetGuidFromString( "@entityKey", "00000000-0000-0000-0000-000000000000" );
			
				sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			
				sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );
				sp.Parameters.SetShort( "@contextTypeID", (short)Context.ContextType );
				sp.Parameters.SetShort( "@queryTypeID", (short)queryType );
				sp.Parameters.SetShort( "@entityTypeID", (short)entityType );

				sp.ExecuteNonQuery();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\messages.cs ===
using System;
using System.IO;
using System.Web;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Web.Services.Protocols;
using UDDI;
using UDDI.Diagnostics;
using UDDI.API.Business;
using UDDI.API.Service;
using UDDI.API.ServiceType;
using UDDI.API.Authentication;

namespace UDDI.API
{
	/// <summary>
	/// The Documentation class is an HTTP handler that will redirect (server-side) GET requests to our .ASMX files
	/// to a help file.
	/// </summary>
	public class Documentation : IHttpHandler
	{
		public void ProcessRequest( HttpContext httpContext ) 
		{				
			
			int cultureID = Localization.GetCulture().LCID;
			string basepath =  "/help/{0}/wsdlinfo.htm";
			
			//
			// Validate that the current UI Culture is supported.  If not, revert to the default
			// language.
			//
			string pathToHelp = GetFullFilePath( string.Format( basepath,cultureID ) ) ;
			
			if( !System.IO.File.Exists( httpContext.Server.MapPath( pathToHelp ) ) )
			{
				try
				{
					cultureID = System.Globalization.CultureInfo.CreateSpecificCulture( Config.GetString( "Setup.WebServer.ProductLanguage", "en-US" ) ).LCID;
				}
				catch
				{
					cultureID = new System.Globalization.CultureInfo( Config.GetString( "Setup.WebServer.ProductLanguage", "en-US" ) ).LCID;
				}
				
				pathToHelp = GetFullFilePath( string.Format( basepath,cultureID ) );
			}
			

			//
			// Do a server-side transfer to return the proper help file to the client.
			//
			httpContext.Server.Transfer( pathToHelp );	
		}
		private static string GetFullFilePath( string file )
		{
			string url = ( ( "/"==HttpContext.Current.Request.ApplicationPath) ? "" : HttpContext.Current.Request.ApplicationPath );
			url += file ;
			return url;
		}
		public bool IsReusable 
		{
			get { return true; }
		} 
	}

	[XmlRootAttribute("get_registeredInfo", Namespace=UDDI.API.Constants.Namespace)]
	public class GetRegisteredInfo : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
	}

	[XmlRootAttribute("dispositionReport", Namespace=UDDI.API.Constants.Namespace)]
	public class DispositionReport
	{
		[XmlAttribute("generic")]
		public string Generic
		{
			get
			{
				if( 0 == Context.ApiVersionMajor )
					return "2.0";

				return Context.ApiVersionMajor.ToString() + ".0";
			}

			set { }
		}
		
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );
		
		[XmlAttribute("truncated")]
		public string Truncated;
		
		[XmlElement("result")]
		public ResultCollection Results = new ResultCollection();

		public DispositionReport() : this( ErrorType.E_success, "" )
		{
		}

		public DispositionReport( ErrorType err, string description )
		{
			Results.Add( err, description );
		}

		public static void ThrowFinal( UDDIException e )
		{
			if( 0 == Context.ApiVersionMajor )
				Context.ApiVersionMajor = 2;

			string versionedNamespace = ( Context.ApiVersionMajor == 1 ? "urn:uddi-org:api" : "urn:uddi-org:api_v2" );

			HttpContext.Current.Response.StatusCode		 = 500;			
			HttpContext.Current.Response.ContentType	 = Config.GetString( "Soap.ContentType", @"text/xml; charset=""utf-8""" );
			HttpContext.Current.Response.ContentEncoding = Encoding.UTF8;

			XmlTextWriter soapFault = new XmlTextWriter( HttpContext.Current.Response.Output );
			soapFault.WriteStartDocument();
			soapFault.WriteStartElement( "soap", "Envelope", "http://schemas.xmlsoap.org/soap/envelope/" );
				soapFault.WriteStartElement( "soap", "Body", "http://schemas.xmlsoap.org/soap/envelope/" );
					soapFault.WriteStartElement( "soap", "Fault", "http://schemas.xmlsoap.org/soap/envelope/" );						
						soapFault.WriteElementString( "soap:faultcode", "soap:Client" );			
						soapFault.WriteElementString( "soap:faultstring", "" );									
						soapFault.WriteStartElement( "soap:detail" );
							soapFault.WriteStartElement( "dispositionReport" );
								soapFault.WriteAttributeString( "generic",  "", Context.ApiVersionMajor.ToString() + ".0" );
								soapFault.WriteAttributeString( "operator", "", Config.GetString( "Operator" ) );
								soapFault.WriteAttributeString( "xmlns", versionedNamespace );					
								soapFault.WriteStartElement( "result" );
									soapFault.WriteAttributeString( "errno", "", ( ( int )e.Number ).ToString() );						
									soapFault.WriteStartElement( "errInfo" );
										soapFault.WriteAttributeString( "errCode", "", e.Number.ToString() );
										soapFault.WriteString( UDDI.Utility.XmlEncode( e.Message ) );							
									soapFault.WriteEndElement();
								soapFault.WriteEndElement();
							soapFault.WriteEndElement();
						soapFault.WriteEndElement();
					soapFault.WriteEndElement();
				soapFault.WriteEndElement();
			soapFault.WriteEndElement();
			soapFault.WriteEndDocument();
			
			soapFault.Flush();

			HttpContext.Current.Response.Flush();
			HttpContext.Current.Response.Close();
			HttpContext.Current.Response.End();				
		}

		public static void Throw( Exception e )
		{
			Debug.Enter();

			//
			// If this is a UDDI exception get the error number
			// Otherwise map all other errors to E_fatalError
			//
			ErrorType et = ErrorType.E_fatalError;
			string debugMessage = "";

			if( e is UDDI.UDDIException )
			{
				et = (ErrorType)( (UDDIException)e ).Number;
			}
			else if( e is System.Data.SqlClient.SqlException )
			{
				//
				// SECURITY: SqlException's include stored procedure names
				// This information is flowing back to the client in the SOAPFault
				// information. This information should be logged and not returned.
				// 
				System.Data.SqlClient.SqlException se = (System.Data.SqlClient.SqlException)e;

				//
				// Build a detailed message about the exception; this text is not sent back to the user.
				//
				debugMessage =	"SQL Exception in " + se.Procedure + 
					" line " + se.LineNumber + 
					" [severity " + se.Class +
					", state " + se.State;

				debugMessage += ", server " + se.Server;				
				debugMessage += "]";		

				//
				// Is this one of our custom error messages?  If so, we'll masssage the
				// error code into one of the UDDIException error types (custom errors
				// are thrown as ErrorType + 50000).  Otherwise, we'll simply use
				// E_fatalError.
				//
				if( 16 == se.Class )
					et = (ErrorType)( se.Number - 50000 );
				else
				{
					//
					// 739178 - See if this was a SQL deadlock issue.  If it was, then return an E_serverBusy error
					// instead.  The 1205 number is a retrieved from sysmessages table in the masters database of
					// SQL Server.  See the SQL Books Online for more information about 1205.
					//
					if( 1205 == se.Number )
					{
						//
						// Change the 'e' variable to a new exception; need to do this since e.Message
						// is read-only.  Keep track of the original exception so we can log it.
						//
						Exception originalException = e;
						e = new UDDIException( ErrorType.E_busy, "ERROR_BUSY" );
						et = ErrorType.E_busy;	
					 						
						Debug.Write( SeverityType.Info, CategoryType.Data, "A deadlock exception has been converted to an E_busy exception.  The original exception was:\r\n" + originalException.ToString() );
					}
					else
					{				
						et = ErrorType.E_fatalError;
					}
				}						
			}

			//
			// Log this error message.
			//
			Debug.Write( SeverityType.Info, CategoryType.Data, "An exception occurred. Details Follow:\r\n" + e.ToString() + "\r\n\r\n" + debugMessage );

			//
			// if this is a V1.0 call, map any new V2.0 error codes to
			// v1.0 error codes
			//
			if( 1 == Context.ApiVersionMajor )
			{
				switch( et )
				{
					case ErrorType.E_invalidValue:
					case ErrorType.E_valueNotAllowed:
					case ErrorType.E_invalidProjection:
					case ErrorType.E_assertionNotFound:
					case ErrorType.E_invalidCompletionStatus:
					case ErrorType.E_messageTooLarge:
					case ErrorType.E_transferAborted:
					case ErrorType.E_publisherCancelled:
					case ErrorType.E_requestDenied:
					case ErrorType.E_secretUnknown:
						et = ErrorType.E_fatalError;
						break;
				}
			}

			//
			// Construct a new instance of a disposition report
			//
			DispositionReport dr = new DispositionReport( et, e.Message );

			//
			// Serialize the disposition report to a stream and load into
			// a DOM.
			//
			XmlDocument doc = new XmlDocument();
						
			MemoryStream strm = new MemoryStream();
			
			// XmlSerializer serializer = new XmlSerializer( typeof( DispositionReport ) );
			XmlSerializer serializer = XmlSerializerManager.GetSerializer( typeof( DispositionReport ) );
			
			serializer.Serialize( strm, dr );
			strm.Position = 0;

			doc.Load( strm );
			
			//
			// Wrap the disposition report with a detail node.
			//
			XmlNode detail = doc.CreateNode(
				XmlNodeType.Element, 
				SoapException.DetailElementName.Name, 
				SoapException.DetailElementName.Namespace );
			
			detail.AppendChild( doc.FirstChild.NextSibling );

			//
			// Construct the SOAP exception using the dr XML
			// as details and the received Exception as the inner exception.
			//

			UDDIText uddiText = new UDDIText( "ERROR_FATAL_ERROR" );
			throw new UDDISoapException( uddiText.GetText(), 
					SoapException.ClientFaultCode,
					"", 
					detail,
					e);			
		}
	}

	/// <summary>
	///		Soap Exception Wrapper to help prevent StackTrace dumps in the XML output sent from the server.
	///		
	///		NOTE:  ASP.NET will call Exception.ToString() to get the stack trace, so in Release/Free builds,
	///				we only return an empty string, other wise we return the entire dump.
	/// </summary>
	public class UDDISoapException : SoapException
	{
		public UDDISoapException( string message, XmlQualifiedName name, string actor, XmlNode detail, Exception e ) : base( message, name, actor, detail, e )
		{}
		public override string ToString()
		{
			
#if DEBUG
				return base.ToString();			
#else
				return ""; 
#endif
			
		}
		
	}

	[XmlRootAttribute("registeredInfo", Namespace=UDDI.API.Constants.Namespace)]
	public class RegisteredInfo
	{
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;
		
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );
		
		[XmlAttribute("truncated")]
		public string Truncated;

		[ XmlArray( "businessInfos" ), XmlArrayItem( "businessInfo" ) ]
		public BusinessInfoCollection BusinessInfos = new BusinessInfoCollection();
		
		[ XmlArray( "tModelInfos" ), XmlArrayItem( "tModelInfo" ) ]
		public TModelInfoCollection TModelInfos = new TModelInfoCollection();

		public void Get()
		{
			BusinessInfos.GetForCurrentPublisher();
			TModelInfos.GetForCurrentPublisher();
		}
	}

	[XmlRootAttribute("validate_categorization", Namespace=UDDI.API.Constants.Namespace)]
	public class ValidateCategorization : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		[XmlElement("tModelKey")]
		public string TModelKey = "";

		[XmlElement("keyValue")]
		public string KeyValue = "";

		[XmlElement("businessEntity")]
		public BusinessEntity BusinessEntity = new BusinessEntity();

		[XmlElement("businessService")]
		public BusinessService BusinessService = new BusinessService();

		[XmlElement("tModel")]
		public TModel TModel = new TModel();

		internal void Validate()
		{
			SqlCommand cmd = new SqlCommand( "net_categoryBag_validate", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;
			
			cmd.Parameters.Add( new SqlParameter( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
		
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
			
			paramacc.SetString( "@keyValue", KeyValue );
			paramacc.SetGuidFromKey( "@tModelKey", TModelKey );

			cmd.ExecuteNonQuery();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\inquire.cs ===
using System;
using System.IO;
using System.Web;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Web.Services;
using System.Xml.Serialization;
using System.Web.Services.Protocols;
using UDDI.API;
using UDDI;
using UDDI.Diagnostics;
using UDDI.API.Authentication;
using UDDI.API.Binding;
using UDDI.API.Service;
using UDDI.API.Business;
using UDDI.API.ServiceType;

namespace UDDI.API
{
	/// ****************************************************************
	///   class InquireMessages
	///	----------------------------------------------------------------
	///	  <summary>
	///		This is the web service class that contains the UDDI inquire
	///		methods.
	///	  </summary>
	/// ****************************************************************
	/// 
	[SoapDocumentService( ParameterStyle=SoapParameterStyle.Bare, RoutingStyle=SoapServiceRoutingStyle.RequestElement )]
	[WebService( Namespace=UDDI.API.Constants.Namespace )]
	public class InquireMessages
	{
		/// ****************************************************************
		///   public FindBinding
		///	----------------------------------------------------------------
		///	  <summary>
		///			Locates qualified bindingTemplates based on the criteria
		///			specified in the message content.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="fbind">
		///		A properly formed instance of the find_binding message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a list of bindingTemplates contained in a BindingDetail element.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="find_binding")]
		[UDDIExtension(messageType="find_binding")]
		public BindingDetail FindBinding( FindBinding fbind )
		{
			Debug.Enter();
			BindingDetail bd = null;

			try
			{
				bd = fbind.Find();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return bd;
		}

		/// ****************************************************************
		///   public FindBusiness
		///	----------------------------------------------------------------
		///	  <summary>
		///			Locates qualified businessEntities based on the criteria
		///			specified in the message content.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="fbind">
		///		A properly formed instance of the find_business message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a list of businessInfo structures contained in a BusinessList.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="find_business")]
		[UDDIExtension(messageType="find_business")]
		//public BusinessList FindBusiness( FindBusiness fbus, [XmlAnyElement] XmlElement[] trash )
		public BusinessList FindBusiness( FindBusiness fbus )
		{
			Debug.Enter();
			BusinessList bl = null;

			try
			{
				bl = fbus.Find();

				//
				// If this request came from a v1 message, filter out any service projections in our list of 
				// businesses
				//
				if( 1 == Context.ApiVersionMajor )
				{					
					foreach( BusinessInfo businessInfo in bl.BusinessInfos )
					{			
						businessInfo.ServiceInfos = FilterServiceProjections( businessInfo.ServiceInfos, businessInfo.BusinessKey );						
					}
				}
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return bl;
		}		

		/// ****************************************************************
		///   public FindRelatedBusinesses
		///	----------------------------------------------------------------
		///	  <summary>
		///			Locates qualified businessEntities based on the criteria
		///			specified in the message content.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="fbind">
		///		A properly formed instance of the find_business message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a list of businessInfo structures contained in a BusinessList.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="find_relatedBusinesses")]
		[UDDIExtension(messageType="find_relatedBusinesses")]
		public RelatedBusinessList FindRelatedBusinesses( FindRelatedBusinesses frelbus )
		{
			Debug.Enter();
			RelatedBusinessList rbl = null;

			try
			{
				rbl = frelbus.Find();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}
			
			return rbl;
		}


		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="find_service")]
		[UDDIExtension(messageType="find_service")]
		public ServiceList FindService( FindService fs )
		{
			Debug.Enter();
			ServiceList sl = null;
		
			try
			{				
				sl = fs.Find();

				//
				// Maybe we could filter service projections out earlier, but this seems to be the
				// most readable place to do it.
				//
				if( 1 == Context.ApiVersionMajor )
				{						
					sl.ServiceInfos = FilterServiceProjections( sl.ServiceInfos, fs.BusinessKey );						
				}
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return sl;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="find_tModel")]
		[UDDIExtension(messageType="find_tModel")]
		public TModelList FindTModel( UDDI.API.ServiceType.FindTModel ftm )
		{
			Debug.Enter();
			TModelList tml = null;

			try
			{
				tml = ftm.Find();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			Debug.Leave();
			return tml;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="get_bindingDetail")]
		[UDDIExtension(messageType="get_bindingDetail")]
		public BindingDetail GetBindingDetail( GetBindingDetail gbd )
		{
			Debug.Enter();
			BindingDetail bd = new BindingDetail();

			try
			{
				bd.Get( gbd.BindingKeys );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return bd;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="get_businessDetail")]
		[UDDIExtension(messageType="get_businessDetail")]
		public BusinessDetail GetBusinessDetail( GetBusinessDetail gbd )
		{
			Debug.Enter();

			BusinessDetail bd = new BusinessDetail();

			try
			{
				bd.Get( gbd.BusinessKeys );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return bd;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="get_businessDetailExt")]
		[UDDIExtension(messageType="get_businessDetailExt")]
		public BusinessDetailExt GetBusinessDetailExt( GetBusinessDetailExt gbde )
		{
			Debug.Enter();
			BusinessDetailExt bde = new BusinessDetailExt();
			try
			{
				bde.Get( gbde.BusinessKeys );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return bde;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="get_serviceDetail")]
		[UDDIExtension(messageType="get_serviceDetail")]
		public ServiceDetail GetServiceDetail( GetServiceDetail gsd )
		{
			Debug.Enter();
			ServiceDetail sd = new ServiceDetail();

			try
			{
				sd.Get( gsd.ServiceKeys );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return sd;
		}
		
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="get_tModelDetail")]
		[UDDIExtension(messageType="get_tModelDetail")]
		public TModelDetail GetTModelDetail( GetTModelDetail gtmd )
		{
			Debug.Enter();
			TModelDetail tmd = new TModelDetail();

			try
			{
				tmd.Get( gtmd.TModelKeys );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return tmd;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="validate_categorization")]
		[UDDIExtension(messageType="validate_categorization")]
		public DispositionReport ValidateCategorization( ValidateCategorization vc )
		{
			Debug.Enter();

			try
			{
				vc.Validate();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return new DispositionReport();
		}
		
		private ServiceInfoCollection FilterServiceProjections( ServiceInfoCollection serviceInfos, string businessKey )
		{	
			//
			// If we are given an empty businessKey, just return the original collection.  Without a businessKey, there is
			// no way to determine if these services are service projections or not.
			//
			if( null == businessKey || 0 == businessKey.Length )
			{
				return serviceInfos;
			}

			//
			// Make a copy because manipulating the collection as you iterate over it is not a good idea.  Accessing
			// a collection by index and removing items is probably very slow.  Since we don't know how this collection
			// is implemented, making a copy and populating it is probably the safest thing to do from a performance standpoint.
			// 
			ServiceInfoCollection filteredCollection = new ServiceInfoCollection();
			foreach( ServiceInfo serviceInfo in serviceInfos )
			{	
				//
				// If these business keys are equal, it is not a service projection, so
				// add it to our filtered list, otherwise, don't add it.
				// 
				if( true == serviceInfo.BusinessKey.Equals( businessKey ) )
				{
					filteredCollection.Add( serviceInfo );					
				}	
			}			

			return filteredCollection;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\name.cs ===
using System;
using System.Data;
using System.Collections;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API
{
	public class Name
	{
		//
		// Attribute: xml:lang
		//
		private string isoLangCode;

		[XmlAttribute( "xml:lang" )]
		public string IsoLangCode
		{
			get { return isoLangCode; }
			set { isoLangCode = value; }
		}

		//
		// Element: Value
		//
		[XmlText]
		public string Value;

		public Name()
		{
		}

		//
		// 741019 - use the UDDI site language if one is not specified.
		//
		public Name( string name ) : this( Config.GetString( "Setup.WebServer.ProductLanguage", "en" ), name )
		{
		}

		public Name( string isoLangCode, string name )
		{			
			this.IsoLangCode = isoLangCode;
			this.Value = name;
		}

		public void Save( string parentKey, EntityType parentType )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			switch( parentType )
			{
				case EntityType.BusinessEntity:
					sp.ProcedureName = "net_businessEntity_name_save";
			
					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@businessKey", parentKey );

					break;

				case EntityType.BusinessService:
					sp.ProcedureName = "net_businessService_name_save";
			
					sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@serviceKey", parentKey );

					break;

				default:
					//throw new UDDIException( ErrorType.E_fatalError, "Unexpected parent entity type '" + parentType.ToString() + "'" );
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_UNEXPECTED_PARENT_ENTITY_TYPE", parentType.ToString() );
			}

			sp.Parameters.Add( "@isoLangCode", SqlDbType.VarChar, UDDI.Constants.Lengths.IsoLangCode );
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );

			sp.Parameters.SetString( "@isoLangCode", ( 1 == Context.ApiVersionMajor ? Context.User.IsoLangCode : IsoLangCode ) );
			sp.Parameters.SetString( "@name", Value );
			
			sp.ExecuteNonQuery();

			Debug.Leave();
		}
	}

	/// ********************************************************************
	///   class NameCollection
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class NameCollection : CollectionBase
	{
		public NameCollection()
		{
		}

		public void Get( string parentKey, EntityType parentType )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
			
			switch( parentType )
			{
				case EntityType.BusinessEntity:
					sp.ProcedureName = "net_businessEntity_names_get";

					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@businessKey", parentKey );

					break;

				case EntityType.BusinessService:
					sp.ProcedureName = "net_businessService_names_get";

					sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@serviceKey", parentKey );

					break;

				default:
					// throw new UDDIException( ErrorType.E_fatalError, "Unexpected parent entity type '" + parentType.ToString() + "'" );
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_UNEXPECTED_PARENT_ENTITY_TYPE", parentType.ToString() );
			}
			
			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				Read( reader );
			}
			finally
			{
				reader.Close();
			}
		}

		public void Read( SqlDataReaderAccessor reader )
		{
			if( 1 == Context.ApiVersionMajor )
			{
				if( reader.Read() )
					Add( null, reader.GetString( "name" ) );
			}
			else
			{
				while( reader.Read() )
					Add( reader.GetString( "isoLangCode" ), reader.GetString( "name" ) );
			}
		}

		internal void ValidateForFind()
		{
            //
            // For v1 messages, we need to throw an exception.  But for v2, errata 3
            // says that we need to just truncate.
            //
            if( 1 == Context.ApiVersionMajor )
            {
                foreach( Name name in this )
                {
					if( null != name.Value && name.Value.Trim().Length > UDDI.Constants.Lengths.Name )
					{
						//	throw new UDDIException( ErrorType.E_nameTooLong, "A name specified in the search exceed the allowable length" );
						throw new UDDIException( ErrorType.E_nameTooLong, "UDDI_ERROR_NAME_TOO_LONG" );
					}
                }
            }
            else
            {
                foreach( Name name in this )
                    Utility.ValidateLength( ref name.Value, "name", UDDI.Constants.Lengths.Name );
            }
		}

		internal void Validate()
		{			
			int minLength = 1;
			int maxLength = UDDI.Constants.Lengths.Name;
			int count = this.Count;

			//
			// We have to make sure we have a names since the schema has made <name> optional to accomodate
			// service projections.
			//
			if( 0 == count )
			{
				//throw new UDDIException( ErrorType.E_fatalError, "Name is a required element." );
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_NAME_IS_A_REQUIRED_ELEMENT" );
			}

			if( 1 == Context.ApiVersionMajor )
			{
				//
				// Validate the name string length.
				//
				Utility.ValidateLength( ref this[ 0 ].Value, "name", maxLength, minLength );
				return;
			}

			for( int i = 0; i < count; i ++ )
			{								
				//
				// The language code should be lower-case characters.
				//
				string isoLangCode = this[ i ].IsoLangCode;

				if( null != isoLangCode )
					this[ i ].IsoLangCode = isoLangCode.ToLower();
			}
			
			bool languageAssigned = false;

			for( int i = 0; i < count; i ++ )
			{
				//
				// Validate the name string length.
				//
				Utility.ValidateLength( ref this[ i ].Value, "name", maxLength, minLength );
				
				//
				// Validate the language code.  If one was not specified,
				// we'll use the publisher's default language.
				//
				if( Utility.StringEmpty( this[ i ].IsoLangCode ) )
				{
					//
					// Only one name can have an unassigned language.
					//
					if( languageAssigned )
					{
				//		throw new UDDIException( 
				//			ErrorType.E_languageError, 
							//"More than one name was found to have an unassigned language" );
						throw new UDDIException( ErrorType.E_languageError, "UDDI_ERROR_MORE_THAN_ONE_NAME_UNASSIGNED" );						
					}

					languageAssigned = true;

					//
					// Fix: Bug 2340 9/9/2002, creeves
					//

					// if( i > 0 )
					// {
					//	throw new UDDIException( 
					// 		ErrorType.E_languageError, 
					//		"Only the first name can have a blank or missing xml:lang attribute.  All other names must have a valid xml:lang attribute." );
					// }

					this[ i ].IsoLangCode = Context.User.IsoLangCode;
				}
			}
				
			// Split loops and fill in default IsoLangCode first (if needed), 
			// then look for repeated languages
			//
			for( int i = 0; i < count; i ++ )
			{
				//
				// Check to make sure there is only one name
				// per language.
				//
				string isoLangCode = this[ i ].IsoLangCode;

				Debug.Write( SeverityType.Info, CategoryType.Data, "Name[" + i + "]: " + this[ i ].Value + ", IsoLangCode: " + isoLangCode );

				for( int j = i + 1; j < count; j ++ )
				{
					if( false == Utility.StringEmpty(this[ j ].IsoLangCode)
						&& isoLangCode.ToLower() == this[ j ].IsoLangCode.ToLower() )
					{
						Debug.Write( SeverityType.Info, CategoryType.Data, "Error: Name[" + j + "]: " + this[ j ].Value + ", IsoLangCode " + this[ j ].IsoLangCode + " matches IsoLangCode[" + i + "]: " + isoLangCode );

						//throw new UDDIException( 
							//ErrorType.E_languageError, 
							//"More than one name found for language '" + isoLangCode + "'" );

						throw new UDDIException( ErrorType.E_languageError, "UDDI_ERROR_MORE_THAN_ONE_NAME_FOR_LANGUAGE", isoLangCode );							
					}
				}
			}
		}
		
		public void Save( string parentKey, EntityType parentType )
		{
			Debug.Enter();

			foreach( Name name in this )
				name.Save( parentKey, parentType );

			Debug.Leave();
		}

		public Name this[ int index ]
		{
			get { return (Name)List[ index ]; }
			set { List[ index ] = value; }
		}

		public int Add( Name name )
		{
			return List.Add( name );
		}

		public int Add( string name )
		{
			return List.Add( new Name( name ) );
		}

		public int Add( string isoLangCode, string name )
		{
			return List.Add( new Name( isoLangCode, name ) );
		}

		public void Insert( int index, Name name )
		{
			List.Insert( index, name );
		}
		
		public int IndexOf( Name name )
		{
			return List.IndexOf( name );
		}
		
		public bool Contains( Name name )
		{
			return List.Contains( name );
		}
		
		public void Remove( Name name )
		{
			List.Remove( name );
		}
		
		public void CopyTo( Name[] names, int index )
		{
			List.CopyTo( names, index );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\find.cs ===
/// ************************************************************************
///   Microsoft UDDI version 2.0
///   Copyright (c) 2000-2001 Microsoft Corporation
///   All Rights Reserved
/// ------------------------------------------------------------------------
///   <summary>
///   </summary>
/// ************************************************************************
/// 

using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using UDDI;
using UDDI.Diagnostics;
using UDDI.API.Business;

namespace UDDI.API
{
	/// ********************************************************************
	///   public class FindBuilder  
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************  
	/// 
	public class FindBuilder
	{
		//
		// Find entity type
		//
		private EntityType entityType;
		private string entityName = null;
		private string parentKey = null;
		
		//
		// Find qualifiers
		//
		public bool ExactNameMatch = false;
		public bool CaseSensitiveMatch = false;
		public bool SortByNameAsc = false;
		public bool SortByNameDesc = false;
		public bool SortByDateAsc = false;
		public bool SortByDateDesc = false;
		public bool OrLikeKeys = false;
		public bool OrAllKeys = false;
		public bool CombineCategoryBags = false;
		public bool ServiceSubset = false;
		public bool AndAllKeys = false;
		public bool Soundex = false;

		/// ****************************************************************
		///   public FindBuilder [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="entityType">
		///     The type of entity to search for.
		///   </param>
		///   
		///   <param name="findQualifiers">
		///   </param>
		///   
		///   <param name="parentKey">
		///   </param>
		/// ****************************************************************
		/// 
		public FindBuilder( EntityType entityType, FindQualifierCollection findQualifiers, string parentKey )
			: this( entityType, findQualifiers )
		{
			this.parentKey = parentKey;
		}

		/// ****************************************************************
		///   public FindBuilder [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="entityType">
		///     The type of entity to search for.
		///   </param>
		///   
		///   <param name="findQualifiers">
		///   </param>
		/// ****************************************************************
		/// 
		public FindBuilder( EntityType entityType, FindQualifierCollection findQualifiers )
		{
			this.entityType = entityType;
			this.entityName = Conversions.EntityNameFromID( entityType );
			
			//
			// Parse the find qualifiers.
			//
			if( null != findQualifiers )
			{
				foreach( FindQualifier findQualifier in findQualifiers )
				{
					//
					// Need to trim whitespace
					//
					switch( findQualifier.Value.Trim() )
					{
						case "exactNameMatch":
							if( EntityType.BusinessEntity == entityType ||
								EntityType.BusinessService == entityType ||
								EntityType.TModel == entityType )
								ExactNameMatch = true;
							break;
						
						case "caseSensitiveMatch":
							if( EntityType.BusinessEntity == entityType ||
								EntityType.BusinessService == entityType ||
								EntityType.TModel == entityType )
								CaseSensitiveMatch = true;
							break;
						
						case "sortByNameAsc":
							if( EntityType.BusinessEntity == entityType ||
								EntityType.BusinessService == entityType ||
								EntityType.TModel == entityType )
							{
								//
								// sortByNameAsc and sortByNameDesc are mutually exclusive.
								//
								Debug.Verify( !SortByNameDesc, "UDDI_ERROR_UNSUPPORTED_NAMEASCANDDESC", ErrorType.E_unsupported );
								SortByNameAsc = true;
							}
							break;
						
						case "sortByNameDesc":
							if( EntityType.BusinessEntity == entityType ||
								EntityType.BusinessService == entityType ||
								EntityType.TModel == entityType )
							{
								//
								// sortByNameAsc and sortByNameDesc are mutually exclusive.
								//
								Debug.Verify( !SortByNameAsc, "UDDI_ERROR_UNSUPPORTED_NAMEASCANDDESC", ErrorType.E_unsupported );
							
								SortByNameDesc = true;
							}
							break;
						
						case "sortByDateAsc":
							if( EntityType.BindingTemplate == entityType ||
								EntityType.BusinessEntity == entityType ||
								EntityType.BusinessService == entityType ||
								EntityType.TModel == entityType )
							{
								//
								// sortByDateAsc and sortByDateDesc are mutually exclusive.
								//
								Debug.Verify( !SortByDateDesc, "UDDI_ERROR_UNSUPPORTED_DATEASCANDDESC", ErrorType.E_unsupported );
								SortByDateAsc = true;
							}
							break;
						
						case "sortByDateDesc":
							if( EntityType.BindingTemplate == entityType ||
								EntityType.BusinessEntity == entityType ||
								EntityType.BusinessService == entityType ||
								EntityType.TModel == entityType )
							{
								//
								// sortByDateAsc and sortByDateDesc are mutually exclusive.
								//
								Debug.Verify( !SortByDateAsc, "UDDI_ERROR_UNSUPPORTED_DATEASCANDDESC", ErrorType.E_unsupported );
								SortByDateDesc = true;
							}
							break;
					
						case "orLikeKeys":
							if( EntityType.BusinessEntity == entityType ||
								EntityType.BusinessService == entityType ||
								EntityType.TModel == entityType )
							{
								//
								// orLikeKeys, orAllKeys, and andAllKeys are mutually exclusive.
								//
								Debug.Verify( !OrAllKeys && !AndAllKeys, "UDDI_ERROR_UNSUPPORTED_KEYSORAND", ErrorType.E_unsupported );
								OrLikeKeys = true;
							}
							break;
					
						case "orAllKeys":
							if( EntityType.BusinessEntity == entityType ||
								EntityType.BindingTemplate == entityType ||
								EntityType.BusinessService == entityType ||
								EntityType.TModel == entityType )
							{
								//
								// orLikeKeys, orAllKeys, and andAllKeys are mutually exclusive.
								//
								Debug.Verify( !OrLikeKeys && !AndAllKeys, "UDDI_ERROR_UNSUPPORTED_KEYSORAND", ErrorType.E_unsupported );

								OrAllKeys = true;
							}
							break;
					
						case "combineCategoryBags":
							if( EntityType.BusinessEntity == entityType )
							{
								CombineCategoryBags = true;
							}
							break;
					
						case "serviceSubset":
							if( EntityType.BusinessEntity == entityType )
							{
								ServiceSubset = true;
							}
							break;
					
						case "andAllKeys":
							if( EntityType.BusinessEntity == entityType ||
								EntityType.TModel == entityType )
							{
								//
								// orLikeKeys, orAllKeys, and andAllKeys are mutually exclusive.
								//
								Debug.Verify( !OrLikeKeys && !OrAllKeys, "UDDI_ERROR_UNSUPPORTED_KEYSORAND", ErrorType.E_unsupported );
							
								AndAllKeys = true;
							}
							break;

						default:
							throw new UDDIException( 
								ErrorType.E_unsupported,
								"UDDI_ERROR_UNSUPPORTED_FINDQUALIFIER",
								findQualifier.Value  );
					}
				}
			}
		}

		/// ****************************************************************
		///   private ScratchCommit
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <returns>
		///   </returns>
		/// ****************************************************************
		///   
		private int ScratchCommit()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_find_scratch_commit" );

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			
			sp.ExecuteNonQuery();

			return sp.Parameters.GetInt( "@rows" );
		}
		
		/// ****************************************************************
		///   public Abort
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		///   
		public void Abort()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_find_cleanup" );
			
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );			
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );

			sp.ExecuteNonQuery();
		}

		/// ****************************************************************
		///   public RetrieveResults
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="maxRows">
		///   </param>
		///   
		///   <param name="truncated">
		///   </param>
		/// ****************************************************************
		///   
		public SqlStoredProcedureAccessor RetrieveResults( int maxRows )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			if( ServiceSubset )
				sp.ProcedureName = "net_find_businessEntity_serviceSubset_commit";
			else
				sp.ProcedureName = "net_find_" + entityName + "_commit";

			if( entityName != "bindingTemplate" )
			{
				sp.Parameters.Add( "@sortByNameAsc", SqlDbType.Bit );
				sp.Parameters.Add( "@sortByNameDesc", SqlDbType.Bit );
			}
			
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@sortByDateAsc", SqlDbType.Bit );
			sp.Parameters.Add( "@sortByDateDesc", SqlDbType.Bit );
			sp.Parameters.Add( "@maxRows", SqlDbType.Int );
			sp.Parameters.Add( "@truncated", SqlDbType.Bit, ParameterDirection.Output );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			
			if( entityName != "bindingTemplate" )
			{
				sp.Parameters.SetBool( "@sortByNameAsc", SortByNameAsc );
				sp.Parameters.SetBool( "@sortByNameDesc", SortByNameDesc );
			}
			
			sp.Parameters.SetBool( "@sortByDateAsc", SortByDateAsc );
			sp.Parameters.SetBool( "@sortByDateDesc", SortByDateDesc );
			
			int defaultMaxRows = Config.GetInt( "Find.MaxRowsDefault" );
			
			if( maxRows < 0 || maxRows > defaultMaxRows )
				maxRows = defaultMaxRows;
			
			sp.Parameters.SetInt( "@maxRows", maxRows );
			
			return sp;
		}

		/// ****************************************************************
		///   public FindByName
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="name">
		///   </param>
		/// ****************************************************************
		///   
		public int FindByName( string name )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_find_" + entityName + "_name";

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );
			sp.Parameters.Add( "@exactNameMatch", SqlDbType.Bit );
			sp.Parameters.Add( "@caseSensitiveMatch", SqlDbType.Bit );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetBool( "@exactNameMatch", ExactNameMatch );
			sp.Parameters.SetBool( "@caseSensitiveMatch", CaseSensitiveMatch );
			sp.Parameters.SetString( "@name", LikeEncode( name ) );
			
			sp.ExecuteNonQuery();

			return ScratchCommit();
		}

		/// ****************************************************************
		///   public FindByNames
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="names">
		///   </param>
		/// ****************************************************************
		///   
		public int FindByNames( NameCollection names )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_find_" + entityName + "_name";

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );
			sp.Parameters.Add( "@isoLangCode", SqlDbType.VarChar, UDDI.Constants.Lengths.IsoLangCode );
			sp.Parameters.Add( "@exactNameMatch", SqlDbType.Bit );
			sp.Parameters.Add( "@caseSensitiveMatch", SqlDbType.Bit );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetBool( "@exactNameMatch", ExactNameMatch );
			sp.Parameters.SetBool( "@caseSensitiveMatch", CaseSensitiveMatch );

			foreach( Name name in names )
			{
				sp.Parameters.SetString( "@name", LikeEncode( name.Value ) );
				
				if( Utility.StringEmpty( name.IsoLangCode ) )
					sp.Parameters.SetString( "@isoLangCode", "%" );
				else
					sp.Parameters.SetString( "@isoLangCode", name.IsoLangCode );
				
				sp.ExecuteNonQuery();
			}			

			return ScratchCommit();
		}

		/// ****************************************************************
		///   public FindByDiscoveryUrls
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="discoveryUrls">
		///   </param>
		/// ****************************************************************
		///   
		public int FindByDiscoveryUrls( DiscoveryUrlCollection discoveryUrls )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_find_" + entityName + "_discoveryURL";

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@useType", SqlDbType.NVarChar, UDDI.Constants.Lengths.UseType );
			sp.Parameters.Add( "@discoveryURL", SqlDbType.NVarChar, UDDI.Constants.Lengths.DiscoveryURL );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			
			int rows = 0;

			foreach( DiscoveryUrl discoveryUrl in discoveryUrls )
			{
				sp.Parameters.SetString( "@useType", discoveryUrl.UseType );
				sp.Parameters.SetString( "@discoveryURL", discoveryUrl.Value );
				
				sp.ExecuteNonQuery();

				rows = sp.Parameters.GetInt( "@rows" );
			}

			return ScratchCommit();
		}

		/// ****************************************************************
		///   public FindByTModelBag
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="tModelBag">
		///   </param>
		/// ****************************************************************
		///   
		public int FindByTModelBag( StringCollection tModelBag )
		{
			//
			// First validate all the keys, this will make sure any invalid keys are 'caught' beforehand.
			//
			foreach( string tModelKey in tModelBag )
			{
				Utility.IsValidKey( EntityType.TModel, tModelKey );
			}

			//
			// Set up the stored procedure call and set common parameters.
			//
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_find_" + entityName + "_tModelBag";
			
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@orKeys", SqlDbType.Bit );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetBool( "@orKeys", OrAllKeys );

			//
			// Process each tModelKey.
			//
			foreach( string tModelKey in tModelBag )
			{
				sp.Parameters.SetGuidFromKey( "@tModelKey", tModelKey );
				sp.ExecuteNonQuery();

				//
				// No point continuing if a query returns no results in AND operation.
				//
				if( false == this.OrAllKeys && 
					0 == sp.Parameters.GetInt( "@rows" ) )
				{
					break;
				}
			}
			
			return ScratchCommit();
		}

		/// ****************************************************************
		///   public FindByKeyedReferences
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="keyedReferenceType">
		///   </param>
		///   
		///   <param name="keyedReferences">
		///   </param>
		/// ****************************************************************
		///   
		public int FindByKeyedReferences( KeyedReferenceType keyedReferenceType, KeyedReferenceCollection keyedReferences )
		{
			int rows = 0;

			//
			// Fix for Windows Bug #728622
			// OrAllKeys findQualifier was being modified for the scope of the entire find.  
			// This fix preserves the initial value of OrAllKeys so as not to affect subsequent method invocations in the same find.
			// All subsequent references to OrAllKeys are replaced by OrAllKeysTemp in this method.
			//

			bool OrAllKeysTemp = OrAllKeys;
			
			//
			// Set up the stored procedure call and set common parameters.
			//
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			switch( keyedReferenceType )
			{
				case KeyedReferenceType.CategoryBag:
					if( CombineCategoryBags )
                        sp.ProcedureName = "net_find_" + entityName + "_combineCategoryBags";
					else if( ServiceSubset )
                        sp.ProcedureName = "net_find_" + entityName + "_serviceSubset";
					else
						sp.ProcedureName = "net_find_" + entityName + "_categoryBag";

					break;

				case KeyedReferenceType.IdentifierBag:
					if (AndAllKeys == false)
					{
						//
						// Fix for Windows Bug #728622
						//

//						OrAllKeys = true; // if OrLikeKeys has been specified, that will be overriden below
						OrAllKeysTemp = true;
					}

					sp.ProcedureName = "net_find_" + entityName + "_identifierBag";
					break;

				default:
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_UNEXPECTEDKRTYPE",keyedReferenceType.ToString() );
			}

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@keyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyName );
			sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@orKeys", SqlDbType.Bit );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );
			
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );

			//
			// Determine whether we should be doing an 'orLikeKeys' search.
			//
			if( OrLikeKeys )
			{
				//
				// First group keyed references by tModelKey (basically 
				// grouping by taxonomy).  This will allow us to easily
				// process keyed references with the same taxonomy.  In
				// an orLikeKeys search, we will match on any of the
				// keys for a given taxonomy (a logical OR operation).
				//
				ArrayList sortedList = new ArrayList();

				foreach( KeyedReference keyedReference in keyedReferences )
					sortedList.Add( keyedReference );
				
				sortedList.Sort( new TModelKeyComparer() );
				
				//
				// In an orLikeKeys search, we or all keys in the scratch
				// table.
				//
				sp.Parameters.SetBool( "@orKeys", true );
				
				//
				// Process each group of keyed references.  Each time
				// we cross a group boundary (seen when the current
				// tModelKey is different than the last one we processed),
				// commit the data in the scratch table to the main results
				// table (a logical AND operation with the result of other 
				// search constraints).
				//
				string prevKey = ((KeyedReference)sortedList[0]).TModelKey.ToLower();
				bool dirty = false;

				foreach( KeyedReference keyedReference in sortedList )
				{
					Utility.IsValidKey( EntityType.TModel, keyedReference.TModelKey );

					if( prevKey != keyedReference.TModelKey.ToLower() )
					{
						//
						// Logical AND scratch table results with main table.
						//
						rows = ScratchCommit();
						dirty = false;

						//
						// If the main results list is now empty, we don't
						// need to process any more constraints.
						//
						if( 0 == rows )
							return rows;
					}

					sp.Parameters.SetString( "@keyName", keyedReference.KeyName );
					sp.Parameters.SetString( "@keyValue", keyedReference.KeyValue );
					sp.Parameters.SetGuidFromKey( "@tModelKey", keyedReference.TModelKey );

					sp.ExecuteNonQuery();
	 
					dirty = true;
					prevKey = keyedReference.TModelKey.ToLower();
				}

				//
				// If the scratch table contains results that haven't been
				// processed, logical AND them with the main table.
				//
				if( dirty )
					rows = ScratchCommit();
			}
			else
			{
				//
				// Determine whether we should be performing a logical OR or 
				// AND on results from each keyed reference.
				//
				//

				//
				// Fix for Windows Bug #728622
				//

//				sp.Parameters.SetBool( "@orKeys", OrAllKeys );
				sp.Parameters.SetBool( "@orKeys", OrAllKeysTemp );

				//
				// Process each keyed reference.
				//
				foreach( KeyedReference keyedReference in keyedReferences )
				{
					sp.Parameters.SetString( "@keyName", keyedReference.KeyName );
					sp.Parameters.SetString( "@keyValue", keyedReference.KeyValue );
					sp.Parameters.SetGuidFromKey( "@tModelKey", keyedReference.TModelKey );

					sp.ExecuteNonQuery();
					int sprows = sp.Parameters.GetInt( "@rows" );

					//
					// No point continuing if a query returns no results in AND operation.
					//

					//
					// Fix for Windows Bug #728622
					//

//					if( false == this.OrAllKeys && 0 == sprows )
					if( false == OrAllKeysTemp && 0 == sprows )
					{
						break;
					}
				}

				//
				// Logical AND scratch table results with main table.
				//
				rows = ScratchCommit();
			}

			return rows;
		}

		public int FindByParentKey( string parentKey )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();
			
			switch( entityType )
			{
				case EntityType.BusinessService:
					sp.ProcedureName = "net_find_businessService_businessKey";

					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@businessKey", parentKey );
					
					break;

				case EntityType.BindingTemplate:
					sp.ProcedureName = "net_find_bindingTemplate_serviceKey";
                    
					sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@serviceKey", parentKey );
					break;

				default:
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FATALERROR_UNEXPECTEDENTITYTYPE", entityType.ToString() );
			}

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			
			sp.ExecuteNonQuery();

			return sp.Parameters.GetInt( "@rows" );
		}

		public SqlStoredProcedureAccessor FindRelatedBusinesses( string businessKey, KeyedReference keyedReference, int maxRows)
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_find_businessEntity_relatedBusinesses" );

			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@keyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyName );
			sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@sortByNameAsc", SqlDbType.Bit );
			sp.Parameters.Add( "@sortByNameDesc", SqlDbType.Bit );
			sp.Parameters.Add( "@sortByDateAsc", SqlDbType.Bit );
			sp.Parameters.Add( "@sortByDateDesc", SqlDbType.Bit );
			sp.Parameters.Add( "@maxRows", SqlDbType.Int );
			sp.Parameters.Add( "@truncated", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@rows", SqlDbType.Int, ParameterDirection.Output );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetGuidFromString( "@businessKey", businessKey );
			
			if( null != keyedReference )
			{
				sp.Parameters.SetString( "@keyName", keyedReference.KeyName );
				sp.Parameters.SetString( "@keyValue", keyedReference.KeyValue );
				sp.Parameters.SetGuidFromKey( "@tModelKey", keyedReference.TModelKey );
			}
			else
			{
				sp.Parameters.SetNull( "@keyName" );
				sp.Parameters.SetNull( "@keyValue" );
				sp.Parameters.SetNull( "@tModelKey" );
			}

			sp.Parameters.SetBool( "@sortByNameAsc", SortByNameAsc );
			sp.Parameters.SetBool( "@sortByNameDesc", SortByNameDesc );
			sp.Parameters.SetBool( "@sortByDateAsc", SortByDateAsc );
			sp.Parameters.SetBool( "@sortByDateDesc", SortByDateDesc );
			sp.Parameters.SetInt( "@maxRows", maxRows );
			
			return sp;
		}

		private class TModelKeyComparer : IComparer
		{
			public int Compare( object keyedReference1, object keyedReference2 )
			{
				return String.Compare( 
					((KeyedReference)keyedReference1).TModelKey.ToLower(),
					((KeyedReference)keyedReference2).TModelKey.ToLower() );
			}
		}

        private string LikeEncode( string str )
        {
            if( null == str )
                return null;

            StringBuilder builder = new StringBuilder( str.Length );

            foreach( char ch in str )
            {
                switch( ch )
                {
                    case '[':
                        builder.Append( "[ [ ]" );
                        break;

                    case ']':
                        builder.Append( "[ ] ]" );
                        break;

                    case '%':
                        //
                        // We'll always treat the % as a wildcard, so don't
                        // escape in the client string.
                        //
                        builder.Append( ch );
                        break;

                    case '_':
                        builder.Append( "[_]" );
                        break;

                    default:
                        builder.Append( ch );
                        break;
                }
            }
            
            return builder.ToString();
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\keyedreference.cs ===
using System;
using System.Data;
using System.Collections;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API
{
	public class KeyedReference
	{
		[XmlAttribute("tModelKey")]
		public string TModelKey
		{
			get
			{
				return tmodelkey;
			}
			set
			{
				if( null == value )
					tmodelkey = null;
				else
					tmodelkey = value.Trim().ToLower();
			}
		}
		string tmodelkey;

		[XmlAttribute("keyName")]
		public string KeyName
		{
			get
			{
				return keyname;
			}
			set
			{
				if( null == value )
					keyname = null;
				else
					keyname = value.Trim();
			}
		}
		string keyname;

		[XmlAttribute("keyValue")]
		public string KeyValue
		{
			get
			{
				return keyvalue;
			}
			set
			{
				if( null == value )
					keyvalue = null;
				else
					keyvalue = value.Trim();
			}
		}
		string keyvalue;

		public KeyedReference()
		{
		}

		public KeyedReference( string name, string value )
		{
			KeyName = name;
			KeyValue = value;
		}

		public KeyedReference( string name, string value, string key )
		{
			KeyName = name;
			KeyValue = value;
			TModelKey = key;
		}

		public void ValidateLength()
		{
		}

		private void ValidateOwningBusiness( EntityType parentType, KeyedReferenceType keyedReferenceType )
		{
			//
			// IN87: 3. If a keyedReference contains the uddi-org:owningBusiness tModelKey, then
			// the following conditions must be met:
			//	1. The keyedReference's tModelKey is case insensitive equal to uuid:4064C064-6D14-4F35-8953-9652106476A9
			//	2. The keyedReference's keyValue contains a valid UUID
			//	3. The keyedReference is contained within a categoryBag or identifierBag
			//	4. The containing categoryBag or identifierBag is a child element of a tModel
			//	5. The UUID (from condition 2) refers to an existing businessEntity
			//	6. The businessEntity is owned (and published by) the same publisher that is publishing the tModel from (condition 4).
			//

			//
			//	1. The keyedReference's tModelKey is case insensitive equal to uuid:4064C064-6D14-4F35-8953-9652106476A9
			//
			if( Context.ContextType != ContextType.Replication && 
				TModelKey.ToLower().Equals( UDDI.Constants.OwningBusinessTModelKey ) )
			{						
				//
				//	3. The keyedReference is contained within a categoryBag or identifierBag
				//
				if( keyedReferenceType != KeyedReferenceType.CategoryBag && 
					keyedReferenceType != KeyedReferenceType.IdentifierBag )
				{
					//
					// Error
					//
					throw new UDDIException(
						ErrorType.E_fatalError,
						"UDDI_ERROR_FATALERROR_KROWNINGBE" );
				}

				//
				//	4. The containing categoryBag or identifierBag is a child element of a tModel
				//
				if( EntityType.TModel != parentType )
				{
					//
					// Error
					//
					throw new UDDIException(
						ErrorType.E_fatalError,
						"UDDI_ERROR_FATALERROR_KROWNINGBETMODELCHILD" );
				}

				//
				//	2. The keyedReference's keyValue contains a valid UUID
				//	5. The UUID (from condition 2) refers to an existing businessEntity
				//	6. The businessEntity is owned (and published by) the same publisher that is publishing the tModel from (condition 4).
				//
				try
				{
					SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_validate" );	
					sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.Add( "@flag", SqlDbType.Int );
				
					sp.Parameters.SetString( "@PUID", Context.User.ID );
					sp.Parameters.SetGuidFromString( "@businessKey", KeyValue );
					sp.Parameters.SetInt( "@flag", 0 );

					sp.ExecuteNonQuery();
				}
				catch
				{
					//
					// Error
					//
					throw new UDDIException(
						ErrorType.E_fatalError,
						"UDDI_ERROR_FATALERROR_INVALIDEVALUEORPUBLISHER" );
				}			
			}
		}

		internal void Validate( string parentKey, KeyedReferenceType keyedReferenceType )
		{
			Debug.Enter();

			//
			// IN69: 4. When a keyedReference is saved within a categoryBag without specifying 
			// a tModelKey (that is no tModelKey attribute at all) the UDDI server MUST 
			// assume the urn:uddi-org:general_keywords tModelKey.  The resulting response
			// MUST add to the keyedReference the attribute 
			// tModelKey=uuid:A035A07C-F362-44dd-8F95-E2B134BF43B4 (case does not matter).
			//
			if( KeyedReferenceType.CategoryBag == keyedReferenceType && Utility.StringEmpty( TModelKey ) )
			{
				TModelKey = Config.GetString( "TModelKey.GeneralKeywords" );
			}

			//
			// IN69: 3. A UDDI server MUST reject a save_xxx request with a keyedReferences 
			// in an identifierBag where no tModelKey attribute is specified.
			//
			if( KeyedReferenceType.IdentifierBag == keyedReferenceType && Utility.StringEmpty( TModelKey ) )
			{
				throw new UDDIException(
					ErrorType.E_fatalError,
					"UDDI_ERROR_FATALERROR_IDBAG_MISSINGTMODELKEY" );
			}

			//
			// IN69: 1. A UDDI server MUST reject a save_xxx request with a keyedReference
			// with no keyName when the urn:uddi-org:general_keywords is involved
			//
			// #1718, make sure the comparison is not case sensitive.
			//
			if( Config.GetString( "TModelKey.GeneralKeywords" ).ToLower().Equals( TModelKey ) && null == keyname )
			{
				throw new UDDIException(
					ErrorType.E_fatalError,
					"UDDI_ERROR_FATALERROR_GENERALKEYWORDS_BLANKNAME" );
			}

			//
			// IN69: 2. A UDDI server MUST reject a save_xxx request with a 
			// keyedReference where only the keyValue is specified 
			//
			if( Utility.StringEmpty( tmodelkey ) && Utility.StringEmpty( keyname ) )
			{
				throw new UDDIException(
					ErrorType.E_fatalError,
					"UDDI_ERROR_FATALERROR_ASSERTION_MISSINGTMODELKEYORNAME" );
			}			

			//
			// Validate TModelKey, KeyName, and KeyValue length.
			//
			if( KeyedReferenceType.Assertion == keyedReferenceType )
			{
				if( Utility.StringEmpty( tmodelkey ) ||
					null == keyname ||
					null == keyvalue )
				{
					throw new UDDIException(
						ErrorType.E_fatalError,
						"UDDI_ERROR_FATALERROR_ASSERTION_MISSINGKEYNAMEORVALUE" );
				}
			}

			Utility.ValidateLength( ref tmodelkey, "tModelKey", UDDI.Constants.Lengths.TModelKey );
			Utility.ValidateLength( ref keyname, "keyName", UDDI.Constants.Lengths.KeyName );
			Utility.ValidateLength( ref keyvalue, "keyValue", UDDI.Constants.Lengths.KeyValue );

			Debug.VerifyKey( tmodelkey );

			//
			// TODO: We are skipping validation of this keyedreference here if the parent entity key is
			// the same as the tModelKey for the identifer bag or category bag. Why???
			//
			// Please insert a comment to describe why this is necessary
			//
			if( parentKey != TModelKey )
			{
				//
				// call net_keyedReference_validate
				//
				SqlCommand cmd = new SqlCommand( "net_keyedReference_validate", ConnectionManager.GetConnection() );

				cmd.CommandType = CommandType.StoredProcedure;
				cmd.Transaction = ConnectionManager.GetTransaction();

				cmd.Parameters.Add( new SqlParameter( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID ) ).Direction = ParameterDirection.Input;
				cmd.Parameters.Add( new SqlParameter( "@keyedRefType", SqlDbType.TinyInt ) ).Direction = ParameterDirection.Input;
				cmd.Parameters.Add( new SqlParameter( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue ) ).Direction = ParameterDirection.Input;
				cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;

				SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );

				paramacc.SetString( "@PUID", Context.User.ID );
				paramacc.SetShort( "@keyedRefType", (short)keyedReferenceType );
				paramacc.SetString( "@keyValue", KeyValue );
				paramacc.SetGuidFromKey( "@tModelKey", TModelKey );

				cmd.ExecuteNonQuery();
			}

			Debug.Leave();
		}

		public void Save( string parentKey, EntityType parentType, KeyedReferenceType keyedReferenceType )
		{
			Debug.Enter();

			//
			// IN 87 Need to validate that keyedReferences that contain the uddi-org:owningBusinessKey.  We can't
			// do this in validate because the parentKey won't be set if the parent is a new tmodel.
			//
			ValidateOwningBusiness( parentType, keyedReferenceType );

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			switch( parentType )
			{
				case EntityType.BusinessEntity:
					if( KeyedReferenceType.CategoryBag == keyedReferenceType )
						sp.ProcedureName = "net_businessEntity_categoryBag_save";
					else
						sp.ProcedureName = "net_businessEntity_identifierBag_save";

					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@businessKey", parentKey );

					break;

				case EntityType.BusinessService:
					Debug.Assert(
						KeyedReferenceType.CategoryBag == keyedReferenceType,
						"Unexpected keyed reference type '" + keyedReferenceType.ToString()
						+ "' for parent entity type '" + parentType.ToString() + "'" );

					sp.ProcedureName = "net_businessService_categoryBag_save";

					sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@serviceKey", parentKey );

					break;

				case EntityType.TModel:
					if( KeyedReferenceType.CategoryBag == keyedReferenceType )
						sp.ProcedureName = "net_tModel_categoryBag_save";
					else
						sp.ProcedureName = "net_tModel_identifierBag_save";

					sp.Parameters.Add( "@tModelKeyParent", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromKey( "@tModelKeyParent", parentKey );

					break;

				default:
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_UNEXPECTED_PARENT_ENTITY_TYPE" , parentType.ToString()  );
			}

			sp.Parameters.Add( "@keyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyName );
			sp.Parameters.Add( "@keyValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.KeyValue );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );

			sp.Parameters.SetString( "@keyName", KeyName );
			sp.Parameters.SetString( "@keyValue", KeyValue );
			sp.Parameters.SetGuidFromKey( "@tModelKey", TModelKey );

			sp.ExecuteNonQuery();

			Debug.Leave();
		}
	}

	public class KeyedReferenceCollection : CollectionBase
	{
		public KeyedReferenceCollection()
		{
		}

		internal void Validate( string parentKey, KeyedReferenceType keyedReferenceType )
		{
			foreach( KeyedReference keyRef in this )
			{
				keyRef.Validate( parentKey, keyedReferenceType );
			}
		}

		public void Save( string parentKey, EntityType parentType, KeyedReferenceType keyedReferenceType )
		{
			foreach( KeyedReference keyRef in this )
			{
				keyRef.Save( parentKey, parentType, keyedReferenceType );
			}
		}

		public KeyedReference this[int index]
		{
			get	{ return (KeyedReference)List[index]; }
			set { List[index] = value; }
		}

		public int Add(KeyedReference value)
		{
			return List.Add(value);
		}

		public int Add( string name, string value )
		{
			return List.Add( new KeyedReference( name, value ) );
		}

		public int Add( string name, string value, string key )
		{
			return List.Add( new KeyedReference( name, value, key ) );
		}

		public int Add()
		{
			return List.Add( new KeyedReference() );
		}

		public void Insert(int index, KeyedReference value)
		{
			List.Insert(index, value);
		}

		public void Get( string parentKey, EntityType parentType, KeyedReferenceType keyedReferenceType )
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			switch( parentType )
			{
				case EntityType.BusinessEntity:
					if( KeyedReferenceType.CategoryBag == keyedReferenceType )
						sp.ProcedureName = "net_businessEntity_categoryBag_get";
					else
						sp.ProcedureName = "net_businessEntity_identifierBag_get";

					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@businessKey", parentKey );

					break;

				case EntityType.BusinessService:
					Debug.Assert(
						KeyedReferenceType.CategoryBag == keyedReferenceType,
						"Unexpected keyed reference type '" + keyedReferenceType.ToString()
						+ "' for parent entity type '" + parentType.ToString() + "'" );

					sp.ProcedureName = "net_businessService_categoryBag_get";

					sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromString( "@serviceKey", parentKey );

					break;

				case EntityType.TModel:
					if( KeyedReferenceType.CategoryBag == keyedReferenceType )
						sp.ProcedureName = "net_tModel_categoryBag_get";
					else
						sp.ProcedureName = "net_tModel_identifierBag_get";

					sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.SetGuidFromKey( "@tModelKey", parentKey );

					break;

				default:
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_UNEXPECTED_PARENT_ENTITY_TYPE" , parentType.ToString()  );					
			}

			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				Read( reader );
#if never
				while( reader.Read() )
				{
					Add(
						reader.GetString( "keyName" ),
						reader.GetString( "keyValue" ),
						reader.GetKeyFromGuid( "tModelKey" ) );
				}
#endif
			}
			finally
			{
				reader.Close();
			}

			Debug.Leave();
		}

		public void Read( SqlDataReaderAccessor reader )
		{
			while( reader.Read() )
			{
				Add( reader.GetString( "keyName" ),
					 reader.GetString( "keyValue" ),
					 reader.GetKeyFromGuid( "tModelKey" ) );
			}
		}

		public int IndexOf( KeyedReference value )
		{
			return List.IndexOf( value );
		}
		public bool Contains( KeyedReference value )
		{
			return List.Contains( value );
		}
		public void Remove( KeyedReference value )
		{
			List.Remove( value );
		}

		public void CopyTo( KeyedReference[] array )
		{
			foreach( KeyedReference keyedReference in array )
				Add( keyedReference );
		}

		public KeyedReference[] ToArray()
		{
			return (KeyedReference[])InnerList.ToArray( typeof( KeyedReference ) );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\serializer.cs ===
using System;
using System.Collections;
using System.Xml.Serialization;

using UDDI.API.Business;
using UDDI.Replication;
using UDDI.Diagnostics;

namespace UDDI
{
	//
	// This class caches all of the serializers that our API and replication uses.
	//
	public class XmlSerializerManager
	{						
		private static Hashtable serializers;

		static XmlSerializerManager()		
		{
			//
			// Pre-create all of our serializers
			//
			serializers = new Hashtable();

			Type type = typeof( ChangeRecordAcknowledgement );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( ChangeRecordCorrection );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( ChangeRecordCustodyTransfer );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( ChangeRecordDelete );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( ChangeRecordDeleteAssertion );
			serializers.Add( type, new XmlSerializer( type ) ) ;
			
			type = typeof( ChangeRecordHide );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( ChangeRecordNewData );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( ChangeRecordNull );
			serializers.Add( type, new XmlSerializer( type ) ) ;
			
			type = typeof( ChangeRecordPublisherAssertion );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( ChangeRecordSetAssertions );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( BusinessEntity );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( UserInfo );
			serializers.Add( type, new XmlSerializer( type ) ) ;

			type = typeof( UDDI.API.DispositionReport );
			serializers.Add( type, new XmlSerializer( type ) ) ;
		}

		static public XmlSerializer GetSerializer( Type type )
		{				
			XmlSerializer serializer = ( XmlSerializer )serializers[ type ];

			if( null == serializer )
			{
				Debug.Write( SeverityType.Warning, CategoryType.None, "No serializer for type: " + type.FullName );
				
				serializer = new XmlSerializer( type );
				serializers[ type ] = serializer;
			}

			return serializer;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\phone.cs ===
using System;
using System.Data;
using System.Collections;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI;

namespace UDDI.API.Business
{
	public class Phone
	{
		[XmlAttribute("useType")]
		public string UseType;

		[XmlText]
		public string Value;

		public Phone()
		{
		}

		public Phone( string phone, string useType )
		{
			Value = phone;
			UseType = useType;
		}

		internal void Validate()
		{
			Utility.ValidateLength( ref UseType, "useType", UDDI.Constants.Lengths.UseType );
			Utility.ValidateLength( ref Value, "phone", UDDI.Constants.Lengths.Phone );
		}
		
		public void Save( long contactID )
		{
			//
			// Create a command object to invoke the stored procedure
			//
			SqlCommand cmd = new SqlCommand( "net_contact_phone_save", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;
			
			//
			// Input parameters
			//
			cmd.Parameters.Add( new SqlParameter( "@contactID", SqlDbType.BigInt ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@phone", SqlDbType.NVarChar, UDDI.Constants.Lengths.Phone ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@useType", SqlDbType.NVarChar, UDDI.Constants.Lengths.UseType ) ).Direction = ParameterDirection.Input;

			//
			// Set parameter values
			//
			SqlParameterAccessor parmacc = new SqlParameterAccessor( cmd.Parameters );
			parmacc.SetLong( "@contactID", contactID );
			parmacc.SetString( "@phone", Value );
			parmacc.SetString( "@useType", UseType );

			cmd.ExecuteNonQuery();
		}
	}
	public class PhoneCollection : CollectionBase
	{
		internal void Validate()
		{
			foreach( Phone phone in this )
			{
				phone.Validate();
			}
		}
		
		public void Save( long contactID )
		{
			//
			// Walk collection and call save on individual contact instances
			//
			foreach( Phone phone in this )
				phone.Save( contactID );
		}
		
		public void Get( long contactID )
		{		
			//
			// Create a command object to invoke the stored procedure net_get_contacts
			//
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_contact_phones_get" );
						
			//
			// Add parameters and set values
			//					
			cmd.Parameters.Add( "@contactID", SqlDbType.BigInt, ParameterDirection.Input );
			cmd.Parameters.SetLong( "@contactID", contactID );

			//
			// Run the stored procedure
			//
			SqlDataReaderAccessor reader = cmd.ExecuteReader();
			try
			{		
				Read( reader );
#if never
				//
				// Phones for this contact will be contained in the resultset
				//
				while( rdr.Read() )
				{
					//
					// construct a new contact from the data in this row, fully populate contact and add to collection
					//
					this.Add( dracc.GetString( PhoneIndex ), dracc.GetString( UseTypeIndex ) );
				}
#endif
			}
			finally
			{
				reader.Close();
			}
		}

		public void Read( SqlDataReaderAccessor reader )
		{
			const int UseTypeIndex = 0;
			const int PhoneIndex = 1;

			//
			// Phones for this contact will be contained in the resultset
			//
			while( reader.Read() )
			{
				//
				// construct a new contact from the data in this row, fully populate contact and add to collection
				//
				this.Add( reader.GetString( PhoneIndex ), reader.GetString( UseTypeIndex ) );
			}
		}

		public Phone this[int index]
		{
			get { return ( Phone )List[ index]; }
			set { List[ index ] = value; }
		}

		public int Add( Phone phoneObject )
		{
			return List.Add( phoneObject );
		}

		public int Add( string phone )
		{
			return( Add( phone, null ) );
		}

		public int Add( string phone, string useType )
		{
			return List.Add( new Phone( phone, useType ) );
		}

		public void Insert( int index, Phone value )
		{
			List.Insert( index, value );
		}

		public int IndexOf( Phone value )
		{
			return List.IndexOf( value );
		}

		public bool Contains( Phone value )
		{
			return List.Contains( value );
		}

		public void Remove( Phone value )
		{
			List.Remove( value );
		}

		public void CopyTo( Phone[] array, int index )
		{
			List.CopyTo( array, index );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\publish.cs ===
using System;
using System.IO;
using System.Web;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Web.Services;
using System.Xml.Serialization;
using System.Security.Principal;
using System.Web.Security;
using System.Web.Services.Protocols;
using UDDI.API;
using UDDI;
using UDDI.Diagnostics;
using UDDI.API.Authentication;
using UDDI.API.Binding;
using UDDI.API.Service;
using UDDI.API.Business;
using UDDI.API.ServiceType;

namespace UDDI.API
{
	/// ****************************************************************
	///   class PublishMessages
	///	----------------------------------------------------------------
	///	  <summary>
	///		This is the web service class that contains the UDDI 
	///		publish methods.
	///	  </summary>
	/// ****************************************************************
	/// 
	[SoapDocumentService( ParameterStyle=SoapParameterStyle.Bare, RoutingStyle=SoapServiceRoutingStyle.RequestElement )]
	[WebService( Namespace=UDDI.API.Constants.Namespace )]
	public class PublishMessages
	{
		/// ****************************************************************
		///   public AddPublisherAssertions
		///	----------------------------------------------------------------
		///	  <summary>
		///		Web method for adding publisher assertions.  Users are
		///		authenticated and the message is processed as part of a
		///		transaction.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="message">
		///		A properly formed instance of the add_publisherAssertions
		///		message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a disposition report indicating success or failure.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod( Action = "\"\"", RequestElementName = "add_publisherAssertions" )]
		[UDDIExtension( authenticate = true, transaction = true, https = true, messageType = "add_publisherAssertions" )]
		public DispositionReport AddPublisherAssertions( AddPublisherAssertions message )
		{
			Debug.Enter();

			//
			// Create a disposition report indicating success
			//
			DispositionReport report = new DispositionReport();

			try
			{
				//
				// Add the publisher assertions.
				//
				message.Save();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}
			
			Debug.Leave();
			
			return report;
		}

		/// ****************************************************************
		///   public DeleteBinding
		///	----------------------------------------------------------------
		///	  <summary>
		///		Web method for removing a set of bindingTemplates from the UDDI registry.
		///		Users are authenticated and the message is processed as part of a
		///		transaction.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="dbind">
		///		A properly formed instance of the delete_binding message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a dispositionReport indicating success or failure.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="delete_binding")]
		[UDDIExtension( authenticate=true, transaction=true, https=true, messageType="delete_binding" )]
		public DispositionReport DeleteBinding( DeleteBinding dbind )
		{
			Debug.Enter();

			//
			// Create dispositionReport indicating success
			//
			DispositionReport dr = new DispositionReport();

			try
			{
				//
				// Delete the binding
				//
				dbind.Delete();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}
			
			return dr;
		}

		/// ****************************************************************
		///   public DeleteBusiness
		///	----------------------------------------------------------------
		///	  <summary>
		///		Web method for removing a set of businessEntities from the UDDI registry.
		///		Users are authenticated and the message is processed as part of a
		///		transaction.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="dbus">
		///		A properly formed instance of the delete_business message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a dispositionReport indicating success or failure.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="delete_business")]
		[UDDIExtension( authenticate=true, transaction=true, https=true, messageType="delete_business" )]
		public DispositionReport DeleteBusiness( DeleteBusiness dbus )
		{
			Debug.Enter();

			DispositionReport dr = new DispositionReport();
			try
			{
				//
				// Delete the business
				//
				dbus.Delete();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}
			
			return dr;
		}

		/// ****************************************************************
		///   public class DeletePublisherAssertions
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		[WebMethod]
		[SoapDocumentMethod( Action = "\"\"", RequestElementName = "delete_publisherAssertions" )]
		[UDDIExtension( authenticate = true, transaction = true, https = true, messageType = "delete_publisherAssertions" )]
		public DispositionReport DeletePublisherAssertions( DeletePublisherAssertions message )
		{
			Debug.Enter();
			
			DispositionReport report = new DispositionReport();

			try
			{
				message.Delete();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			Debug.Leave();

			return report;
		}

		/// ****************************************************************
		///   public DeleteService
		///	----------------------------------------------------------------
		///	  <summary>
		///		Web method for removing a set of businessServices from the UDDI registry.
		///		Users are authenticated and the message is processed as part of a
		///		transaction.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="ds">
		///		A properly formed instance of the delete_service message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a dispositionReport indicating success or failure.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="delete_service")]
		[UDDIExtension( authenticate=true, transaction=true, https=true, messageType="delete_service" )]
		public DispositionReport DeleteService( DeleteService ds )
		{
			Debug.Enter();
			DispositionReport dr = new DispositionReport();
			try
			{
				//
				// Delete the service
				//
				ds.Delete();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return dr;
		}

		/// ****************************************************************
		///   public DeleteTModel
		///	----------------------------------------------------------------
		///	  <summary>
		///		Web method for removing a set of tModels from the UDDI registry.
		///		Users are authenticated and the message is processed as part of a
		///		transaction.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="dtm">
		///		A properly formed instance of the delete_tModel message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a dispositionReport indicating success or failure.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="delete_tModel")]
		[UDDIExtension( authenticate=true, transaction=true, https=true, messageType="delete_tModel" )]
		public DispositionReport DeleteTModel( DeleteTModel dtm )
		{
			Debug.Enter();
			DispositionReport dr = new DispositionReport();
			try
			{
				//
				// Delete the tModel
				//
				dtm.Delete();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return dr;
		}

		/// ****************************************************************
		///   public DiscardAuthToken
		///	----------------------------------------------------------------
		///	  <summary>
		///			This optional message is used to deactivate an authentication token
		///			that was obtained by a call to get_authToken.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="dat">
		///		A properly formed instance of the discard_authToken message.
		///	  </param>
		///	----------------------------------------------------------------
		///   <returns>
		///		Returns a dispositionReport indicating success or failure.
		///	  </returns>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="discard_authToken")]
		[UDDIExtension( https=true, messageType="discard_authToken" )]
		public DispositionReport DiscardAuthToken( DiscardAuthToken dat )
		{
			Debug.Enter();
			DispositionReport dr = new DispositionReport();

			try
			{
				if( ( Config.GetInt( "Security.AuthenticationMode" ) == (int) AuthenticationMode.Passport ) )
				{
					PassportAuthenticator authenticator = new PassportAuthenticator();
					authenticator.Authenticate( dat.AuthInfo, Config.GetInt( "Security.TimeOut" ) );
					
					//
					// Call to the database to update the user status to logged off.
					//
					SqlCommand cmd = new SqlCommand( "ADM_setPublisherStatus", ConnectionManager.GetConnection() );
				
					cmd.Transaction = ConnectionManager.GetTransaction();
					cmd.CommandType = CommandType.StoredProcedure;
					cmd.Parameters.Add( new SqlParameter( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID ) ).Direction = ParameterDirection.Input;
					cmd.Parameters.Add( new SqlParameter( "@publisherStatus", SqlDbType.NVarChar, UDDI.Constants.Lengths.PublisherStatus ) ).Direction = ParameterDirection.Input;
			
					SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
					paramacc.SetString( "@PUID", Context.User.ID );			
					paramacc.SetString( "@publisherStatus", "loggedOut");
					cmd.ExecuteNonQuery();
				}
				
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return dr;
		}

		[WebMethod]
		[SoapDocumentMethod( Action = "\"\"", RequestElementName = "get_assertionStatusReport" )]
		[UDDIExtension( authenticate = true, https = true, messageType = "get_assertionStatusReport" )]
		public AssertionStatusReport GetAssertionStatusReport( GetAssertionStatusReport message )
		{
			Debug.Enter();

			AssertionStatusReport statusReport = new AssertionStatusReport();

			try
			{
				statusReport.Get( message.CompletionStatus );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}
			
			Debug.Leave();

			return statusReport;
		}


		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="get_authToken")]
		[UDDIExtension( https=true, messageType="get_authToken" )]
		public AuthToken GetAuthToken( GetAuthToken gat )
		{
			Debug.Enter();
			AuthToken at = new AuthToken();

			try
			{
				//
				// XX-SECURITY: Review the value here in the case where we use
				// XX-this with a web.config with Authentication set to None or Passport
				//
				//
				// NOW:	We now Get a Generic Identity.  If the AuthenticationMode is AuthenticationMode.Passport (8),
				//		we make sure the Identity is a PassportIdentity, then we authenticate.  If AuthenticationMode
				//		is Not set to AuthenticationMode.Passport, then process it as a WindowsIdentity.
				//
				//
								
				IIdentity identity = HttpContext.Current.User.Identity;

				int mode = Config.GetInt( "Security.AuthenticationMode", (int) AuthenticationMode.Both );
				if( ( (int) AuthenticationMode.Passport ) == mode )
				{
					if( identity is PassportIdentity )
					{
						Debug.Write( SeverityType.Info, CategoryType.Soap, "Generating credentials for Passport based authentication Identity is " + gat.UserID  );
						
						PassportAuthenticator pa = new PassportAuthenticator();

						//
						// Get a Passport ticket for this user.
						//
						if( !pa.GetAuthenticationInfo( gat.UserID, gat.Cred, out at.AuthInfo ) )
						{																		
							// throw new UDDIException( ErrorType.E_unknownUser, "User failed authentication." ) ;
							throw new UDDIException( ErrorType.E_unknownUser, "USER_FAILED_AUTHENTICATION" ) ;
						}

						//
						// We need to extract the PUID from the ticket and put it into our Context.UserInfo.ID; a 
						// successfull call to Authenticate will do all of this.
						//
						if( !pa.Authenticate( at.AuthInfo, UDDI.Constants.Passport.TimeWindow ) )
						{
							throw new UDDIException( ErrorType.E_unknownUser, "UDDI_ERROR_USER_FAILED_AUTHENTICATION" ) ;
						}
						
						//
						// Make sure this Passport user has registered with our UDDI site as a publisher.
						//
						if( !Context.User.IsVerified )
						{							
							// throw new UDDIException( ErrorType.E_unknownUser, "Not a valid publisher." ) ;
							throw new UDDIException( ErrorType.E_unknownUser, "UDDI_ERROR_NOT_A_VALID_PUBLISHER" ) ;
						}						
					}
					else
					{
#if never						
						throw new UDDIException( ErrorType.E_fatalError, 
									"CONFIGURATION ERROR:  Passport Identity Expected.  \r\n"+
									"You are currently running in Passport Authentication Mode. \r\n"+
									"Check your web.config for the <authentication mode=\"Passport\" /> entry and try again." ) ;
#endif

						throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_PASSPORT_CONFIGURATION_ERROR" );							
					}
				}

				//
				// SECURITY: Check to make sure the password is blank too
				//
				else if( !((WindowsIdentity)identity).IsAnonymous && 
					( ( mode & (int) AuthenticationMode.Windows ) != 0 ) &&
					Utility.StringEmpty( gat.UserID ) )
				{
					Debug.Write( SeverityType.Info, CategoryType.Soap, "Generating credentials for Windows based authentication Identity is " + identity.Name );
					WindowsAuthenticator wa = new WindowsAuthenticator();
					wa.GetAuthenticationInfo( gat.UserID, gat.Cred, out at.AuthInfo );
				}
				else if( ( mode & (int) AuthenticationMode.Uddi ) != 0 )
				{
					Debug.Write( SeverityType.Info, CategoryType.Soap, "Generating credentials for UDDI based authentication" );
					UDDIAuthenticator ua = new UDDIAuthenticator();
					ua.GetAuthenticationInfo( gat.UserID, gat.Cred, out at.AuthInfo );
				}
				else
				{
				//	throw new UDDIException( UDDI.ErrorType.E_unsupported,
						//"The UDDI server is not configured to support the requested form of authentication." );
					throw new UDDIException( UDDI.ErrorType.E_unsupported, "UDDI_ERROR_AUTHENTICATION_CONFIGURATION_ERROR" );					
				}

				Debug.Write( SeverityType.Info, CategoryType.Soap, "Windows Identity is " + WindowsIdentity.GetCurrent().Name );
				Debug.Write( SeverityType.Info, CategoryType.Soap, "Thread Identity is " + System.Threading.Thread.CurrentPrincipal.Identity.Name );
				Debug.Write( SeverityType.Info, CategoryType.Soap, "HttpContext Identity is " + identity.Name );

				//
				// Check to make sure the authenticated user has publisher credentials
				//
#if never
				Debug.Verify( Context.User.IsPublisher, 
					"The user account " + Context.User.ID + " does not have publisher credentials",
					UDDI.ErrorType.E_fatalError );
#endif

				Debug.Verify( Context.User.IsPublisher, 
							  "UDDI_ERROR_NO_PUBLISHER_CREDENTIALS",
							  UDDI.ErrorType.E_fatalError,
							  Context.User.ID );

				Debug.Write(
					SeverityType.Info,
					CategoryType.Authorization,
					"Authenticated user (userid = " + gat.UserID + " )" );
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return at;
		}

		/// ****************************************************************
		///   public class GetPublisherAssertions
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		[WebMethod]
		[SoapDocumentMethod( Action = "\"\"", RequestElementName = "get_publisherAssertions" )]
		[UDDIExtension( authenticate = true, https = true, messageType = "get_publisherAssertions" )]
		public PublisherAssertionDetail GetPublisherAssertions( GetPublisherAssertions message )
		{
			Debug.Enter();
			
			PublisherAssertionDetail detail = new PublisherAssertionDetail();

			try
			{
				detail.Get();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			Debug.Leave();

			return detail;
		}

		/// ****************************************************************
		///   public class GetRegisteredInfo
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		[WebMethod, SoapDocumentMethod( Action="\"\"", RequestElementName="get_registeredInfo" )]
		[UDDIExtension( authenticate=true, https=true, messageType="get_registeredInfo")]
		public RegisteredInfo GetRegisteredInfo( GetRegisteredInfo gri )
		{
			Debug.Enter();
			RegisteredInfo ri = new RegisteredInfo();

			try
			{
				ri.Get();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return ri;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="save_binding")]
		[UDDIExtension( authenticate=true, transaction=true, https=true, messageType="save_binding")]
		public BindingDetail SaveBinding( SaveBinding sb )
		{
			Debug.Enter();
			BindingDetail bd = new BindingDetail();

			try
			{
				sb.Save();
				bd.BindingTemplates = sb.BindingTemplates;
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return bd;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="save_business")]
		[UDDIExtension( authenticate=true, transaction=true, https=true, messageType="save_business" )]
		public BusinessDetail SaveBusiness( SaveBusiness sb )
		{
			Debug.Enter();
			BusinessDetail bd = new BusinessDetail();
			try
			{
				sb.Save();
				bd.BusinessEntities = sb.BusinessEntities;
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return bd;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="save_service")]
		[UDDIExtension( authenticate=true, transaction=true, https=true, messageType="save_service" )]
		public ServiceDetail SaveService( SaveService ss )
		{
			Debug.Enter();
			ServiceDetail sd = new ServiceDetail();

			try
			{
				ss.Save();
				sd.BusinessServices = ss.BusinessServices;
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return sd;
		}

		[WebMethod, SoapDocumentMethod(Action="\"\"", RequestElementName="save_tModel")]
		[UDDIExtension( authenticate=true, transaction=true, https=true, messageType="save_tModel" )]
		public TModelDetail SaveTModel( UDDI.API.ServiceType.SaveTModel stm )
		{
			Debug.Enter();
			TModelDetail tmd = new TModelDetail();
			try
			{
				stm.Save();
				tmd.TModels = stm.TModels;
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}

			return tmd;
		}

		[WebMethod()]
		[SoapDocumentMethod( Action = "\"\"", RequestElementName = "set_publisherAssertions" )]
		[UDDIExtension( authenticate = true, transaction = true, https = true, messageType = "set_publisherAssertions" )]
		public PublisherAssertionDetail SetPublisherAssertions( SetPublisherAssertions message )
		{
			Debug.Enter();

			PublisherAssertionDetail detail = new PublisherAssertionDetail();

			try
			{
				detail = message.Set();
			}
			catch( Exception e )
			{
				DispositionReport.Throw( e );
			}
			
			Debug.Leave();

			return detail;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\taxonomy.cs ===
using System;
using System.Data;
using System.IO;
using System.Collections;
using System.Data.SqlClient;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using UDDI.API;
using UDDI;
using UDDI.Diagnostics;
using UDDI.API.Binding;
using UDDI.API.Service;
using UDDI.API.Business;
using UDDI.API.ServiceType;

namespace UDDI.Admin
{
	[XmlRootAttribute("resources", Namespace="urn:microsoft-com:uddi_bootstrap_v1")]
	public class Resources
	{
		private TModelDetail tModelDetail;

		[XmlElement("tModelDetail", Namespace=UDDI.API.Constants.Namespace)]
		public TModelDetail TModelDetail
		{
			get
			{
				if( null == (object) tModelDetail )
				{
					tModelDetail = new TModelDetail();
				}

				return tModelDetail;
			}
			set
			{
				tModelDetail = value;
			}
		}

		[XmlIgnore()]
		public TaxonomyCollection Taxonomies = new TaxonomyCollection();

		[XmlArray( "categorizationSchemes" ), XmlArrayItem( "categorizationScheme" )]
		public Taxonomy[] TaxonomiesSerialize
		{
			get
			{
				return Taxonomies.ToArray();
			}
			set
			{
				Taxonomies.CopyTo( value );
			}
		}

		private BusinessDetail businessDetail;

		[XmlElement("businessDetail", Namespace=UDDI.API.Constants.Namespace)]
		public BusinessDetail BusinessDetail
		{
			get
			{
				if( null == businessDetail )
				{
					businessDetail = new BusinessDetail();
				}

				return businessDetail;
			}
			set
			{
				businessDetail = value;
			}
		}

		private ServiceDetail serviceDetail;

		[XmlElement("serviceDetail", Namespace=UDDI.API.Constants.Namespace)]
		public ServiceDetail ServiceDetail
		{
			get
			{
				if( null == serviceDetail )
				{
					serviceDetail = new ServiceDetail();
				}

				return serviceDetail;
			}
			set
			{
				serviceDetail = value;
			}
		}

		private BindingDetail bindingDetail;

		[XmlElement("bindingDetail", Namespace=UDDI.API.Constants.Namespace)]
		public BindingDetail BindingDetail
		{
			get
			{
				if( null == bindingDetail )
				{
					bindingDetail = new BindingDetail();
				}

				return bindingDetail;
			}
			set
			{
				bindingDetail = value;
			}
		}

		public Resources(){}

		public static void Validate( Stream strm )
		{
			Debug.VerifySetting( "Schema-v2" );
			Debug.VerifySetting( "InstallRoot" );

			string apiSchema = Config.GetString( "Schema-v2" );
			string resourceSchema = Config.GetString( "InstallRoot") + "uddi.resources.xsd";

			Debug.Verify( File.Exists( apiSchema ), "The API schema was not found in the location " + apiSchema );
			Debug.Verify( File.Exists( resourceSchema ), "The UDDI data resource schema was not found in the location " + resourceSchema );

			XmlSchemaCollection xsc = new XmlSchemaCollection();
			xsc.Add( "urn:uddi-org:api_v2", apiSchema );
			xsc.Add( "urn:microsoft-com:uddi_bootstrap_v1", resourceSchema );

			//
			// Rewind stream (to be safe) and validate
			//
			strm.Seek( 0, SeekOrigin.Begin );

			//
			// Construct a validating reader to verify the document is kosher
			//
			XmlTextReader reader = new XmlTextReader( strm );
			XmlValidatingReader vreader = new XmlValidatingReader( reader );
			vreader.Schemas.Add( xsc );
			while( vreader.Read()){}
			
			//
			// Rewind stream again, so someone else can use it
			//
			strm.Seek( 0, SeekOrigin.Begin );

		}

		public void Save()
		{
			UDDI.Diagnostics.Debug.Enter();

			Debug.Write( SeverityType.Info, CategoryType.Data, "Importing tModels..." );
			foreach( TModel tm in TModelDetail.TModels )
			{
				tm.Save();
			}

			Debug.Write( SeverityType.Info, CategoryType.Data, "Importing Categorization schemes..." );
			foreach( Taxonomy cs in Taxonomies )
			{
				cs.Save();
			}

			Debug.Write( SeverityType.Info, CategoryType.Data, "Importing Providers..." );
			foreach( BusinessEntity be in BusinessDetail.BusinessEntities )
			{
				be.Save();
			}

			Debug.Write( SeverityType.Info, CategoryType.Data, "Importing Services..." );
			foreach( BusinessService bs in ServiceDetail.BusinessServices )
			{
				bs.Save();
			}

			Debug.Write( SeverityType.Info, CategoryType.Data, "Importing bindings..." );
			foreach( BindingTemplate bind in BindingDetail.BindingTemplates )
			{
				bind.Save();
			}
		}
	}

	public class Taxonomy
	{
		private string tModelKey = "";

		private int taxonomyFlag = 1;

		[XmlAttribute( "checked" )]
		public XmlBoolType Checked
		{
			get { return ( 1 == taxonomyFlag ) ? XmlBoolType.True : XmlBoolType.False; }
			set	
			{ 
				if( XmlBoolType.True == value )
					taxonomyFlag = 1;
				else
					taxonomyFlag = 2;
			}
		}

		[XmlElement( "tModelKey" )]
		public string TModelKey
		{
			get
			{ 
				return tModelKey; 
			}
			set
			{ 
				tModelKey = value; 
			}
		}

		[XmlIgnore()]
		public TaxonomyValueCollection TaxonomyValues = new TaxonomyValueCollection();

		[XmlArray( "categoryValues" ), XmlArrayItem( "categoryValue" )]
		public TaxonomyValue[] TaxonomyValuesSerialize
		{
			get
			{
				return TaxonomyValues.ToArray();
			}
			set
			{
				TaxonomyValues.CopyTo( value );
			}
		}

		public Taxonomy()
		{
		}

		public void Delete()
		{
			Debug.Enter();
			
			SqlCommand cmd = new SqlCommand( "net_taxonomy_delete", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Transaction = ConnectionManager.GetTransaction();

			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;

			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetGuidFromKey( "@tModelKey", tModelKey );

			cmd.ExecuteNonQuery();

			Debug.Leave();
		}

		public void Save()
		{
			Debug.Enter();

			//
			// Save the taxonomy entry.
			//
			SqlCommand cmd = new SqlCommand( "net_taxonomy_save", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@flag", SqlDbType.Int ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@taxonomyID", SqlDbType.Int ) ).Direction = ParameterDirection.Output;
			
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetGuidFromKey( "@tModelKey", tModelKey );
			paramacc.SetInt( "@flag", taxonomyFlag );

			cmd.ExecuteNonQuery();

			int taxonomyID = paramacc.GetInt( "@taxonomyID" );

			foreach( TaxonomyValue tv in TaxonomyValues )
			{
				tv.Save( tModelKey );
			}
		}
	}

	public enum ValidForCategorization
	{
		[XmlEnumAttribute("false")]
		False	= 0,
		[XmlEnumAttribute("true")]
		True	= 1,
	}

	public class TaxonomyValue
	{
		[XmlAttribute( "categoryKey" )]
		public string KeyValue;

		private bool validForClassification = true;
		
		[XmlAttribute( "isValid" )]
		public ValidForCategorization ValidForClassification
		{
			get
			{ 
				return validForClassification ? ValidForCategorization.True : ValidForCategorization.False;
			}
			set
			{
				if( ValidForCategorization.True == value )
					validForClassification = true;
				else
					validForClassification = false;
			}
		}

		[XmlElement( "parentCategoryKey" )]
		public string ParentKeyValue;

		[XmlArray( "categoryNames" ), XmlArrayItem( "categoryName" )]
		public KeyName[] KeyNames;

		public TaxonomyValue(){}
		public TaxonomyValue( string keyValue, string parentKeyValue, string keyName, bool validForClassification )
		{
			this.KeyValue = keyValue;
			this.ParentKeyValue = parentKeyValue;
			KeyNames = new KeyName[ 1 ];
			KeyNames[0].Name = keyName;
			this.validForClassification = validForClassification;
		}

		public void Save( string tModelKey )
		{
			Debug.Enter();

			SqlCommand cmd = new SqlCommand( "net_taxonomyValue_save", ConnectionManager.GetConnection() );
			
			cmd.CommandType = CommandType.StoredProcedure;
			cmd.Transaction = ConnectionManager.GetTransaction();
			
			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@keyValue", SqlDbType.NVarChar, 128 ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@parentKeyValue", SqlDbType.NVarChar, 128 ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@keyName", SqlDbType.NVarChar, 128 ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@valid", SqlDbType.Bit ) ).Direction = ParameterDirection.Input;
			
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
				
			paramacc.SetGuidFromKey( "@tModelKey", tModelKey );
			paramacc.SetString( "@keyValue", KeyValue );
			paramacc.SetString( "@keyName", KeyNames[0].Name );
			cmd.Parameters[ "@valid" ].Value = ValidForClassification;

			if( Utility.StringEmpty( ParentKeyValue ) )
				paramacc.SetString( "@parentKeyValue", KeyValue );
			else
				paramacc.SetString( "@parentKeyValue", ParentKeyValue );

			cmd.ExecuteNonQuery();
		}
	}

	public class KeyName
	{
		[XmlText()]
		public string Name;

		[XmlAttribute( "xml:lang" )]
		public string IsoLanguageCode;

		public KeyName(){}
	}

	public class TaxonomyCollection : CollectionBase
	{
		public TaxonomyCollection()
		{
		}


		public void Save()
		{
			Debug.Enter();

			foreach( Taxonomy tax in this )
			{
				tax.Save();
			}

			Debug.Leave();
		}

		public Taxonomy this[int index]
		{
			get 
			{ return (Taxonomy)List[index]; }
			set 
			{ List[index] = value; }
		}

		public int Add(Taxonomy value)
		{
			return List.Add(value);
		}

		public void Insert(int index, Taxonomy value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( Taxonomy value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( Taxonomy value )
		{
			return List.Contains( value );
		}
		
		public void Remove( Taxonomy value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(Taxonomy[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public void CopyTo( Taxonomy[] array )
		{
			foreach( Taxonomy tax in array )
				Add( tax );
		}

		public Taxonomy[] ToArray()
		{
			return (Taxonomy[]) InnerList.ToArray( typeof( Taxonomy ) );
		}
	}

	public class TaxonomyValueCollection : CollectionBase
	{
		public TaxonomyValueCollection()
		{
		}

		public TaxonomyValue this[int index]
		{
			get 
			{ return (TaxonomyValue)List[index]; }
			set 
			{ List[index] = value; }
		}

		public int Add(TaxonomyValue value)
		{
			return List.Add(value);
		}

		public void Insert(int index, TaxonomyValue value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf( TaxonomyValue value )
		{
			return List.IndexOf( value );
		}
		
		public bool Contains( TaxonomyValue value )
		{
			return List.Contains( value );
		}
		
		public void Remove( TaxonomyValue value )
		{
			List.Remove( value );
		}
		
		public void CopyTo(TaxonomyValue[] array, int index)
		{
			List.CopyTo( array, index );
		}

		public void CopyTo( TaxonomyValue[] array )
		{
			foreach( TaxonomyValue tax in array )
				Add( tax );
		}

		public TaxonomyValue[] ToArray()
		{
			return (TaxonomyValue[]) InnerList.ToArray( typeof( TaxonomyValue ) );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\service.cs ===
using System;
using UDDI;
using System.Data;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI.API.Binding;
using UDDI.Replication;
using UDDI.API.ServiceType;
using UDDI.Diagnostics;

namespace UDDI.API.Service
{
	/// ********************************************************************
	///   class BusinessService
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute( "businessService", Namespace=UDDI.API.Constants.Namespace )]
	public class BusinessService : EntityBase
	{
		//
		// Attribute: serviceKey
		//		
		[XmlAttribute("serviceKey")]
		public string ServiceKey = "";

		//
		// Attribute: businessKey
        //	
		[XmlAttribute("businessKey")]
		public string BusinessKey = "";

		//
		// Element: name
		//		
		private NameCollection names;

		[XmlElement("name")]
		public NameCollection Names
		{
			get 
			{ 
				if( null == names )
					names = new NameCollection();
				
				return names; 
			}
			
			set { names = value; }
		}

		//
		// Element: description
		//	
		private DescriptionCollection descriptions;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		//
		// Element: bindingTemplates
		//		
		[ XmlIgnore ]
		public BindingTemplateCollection BindingTemplates = new BindingTemplateCollection();

		[ XmlArray( "bindingTemplates" ), XmlArrayItem( "bindingTemplate" ) ]
		public BindingTemplate[] BindingTemplatesSerialize
		{
			get
			{
				//
				// Don't return an empty BindingTemplates collection if we are not using v1.0.
				//
				if( true == Utility.CollectionEmpty( BindingTemplates ) && 
					1    != Context.ApiVersionMajor)
				{
					return null;
				}
				else
				{				
					return BindingTemplates.ToArray();
				}
			}

			set
			{
				BindingTemplates.Clear();
				BindingTemplates.CopyTo( value );
			}
		}

		//
		// Element: categoryBag
		//
		[ XmlIgnore ]
		public KeyedReferenceCollection CategoryBag = new KeyedReferenceCollection();

		[ XmlArray( "categoryBag" ), XmlArrayItem( "keyedReference" ) ]
		public KeyedReference[] CategoryBagSerialize
		{
			get
			{
				if( Utility.CollectionEmpty( CategoryBag ) )
					return null;

				return CategoryBag.ToArray();
			}

			set 
			{ 
				CategoryBag.Clear();
				CategoryBag.CopyTo( value ); 
			}
		}

		[XmlIgnore]
		public override UDDI.EntityType EntityType
		{
			get { return EntityType.BusinessService; }
		}
		
		[XmlIgnore]
		public override string EntityKey
		{
			get { return ServiceKey; }
		}

		/// ****************************************************************
		///   public BusinessService [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public BusinessService()
		{			
		}

		/// ****************************************************************
		///   public BusinessService [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///	  <param name="serviceKey">
		///	  </param>
		/// ****************************************************************
		/// 
		public BusinessService( string serviceKey )
		{
			ServiceKey = serviceKey;
		}

		public BusinessService( string serviceKey, string businessKey )
		{
			ServiceKey = serviceKey;
			BusinessKey = businessKey;
		}

		/// ****************************************************************
		///   public Delete
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public override void Delete()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_businessService_delete";

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
			
			sp.ExecuteNonQuery();

			//
			// Save the change log entry.
			//
			if( Context.LogChangeRecords )
			{
				ChangeRecord changeRecord = new ChangeRecord();

				changeRecord.Payload = new ChangeRecordDelete( EntityType.BusinessService, ServiceKey );
				changeRecord.Log();
			}
		}

		/// ****************************************************************
		///   public Get
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public override void Get()
		{
			Debug.Enter();
			
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessService_get_batch" );
	
			sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier, ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );

			SqlDataReaderAccessor reader = null;
			try
			{
				//
				// net_businessEntity_get will return the objects contained in a business in the following order:
				//
				//	- descriptions
				//	- names
				//	- binding templates				
				//  - category bags				
				reader = sp.ExecuteReader();

				//
				// Read the descriptions
				//
				Descriptions.Read( reader );					
				
				//
				// Read the names
				//
				if( true == reader.NextResult() )
				{
					Names.Read( reader );		
				}

				//
				// Read the binding templates
				//
				if( true == reader.NextResult() )
				{
					BindingTemplates.Read( reader );					
				}

				//
				// Read the category bags
				//
				if( true == reader.NextResult() )
				{
					CategoryBag.Read( reader );					
				}
			}
			finally
			{
				if( null != reader )
				{
					reader.Close();
				}
			}

			//
			// These calls will make separate sproc calls, so we have to close our reader first.
			//
			BindingTemplates.Populate();

			//
			// Output parameters
			//
			BusinessKey = sp.Parameters.GetGuidString( "@businessKey" );

#if never
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessService_get" );
	
			sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier, ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );

			sp.ExecuteNonQuery();

			BusinessKey = sp.Parameters.GetGuidString( "@businessKey" );

			//
			// Get all contained objects.
			//
			Descriptions.Get( ServiceKey, EntityType.BusinessService );
			Names.Get( ServiceKey, EntityType.BusinessService );
			BindingTemplates.Get( ServiceKey );
			CategoryBag.Get( ServiceKey, EntityType.BusinessService, KeyedReferenceType.CategoryBag );
#endif

			QueryLog.Write( QueryType.Get, EntityType.BusinessService );

			Debug.Leave();
		}

		/// ****************************************************************
		///   internal InnerSave
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="businessKey">
		///   </param>
		/// ****************************************************************
		/// 
		internal void InnerSave( string businessKey )
		{
			Debug.Enter();
			
			if( IsServiceProjection( businessKey ) )
			{
				//
				// Make sure that service projections are enabled.
				//
				if( 0 == Config.GetInt( "Service.ServiceProjectionEnable", 1 ) )
				{
					// throw new UDDIException( UDDI.ErrorType.E_fatalError, "Service projections are not enabled" );	
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_SERVICE_PROJECTIONS_NOT_ENABLED" );
				}
#if never
				Debug.Verify( 
					!Utility.StringEmpty( ServiceKey ), 
					"A valid serviceKey must be specified when saving a service projection" );
#endif

				Debug.Verify( 
					!Utility.StringEmpty( ServiceKey ), 
					"UDDI_ERROR_INVALID_SERVICE_PROJECTION_KEY" );

				try
				{
					//
					// Save the service projection.
					//
					SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_serviceProjection_save" );
				
					sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
					sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );

					sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
					sp.Parameters.SetGuidFromString( "@businessKey", businessKey );				
					sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );

					sp.ExecuteNonQuery();

					//
					// Get all of the containing objects for this service; we'll return this information.  Do this
					// in a try and ignore any exceptions because the projected service may not exist.  It is not an
					// error to project to a non-existing service.
					//

					try
					{
						//
						// Clear out collections first.  There might be data in these collections if the request
						// contained information about the service.
						//

						Names.Clear();
						Descriptions.Clear();
						BindingTemplates.Clear();
						CategoryBag.Clear();
					
						Get();
					}
					catch
					{
						//
						// Intentionally left blank.
						//
					}
				}
				catch( SqlException sqlException )
				{
					//
					// As per IN 60, we have to process service projection change records that refer to broken services.
					//					
					if( sqlException.Number - UDDI.Constants.ErrorTypeSQLOffset == ( int ) ErrorType.E_invalidKeyPassed &&
						sqlException.Message.IndexOf( "serviceKey" ) >= 0 && 
						Context.ContextType == ContextType.Replication )
					{							
						SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_serviceProjection_repl_save" );
				
						sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
						sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
						sp.Parameters.Add( "@businessKey2", SqlDbType.UniqueIdentifier );
						sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );

						sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
						sp.Parameters.SetGuidFromString( "@businessKey", businessKey );				
						sp.Parameters.SetGuidFromString( "@businessKey2", BusinessKey );				
						sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );

						sp.ExecuteNonQuery();

						//
						// Set our exception source
						//
						Context.ExceptionSource = ExceptionSource.BrokenServiceProjection;
					}
					else
					{
						Context.ExceptionSource = ExceptionSource.Other;
					}
					
					//
					// Re-throw the exception so replication can properly log it.
					//
					throw sqlException;					
				}
			}
			else
			{				
				//
				// If we are not saving a service projection, then we want to still validate our names collection before
				// saving our service, since the schema has made <name> optional in order to accomodate service projections.
				//
				Names.Validate();

				//
				// Save the contained business service.
				//
				BusinessKey = businessKey;

				if( Utility.StringEmpty( ServiceKey ) )
					ServiceKey = Guid.NewGuid().ToString();
				
				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessService_save" );

				sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
				sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@generic", SqlDbType.VarChar, UDDI.Constants.Lengths.generic );
				sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );

				sp.Parameters.SetString( "@PUID", Context.User.ID );
				sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
				sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );
				sp.Parameters.SetString( "@generic", Constants.Version );
				sp.Parameters.SetGuid( "@contextID", Context.ContextID );				
				sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );

				sp.ExecuteNonQuery();
			
				//
				// Save all contained objects
				//
				Names.Save( ServiceKey, EntityType.BusinessService );
				Descriptions.Save( ServiceKey, EntityType.BusinessService );
				BindingTemplates.Save( ServiceKey );
				CategoryBag.Save( ServiceKey, EntityType.BusinessService, KeyedReferenceType.CategoryBag );
			}

			Debug.Leave();
		}

		/// ****************************************************************
		///   internal Validate
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		internal void Validate( string businessEntityBusinessKey )
		{
			Debug.Enter();
					
			// 
			// We don't want to do this if our save was a service projection because in that case
			// the caller of this operation may or may not be the publisher of the service being
			// projected.
			//
			// If we are doing a service projection, then the business key will be the value of another businessEntity and
			// the serviceKey will be the value of the service in that entity that we want to project.

			//
			// Only do this check if this service is not a service projection.
			//
			
			if( false == IsServiceProjection( businessEntityBusinessKey ) )
			{			
				//
				// We are not doing a service projection, so make sure the caller is the person who published
				// this service.
				//

				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessService_validate" );

				sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
				sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@flag", SqlDbType.Int );

				sp.Parameters.SetString( "@PUID", Context.User.ID );
				sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
				sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );
				if( Context.User.AllowPreassignedKeys )
					sp.Parameters.SetInt( "@flag", 1 );
				else
					sp.Parameters.SetInt( "@flag", 0 );

				//
				// The sproc will throw an exception if anything goes wrong
				//
				sp.ExecuteNonQuery();

				//
				// Validate all contained objects.
				//
				Names.Validate();
				Descriptions.Validate();
				BindingTemplates.Validate();
				CategoryBag.Validate( ServiceKey, KeyedReferenceType.CategoryBag );
			}
			else
			{
				//
				// Make sure that service projections are enabled.
				//
				if( 0 == Config.GetInt( "Service.ServiceProjectionEnable", 1 ) )
				{
					// throw new UDDIException( UDDI.ErrorType.E_fatalError, "Service projections are not enabled" );	
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_SERVICE_PROJECTIONS_NOT_ENABLED" );
				}

				// 
				// Validation for a service projection is different than a regular service.
				//

				//
				// First check to see that we are using the version 2 API, service projections
				// are not supported in version 1.
				if( Context.ApiVersionMajor == 1 )
				{
				//	throw new UDDIException( ErrorType.E_userMismatch, "Service projections are not supported using the version 1.0 API.  Use version 2.0 or higher." );
					throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_SERVICE_PROJECTIONS_NOT_ENABLED_FOR_VERSION" );
				}
			
				//
				// We need to check that the service being projected really belongs to the business key that was specified.  It's ok
				// if the service does not exist, but it cannot belong to someone else (like us).
				//

				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_serviceProjection_validate" );
				
				sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );

				sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
				sp.Parameters.SetGuidFromString( "@businessKey", BusinessKey );

				//
				// The sproc will throw an exception if anything goes wrong
				//
				try
				{
					sp.ExecuteNonQuery();				
				}
				catch( System.Data.SqlClient.SqlException se )
				{
					switch ( se.Number - UDDI.Constants.ErrorTypeSQLOffset )
					{
						case (int) ErrorType.E_invalidKeyPassed :
							//
							// E_invalidKey: parent businessKey of service projection is not true owner
							//
							
							if( Context.ContextType == ContextType.Replication )
							{
								//
								//We are going to allow this under replication but write a warning
								//
								string message = "Service projection saved with invalid businessKey.  serviceKey = " + ServiceKey.ToString() + "; businessKey = " + BusinessKey.ToString();
								Debug.Write( UDDI.Diagnostics.SeverityType.Warning, UDDI.Diagnostics.CategoryType.Data, message );														
							}
							else
							{
								//
								// re-throw error if not running in replication
								//

								throw se;
							}

							break;

						default:
							throw se;
					}		

				}
				catch( Exception e )
				{
					throw e;
				}
			}
			Debug.Leave();
		}
		
		/// ****************************************************************
		///   public Save
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public override void Save()
		{
			Validate( this.BusinessKey );			
			InnerSave( this.BusinessKey );

			//
			// Save the change log entry.
			//
			if( Context.LogChangeRecords )
			{
				//
				// If we used a V1 API message, make sure to add in language codes for the names.  We will
				// then take these names out after we save the change record.
				// 
				if( 1 == Context.ApiVersionMajor )
				{
					foreach( Name name in Names )
					{
						name.IsoLangCode = Context.User.IsoLangCode;
					}
				}

				ChangeRecord changeRecord = new ChangeRecord();
				changeRecord.Payload = new ChangeRecordNewData( this );
				changeRecord.Log();

				//
				// Take out language names if we are using V1.
				//
				if( 1 == Context.ApiVersionMajor )
				{
					foreach( Name name in Names )
					{
						name.IsoLangCode = null;
					}
				}
			}
		}

		//
		// TODO: is this the best way to determine that this is a service project?
		//			
		private bool IsServiceProjection( string businessEntityBusinessKey )
		{
			//
			// If the business key in the service does not match the key
			// of the business entity saving it, this is a service 
			// projection.
			//
			if( !Utility.StringEmpty( BusinessKey ) 
				&& 0 != String.Compare( BusinessKey, businessEntityBusinessKey, true ) )
			{
				return true;
			}
			else
			{
				return false;
			}
		}
	}
	
	public class BusinessServiceCollection : CollectionBase
	{
		public BusinessService this[int index]
		{
			get { return (BusinessService)List[index]; }
			set { List[index] = value; }
		}
		
		internal void Validate( string businessKey )
		{
			foreach( BusinessService service in this )
			{				
				service.Validate( businessKey );
			}
		}

		public void Save( string businessKey )
		{
			//
			// Implement IN92 restriction which states:
			// "A service must not contain a service and a service projection to this service. As a result, a service 
			// cannot be moved to a BE that already has a projection to that service. Regardless of the order of operation,
			// a service and a service projection can never appear under the same business. Implementations are required to 
			// reject and return an E_fatalError during a save_business operation. Should a changeRecord be processed via 
			// the replication stream with a business containing a service and a service projection to that same service, 
			// this occurrence will result in the processing node throwing an error and halting replication."
			//

			for( int i=0; i < this.Count; i++ )
			{
				if( !Utility.StringEmpty( this[ i ].BusinessKey ) && 0 != String.Compare( this[ i ].BusinessKey, businessKey, true ) )
				{
					//
					// Current service is a service projection
					// Check all the other services to see if the same service is being saved elsewhere
					//

					for( int j=0; j < this.Count; j++ )
					{
						if( j == i )
						{
							continue;
						}
						
						if( 0 == String.Compare( this[ j ].ServiceKey, this[ i ].ServiceKey, true ) 
							&& ( !Utility.StringEmpty( this[ j ].BusinessKey ) && 0 == String.Compare( this[ j ].BusinessKey, businessKey, true ) ) )
						{
							//
							// The serviceKey of a projection has been used a second time in the body of a save
							// This second use is not a service project itself, and should therefore be rejected
							// 

							//throw new UDDIException( UDDI.ErrorType.E_fatalError, "The serviceKey associated with a service projection cannot be referenced in a subsequent serviceDetail that is not itself a service projection.  serviceKey = " + this[ i ].ServiceKey );
							throw new UDDIException( UDDI.ErrorType.E_fatalError, "UDDI_ERROR_INVALID_SERVICEKEY_FOR_PROJECTION", this[ i ].ServiceKey );
						}

					}
				}
			}
			foreach( BusinessService service in this )
			{							
				service.InnerSave( businessKey );
			}
		}

		public void Get( string businessKey )
		{
			//
			// Retrieve the core information for this business
			//
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_businessEntity_businessServices_get" );

			//
			// Add parameters and set values
			//
			cmd.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			cmd.Parameters.SetGuidFromString( "@businessKey", businessKey );

			//
			// Execute query to retreive services for this businesskey
			//
			SqlDataReaderAccessor reader = cmd.ExecuteReader();
			try
			{
				Read( reader );
#if never
				while( rdr.Read() )
				{
					//
					// Add a BusinessService object to the collection.  We'll populate it
					// with the serviceKey (column 0) and a businessKey (column 1).  The 
					// businessKey will only have a meaningful value if this BusinessService is
					// a service projection, otherwise it will be null.  We need this value now
					// because we might not be able to get any other information for this BusinessService
					// if it is a projection of a non-existant BusinessService.
					//					
					if( false == rdr.IsDBNull ( 1 ) )
					{
						Add( rdr.GetGuid( 0 ).ToString(), rdr.GetGuid( 1 ).ToString() );
					}
					else
					{
						Add( rdr.GetGuid( 0 ).ToString(), null );
					}
				}
#endif
			}
			finally
			{
				reader.Close();
			}

			Populate();

#if never
			foreach( BusinessService service in this )
			{
				//
				// Get will throw an exception if this service is a service projection for service that no longer
				// exists.  If that's the case, we'll eat the exception since we already have businessKey and serviceKey,
				// which is the only data that we need for this type of service projection.  
				//
				try
				{
					service.Get();
				}
				catch( SqlException sqlException )
				{
					//
					// If we don't have a valid businessKey for this service, then the key really was invalid, so rethrow the
					// exception.
					//
					if( null == service.BusinessKey )
					{
						throw sqlException;						
					}					
				}
			}
#endif
		}
		
		public void Read( SqlDataReaderAccessor reader )
		{
			while( reader.Read() )
			{
				//
				// Add a BusinessService object to the collection.  We'll populate it
				// with the serviceKey (column 0) and a businessKey (column 1).  The 
				// businessKey will only have a meaningful value if this BusinessService is
				// a service projection, otherwise it will be null.  We need this value now
				// because we might not be able to get any other information for this BusinessService
				// if it is a projection of a non-existant BusinessService.
				//					
				if( false == reader.IsDBNull ( 1 ) )
				{
					Add( reader.GetGuidString( 0 ), reader.GetGuidString( 1 ) );
				}
				else
				{
					Add( reader.GetGuidString( 0 ), null );
				}
			}
		}

		public void Populate()
		{
			foreach( BusinessService service in this )
			{
				//
				// Get will throw an exception if this service is a service projection for service that no longer
				// exists.  If that's the case, we'll eat the exception since we already have businessKey and serviceKey,
				// which is the only data that we need for this type of service projection.  
				//
				try
				{
					service.Get();
				}
				catch( SqlException sqlException )
				{
					//
					// If we don't have a valid businessKey for this service, then the key really was invalid, so rethrow the
					// exception.
					//
					if( null == service.BusinessKey )
					{
						throw sqlException;						
					}					
				}
			}
		}

		public int Add()
		{			
			return List.Add( new BusinessService() );
		}

		public int Add(BusinessService value)
		{
			return List.Add(value);
		}

		public int Add( string serviceKey, string businessKey )
		{
			return List.Add( new BusinessService( serviceKey, businessKey ) );
		}

		public int Add( string serviceKey )
		{
			return List.Add( new BusinessService( serviceKey ) );
		}
		
		public void Insert(int index, BusinessService value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(BusinessService value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(BusinessService value)
		{
			return List.Contains(value);
		}

		public void Remove(BusinessService value)
		{
			List.Remove(value);
		}

		public void CopyTo( BusinessService[] array )
		{
			foreach( BusinessService service in array )
				Add( service );
		}

		public BusinessService[] ToArray()
		{
			return (BusinessService[])InnerList.ToArray( typeof( BusinessService ) );
		}
		public void Sort()
		{
			InnerList.Sort( new BusinessServiceComparer() );
		}

		internal class BusinessServiceComparer : IComparer
		{
			public int Compare( object x, object y )
			{
				BusinessService entity1 = (BusinessService)x;
				BusinessService entity2 = (BusinessService)y;
				
				//
				// Service projections might not have names
				//
				if( 0 == entity1.Names.Count && 0 == entity2.Names.Count )
				{
					return 0;
				}
				else if ( 0 == entity1.Names.Count )
				{
					return -1;
				}
				else if ( 0 == entity2.Names.Count )
				{
					return 1;
				}
				else
				{
					return string.Compare( entity1.Names[ 0 ].Value, entity2.Names[ 0 ].Value, true );
				}
			}
		}
	}

	public class ServiceInfoCollection : CollectionBase
	{
		public void Get( string businessKey )
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_businessServices_get" );
			
			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.SetGuidFromString( "@businessKey", businessKey );
			
			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				Read( reader );
			}
			finally
			{
				reader.Close();
			}			

			Populate();
		
#if never
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessEntity_businessServices_get" );
			
			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.SetGuidFromString( "@businessKey", businessKey );
			
			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				while( reader.Read() )
				{
					//
					// Add a ServiceInfo object to the collection.  We'll populate it
					// with the serviceKey (column 0) and a businessKey (column 1).  The 
					// businessKey will only have a meaningful value if the BusinessService this ServiceInfo refers
					// to is a service projection, otherwise it will be null.  We need this value now
					// because we might not be able to get any other information for this BusinessService
					// if it is a projection of a non-existant BusinessService.
					//			
					Add( reader.GetGuidString( 0 ) , reader.GetGuidString( 1 ) );					
				}
			}
			finally
			{
				reader.Close();
			}			

			//
			// Get the details for each service info.
			//
			foreach( ServiceInfo serviceInfo in this )
			{
				//
				// Get will throw an exception if this service is a service projection for service that no longer
				// exists.  If that's the case, we'll eat the exception since we already have businessKey and serviceKey,
				// which is the only data that we need for this type of service projection.  
				//
				try
				{
					serviceInfo.Get();
				}
				catch( SqlException sqlException )
				{
					//
					// If we don't have a valid businessKey for this service, then the key really was invalid, so rethrow the
					// exception.
					//					
					if( null == serviceInfo.BusinessKey )
					{
						throw sqlException;						
					}					
				}
			}
#endif
		}

		public void Read( SqlDataReaderAccessor reader )
		{
			while( reader.Read() )
			{
				//
				// Add a ServiceInfo object to the collection.  We'll populate it
				// with the serviceKey (column 0) and a businessKey (column 1).  The 
				// businessKey will only have a meaningful value if the BusinessService this ServiceInfo refers
				// to is a service projection, otherwise it will be null.  We need this value now
				// because we might not be able to get any other information for this BusinessService
				// if it is a projection of a non-existant BusinessService.
				//			
				if( false == reader.IsDBNull ( 1 ) )
				{
					Add( reader.GetGuidString( 0 ), reader.GetGuidString( 1 ) );
				}
				else
				{
					Add( reader.GetGuidString( 0 ), null );
				}
			}
		}

		public void Populate()
		{
			//
			// Get the details for each service info.
			//
			foreach( ServiceInfo serviceInfo in this )
			{
				//
				// Get will throw an exception if this service is a service projection for service that no longer
				// exists.  If that's the case, we'll eat the exception since we already have businessKey and serviceKey,
				// which is the only data that we need for this type of service projection.  
				//
				try
				{
					serviceInfo.Get();
				}
				catch( SqlException sqlException )
				{
					//
					// If we don't have a valid businessKey for this service, then the key really was invalid, so rethrow the
					// exception.
					//					
					if( null == serviceInfo.BusinessKey )
					{
						throw sqlException;						
					}					
				}
			}
		}

		public ServiceInfo this[ int index ]
		{
			get { return (ServiceInfo)List[ index ]; }
			set { List[ index ] = value; }
		}
		
		public int Add()
		{
			return List.Add( new ServiceInfo() );
		}

		public int Add( string serviceKey, string businessKey )
		{
			return List.Add( new ServiceInfo( serviceKey, businessKey ) );
		}

		public int Add( ServiceInfo serviceInfo )
		{
			return List.Add( serviceInfo );
		}
		public void Insert( int index, ServiceInfo serviceInfo )
		{
			List.Insert( index, serviceInfo );
		}
		public int IndexOf( ServiceInfo serviceInfo )
		{
			return List.IndexOf( serviceInfo );
		}
		public bool Contains( ServiceInfo serviceInfo )
		{
			return List.Contains( serviceInfo );
		}
		public void Remove( ServiceInfo serviceInfo )
		{
			List.Remove( serviceInfo );
		}
		public void CopyTo( ServiceInfo[] array, int index )
		{
			List.CopyTo( array, index );
		}

		public void Sort()
		{
			InnerList.Sort( new ServiceInfoComparer() );
		}

		internal class ServiceInfoComparer : IComparer
		{
			public int Compare( object x, object y )
			{
				ServiceInfo entity1 = (ServiceInfo)x;
				ServiceInfo entity2 = (ServiceInfo)y;
				
				//
				// Service projections might not have names
				//
				if( 0 == entity1.Names.Count && 0 == entity2.Names.Count )
				{
					return 0;
				}
				else if ( 0 == entity1.Names.Count )
				{
					return -1;
				}
				else if ( 0 == entity2.Names.Count )
				{
					return 1;
				}
				else
				{
					return string.Compare( entity1.Names[ 0 ].Value, entity2.Names[ 0 ].Value, true );
				}
			}
		}
	}

	public class ServiceInfo
	{
		//
		// Attribute: serviceKey
		//
		[XmlAttribute("serviceKey")]
		public string ServiceKey;

		//
		// Attribute: businessKey
		//
		[XmlAttribute("businessKey")]
		public string BusinessKey;

		//
		// Element: name
		//
		[XmlElement("name")]
		public NameCollection Names = new NameCollection();

		public ServiceInfo()
		{
		}

		public ServiceInfo( string serviceKey, string businessKey )
		{
			ServiceKey = serviceKey;
			BusinessKey = businessKey;
		}

		public void Get()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_serviceInfo_get_batch" );
	
			sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier, ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );
			
			SqlDataReaderAccessor reader = null;
			try
			{
				//
				// net_serviceInfo_get_batch will return the objects contained in a business in the following order:
				//				
				//	- names
				reader = sp.ExecuteReader();

				//
				// Read the names
				//
				Names.Read( reader );
			}
			finally
			{
				if( null != reader )
				{
					reader.Close();
				}
			}

			//
			// Output parameters
			//
			BusinessKey = sp.Parameters.GetGuidString( "@businessKey" );
#if never
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_businessService_get" );
	
			sp.Parameters.Add( "@serviceKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@businessKey", SqlDbType.UniqueIdentifier, ParameterDirection.Output );

			sp.Parameters.SetGuidFromString( "@serviceKey", ServiceKey );

			sp.ExecuteNonQuery();

			BusinessKey = sp.Parameters.GetGuidString( "@businessKey" );

			//
			// Get all contained objects.
			//
			Names.Get( ServiceKey, EntityType.BusinessService );
#endif
		}		
	}

	/// ****************************************************************
	///   class DeleteService
	///	----------------------------------------------------------------
	///	  <summary>
	///		The DeleteService class contains data and methods associated 
	///		with the delete_service message. It is typically populated 
	///		via deserialization by the .NET runtime as part of the 
	///		message processing interface.
	///		
	///		As part of the publisher API, this message implements 
	///		IAuthenticateable. This allows the enclosed authInfo to be 
	///		authorized prior to processing
	///	  </summary>
	/// ****************************************************************
	/// 
	[XmlRootAttribute( "delete_service", Namespace=UDDI.API.Constants.Namespace )]
	public class DeleteService : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
		
		//
		// Element: serviceKey
		//
		[XmlElement("serviceKey")]
		public StringCollection ServiceKeys;

		public void Delete()
		{
			foreach( string key in ServiceKeys )
			{
				BusinessService bs = new BusinessService( key );
				bs.Delete();
			}
		}
	}

	[XmlRootAttribute("find_service", Namespace=UDDI.API.Constants.Namespace)]
	public class FindService : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Attribute: maxRows
		//
		private int maxRows = -1;

		[XmlAttribute( "maxRows" ), DefaultValue( -1 )]
		public int MaxRows
		{
			get	{ return maxRows; }
			set	
			{
				if( value < 0 )
				{
					// throw new UDDIException( ErrorType.E_fatalError, "maxRows must not be less than 0" );
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_MAXROW_CANNOT_BE_LESS_THAN_0" );
				}

				maxRows = value; 
			}
		}
		
		[XmlAttribute("businessKey")]
		public string BusinessKey;
		
		[XmlArray("findQualifiers"), XmlArrayItem("findQualifier")]
		public FindQualifierCollection FindQualifiers;

		[XmlElement("name")]
		public NameCollection Names = new NameCollection();

		[XmlArray("categoryBag"), XmlArrayItem( "keyedReference" )]
		public KeyedReferenceCollection CategoryBag;

		[XmlArray("tModelBag"), XmlArrayItem("tModelKey")]
		public StringCollection TModelBag;

		public ServiceList Find()
		{
			ServiceList	serviceList = new ServiceList();
		
			QueryLog.Write( QueryType.Find, EntityType.BusinessService );

			//
			// Validate find parameters.
			//
			if( !Utility.StringEmpty( BusinessKey ) )
				Utility.IsValidKey( EntityType.BusinessEntity, BusinessKey );

			//
			// Process each find constraint.
			//
			FindBuilder find = new FindBuilder( EntityType.BusinessService, FindQualifiers, BusinessKey );

			//
			// If no search arguments are given, search the whole thing. The arguments below are optional.
			//
			if( !Utility.CollectionEmpty( Names ) )
			{
				Names.ValidateForFind();
			}
			else
			{
#if never
				Debug.Verify( find.CaseSensitiveMatch == false && find.ExactNameMatch == false,
						 "Cannot specifiy find qualifiers on names without specifying names", ErrorType.E_unsupported );
#endif
				Debug.Verify( find.CaseSensitiveMatch == false && find.ExactNameMatch == false,
							  "UDDI_ERROR_NO_NAME_ON_FIND_QUALIFIER", 
							  ErrorType.E_unsupported );
			}

			//
			// TODO: Override may be better for these calls to KeyedReference.Validate because no parent key is used
			//
			if( !Utility.CollectionEmpty( CategoryBag ) )
				CategoryBag.Validate( "", KeyedReferenceType.CategoryBag );

			try
			{
				int rows = 1;

				//
				// First validate all the keys, this will make sure any invalid keys are 'caught' beforehand.
				//
				foreach( string tModelKey in TModelBag )
				{
					Utility.IsValidKey( EntityType.TModel, tModelKey );
				}

				//
				// Find entities with matching parent key.
				//
				if( !Utility.StringEmpty( BusinessKey ) )
					rows = find.FindByParentKey( BusinessKey );
				
				//
				// Find entities with matching category bag items.
				//
				if( rows > 0 && !Utility.CollectionEmpty( CategoryBag ) )
					rows = find.FindByKeyedReferences( KeyedReferenceType.CategoryBag, CategoryBag );

				//
				// Find entities with matching TModel bag items.
				//
				if( rows > 0 && !Utility.CollectionEmpty( TModelBag ) )
					rows = find.FindByTModelBag( TModelBag );
				
				//
				// Find entities with matching names
				//
				if( rows > 0 && !Utility.CollectionEmpty( Names ) )
					rows = find.FindByNames( Names );

				//
				// Process the find result set.
				//
				if( 0 == rows )
				{
					//
					// Cleanup any temporary tables.
					//
					find.Abort();
				}
				else if( 0 == MaxRows )
				{
					serviceList.Truncated = Truncated.True;
					return serviceList;
				}
				else
				{
					//
					// Read in the find results.
					//
					SqlDataReaderAccessor reader;
					SqlStoredProcedureAccessor sp;
					sp = find.RetrieveResults( MaxRows );

					reader = sp.ExecuteReader();
				
					try
					{
						while( reader.Read() )
						{
							serviceList.ServiceInfos.Add(
								reader.GetGuidString( "entityKey" ),
								reader.GetGuidString( "parentEntityKey" ) );
						}
					}
					finally
					{
						reader.Close();
					}

					if( sp.Parameters.GetBool( "@truncated" ) )
						serviceList.Truncated = Truncated.True;
					else
						serviceList.Truncated = Truncated.False;			

					foreach( ServiceInfo serviceInfo in serviceList.ServiceInfos )
						serviceInfo.Get();
				}
			}
			catch( Exception )
			{
				find.Abort();
				throw;
			}

			return serviceList;
		}
	}

	/// ********************************************************************
	///   public class GetServiceDetail
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute( "get_serviceDetail", Namespace=UDDI.API.Constants.Namespace )]
	public class GetServiceDetail : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: serviceKey
		//
		[XmlElement("serviceKey")]
		public StringCollection ServiceKeys;

		public GetServiceDetail()
		{
		}
	}

	/// ********************************************************************
	///   public class SaveService
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute( "save_service", Namespace=UDDI.API.Constants.Namespace )]
	public class SaveService : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
		
		//
		// Element: businessService
		//
		[XmlElement("businessService")]
		public BusinessServiceCollection BusinessServices;

		/// ****************************************************************
		///   public Save
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************		
		/// 
		public void Save()
		{
			foreach( BusinessService BusinessService in BusinessServices )
				BusinessService.Save();
		}
	}

	[XmlRootAttribute("serviceDetail", Namespace=UDDI.API.Constants.Namespace)]
	public class ServiceDetail
	{
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;
		
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );
		
		[XmlAttribute("truncated")]
		public Truncated Truncated;
		
		[XmlElement("businessService")]
		public BusinessServiceCollection BusinessServices = new BusinessServiceCollection();
	
		public void Get( StringCollection serviceKeys )
		{
			foreach( string key in serviceKeys )
			{
				int n = BusinessServices.Add( key );
				BusinessServices[ n ].Get();
			}
		}
	}

	[XmlRootAttribute("serviceList", Namespace=UDDI.API.Constants.Namespace)]
	public class ServiceList
	{
		//
		// Attribute: generic
		//
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;

		//
		// Attribute: operator
		//
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );

		//
		// Attribute: truncated
		//
		[XmlAttribute("truncated")]
		public Truncated Truncated;

		//
		// Element: serviceInfos
		//
		private ServiceInfoCollection serviceInfos;

		[ XmlArray( "serviceInfos" ), XmlArrayItem( "serviceInfo" ) ]
		public ServiceInfoCollection ServiceInfos
		{
			get
			{
				if( null == serviceInfos )
					serviceInfos = new ServiceInfoCollection();

				return serviceInfos;
			}

			set { serviceInfos = value; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\common\uddicommon.cpp ===
// 
// This creates a "dummy" entry point for the DLL and helps the build system
// in figuring out the build order 
//
//	The DLL contains some common functions used across the UDDI universe,
//	along with resources (Message Tables, Strings, Version stamps etc.)
//	that are commonly used by other UDDI subsystems
//

#include <windows.h>

BOOL APIENTRY DllMain (HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\types.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Diagnostics;
using System.Xml.Serialization;
using UDDI;

namespace UDDI.API
{
	public enum XmlBoolType
	{
		[XmlEnum( "false" )]
		False = 0,

		[XmlEnum( "true" )]
		True = 1
	}
	
	public class Constants
	{
		public const string Version = "2.0";
		public const int VersionMajor = 2;
		public const int VersionMinor = 0;
		public const string Namespace = "urn:uddi-org:api_v2";
	}

	public enum ChangeRecordPayloadType
	{
		ChangeRecordNull				= 0,
		ChangeRecordNewData				= 1,
		ChangeRecordDelete				= 2,
		ChangeRecordHide				= 3,
		ChangeRecordPublisherAssertion	= 4,
		ChangeRecordDeleteAssertion		= 5,
		ChangeRecordCustodyTransfer		= 6,
		ChangeRecordAcknowledgement		= 7,
		ChangeRecordCorrection			= 8,
		ChangeRecordSetAssertions		= 9
	}

	public enum MessageType
	{
		//
		// Inquire message types
		//
		FindBinding						= 1,
		FindBusiness					= 2,
		FindService						= 3,
		FindTModel						= 4,
		GetBindingDetail				= 5,
		GetBusinessDetail				= 6,
		GetBusinessDetailExt			= 7,
		GetServiceDetail				= 8,
		GetTModelDetail					= 9,

		//
		// Publish message types
		//
		AddPublisherAssertions			= 1001,
		DeleteBinding					= 1002,
		DeleteBusiness					= 1003,
		DeletePublisherAssertions		= 1004,
		DeleteService					= 1005,
		DeleteTModel					= 1006,
		DiscardAuthToken				= 1007,
		GetAssertionStatusReport		= 1008,
		GetAuthToken					= 1009,
		GetPublisherAssertions			= 1010,
		GetRegisteredInfo				= 1011,
		SaveBinding						= 1012,
		SaveBusiness					= 1013,
		SaveService						= 1014,
		SaveTModel						= 1015,
		SetPublisherAssertions			= 1016,
		ValidateCategorization			= 1017,
		ValidateValues					= 1018,

		//
		// Replication message types
		//
		GetChangeRecords				= 2001,
		NotifyChangeRecordsAvailable	= 2002,
		DoPing							= 2003,
		GetHighWaterMarks				= 2004
	}

	//
	// TODO: This does not appear to be used remove it
	//
	public enum TaxonomyType
	{
		Business		= 0,
		Product			= 1,
		Geography		= 2
	}

	/// ********************************************************************
	///   public IAuthenticateable [interface]
	/// --------------------------------------------------------------------
	///   <summary>
	///     Common interface for all publication API's that require 
	///     authentication.
	///   </summary>
	/// ********************************************************************
	/// 
	public interface IAuthenticateable
	{
		string AuthInfo { get; }
	}

	/// ********************************************************************
	///   public IMessage [interface]
	/// --------------------------------------------------------------------
	///   <summary>
	///     Common interface for all messages.
	///   </summary>
	/// ********************************************************************
	/// 
	public interface IMessage
	{
		string Generic { get; }
	}

	/// ********************************************************************
	///   public class EntityBase [abstract]
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public abstract class EntityBase
	{
		public abstract UDDI.EntityType EntityType { get; }
		public abstract string EntityKey { get; }
		
		public abstract void Delete();
		public abstract void Get();
		public abstract void Save();
	}
	
	public enum KeyType
	{
		[XmlEnum( "" )]
		Uninitialized,
		[XmlEnum( "businessKey" )]
		BusinessKey,
		[XmlEnum( "tModelKey" )]
		TModelKey,
		[XmlEnum( "serviceKey" )]
		ServiceKey,
		[XmlEnum( "bindingKey" )]
		BindingKey,
	}

	public enum Truncated
	{
		[XmlEnum( "false" )]
		False	= 0,
		[XmlEnum( "true" )]
		True	= 1,
	}

	public enum URLType
	{
		[XmlEnum( "mailto" )]
		Mailto	= 0,
		[XmlEnum( "http" )]
		Http	= 1,
		[XmlEnum( "https" )]
		Https	= 2,
		[XmlEnum( "ftp" )]
		Ftp		= 3,
		[XmlEnum( "fax" )]
		Fax		= 4,
		[XmlEnum( "phone" )]
		Phone	= 5,
		[XmlEnum( "other" )]
		Other	= 6,
	}		

	public enum CompletionStatusType
	{
		[XmlEnum( "" )]
		Uninitialized		= 0,
		[XmlEnum( "status:fromKey_incomplete" )]
		FromKeyIncomplete	= 1,
		[XmlEnum( "status:toKey_incomplete" )]
		ToKeyIncomplete		= 2,
		[XmlEnum( "status:complete" )]
		Complete			= 3,
	}

	public class ErrInfo
	{
		[XmlAttribute("errCode")]
		public string ErrCode = "";

		[XmlText()]
		public string Value = "";

	}

	public class Result
	{
		public Result()
		{
			Errno = (int) ErrorType.E_success;
			ErrInfo.ErrCode = "";
			ErrInfo.Value = "";
		}

		public Result( ErrorType err, string description )
		{
			Errno = (int) err;
			ErrInfo.ErrCode = err.ToString();
			ErrInfo.Value = description;
		}

		[XmlIgnore]
		public KeyType KeyType;

		[XmlAttribute("keyType")]
		public string KeyTypeSerialized
		{
			get
			{ 
				if( KeyType.Uninitialized == KeyType )
					return null;
				else
					return KeyType.ToString();
			}
			set
			{
				KeyType = (KeyType) KeyType.Parse( KeyType.GetType(), value );
			}
		}

		[XmlAttribute("errno")]
		public int Errno = (int) ErrorType.E_success;

		[XmlElement("errInfo")]
		public ErrInfo ErrInfo = new ErrInfo();
	}

	//
	// TODO: Move this class into find.cs
	//
	public class FindQualifier
	{	
		[XmlText()]
		public string Value;

		public FindQualifier()
		{
		}

		public FindQualifier( string findQualifierValue )
		{
			Value = findQualifierValue;
		}
	}

	public class FindQualifierCollection : CollectionBase
	{
		public FindQualifierCollection()
		{
		}

		public FindQualifier this[int index]
		{
			get { return (FindQualifier)List[index]; }
			set { List[index] = value; }
		}
		public int Add()
		{
			return List.Add( new FindQualifier() );
		}
		public int Add( string value)
		{
			return List.Add( new FindQualifier(value) );
		}
		public int Add( FindQualifier value )
		{
			return List.Add( value );
		}
		public void Insert(int index, FindQualifier value)
		{
			List.Insert(index, value);
		}
		public int IndexOf(FindQualifier value)
		{
			return List.IndexOf(value);
		}
		public bool Contains(FindQualifier value)
		{
			return List.Contains(value);
		}
		public void Remove(FindQualifier value)
		{
			List.Remove(value);
		}
		public void CopyTo(FindQualifier[] array, int index)
		{
			InnerList.CopyTo(array, index);
		}
	}

	public class ResultCollection : CollectionBase
	{
		public Result this[int index]
		{
			get { return (Result)List[index]; }
			set { List[index] = value; }
		}
		
		public int Add()
		{
			return List.Add( new Result() );
		}

		public int Add(Result value)
		{
			return List.Add(value);
		}

		public int Add( ErrorType err, string description )
		{
			return List.Add( new Result( err, description ) );
		}
		
		public void Insert(int index, Result value)
		{
			List.Insert(index, value);
		}
		
		public int IndexOf(Result value)
		{
			return List.IndexOf(value);
		}
		
		public bool Contains(Result value)
		{
			return List.Contains(value);
		}
		
		public void Remove(Result value)
		{
			List.Remove(value);
		}
		
		public void CopyTo(Result[] array, int index)
		{
			List.CopyTo(array, index);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\common\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by uddicommon.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\api\tmodel.cs ===
using System;
using System.Data;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI.API;
using UDDI.Replication;
using UDDI;
using UDDI.Diagnostics;

namespace UDDI.API.ServiceType
{
	[XmlRootAttribute("tModel", Namespace=UDDI.API.Constants.Namespace)]
	public class TModel : EntityBase
	{
		//
		// Attribute: tModelKey
		//
		[XmlAttribute("tModelKey")]
		public string TModelKey = "";

		//
		// Attribute: operator
		//
		[XmlAttribute("operator")]
		public string Operator;
		
		//
		// Attribute: authorizedName
		//
		[XmlAttribute("authorizedName")]
		public string AuthorizedName;
		
		//
		// Attribute: name
		//
		[XmlElement("name")]
		public string Name;

		//
		// Element: description
		//
		private DescriptionCollection descriptions;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		//
		// Element: overviewDoc
		//		
		private OverviewDoc overviewDoc;

		[XmlElement("overviewDoc")]
		public OverviewDoc OverviewDocSerialize
		{
			get
			{
				if( null != overviewDoc && overviewDoc.ShouldSerialize )
					return overviewDoc;
				
				return null;
			}
			
			set { overviewDoc = value; }
		}
		
		[XmlIgnore]
		public OverviewDoc OverviewDoc
		{
			get
			{
				if( null == overviewDoc )
					overviewDoc = new OverviewDoc();

				return overviewDoc;
			}
		}

		//
		// Element: identifierBag
		//
		[ XmlIgnore ]
		public KeyedReferenceCollection IdentifierBag = new KeyedReferenceCollection();
		
		[ XmlArray( "identifierBag" ), XmlArrayItem( "keyedReference" ) ]
		public KeyedReference[] IdentifierBagSerialize
		{
			get
			{
				if( Utility.CollectionEmpty( IdentifierBag ) )
					return null;

				return IdentifierBag.ToArray();
			}

			set 
			{ 
				IdentifierBag.Clear();
				IdentifierBag.CopyTo( value );
			}
		}

		//
		// Element: categoryBag
		//
		[ XmlIgnore ]
		public KeyedReferenceCollection CategoryBag = new KeyedReferenceCollection();

		[ XmlArray( "categoryBag" ), XmlArrayItem( "keyedReference" ) ]
		public KeyedReference[] CategoryBagSerialize
		{
			get
			{
				if( Utility.CollectionEmpty( CategoryBag ) )
					return null;

				return CategoryBag.ToArray();
			}

			set 
			{ 
				CategoryBag.Clear();
				CategoryBag.CopyTo( value );
			}
		}

		[XmlIgnore]
		public override UDDI.EntityType EntityType
		{
			get { return EntityType.TModel; }
		}
		
		[XmlIgnore]
		public override string EntityKey
		{
			get { return TModelKey; }
		}

		public TModel()
		{
		}

		public TModel( string tModelKey )
		{
			TModelKey = tModelKey;
		}

		public override void Get()
		{
			//
			// Create a command object to invoke the stored procedure
			//
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_tModel_get_batch" );
			
			//
			// Add parameters
			//
			cmd.Parameters.Add( "@tModelKey",		SqlDbType.UniqueIdentifier, ParameterDirection.Input );
			cmd.Parameters.Add( "@operatorName",	SqlDbType.NVarChar, UDDI.Constants.Lengths.OperatorName,	ParameterDirection.Output );
			cmd.Parameters.Add( "@authorizedName",	SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName,	ParameterDirection.Output );
			cmd.Parameters.Add( "@name",			SqlDbType.NVarChar, UDDI.Constants.Lengths.Name,			ParameterDirection.Output );
			cmd.Parameters.Add( "@overviewURL",		SqlDbType.NVarChar, UDDI.Constants.Lengths.OverviewURL,		ParameterDirection.Output );

			cmd.Parameters.SetGuidFromKey( "@tModelKey", TModelKey );

			SqlDataReaderAccessor reader = null;
			try
			{
				//
				// net_tModel_get will return the objects contained in a business in the following order:
				//
				//	- descriptions
				//	- overview descriptions
				//  - identifier bags
				//  - category bags				
				//
				reader = cmd.ExecuteReader();

				//
				// Read the descriptions
				//
				Descriptions.Read( reader );									

				//
				// Read the overview descriptions
				//
				if( true == reader.NextResult() )
				{
					OverviewDoc.Descriptions.Read( reader );					
				}

				//
				// Read the identifier bags
				//
				if( true == reader.NextResult() )
				{
					IdentifierBag.Read( reader );					
				}

				//
				// Read the category bags
				//
				if( true == reader.NextResult() )
				{
					CategoryBag.Read( reader );					
				}
			}
			finally
			{
				if( null != reader )
				{
					reader.Close();
				}
			}

			//
			// Output parameters
			//
			Operator				= cmd.Parameters.GetString( "@operatorName" );
			AuthorizedName			= cmd.Parameters.GetString( "@authorizedName" );
			Name					= cmd.Parameters.GetString( "@name" );
			OverviewDoc.OverviewURL = cmd.Parameters.GetString( "@overviewURL" );
#if never
			//
			// Create a command object to invoke the stored procedure
			//
			SqlCommand cmd = new SqlCommand( "net_tModel_get", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();			
			cmd.CommandType = CommandType.StoredProcedure;

			//
			// Add parameters
			//
			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@operatorName", SqlDbType.NVarChar, UDDI.Constants.Lengths.OperatorName ) ).Direction = ParameterDirection.Output;
			cmd.Parameters.Add( new SqlParameter( "@authorizedName", SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName ) ).Direction = ParameterDirection.Output;
			cmd.Parameters.Add( new SqlParameter( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name ) ).Direction = ParameterDirection.Output;
			cmd.Parameters.Add( new SqlParameter( "@overviewURL", SqlDbType.NVarChar, UDDI.Constants.Lengths.OverviewURL ) ).Direction = ParameterDirection.Output;

			//
			// Set parameter values and execute query
			//
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
			paramacc.SetGuidFromKey( "@tModelKey", TModelKey );

			cmd.ExecuteScalar();    

			//
			// Move query results into member variables
			//
			Operator = paramacc.GetString( "@operatorName" );
			AuthorizedName = paramacc.GetString( "@authorizedName" );
			Name = paramacc.GetString( "@name" );
			OverviewDoc.OverviewURL = paramacc.GetString( "@overviewURL" );

			//
			// Retrieve sub-objects
			//
			Descriptions.Get( TModelKey, EntityType.TModel );
			OverviewDoc.Descriptions.Get( TModelKey, EntityType.TModelOverviewDoc );
			IdentifierBag.Get( TModelKey, EntityType.TModel, KeyedReferenceType.IdentifierBag );
			CategoryBag.Get( TModelKey, EntityType.TModel, KeyedReferenceType.CategoryBag );
#endif

			QueryLog.Write( QueryType.Get, EntityType.TModel );
		}

		internal void Validate()
		{
			//
			// Check to make sure publisher's limit allows save of this
			// entity.  If this is an update, we won't check since they
			// are simply replacing an existing entity.  We also won't
			// check if the limit is 0, since this indicates unlimited
			// publishing rights.
			//
			int limit = Context.User.TModelLimit;
			int count = Context.User.TModelCount;

			if( 0 != limit && Utility.StringEmpty( TModelKey ) )
			{				
				//
				// Verify that the publisher has not exceeded their limit.
				//
				if( count >= limit )
				{
#if never
					throw new UDDIException( 
						ErrorType.E_accountLimitExceeded,
						"Publisher limit for 'tModel' exceeded (limit=" + limit + ", count=" + count + ")" );
#endif
					throw new UDDIException( ErrorType.E_accountLimitExceeded, "UDDI_ERROR_PUBLISHER_LIMIT_FOR_TMODELS_EXCEEDED", limit, count );						
				}
			}

			//
			// Check field lengths and truncate if necessary.
			//
			Utility.ValidateLength( ref Name, "name", UDDI.Constants.Lengths.Name, 1 );
			Utility.ValidateLength( ref AuthorizedName, "authorizedName", UDDI.Constants.Lengths.AuthorizedName );
			Utility.ValidateLength( ref Operator, "operator", UDDI.Constants.Lengths.Operator );

			//
			// SECURITY: The operator field should be validated to ensure it is
			// the local operator name or empty. This is not currently being done.
			//

			//
			// If no tModelKey is specified, then it is an add and no
			// database validation is necessary here.  Otherwise, we do
			// need to validate that the specified tModel exists and 
			// is owned by the user.
			//
			if( !Utility.StringEmpty( TModelKey ) )
			{
				//
				// call net_tModel_validate
				//
				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_tModel_validate" );
				
				sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
				sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
				sp.Parameters.Add( "@flag", SqlDbType.Int );
			
				sp.Parameters.SetString( "@PUID", Context.User.ID );
				sp.Parameters.SetGuidFromKey( "@tModelKey", TModelKey );
				if( Context.User.AllowPreassignedKeys )
					sp.Parameters.SetInt( "@flag", 1 );
				else
					sp.Parameters.SetInt( "@flag", 0 );

				sp.ExecuteNonQuery();
			}

			Descriptions.Validate();
			IdentifierBag.Validate( TModelKey, KeyedReferenceType.IdentifierBag );
			CategoryBag.Validate( TModelKey, KeyedReferenceType.CategoryBag );
			OverviewDoc.Validate();
		}
		
		public override void Save()
		{
			Debug.Enter();

			//
			// If we're not in replication mode, we'll set the operator 
			// name (ignoring whatever was specified). 
			//
			if( ContextType.Replication != Context.ContextType )
				Operator = Config.GetString( "Operator" );

			//
			// Validate the tModel
			//
			Validate();
			
			if( Utility.StringEmpty( TModelKey ) )
			{
				//
				// This is an insert, so generate a tmodelkey
				//
				TModelKey = "uuid:" + System.Guid.NewGuid().ToString();
			}

			//
			// Create a command object to invoke the stored procedure
			//
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_tModel_save" );

			//
			// Add parameters
			//
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@generic", SqlDbType.NVarChar, UDDI.Constants.Lengths.generic );
			sp.Parameters.Add( "@authorizedName", SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName, ParameterDirection.InputOutput );
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );
			sp.Parameters.Add( "@overviewURL", SqlDbType.NVarChar, UDDI.Constants.Lengths.OverviewURL );

			//
			// Set parameter values
			//
			sp.Parameters.SetGuid( "@contextID", Context.ContextID );			
			sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );
			sp.Parameters.SetGuidFromKey( "@tModelKey", TModelKey );
			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetString( "@generic", Constants.Version );
			sp.Parameters.SetString( "@authorizedName", AuthorizedName );
			sp.Parameters.SetString( "@name", Name );
			
			if( null == (object)OverviewDoc )
				sp.Parameters.SetNull( "@overviewUrl" );
			else
				sp.Parameters.SetString( "@overviewUrl", OverviewDoc.OverviewURL );

			//
			// Execute query
			//
			sp.ExecuteNonQuery();

			AuthorizedName = sp.Parameters.GetString( "@authorizedName" );

			//
			// Save the descriptions, category, identifier and overview doc 
			// information
			//
			Descriptions.Save( TModelKey, EntityType.TModel );
			IdentifierBag.Save( TModelKey, EntityType.TModel, KeyedReferenceType.IdentifierBag );
			CategoryBag.Save( TModelKey, EntityType.TModel, KeyedReferenceType.CategoryBag );
			OverviewDoc.Descriptions.Save( TModelKey, EntityType.TModelOverviewDoc );
			
			//
			// Save the change log entry.
			//
			if( Context.LogChangeRecords )
			{
				ChangeRecord changeRecord = new ChangeRecord();

				changeRecord.Payload = new ChangeRecordNewData( this );
				changeRecord.Log();
			}

			Debug.Leave();
		}

		public void Hide()
		{
			//
			// TODO: We should really have a way of hiding vs. deleting
			//
			Delete();
		}

		public override void Delete()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_tModel_delete" );
			
			sp.Parameters.Add( "@contextID", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@lastChange", SqlDbType.BigInt );
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );

			sp.Parameters.SetGuid( "@contextID", Context.ContextID );
			sp.Parameters.SetLong( "@lastChange", DateTime.UtcNow.Ticks );
			sp.Parameters.SetString( "@PUID", Context.User.ID );
			sp.Parameters.SetGuidFromKey( "@tModelKey", TModelKey );
			
			sp.ExecuteNonQuery();

			//
			// Save the change log entry.
			//
			if( Context.LogChangeRecords )
			{
				ChangeRecord changeRecord = new ChangeRecord();

				changeRecord.AcknowledgementRequested = true;
				changeRecord.Payload = new ChangeRecordHide( TModelKey );
				changeRecord.Log();
			}
		}
	}
	public class TModelCollection : CollectionBase
	{
		public TModelCollection()
		{
		}

		public TModel this[int index]
		{
			get { return (TModel)List[index]; }
			set { List[index] = value; }
		}

		public int Add(TModel value)
		{
			return List.Add(value);
		}

		public int Add( string tModelKey )
		{
			return List.Add( new TModel( tModelKey ) );
		}

		public int Add()
		{
			return List.Add( new TModel() );
		}

		public void Insert(int index, TModel value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(TModel value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(TModel value)
		{
			return List.Contains(value);
		}

		public void Remove(TModel value)
		{
			List.Remove(value);
		}

		public void CopyTo(TModel[] array, int index)
		{
			InnerList.CopyTo(array, index);
		}

		public void Save()
		{
			//
			// Walk tModels collection and save each tModel
			//
			foreach( TModel tm in this )
			{
				tm.Save();
			}
		}
		public void Sort()
		{
			InnerList.Sort( new TModelComparer() );
		}

		internal class TModelComparer : IComparer
		{
			public int Compare( object x, object y )
			{
				TModel entity1 = (TModel)x;
				TModel entity2 = (TModel)y;

				return string.Compare( entity1.Name, entity2.Name, true );
			}
		}
	}

	public class TModelInfoCollection : CollectionBase
	{
		public void GetForCurrentPublisher()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor();

			sp.ProcedureName = "net_publisher_tModelInfos_get";
			
			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.SetString( "@PUID", Context.User.ID );
			
			SqlDataReaderAccessor reader = sp.ExecuteReader();

			try
			{
				while( reader.Read() )
				{
					TModelInfo info = new TModelInfo( 
						reader.GetKeyFromGuid( "tModelKey" ), 
						reader.GetString( "name" ) );

					info.IsHidden = ( 1 == reader.GetInt( "flag" ) ); 					
					this.Add( info );
				}
			}
			finally
			{
				reader.Close();
			}
		}

		public TModelInfo this[int index]
		{
			get { return (TModelInfo)List[index]; }
			set { List[index] = value; }
		}

		public int Add()
		{
			return List.Add( new TModelInfo() );
		}

		public int Add( string tModelKey )
		{
			return List.Add( new TModelInfo( tModelKey ) );
		}

		public int Add( string tModelKey, string name )
		{
			return List.Add( new TModelInfo( tModelKey, name ) );
		}

		public int Add(TModelInfo value)
		{
			return List.Add(value);
		}

		public void Insert(int index, TModelInfo value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(TModelInfo value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(TModelInfo value)
		{
			return List.Contains(value);
		}

		public void Remove(TModelInfo value)
		{
			List.Remove(value);
		}

		public void CopyTo(TModelInfo[] array, int index)
		{
			List.CopyTo(array, index);
		}

		public void Sort()
		{
			InnerList.Sort( new TModelInfoComparer() );
		}

		internal class TModelInfoComparer : IComparer
		{
			public int Compare( object x, object y )
			{
				TModelInfo entity1 = (TModelInfo)x;
				TModelInfo entity2 = (TModelInfo)y;

				return string.Compare( entity1.Name, entity2.Name, true );
			}
		}
	}

	public class TModelInstanceInfoCollection : CollectionBase
	{
		internal void Validate()
		{
			foreach( TModelInstanceInfo info in this )
			{
				info.Validate();
			}
		}

		public void Save( string bindingKey )
		{
			foreach( TModelInstanceInfo tmii in this )
			{
				tmii.Save( bindingKey );
			}
		}

		public void Get( string bindingKey )
		{
			ArrayList instanceIds = new ArrayList();

			//
			// Create a command object to invoke the stored procedure
			//
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_bindingTemplate_tModelInstanceInfos_get" );
			
			//
			// Parameters
			//
			cmd.Parameters.Add( "@bindingKey", SqlDbType.UniqueIdentifier, ParameterDirection.Input );

			//
			// Set parameter values and execute query
			//			
			cmd.Parameters.SetGuidFromString( "@bindingKey", bindingKey );

			SqlDataReaderAccessor reader = cmd.ExecuteReader();			

			try
			{
				instanceIds = Read( reader );
#if never
				//
				// The core data for this binding will be contained in the resultset
				//
				while( reader.Read() )
				{
					instanceIds.Add( rdracc.GetInt( instanceIdIndex ) );

					Add( rdracc.GetKeyFromGuid( tModelKeyIndex ),
						rdracc.GetString( overviewURLIndex ),
						rdracc.GetString( instanceParmIndex ) );
				}
#endif
			}
			finally
			{
				reader.Close();
			}

			Populate( instanceIds );			
		}

		public ArrayList Read( SqlDataReaderAccessor reader )
		{
			const int instanceIdIndex   = 0;
			const int tModelKeyIndex    = 1;
			const int overviewURLIndex  = 2;
			const int instanceParmIndex = 3;

			ArrayList instanceIds = new ArrayList();

			//
			// The core data for this binding will be contained in the resultset
			//
			while( reader.Read() )
			{	
				instanceIds.Add( reader.GetInt( instanceIdIndex ) );

				Add( reader.GetKeyFromGuid( tModelKeyIndex ),
					 reader.GetString( overviewURLIndex ),
					 reader.GetString( instanceParmIndex ) );				
			}

			return instanceIds;
		}

		public void Populate( ArrayList instanceIds )
		{
			int i = 0;
			foreach( TModelInstanceInfo tmii in this )
			{
				tmii.Get( (int) instanceIds[ i++ ] );
			}
		}

		public TModelInstanceInfo this[int index]
		{
			get 
			{ return (TModelInstanceInfo)List[index]; }
			set 
			{ List[index] = value; }
		}

		public int Add()
		{
			return List.Add( new TModelInstanceInfo() );
		}

		public int Add(TModelInstanceInfo value)
		{
			return List.Add(value);
		}
		public int Add(  string tModelKey, string overviewURL, string instanceParm )
		{
			return List.Add( new TModelInstanceInfo( tModelKey, overviewURL, instanceParm ) );
		}

		public void Insert(int index, TModelInstanceInfo value)
		{
			List.Insert(index, value);
		}

		public int IndexOf(TModelInstanceInfo value)
		{
			return List.IndexOf(value);
		}

		public bool Contains(TModelInstanceInfo value)
		{
			return List.Contains(value);
		}

		public void Remove(TModelInstanceInfo value)
		{
			List.Remove(value);
		}

		public void CopyTo(TModelInstanceInfo[] array, int index)
		{
			List.CopyTo(array, index);
		}
	}

	public class TModelBag
	{
		[XmlElement("tModelKey")]
		public StringCollection tmodelkeys;
	
		[XmlIgnore]
		public StringCollection TModelKeys
		{
			get
			{
				if( null == tmodelkeys )
					tmodelkeys = new StringCollection();

				return tmodelkeys;
			}
		}
	}

	public class TModelInstanceInfo
	{
		// ----[Attribute: tModelKey]---------------------------------------
		
		[XmlAttribute("tModelKey")]
		public string TModelKey
		{
			get
			{
				return tmodelkey;
			}
			
			set
			{
				if( null == value )
					tmodelkey = null;
				else
					tmodelkey = value.Trim();
			}
		}
		private string tmodelkey;

		// ----[Element: description]---------------------------------------

		private DescriptionCollection descriptions;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		// ----[Element: instanceDetails]-----------------------------------
		
		private InstanceDetail instanceDetail;
		
		[XmlElement("instanceDetails")]
		public InstanceDetail InstanceDetailSerialize
		{
			get
			{
				if( null != instanceDetail && instanceDetail.ShouldSerialize )
					return instanceDetail;

				return null;
			}

			set { instanceDetail = value; }
		}

		[XmlIgnore]
		public InstanceDetail InstanceDetail
		{
			get
			{
				if( null == instanceDetail )
					instanceDetail = new InstanceDetail();

				return instanceDetail;
			}
		}

		public TModelInstanceInfo()
		{
		}
		
		public TModelInstanceInfo( string tModelKey, string overviewURL, string instanceParm )
		{
			TModelKey = tModelKey.Trim();
			InstanceDetail.OverviewDoc.OverviewURL = overviewURL;
			InstanceDetail.InstanceParm = instanceParm;
		}

		public void Get( int instanceId )
		{
			//
			// Create a command object to invoke the stored procedure
			//
			SqlStoredProcedureAccessor cmd = new SqlStoredProcedureAccessor( "net_bindingTemplate_tModelInstanceInfo_get_batch" );
			
			//
			// Add parameters
			//
			cmd.Parameters.Add( "@instanceID", SqlDbType.BigInt, ParameterDirection.Input );
			cmd.Parameters.SetLong( "@instanceID", instanceId );
			
			SqlDataReaderAccessor reader = null;
			try
			{
				//
				// net_bindingTemplate_tModelInstanceInfo_get_batch will return the objects contained in a business in the following order:
				//
				//	- descriptions
				//	- instance detail descriptions
				//	- instance detail overview descriptions 
				reader = cmd.ExecuteReader();

				//
				// Read the descriptions
				//
				Descriptions.Read( reader );

				//
				// Read the instance detail descriptions
				//
				if ( true == reader.NextResult() )
				{
					InstanceDetail.Descriptions.Read( reader );
				}	

				//
				// Read the overview document descriptions
				//
				if ( true == reader.NextResult() )
				{
					InstanceDetail.OverviewDoc.Descriptions.Read( reader );
				}
			}
			finally
			{
				if( null != reader )
				{
					reader.Close();
				}
			}
#if never
			//
			// Get sub-objects, current level stuff is already populated
			//
			Descriptions.Get( instanceId, EntityType.TModelInstanceInfo );
			InstanceDetail.Descriptions.Get( instanceId, EntityType.InstanceDetail );
			InstanceDetail.OverviewDoc.Descriptions.Get( instanceId, EntityType.InstanceDetailOverviewDoc );
#endif
		}

		internal void Validate()
		{
			Debug.Enter();
			Debug.VerifyKey( TModelKey );

			//
			// Validate that the current TModelKey is valid
			// Replication shouldn't get in here
			//
			SqlCommand cmd = new SqlCommand( "net_bindingTemplate_tModelInstanceInfo_validate", ConnectionManager.GetConnection() );
				
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;			
				
			cmd.Parameters.Add( new SqlParameter( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
			paramacc.SetString( "@PUID", Context.User.ID );
			paramacc.SetGuidFromKey( "@tModelKey", TModelKey );
			cmd.ExecuteNonQuery();

			Descriptions.Validate();
			InstanceDetail.Validate();
			Debug.Leave();
		}
		
		public void Save( string bindingKey )
		{
			//
			// Create a command object to invoke the stored procedure
			//
			SqlCommand cmd = new SqlCommand( "net_bindingTemplate_tModelInstanceInfo_save", ConnectionManager.GetConnection() );
			
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;
			
			//
			// Input parameters
			//
			cmd.Parameters.Add( new SqlParameter( "@bindingKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@tModelKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@overviewUrl", SqlDbType.NVarChar, UDDI.Constants.Lengths.OverviewURL ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@instanceParms", SqlDbType.NVarChar, UDDI.Constants.Lengths.InstanceParms ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@instanceID", SqlDbType.BigInt ) ).Direction = ParameterDirection.Output;

			//
			// Set parameter values and execute query
			//
			SqlParameterAccessor paramacc = new SqlParameterAccessor( cmd.Parameters );
			
			paramacc.SetGuidFromString( "@bindingKey", bindingKey );
			paramacc.SetGuidFromKey( "@tModelKey", TModelKey );

			//
			// TODO: I think OverviewDoc will always be non-null... we should be
			// testing for a non empty overviewURL
			// Agreed there a bunch of these laying around. 
			//
			if( null == (object) InstanceDetail.OverviewDoc )
				paramacc.SetNull( "@overviewUrl" );
			else
				paramacc.SetString( "@overviewUrl", InstanceDetail.OverviewDoc.OverviewURL );

			// TODO: same here

			if( null != (object) InstanceDetail )
				paramacc.SetString( "@instanceParms", InstanceDetail.InstanceParm );
			else
				paramacc.SetNull( "@instanceParms" );

			cmd.ExecuteScalar();

			//
			// Move out parameters into local variables
			//
			long InstanceID = paramacc.GetLong( "@instanceID" );

			//
			// Save sub-objects
			//
			Descriptions.Save( InstanceID, EntityType.TModelInstanceInfo );

			if( null != (object) InstanceDetail )
			{
				InstanceDetail.Descriptions.Save( InstanceID, EntityType.InstanceDetail );
				if( null != (object) InstanceDetail.OverviewDoc )
				{
					InstanceDetail.OverviewDoc.Descriptions.Save( InstanceID, EntityType.InstanceDetailOverviewDoc );
				}
			}
		}
	}

	public class TModelInfo
	{
		[XmlAttribute("tModelKey")]
		public string TModelKey
		{
			get
			{
				return tmodelkey;
			}
			set
			{
				if( null == value )
					tmodelkey = null;
				else
					tmodelkey = value.Trim();
			}
		}
		private string tmodelkey = "";

		[XmlElement("name")]
		public string Name = "";

		[XmlIgnore]
		public bool IsHidden = false;

		public TModelInfo()
		{
		}

		public TModelInfo( string tModelKey )
		{
			TModelKey = tModelKey;
		}

		public TModelInfo( string tModelKey, string name )
		{
			TModelKey = tModelKey;
			Name = name;
		}

		public void Get()
		{
			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_tModel_get" );

			sp.Parameters.Add( "@tModelKey", SqlDbType.UniqueIdentifier );
			sp.Parameters.Add( "@operatorName", SqlDbType.NVarChar, UDDI.Constants.Lengths.OperatorName, ParameterDirection.Output );
			sp.Parameters.Add( "@authorizedName", SqlDbType.NVarChar, UDDI.Constants.Lengths.AuthorizedName, ParameterDirection.Output );
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name, ParameterDirection.Output );
			sp.Parameters.Add( "@overviewURL", SqlDbType.NVarChar, UDDI.Constants.Lengths.OverviewURL, ParameterDirection.Output );

			sp.Parameters.SetGuidFromKey( "@tModelKey", TModelKey );

			sp.ExecuteNonQuery();

			Name = sp.Parameters.GetString( "@name" );
		}
	}

	public class InstanceDetail
	{
		// ----[Element: description]---------------------------------------

		private DescriptionCollection descriptions;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		// ----[Element: overviewDoc]---------------------------------------
		
		private OverviewDoc overviewDoc;
		
		[XmlElement("overviewDoc")]
		public OverviewDoc OverviewDocSerialize
		{
			get
			{
				if( null != overviewDoc && overviewDoc.ShouldSerialize )
					return overviewDoc;

				return null;
			}

			set { overviewDoc = value; }
		}

		[XmlIgnore]
		public OverviewDoc OverviewDoc
		{
			get
			{
				if( null == overviewDoc )
					overviewDoc = new OverviewDoc();

				return overviewDoc;
			}
		}

		// ----[Element: instanceParms]-------------------------------------
		
		private string instanceParm;
		
		[XmlElement("instanceParms")]
		public string InstanceParm
		{
			get { return instanceParm; }
			set { instanceParm = value; }
		}

		public InstanceDetail()
		{
		}

		internal void Validate()
		{
			//
			// Check field lengths and truncate if necessary.
			//
			Utility.ValidateLength( ref instanceParm, "instanceParms", UDDI.Constants.Lengths.InstanceParms );

			Descriptions.Validate();
			OverviewDoc.Validate();			
		}

		[XmlIgnore]		
		public bool ShouldSerialize
		{
			get
			{
				if( null != descriptions && descriptions.Count > 0 )
					return true;

				if( null != overviewDoc && overviewDoc.ShouldSerialize )
					return true;

				if( null != InstanceParm )
					return true;

				return false;
			}
		}
	}

	public class OverviewDoc
	{
		// --[element: description]-----------------------------------------

		private DescriptionCollection descriptions;
		
		[XmlElement("description")]
		public DescriptionCollection Descriptions
		{
			get
			{
				if( null == descriptions )
					descriptions = new DescriptionCollection();

				return descriptions;
			}

			set { descriptions = value; }
		}

		// --[element: overviewURL]-----------------------------------------
		
		private string overviewURL;
		
		[XmlElement("overviewURL")]
		public string OverviewURL
		{
			get { return overviewURL; }
			set { overviewURL = value; }
		}

		public OverviewDoc()
		{
		}

		[XmlIgnore]
		public bool ShouldSerialize
		{
			get
			{
				if( ( null != descriptions && descriptions.Count > 0 ) 
					|| null != OverviewURL )
						return true;

				return false;
			}
		}

		internal void Validate()
		{
			Utility.ValidateLength( ref overviewURL, "overviewURL", UDDI.Constants.Lengths.OverviewURL );

			Descriptions.Validate();
		}
	}

	/// ****************************************************************
	///   class DeleteTModel
	///	----------------------------------------------------------------
	///	  <summary>
	///		The DeleteTModel class contains data and methods associated 
	///		with the delete_tModel message. It is typically populated 
	///		via deserialization by the .NET runtime as part of the 
	///		message processing interface.
	///		
	///		As part of the publisher API, this message implements 
	///		IAuthenticateable. This allows the enclosed authInfo to be 
	///		authorized prior to processing
	///	  </summary>
	/// ****************************************************************
	/// 
	[XmlRootAttribute( "delete_tModel", Namespace=UDDI.API.Constants.Namespace )]
	public class DeleteTModel : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}
		
		//
		// Element: tModelKey
		//
		[XmlElement("tModelKey")]
		public StringCollection TModelKeys;

		public void Delete()
		{
			foreach( string key in TModelKeys )
			{
				TModel tm = new TModel( key );
				tm.Delete();
			}
		}
	}

	[XmlRootAttribute("find_tModel", Namespace=UDDI.API.Constants.Namespace)]
	public class FindTModel : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}
		
		//
		// Attribute: maxRows
		//
		private int maxRows = -1;

		[XmlAttribute( "maxRows" ), DefaultValue( -1 )]
		public int MaxRows
		{
			get	{ return maxRows; }
			set	
			{
				if( value < 0 )
				{
#if never
					throw new UDDIException( 
						ErrorType.E_fatalError, 
						"maxRows must not be less than 0" );
#endif
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_MAXROW_CANNOT_BE_LESS_THAN_0" );
				}

				maxRows = value; 
			}
		}

		[XmlArray("findQualifiers"), XmlArrayItem("findQualifier")]
		public FindQualifierCollection FindQualifiers;

		[XmlElement("name")]
		public string Name;

		[XmlArray("identifierBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection IdentifierBag;

		[XmlArray("categoryBag"), XmlArrayItem("keyedReference")]
		public KeyedReferenceCollection CategoryBag;

		public FindTModel()
		{
			Generic = UDDI.API.Constants.Version;
		}

		public TModelList Find()
		{
			TModelList tModelList = new TModelList();

			QueryLog.Write( QueryType.Find, EntityType.TModel );

			//
			// Process each find constraint.
			//
			FindBuilder find = new FindBuilder( EntityType.TModel, FindQualifiers );

			//
			// If no search arguments are specified, return an empty result
			// set.
			//
			if( Utility.StringEmpty( Name ) &&
				Utility.CollectionEmpty( IdentifierBag ) &&
				Utility.CollectionEmpty( CategoryBag ) )
				return tModelList;

			//
			// Validate find parameters.
			//
			if( !Utility.StringEmpty( Name ) )
			{
                if( 1 == Context.ApiVersionMajor )
                {
                    Name = Name.Trim();
				
					if( Name.Length > UDDI.Constants.Lengths.Name )
					{
					//	throw new UDDIException( ErrorType.E_nameTooLong, "A name specified in the search exceeds the allowable length" );
						throw new UDDIException( ErrorType.E_nameTooLong, "UDDI_ERROR_NAME_TOO_LONG" );
					}
                }
                else
                {
                    Utility.ValidateLength( ref Name, "Name", UDDI.Constants.Lengths.Name );
                }
			}

			//
			// TODO: Override may be better for these calls to KeyedReference.Validate because no parent key is used
			//
			if( !Utility.CollectionEmpty( IdentifierBag ) )
				IdentifierBag.Validate( "", KeyedReferenceType.IdentifierBag );

			if( !Utility.CollectionEmpty( CategoryBag ) )
				CategoryBag.Validate( "", KeyedReferenceType.CategoryBag );			

			try
			{
				int rows = 1;

				//
				// Find entities with matching identifier bag items.
				//
				if( !Utility.CollectionEmpty( IdentifierBag ) )
					rows = find.FindByKeyedReferences( KeyedReferenceType.IdentifierBag, IdentifierBag );

				//
				// Find entities with matching category bag items.
				//
				if( rows > 0 && !Utility.CollectionEmpty( CategoryBag ) )
					rows = find.FindByKeyedReferences( KeyedReferenceType.CategoryBag, CategoryBag );

				//
				// Find entities with matching names
				//
				if( rows > 0 && !Utility.StringEmpty( Name ) )
					rows = find.FindByName( Name );

				//
				// Process the find result set.
				//
				if( 0 == rows )
				{
					//
					// Cleanup any temporary tables.
					//
					find.Abort();
				}
				else if( 0 == MaxRows )
				{
					tModelList.Truncated = Truncated.True;
					return tModelList;
				}
				else
				{
					//
					// Read in the find results.
					//
					SqlDataReaderAccessor reader;
					SqlStoredProcedureAccessor sp;
					sp = find.RetrieveResults( MaxRows );

					reader = sp.ExecuteReader();
				
					try
					{
						while( reader.Read() )
						{
							tModelList.TModelInfos.Add( reader.GetKeyFromGuid( "entityKey" ) );
						}
					}
					finally
					{
						reader.Close();
					}

					if( sp.Parameters.GetBool( "@truncated" ) )
						tModelList.Truncated = Truncated.True;
					else
						tModelList.Truncated = Truncated.False;			
					
					foreach( TModelInfo tModelInfo in tModelList.TModelInfos )
						tModelInfo.Get();
				}				
			}
			catch( Exception )
			{
				find.Abort();
				throw;
			}

			return tModelList;
		}
	}

	/// ********************************************************************
	///   public class GetTModelDetail
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute("get_tModelDetail", Namespace=UDDI.API.Constants.Namespace)]
	public class GetTModelDetail : IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: tModelKey
		//
		[XmlElement("tModelKey")]
		public StringCollection TModelKeys;

		public GetTModelDetail()
		{
		}
	}

	/// ********************************************************************
	///   public class SaveTModel
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	[XmlRootAttribute("save_tModel", Namespace=UDDI.API.Constants.Namespace)]
	public class SaveTModel : IAuthenticateable, IMessage
	{
		//
		// Attribute: generic
		//
		private string generic;

		[XmlAttribute("generic")]
		public string Generic
		{
			get { return generic; }
			set { generic = value; }
		}

		//
		// Element: authInfo
		//
		private string authInfo;

		[XmlElement("authInfo")]
		public string AuthInfo
		{
			get { return authInfo; }
			set { authInfo = value; }
		}

		//
		// Element: tModel
		//
		[XmlElement("tModel")]
		public TModelCollection TModels;

		//
		// Element: uploadRegister
		//
		[XmlElement("uploadRegister")]
		public StringCollection UploadRegisters = new StringCollection();

		public SaveTModel()
		{
			Generic = UDDI.API.Constants.Version;
		}

		/// ****************************************************************
		///   public Save
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public void Save()
		{
			//
			// This is outside of replication so any attempt to specify
			// an upload register URL will force an E_unsupported response
			//
			if( 0 != UploadRegisters.Count )
			{
			//	throw new UDDIException( ErrorType.E_unsupported, "This node does not support the upload register facility" );
				throw new UDDIException( ErrorType.E_unsupported, "UDDI_ERROR_NODE_DOES_NOT_SUPPORT_UPLOAD" );
			}

			TModels.Save();
		}
	}

	[XmlRootAttribute("tModelDetail", Namespace=UDDI.API.Constants.Namespace)]
	public class TModelDetail
	{
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;

		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );

		[XmlAttribute("truncated")]
		public Truncated Truncated;

		[XmlElement("tModel")]
		public TModelCollection TModels = new TModelCollection();

		public void Get( StringCollection tModelKeys )
		{
			foreach( string tModelKey in tModelKeys )
			{
				int index = TModels.Add( tModelKey );
				TModels[ index ].Get();
			}
		}
	}

	[XmlRootAttribute("tModelList", Namespace=UDDI.API.Constants.Namespace)]
	public class TModelList
	{
		//
		// Attribute: generic
		//
		[XmlAttribute("generic")]
		public string Generic = UDDI.API.Constants.Version;
		
		//
		// Attribute: operator
		//
		[XmlAttribute("operator")]
		public string Operator = Config.GetString( "Operator" );
		
		//
		// Attribute: truncated
		//
		[XmlAttribute("truncated")]
		public Truncated Truncated;

		//
		// Element: tModelInfos
		//
		private TModelInfoCollection tModelInfos;

		[ XmlArray( "tModelInfos" ), XmlArrayItem( "tModelInfo" ) ]
		public TModelInfoCollection TModelInfos
		{
			get
			{
				if( null == tModelInfos )
					tModelInfos = new TModelInfoCollection();

				return tModelInfos;
			}

			set { tModelInfos = value; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\makefile.inc ===
foo.cs:
	..\version\$(O)\version.exe -outfile .\assemblyversioninfo.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\assemblyinfo.cs ===
using System.Reflection;
using System.Security.Permissions;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("uddi.core.dll")]
[assembly: AssemblyDescription("Common Server DLL for UDDI Services")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("UDDI Services")]
[assembly: AssemblyCopyright("Copyright(c) 2002 Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly:PermissionSetAttribute(SecurityAction.RequestMinimum, Name = "FullTrust")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\application.cs ===
using System;
using UDDI.Diagnostics;

namespace UDDI
{
	/// ********************************************************************
	///   public class Application
	/// --------------------------------------------------------------------
	///   <summary>
	///
	///   </summary>
	/// ********************************************************************
	/// 
	public class Application
	{
		private static Application application;

		private Config config;
		private Debug debug;

		/// ****************************************************************
		///	  private Application [constructor]
		/// ----------------------------------------------------------------
		///   <summary> 
		///   </summary>
		/// ****************************************************************
		/// 	
		private Application()
		{
			config = new Config();
			debug = new Debug();
		}

		/// ****************************************************************
		///	  public Current [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Returns the current Application instance.
		///   </summary>
		/// ****************************************************************
		/// 	
		public static Application Current
		{
			get
			{
				if( null == application )
					application = new Application();

				return application;
			}
		}

		/// ****************************************************************
		///	  public Config [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Returns the Config instance associated with the global 
		///     Application instance.
		///   </summary>
		/// ****************************************************************
		/// 	
		public static Config Config
		{
			get { return Current.config; }
		}

		/// ****************************************************************
		///	  public Debug [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Returns the Debug instance associated with the global 
		///     Application instance.
		///   </summary>
		/// ****************************************************************
		/// 	
		public static Debug Debug
		{
			get { return Current.debug; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\config.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Threading;
using Microsoft.Win32;

namespace UDDI
{
	/// ****************************************************************
	///   public class Config
	/// ----------------------------------------------------------------
	///   <summary>
	///     Manages configuration settings for UDDI.
	///   </summary>
	/// ----------------------------------------------------------------
	///   <remarks>
	///     The configuration table is of very high importance, so if
	///     we fail to retrieve the configuration settings we'll mark
	///     the table as being invalid by setting it to NULL.  Any 
	///     attempt to retrieve a setting while the table is in this
	///     invalid state will result in an exception.
	///   </remarks>
	/// ****************************************************************
	///

	//
	// TODO: Get and Set static methods should check the IsValid property through a
	// common piece of code method. This would avoid a significant 
	// amount of code bload in the try/catch blocks.
	//
	public class Config
	{
		private const string registryRoot = @"SOFTWARE\Microsoft\UDDI";
		
		private static Hashtable settings = null;
		private static ReaderWriterLock readWriteLock = new ReaderWriterLock();

		private static Thread monitor = null;					
		private static WindowsIdentity identity = null;
		public static Exception LastError = null;
		
		public delegate void ConfigChangeHandler();
		public static event ConfigChangeHandler ConfigChange;

		/// ****************************************************************
		///   private Config
		/// ----------------------------------------------------------------
		///   <summary>
		///     Constructor.
		///   </summary>
		/// ****************************************************************
		/// 
		static Config()
		{
			//
			// 730294 - Never throw exceptions out of this static initializer
			//
			try
			{
				System.Diagnostics.Debug.Write( "INFO  CONF  Configuration manager starting (thread="
					+ Thread.CurrentThread.GetHashCode().ToString()
					+ ", user='" + WindowsIdentity.GetCurrent().Name + "')\r\n" );
				//
				// Initialize the settings collection.
				//
				Refresh();
				
				//
				// Verify that the version of the database that we are using is compatible.
				//
				string versionRegKeyName = "Setup.WebServer.DBSchemaVersion";

				//
				// This key will not exist if only the DB was installed on this machine.  In that case,
				// default to the DbServer.DBSchemaVersion setting.
				//
				if( false == Config.SettingExists( versionRegKeyName ) )
				{			
					versionRegKeyName = "Setup.DbServer.DBSchemaVersion";
				}

				UDDI.Diagnostics.Debug.VerifySetting( versionRegKeyName );
				UDDI.Diagnostics.Debug.VerifySetting( "Database.Version" );

				Version webServerVersion = new Version( Config.GetString( versionRegKeyName ) );
				Version dataBaseVersion  = new Version( Config.GetString( "Database.Version" ) );

				//
				// The major and minor versions must be equal.
				//
				if( ( dataBaseVersion.Major != webServerVersion.Major ) ||
					( dataBaseVersion.Minor != webServerVersion.Minor ) )
				{					
					UDDIText errorMessage = new UDDIText( "UDDI_ERROR_SCHEMA_MISMATCH", webServerVersion.ToString(),  dataBaseVersion.ToString() );					
					
					throw new UDDIException( ErrorType.E_fatalError, errorMessage );
				}

				//
				// Install the registry change notification event handler.  By 
				// marking this thread as a background thread, the runtime will 
				// automatically terminate it when all foreground threads have 
				// finished processing.  This eliminates the need for a separate
				// shutdown mechanism.
				//
				identity = WindowsIdentity.GetCurrent();

				monitor = new Thread( new ThreadStart( Registry_OnChange ) );
				
				monitor.IsBackground = true;
				monitor.Start();
			}			
			catch( UDDIException uddiException )
			{
				//
				// Something has thrown a UDDIException; in this case, just make this exception the last error.
				//
				LastError = uddiException;
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.ConfigError, uddiException.Message );					

				//
				// If any exception occurs, invalidate ourselves.
				//
				InvalidateSelf();
			}
			catch( Exception )
			{
				//
				// Something has thrown a generic Exception; in this case, just create a generic UDDIException, and make
				// that the last error.
				//
				UDDIText errorMessage = new UDDIText( "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );
				LastError = new UDDIException( ErrorType.E_fatalError, errorMessage );

				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.CannotReadSettings, errorMessage.GetText() );					

				//
				// If any exception occurs, invalidate ourselves.
				//
				InvalidateSelf();
			}
		}

		/// ****************************************************************
		///   public CheckForUpdate [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public static void CheckForUpdate()
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			SqlConnection conn = new SqlConnection( Config.GetString( "Database.WriterConnectionString" ) );
			SqlCommand cmd = new SqlCommand( "net_config_getLastChangeDate", conn );
			conn.Open();
					
			try	
			{
				cmd.CommandType = CommandType.StoredProcedure;
				
				string lastChange = (string)cmd.ExecuteScalar();
				string lastRefresh = Config.GetString( "LastChange", "Jan 01 0001 12:00AM" );

				//
				// Compare the database last change configuration with our latest 
				// config.  If it differs, the database has changed and we need
				// to refresh.  Use the minimum SQL date value if the config value
				// isn't available.
				//
				if( 0 != String.Compare( lastChange, lastRefresh ) )
					Config.Refresh();
			}
			finally
			{
				conn.Close();
			}
		}

		/// ****************************************************************
		///   public IsValid [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Returns true if the config table is valid (i.e. has been
		///     properly initialized).
		///   </summary>
		/// ----------------------------------------------------------------
		///   <returns>
		///     True if the table is valid, false otherwise.
		///   </returns>
		/// ****************************************************************
		/// 
		public static bool IsValid
		{
			get 
			{ 
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );
	
				try
				{
					return ( null != settings );
				}
				finally
				{
					readWriteLock.ReleaseReaderLock();
				}
			}
		}

		/// ****************************************************************
		///   private OperatorMessage [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Writes a message to the event log.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="source">
		///   </param>
		///   
		///   <param name="message">
		///   </param>
		///   
		///   <param name="type">
		///   </param>
		///   
		///   <param name="eventID">
		///   </param>
		///   
		///   <param name="category">
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     This is a safe version of the Debug.WriteEventLog method
		///     that prevents re-entrancy issues with the config.
		///   </remarks>
		/// ****************************************************************
		/// 
		private static void OperatorMessage( UDDI.Diagnostics.OperatorMessageType messageType, string message )
		{
			try
			{
				EventLog.WriteEntry(
					"UDDIRuntime", 
					message, 
					EventLogEntryType.Error, 
					(int)messageType, 
					(int)UDDI.Diagnostics.CategoryType.Config );
			}
			catch( Exception )
			{
				Debug.Write(
					"ERRO  CONF  Error writing message to event log.\r\n\r\n"
						+ "Message:\r\n" + message );
			}
		}

		/// ****************************************************************  
		///   private AddSetting [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Adds a configuration setting.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="key">
		///		The setting key.
		///   </param>
		///   
		///   <param name="data">
		///     The configuration setting data.
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///		This function assumes that the writer lock has already been
		///		obtained.
		///   </remarks>
		/// ****************************************************************  
		/// 
		private static void AddSetting( string key, object data )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			if( true == settings.ContainsKey( key ) )
			{
				Debug.Write( "INFO  CONF  Updating setting '" + key + "' value '" + data.ToString() + "'\r\n" );
				settings[ key ] = data;
			}
			else
			{
				Debug.Write( "INFO  CONF  Adding setting '" + key + "' value '" + data.ToString() + "'\r\n" );
				settings.Add( key, data );
			}
		}

		/// ****************************************************************  
		///   private SetString [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Adds a configuration setting to the database configuration table.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="name">
		///		The configuration setting name.
		///   </param>
		///   
		///   <param name="value">
		///     The value to store in the configuration.
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///		This function does not update the in memory cache.
		///   </remarks>
		/// ****************************************************************  
		/// 
		public static void SetString( string name, string value )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			//
			// Connect to the database and get the configuration settings.
			//
			SqlConnection conn = new SqlConnection( Config.GetString( "Database.WriterConnectionString" ) );
			SqlCommand cmd = new SqlCommand( "net_config_save", conn );
			
			conn.Open();
					
			try	
			{
				cmd.CommandType = CommandType.StoredProcedure;
				cmd.Parameters.Add( new SqlParameter( "@configName", SqlDbType.NVarChar, UDDI.Constants.Lengths.ConfigName ) ).Direction = ParameterDirection.Input;
				cmd.Parameters.Add( new SqlParameter( "@configValue", SqlDbType.NVarChar, UDDI.Constants.Lengths.ConfigValue ) ).Direction = ParameterDirection.Input;

				cmd.Parameters[ "@configName" ].Value = name;
				cmd.Parameters[ "@configValue" ].Value = value;
				cmd.ExecuteNonQuery();
			}
			finally
			{
				conn.Close();
			}
		}

		public static int GetCount()
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			int n = 0;
			//
			// Acquire the reader lock and read the setting.
			//
			readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );
			try
			{
				n = settings.Count;
			}
			finally
			{
				readWriteLock.ReleaseReaderLock();
			}

			return n;
		}

		/// ****************************************************************  
		///   private CopyTo [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Adds a configuration setting.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="array">
		///		The array to copy the stuff into.
		///   </param>
		///   
		///   <param name="arrayIndex">
		///     The location in the array to start copying the stuff into.
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///		This function assumes that the writer lock has already been
		///		obtained.
		///   </remarks>
		/// ****************************************************************  
		/// 
		public static void CopyTo( Array array, int arrayIndex )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			//
			// Acquire the reader lock and read the setting.
			//
			readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );
			try
			{
				settings.CopyTo( array, arrayIndex );
			}
			finally
			{
				readWriteLock.ReleaseReaderLock();
			}
		}

		/// ****************************************************************  
		///   public GetObject [static]
		/// ----------------------------------------------------------------  
		///   <summary>
		///     Retrieves the setting with the given key.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="key">
		///     The setting key.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The value of the key, if it exists.  An exception is raised
		///     if it does not.
		///   </returns>
		/// ****************************************************************  
		///  
		public static object GetObject( string key )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			object setting = null;

			try
			{
				//
				// Acquire the reader lock and read the setting.
				//
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

				setting = settings[ key ];
			}
			catch( NullReferenceException )
			{
				//
				// Null reference exceptions are generated when the settings
				// table could not be read.
				//
#if never
				OperatorMessage(
					UDDI.Diagnostics.OperatorMessageType.ConfigInvalid,
					"Configuration table is in an invalid state.\r\n\r\n" + LastError.ToString() );
#endif
				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_CONFIG_INVALID_STATE", LastError.ToString() );					
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.ConfigInvalid, operatorMessage.GetText() );				
#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Server configuration error.\r\n\r\n" + LastError.ToString() );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );				
			}
			finally
			{
				//
				// Release the reader lock.
				//
				readWriteLock.ReleaseReaderLock();
			}

			return setting;
		}

		/// ****************************************************************  
		///   public GetObject [static]
		/// ----------------------------------------------------------------  
		///   <summary>
		///     Retrieves the setting with the given key.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="key">
		///     The setting key.
		///   </param>
		///   
		///   <param name="defaultValue">
		///     Default value to use if the key does not exist.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The value of the key, if it exists, or the specified default
		///     value if it does not.
		///   </returns>
		/// ****************************************************************  
		///  
		public static object GetObject( string key, object defaultValue )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			object setting = defaultValue;

			try
			{
				//
				// Acquire the reader lock and read the setting.
				//
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

				if( settings.ContainsKey( key ) )
					setting = settings[ key ];
			}
			catch( NullReferenceException )
			{
				//
				// Null reference exceptions are generated when the settings
				// table could not be read.
				//
#if never
				OperatorMessage(
					UDDI.Diagnostics.OperatorMessageType.ConfigInvalid,
					"Configuration table is in an invalid state.\r\n\r\n" + LastError.ToString() );
#endif
				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_CONFIG_INVALID_STATE", LastError.ToString() );					
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.ConfigInvalid, operatorMessage.GetText() );				

#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Server configuration error.\r\n\r\n" + LastError.ToString() );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );				
			}
			finally
			{
				//
				// Release the reader lock.
				//
				readWriteLock.ReleaseReaderLock();
			}

			return setting;
		}

		/// ****************************************************************  
		///   public GetInt [static]
		/// ----------------------------------------------------------------  
		///   <summary>
		///     Retrieves the setting with the given key.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="key">
		///     The setting key.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The value of the key, if it exists.  An exception is raised
		///     if it does not.
		///   </returns>
		/// ****************************************************************  
		///  
		public static string GetString( string key )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			string setting = null;

			try
			{
				//
				// Acquire the reader lock and read the setting.
				//
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

				object data = settings[ key ];
				
				if( data is System.String )
					setting = (string)data;
				else
					setting = Convert.ToString( data );
			}
			catch( NullReferenceException )
			{
				//
				// Null reference exceptions are generated when the settings
				// table could not be read.
				//
#if never
				OperatorMessage(
					UDDI.Diagnostics.OperatorMessageType.ConfigInvalid,
					"Configuration table is in an invalid state.\r\n\r\n" + LastError.ToString() );
#endif
				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_CONFIG_INVALID_STATE", LastError.ToString() );					
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.ConfigInvalid, operatorMessage.GetText() );				
#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Server configuration error.\r\n\r\n" + LastError.ToString() );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );				
			}
			finally
			{
				//
				// Release the reader lock.
				//
				readWriteLock.ReleaseReaderLock();
			}

			return setting;
		}

		/// ****************************************************************  
		///   public GetString [static]
		/// ----------------------------------------------------------------  
		///   <summary>
		///     Retrieves the setting with the given key.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="key">
		///     The setting key.
		///   </param>
		///   
		///   <param name="defaultValue">
		///     Default value to use if the key does not exist.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The value of the key, if it exists.  Otherwise returns the
		///     default value.
		///   </returns>
		/// ****************************************************************  
		///  
		public static string GetString( string key, string defaultValue )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			string setting = defaultValue;

			try
			{
				//
				// Acquire the reader lock and read the setting.
				//
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );
				
				if( settings.ContainsKey( key ) )
				{
					object data = settings[ key ];
				
					if( data is System.String )
						setting = (string)data;
					else
						setting = Convert.ToString( data );
				}
			}
			catch( NullReferenceException )
			{
				//
				// Null reference exceptions are generated when the settings
				// table could not be read.
				//
#if never
				OperatorMessage(
					UDDI.Diagnostics.OperatorMessageType.ConfigInvalid,
					"Configuration table is in an invalid state.\r\n\r\n" + LastError.ToString() );
#endif
				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_CONFIG_INVALID_STATE", LastError.ToString() );					
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.ConfigInvalid, operatorMessage.GetText() );				

#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Server configuration error.\r\n\r\n" + LastError.ToString() );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );				
			}
			finally
			{
				//
				// Release the reader lock.
				//
				readWriteLock.ReleaseReaderLock();
			}

			return setting;
		}

		/// ****************************************************************  
		///   public GetInt [static]
		/// ----------------------------------------------------------------  
		///   <summary>
		///     Retrieves the setting with the given key.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="key">
		///     The setting key.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The value of the key.
		///   </returns>
		/// ****************************************************************  
		///  
		public static int GetInt( string key )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			int setting = 0;

			try
			{
				//
				// Acquire the reader lock and read the setting.
				//
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

				object data = settings[ key ];

				if( data is System.Int32 )
					setting = (int)data;
				else
					setting = Convert.ToInt32( data );
			}
			catch( NullReferenceException )
			{
				//
				// Null reference exceptions are generated when the settings
				// table could not be read.				
				//
#if never
				OperatorMessage(
					UDDI.Diagnostics.OperatorMessageType.ConfigInvalid,
					"Configuration table is in an invalid state.\r\n\r\n" + LastError.ToString() );
#endif
				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_CONFIG_INVALID_STATE", LastError.ToString() );					
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.ConfigInvalid, operatorMessage.GetText() );				
#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Server configuration error.\r\n\r\n" + LastError.ToString() );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );				
			}
			finally
			{
				//
				// Release the reader lock.
				//
				readWriteLock.ReleaseReaderLock();
			}

			return setting;
		}

		/// ****************************************************************  
		///   public GetInt [static]
		/// ----------------------------------------------------------------  
		///   <summary>
		///     Retrieves the setting with the given key.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="key">
		///     The setting key.
		///   </param>
		///   
		///   <param name="defaultValue">
		///     Default value to use if the key does not exist.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///     The value of the key, if it exists.  Otherwise returns the
		///     default value.
		///   </returns>
		/// ****************************************************************  
		///  
		public static int GetInt( string key, int defaultValue )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			int setting = defaultValue;

			try
			{
				//
				// Acquire the reader lock and read the setting.
				//
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

				if( settings.ContainsKey( key ) )
				{
					object data = settings[ key ];
					
					if( data is System.Int32 )
						setting = (int)data;
					else
						setting = Convert.ToInt32( data );
				}
			}
			catch( NullReferenceException )
			{
				//
				// Null reference exceptions are generated when the settings
				// table could not be read.
				//
#if never
				OperatorMessage(
					UDDI.Diagnostics.OperatorMessageType.ConfigInvalid,
					"Configuration table is in an invalid state.\r\n\r\n" + LastError.ToString() );
#endif
				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_CONFIG_INVALID_STATE", LastError.ToString() );					
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.ConfigInvalid, operatorMessage.GetText() );				
#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Server configuration error.\r\n\r\n" + LastError.ToString() );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );				
			}
			finally
			{
				//
				// Release the reader lock.
				//
				readWriteLock.ReleaseReaderLock();
			}

			return setting;
		}

		/// ****************************************************************
		///	  public SettingExists [static]
		/// ----------------------------------------------------------------  
		///   <summary>
		///		Determines whether the given setting exists in the 
		///		collection.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="key">
		///		The setting key.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <returns>
		///		Returns true if the setting exists.
		///   </returns>
		/// ****************************************************************
		/// 
		public static bool SettingExists( string key )
		{
			//
			// Throw an exception if we are not in a valid state.
			//
			CheckIsValid();

			bool exists = false;

			try
			{
				//
				// Acquire the reader lock and read the setting.
				//
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

				exists = settings.ContainsKey( key );
			}
			catch( NullReferenceException )
			{
				//
				// Null reference exceptions are generated when the settings
				// table could not be read.
				//
#if never
				OperatorMessage(
					UDDI.Diagnostics.OperatorMessageType.ConfigInvalid,
					"Configuration table is in an invalid state.\r\n\r\n" + LastError.ToString() );
#endif
				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_CONFIG_INVALID_STATE", LastError.ToString() );					
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.ConfigInvalid, operatorMessage.GetText() );				

#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Server configuration error.\r\n\r\n" + LastError.ToString() );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );				
			}
			finally
			{			
				//
				// Release the reader lock.
				//
				readWriteLock.ReleaseReaderLock();
			}

			return exists;
		}

		/// ****************************************************************
		///	  public Refresh [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Refreshes setting information.
		///   </summary>
		/// ****************************************************************
		/// 
		public static void Refresh()
		{
			try
			{
				Debug.Write(
					"INFO  CONF  Refreshing configuration settings (thread="
						+ Thread.CurrentThread.GetHashCode().ToString() 
						+ ", user='" + WindowsIdentity.GetCurrent().Name + "')\r\n" );

				//
				// Obtain the writer lock.
				//
				readWriteLock.AcquireWriterLock( Timeout.Infinite );

				//
				// Clear the existing setting table.
				//
				settings = new Hashtable( CaseInsensitiveHashCodeProvider.Default, 
										  CaseInsensitiveComparer.Default );

				//
				// Attempt to get the database connection string.
				//			
				RegistryKey databaseKey = Registry.LocalMachine.OpenSubKey( registryRoot + @"\Database" );					

				string writerConnectionString = null;
					
				if( null != databaseKey )
				{					
					try
					{
						writerConnectionString = (string)databaseKey.GetValue( "WriterConnectionString" );
					}
					catch( Exception )
					{
						throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_DB_WRITER_CONNECTION_STRING" );							
					}
				}

				//
				// 730294 - The MMC will set this value to "", so use StringEmtpy, not just check for null.
				//
				if( true == Utility.StringEmpty( writerConnectionString ) )				
				{
					throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_DB_WRITER_CONNECTION_STRING" );							
				}

				//
				// Connect to the database and get the configuration settings.
				//
				SqlConnection conn = new SqlConnection( writerConnectionString );
				SqlCommand cmd = new SqlCommand( "net_config_get", conn );
			
				conn.Open();
					
				try	
				{
					cmd.CommandType = CommandType.StoredProcedure;
		
					SqlDataReader reader = cmd.ExecuteReader();
					
					while( reader.Read() )
					{
						//
						// We'll treat all database settings as strings, except for those
						// with special prefixes.
						//
						string keyName = reader.GetString( 0 );
						string keyPrefix = "";

						int separator = keyName.IndexOf( "." );
						if( -1 != separator )
							keyPrefix = keyName.Substring( 0, separator );

						if( "Length" == keyPrefix )
						{
							AddSetting( keyName, Convert.ToInt32( reader.GetString( 1 ) ) );
						}
						else
						{
							AddSetting( keyName, reader.GetString( 1 ) );
						}
					}
				}
				finally
				{
					conn.Close();
				}

				//
				// Read configuration data from the registry.
				//
				RegistryKey root = Registry.LocalMachine.OpenSubKey( registryRoot );

				if( null != root )
					RefreshRegistrySettings( root, "", true );
			}
			catch( SqlException e )
			{
				LastError = e;

				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_ERROR_READING_CONFIG_SETTINGS", e.ToString() );
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.CannotReadSettings, operatorMessage.GetText() );
				
				//
				// Mark the table as being invalid.
				//
				settings = null;
			}
			catch( Exception e )
			{
				LastError = e;

				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_ERROR_READING_CONFIG_SETTINGS", e.ToString() );
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.CannotReadSettings, operatorMessage.GetText() );
	
				//
				// Mark the table as being invalid.
				//
				settings = null;
			}
			finally
			{
				//
				// Release the writer lock.
				//
				readWriteLock.ReleaseWriterLock();

				if( null != ConfigChange )
				{
					try
					{
						ConfigChange();
					}
					catch( Exception )
					{
					}
				}
			}
		}

		/// ****************************************************************
		///	  private RefreshRegistrySettings [static]
		/// ----------------------------------------------------------------  
		///   <summary>
		///		Refreshes configuration settings from the registry, 
		///		starting at the specified root.
		///   </summary>
		/// ----------------------------------------------------------------  
		///   <param name="root">
		///		Registry key that contains the settings.
		///   </param>
		///   
		///   <param name="prefix">
		///		Optional.  Prefix to add to the beginning of setting names
		///		in the collection.
		///   </param>
		///   
		///   <param name="recurse">
		///		True if subkeys of the root should be searched.
		///   </param>
		/// ----------------------------------------------------------------  
		///   <remarks>
		///		If recursion is enabled, values in subkeys of the root are
		///		also enumerated.  When enumerating subkeys, the value names
		///		are prefixed with the name of the subkey.
		///   </remarks>
		/// ****************************************************************
		/// 
		private static void RefreshRegistrySettings( RegistryKey root, string prefix, bool recurse )
		{
			//
			// Add the values in the given root.
			//
			foreach( string name in root.GetValueNames() )
				AddSetting( prefix + name, root.GetValue( name ) );

			//
			// If recursion is enabled, search through the subkeys under the given root.  The
			// key will be prefixed with the subkey name.
			//
			if( true == recurse )
			{
				foreach( string name in root.GetSubKeyNames() )
					RefreshRegistrySettings( root.OpenSubKey( name ), prefix + name + ".", true );
			}
		}
		
		/// ****************************************************************
		///   private Registry_OnChange [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Event handler for setting change events in the registry.
		///   </summary>
		/// ****************************************************************
		/// 
		private static void Registry_OnChange()
		{
			//
			// Impersonate the identity of the main thread.
			//
			if( WindowsIdentity.GetCurrent().Name != identity.Name )
			{
				try
				{
					identity.Impersonate();
					
				}
				catch( Exception e )
				{
#if never
					OperatorMessage(
						UDDI.Diagnostics.OperatorMessageType.CannotReadSettings,
						"Configuration refresh thread was unable take on the identity " +
						"of the creating thread (thread=" + Thread.CurrentThread.GetHashCode().ToString() + 
						").\r\n\r\nDetails:\r\n" + e.ToString() );
#endif
					UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_CANNOT_IMPERSONATE", Thread.CurrentThread.GetHashCode().ToString(), e.ToString() );
					OperatorMessage( UDDI.Diagnostics.OperatorMessageType.CannotReadSettings, operatorMessage.GetText() );
										
					return;
				}
			}

			Debug.Write(
				"INFO  CONF  Configuration registry change handler starting (thread=" +
				Thread.CurrentThread.GetHashCode().ToString() +
				", user='" + WindowsIdentity.GetCurrent().Name + "')\r\n" );

			//
			// Obtain a handle to the registry key we want to monitor.
			//
			uint hkey;

			int hr = Win32.RegOpenKeyEx( Win32.HKEY_LOCAL_MACHINE, registryRoot, 0, Win32.KEY_READ, out hkey );

			if( 0 != hr )
			{				
#if never
				OperatorMessage(
					UDDI.Diagnostics.OperatorMessageType.CannotReadSettings,
					"Unable to access registry root '" + registryRoot + "'" );
#endif
				UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_UNABLE_TO_ACCESS_REGISTRY", registryRoot );
				OperatorMessage( UDDI.Diagnostics.OperatorMessageType.CannotReadSettings, operatorMessage.GetText() );			
			}

			//
			// Monitor changes to the registry key.
			//
			AutoResetEvent changeEvent = new AutoResetEvent( false );
		
			while( true )
			{
				//
				// Wait for a change notification event.
				//
				Win32.RegNotifyChangeKeyValue( hkey, true, 
					Win32.REG_NOTIFY_CHANGE_LAST_SET, (uint)changeEvent.Handle.ToInt32(), true );
				
				changeEvent.WaitOne();

				//
				// Refresh the settings.  We trap all errors since we never
				// want to kill the refresh thread, otherwise who would read 
				// the settings when they finally become available?
				//
				try
				{
					Refresh();
				}
				catch( Exception e )
				{
#if never
					OperatorMessage(
						UDDI.Diagnostics.OperatorMessageType.CannotReadSettings,
						"Unable to refresh configuration settings from registry monitor thread.\r\n\r\nDetails:\r\n" + e.ToString() );
#endif
					UDDIText operatorMessage = new UDDIText( "UDDI_ERROR_OPERATOR_MESSAGE_UNABLE_TO_REFRESH", e.ToString() );
					OperatorMessage( UDDI.Diagnostics.OperatorMessageType.CannotReadSettings, operatorMessage.GetText() );						
				}
			}
		}

		//
		// 730294 - Centralize what exceptions we throw.
		//
		private static void CheckIsValid()
		{
			if( !IsValid )
			{
				//
				// Make sure we are always throwing a nice UDDIException; construct a generic one if you have to.
				//
				UDDIException uddiException = LastError as UDDIException;				
				if( null == uddiException )
				{
					uddiException = new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_COMMUNICATION_ERROR" );
				}
				
				throw uddiException;
			}
		}

		//
		// 730294 - Clean up the way we do exceptions.
		//
		private static void InvalidateSelf()
		{
			//
			// Make ourself invalid by nulling out the setting table.  Make sure to keep this in sync with 
			// what the IsValid property is doing.
			//
			try
			{
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );
				settings = null;
			}
			finally
			{
				readWriteLock.ReleaseReaderLock();
			}
		}
	}

	/// ********************************************************************
	///   public class CachedSetting
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	///   
	public class CachedSetting
	{
		private ReaderWriterLock readWriteLock = new ReaderWriterLock();
		
		//
		// 730294 - Keep the state of a CachedSetting in sync with the Config by just using the Config.IsValid property instead
		// of keeping a valid member.  Remove the valid member.
		//

		private string key;
		private object setting;
		private object defaultValue;
		private bool exists;
		private bool defaultSpecified;
		
		public event Config.ConfigChangeHandler ConfigChange;

		/// ****************************************************************
		///   public CachedSetting [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="key">
		///   </param>
		/// ****************************************************************
		/// 
		public CachedSetting( string key )
		{
			this.key = key;
			this.defaultSpecified = false;
			this.defaultValue = null;
			
			Config_OnChange();
			Config.ConfigChange += new Config.ConfigChangeHandler( Config_OnChange );
		}

		/// ****************************************************************
		///   public CachedSetting [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="key">
		///   </param>
		///   
		///   <param name="defaultValue">
		///   </param>
		/// ****************************************************************
		/// 
		public CachedSetting( string key, object defaultValue )
		{
			this.key = key;
			this.defaultSpecified = true;
			this.defaultValue = defaultValue;
		
			Config_OnChange();
			Config.ConfigChange += new Config.ConfigChangeHandler( Config_OnChange );
		}

		/// ****************************************************************
		///   private Config_OnChange [event handler]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     We don't have to worry about acquiring a reader lock in
		///     this method because the configuration update only executes
		///     on a single background thread.
		///   </remarks>
		/// ****************************************************************
		/// 
		private void Config_OnChange()
		{					
			//
			// Make sure the config is valid.  If not, just return.
			//
			if( !Config.IsValid )
			{		
				return;
			}
		
			object setting = null;
				
			//
			// Retrieve the new setting.
			//			
			bool exists = Config.SettingExists( key );			

			if( exists )			
				setting = Config.GetObject( key );

			//
			// Check to see if we need to do anything.  First of all, if the
			// existance of the setting has changed, we need to update that
			// information.  If that has not changed, then the only other way
			// we do not have to update is if the setting itself hasn't 
			// changed.
			//
			
			if( exists == this.exists && 
				null != setting && setting.Equals( this.setting ) )
				return;
				
			//
			// Store the new setting details.
			//
			System.Diagnostics.Debug.Write(
				"INFO  CONF  Refreshing cached setting '" + key + "' (thread="
					+ Thread.CurrentThread.GetHashCode().ToString() 
					+ ", user='" + WindowsIdentity.GetCurrent().Name + "')\r\n" );

			readWriteLock.AcquireWriterLock( Timeout.Infinite );

			try
			{
				this.exists = exists;
				this.setting = setting;				
			}
			finally
			{
				readWriteLock.ReleaseWriterLock();
				
				if( null != ConfigChange )
					ConfigChange();
			}
		}

		/// ****************************************************************
		///   public Exists
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public bool Exists
		{
			get 
			{ 
				// 
				// Don't call CheckSetting() here because we don't want to throw an exception if the setting
				// does not exist.
				//			
				readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

				try
				{					
					//
					// Make sure that our configuration is still valid.
					//
					CheckIsConfigValid();

					return exists;
				}
				finally
				{
					readWriteLock.ReleaseReaderLock();
				}
			}
		}

		/// ****************************************************************
		///   public HasDefaultValue
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public bool HasDefaultValue
		{
			get { return defaultSpecified; }
		}

		/// ****************************************************************
		///   public DefaultValue
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public object DefaultValue
		{
			get { return defaultValue; }
		}

		/// ****************************************************************
		///   public GetString
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public string GetString()
		{
			// 
			// 730294 - Centralize checking of setting state and validity.
			//
			CheckSetting();
			
			//
			// Return the setting as a string.
			//
			readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

			try
			{								
				if( exists )
					return Convert.ToString( setting );
				else
					return Convert.ToString( defaultValue );
			}
			finally
			{
				readWriteLock.ReleaseReaderLock();
			}
		}
		
		/// ****************************************************************
		///   public GetInt
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public int GetInt()
		{
			// 
			// 730294 - Centralize checking of setting state and validity.
			//
			CheckSetting();
			
			//
			// Return the setting as an integer.
			//
			readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

			try
			{							
				if( exists )
					return Convert.ToInt32( setting );
				else
					return Convert.ToInt32( defaultValue );
			}
			finally
			{
				readWriteLock.ReleaseReaderLock();
			}
		}

		/// ****************************************************************
		///   public GetObject
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		public object GetObject()
		{
			// 
			// 730294 - Centralize checking of setting state and validity.
			//
			CheckSetting();
			
			//
			// Return the setting as an object.
			//
			readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

			try
			{							
				if( exists )
					return setting;
				else
					return defaultValue;
			}
			finally
			{
				readWriteLock.ReleaseReaderLock();
			}
		}
		
		//
		// 730294 - Keep the state of a CachedSetting in sync with the Config by just using the Config.IsValid property instead
		// of keeping a valid member.
		//
		private void CheckSetting()
		{
			//
			// First, make sure that we still exist.
			//
			if( !exists && !defaultSpecified )
			{
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_CONFIG_SETTING_MISSING", key );				
			}

			//
			// Make sure that our configuration is still valid.
			//
			CheckIsConfigValid();
		}

		private void CheckIsConfigValid()
		{			
			if( false == Config.IsValid )
			{
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_SERVER_CONFIGURATION_ERROR", Config.LastError.Message );				
			}
		}

		public void AcquireReaderLock( int millisecondsTimeout )
		{
			readWriteLock.AcquireReaderLock( millisecondsTimeout );
		}

		public void AcquireReaderLock( TimeSpan timeout )
		{
			readWriteLock.AcquireReaderLock( timeout );
		}

		public void ReleaseReaderLock()
		{
			readWriteLock.ReleaseReaderLock();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\context.cs ===
using System;
using System.Data;
using System.IO;
using System.Security.Principal;
using System.Text;
using System.Web;
using System.Xml.Serialization;
using System.Runtime.InteropServices;
using UDDI.Diagnostics;

namespace UDDI
{
	public enum AuthenticationMode : int
	{
		None							= 0,
		Uddi							= 1,
		Windows							= 2,
		AuthenticatedRead				= 4,
		Passport						= 8,
		Both							= Uddi | Windows,
		WindowsWithAuthenticatedRead	= Windows | AuthenticatedRead
	}

	/// ********************************************************************
	///   public enum ContextType
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public enum ContextType
	{
		Other			= 0,
		SOAP			= 1,
		UserInterface	= 2,
		Replication		= 3
	}

	//
	// Used in replication to determine where the exception came from
	// 
	public enum ExceptionSource
	{
		Other					= 0,
		BrokenServiceProjection = 1,
		PublisherAssertion		= 2
	}

	/// ********************************************************************
	///   public enum RoleType
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public enum RoleType
	{
		Anonymous		= 0,
		User			= 1,
		Publisher		= 2,
		Coordinator		= 3,
		Administrator	= 4
	}

	/// ********************************************************************
	///   public class Context
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class Context
	{
		[ThreadStatic]
		private static Context context = null;

		private ContextType contextType;
		private ExceptionSource exceptionSource;

		internal UserInfo userInfo;
		private Guid contextID;
		private int threadID;
		private int apiVersionMajor;
		private bool logChangeRecords = false;
		private DateTime timeStamp;
		private string remoteOperator = null;

		/// ****************************************************************
		///	  private Context [constructor]
		/// ----------------------------------------------------------------
		///   <summary> 
		///   </summary>
		/// ****************************************************************
		/// 	
		private Context()
		{
			//
			// SECURITY: These member variables are not initialized during construction
			//
			// apiVersionMajor
			// contextType
			//

			//
			// Verify that the operating system is supported.
			//
			Win32.OsVersionInfoEx osVersion = new Win32.OsVersionInfoEx();

			if( !Win32.GetVersionEx( osVersion ) )
			{
#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Could not retrieve operating system version." );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_COULD_NOT_RETRIEVE_OPERATING_SYSTEM_VERSION" );				
			}

			if( ( Win32.ProductType.WindowsServer != osVersion.ProductType 
                    && Win32.ProductType.DomainController != osVersion.ProductType ) 
                || osVersion.MajorVersion < 5 
                || ( 5 == osVersion.MajorVersion && osVersion.MinorVersion < 1 ) )
			{
#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Microsoft UDDI Services is not supported on this platform." );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_UNSUPPORTED_PLATFORM" );				
			}			
					
#if never		
			contextID = Guid.NewGuid();		
			threadID = System.Threading.Thread.CurrentThread.GetHashCode();
			timeStamp = DateTime.UtcNow;			
			userInfo = new UserInfo();
#endif
		}

		/// ****************************************************************
		///  public Initialize
		/// ----------------------------------------------------------------
		/// <summary>
		///		Initialize per-request data for the context.  This method
		///		MUST be called once per request.  Multiple calls will
		///		re-initialize the contents of the current context.
		/// 
		/// </summary>
		/// ****************************************************************
		public void Initialize()
		{
			//
			// Reset our state.  apiVersionMajor is not reset since it will be set in our VersionSupportExtension
			//
			contextType      = ContextType.Other;
			exceptionSource  = ExceptionSource.Other;
			userInfo		 = new UserInfo();
			contextID		 = Guid.NewGuid();
			threadID		 = System.Threading.Thread.CurrentThread.GetHashCode();		

			//
			// 738148 - To reduce disk usage, make it configurable as to whether we log change records or not.
			//
			logChangeRecords = Config.GetInt( "LogChangeRecords", 0 ) == 0 ? false : true;
			timeStamp		 = DateTime.UtcNow;
			remoteOperator	 = null;
		
			//
			// In our log, we should never ever see multiple calls to this method
			// in the same application_request_started/application_request_ended blocks (see global.asax)
			// In the event log, correct behaviour is:
			//		application_request started:
			//			"Context.Initialize" message
			//			... (any number of messages)
			//		application_request ended
			//
			Debug.Write( SeverityType.Info, 
						 CategoryType.Soap, 
						 "Context.Initialize" );
		}

		/// ****************************************************************
		///	  public Current [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Returns the current Context instance.  This is either
		///     the Context instance that is associated with the 
		///     current HttpContext, or the instance that is associated with 
		///     the thread.
		///   </summary>
		/// ****************************************************************
		/// 	
		public static Context Current
		{
			get
			{
				HttpContext httpContext = HttpContext.Current;

				if( null == httpContext )
				{
					//
					// There is no HttpContext, so we must be running within
					// the context of an application.  In such cases, we
					// create a message context for each thread.
					//
					if( null == context )		
					{
						context = new Context();					

						//
						// Since we are running in an application, we want to initialize each
						// instance that we create.
						//
						context.Initialize();
					}
				}
				else
				{
					//
					// Check to see if the we have seen this HttpContext
					// before.  If not, we create a new message context and
					// mark the HttpContext.
					//
					if( null == httpContext.Items[ "UddiContext" ] || !( httpContext.Items[ "UddiContext" ] is Context ) )
						httpContext.Items.Add( "UddiContext", new Context() );

					context = (Context)httpContext.Items[ "UddiContext" ];
				}

				return context;
			}
		}

		/// ****************************************************************
		///	  public LogChangeRecords [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Specifies whether change records should be generated when
		///     updating registry data.
		///   </summary>
		/// ****************************************************************
		/// 	
		public static bool LogChangeRecords
		{
			get { return Current.logChangeRecords; }
			set
			{
				Debug.Verify( User.IsAdministrator, "UDDI_ERROR_FATALERROR_CONTEXT_SETLOGCHANGESNOTADMIN" );
				Current.logChangeRecords = value;
			}
		}		
		
		/// ****************************************************************
		///	  public TimeStamp [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Gets or sets the context timestamp.
		///   </summary>
		/// ****************************************************************
		/// 	

		//
		// TODO: Why not use a field for this instead of a property
		//
		public static DateTime TimeStamp
		{
			get { return Current.timeStamp; }
			set { Current.timeStamp = value; }
		}
		
		/// ****************************************************************
		///	  public RemoteOperator [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Gets or sets the context remote operator.
		///   </summary>
		/// ****************************************************************
		/// 	

		//
		// TODO: Why not use a field for this instead of a property
		//
		public static string RemoteOperator
		{
			get { return Current.remoteOperator; }
			set { Current.remoteOperator = value; }
		}

		/// ****************************************************************
		///	  public User [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Returns the UserInfo associated with the current 
		///     Context instance.
		///   </summary>
		/// ****************************************************************
		/// 	

		//
		// TODO: Why not use a field for this instead of a property
		//
		public static UserInfo User
		{
			get { return Current.userInfo; }
			set { Current.userInfo = value; }
		}

		/// ****************************************************************
		///	  public ContextID [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Returns the ContextID associated with the current 
		///     Context instance.
		///   </summary>
		/// ****************************************************************
		/// 	
		public static Guid ContextID
		{
			get { return Current.contextID;	}
		}

		/// ****************************************************************
		///	  public ThreadID [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Returns the ThreadID associated with the current 
		///     Context instance.
		///   </summary>
		/// ****************************************************************
		/// 	
		public static int ThreadID
		{
			get { return Current.threadID; }
		}

		/// ****************************************************************
		///	  public ContextType [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Gets/sets the ContextType associated with the current 
		///     Context instance.
		///   </summary>
		/// ****************************************************************
		/// 	

		//
		// TODO: Why not use a field for this instead of a property
		//
		public static UDDI.ContextType ContextType
		{
			get { return Current.contextType; }
			set { Current.contextType = value; }
		}

		public static UDDI.ExceptionSource ExceptionSource
		{
			get { return Current.exceptionSource; }
			set { Current.exceptionSource = value; }
		}

		/// ****************************************************************
		///	  public ApiVersionMajor [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Returns the major version number of the request associated
		///     with the current Context instance.
		///   </summary>
		/// ****************************************************************
		/// 	

		//
		// TODO: Why not use a field for this instead of a property
		//
		public static int ApiVersionMajor
		{
			get { return Current.apiVersionMajor; }
			set { Current.apiVersionMajor = value; }
		}
	}

	/// ********************************************************************
	///   public class UserInfo
	/// --------------------------------------------------------------------
	///   <summary>
	///     Stores information about an authenticated publisher.
	///   </summary>
	/// ********************************************************************
	/// 

	//
	// SECURITY: Could probably use some SALT to fuzzy up the content
	// of this class when serialized as a ticket/token
	//
	public class UserInfo
	{
		//
		// pInvoke stuff to work with the SID strings
		//

		[DllImport("ADVAPI32.DLL", EntryPoint="ConvertStringSidToSidW",  
			 SetLastError=true,
			 CharSet=CharSet.Unicode, ExactSpelling=true,
			 CallingConvention=CallingConvention.StdCall)]
		public static extern int ConvertStringSidToSid( string sidStr, out IntPtr psid );

		[DllImport("ADVAPI32.DLL", EntryPoint="LookupAccountSidW",  
			 SetLastError=true,
			 CharSet=CharSet.Unicode, ExactSpelling=true,
			 CallingConvention=CallingConvention.StdCall)]
		public static extern int LookupAccountSid( string systemName,
			IntPtr psid,
			StringBuilder acctName,
			out int cbAcctName,
			StringBuilder domainName,
			out int cbDomainName,
			out int sidUse );

		[XmlAttribute( "a" )]
		public Guid guid = Guid.NewGuid();

		[XmlElement( "created", DataType="dateTime" )]
		public DateTime created = DateTime.Now;

		[XmlAttribute( "Role" )]
		public RoleType Role = RoleType.Anonymous;

		[XmlAttribute( "ID" )]
		public string ID = null;

		[XmlAttribute( "Language" )]
		public string IsoLangCode = "en";

		[XmlIgnore()]
        public string ImpersonatorID = null;
		[XmlIgnore()]
		public string Name = null;
		[XmlIgnore()]
		public string Email = null;
		[XmlIgnore()]
		public string Phone = null;
		[XmlIgnore()]
		public string CompanyName = null;
		[XmlIgnore()]
		public string AltPhone = null;
		[XmlIgnore()]
		public string AddressLine1 = null;
		[XmlIgnore()]
		public string AddressLine2 = null;
		[XmlIgnore()]
		public string City = null;
		[XmlIgnore()]
		public string StateProvince = null;
		[XmlIgnore()]
		public string PostalCode = null;
		[XmlIgnore()]
		public string Country = null;
		[XmlIgnore()]
		public bool TrackPassport = true;
		[XmlIgnore()]
		public bool Verified = false;
		[XmlIgnore()]
		public int BusinessLimit = 0;
		[XmlIgnore()]
		public int BusinessCount = 0;
		[XmlIgnore()]
		public int TModelLimit = 0;
		[XmlIgnore()]
		public int TModelCount = 0;
		[XmlIgnore()]
		public int ServiceLimit = 0;
		[XmlIgnore()]
		public int BindingLimit = 0;
		[XmlIgnore()]
		public int AssertionLimit = 0;
		[XmlIgnore()]
		public int AssertionCount = 0;
		[XmlIgnore()]
		public bool AllowPreassignedKeys = false; 


		/// ****************************************************************
		///	  public IsInRole [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Checks membership of the windows identity of the current 
		///     thread in a Windows Group.
		///   </summary>
		/// ****************************************************************
		/// 	
		public bool IsInRole( string strSID )
		{
			WindowsPrincipal prin = new WindowsPrincipal( WindowsIdentity.GetCurrent() );

			return IsInRole( strSID, prin );
		}


		public bool IsInRole( string strSID, IPrincipal principal )
		{
			return principal.IsInRole( GroupNameFromSid( strSID ) );
		}

		public string GroupNameFromSid( string strSid )
		{
			IntPtr psid;
			StringBuilder szstrSid = new StringBuilder( strSid );
			StringBuilder domainName = new StringBuilder( 1024 );
			StringBuilder acctName = new StringBuilder( 1024 );
			int cbDomainName = 1024;
			int cbAcctName = 1024;
			int sidUse = -1;

			int iRet = ConvertStringSidToSid( strSid, out psid );
			if( 0 == iRet )
			{
			//	throw new UDDIException( ErrorType.E_fatalError, "An attempt to convert a security id to a group name failed. ConvertStringSidToSid failed. " );
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_SID_CONVERSION_FAILED" );
			}

			iRet = LookupAccountSid( null, psid, acctName, out cbAcctName, domainName, out cbDomainName, out sidUse );
			if( 0 == iRet )
			{
				//throw new UDDIException( ErrorType.E_fatalError, "An attempt to convert a security id to a group name failed. An attempt to LookupAccountSid failed." );
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_SID_LOOKUP_FAILED" );
			}
			return domainName.ToString() + "\\" + acctName.ToString();
		}

		/// ****************************************************************
		///	  public IsUser
		/// ----------------------------------------------------------------
		///   <summary> 
		///   </summary>
		/// ****************************************************************
		/// 	
		public bool IsUser
		{
			get { return Role >= RoleType.User; }
		}

		/// ****************************************************************
		///	  public IsPublisher
		/// ----------------------------------------------------------------
		///   <summary> 
		///   </summary>
		/// ****************************************************************
		/// 	
		public bool IsPublisher
		{
			get { return Role >= RoleType.Publisher; }
		}
	
		/// ****************************************************************
		///	  public IsCoordinator
		/// ----------------------------------------------------------------
		///   <summary> 
		///   </summary>
		/// ****************************************************************
		/// 	
		public bool IsCoordinator
		{
			get { return Role >= RoleType.Coordinator; }
		}

		/// ****************************************************************
		///	  public IsAdministrator
		/// ----------------------------------------------------------------
		///   <summary> 
		///   </summary>
		/// ****************************************************************
		/// 	
		public bool IsAdministrator
		{
			get { return Role >= RoleType.Administrator; }
		}

		/// ****************************************************************
		///	  public IsImpersonated
		/// ----------------------------------------------------------------
		///   <summary> 
		///   </summary>
		/// ****************************************************************
		/// 	
		public bool IsImpersonated
		{
			get 
			{ 
				return ( null != ImpersonatorID && ID != ImpersonatorID );
			}
		}

		/// ****************************************************************
		///	  public Register [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///   </summary>
		/// ****************************************************************
		/// 	
		public void Register()
		{
			Debug.Enter();

			//
			// If the Name has not been populated during authentication
			// use the ID. This is needed to populate the authorizedName
			// field.
			//
			if( null == Name || 0 == Name.Length )
			{
				Name = ID;
			}

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "UI_savePublisher" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@isoLangCode", SqlDbType.NVarChar, UDDI.Constants.Lengths.IsoLangCode );
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name );
			sp.Parameters.Add( "@email", SqlDbType.NVarChar, UDDI.Constants.Lengths.Email );
			sp.Parameters.Add( "@phone", SqlDbType.NVarChar, UDDI.Constants.Lengths.Phone );
			sp.Parameters.Add( "@companyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.CompanyName );
			sp.Parameters.Add( "@altphone", SqlDbType.NVarChar, UDDI.Constants.Lengths.Phone );
			sp.Parameters.Add( "@addressLine1", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine );
			sp.Parameters.Add( "@addressLine2", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine );
			sp.Parameters.Add( "@city", SqlDbType.NVarChar, UDDI.Constants.Lengths.City );
			sp.Parameters.Add( "@stateProvince", SqlDbType.NVarChar, UDDI.Constants.Lengths.StateProvince );
			sp.Parameters.Add( "@postalCode", SqlDbType.NVarChar, UDDI.Constants.Lengths.PostalCode );
			sp.Parameters.Add( "@country", SqlDbType.NVarChar, UDDI.Constants.Lengths.Country );
			sp.Parameters.Add( "@flag", SqlDbType.Int );
			sp.Parameters.Add( "@tier", SqlDbType.NVarChar, UDDI.Constants.Lengths.Tier );

			sp.Parameters.SetString( "@PUID", ID );
			sp.Parameters.SetString( "@isoLangCode", IsoLangCode );
			sp.Parameters.SetString( "@name", Name );
			sp.Parameters.SetString( "@email", Email );
			sp.Parameters.SetString( "@phone", Phone );
			sp.Parameters.SetString( "@companyName", CompanyName );
			sp.Parameters.SetString( "@altphone", AltPhone );
			sp.Parameters.SetString( "@addressLine1", AddressLine1 );
			sp.Parameters.SetString( "@addressLine2", AddressLine2 );
			sp.Parameters.SetString( "@city", City );
			sp.Parameters.SetString( "@stateProvince", StateProvince );
			sp.Parameters.SetString( "@postalCode", PostalCode );
			sp.Parameters.SetString( "@country", Country );
			sp.Parameters.SetString( "@tier", Config.GetString( "Publisher.DefaultTier", "2" ) );
		
			int flag = 0;
		
			//
			// TODO: Comments or an enumeration please
			//
			if( !TrackPassport )
				flag = flag | 0x02;

			if( Verified )
				flag = flag | 0x01;

			sp.Parameters.SetInt( "@flag", flag );
			sp.ExecuteNonQuery();
		
			Debug.Leave();
		}

		/// ****************************************************************
		///	  public IsRegistered
		/// ----------------------------------------------------------------
		///   <summary> 
		///		Determines whether the current user is registered as a
		///		publisher.
		///   </summary>
		/// ****************************************************************
		/// 	
		public bool IsRegistered
		{
			get 
			{
				Debug.Enter();

				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_publisher_isRegistered" );
				sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
				sp.Parameters.Add( "@returnValue", SqlDbType.Int, ParameterDirection.ReturnValue );
	
				sp.Parameters.SetString( "@PUID", ID );
				sp.ExecuteNonQuery();
		
				int returnValue = sp.Parameters.GetInt( "@returnValue" );
		
				Debug.Leave();

				return ( 0 == returnValue );
			}
		}
		
		/// ****************************************************************
		///	  public IsVerified
		/// ----------------------------------------------------------------
		///   <summary> 
		///		Determines whether the current user is registered as a
		///		publisher.
		///   </summary>
		/// ****************************************************************
		/// 	
		public bool IsVerified
		{
			get 
			{
				Debug.Enter();

				SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_publisher_isVerified" );

				sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
				sp.Parameters.Add( "@returnValue", SqlDbType.Int, ParameterDirection.ReturnValue );
	
				sp.Parameters.SetString( "@PUID", ID );
				sp.ExecuteNonQuery();
		
				int returnValue = sp.Parameters.GetInt( "@returnValue" );
		
				Debug.Leave();

				return ( 0 == returnValue );
			}
		}

		/// ****************************************************************
		///	  public Login
		/// ----------------------------------------------------------------
		///   <summary> 
		///		Logs the current user in.
		///   </summary>
		/// ****************************************************************
		/// 		
		public void Login()
		{
			Debug.Enter();

			SqlStoredProcedureAccessor sp = new SqlStoredProcedureAccessor( "net_publisher_login" );

			sp.Parameters.Add( "@PUID", SqlDbType.NVarChar, UDDI.Constants.Lengths.UserID );
			sp.Parameters.Add( "@email", SqlDbType.NVarChar, UDDI.Constants.Lengths.Email, ParameterDirection.InputOutput );
			
			sp.Parameters.Add( "@name", SqlDbType.NVarChar, UDDI.Constants.Lengths.Name, ParameterDirection.Output );
			sp.Parameters.Add( "@phone", SqlDbType.VarChar, UDDI.Constants.Lengths.Phone, ParameterDirection.Output );
			sp.Parameters.Add( "@companyName", SqlDbType.NVarChar, UDDI.Constants.Lengths.CompanyName, ParameterDirection.Output );
			sp.Parameters.Add( "@altPhone", SqlDbType.VarChar, UDDI.Constants.Lengths.Phone, ParameterDirection.Output );
			sp.Parameters.Add( "@addressLine1", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine, ParameterDirection.Output );
			sp.Parameters.Add( "@addressLine2", SqlDbType.NVarChar, UDDI.Constants.Lengths.AddressLine, ParameterDirection.Output );
			sp.Parameters.Add( "@city", SqlDbType.NVarChar, UDDI.Constants.Lengths.City, ParameterDirection.Output );
			sp.Parameters.Add( "@stateProvince", SqlDbType.NVarChar, UDDI.Constants.Lengths.StateProvince, ParameterDirection.Output );
			sp.Parameters.Add( "@postalCode", SqlDbType.NVarChar, UDDI.Constants.Lengths.PostalCode, ParameterDirection.Output );
			sp.Parameters.Add( "@country", SqlDbType.NVarChar, UDDI.Constants.Lengths.Country, ParameterDirection.Output );
			sp.Parameters.Add( "@isoLangCode", SqlDbType.VarChar, UDDI.Constants.Lengths.IsoLangCode, ParameterDirection.Output );			
			sp.Parameters.Add( "@businessLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@businessCount", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@tModelLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@tModelCount", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@serviceLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@bindingLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@assertionLimit", SqlDbType.Int, ParameterDirection.Output );
			sp.Parameters.Add( "@assertionCount", SqlDbType.Int, ParameterDirection.Output );
		
			sp.Parameters.SetString( "@PUID", ID );
			sp.Parameters.SetString( "@email", Email );

			sp.ExecuteNonQuery();
	
			Email = sp.Parameters.GetString( "@email" );
			Name = sp.Parameters.GetString( "@name" );
			Phone = sp.Parameters.GetString( "@phone" );
			CompanyName = sp.Parameters.GetString( "@companyName" );
			AltPhone = sp.Parameters.GetString( "@altPhone" );
			AddressLine1 = sp.Parameters.GetString( "@addressLine1" );
			AddressLine2 = sp.Parameters.GetString( "@addressLine2" );
			City = sp.Parameters.GetString( "@city" );
			StateProvince = sp.Parameters.GetString( "@stateProvince" );
			PostalCode = sp.Parameters.GetString( "@postalCode" );
			Country = sp.Parameters.GetString( "@country" );			
			IsoLangCode = sp.Parameters.GetString( "@isoLangCode" );
			
			BusinessLimit = sp.Parameters.GetInt( "@businessLimit" );
			BusinessCount = sp.Parameters.GetInt( "@businessCount" );
			TModelLimit = sp.Parameters.GetInt( "@tModelLimit" );
			TModelCount = sp.Parameters.GetInt( "@tModelCount" );
			ServiceLimit = sp.Parameters.GetInt( "@serviceLimit" );
			BindingLimit = sp.Parameters.GetInt( "@bindingLimit" );
			AssertionLimit = sp.Parameters.GetInt( "@assertionLimit" );
			AssertionCount = sp.Parameters.GetInt( "@assertionCount" );

			Debug.Leave();
		}

		public void Serialize( Stream stream )
		{
			//
			// Serialize it as XML into a stream
			//
			StreamWriter writer = new StreamWriter( stream, Encoding.UTF8 );
			
			XmlSerializer serializer = new XmlSerializer( typeof( UserInfo ) );
			serializer.Serialize( writer, this );
			writer.Flush();
			
			stream.Position = 0;
		}

		public void CheckAge( int timeWindow )
		{
			TimeSpan duration = DateTime.Now - created;

			Debug.Write( SeverityType.Info, 
				CategoryType.Authorization,
				"Ticket is dated: " + created.ToLongDateString() + ", " + created.ToLongTimeString() );

			if( duration.TotalMinutes > timeWindow )
			{
#if never
				throw new UDDIException( UDDI.ErrorType.E_authTokenExpired, 
					"The submitted credentials have expired." );
#endif
				throw new UDDIException( UDDI.ErrorType.E_authTokenExpired, "UDDI_ERROR_CREDENTIALS_EXPIRED" );
			}
		}

		public void SetPublisherRole( string userID )
		{
			Role = RoleType.Publisher;
			ID = userID;
		}

		public void SetRole( IPrincipal principal )
		{
			//
			// Determine the role of the caller and assign it into the user object
			//
			if( IsInRole( Config.GetString( "GroupName.Administrators", "S-1-5-32-544" ), principal ) )
			{
				Role = RoleType.Administrator;
			}
			else if( IsInRole( Config.GetString( "GroupName.Coordinators", "S-1-5-32-544" ), principal ) )
			{
				Role = RoleType.Coordinator;
			}
			else if( IsInRole( Config.GetString( "GroupName.Publishers", "S-1-5-32-544" ), principal ) )
			{
				Role = RoleType.Publisher;
			}
			else if( IsInRole( Config.GetString( "GroupName.Users", "S-1-5-32-545" ), principal ) )
			{
				Role = RoleType.User;
			}
			else
			{
				Role = RoleType.Anonymous;
			}

		    ID = principal.Identity.Name;
			Name = ID;
		}

		public void SetAllowPreassignedKeys( bool flag )
		{
			AllowPreassignedKeys = flag;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\performance.cs ===
namespace UDDI.Diagnostics
{
	using System;
	using System.Diagnostics;
	using System.Collections;
	using System.Text;

	/// <summary>
	///		This class provides support for publication of all of the
	///		UDDI performance counters
	/// </summary>
	public class Performance
	{
		//
		// suffix use to identify average base counters
		//
		private static string BaseSuffix = "b";

		public Performance()
		{
		}

		public static void DeleteCounters()
		{
			PerformanceCounterCategory.Delete( "UDDI.API.Times" );
			PerformanceCounterCategory.Delete( "UDDI.API.Counts" );
		}
	
		public static void InitializeCounters()
		{
			if( !PerformanceCounterCategory.Exists( "UDDI.API.Times" ) )
			{			
				//
				// Create performance counters to measure the duration of message calls.
				//
				CounterCreationDataCollection times = new CounterCreationDataCollection();
				
				foreach( string messageName in MessageNames.Names )
				{
					AddAverageTimesCounter( ref times, messageName );
				}
				
				PerformanceCounterCategory.Create( "UDDI.API.Times", "UDDI.API.Times.Category.Help", times );
			}

			if( !PerformanceCounterCategory.Exists( "UDDI.API.Counts" ) )
			{
				//
				// Create performance counters to measure the number of times each message is called.
				//
				CounterCreationDataCollection counts = new CounterCreationDataCollection();

				foreach( string messageName in MessageNames.Names )
				{
					AddCumulativeAccessCountCounter(ref counts, messageName);
				}				
				PerformanceCounterCategory.Create( "UDDI.API.Counts", "UDDI.API.Counts.Category.Help", counts );
			}
		}

		public static void PublishMessageData( string name, TimeSpan duration )
		{
			PerformanceCounter pc = new PerformanceCounter( "UDDI.API.Counts", name, false );
			pc.Increment();

			//
			// The milliseconds value is a double, IncrementBy accepts a long check to
			// avoid casting errors
			//
			if( duration.TotalMilliseconds <= long.MaxValue )
			{
				PerformanceCounter pcduration =  new PerformanceCounter( "UDDI.API.Times", name, false );
				pcduration.IncrementBy( (long) duration.TotalMilliseconds );

				//
				// The RawFraction counter type multiplies by 100 to generate a percentage; we don't
				// want this, so increment by 100 to offset.
				//
				PerformanceCounter pcdurationbase = new PerformanceCounter( "UDDI.API.Times", name + BaseSuffix, false );
				pcdurationbase.IncrementBy( 100 );
			}
		}

		private static void AddAverageTimesCounter(ref CounterCreationDataCollection counters, string name)
		{	
			string helpstr = string.Format( Localization.GetString( "AVERAGE_DURATION_COUNT_HELP" ), name );
			string avgstr = string.Format( Localization.GetString( "AVERAGE_DURATION_COUNT_BASE" ), name );


			CounterCreationData newCounter = new  CounterCreationData( name, 
																	   helpstr,
				                                                       PerformanceCounterType.RawFraction );

			CounterCreationData baseCounter = new  CounterCreationData( name + BaseSuffix, 
																		avgstr,
																	    PerformanceCounterType.RawBase );

			//
			// RawFraction counter types must be followed by their corresponding base counter type in list of counters added to CounterCreationDataCollection.
			//
			counters.Add( newCounter );
			counters.Add( baseCounter );
		}

		private static void AddCumulativeAccessCountCounter(ref CounterCreationDataCollection counters, string name)
		{
			string helpstr = string.Format( Localization.GetString( "CUMULATIVE_ACCESS_COUNT_HELP" ), name );

			
			CounterCreationData newCounter = new  CounterCreationData( name, 				
																	   helpstr, 
																	   PerformanceCounterType.NumberOfItems64 );		
			counters.Add( newCounter );
		}



		//
		// TODO: This class should probably go somewhere else.  API is a likely choice, but do we want Core to have
		// a dependency on API?  
		//
		// We can't, it would be a cyclical reference.

		//
		// SOAP message names.  V2 API messages were added as part of bug# 1388
		//
		class MessageNames
		{
			public static string[] Names = 
			{	
				//
				// Inquire message names
				//
				"find_binding",
				"find_business",
				"find_relatedBusinesses",
				"find_service",
				"find_tModel",
				"get_bindingDetail",
				"get_businessDetail",
				"get_businessDetailExt",
				"get_serviceDetail",
				"get_tModelDetail",
				"validate_categorization",

				//
				// Publish message types
				//	
				"add_publisherAssertions", 
				"delete_binding",
				"delete_business",
				"delete_publisherAssertions",
				"delete_service",
				"delete_tModel",
				"discard_authToken",
				"get_assertionStatusReport",
				"get_authToken",
				"get_publisherAssertions",
				"get_registeredInfo",
				"save_binding",
				"save_business",
				"save_service",
				"save_tModel",
				"set_publisherAssertions",

				//
				// Replication message types
				//		
				"get_changeRecords",					
				"notify_changeRecordsAvailable",		
				"do_ping",								
				"get_highWaterMarks",					

				//
				// MS Extensions
				//
				"get_relatedCategories"					
			};
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\schemacollection.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using UDDI.Diagnostics;

namespace UDDI
{
	/// ********************************************************************
	///   public class SchemaCollection  
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************  
	/// 
	public class SchemaCollection
	{
		private static XmlSchemaCollection xsc = new XmlSchemaCollection();
		private static bool initialized = false;

		static SchemaCollection()
		{
			Debug.VerifySetting( "InstallRoot" );

			string installRoot = Config.GetString( "InstallRoot" );
			
			AddSchema( "urn:uddi-org:api", installRoot + "uddi_v1.xsd" );
			AddSchema( "urn:uddi-org:api_v2", installRoot + "uddi_v2.xsd" );
			AddSchema( "urn:uddi-org:repl", installRoot + "uddi_v2replication.xsd" );
			AddSchema( "urn:uddi-microsoft-com:api_v2_extensions", installRoot + "extensions.xsd" );
            
            Debug.Verify( 4 == xsc.Count, "UDDI_ERROR_FATALERROR_SCHEAMAS_LOADING" );

			initialized = true;
		}

		public static void AddSchema( string ns, string filename )
		{
			Debug.Verify( 
				File.Exists( filename ), 
				"UDDI_ERROR_FATALERROR_SCHEMEMISSING",
				ErrorType.E_fatalError,
				filename  
			);
			
			xsc.Add( ns, filename );
		}
	 	
		public static void Validate( object obj )
		{
			Debug.Verify( initialized, "UDDI_ERROR_FATALERROR_SCHEAMAS_LOADING" );

			MemoryStream stream = new MemoryStream();
			XmlSerializer serializer = new XmlSerializer( obj.GetType() );

			serializer.Serialize( stream, obj );

			stream.Seek( 0, SeekOrigin.Begin );
			XmlTextReader reader = new XmlTextReader( stream );
			
			LocalValidate( reader );
		}

		public static void Validate( Stream stream )
		{
			Debug.Verify( initialized, "UDDI_ERROR_FATALERROR_SCHEAMAS_LOADING" );

			//
			// Rewind stream and validate
			//
			stream.Seek( 0, SeekOrigin.Begin );
			
			XmlTextReader reader = new XmlTextReader( stream );
			LocalValidate( reader );

			//
			// Rewind stream again, so someone else can use it
			//
			stream.Seek( 0, SeekOrigin.Begin );
		}

		public static void ValidateFile( string filename )
		{
			Debug.Verify( initialized, "UDDI_ERROR_FATALERROR_SCHEAMAS_LOADING" );

			XmlTextReader reader = new XmlTextReader( filename );
			
			LocalValidate( reader );
		}

		private static void LocalValidate( XmlTextReader reader )
		{
			XmlValidatingReader validator = new XmlValidatingReader( reader );
			validator.Schemas.Add( xsc );
			
			while( validator.Read()){}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\localization.cs ===
using System;
using System.Threading;
using System.Resources;
using System.Globalization;
using System.Web;

using Microsoft.Win32;

using UDDI.Diagnostics;

namespace UDDI
{
	public class Localization
	{
		protected static ResourceManager manager = null;

		static Localization()
		{
			try
			{
				Debug.VerifySetting( "InstallRoot" );
				manager = ResourceManager.CreateFileBasedResourceManager( "uddi", 
																		  Config.GetString( "InstallRoot" ) + "resources", 
																		  null );								
			}
			catch
			{
				//
				// There may be a case where we get called before the database and hence our configuration
				// settings are setup.  The only information we need is the install root.  If we can't get
				// this information from the database, we'll try to get it from the registry.
				//

				//
				// TODO should make this field non-private on Config
				//

				string registryRoot = @"SOFTWARE\Microsoft\UDDI";
				RegistryKey uddiRegKey = Registry.LocalMachine.OpenSubKey( registryRoot );								

				//
				// At this point, let any exceptions just propogate since we can't get the information that we need.
				//
				manager = ResourceManager.CreateFileBasedResourceManager( "uddi", 
																		  uddiRegKey.GetValue( "InstallRoot" ) + "resources", 
																		  null );	
			}			
		}

		public static CultureInfo GetCulture()
		{
			Thread thread = Thread.CurrentThread;
			CultureInfo culture = thread.CurrentUICulture;
			
			try
			{
				//
				// If this is an HTTP request, attempt to use the browser's
				// preferred language setting.
				//
				HttpContext context = HttpContext.Current;

				if( null != context && context.Request.UserLanguages.Length >= 1 )
				{
					string language = context.Request.UserLanguages[ 0 ];
					
					//
					// BUG: 778542.  To fully support MUI Builds via the UI, we must
					// first attempt to create a specific culture, and if that failes, create a
					// primary culture.
					//
	            	try
	            	{
	            		culture = CultureInfo.CreateSpecificCulture( language );
	            	}
	            	catch
	            	{
						culture = new CultureInfo( language );
					}
				}
			}
			catch
			{
				culture = thread.CurrentUICulture;
			}
		
			return culture;
		}

		//
		// Return the given string using the local machine culture rather than the
		// caller's culture.  TODO consider creating a new method, GetString( string name, bool useLocalMachine )		
		//
		public static string GetStringLocalMachineCulture( string name )
		{
			string resource = null;

			try
			{
				resource = manager.GetString( name );
				
			}
			catch
			{}
			if( null == resource )
			resource = "[[" + name + "]]";

			return resource;
		}
		public static CultureInfo GetCultureWithFallback(  )
		{
			CultureInfo localculture = GetCulture();
			string filebase = Config.GetString( "InstallRoot" ) + "resources\\uddi{0}resources";
			string file = string.Format( filebase, "." + localculture.Name + "." ) ;
			
			bool installed = System.IO.File.Exists( file );
			
			if( installed )
				return localculture;
			else
			{
				do
				{
					localculture = localculture.Parent;
					file = string.Format( filebase, "." + localculture.Name + "." ) ;
					installed = System.IO.File.Exists( file );
				
				}while( !installed && 127!=localculture.LCID );

				if( installed )
					return localculture;
				else
					return CultureInfo.InstalledUICulture;
			}
			
		}
		public static string GetString( string name )
		{
			CultureInfo culture = GetCulture();

			//
			// Retrieve the resource.
			//
			string resource = null;
			
			try
			{
				resource = manager.GetString( name, culture );
			}
			catch
			{
			}

			if( null == resource )
				resource = "[[" + name + "]]";

			return resource;
		}
		
		/// *****************************************************************************
		/// <summary>
		///		Check to see if a string is marked up with '[[' at the start and ']]' at
		///		the end.  If so, return true, else return false.
		/// </summary>
		/// <param name="key">Key to validate</param>
		/// <returns>Boolean indicated if it is a valide key</returns>
		/// *****************************************************************************
		public static bool IsKey( string key )
		{
			return( null!=key && key.StartsWith( "[[" ) && key.EndsWith( "]]" ) );
		}

		/// *****************************************************************************
		/// <summary>
		///		Removes the UDDI Localization Markup tags from a string. It will remove 
		///		'[[' from the begining and ']]' from the end.
		///		
		///		If the key doesn't contain markup tags, the string is returned in its 
		///		original state.
		/// </summary>
		/// <param name="key">Key to remove markup on</param>
		/// <returns>Bare Localization key.</returns>
		/// *****************************************************************************
		public static string StripMarkup( string key )
		{
			return key.TrimEnd( "]]".ToCharArray() ).TrimStart( "[[".ToCharArray() );
		}

		/// *****************************************************************************
		/// <summary>
		///		Translation of kernel32:SetThreadUILanguage semantics into managed code.
		///		Used for overridding console CurrentUICulture when console code page 
		///		doesn't match the current ANSI or OEM code page.
		/// </summary>
		/// *****************************************************************************
		public static void SetConsoleUICulture()
		{
			int iConsoleCodePage = System.Console.Out.Encoding.CodePage;
			System.Threading.Thread currentThread = Thread.CurrentThread;

			//
			// if no code page set, we're not in a console
			//
			if( 0 != iConsoleCodePage )
			{
				if( !((iConsoleCodePage == currentThread.CurrentCulture.TextInfo.ANSICodePage ||
					iConsoleCodePage == currentThread.CurrentCulture.TextInfo.OEMCodePage) &&
					(iConsoleCodePage == currentThread.CurrentUICulture.TextInfo.ANSICodePage ||
					iConsoleCodePage == currentThread.CurrentUICulture.TextInfo.OEMCodePage)) )
				{
					//
					// override with en-US culture
					//
					currentThread.CurrentUICulture = new CultureInfo( "en-US" );
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\win32.cs ===
using System;
using System.Runtime.InteropServices;

namespace UDDI
{
	public class Win32
	{
		public static readonly uint HKEY_LOCAL_MACHINE = 0x80000002;
		public static readonly uint KEY_READ = 0x00020019;
		public static readonly uint KEY_WRITE = 0x00020006;
		public static readonly uint KEY_ALL_ACCESS = 0x0002003F;
		public static readonly uint REG_NOTIFY_CHANGE_LAST_SET = 0x0004;

		public enum ProductType : byte
		{
			WindowsWorkstation	= 0x01,
			DomainController	= 0x02,
			WindowsServer		= 0x03
		}

		[ StructLayout( LayoutKind.Sequential ) ]
		public class OsVersionInfo
		{
			private int size = Marshal.SizeOf( typeof( OsVersionInfo ) );
			
			public uint MajorVersion;
			public uint MinorVersion;
			public uint BuildNumber;
			public uint PlatformID;
			
			[ MarshalAs( UnmanagedType.ByValTStr, SizeConst=128 ) ]
			public string AdditionalInformation;
		}

		[ StructLayout( LayoutKind.Explicit ) ]
		public class OsVersionInfoEx
		{
			[ FieldOffset( 0 ) ]
			private int size = Marshal.SizeOf( typeof( OsVersionInfoEx ) );
			
			[ FieldOffset( 4 ) ]
			public uint MajorVersion;
			[ FieldOffset( 8 ) ]
			public uint MinorVersion;
			[ FieldOffset( 12 ) ]
			public uint BuildNumber;
			[ FieldOffset( 16 ) ]
			public uint PlatformID;

			[ FieldOffset( 20 ), MarshalAs( UnmanagedType.ByValTStr, SizeConst=128 ) ]
			public string AdditionalInformation;

			[ FieldOffset( 276 ) ]
			public ushort ServicePackMajor;
			[ FieldOffset( 278 ) ]
			public ushort ServicePackMinor;
			[ FieldOffset( 280 ) ]
			public ushort SuiteMask;
			[ FieldOffset( 282 ) ]
			public Win32.ProductType ProductType;
			[ FieldOffset( 283 ) ]
			public byte Reserved;
		}

		[ DllImport( "kernel32", EntryPoint="GetVersionExW" ) ]
		public static extern bool GetVersionEx( [In, Out] OsVersionInfo versionInfo );

		[ DllImport( "kernel32", EntryPoint="GetVersionExW" ) ]
		public static extern bool GetVersionEx( [In, Out] OsVersionInfoEx versionInfo );

		[ DllImport( "advapi32.dll", CharSet=CharSet.Auto ) ]
		public static extern int RegCreateKeyEx( uint hkey, string subKey, uint reserved, string className, uint options, uint security, uint attributes, out uint result, uint disposition );

		[ DllImport( "advapi32.dll", CharSet=CharSet.Auto ) ]
		public static extern int RegNotifyChangeKeyValue( uint hkey, bool watchSubtree, uint notifyFilter, uint eventHandle, bool asynchronous );				

		[ DllImport( "advapi32.dll", CharSet=CharSet.Auto ) ]
		public static extern int RegOpenKeyEx( uint hkey, string subKey, uint options, uint security, out uint result );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\debug.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Web.Mail;
using UDDI;

namespace UDDI.Diagnostics
{
	/// ********************************************************************
	///	  public enum SeverityType
	/// --------------------------------------------------------------------
	///   <summary>
	///		Severity codes for error reporting.
	///   </summary>
	/// ********************************************************************
	/// 
	public enum SeverityType : int
	{
		None			= 0,
		Error			= 1,
		Warning			= 2,
		FailAudit		= 3,
		PassAudit		= 4,
		Info			= 5,
		Verbose			= 6
	}

	/// ********************************************************************
	///	  public enum CategoryType
	/// --------------------------------------------------------------------
	///   <summary>
	///		Category codes for specifying where an error occurred.
	///   </summary>
	/// ********************************************************************
	/// 
	public enum CategoryType : int
	{
		None			= 0,
		Config			= 1,
		Soap			= 2,
		Data			= 3,
		Authorization	= 4,
		Website			= 5,
		Replication		= 6
	}

	/// ********************************************************************
	///	  public enum OperatorMessageType
	/// --------------------------------------------------------------------
	///   <summary>
	///		Error message codes for the various operator messages.
	///   </summary>
	/// ********************************************************************
	/// 
	public enum OperatorMessageType : int
	{
		None							= 100,

		//
		// Client messages (100 level)
		//
		InvalidUserId					= 101,

		// 
		// Server messages (200 level)
		//
		ConfigError						= 200,
		CannotReadSettings				= 201,
		MissingSetting					= 202,
		ConfigInvalid					= 203,
		UnableToPublishCounter			= 204,
		CouldNotCreateEventLog			= 205,
		PassportNotConfigured			= 206,
		UnknownLoginURL					= 207,
		PassportSiteUnavailable			= 208,
		CannotRetrieveClientXml			= 209,
		InvalidTicketFormat				= 210,
		StartingReplicationSession		= 211,
		StartingReplicationWithNode		= 212,
		EndingReplicationWithNode		= 213,
		ReplicationSessionSummary		= 214,
		NoReplicationOperators			= 215,
		CannotRetrieveHighWaterMarks	= 216,
		ErrorCommunicatingWithNode		= 217,
		ValidationError					= 218,
		UnknownOperator					= 219,
		CouldNotSendMail				= 220,
		InvalidKey						= 221

		//
		// if you exceed 300, you must edit uddievents.mc and add more event numbers
		//
	}

	/// ********************************************************************
	///   public class Debug
	/// --------------------------------------------------------------------
	///   <summary>
	///		Manages error reporting and logging.
	///   </summary>
	/// ********************************************************************
	/// 
	public class Debug
	{
		private static ReaderWriterLock readWriteLock = new ReaderWriterLock();

		//
		// The default values of these settings should be kept in sync with the values stored in the UDO_config table
		// in the database.
		//
		private static CachedSetting debuggerLevel = new CachedSetting( "Debug.DebuggerLevel", SeverityType.Verbose );
		private static CachedSetting eventLogLevel = new CachedSetting( "Debug.EventLogLevel", SeverityType.Warning );
		private static CachedSetting fileLogLevel = new CachedSetting( "Debug.FileLogLevel", SeverityType.None );

		//
		// SECURITY: Default location of the log file needs to be changed
		// It should not go to the root of the c: drive. This location may not be
		// accessible.
		//
		private static CachedSetting logFilename = new CachedSetting( "Debug.LogFilename", @"c:\uddi.log" );
		private static DateTime lastLogEvent = DateTime.Now;
		
		private static TextWriter textStream = null;		

		/// ****************************************************************
		///   static Debug [constructor]
		/// ----------------------------------------------------------------
		///   <summary>
		///   </summary>
		/// ****************************************************************
		/// 
		static Debug()
		{
			//
			// Register a configuration change handler for the logFilename
			// setting.
			//
			logFilename.ConfigChange += new Config.ConfigChangeHandler( LogFilename_OnChange );

			//
			// Register a configuration change handler for the file log level setting.  When this
			// setting becomes SeverityType.None, we'll release our handle to the log file (if we have one).
			//
			fileLogLevel.ConfigChange += new Config.ConfigChangeHandler( FileLogLevel_OnChange );
		}
		
		/// ****************************************************************
		///   private FileLogLevel_OnChange [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Handler for file log level configuration change events.
		///   </summary>
		/// ****************************************************************
		/// 
		private static void FileLogLevel_OnChange()
		{
			try
			{
				SeverityType newSeverity = ( SeverityType ) fileLogLevel.GetInt();
				
				//
				// If logging is turned off, release our handle to the log file.
				//
				if( SeverityType.None == newSeverity )
				{
					ReleaseLogFile();
				}
			}
			catch
			{
				// 
				// We should never get any exceptions from this, but eat them if we do.  We don't want to
				// put our file logging in an inconsistent state.
				//
			}
		}

		/// ****************************************************************
		///   private LogFilename_OnChange [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Handler for logFilename configuration change events.
		///   </summary>
		/// ****************************************************************
		/// 
		private static void LogFilename_OnChange()
		{
			ReleaseLogFile();
		}
		
		private static void ReleaseLogFile()
		{
			//
			// Acquire the writer lock.
			//
			readWriteLock.AcquireWriterLock( Timeout.Infinite );

			try
			{
				//
				// Close the text stream, if open.  We do this so that the file
				// logging method will reopen with the current log filename.
				//
				if( null != textStream )
				{
					textStream.Close();
					textStream = null;
				}
			}
			finally
			{
				readWriteLock.ReleaseWriterLock();
			}
		}

		/// ****************************************************************
		///   public Enter [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Writes trace information indicating the beginning of 
		///		execution of a function
		///   </summary>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     The trace information generated by this function
		///     is published at the verbose level.
		///   </remarks>
		/// ****************************************************************
		/// 
		public static void Enter()
		{
#if DEBUG
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Debug.Write( 
				SeverityType.Verbose, 
				CategoryType.None, 
				"Entering " + method.ReflectedType.FullName + "." + method.Name + "..." );
#endif
		}

		/// ****************************************************************
		///   public Leave [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Writes trace information indicating the end of execution of
		///		a function
		///   </summary>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     The trace information generated by this function
		///     is published at the verbose level.
		///   </remarks>
		/// ****************************************************************
		/// 
		public static void Leave()
		{
#if DEBUG
			System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace( 1, false );
			System.Reflection.MethodBase method = trace.GetFrame( 0 ).GetMethod();

			Debug.Write( 
				SeverityType.Verbose, 
				CategoryType.None, 
				"Leaving " + method.ReflectedType.FullName + "." + method.Name );
#endif
		}

		/// ****************************************************************
		///   public OperatorMessage [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Writes an operator message to the event log.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="severity">
		///     The severity of the message.
		///   </param>
		///   
		///   <param name="category">
		///     The category of the message.
		///   </param>
		///   
		///   <param name="messageId">
		///		Operator message type.
		///   </param>
		///   
		///   <param name="message">
		///     Message to write to the event log.
		///   </param>
		/// ****************************************************************
		/// 
		public static void OperatorMessage( SeverityType severity, CategoryType category, OperatorMessageType messageId, string message )
		{
            try
            {   				
				//
                // Store the entry in the event log as an error.
                //
                WriteEventLog(
                    severity,
                    category,
                    messageId,
                    message );

                //
                // Also write this as a warning level message to any debug message 
                // listeners (other than event log, since we already logged this
                // message there).
                //
                if( (int)severity <= debuggerLevel.GetInt() )
                {
                    WriteDebugger(
                        severity, 
                        category, 
                        "Operator message [" + messageId.ToString() + "]: " + message );
                }

                if( (int)severity <= fileLogLevel.GetInt() )
                {
                    WriteFileLog( 
                        severity, 
                        category, 
                        "Operator message [" + messageId.ToString() + "]: " + message );
                }
            }
            catch( Exception )
            {
            }
		}
		
		/// ****************************************************************
		///   public Assert [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Checks for a condition and displays a message if false.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="condition">
		///		The condition to verify.  If the condition is false, the
		///		given message is displayed.
		///   </param>
		///   
		///   <param name="message">
		///		LocalizaitonKey to use for the Exception.
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     Calls to Assert are ignored in non-debug builds.
		///   </remarks>
		/// ****************************************************************
		/// 
		[System.Diagnostics.Conditional( "DEBUG" )]
		[System.Diagnostics.DebuggerHidden()]		
		public static void Assert( bool condition, string message )
		{
			if( false == condition )
			{
				try
				{
					//
					// Build the assert message.  We'll attempt to build a pretty stack
					// trace, eliminating our frame from the list.
					//
					string trace = System.Environment.StackTrace;

					int pos = trace.IndexOf( "Debug.Assert" );
					if( pos >= 0 && pos < trace.Length - 1 )
					{
						pos = trace.IndexOf( "at", pos + 1 );
						if( pos >= 0 )
							trace = "   " + trace.Substring( pos );
					}

					string text = "Assertion failed: " + message + "\r\n\r\n" + 
						"Stack trace:\r\n" + trace;
					
					//
					// Write the assertion to the debugger and break.
					//
					WriteDebugger( SeverityType.Error, CategoryType.None, text );									
					System.Diagnostics.Debugger.Break();
				}
				catch( Exception )
				{
				}
				finally
				{
					throw new UDDIException( ErrorType.E_fatalError, message );
				}
			}
		}

		/// ****************************************************************
		///   public VerifyKey [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Checks for a tModelKey of the form uuid:xxx...xxx
		///   </summary>
		/// ----------------------------------------------------------------   
		///   <param name="key">
		///		A string presumed to begin with "uuid:" and followed by a properly formed Guid
		///   </param>
		///   
		/// ----------------------------------------------------------------   
		///   <param name="message">
		///		Message to display if the assertion fails.
		///   </param>
		///   
		/// ----------------------------------------------------------------
		///   <remarks>
		///     Calls to this function are honored, even in non-debug
		///     builds.
		///   </remarks>
		/// ****************************************************************
		/// 
		[System.Diagnostics.DebuggerHidden()]
		public static void VerifyKey( string key )
		{
			Debug.Verify( 
				null != key, 
				"UDDI_ERROR_INVALIDKEYPASSED_INVALIDTMODELKEY", 
				ErrorType.E_invalidKeyPassed 
			);
			
			Debug.Verify( 
				key.Length >= 5 && key.Substring( 0, 5 ).ToLower().Equals( "uuid:" ), 
				"UDDI_ERROR_INVALIDKEYPASSED_NOUUIDONTMODELKEY",
				ErrorType.E_invalidKeyPassed
			);
			
			Debug.Verify( 
				41 == key.Length, 
				"UDDI_ERROR_INVALIDKEYPASSED_INVALIDTMODELKEYLENGTH" ,
				ErrorType.E_invalidKeyPassed
			);


			/*try
			{
				Debug.Verify( null != key, "A valid tModelKey is required", ErrorType.E_fatalError );
				Debug.Verify( key.Length >= 5 && key.Substring( 0, 5 ).ToLower().Equals( "uuid:" ), "Specified tModelKey does not begin with uuid:" );
				Debug.Verify( 41 == key.Length, "Specified tModelKey is not the correct length" );
			}
			catch( Exception e )
			{
				throw new UDDIException( ErrorType.E_invalidKeyPassed, e.Message );
			}*/
		}

		/// ****************************************************************
		///   public Verify [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Checks for a condition and displays a message if false.
		///   </summary>
		/// ----------------------------------------------------------------   
		///   <param name="condition">
		///		The condition to verify.  If the condition is false, the
		///		given message is displayed.
		///   </param>
		///   
		///   <param name="message">
		///		Message to display if the assertion fails.
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     Calls to this function are honored, even in non-debug
		///     builds.
		///   </remarks>
		/// ****************************************************************
		/// 
		[System.Diagnostics.DebuggerHidden()]
		public static void Verify( bool condition, string message )
		{
			Verify( condition, message, ErrorType.E_fatalError );
		}

		/// ****************************************************************
		///   public Verify [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Checks for a condition and displays a message if false.
		///   </summary>
		/// ----------------------------------------------------------------   
		///   <param name="condition">
		///		The condition to verify.  If the condition is false, the
		///		given message is displayed.
		///   </param>
		///   
		///   <param name="message">
		///		Message to display if the assertion fails.
		///   </param>
		///   
		///   <param name="errorType">
		///		Specifies the type of error to throw should the condition
		///		evaluate to false.
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     Calls to this function are honored, even in non-debug
		///     builds.
		///   </remarks>
		/// ****************************************************************
		[System.Diagnostics.DebuggerHidden()]
		public static void Verify( bool condition, string message, ErrorType errorType )
		{
			Verify( condition,message,errorType,null );
		}

		/// ****************************************************************
		///   public Verify [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Checks for a condition and displays a message if false.
		///   </summary>
		/// ----------------------------------------------------------------   
		///   <param name="condition">
		///		The condition to verify.  If the condition is false, the
		///		given message is displayed.
		///   </param>
		///   
		///   <param name="message">
		///		Message to display if the assertion fails.
		///   </param>
		///   
		///   <param name="errorType">
		///		Specifies the type of error to throw should the condition
		///		evaluate to false.
		///   </param>
		///   <param name="format">
		///		Error string format arguments used for localized messages.
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     Calls to this function are honored, even in non-debug
		///     builds.
		///   </remarks>
		/// ****************************************************************
		[System.Diagnostics.DebuggerHidden()]
		public static void Verify( bool condition, string message, ErrorType errorType, params object[] format )
		{
			if( false == condition )
			{
				try
				{
					//
					// Build the verify failure message.  We'll attempt to 
					// build a pretty stack trace, eliminating our frame from
					// the list.
					//
					string trace = System.Environment.StackTrace;

					int pos = trace.IndexOf( "Debug.Verify" );
					if( pos >= 0 && pos < trace.Length - 1 )
					{
						pos = trace.IndexOf( "at", pos + 1 );
						if( pos >= 0 )
							trace = "   " + trace.Substring( pos );
					}

					string text = "Verify failed: " + message + "\r\n\r\n" + 
						"Stack trace:\r\n" + trace;
					
					//
					// Write the verify failure to the debugging logs. 
					//
					Write( SeverityType.Error, CategoryType.None, text );									
				}
				catch( Exception )
				{
				}
				finally
				{
					throw new UDDIException( errorType, message,format );
				}
			}
		}

		/// ****************************************************************
		///   public VerifySetting [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///		Verifies that the specified setting exists, and writes an
		///		error to the debugger and operator log if not.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="key">
		///		Configuration setting to verify.
		///   </param>
		/// ****************************************************************
		/// 
		[System.Diagnostics.DebuggerHidden()]
		public static void VerifySetting( string key )
		{
			if( false == Config.SettingExists( key ) )
			{
				OperatorMessage(
					SeverityType.Error,
					CategoryType.Config,
					OperatorMessageType.MissingSetting,
					"Missing required setting: " + key );

				Verify( false, "Server configuration error" );
			}
		}

		/// ****************************************************************
		///   public WriteIf [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Writes a message to the debugging logs if the specified
		///     condition is true.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="condition">
		///		The condition to verify.  If the condition is true, the
		///		given message is displayed.
		///   </param>
		///   
		///   <param name="severity">
		///     The severity type.
		///   </param>
		///   
		///   <param name="category">
		///     The category type.
		///   </param>
		///   
		///   <param name="message">
		///     The message to log.
		///   </param>
		/// ****************************************************************
		/// 
		public static void WriteIf( bool condition, SeverityType severity, CategoryType category, string message )
		{
			if( true == condition )
				Write( severity, category, message );
		}

		/// ****************************************************************
		///   public Write [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Writes a message to the debugging logs.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="severity">
		///     The Severity type.
		///   </param>
		///   
		///   <param name="category">
		///     The category type.
		///   </param>
		///   
		///   <param name="message">
		///     The message to log.
		///   </param>
		/// ----------------------------------------------------------------
		///   <remarks>
		///     Debugging information is logged to the debugger, log file,
		///     and event log depending on the level of the following
		///     configuration settings:
		///     
		///			Debug.DebuggerLevel
		///			Debug.EventLogLevel
		///			Debug.FileLogLevel
		///		
		///		Where the trace level is the highest severity to log:
		///			0 = none
		///			1 = errors
		///			2 = warnings
		///			3 = failure audit messages
		///			4 = success audit messages
		///			5 = information messages
		///			6 = all (verbose)
		///   </remarks>
		/// ****************************************************************
		/// 
		public static void Write( SeverityType severity, CategoryType category, string message )
		{
			//
			// Write to the debugger if the level setting is high enough.
			//
			if( (int)severity <= debuggerLevel.GetInt() )
				WriteDebugger( severity, category, message );
	
			//
			// Write to the event log if the level setting is high enough.
			//
			if( (int)severity <= eventLogLevel.GetInt() )
				WriteEventLog( severity, category, OperatorMessageType.None, message );

			//
			// Write to the file log if the level setting is high enough.
			//
			if( (int)severity <= fileLogLevel.GetInt() )
				WriteFileLog( severity, category, message );			
		}
		

		/// ****************************************************************
		///   public WriteDebugger [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Writes a message to the debugger.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="severity">
		///     The severity type.
		///   </param>
		///   
		///   <param name="category">
		///     The category type.
		///   </param>
		///   
		///   <param name="message">
		///     The message.
		///   </param>
		/// ****************************************************************
		/// 
		public static void WriteDebugger( SeverityType severity, CategoryType category, string message )
		{
			try
			{
				string text = string.Format(
					"{0,-4}  {1,-4}  {2}",
					severity.ToString().Substring( 0, 4 ).ToUpper(),
					category.ToString().Substring( 0, 4 ).ToUpper(),
					message.Replace( "\r\n", "\r\n\t\t" ) );

				//
				// Write out the debugger message.
				//
				System.Diagnostics.Trace.WriteLine( text );
			}
			catch( Exception )
			{
				//
				// WriteDebugger is used as a last ditch logging mechanism
				// in many cases.  This should never throw an exception,
				// but if it does, there really isn't any more we can do
				// about it.  We'll simply eat the error.
				//
			}
		}

		/// ****************************************************************
		///   public WriteFileLog [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Writes a message to the file log.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="severity">
		///     The severity type.
		///   </param>
		///   
		///   <param name="category">
		///     The category type.
		///   </param>
		///   
		///   <param name="message">
		///     The message.
		///   </param>
		/// ****************************************************************
		/// 
		public static void WriteFileLog( SeverityType severity, CategoryType category, string message )
		{	
			readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

			try
			{
				//
				// If the log filename has not yet been initialized, there is nothing we
				// can log yet.
				//
				if( null == logFilename )
					return;
				
				//
				// Open the logging file, if it is not already.
				//				
				if( null == textStream )
				{
					//
					// Get the full path to our log file.
					//
					string logFilePath = logFilename.GetString();

					//
					// Pull off the directory of the log file and see if we need to 
					// create it.
					//
					string logFileDirectory = Path.GetDirectoryName( logFilePath );
					if( false == Directory.Exists( logFileDirectory ) )
					{
						Directory.CreateDirectory( logFileDirectory );
					}
					
					//
					// Append to an existing log file, or create a new one.
					//
					FileStream file = File.Open( 
						logFilePath, 
						FileMode.Append, 
						FileAccess.Write, 
						FileShare.ReadWrite );	
			
					textStream = TextWriter.Synchronized( new StreamWriter( file, System.Text.Encoding.UTF8 ) );
					textStream.NewLine = "\r\n";
				}

				//
				// Build a time string of the format: YYMMDD:hhmmss
				//
				DateTime time = DateTime.Now;
				
				string timeString = string.Format(
					"{0,-4:D4}/{1:D2}/{2:D2} {3:D2}:{4:D2}:{5:D2}",
					time.Year,				
					time.Month,
					time.Day,
					time.Hour,
					time.Minute,
					time.Second );
			
				//
				// Write out the file log entry.
				//					
				textStream.WriteLine(
					severity.ToString().Substring( 0, 4 ).ToUpper() + "  " +
					category.ToString().Substring( 0, 4 ).ToUpper() + "  " +
					timeString + "  " + 
					message.Replace( "\r\n", "\r\n\t\t" ) );

				textStream.Flush();
			}
			catch( Exception e )
			{
				WriteDebugger(
					SeverityType.Error,
					CategoryType.None,
					"Could not write to log file " + logFilename + ".\r\n\r\nDetails:\r\n" + e.ToString() );

                //
                // If for whatever reason we could not write output to the log file, we dump the logfile name,
                // and the reason to the event log.
                //
                WriteEventLog(
                    SeverityType.Error,
                    CategoryType.None,
                    OperatorMessageType.None,
                    "Could not write to log file " + logFilename + ".\r\n\r\nDetails:\r\n" + e.ToString() );
            }
			finally
			{
				readWriteLock.ReleaseReaderLock();
			}
		}

		/// ****************************************************************
		///   public WriteEventLog [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Writes a message to the event log.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="severity">
		///     The severity type.
		///   </param>
		///   
		///   <param name="category">
		///     The category type.
		///   </param>
		///   
		///   <param name="messageId">
		///	    The message type.
		///   </param>
		///   
		///   <param name="message">
		///     The message.
		///   </param>
		/// ****************************************************************
		/// 
		public static void WriteEventLog( SeverityType severity, CategoryType category, OperatorMessageType messageId, string message )
		{
			readWriteLock.AcquireReaderLock( Constants.ReadLockTimeout );

			try
			{								
				//
				// Map the severity type to an event log entry type.
				//
				System.Diagnostics.EventLogEntryType entryType;

				switch( severity )
				{
					case SeverityType.Error:
						entryType = System.Diagnostics.EventLogEntryType.Error;
						break;

					case SeverityType.Warning:
						entryType = System.Diagnostics.EventLogEntryType.Warning;
						break;

					case SeverityType.PassAudit:
						entryType = System.Diagnostics.EventLogEntryType.SuccessAudit;
						break;

					case SeverityType.FailAudit:
						entryType = System.Diagnostics.EventLogEntryType.FailureAudit;
						break;

					default:
						//
						// SeverityType.Info and Verbose are mapped to info
						//
						entryType = System.Diagnostics.EventLogEntryType.Information;
						break;
				}

				System.Diagnostics.EventLog.WriteEntry(
					"UDDIRuntime",
					message, 
					entryType,
					(int)messageId,
					(short)category );
					
			}
			catch( Exception e )
			{
				WriteDebugger(
					SeverityType.Error,
					CategoryType.None,
					"Could not write to event log.\r\n\r\nDetails:\r\n" + e.ToString() );
			}
			finally
			{
				readWriteLock.ReleaseReaderLock();
			}
		}

		//
		// Note: All calls to this function should occur in administrator initiated
		// processes. No calls to this function should as a result of an HTTP request from
		// a SOAP API.
		// This is verified to be true on 3/1/2002 by creeves
		//
		public static void OperatorMail( SeverityType severity, CategoryType category, OperatorMessageType messageId, string message )
		{
			string mailTo = Config.GetString( "Debug.MailTo", null );

			if( null == mailTo )
			{
				Debug.Write(
					SeverityType.Info,
					CategoryType.Config,
					"Skipping send of operator mail.  Configuration setting 'Debug.MailTo' not set." );

				return;
			}

			Debug.VerifySetting( "Debug.MailFrom" );

			try
			{
				string mailCc = Config.GetString( "Debug.MailCc", null );
				string mailSubject = Config.GetString( 
					"Debug.MailSubject", 
					"Operator message from {0}.  Severity: {1}, Category: {2}" );
				
				MailMessage mail = new MailMessage();

				mail.To = mailTo;
				mail.From = Config.GetString( "Debug.MailFrom" );
				mail.Subject = String.Format(
					mailSubject,
					System.Environment.MachineName,
					severity.ToString(),
					category.ToString(),
					(int)messageId );

				if( null != mailCc )
					mail.Cc = mailCc;

				mail.BodyFormat = MailFormat.Text;
				mail.Body =
					"SEVERITY: " + severity.ToString() + "\r\n" +
					"CATEGORY: " + category.ToString() + "\r\n" +
					"EVENT ID: " + (int)messageId + "\r\n\r\n" +
					message;

				SmtpMail.Send( mail );
			}
			catch( Exception e )
			{
				Debug.OperatorMessage(
					SeverityType.Error,
					CategoryType.None,
					OperatorMessageType.CouldNotSendMail,
					"Could not send operator mail.\r\n\r\nDetails:\r\n\r\n" + e.ToString() );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\uddiadconn.cs ===
using System;
using System.DirectoryServices;

namespace UDDI.ActiveDirectory
{
	/// <summary>
	/// This class manages the ServiceConnectionPoint publication into the AD
	/// </summary>
	public class UDDIServiceConnPoint
	{

		//------------------------- PUBLIC KEYWORDS -----------------------------
		//
		public const string kwdVendor			= "Microsoft Corporation";
		public const string kwdVendorGuid		= "83C29870-1DFC-11D3-A193-0000F87A9099";
		public const string kwdTechnology		= "UDDI";
		public const string kwdTechnologyVer	= "2.0";
		public const string kwdProduct			= "UDDI Services";
		public const string kwdProductGuid		= "09A92664-D144-49DB-A600-2B3ED04BF639";

		public const string kwdInquireAPI		= "Inquire API";
		public const string kwdInquireAPIGuid	= "4CD7E4BC-648B-426D-9936-443EAAC8AE23";
		public const string kwdInquireSvcClass	= "UddiInquireUrl";

		public const string kwdPublishAPI		= "Publish API";
		public const string kwdPublishAPIGuid	= "64C756D1-3374-4E00-AE83-EE12E38FAE63";
		public const string kwdPublishSvcClass	= "UddiPublishUrl";

		public const string kwdWebSiteSignature	= "Web Site";
		public const string kwdWebSiteGuid		= "316F991C-2591-4F1A-8FF1-352A76669E37";
		public const string kwdWebSiteSvcClass	= "UddiWebSiteUrl";

		public const string kwdDiscovery		= "DiscoveryUrl";
		public const string kwdDiscoveryGuid	= "1276768A-1488-4C6F-A8D8-19556C6BE583";
		public const string kwdDiscoverySvcClass= "UddiDiscoveryUrl";

		public const string kwdAddWebRef		= "Add Web Reference";
		public const string kwdAddWebRefGuid	= "CE653789-F6D4-41B7-B7F4-31501831897D";
		public const string kwdAddWebRefSvcClass= "UddiAddWebReferenceUrl";

		//-------------------------- PRIVATE DEFINITIONS --------------------------
		//
		// default keywords for the site node
		// comma separates keywords
		//
		private const string szDefSiteKeywords = kwdTechnology + "," + kwdTechnologyVer + "," +
												 kwdVendor + "," + kwdVendorGuid + "," +
												 kwdProduct + "," + kwdProductGuid;

		// INTERNAL representation of the path. Slashes will be replaced with CN's
		// Do not remove or change the separators
		private const char	 cADPathSeparator = '/';
		private const string szADUDDIRootPath = "System/Microsoft/UDDI/Sites";


		//-------------------------------------------------------------------------
		// Creates a new entry for the site, right under the root path
		// above
		//
		static public DirectoryEntry CreateSiteEntry( string siteCN )
		{
			if ( siteCN == null )
				throw new ArgumentNullException( "Site CN cannot be null" );

			if ( siteCN.Length == 0 )
				throw new ArgumentException( "Site CN cannot be empty" );

			string[] ADPath = szADUDDIRootPath.Split( cADPathSeparator );
			string	 nodeCN = NormalizeCN( siteCN );

			DirectoryEntry adRootNode = CreateFullADPath (ADPath);
		
			DirectoryEntry adSiteNode = null;
			try
			{
				adSiteNode = adRootNode.Children.Find( nodeCN, "container" );
			}
			catch (Exception)
			{
				adSiteNode = null;
			}

			if ( adSiteNode == null )
			{
				adSiteNode = adRootNode.Children.Add( nodeCN, "container" );
				adSiteNode.CommitChanges();
			}

			try
			{
				AddNodeKeywords( adSiteNode );
			}
			catch (Exception)
			{
			}

			return adSiteNode;
		}

		//
		// Removes the Site entry and all the children
		//
		public static void DeleteSiteEntry( string siteCN )
		{
			if ( siteCN == null )
				throw new ArgumentNullException( "Site CN cannot be null" );

			if ( siteCN.Length == 0 )
				throw new ArgumentException( "Site CN cannot be empty" );

			string nodeCN = NormalizeCN( siteCN );
			string fullyQualifiedPath = GetFullyQualifiedPath( "" );
			DirectoryEntry entry = new DirectoryEntry( fullyQualifiedPath );
			
			DirectoryEntry sub = entry.Children.Find( nodeCN );
			try
			{
				// first, try deleting the node as if it was a leaf
				entry.Children.Remove (sub);
				entry.CommitChanges ();
			}
			catch (Exception)	// most likely this is a tree, or we don't have permissions
			{
				// retry deleting the whole tree
				sub.DeleteTree ();
			}
		}


		// Drop + Create the whole site node
		public static DirectoryEntry ResetSiteEntry( string siteCN )
		{
			if ( siteCN == null )
				throw new ArgumentNullException( "Site CN cannot be null" );

			if ( siteCN.Length == 0 )
				throw new ArgumentException( "Site CN cannot be empty" );

			try
			{
				DeleteSiteEntry( siteCN );
			}
			catch(Exception)
			{
			}

			return CreateSiteEntry( siteCN );
		}


		//
		// Creates a Web Service entry point (e.g. Publish API)
		//
		public static void CreateEntryPoint( string siteCN, 
											 string bindingKey, string accessPoint, 
											 string serviceClass,
											 string displayName, string description, 
											 params object[] additionalKeywords )
		{
			if ( siteCN == null || bindingKey == null || accessPoint == null || serviceClass == null)
				throw new ArgumentNullException( "'Site CN', 'Binding Key', 'Acess Point' and 'Service Class' are required parameters" );

			if ( siteCN.Length == 0 || bindingKey.Length == 0 )
				throw new ArgumentException( "'Site CN', 'Binding Key', 'Acess Point' and 'Service Class' are required parameters" );

			string entryKey = NormalizeCN( bindingKey );

			//
			// first, make sure the Site node is OK
			//
			DirectoryEntry siteNode = CreateSiteEntry( siteCN );

			//
			// then see whether the entry has been created already
			//
			DirectoryEntry svcEntry = null;
			try
			{
				svcEntry = siteNode.Children.Find( entryKey, "serviceConnectionPoint" );
			}
			catch (Exception)
			{
				 svcEntry = null;
			}

			//
			// create a new entry if there is no one yet.
			// Otherwise, just leave it alone
			//
			if ( svcEntry == null )											
			{
				svcEntry = siteNode.Children.Add( entryKey, "serviceConnectionPoint" );

				// now add all the rest
				svcEntry.Properties[ "url" ].Add( accessPoint );
				
				if ( displayName != null && displayName.Length > 0 )
					svcEntry.Properties[ "displayName" ].Add( displayName );

				if ( description != null && description.Length > 0 )
					svcEntry.Properties[ "description" ].Add( description );

				svcEntry.Properties[ "serviceClassName" ].Add( serviceClass );			
				svcEntry.Properties[ "serviceBindingInformation" ].Add( accessPoint );			

				//
				// try to save...
				//
				svcEntry.CommitChanges();
			}

			// now set the keywords
			try
			{
				AddNodeKeywords( svcEntry, additionalKeywords );
			}
			catch (Exception)
			{
			}
		}


		//
		// Removes specific service "entry point" node for the Site
		// E.g., one can drop "Publish API" entry but leave the rest intact
		//
		public static void RemoveEntryPoint( string siteCN, string bindingKey )
		{
			if ( siteCN == null || bindingKey == null )
				throw new ArgumentNullException( "Neither 'Site CN' nor 'Binding Key' can be null" );

			if ( siteCN.Length == 0 || bindingKey.Length == 0 )
				throw new ArgumentException( "Neither 'Site CN' nor 'Binding Key' can be empty" );
			
			string nodeCN = NormalizeCN( siteCN );
			string subKey = NormalizeCN( bindingKey );
			string fullyQualifiedPath = GetFullyQualifiedPath( nodeCN );
			DirectoryEntry entry = new DirectoryEntry( fullyQualifiedPath );
			
			DirectoryEntry sub = entry.Children.Find( subKey );
			try
			{
				// first, try deleting the node as if it was a leaf
				entry.Children.Remove (sub);
				entry.CommitChanges ();
			}
			catch (Exception)	// most likely this is a tree, or we don't have permissions
			{
				// retry deleting the whole tree
				sub.DeleteTree ();
			}
		}

		//***************************************************************************
		// Internal helpers go here
		//

		//
		// Verifies the AD path from the root and creates the missing nodes
		// if necessary. Returns the AD Directory entry that corresponds to
		// the last (rightmost) node in the path
		//
		protected static DirectoryEntry CreateFullADPath (string[] path)
		{
			DirectoryEntry objDE = new DirectoryEntry( "LDAP://RootDSE" );
			string szNamingContext = objDE.Properties["defaultNamingContext"][0].ToString();

			DirectoryEntry adOurRoot = new DirectoryEntry ("LDAP://" + szNamingContext);
			DirectoryEntry adNode = adOurRoot;

			if ( path.Length == 0 )
				return adNode;

			foreach (string pathCN in path)
			{
				string pathPart = NormalizeCN( pathCN );

				DirectoryEntry subnode = null;
				try
				{
					subnode = adNode.Children.Find( pathPart, "container" );
				}
				catch (Exception) // not found
				{
					subnode = null;
				}

				if ( subnode == null )  // not found, go create one
				{
					subnode = adNode.Children.Add( pathPart, "container" );
					subnode.CommitChanges();
				}

				adNode = subnode;
			}

			return adNode;
		}

		//
		// Makes sure the CN node is prepended with "cn="
		//
		static protected string NormalizeCN( string szCN )
		{
			string nodeCN = szCN.ToLower();

			if ( !nodeCN.StartsWith( "cn=" ) )
				nodeCN = "CN=" + szCN;
			else
				nodeCN = szCN;

			return nodeCN;
		}


		//
		// Composes a full "path" based on the defaule naming context and our "root" path
		// Optionally, a "leaf" under the path can be specified
		//
		static protected string GetFullyQualifiedPath( string leafNode )
		{
			string[] ADPath = szADUDDIRootPath.Split( cADPathSeparator );
			string fullyQualifiedPath = "";

			if ( leafNode != null && leafNode.Length > 0 )
				fullyQualifiedPath = NormalizeCN( leafNode ) + ",";

			for (int i = ADPath.Length - 1; i >= 0; i-- )
			{
				fullyQualifiedPath += NormalizeCN( ADPath[i] );
				fullyQualifiedPath += ",";
			}

			DirectoryEntry objRoot = new DirectoryEntry ("LDAP://RootDSE");
			string szNamingContext = objRoot.Properties["defaultNamingContext"][0].ToString();

			fullyQualifiedPath = "LDAP://" + fullyQualifiedPath + szNamingContext;

			return fullyQualifiedPath;
		}


		//
		// Attempts to add the required keywords to the node
		// Sets up the "required" ones and then appends the "optional"
		//
		static protected void AddNodeKeywords( DirectoryEntry node, params object[] optionalKwds )
		{
			if ( node == null ) 
				throw new ArgumentNullException ("'Node' cannot be null");

			string[] keywords = szDefSiteKeywords.Split( ',' );
			foreach ( string szKwd in keywords )
			{
				node.Properties[ "keywords" ].Add( szKwd );
			}

			foreach ( object szOptKwd in optionalKwds )
			{
				node.Properties[ "keywords" ].Add( szOptKwd.ToString() );
			}

			node.CommitChanges();
		}	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\sql.cs ===
using System;
using System.IO;
using System.Xml;
using System.Web;
using System.Text;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Xml.Serialization;
using UDDI.Diagnostics;

namespace UDDI
{	
	public class ConnectionManager
	{
		private static string readerConnectionString;
		private static string writerConnectionString;
		
		private SqlConnection conn;
		private SqlTransaction txn;

		[ThreadStatic]
		static private ConnectionManager cm;

		private ConnectionManager( bool writeAccess, bool transactional )
		{
			try
			{
				Debug.VerifySetting( "Database.ReaderConnectionString" );
				Debug.VerifySetting( "Database.WriterConnectionString" );

				//
				// Get the database connection strings.  We do this each time a 
				// connection is opened so that an operator can change database 
				// connection strings without having to restart the server.
				//
				readerConnectionString = Config.GetString( "Database.ReaderConnectionString" );
				writerConnectionString = Config.GetString( "Database.WriterConnectionString" );
			}
			catch( UDDIException )
			{
				//
				// Treat these specially; we want to give the user a better error message since this
				// means that this web server is not associated with a UDDI site.
				//
				//throw new UDDIException( ErrorType.E_fatalError, "This web server cannot process UDDI requests because it is not part of a UDDI site or the UDDI site being used is not valid.  Ensure that values in the ReaderConnectionString and WriterConnectionString registry keys specify a valid UDDI Site." );
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_INVALID_UDDI_SITE" );
			}

			if( writeAccess )
                conn = new SqlConnection( writerConnectionString );
			else
				conn = new SqlConnection( readerConnectionString );

			conn.Open();

			if( transactional )
			{
				txn = conn.BeginTransaction();
				Debug.Write( SeverityType.Info, CategoryType.Data, "Initiating a Transaction" );
			}
		}

		public static void Open( bool writeAccess, bool transactional )
		{
			Debug.Enter();

			ConnectionManager cm = new ConnectionManager( writeAccess, transactional );
			HttpContext ctx = HttpContext.Current;

			if( null != (object) ctx )
			{
				ctx.Items[ "Connection" ] = cm;
			}
			else
			{
				ConnectionManager.cm = cm;
			}

			Debug.Leave();
		}

		public static ConnectionManager Get()
		{
			HttpContext ctx = HttpContext.Current;

			if( null != (object) ctx )
			{
				return (ConnectionManager) ctx.Items[ "Connection" ];
			}
			else
			{
				return ConnectionManager.cm;
			}
		}

		public static SqlConnection GetConnection()
		{
			ConnectionManager cm = Get();
			if( null == (object) cm )
				return null;

			return cm.conn;
		}

		public static SqlTransaction GetTransaction()
		{
			ConnectionManager cm = Get();
			if( null == (object) cm )
				return null;

			return cm.txn;
		}

		public static void BeginTransaction()
		{
			Debug.Enter();
			
			ConnectionManager cm = Get();
#if never
			Debug.Verify( null != (object)cm, "Static connection manager was null in attempt to begin transaction." );
			Debug.Verify( null != (object)cm.conn, "Database connection was null in attempt to begin transaction." );
			Debug.Verify( null == (object)cm.txn, "Database was already in a transaction in attempt to begin a new transaction." );
#endif
			Debug.Verify( null != (object)cm,		"UDDI_ERROR_TRANSACTION_BEGIN_CONNECTION_MANAGER" );
			Debug.Verify( null != (object)cm.conn,  "UDDI_ERROR_TRANSACTION_BEGIN_CONNECTION" );
			Debug.Verify( null == (object)cm.txn,	"UDDI_ERROR_ALREADY_IN_TRANSACTION" );

			cm.txn = cm.conn.BeginTransaction();

			Debug.Leave();
		}

		public static void Commit()
		{
			Debug.Enter();

			ConnectionManager cm = Get();
#if never
			Debug.Verify( null != (object)cm.conn, "Database connection was null in attempt to commit transaction." );
			Debug.Verify( null != (object)cm.txn, "Database transaction was null in attempt to commit transaction." );
#endif			
			Debug.Verify( null != (object)cm.conn, "UDDI_ERROR_TRANSACTION_COMMIT_CONNECTION" );
			Debug.Verify( null != (object)cm.txn,  "UDDI_ERROR_TRANSACTION_COMMIT_TRANSACTION" );

			cm.txn.Commit();
			cm.txn = null;

			Debug.Leave();
		}

		public static void Abort()
		{
			Debug.Enter();

			ConnectionManager cm = Get();
#if never
			Debug.Verify( null != (object)cm.conn, "Database connection was null in attempt to abort transaction." );
			Debug.Verify( null != (object)cm.txn, "Database transaction was null in attempt to abort transaction." );
#endif
			Debug.Verify( null != (object)cm.conn, "UDDI_ERROR_TRANSACTION_ABORT_CONNECTION" );
			Debug.Verify( null != (object)cm.txn,  "UDDI_ERROR_TRANSACTION_ABORT_TRANSACTION" );

			cm.txn.Rollback();
			cm.txn = null;

			Debug.Leave();
		}

		public static void Close()
		{
			Debug.Enter();

			SqlConnection cn = GetConnection();
			SqlTransaction txn = GetTransaction();

			//
			// This function can be safely called repeatedly
			if( null == (object) cn )
				return;

			cn.Close();

			HttpContext ctx = HttpContext.Current;

			if( null != (object) ctx )
			{
				ctx.Items.Remove( "Connection" );
			}
			else
			{
				ConnectionManager.cm = null;
			}

			Debug.Leave();
		}
	}

	public class SqlStoredProcedureAccessor
	{
		private SqlCommand cmd;
		private SqlParameterAccessor paramAcc;
		
		public SqlStoredProcedureAccessor()
		{
			cmd = new SqlCommand();
 
			cmd.Connection = ConnectionManager.GetConnection();
			cmd.Transaction = ConnectionManager.GetTransaction();
			cmd.CommandType = CommandType.StoredProcedure;
			
			paramAcc = new SqlParameterAccessor( cmd.Parameters );
		}		

		public SqlStoredProcedureAccessor( string procedureName )
			: this()
		{
			ProcedureName = procedureName;
		}
	
		public void Close()
		{			
			cmd.Dispose();
		}
	
		public int Fill( DataSet dataSet, string srcTable )
		{
			SqlDataAdapter adapter = new SqlDataAdapter( cmd );
			
			return adapter.Fill( dataSet, srcTable );
		}

		public string ProcedureName
		{
			get { return cmd.CommandText; }
			set { cmd.CommandText = value; }
		}

		public SqlParameterAccessor Parameters
		{
			get { return paramAcc; }
		}

		public int ExecuteNonQuery()
		{
			return cmd.ExecuteNonQuery();
		}

		public SqlDataReaderAccessor ExecuteReader()
		{
			return new SqlDataReaderAccessor( cmd.ExecuteReader() );
		}
		
		public object ExecuteScalar()
		{
			return cmd.ExecuteScalar();
		}
	}

	public class SqlParameterAccessor
	{
		private SqlParameterCollection parameters;

		public SqlParameterAccessor( SqlParameterCollection parameters )
		{
			this.parameters = parameters;
		}

		public void Clear()
		{
			parameters.Clear();
		}

		public void Add( string name, SqlDbType dbType )
		{
			Add( name, dbType, ParameterDirection.Input );
		}
		
		public void Add( string name, SqlDbType dbType, ParameterDirection direction )
		{
			parameters.Add( new SqlParameter( name, dbType ) ).Direction = direction;
		}
		
		public void Add( string name, SqlDbType dbType, int size )
		{
			Add( name, dbType, size, ParameterDirection.Input );
		}

		public void Add( string name, SqlDbType dbType, int size, ParameterDirection direction )
		{
			parameters.Add( new SqlParameter( name, dbType, size ) ).Direction = direction;
		}
		
		public void SetNull( string index )
		{
			parameters[ index ].Value = DBNull.Value;
		}

		public void SetNull( int index )
		{
			parameters[ index ].Value = DBNull.Value;
		}

		public void SetBinary( string index, byte[] data )
		{
			if( null == data )
				parameters[ index ].Value = DBNull.Value;
			else
				parameters[ index ].Value = data;
		}

		public void SetString( string index, string data )
		{
			if( null == data )
				parameters[ index ].Value = DBNull.Value;
			else
				parameters[ index ].Value = data;
		}

		public void SetString( int index, string data )
		{
			if( null == data )
				parameters[ index ].Value = DBNull.Value;
			else
				parameters[ index ].Value = data;
		}

		public void SetShort( string index, short data )
		{
			parameters[ index ].Value = data;
		}

		public void SetShort( int index, short data )
		{
			parameters[ index ].Value = data;
		}

		public void SetInt( string index, int data )
		{
			parameters[ index ].Value = data;
		}

		public void SetInt( int index, int data )
		{
			parameters[ index ].Value = data;
		}

		public void SetLong( string index, long data )
		{
			parameters[ index ].Value = data;
		}

		public void SetLong( int index, long data )
		{
			parameters[ index ].Value = data;
		}

		public void SetGuid( string index, Guid guid )
		{
			if( null == (object)guid )
				parameters[ index ].Value = DBNull.Value;
			else
				parameters[ index ].Value = guid;
		}

		public void SetGuid( int index, Guid guid )
		{
			if( null == (object)guid )
				parameters[ index ].Value = DBNull.Value;
			else
				parameters[ index ].Value = guid;
		}

		public void SetGuidFromString( string index, string guid )
		{
			try
			{
				if( Utility.StringEmpty( guid ) )
					parameters[ index ].Value = DBNull.Value;
				else
					parameters[ index ].Value = new Guid( guid );
			}
			catch
			{
				throw new UDDIException( ErrorType.E_invalidKeyPassed, "UDDI_ERROR_INVALID_KEY" );
			}
		}

		public void SetGuidFromString( int index, string guid )
		{
			try
			{
				if( Utility.StringEmpty( guid ) )
					parameters[ index ].Value = DBNull.Value;
				else
					parameters[ index ].Value = new Guid( guid );
			}
			catch
			{
				throw new UDDIException( ErrorType.E_invalidKeyPassed, "UDDI_ERROR_INVALID_KEY" );
			}
		}

		public void SetGuidFromKey( string index, string key )
		{
			try
			{
				if( Utility.StringEmpty( key ) )
					parameters[ index ].Value = DBNull.Value;
				else
					parameters[ index ].Value = Conversions.GuidFromKey( key );
			}
			catch
			{
				throw new UDDIException( ErrorType.E_invalidKeyPassed, "UDDI_ERROR_INVALID_KEY" );
			}
		}

		public void SetGuidFromKey( int index, string key )
		{
			try
			{
				if( Utility.StringEmpty( key ) )
					parameters[ index ].Value = DBNull.Value;
				else
					parameters[ index ].Value = Conversions.GuidFromKey( key );
			}
			catch
			{
				throw new UDDIException( ErrorType.E_invalidKeyPassed, "UDDI_ERROR_INVALID_KEY" );
			}
		}

		public void SetBool( string index, bool flag )
		{
			parameters[ index ].Value = flag;
		}

		public void SetBool( int index, bool flag )
		{
			parameters[ index ].Value = flag;
		}

		public void SetDateTime( string index, DateTime datetime )
		{
			parameters[ index ].Value = datetime;
		}

		public void SetDateTime( int index, DateTime datetime )
		{
			parameters[ index ].Value = datetime;
		}

		public byte[] GetBinary( string index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return null;

			return (byte[])data;
		}
		
		public string GetString( string index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return null;

			return Convert.ToString( data );
		}

		public string GetString( int index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return null;

			return Convert.ToString( data );
		}
		
		public int GetInt( string index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return 0;

			return Convert.ToInt32( data );
		}

		public int GetInt( int index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return 0;

			return Convert.ToInt32( data );
		}

		public short GetShort( string index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return 0;

			return Convert.ToInt16( data );
		}

		public short GetShort( int index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return 0;

			return Convert.ToInt16( data );
		}

		public long GetLong( string index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return 0;

			return Convert.ToInt64( data );
		}

		public long GetLong( int index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return 0;

			return Convert.ToInt64( data );
		}

		public string GetGuidString( string index )
		{
			object data = parameters[ index ].Value;
			
			if( DBNull.Value == data )
				return null;

			System.Guid guid = (System.Guid)data;
			
			return Convert.ToString( guid );
		}

		public string GetGuidString( int index )
		{
			object data = parameters[ index ].Value;
			
			if( DBNull.Value == data )
				return null;

			System.Guid guid = (System.Guid)data;
			
			return Convert.ToString( guid );
		}

		public bool GetBool( string index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return false;

			return Convert.ToBoolean( parameters[ index ].Value );
		}

		public bool GetBool( int index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return false;

			return Convert.ToBoolean( parameters[ index ].Value );
		}

		
		public object GetDateTime( string index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return null;

			return parameters[ index ].Value ;
		}

		public object GetDateTime( int index )
		{
			object data = parameters[ index ].Value;

			if( DBNull.Value == data )
				return null;

			return parameters[ index ].Value ;
		}


		public bool IsNull( string index )
		{
			return DBNull.Value == parameters[ index ].Value;
		}

		public bool IsNull( int index )
		{
			return DBNull.Value == parameters[ index ].Value;
		}	
	}

	public class SqlDataReaderAccessor
	{
		private SqlDataReader reader;

		public SqlDataReaderAccessor( SqlDataReader reader )
		{
			this.reader = reader;
		}
		
		~SqlDataReaderAccessor()
		{
		}

		public void Close()
		{
			reader.Close();
		}

		public bool Read()
		{
			return reader.Read();
		}

		public bool NextResult()
		{
			return reader.NextResult();
		}

		public bool IsDBNull( int index )
		{
			return reader.IsDBNull( index );
		}

		public byte[] GetBinary( string index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return null;

			return (byte[])data;
		}

		public string GetString( string index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return null;
			
			return Convert.ToString( data );
		}

		public string GetString( int index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return null;
			
			return Convert.ToString( data );
		}

		public int GetInt( string index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return 0;
			
			return Convert.ToInt32( data );
		}

		public int GetInt( int index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return 0;
			
			return Convert.ToInt32( data );
		}

		public short GetShort( string index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return 0;

			return Convert.ToInt16( data );
		}

		public short GetShort( int index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return 0;

			return Convert.ToInt16( data );
		}

		public long GetLong( string index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return 0;
			
			return Convert.ToInt64( data );
		}

		public long GetLong( int index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return 0;
			
			return Convert.ToInt64( data );
		}

		public string GetGuidString( string index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return null;
			
			return Convert.ToString( data );
		}

		public string GetGuidString( int index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return null;
			
			return Convert.ToString( data );
		}

		public string GetKeyFromGuid( string index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return null;
			
			return "uuid:" + Convert.ToString( data );
		}
		
		public string GetKeyFromGuid( int index )
		{
			object data = reader[ index ];

			if( DBNull.Value == data )
				return null;
			
			return "uuid:" + Convert.ToString( data );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\core\core.cs ===
using System;
using System.Data;
using System.Collections;
using System.Data.SqlClient;
using System.IO;
using System.Security.Principal;
using System.Xml;
using System.Text;
using System.Xml.Serialization;
using System.Globalization;

using UDDI.Diagnostics;

namespace UDDI
{
	//
	// 739955 - Make sure date is parsed in the same format it was written.
	//
	public class UDDILastResetDate
	{
		private const string			   dateTimeFormat = "MM/dd/yyyy HH:mm:ss";
		private static DateTimeFormatInfo  dateTimeFormatInfo;

		static UDDILastResetDate()
		{
			dateTimeFormatInfo = new DateTimeFormatInfo();			

			//
			// When you specify a '/' in a date/time format string, this tells the DateTime
			// class to use the default Date Separator, not the character '/'.  Same goes
			// for ':' and Time Separator.
			//
			// So all we do is change the defaults to '/' and ':'.
			//
			dateTimeFormatInfo.DateSeparator = "/";
			dateTimeFormatInfo.TimeSeparator = ":";
		}

		public static DateTime Get()
		{			
			return DateTime.ParseExact( Config.GetString( "Security.KeyLastResetDate" ), dateTimeFormat, dateTimeFormatInfo );				
		}

		public static void Set( DateTime dateTime )
		{			
			Config.SetString( "Security.KeyLastResetDate", dateTime.ToString( dateTimeFormat, dateTimeFormatInfo ) );
		}
	}

	public class Constants
	{
		public const int ReadLockTimeout = 120000; // milliseconds
		//
		// Subtract this offset from error numbers that come from our DB layer to get an 
		// ErrorType value.  This offset is added in our DB to keep us away from SQL-defined
		// error numbers.
		//		
		public const int ErrorTypeSQLOffset = 50000;	
		
		public const string OwningBusinessTModelKey = "uuid:4064c064-6d14-4f35-8953-9652106476a9";

		public const string UDDITypeTaxonomyTModelKey		 = "uuid:c1acf26d-9672-4404-9d70-39b756e62ab4";
		public const string UDDITypeTaxonomyWSDLSpecKeyValue = "wsdlSpec";		

		public const int Run = 1;
		public class Site
		{
			public const string Version = "";
		}
		public class Passport
		{
			public const int TimeWindow = 14400;
		}
		public class Web
		{
			public const int HttpsPort = 443;
			public const int HttpPort = 80;
			public const int BetaSite = 0;
			public const int TestSite = 0;
			public const string SiteStatus = "open";
			public const string OutageStart = "";
			public const string OutageEnd = "";
			public const int EnableRegistration = 1;
		}
		public class Security
		{
			public const int HTTPS = 1;
			
		}
		public class Debug
		{
			public const int StackTrace = 0;
		}
		public class Lengths
		{
			//public const int Behavior				=	1;
			//public const int ReplicationBehavior	=	2;
			public const int AccessPoint			=	255;
			public const int AddressLine			=	80;
			public const int AuthInfo				=	4096;
			public const int AuthorizedName			=	255;
			//public const int BindingKey			=	41;
			//public const int BusinessKey			=	41;
			//public const int ServiceKey			=	41;
			public const int Key					=	41;
			public const int TModelKey				=	255;

			public const int Description			=	255;
			public const int DiscoveryURL			=	255;
			public const int Email					=	255;
			public const int HostingRedirector		=	41;
			public const int InstanceParms			=	255;
			public const int KeyName				=	255;
			public const int KeyType				=	16;
			public const int KeyValue				=	255;
			//public const int MaxRows				=	5;
			public const int Name					=	255;
			public const int Operator				=	48;
			public const int OverviewURL			=	255;
			public const int PersonName				=	255;
			public const int Phone					=	50;
			public const int SortCode				=	10;
			public const int UploadRegister			=	255;
			public const int URLType				=	16;
			public const int UseType				=	255;
			public const int UserID					=	450;

			// additional lengths
			public const int ConfigName				=	450;
			public const int ConfigValue			=	4000;
			public const int Context				=	20;
			public const int IsoLangCode			=	17;
			public const int generic				=	20;
			public const int OperatorName			=	450;
			public const int CertSerialNo			=	450;
			public const int PublisherStatus		=	256;
			public const int SoapReplicationURL		=	4000;
			public const int CertIssuer				=	225;
			public const int CertSubject			=	225;
			public const int Certificate			=	225;
			public const int CompanyName			=	100;
			public const int City					=	100;
			public const int StateProvince			=	100;
			public const int PostalCode				=	100;
			public const int Country				=	100;
			public const int Tier					=	256;
		}
	}

	public enum EntityType
	{
		TModel						= 0, 
		BusinessEntity				= 1, 
		BusinessService				= 2,
		BindingTemplate				= 3,
		Contact						= 4,
		TModelInstanceInfo			= 5,
		InstanceDetail				= 6,
		TModelOverviewDoc			= 7,
		InstanceDetailOverviewDoc	= 8
	}
	
	public enum KeyedReferenceType
	{
		CategoryBag		= 1,
		IdentifierBag	= 2,
		Assertion		= 3
	}
	
	public enum ErrorType
	{
		E_success					= 0,
		E_nameTooLong				= 10020,
		E_tooManyOptions			= 10030,
		E_unrecognizedVersion		= 10040,
		E_unsupported				= 10050,
		E_authTokenExpired			= 10110,
		E_authTokenRequired			= 10120,
		E_operatorMismatch			= 10130, // Deprecated.
		E_userMismatch				= 10140,
		E_unknownUser				= 10150,
		E_accountLimitExceeded		= 10160,
		E_invalidKeyPassed			= 10210,
		E_invalidURLPassed			= 10220, // Deprecated.
		E_keyRetired				= 10310,
		E_busy						= 10400, // Deprecated.
		E_fatalError				= 10500,
		E_languageError				= 10060,
		E_invalidCategory			= 20000, // Deprecated.  Use E_invalidValue
		E_categorizationNotAllowed	= 20100, // Deprecated.  Use E_valueNotAllowed
		E_invalidValue				= 20200,
		E_valueNotAllowed			= 20210,
		E_invalidProjection			= 20230,
		E_assertionNotFound			= 30000,
		E_messageTooLarge			= 30110, // TODO: Error codes duplicated?
		E_invalidCompletionStatus	= 30100, // TODO: Error codes duplicated?
		E_transferAborted			= 30200,
		E_requestDenied				= 30210,
		E_publisherCancelled		= 30220,
		E_secretUnknown				= 30230		
	}

	public enum QueryType
	{
		Get			= 0,
		Find		= 1
	}

	//
	// Use this enumerated type to determine where the UDDIException instance is being
	// used.
	//
	public enum UDDITextContext
	{
		API,
		UI,
		EventLog,
		FileLog
	}

	//
	// This class should be used for any message that the user would see.  Depending on the
	// context, this class will localize it's message as the system locale, or the user's locale.
	//
	public class UDDIText
	{
		private string   defaultLocaleText;
		private string	 textName;
		private object[] textFormatParts;
		
		public UDDIText( string textName ) : this( textName, null )
		{
		}

		public UDDIText( string textName, params object[] textFormatParts )
		{	
			this.textName		 = textName;
			this.textFormatParts = textFormatParts;
			defaultLocaleText    = ConstructString( Localization.GetStringLocalMachineCulture( textName ) );			
		}

		public string GetText()
		{
			return defaultLocaleText;
		}

		public override string ToString()
		{
			return defaultLocaleText;
		}

		public string GetText( UDDITextContext context )
		{
			switch( context )
			{
				case UDDITextContext.API:
				{
					return defaultLocaleText;		
				}
				case UDDITextContext.UI:
				{					
					return ConstructString( Localization.GetString( textName ) );
				}
				case UDDITextContext.EventLog:
				{
					return defaultLocaleText;					
				}
				case UDDITextContext.FileLog:
				{
					return defaultLocaleText;					
				}
				default:
				{
					return defaultLocaleText;					
				}
			}
		}

		private string ConstructString( string stringToConstruct )
		{
			if( null != textFormatParts )
			{
				stringToConstruct = string.Format( stringToConstruct, textFormatParts );
			}

			return stringToConstruct;
		}
	}

	public class UDDIException : ApplicationException
	{
		private UDDIText uddiText;
		
		public UDDIException() : this( ErrorType.E_fatalError, "", null )
		{			
		}

		public UDDIException( ErrorType number, string errorMsgName ) : this( number, errorMsgName, null )
		{
		}

		public UDDIException( ErrorType number, string errorMsgName, params object[] errorMsgFormatParts ) : this( number, new UDDIText( errorMsgName, errorMsgFormatParts ) )
		{					
		}	
		
		public UDDIException( ErrorType number, UDDIText uddiText )
		{
			this.uddiText = uddiText;
			this.Number = number;
		}

		//
		// GetMessage will localize the exception message depending on who is 
		// using the exception.  Currently, in all cases we localize the message
		// using the server local, except if the exception is coming from the 
		// UI.
		//
		public string GetMessage( UDDITextContext context )
		{
			return uddiText.GetText( context );			
		}

		public override string Message
		{
			get
			{
				return uddiText.GetText();
			}			
		}

		public override string ToString()
		{
			return uddiText.GetText();
		}

		public ErrorType Number = 0;
	}

	public class Conversions
	{
		public static string EntityNameFromID( EntityType entityType )
		{			
			switch( entityType )
			{
				case EntityType.BusinessEntity:
					return "businessEntity";

				case EntityType.BusinessService:
					return "businessService";

				case EntityType.BindingTemplate:
					return "bindingTemplate";

				case EntityType.TModel:
					return "tModel";

				default:
					return null;
			}
		}

		/// ****************************************************************
		///   public GuidFromKey [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Converts "uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" keys to
		///     a standard GUID.
		///   </summary>
		/// ----------------------------------------------------------------
		/// <param name="key">
		///   The key to convert.
		/// </param>
		/// ----------------------------------------------------------------
		/// <returns>
		///   The equivalent GUID.
		/// </returns>
		/// ****************************************************************
		///
		public static Guid GuidFromKey( string key )
		{
			Debug.VerifyKey( key );

			return new Guid( key.Substring(5) );
		}

		/// ****************************************************************
		///   public KeyFromGuid [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Converts standard GUIDs to a key of the form
		///     "uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
		///   </summary>
		/// ----------------------------------------------------------------
		/// <param name="guid">
		///   The GUID to convert.
		/// </param>
		/// ----------------------------------------------------------------
		/// <returns>
		///   The equivalent key.
		/// </returns>
		/// ****************************************************************
		///
		public static string KeyFromGuid( Guid guid )
		{
			if( null == (object)guid )
				return null;

			return "uuid:" + Convert.ToString( guid );
		}

		/// ****************************************************************
		///   public KeyFromGuid [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Converts standard GUIDs to a key of the form
		///     "uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
		///   </summary>
		/// ----------------------------------------------------------------
		/// <param name="guid">
		///   The GUID to convert.
		/// </param>
		/// ----------------------------------------------------------------
		/// <returns>
		///   The equivalent key.
		/// </returns>
		/// ****************************************************************
		///
		public static string KeyFromGuid( string guid )
		{
			if( null == guid )
				return null;

			return "uuid:" + guid;
		}

		public static string GuidStringFromKey( string key )
		{
			//
			// Convert uuid:E31A569A-AEFF-4468-BA4D-2BF22FE4ACEE
			// to string type without uuid:
			// Example: E31A569A-AEFF-4468-BA4D-2BF22FE4ACEE
			//
			string NewGuidStr = "";

			switch ( key )
			{
				case null:
					NewGuidStr = null;
					break;

				case "":
					NewGuidStr = "";
					break;

				default:
					Debug.VerifyKey( key );
			
					NewGuidStr = new Guid( key.Substring(5) ).ToString();
					break;
			}
			
			return( NewGuidStr );
		}
	}

	/// ********************************************************************
	///   public class Utility
	/// --------------------------------------------------------------------
	///   <summary>
	///   </summary>
	/// ********************************************************************
	/// 
	public class Utility
	{
		public enum LengthBehavior
		{
			Ignore			= 0,
			Truncate		= 1,
			ThrowException	= 2
		};

		/// ****************************************************************
		///   public Iff [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Returns a particular value depending on whether the given
		///     expression is true or false.  Useful for web page templates
		///     where arbitrary expressions cannot be evaluated, but 
		///     functions that take expressions as arguments can be 
		///     evaluated.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="expression">
		///     The boolean result of an expression.
		///   </param>
		///   
		///   <param name="trueReturnValue">
		///     The object to return if the expression is true.
		///   </param>
		///   		
		///   <param name="falseReturnValue">
		///     The object to return if the expression is false.
		///   </param>
		/// ----------------------------------------------------------------
		///   <returns>
		///     The value of trueReturnValue if the expression is true,
		///     otherwise falseReturnValue.
		///   </returns>
		/// ****************************************************************
		/// 
		public static object Iff( bool expression, object trueReturnValue, object falseReturnValue )
		{
			if( expression )
				return trueReturnValue;
			else
				return falseReturnValue;
		}

		/// ****************************************************************
		///   public StringEmpty [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Checks if a string is empty.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="str">
		///     The string to check.
		///   </param>
		/// ----------------------------------------------------------------
		///   <returns>
		///     True if the string is empty or null.
		///   </returns>
		/// ****************************************************************
		/// 
		public static bool StringEmpty( string str )
		{
			if( null == str ) 
				return true;

			return String.Empty == str;
		}

		/// ****************************************************************
		///   public CollectionEmpty [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Checks if a collection is empty.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="col">
		///     The collection to check.
		///   </param>
		/// ----------------------------------------------------------------
		///   <returns>
		///     True if the collection is empty or null.
		///   </returns>
		/// ****************************************************************
		/// 
		public static bool CollectionEmpty( ICollection col )
		{
			if( null == col || 0 == col.Count )
				return true;

			return false;
		}

		/// ****************************************************************
		///   public ValidateLength [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Removes leading and trailing whitespace.
		///     The resulting string is then truncated to the specified length.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="str">
		///     The string to check.
		///   </param>
		///   
		///   <param name="field">
		///     The attribute or element from which the string came.
		///   </param>
		///   
		///   <param name="maxLength">
		///     The maximum length for the string.
		///   </param>
		/// ****************************************************************
		/// 
		public static void ValidateLength( ref string str, string field, int maxLength )
		{
			if( Utility.StringEmpty( str ) )
				return;

			//
			// Remove leading and trailing whitespace
			//
			str = str.Trim();

//			FixCRLF( ref str );

			if( str.Length > maxLength )
			{
				Debug.Write( SeverityType.Info, CategoryType.Data, "String is too long" );
				Debug.Write( SeverityType.Info, CategoryType.Data, "Trimmed length is " + str.Length.ToString() );
				Debug.Write( SeverityType.Info, CategoryType.Data, "Trimmed String follows:\n" + str );
				Debug.Write( SeverityType.Info, CategoryType.Data, "Trimmed field follows:\n" + field );

				for( int i=0; i<str.Length; i++ )
				{
					Debug.Write( SeverityType.Info, CategoryType.Data, i.ToString() + ": " + str[i].ToString() + " -- 0x" + Convert.ToInt32( str[i] ).ToString( "x" ) );
				}

				LengthBehavior mode;

				if( ContextType.Replication == Context.ContextType )
					mode = (LengthBehavior)Config.GetInt( "Length.ReplicationBehavior", (int)LengthBehavior.ThrowException );
				else
					mode = (LengthBehavior)Config.GetInt( "Length.Behavior", (int)LengthBehavior.Truncate );

				if( LengthBehavior.Truncate == mode )
				{
					str = str.Substring( 0, maxLength );
					str = str.Trim();
				}
				else if( LengthBehavior.ThrowException == mode )
				{
#if never
					throw new UDDIException( 
						ErrorType.E_nameTooLong, 
						"Field " + field + " exceeds maximum length" );
#endif
					throw new UDDIException( ErrorType.E_nameTooLong, "UDDI_ERROR_FIELD_TOO_LONG", field );
				}
			}
		}

		//
		// Strip out the non-printable characters
		//
		public static string XmlEncode( string str )
		{
			StringBuilder newstring = new StringBuilder();

			foreach( char ch in str )
			{
				//#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] |
				if( 0x09 == ch || 0x0A == ch || 0x0D == ch || ( ch >= 0x20 && ch <= 0xD7FF ) || ( ch >= 0xE000 && ch <= 0xFFFD ) )
				{
					newstring.Append( ch );
				}
			}

			return newstring.ToString();
		}

		public static string GetDefaultPublisher()
		{
			//
			// TODO: Need to do the right thing here
			//
			return "System";
		}

		//
		// TODO: remove once we have verified .NET does this for us
		//
		private static void FixCRLF( ref string str )
		{
			char[] bytes = new char[ str.Length ];
			int n = 0;
			int length = str.Length;

			for( int i = 0; i < length; i++ )
			{
				//
				// If the char is not a CR write it out
				//
				if( 0x0D != str[ i ] )
					bytes[ n++ ] = str[ i ];
				else
				{
					//
					// If a CRLF combo is found or we are on a CR
					// at the end of the string write out a LF
					//
					if( ( ( i != length - 1 ) && ( 0x0A != str[ i + 1 ] ) ) ||
						( i == length - 1 ) )
					{
						bytes[ n++ ] = (char) 0x0A;
					}
				}
			}

			str = new string( bytes, 0, n );
		}

		/// ****************************************************************
		///   public ValidateLength [static]
		/// ----------------------------------------------------------------
		///   <summary>
		///     Checks that a string is shorter than a given maximum and longer than the specified
		///     minimum. It also removes any leading or trailing whitespace.
		///   </summary>
		/// ----------------------------------------------------------------
		///   <param name="str">
		///     The string to check.
		///   </param>
		///   
		///   <param name="field">
		///     The attribute or element from which the string came.
		///   </param>
		///   
		///   <param name="maxLength">
		///     The maximum length for the string.
		///   </param>
		///   
		///   <param name="minLength">
		///     The minimum length for the string.
		///   </param>
		/// ****************************************************************
		/// 

		//
		// TODO: This function should call the other overload for ValidateLength
		//
		public static void ValidateLength( ref string str, string field, int maxLength, int minLength )
		{
			int length = 0;
			
			if( null != str )
			{
				//
				// Remove leading and trailing whitespace
				//
				str = str.Trim();
//				FixCRLF( ref str );

				length = str.Length;
			}

			if( length < minLength )
			{
#if never
				throw new UDDIException(
					ErrorType.E_fatalError,
					"Value for '" + field + "' does not meet minimum length requirement of " + minLength.ToString() );
#endif
				throw new UDDIException( ErrorType.E_fatalError, "UDDI_ERROR_FIELD_TOO_SHORT", field, minLength.ToString() );			
			}

			if( null != str && length > maxLength )
			{
				LengthBehavior mode;

				if( ContextType.Replication == Context.ContextType )
					mode = (LengthBehavior)Config.GetInt( "Length.ReplicationBehavior", (int)LengthBehavior.ThrowException );
				else
					mode = (LengthBehavior)Config.GetInt( "Length.Behavior", (int)LengthBehavior.Truncate );

				if( LengthBehavior.Truncate == mode )
				{
					str = str.Substring( 0, maxLength );
					str = str.Trim();
				}
				else if( LengthBehavior.ThrowException == mode )
				{
#if never
					throw new UDDIException( 
						ErrorType.E_nameTooLong, 
						"Field " + field + " exceeds maximum length" );
#endif
					throw new UDDIException( ErrorType.E_nameTooLong, "UDDI_ERROR_FIELD_TOO_LONG", field );						
				}
			}
		}

		/// ****************************************************************
		///   public ParseDelimitedToken [static]
		///	----------------------------------------------------------------
		///	  <summary>
		///		Retrieves a token from a string given the delimiter that
		///		immediately preceeds (and optionally, the delimiter that
		///		follows) the desired token.
		///	  </summary>
		///	----------------------------------------------------------------
		///   <param name="beginDelimiter">
		///     The starting delimiter.
		///   </param>
		///   
		///   <param name="endDelimiter">
		///     [Optional] The ending delimiter.  This can be null.
		///   </param>
		///   
		///   <param name="text">
		///     The string to search.
		///   </param>
		///	----------------------------------------------------------------
		///   <returns>
		///     The token, if successful.  Otherwise, null.
		///   </returns>
		/// ****************************************************************
		/// 
		public static string ParseDelimitedToken( string beginDelimiter, string endDelimiter, string text )
		{
			Debug.Assert( null != beginDelimiter, "beginDelimiter cannot be null" );
			Debug.Assert( null != text, "text cannot be null" );

			//
			// Find the beginning of the starting delimiter.  Add the length to
			// give the starting position of the token.
			//
			int startPos = text.IndexOf( beginDelimiter );

			if( -1 == startPos )
				return null;

			startPos += beginDelimiter.Length;

			//
			// Find the ending delimiter.  If no ending delimiter was specified, then
			// simply return the remaining string after the beginning delimiter.
			//
			if( null == endDelimiter )
				return text.Substring( startPos );

			int endPos = text.IndexOf( endDelimiter, startPos );

			if( -1 == endPos )
				return null;

			return text.Substring( startPos, endPos - startPos );
		}

		/// ****************************************************************
		///	  public IsValidKey [static]
		/// ----------------------------------------------------------------
		///   <summary> 
		///     Checks to see if the entity associated with a key actually
		///     exists in the database.
		///   </summary>
		/// ****************************************************************
		/// 	

		//
		// TODO: This function need to be re-written
		//
		public static void IsValidKey( EntityType entityType, string key )
		{
			SqlCommand cmd = new SqlCommand( "net_key_validate", ConnectionManager.GetConnection() );
			cmd.CommandType = CommandType.StoredProcedure;

			cmd.Parameters.Add( new SqlParameter( "@entityTypeID", SqlDbType.TinyInt ) ).Direction = ParameterDirection.Input;
			cmd.Parameters.Add( new SqlParameter( "@entityKey", SqlDbType.UniqueIdentifier ) ).Direction = ParameterDirection.Input;

			SqlParameterAccessor parmacc = new SqlParameterAccessor( cmd.Parameters );

			parmacc.SetShort( "@entityTypeID", (short)entityType );


			//
			// Check for a tModel key vs other
			//
			if( key.ToLower().StartsWith( "uuid:" ) )
			{
				if( entityType != EntityType.TModel )
				{
					//throw new UDDIException( ErrorType.E_invalidKeyPassed, "Only TModel Keys can start with uuid:" );
					throw new UDDIException( ErrorType.E_invalidKeyPassed, "UDDI_ERROR_INVALID_TMODEL_KEY" );
				}

				parmacc.SetGuidFromKey( "@entityKey", key );
			}
			else
			{
				if( EntityType.TModel == entityType )
				{
					//throw new UDDIException( ErrorType.E_invalidKeyPassed, "Only TModel Keys can start with uuid:" );
					throw new UDDIException( ErrorType.E_invalidKeyPassed, "UDDI_ERROR_INVALID_TMODEL_KEY" );
				}
				try
				{
					parmacc.SetGuidFromString( "@entityKey", key );
				}
				catch( Exception )
				{
					//throw new UDDIException( ErrorType.E_invalidKeyPassed, "Key has invalid format" );
					throw new UDDIException( ErrorType.E_invalidKeyPassed, "UDDI_ERROR_INVALID_KEY_FORMAT" );
				}					
			}

			cmd.ExecuteScalar(); 
		}
	}

	public class UTF8EncodedStringWriter : StringWriter
	{
		private System.Text.UTF8Encoding utfEncoding;
		
		public UTF8EncodedStringWriter() : base()
		{
			utfEncoding = new UTF8Encoding();
		}
		
		public override Encoding Encoding 
		{
			get
			{
				return utfEncoding;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\filter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by filter.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\about.h ===
#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG	m_cref;
    HBITMAP	m_hSmallImage;
    HBITMAP	m_hLargeImage;
    HBITMAP	m_hSmallImageOpen;
    HICON	m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( /* [out] */ LPOLESTR *lpDescription );
    STDMETHODIMP GetProvider( /* [out] */ LPOLESTR *lpName );
    STDMETHODIMP GetSnapinVersion( /* [out] */ LPOLESTR *lpVersion );
    STDMETHODIMP GetSnapinImage( /* [out] */ HICON *hAppIcon );
    STDMETHODIMP GetStaticFolderImage( 
				/* [out] */ HBITMAP *hSmallImage,
				/* [out] */ HBITMAP *hSmallImageOpen,
				/* [out] */ HBITMAP *hLargeImage,
				/* [out] */ COLORREF *cMask);
        
private:
    HRESULT	CSnapinAbout::AllocOleStr( LPOLESTR *lpDest, _TCHAR *szBuffer );
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\about.cpp ===
#include "about.h"
#include "resource.h"
#include "globals.h"
#include "uddi.h"

#include <crtdbg.h>
#include <atlbase.h>

CSnapinAbout::CSnapinAbout()
	: m_cref(0)
{
    OBJECT_CREATED

    m_hSmallImage = (HBITMAP) LoadImage( g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT );
    m_hLargeImage = (HBITMAP) LoadImage( g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT );

    m_hSmallImageOpen = (HBITMAP)LoadImage( g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT );
    m_hAppIcon = LoadIcon( g_hinst, MAKEINTRESOURCE( IDI_UDDIMMC ) );
}

CSnapinAbout::~CSnapinAbout()
{
    if( m_hSmallImage != NULL )
        FreeResource( m_hSmallImage );

    if( m_hLargeImage != NULL )
        FreeResource( m_hLargeImage );

    if( m_hSmallImageOpen != NULL )
        FreeResource( m_hSmallImageOpen );

    if( m_hAppIcon != NULL )
        FreeResource( m_hAppIcon );

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////
STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if( !ppv )
        return E_FAIL;

    *ppv = NULL;

    if( IsEqualIID( riid, IID_IUnknown ) )
        *ppv = static_cast<ISnapinAbout *>(this);
    else if( IsEqualIID( riid, IID_ISnapinAbout ) )
        *ppv = static_cast<ISnapinAbout *>(this);

    if( *ppv )
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement( (LONG *)&m_cref );
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if( 0 == InterlockedDecrement( (LONG *)&m_cref ) )
    {
		//
        // we need to decrement our object count in the DLL
		//
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( /* [out] */ LPOLESTR *lpDescription )
{
	if( NULL == lpDescription )
	{
		return E_INVALIDARG;
	}

    _TCHAR szDesc[MAX_PATH];
	memset( szDesc, 0, MAX_PATH * sizeof( _TCHAR ) );

    LoadString( g_hinst, IDS_UDDIMMC_SNAPINDESC, szDesc, ARRAYLEN( szDesc ) );

    return AllocOleStr( lpDescription, szDesc );
}


STDMETHODIMP CSnapinAbout::GetProvider( /* [out] */ LPOLESTR *lpName )
{
	if( NULL == lpName )
	{
		return E_INVALIDARG;
	}

	_TCHAR szProvider[ MAX_PATH ];
	memset( szProvider, 0, MAX_PATH * sizeof( _TCHAR ) );

	LoadString( g_hinst, IDS_UDDIMMC_PROVIDER, szProvider, ARRAYLEN( szProvider ) );

    return AllocOleStr( lpName, szProvider );;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( /* [out] */ LPOLESTR *lpVersion )
{
	if( NULL == lpVersion ) 
	{
		return E_INVALIDARG;
	}

	USES_CONVERSION;

	TCHAR szBuf[ MAX_PATH + 1 ] = {0};
	DWORD dwLen = GetModuleFileName( g_hinst, szBuf, MAX_PATH + 1 );
	szBuf[ MAX_PATH ] = NULL;

	if( dwLen < MAX_PATH )
	{            
		LPDWORD pTranslation    = NULL;
		UINT    uNumTranslation = 0;
		DWORD   dwHandle        = NULL;
		DWORD   dwSize          = GetFileVersionInfoSize( szBuf, &dwHandle );
		if( !dwSize ) 
			return E_FAIL;

		BYTE* pVersionInfo = new BYTE[dwSize];           
		if( !pVersionInfo ) 
			return E_OUTOFMEMORY;

		if( !GetFileVersionInfo( szBuf, dwHandle, dwSize, pVersionInfo ) ||
			!VerQueryValue( (const LPVOID)pVersionInfo, _T("\\VarFileInfo\\Translation"), (LPVOID*)&pTranslation, &uNumTranslation ) ||
			!pTranslation ) 
		{
			delete [] pVersionInfo;
	        
			pVersionInfo    = NULL;                
			pTranslation    = NULL;
			uNumTranslation = 0;

			return E_FAIL;
		}

		uNumTranslation /= sizeof(DWORD);           

		tstring strQuery = _T("\\StringFileInfo\\");            

		//
		// 8 characters for the language/char-set, 
		// 1 for the slash, 
		// 1 for terminating NULL
		//
		TCHAR szTranslation[ 128 ] = {0};            
		_sntprintf( szTranslation, 127, _T("%04x%04x\\"), LOWORD(*pTranslation), HIWORD(*pTranslation) );

		try
		{
			strQuery += szTranslation;            
			strQuery += _T("FileVersion");
		}
		catch( ... )
		{
			delete [] pVersionInfo;
			return E_OUTOFMEMORY;
		}

		LPBYTE lpVerValue = NULL;
		UINT uSize = 0;

		if( !VerQueryValue(pVersionInfo, (LPTSTR)strQuery.c_str(), (LPVOID *)&lpVerValue, &uSize) ) 
		{
			delete [] pVersionInfo;
			return E_FAIL;
		}

		//
		// Check the version            
		//
		_tcsncpy( szBuf, (LPTSTR)lpVerValue, MAX_PATH-1 );

		delete [] pVersionInfo;
	}        

    *lpVersion = (LPOLESTR)CoTaskMemAlloc( (lstrlen(szBuf) + 1) * sizeof(OLECHAR) );
    if( NULL == *lpVersion ) 
		return E_OUTOFMEMORY;

    ocscpy( *lpVersion, T2OLE(szBuf) );

    return S_OK;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( /* [out] */ HICON *hAppIcon )
{
    *hAppIcon = m_hAppIcon;

    if( NULL == *hAppIcon )
        return E_FAIL;
    else
        return S_OK;
}

STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                        /* [out] */ HBITMAP *hSmallImage,
                        /* [out] */ HBITMAP *hSmallImageOpen,
                        /* [out] */ HBITMAP *hLargeImage,
                        /* [out] */ COLORREF *cMask )
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(255, 255, 255);

    if( ( NULL == *hSmallImage ) || ( NULL == *hLargeImage ) || ( NULL == *hSmallImageOpen ) )
        return E_FAIL;
    else
        return S_OK;
}

//
// This allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
//
HRESULT CSnapinAbout::AllocOleStr( LPOLESTR *lpDest, _TCHAR *szBuffer )
{
	if( ( NULL == lpDest ) || ( NULL == szBuffer ) )
	{
		return E_INVALIDARG;
	}

	int iLen = _tcslen( szBuffer );
	
	*lpDest = reinterpret_cast<LPOLESTR>( ::CoTaskMemAlloc( ( iLen + 1 ) * sizeof( _TCHAR ) ) );
	if( NULL == *lpDest )
	{
		return E_OUTOFMEMORY;
	}

	_tcsncpy( *lpDest, szBuffer, iLen );
	(*lpDest)[iLen] = NULL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\filter\filter.cpp ===
#include <windows.h>
#include <httpext.h>
#include <httpfilt.h>

#include <string>

using namespace std;

//
// Incoming URL variables
//
string g_strPublishURL( "/publish" );
string g_strInquireURL( "/inquire" );
string g_strDiscoveryURL( "/discovery" );
string g_strReplicationURL( "/replication" );
string g_strPublishContractURL( "/publish?wsdl" );
string g_strInquireContractURL( "/inquire?wsdl" );

string g_strPublishListenerURL( "/uddi/publish.asmx" );
string g_strInquireListenerURL( "/uddi/inquire.asmx" );
string g_strDiscoveryListenerURL( "/uddi/discovery.ashx" );
string g_strReplicationListenerURL( "/uddi/replication.ashx" );
string g_strPublishContractListenerURL( "/uddi/publish.wsdl" );
string g_strInquireContractListenerURL( "/uddi/inquire.wsdl" );

BOOL WINAPI
GetFilterVersion( HTTP_FILTER_VERSION * pVer )
{
    //
    //  Specify the types and order of notification
    //
    pVer->dwFlags = SF_NOTIFY_PREPROC_HEADERS | SF_NOTIFY_URL_MAP;
    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    strcpy( pVer->lpszFilterDesc, "UDDI Services Url Map Filter" );

    return TRUE;
}


DWORD WINAPI
HttpFilterProc( HTTP_FILTER_CONTEXT* pfc, DWORD NotificationType, void* pvData )
{
	//char szMessage[ 1000 ];

	if( SF_NOTIFY_URL_MAP == NotificationType )
	{
#ifdef _DEBUG
		PHTTP_FILTER_URL_MAP pURLMap;
		pURLMap = (PHTTP_FILTER_URL_MAP) pvData;
		//sprintf( szMessage, "Physical Path: %s Buffer Size: %d\n", pURLMap->pszPhysicalPath, pURLMap->cbPathBuff );
		//OutputDebugStringA( szMessage );


        pfc->pFilterContext = 0;
#endif
	}
	else if( SF_NOTIFY_PREPROC_HEADERS == NotificationType )
	{
		PHTTP_FILTER_PREPROC_HEADERS pHeaders = (PHTTP_FILTER_PREPROC_HEADERS) pvData;

		char szUrl[ 256 ];
		char szContentType[ 256 ];

		DWORD cbUrl = sizeof(szUrl);
		DWORD cbContentType = sizeof(szContentType);
		
		BOOL bResult;
		
		//
		// Map the URL
		//		
		bResult = pHeaders->GetHeader( pfc, "url", szUrl, &cbUrl );

		//sprintf( szMessage, "URL: %s\n", szUrl );
		//OutputDebugStringA( szMessage );

		//
		// Check for Inquire API Reference
		//
		if( 0 == _stricmp( szUrl, g_strInquireURL.c_str() ) )
		{
			bResult = pHeaders->SetHeader( pfc, "url", (char*) g_strInquireListenerURL.c_str() );
		}
	
		//
		// Check for Publish API Reference
		//
		else if( 0 == _stricmp( szUrl, g_strPublishURL.c_str() ) )
		{
			bResult = pHeaders->SetHeader( pfc, "url", (char*) g_strPublishListenerURL.c_str() );
		}

		//
		// Check for Inquire API Contract Reference
		//
		else if( 0 == _stricmp( szUrl, g_strInquireContractURL.c_str() ) )
		{
			bResult = pHeaders->SetHeader( pfc, "url", (char*) g_strInquireContractListenerURL.c_str() );
		}
	
		//
		// Check for Publish API Contract Reference
		//
		else if( 0 == _stricmp( szUrl, g_strPublishContractURL.c_str() ) )
		{
			bResult = pHeaders->SetHeader( pfc, "url", (char*) g_strPublishContractListenerURL.c_str() );
		}

		//
		// Check for Replication URL Reference
		// 
		else if( 0 == _strnicmp( szUrl, g_strReplicationURL.c_str(), g_strReplicationURL.length() ) )
		{
			//
			// Amend URL to point to replication URL
			//
			string strUrl( g_strReplicationListenerURL );

			//
			// This appears to be a Replication URL
			//
			string strTemp( szUrl );

			//
			// Find the beginning of the query string
			//
			string::size_type n = strTemp.find( "?" );
			if( string::npos != n )
			{
				//
				// Found a query string
				//

				//
				// Attach the query string to the new URL
				//
				strUrl += strTemp.substr( n );
			}

			//
			// Update the headers with the new destination
			//
			bResult = pHeaders->SetHeader( pfc, "url", (char*) strUrl.c_str() );

			string strDebug = string( "\nURL mapped to: " ) + strUrl;
			OutputDebugStringA( strDebug.c_str() );

//				sprintf( szMessage, "New URL: %s\n", strUrl.c_str() );
//				OutputDebugStringA( szMessage );
		}

		//
		// Check for Discovery URL Reference
		//

		else if( 0 == _strnicmp( szUrl, g_strDiscoveryURL.c_str(), g_strDiscoveryURL.length() ) )
		{
			//
			// This appears to be a discovery URL
			//
			string strTemp( szUrl );
			string strUrl( g_strDiscoveryListenerURL );

			//
			// Find the beginning of the query string
			//
			string::size_type n = strTemp.find( "?" );
			if( string::npos != n )
			{
				//
				// Found a query string
				//

				//
				// Attach the query string to the new URL
				//
				strUrl += strTemp.substr( n );
			}

			//
			// Update the headers with the new destination
			//
			bResult = pHeaders->SetHeader( pfc, "url", (char*) strUrl.c_str() );
		}
	}

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

void WINAPI 
GetRegKeyStringValue( HKEY& hKey, const char* regKeyName, string& regKeyValue )
{
	long  nResult = ERROR_SUCCESS;
	DWORD dwType  = REG_SZ;
	DWORD dwCount  = 0;

	nResult = ::RegQueryValueExA( hKey,
								  regKeyName,
								  NULL,
								  &dwType,
								  NULL,
								  &dwCount );

	if( dwCount && ( nResult == ERROR_SUCCESS ) && ( dwType == REG_SZ || dwType == REG_EXPAND_SZ ) )
	{
		char* pszBuf = new char[ dwCount ];
		
		if( NULL != pszBuf )
		{
			__try
			{
				nResult = ::RegQueryValueExA( hKey,
											  regKeyName,
											  NULL,
											  &dwType,
											  ( LPBYTE )pszBuf,
											  &dwCount );
				regKeyValue = pszBuf;
			}
			__finally
			{
				delete [] pszBuf;
				pszBuf = NULL;
			}
		}
	}
}

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	try
	{
		if( DLL_PROCESS_ATTACH == dwReason )
		{
			DisableThreadLibraryCalls( hInstance );

			HKEY hKey = NULL;
			if ( ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
								"Software\\Microsoft\\UDDI\\Filter",
								0,
								KEY_QUERY_VALUE,
								&hKey ) == ERROR_SUCCESS ) 
			{
				GetRegKeyStringValue( hKey, "PublishURL",				  g_strPublishURL );
				GetRegKeyStringValue( hKey, "PublishListenerURL",		  g_strPublishListenerURL );
				GetRegKeyStringValue( hKey, "PublishContractURL",		  g_strPublishContractURL );			
				GetRegKeyStringValue( hKey, "PublishContractListenerURL", g_strPublishContractListenerURL );			

				GetRegKeyStringValue( hKey, "InquireURL",				  g_strInquireURL );
				GetRegKeyStringValue( hKey, "InquireListenerURL",		  g_strInquireListenerURL );
				GetRegKeyStringValue( hKey, "InquireContractURL",		  g_strInquireContractURL );			
				GetRegKeyStringValue( hKey, "InquireContractListenerURL", g_strInquireContractListenerURL );			
				
				GetRegKeyStringValue( hKey, "DiscoveryURL",			g_strDiscoveryURL );
				GetRegKeyStringValue( hKey, "DiscoveryListenerURL", g_strDiscoveryListenerURL );

				GetRegKeyStringValue( hKey, "ReplicationURL",		  g_strReplicationURL );			
				GetRegKeyStringValue( hKey, "ReplicationListenerURL", g_strReplicationListenerURL );			
										
				::RegCloseKey( hKey );
				
				string strUrls = string( "\nInquire [" ) + string( g_strInquireURL ) + string( "]: " ) + string( g_strInquireListenerURL ) +
								string( "\nPublish [" ) + string( g_strPublishURL ) + string( "]: " ) + g_strPublishListenerURL +
								string( "\nDiscovery [" ) + string( g_strDiscoveryURL ) + string( "]: " ) + g_strDiscoveryListenerURL +
								string( "\nReplication [" ) + string( g_strReplicationURL ) + string( "]: " ) + g_strReplicationListenerURL +
								string( "\nInquire Contract [" ) + string( g_strInquireContractURL ) + string( "]: " ) + string( g_strInquireContractListenerURL ) +
								string( "\nPublish Contract [" ) + string( g_strPublishContractURL ) + string( "]: " ) + g_strPublishContractListenerURL;

				OutputDebugStringA( strUrls.c_str() );
			}		
		}
		return TRUE;
	}
	catch( ... )
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\adm_execresetkeyimmediate.h ===
// adm_execresetkeyimmediate.h : Declaration of the ADM_execResetKeyImmediate class

#ifndef __ADM_EXECRESETKEYIMMEDIATE_H_
#define __ADM_EXECRESETKEYIMMEDIATE_H_

class ADM_execResetKeyImmediateAccessor
{
public:
	LONG m_RETURNVALUE;
	TCHAR m_keyLastResetDate[4001];
	CComBSTR m_connectionString;

BEGIN_PARAM_MAP(ADM_execResetKeyImmediateAccessor)
	SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
	COLUMN_ENTRY(1, m_RETURNVALUE)
	SET_PARAM_TYPE(DBPARAMIO_INPUT | DBPARAMIO_OUTPUT)
	COLUMN_ENTRY(2, m_keyLastResetDate)
END_PARAM_MAP()

DEFINE_COMMAND(ADM_execResetKeyImmediateAccessor, _T("{ ? = CALL dbo.ADM_execResetKeyImmediate;1 (?) }"))

	// You may wish to call this function if you are inserting a record and wish to
	// initialize all the fields, if you are not going to explicitly set all of them.
	void ClearRecord()
	{
		memset(this, 0, sizeof(*this));
	}
};

class ADM_execResetKeyImmediate : public CCommand<CAccessor<ADM_execResetKeyImmediateAccessor> >
{
public:
	HRESULT Open()
	{
		HRESULT hr;

		hr = OpenDataSource();
		if( FAILED(hr) )
			return hr;

		return OpenRowset();
	}
	HRESULT OpenDataSource()
	{
		HRESULT		hr;
		CDataSource db;
		m_keyLastResetDate[ 0 ] = NULL;

		hr = db.OpenFromInitializationString( m_connectionString );
		if( FAILED(hr) )
			return hr;

		return m_session.Open(db);
	}
	HRESULT OpenRowset()
	{
		return CCommand<CAccessor<ADM_execResetKeyImmediateAccessor> >::Open(m_session);
	}
	CSession	m_session;
};

#endif // __ADM_EXECRESETKEYIMMEDIATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\basesnap.h ===
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\comp.h ===
#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent, IExtendPropertySheet2, IExtendControlbar, IExtendContextMenu
{
private:
    ULONG			m_cref;
    
    IConsole*		m_ipConsole;
    IControlbar*    m_ipControlBar;
    IToolbar*       m_ipToolbar;
    IDisplayHelp*	m_ipDisplayHelp;

    HBITMAP         m_hBMapSm;
    HBITMAP         m_hBMapLg;

    class CComponentData *m_pComponentData;
    
    public:
        CComponent( CComponentData *parent );
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual HRESULT STDMETHODCALLTYPE Initialize( /* [in] */ LPCONSOLE lpConsole );
            
        virtual HRESULT STDMETHODCALLTYPE Notify( 
			/* [in] */ LPDATAOBJECT lpDataObject,
			/* [in] */ MMC_NOTIFY_TYPE event,
			/* [in] */ LPARAM arg,
			/* [in] */ LPARAM param );
	        
        virtual HRESULT STDMETHODCALLTYPE Destroy(/* [in] */ MMC_COOKIE cookie );
        
        virtual HRESULT STDMETHODCALLTYPE QueryDataObject( 
			/* [in] */ MMC_COOKIE cookie,
			/* [in] */ DATA_OBJECT_TYPES type,
			/* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject );
        
        virtual HRESULT STDMETHODCALLTYPE GetResultViewType( 
			/* [in] */ MMC_COOKIE cookie,
			/* [out] */ LPOLESTR __RPC_FAR *ppViewType,
			/* [out] */ long __RPC_FAR *pViewOptions );
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayInfo( /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem );
        
        virtual HRESULT STDMETHODCALLTYPE CompareObjects( 
			/* [in] */ LPDATAOBJECT lpDataObjectA,
			/* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
			/* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
			/* [in] */ LONG_PTR handle,
			/* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual HRESULT STDMETHODCALLTYPE QueryPagesFor( /* [in] */ LPDATAOBJECT lpDataObject );
        
        virtual HRESULT STDMETHODCALLTYPE GetWatermarks( 
			/* [in] */ LPDATAOBJECT lpIDataObject,
			/* [out] */ HBITMAP __RPC_FAR *lphWatermark,
			/* [out] */ HBITMAP __RPC_FAR *lphHeader,
			/* [out] */ HPALETTE __RPC_FAR *lphPalette,
			/* [out] */ BOOL __RPC_FAR *bStretch );

        ///////////////////////////////
        // Interface IExtendControlBar
        ///////////////////////////////
        virtual HRESULT STDMETHODCALLTYPE SetControlbar( /* [in] */ LPCONTROLBAR pControlbar );
        
        virtual HRESULT STDMETHODCALLTYPE ControlbarNotify( 
			/* [in] */ MMC_NOTIFY_TYPE event,
			/* [in] */ LPARAM arg,
			/* [in] */ LPARAM param );

		///////////////////////////////
		// Interface IExtendContextMenu
		///////////////////////////////
		virtual HRESULT STDMETHODCALLTYPE AddMenuItems(
					/* [in] */ LPDATAOBJECT piDataObject,
					/* [in] */ LPCONTEXTMENUCALLBACK piCallback,
					/* [out][in] */ long __RPC_FAR *pInsertionAllowed );

		virtual HRESULT STDMETHODCALLTYPE Command(
					/* [in] */ long lCommandID,
					/* [in] */ LPDATAOBJECT piDataObject );

    public:
        IToolbar *getToolbar() { return m_ipToolbar; }
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\comp.cpp ===
#include "comp.h"
#include "dataobj.h"
#include <crtdbg.h>
#include "resource.h"
#include "delebase.h"
#include "compdata.h"
#include "globals.h"
#include <commctrl.h>


CComponent::CComponent( CComponentData *parent )
	: m_pComponentData( parent )
	, m_cref( 0 )
	, m_ipConsole( NULL )
	, m_ipControlBar( NULL )
	, m_ipToolbar( NULL )
{
    OBJECT_CREATED

    m_hBMapSm = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDR_SMICONS) );
    m_hBMapLg = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDR_LGICONS) );
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED

    if( NULL != m_hBMapSm )
    {
        DeleteObject( m_hBMapSm );
    }

    if( NULL != m_hBMapLg )
    {
        DeleteObject( m_hBMapLg );
    }
}

STDMETHODIMP CComponent::QueryInterface( REFIID riid, LPVOID *ppv )
{
    if( !ppv )
        return E_FAIL;

    *ppv = NULL;

    if( IsEqualIID( riid, IID_IUnknown ) )
        *ppv = static_cast<IComponent *>(this);
    else if( IsEqualIID(riid, IID_IComponent) )
        *ppv = static_cast<IComponent *>(this);
    else if( IsEqualIID( riid, IID_IExtendPropertySheet ) )
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if( IsEqualIID(riid, IID_IExtendPropertySheet2 ) )
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if( IsEqualIID(riid, IID_IExtendControlbar ) )
        *ppv = static_cast<IExtendControlbar *>(this);
    else if( IsEqualIID(riid, IID_IExtendContextMenu ) )
        *ppv = static_cast<IExtendContextMenu *>(this);

    if( *ppv )
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement( (LONG *)&m_cref );
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if( 0 == InterlockedDecrement( (LONG *)&m_cref ) )
    {
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize( /* [in] */ LPCONSOLE lpConsole )
{
    HRESULT hr = S_OK;

	//
    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.
	//
    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);

    return hr;
}

STDMETHODIMP CComponent::Notify(
                    /* [in] */ LPDATAOBJECT lpDataObject,
                    /* [in] */ MMC_NOTIFY_TYPE event,
                    /* [in] */ LPARAM arg,
                    /* [in] */ LPARAM param )
{
    MMCN_Crack( FALSE, lpDataObject, NULL, this, event, arg, param );

    HRESULT hr = S_FALSE;
    CDelegationBase *base = NULL;

	//
    // We need to watch for property change and delegate it
    // a little differently, we're actually going to send
    // the CDelegationBase object pointer in the property page
    // PSN_APPLY handler via MMCPropPageNotify()
	//
    if( MMCN_PROPERTY_CHANGE != event && MMCN_VIEW_CHANGE != event )
	{
        if( NULL == lpDataObject )
            return S_FALSE;

        CDataObject *pDataObject = GetOurDataObject( lpDataObject );
        if( NULL != pDataObject )
        {
            base = pDataObject->GetBaseNodeObject();
        }

		if( ( NULL == base ) && ( MMCN_ADD_IMAGES != event ) )
		{
			return S_FALSE;
		}
    }
	else if( MMCN_PROPERTY_CHANGE == event )
	{
        base = (CDelegationBase *) param;
    }


	//
	// MMCN_VIEW_CHANGE
	//

	if( MMCN_VIEW_CHANGE == event )
	{	
		//
		// Arg holds the data. For a scope item, this is the
		// item's myhscopeitem. For a result item, this is
		// the item's nId value, but we don't use it
		// param holds the hint passed to IConsole::UpdateAllViews.
		// hint is a value of the UPDATE_VIEWS_HINT enumeration
		//
		CDataObject *pDataObject = GetOurDataObject(lpDataObject);
        if( NULL == pDataObject )
        {
            return S_FALSE;
        }
        else
        {
            base = pDataObject->GetBaseNodeObject();

            if( NULL == base )
            {
                return S_FALSE;
            }
        }

		switch( param )
		{		
			case UPDATE_SCOPEITEM:
			{
                hr = base->OnUpdateItem( m_ipConsole, (long)arg, SCOPE );
                break;
			}				
			case UPDATE_RESULTITEM:
			{
		        hr = base->OnUpdateItem( m_ipConsole, (long)arg, RESULT );
                break;
			}
		}

		return S_OK;
	}

	//
	// The remaining notifications
	//
    switch( event )
	{
    case MMCN_SHOW:
	{
        hr = base->OnShow( m_ipConsole, (BOOL) arg, (HSCOPEITEM) param );
        break;
	}

    case MMCN_ADD_IMAGES:
	{
        if( NULL == base )
        {
            IImageList *pResultImageList = (IImageList *)arg;

            if( ( NULL != pResultImageList ) && ( NULL != m_hBMapSm ) && ( NULL != m_hBMapLg ) )
            {
                hr = pResultImageList->ImageListSetStrip(
                                            (LONG_PTR *)m_hBMapSm,
                                            (LONG_PTR *)m_hBMapLg,
                                            0,
                                            RGB(0, 128, 128));
            }
        }
        else
        {
            hr = base->OnAddImages( (IImageList *) arg, (HSCOPEITEM) param );
        }
        break;
	}
    case MMCN_SELECT:
	{
        hr = base->OnSelect( this, m_ipConsole, (BOOL) LOWORD(arg), (BOOL) HIWORD(arg) );
        break;
	}

    case MMCN_RENAME:
	{
        hr = base->OnRename( (LPOLESTR) param );

		//
		// Now call IConsole::UpdateAllViews to redraw the item in all views.
		//
		hr = m_pComponentData->m_ipConsole->UpdateAllViews( lpDataObject, 0, UPDATE_RESULTITEM );
		_ASSERT( S_OK == hr);		

		break;
	}
	case MMCN_REFRESH:
	{
		//
		// We pass CComponentData's stored IConsole pointer here,
		// so that the IConsole::UpdateAllViews can be called in OnRefresh
		//
		hr = base->OnRefresh( m_pComponentData->m_ipConsole );
		break;
	}
	case MMCN_DELETE: 
	{
		//
		// First delete the selected result item
		//
		hr = base->OnDelete( m_pComponentData->m_ipConsoleNameSpace, m_ipConsole );

		//
		// Now call IConsole::UpdateAllViews to redraw all views
		// owned by the parent scope item. OnRefresh already does
		// this for us, so use it.
		//
		hr = base->OnRefresh( m_pComponentData->m_ipConsole );
		break;
	}

	//
    // Handle the property change notification if we need to do anything
    // special with it
	//
    case MMCN_PROPERTY_CHANGE:
	{
		//
		// We pass CComponentData's stored IConsole pointer here,
		// so that the IConsole::UpdateAllViews can be called in OnPropertyChange
		//
        hr = base->OnPropertyChange( m_pComponentData->m_ipConsole, this );
        break;
	}
    case MMCN_CONTEXTHELP:
	{
		hr = base->OnShowContextHelp( m_ipDisplayHelp, (LPOLESTR) base->GetHelpFile().c_str() );
		break;
    }
	}

    return hr;
}

STDMETHODIMP CComponent::Destroy( MMC_COOKIE cookie )
{
    if( m_ipConsole )
	{
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    if( m_ipDisplayHelp )
	{
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CComponent::QueryDataObject(
                        /* [in] */ MMC_COOKIE cookie,
                        /* [in] */ DATA_OBJECT_TYPES type,
                        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject )
{
    CDataObject *pObj = NULL;

    if( 0 == cookie )
        pObj = new CDataObject( (MMC_COOKIE) m_pComponentData->m_pStaticNode, type );
    else
        pObj = new CDataObject( cookie, type );

    if( !pObj )
        return E_OUTOFMEMORY;

    pObj->QueryInterface( IID_IDataObject, (void **)ppDataObject );

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                        /* [in] */ MMC_COOKIE cookie,
                        /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                        /* [out] */ long __RPC_FAR *pViewOptions )
{
    CDelegationBase *base = (CDelegationBase*) cookie;

    //
    // Ask for default listview.
    //
    if( NULL == base )
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType( ppViewType, pViewOptions );

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo( RESULTDATAITEM __RPC_FAR *pResultDataItem )
{
	if( NULL == pResultDataItem )
	{
		return E_INVALIDARG;
	}

    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

	//
    // If they are asking for the RDI_STR we have one of those to give
	//
    if( pResultDataItem->lParam )
	{
        base = (CDelegationBase*) pResultDataItem->lParam;
		if( NULL == base )
		{
			return E_INVALIDARG;
		}

        if( pResultDataItem->mask & RDI_STR )
		{
            LPCTSTR pszT = base->GetDisplayName( pResultDataItem->nCol );
			if( NULL == pszT )
			{
				return E_OUTOFMEMORY;
			}

            pResultDataItem->str = const_cast<LPOLESTR>( pszT );
        }

        if( pResultDataItem->mask & RDI_IMAGE )
		{
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                        /* [in] */ LPDATAOBJECT lpDataObjectB )
{
	if( ( NULL == lpDataObjectA ) || ( NULL == lpDataObjectB ) )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObjectA = GetOurDataObject( lpDataObjectA );
	if( NULL == pDataObjectA )
	{
		return E_FAIL;
	}

	CDataObject *pDataObjectB = GetOurDataObject( lpDataObjectB );
	if( NULL == pDataObjectB )
	{
		return E_FAIL;
	}

    CDelegationBase *baseA = pDataObjectA->GetBaseNodeObject();
	if( NULL == baseA )
	{
		return E_FAIL;
	}

    CDelegationBase *baseB = pDataObjectB->GetBaseNodeObject();
	if( NULL == baseB )
	{
		return E_FAIL;
	}

	//
    // compare the object pointers
	//
    if( baseA->GetCookie() == baseB->GetCookie() )
	{
        return S_OK;
	}
	else
	{
	    return S_FALSE;
	}
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                        /* [in] */ LONG_PTR handle,
                        /* [in] */ LPDATAOBJECT piDataObject )
{
	if( ( NULL == lpProvider ) || ( NULL == handle ) || ( NULL == piDataObject ) )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->CreatePropertyPages( lpProvider, handle );
}

HRESULT CComponent::QueryPagesFor(/* [in] */ LPDATAOBJECT piDataObject )
{
	if( NULL == piDataObject )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                        /* [in] */ LPDATAOBJECT piDataObject,
                        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                        /* [out] */ BOOL __RPC_FAR *bStretch)
{
	if( ( NULL == piDataObject ) || ( NULL == lphWatermark ) || ( NULL == lphHeader ) || ( NULL == lphPalette ) || ( NULL == bStretch ) )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->GetWatermarks( lphWatermark, lphHeader, lphPalette, bStretch );
}

///////////////////////////////
// Interface IExtendControlBar
///////////////////////////////

HRESULT CComponent::SetControlbar( /* [in] */ LPCONTROLBAR pControlbar )
{
    HRESULT hr = S_OK;

    //
    //  Clean up
    //

	//
    // If we've got a cached toolbar, release it
	//
    if( m_ipToolbar )
	{
        m_ipToolbar->Release();
        m_ipToolbar = NULL;
    }

	//
    // If we've got a cached control bar, release it
	//
    if( m_ipControlBar )
	{
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }

    //
    // Install new pieces if necessary
    //

	//
    // if a new one came in, cache and AddRef
	//
    if( pControlbar ) 
	{
        m_ipControlBar = pControlbar;
        m_ipControlBar->AddRef();

        hr = m_ipControlBar->Create(
			TOOLBAR,			// type of control to be created
            dynamic_cast<IExtendControlbar *>(this),
            reinterpret_cast<IUnknown **>(&m_ipToolbar) );

        _ASSERT(SUCCEEDED(hr));

		WCHAR szStart[ 100 ], szStop[ 100 ];
		WCHAR szStartDescription[ 256 ], szStopDescription[ 256 ];

		MMCBUTTON SnapinButtons1[] =
		{
			{ 0, ID_BUTTONSTART, TBSTATE_ENABLED, TBSTYLE_GROUP, szStart, szStartDescription },
			{ 1, ID_BUTTONSTOP,  TBSTATE_ENABLED, TBSTYLE_GROUP, szStop,  szStopDescription},
		};

		::LoadStringW( g_hinst, IDS_WEBSERVER_START, szStart, ARRAYLEN( szStart ) );
		::LoadStringW( g_hinst, IDS_WEBSERVER_START_DESCRIPTION, szStartDescription, ARRAYLEN( szStartDescription ) );
		::LoadStringW( g_hinst, IDS_WEBSERVER_STOP, szStop, ARRAYLEN( szStop ) );
		::LoadStringW( g_hinst, IDS_WEBSERVER_STOP_DESCRIPTION, szStopDescription, ARRAYLEN( szStopDescription ) );

		//
        // The IControlbar::Create AddRefs the toolbar object it created
        // so no need to do any addref on the interface.
		//

		//
        // Add the bitmap to the toolbar
		//
        HBITMAP hbmp = LoadBitmap( g_hinst, MAKEINTRESOURCE( IDR_TOOLBAR1 ) );
        hr = m_ipToolbar->AddBitmap( ARRAYLEN( SnapinButtons1 ), hbmp, 16, 16, RGB( 0, 128, 128 ) ); 
        _ASSERT( SUCCEEDED(hr) );

		//
        // Add the buttons to the toolbar
		//
        hr = m_ipToolbar->AddButtons( ARRAYLEN(SnapinButtons1), SnapinButtons1 );
        _ASSERT( SUCCEEDED(hr) );
    }

    return hr;
}

HRESULT CComponent::ControlbarNotify(
                        /* [in] */ MMC_NOTIFY_TYPE event,
                        /* [in] */ LPARAM arg,
                        /* [in] */ LPARAM param )
{
    HRESULT hr = S_OK;

    if( MMCN_SELECT == event )
	{
        BOOL bScope = (BOOL) LOWORD(arg);
        BOOL bSelect = (BOOL) HIWORD(arg);

		if( NULL == param )
		{
			return E_INVALIDARG;
		}

		CDataObject *pDataObject = GetOurDataObject( reinterpret_cast<IDataObject *>( param ) );
		if( NULL == pDataObject )
		{
			return E_FAIL;
		}

		CDelegationBase *base = pDataObject->GetBaseNodeObject();
		if( NULL == base )
		{
			return E_FAIL;
		}

        hr = base->OnSetToolbar( m_ipControlBar, m_ipToolbar, bScope, bSelect );
    } 
	else if( MMCN_BTN_CLICK == event )
	{
		if( NULL == arg )
		{
			return E_INVALIDARG;
		}

		CDataObject *pDataObject = GetOurDataObject( reinterpret_cast<IDataObject *>( arg ) );
		if( NULL == pDataObject )
		{
			return E_FAIL;
		}

		CDelegationBase *base = pDataObject->GetBaseNodeObject();
		if( NULL == base )
		{
			return E_FAIL;
		}

        hr = base->OnToolbarCommand( m_pComponentData->m_ipConsole, (MMC_CONSOLE_VERB)param, reinterpret_cast<IDataObject *>(arg) );
    }

    return hr;
}

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CComponent::AddMenuItems(
                        LPDATAOBJECT piDataObject,
                        LPCONTEXTMENUCALLBACK piCallback,
                        long __RPC_FAR *pInsertionAllowed )
{
	if( ( NULL == piDataObject ) || ( NULL == piCallback ) || ( NULL == pInsertionAllowed ) )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->OnAddMenuItems( piCallback, pInsertionAllowed );
}

HRESULT CComponent::Command( long lCommandID, LPDATAOBJECT piDataObject )
{
	if( NULL == piDataObject )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->OnMenuCommand( m_ipConsole, NULL, lCommandID, piDataObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\adm_setadminaccount.h ===
// ADM_setAdminAccount.h : Declaration of the ADM_setAdminAccount class

#ifndef __ADM_SETADMINACCOUNT_H_
#define __ADM_SETADMINACCOUNT_H_

class ADM_setAdminAccountAccessor
{
public:
	LONG m_RETURNVALUE;
	TCHAR m_accountName[129];
	CComBSTR m_connectionString;

BEGIN_PARAM_MAP(ADM_setAdminAccountAccessor)
	SET_PARAM_TYPE(DBPARAMIO_OUTPUT)
	COLUMN_ENTRY(1, m_RETURNVALUE)
	SET_PARAM_TYPE(DBPARAMIO_INPUT)
	COLUMN_ENTRY(2, m_accountName)
END_PARAM_MAP()

DEFINE_COMMAND(ADM_setAdminAccountAccessor, _T("{ ? = CALL dbo.ADM_setAdminAccount;1 (?) }"))

	// You may wish to call this function if you are inserting a record and wish to
	// initialize all the fields, if you are not going to explicitly set all of them.
	void ClearRecord()
	{
		memset(this, 0, sizeof(*this));
	}
};

class ADM_setAdminAccount : public CCommand<CAccessor<ADM_setAdminAccountAccessor> >
{
public:
	HRESULT Open()
	{
		HRESULT		hr;

		hr = OpenDataSource();
		if( FAILED(hr) )
			return hr;

		return OpenRowset();
	}

	HRESULT OpenDataSource()
	{
		HRESULT		hr;
		CDataSource db;

		hr = db.OpenFromInitializationString( m_connectionString );
		if( FAILED(hr) )
			return hr;

		return m_session.Open(db);
	}

	HRESULT OpenRowset()
	{
		return CCommand<CAccessor<ADM_setAdminAccountAccessor> >::Open(m_session);
	}

	CSession	m_session;
};

#endif // __ADM_SETADMINACCOUNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\compdata.h ===
#pragma once

#include <mmc.h>
#include "delebase.h"
#include "uddiservicesnode.h"
#include "comp.h"
#include "objidl.h"

class CComponentData 
	: public IComponentData
	, IExtendPropertySheet2
	, IExtendContextMenu
	, IPersistStream
	, ISnapinHelp2
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    BOOL				m_bExpanded;
    
    CUDDIServicesNode			*m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();

    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
    HRESULT ExtractString( IDataObject *piDataObject, CLIPFORMAT cfClipFormat, _TCHAR *pstr, DWORD cchMaxLength);
    HRESULT ExtractData( IDataObject* piDataObject, CLIPFORMAT cfClipFormat, BYTE* pbData, DWORD cbData );
	HRESULT ExtractComputerNameExt( IDataObject * pDataObject, tstring& strComputer );
    HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);


    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE Initialize( /* [in] */ LPUNKNOWN pUnknown );
    virtual HRESULT STDMETHODCALLTYPE CreateComponent( /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
    
    virtual HRESULT STDMETHODCALLTYPE Notify( 
				/* [in] */ LPDATAOBJECT lpDataObject,
				/* [in] */ MMC_NOTIFY_TYPE event,
				/* [in] */ LPARAM arg,
				/* [in] */ LPARAM param);
    
    virtual HRESULT STDMETHODCALLTYPE Destroy( void );
    
    virtual HRESULT STDMETHODCALLTYPE QueryDataObject( 
				/* [in] */ MMC_COOKIE cookie,
				/* [in] */ DATA_OBJECT_TYPES type,
				/* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
    virtual HRESULT STDMETHODCALLTYPE GetDisplayInfo( /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem );
    
    virtual HRESULT STDMETHODCALLTYPE CompareObjects( 
				/* [in] */ LPDATAOBJECT lpDataObjectA,
				/* [in] */ LPDATAOBJECT lpDataObjectB );
    
    //////////////////////////////////
    // Interface IExtendPropertySheet2
    //////////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
				/* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
				/* [in] */ LONG_PTR handle,
				/* [in] */ LPDATAOBJECT lpIDataObject );
    
    virtual HRESULT STDMETHODCALLTYPE QueryPagesFor( 
				/* [in] */ LPDATAOBJECT lpDataObject );
    
    virtual HRESULT STDMETHODCALLTYPE GetWatermarks( 
				/* [in] */ LPDATAOBJECT lpIDataObject,
				/* [out] */ HBITMAP __RPC_FAR *lphWatermark,
				/* [out] */ HBITMAP __RPC_FAR *lphHeader,
				/* [out] */ HPALETTE __RPC_FAR *lphPalette,
				/* [out] */ BOOL __RPC_FAR *bStretch );

    ///////////////////////////////
    // Interface IExtendContextMenu
    ///////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE AddMenuItems(
				/* [in] */ LPDATAOBJECT piDataObject,
				/* [in] */ LPCONTEXTMENUCALLBACK piCallback,
				/* [out][in] */ long __RPC_FAR *pInsertionAllowed );

    virtual HRESULT STDMETHODCALLTYPE Command(
				/* [in] */ long lCommandID,
				/* [in] */ LPDATAOBJECT piDataObject );

    ///////////////////////////////
    // Interface IPersistStream
    ///////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE GetClassID( /*[out]*/ CLSID *pClassID );
    virtual HRESULT STDMETHODCALLTYPE IsDirty();
    virtual HRESULT STDMETHODCALLTYPE Load( /*[unique][in]*/ IStream *pStm );
    virtual HRESULT STDMETHODCALLTYPE Save( /*[unique][in]*/ IStream *pStm, /*[in]*/ BOOL fClearDirty );
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax( /*[out]*/ ULARGE_INTEGER *pcbSize );

	///////////////////////////////
	// Interface ISnapinHelp
	///////////////////////////////
	virtual HRESULT STDMETHODCALLTYPE GetHelpTopic( LPOLESTR* lpCompiledHelpFile);
	virtual HRESULT STDMETHODCALLTYPE GetLinkedTopics( LPOLESTR* lpCompiledHelpFiles  );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\compdata.cpp ===
#include "comp.h"
#include "compdata.h"
#include "dataobj.h"
#include "resource.h"
#include <crtdbg.h>
#include "globals.h"
#include "guids.h"
#include "uddi.h"

CComponentData::CComponentData()
	: m_cref(0)
	, m_ipConsoleNameSpace(NULL)
	, m_ipConsole(NULL)
	, m_bExpanded( false )
{
    OBJECT_CREATED
	m_pStaticNode = new CUDDIServicesNode;
}

CComponentData::~CComponentData()
{
    if( m_pStaticNode ) 
	{
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////
STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if( !ppv )
        return E_FAIL;

    *ppv = NULL;

    if( IsEqualIID( riid, IID_IUnknown ) )
        *ppv = static_cast<IComponentData *>(this);
    else if( IsEqualIID( riid, IID_IComponentData ) )
        *ppv = static_cast<IComponentData *>(this);
    else if( IsEqualIID( riid, IID_IExtendPropertySheet ) ||
        IsEqualIID( riid, IID_IExtendPropertySheet2 ) )
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if( IsEqualIID(riid, IID_IExtendContextMenu ) )
        *ppv = static_cast<IExtendContextMenu *>(this);
	else if( IsEqualIID( riid, IID_IPersistStream ) ) 
		*ppv = static_cast<IPersistStream *>(this);
	else if( IsEqualIID( riid, IID_ISnapinHelp ) )
		*ppv = static_cast<ISnapinHelp *>(this);

    if( *ppv )
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement(( LONG *)&m_cref );
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if( 0 == InterlockedDecrement( (LONG *)&m_cref ) )
    {
		//
        // We need to decrement our object count in the DLL
		//
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize( LPUNKNOWN pUnknown )
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface( IID_IConsoleNameSpace, (void **) &m_ipConsoleNameSpace );
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface( IID_IConsole, (void **) &m_ipConsole );
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList( &pImageList );
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( 
		(long *) m_pStaticNode->m_pBMapSm,	// pointer to a handle
        (long *) m_pStaticNode->m_pBMapLg,	// pointer to a handle
        0,									// index of the first image in the strip
        RGB(0, 128, 128)					// color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent( LPCOMPONENT __RPC_FAR *ppComponent )
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if( NULL == pComponent )
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface( IID_IComponent, (void **)ppComponent );
}

HRESULT CComponentData::ExtractData( IDataObject* piDataObject,
                                           CLIPFORMAT   cfClipFormat,
                                           BYTE*        pbData,
                                           DWORD        cbData )
{
	HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if( NULL == stgmedium.hGlobal )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if( NULL == pbNewData )
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } 
	while( FALSE ); // false loop
    
    if( NULL != stgmedium.hGlobal )
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
} // ExtractData()

HRESULT CComponentData::ExtractString( IDataObject *piDataObject,
                                             CLIPFORMAT   cfClipFormat,
                                             WCHAR        *pstr,
                                             DWORD        cchMaxLength )
{
    return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
}

HRESULT CComponentData::ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
	return ExtractData( piDataObject, static_cast<CLIPFORMAT>(CDataObject::s_cfSnapinClsid), (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT CComponentData::ExtractComputerNameExt( IDataObject * pDataObject, tstring& strComputer )
{
	//
	// Find the computer name from the ComputerManagement snapin
	//
    CLIPFORMAT CCF_MyComputMachineName = (CLIPFORMAT) RegisterClipboardFormat( _T("MMC_SNAPIN_MACHINE_NAME") );
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { 
        CCF_MyComputMachineName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL
    };

    //
    // Allocate memory for the stream
    //
    int len = MAX_PATH;
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, len );

	if( NULL == stgmedium.hGlobal )
	{
		return ERROR_NOT_ENOUGH_MEMORY;
	}

	HRESULT hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
    _ASSERT( SUCCEEDED(hr) );

	//
	// Get the computer name
	//
    strComputer = (LPTSTR) stgmedium.hGlobal;

	GlobalFree( stgmedium.hGlobal );

    return hr;
}

HRESULT CComponentData::ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
	return ExtractData( piDataObject, static_cast<CLIPFORMAT>(CDataObject::s_cfNodeType), (PBYTE)pguidObjectType, sizeof(GUID) );
}

HRESULT CComponentData::Notify( LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param )
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	if( NULL == lpDataObject )
	{
		if( MMCN_PROPERTY_CHANGE == event )
		{
			CDelegationBase* pNode = (CDelegationBase*) param;
			if( NULL == pNode )
			{
				return E_INVALIDARG;
			}
			else
			{
				return pNode->OnPropertyChange( this->m_ipConsole, NULL );
			}
		}
		return S_FALSE;
	}

    switch( event )
    {
		case MMCN_EXPAND:
		{
			GUID guid;
			
			//
			// Extract GUID of the currently selected node type
			// from the data object
			//
			memset( &guid, 0, sizeof( GUID ) );
			hr = ExtractObjectTypeGUID( lpDataObject, &guid );
			if( FAILED( hr ) )
			{
				return E_INVALIDARG;
			}

			//
			// Check to see if the "Services and Applications" node
			// is being expanded. If so add our stuff.
			// 
			if( IsEqualGUID( guid, CLSID_CServicesAndApplications ) )
			{
				m_pStaticNode->SetExtension( true );

				//
				// Turn on Extension mode
				//
				tstring strComputerName;
				hr = ExtractComputerNameExt( lpDataObject, strComputerName );
				OutputDebugString( _T("Computer Name is: ") );
				OutputDebugString( strComputerName.c_str() );
				OutputDebugString( _T("\n") );
				m_pStaticNode->SetRemoteComputerName( strComputerName.c_str() );

				OnExpand( m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM) param );
			}
			else
			{
				//
				// Get our data object. If it is NULL, we return with S_FALSE.
				// See implementation of GetOurDataObject() to see how to
				// handle special data objects.
				//
				CDataObject *pDataObject = GetOurDataObject( lpDataObject );
				if( NULL == pDataObject )
				{
					return S_FALSE;
				}

				CDelegationBase *base = pDataObject->GetBaseNodeObject();
				if( NULL == base )
				{
					return S_FALSE;
				}

				hr = base->OnExpand( m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM) param );
			}
			break;
		}

		case MMCN_PROPERTY_CHANGE:
		{
			//
			// Get our data object. If it is NULL, we return with S_FALSE.
			// See implementation of GetOurDataObject() to see how to
			// handle special data objects.
			//
			CDataObject *pDataObject = GetOurDataObject( lpDataObject );
			if( NULL == pDataObject )
			{
				return S_FALSE;
			}

			CDelegationBase *base = pDataObject->GetBaseNodeObject();
			if( NULL == base )
			{
				return S_FALSE;
			}

			//
			// We pass CComponentData's stored IConsole pointer here,
			// so that the IConsole::UpdateAllViews can be called in OnPropertyChange
			//
			hr = base->OnPropertyChange( m_ipConsole, NULL );
			break;
		}

		case MMCN_DELETE:
		{
			//
			// Get our data object. If it is NULL, we return with S_FALSE.
			// See implementation of GetOurDataObject() to see how to
			// handle special data objects.
			//
			CDataObject *pDataObject = GetOurDataObject( lpDataObject );
			if( NULL == pDataObject )
			{
				return S_FALSE;
			}

			CDelegationBase *base = pDataObject->GetBaseNodeObject();
			if( NULL == base )
			{
				return S_FALSE;
			}

			hr = base->OnDelete( m_ipConsoleNameSpace, m_ipConsole );
			break;
		}

		case MMCN_REMOVE_CHILDREN:
		{
			OutputDebugString( _T( "inside MMCN_REMOVE_CHILDREN handler.\r\n" ) );

			HSCOPEITEM hToBeDeleted = (HSCOPEITEM)arg;
			HSCOPEITEM hStaticNodesParent = m_pStaticNode->GetParentScopeItem();
			if( hToBeDeleted == hStaticNodesParent )
			{
				hr = m_pStaticNode->RemoveChildren( m_ipConsoleNameSpace );
			}
			break;
		}

	}

    return hr;
}

HRESULT CComponentData::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
	//
	// Now fill an SCOPEDATAITEM for each item and then insert it
	//
	SCOPEDATAITEM sdi;
    
    if( !m_bExpanded )
	{
		//
        // Create the child nodes, then expand them
		//
        ZeroMemory( &sdi, sizeof(SCOPEDATAITEM) );
        sdi.mask = SDI_STR       |   // Displayname is valid
            SDI_PARAM     |   // lParam is valid
            SDI_IMAGE     |   // nImage is valid
            SDI_PARENT    |   // relativeID is valid
			SDI_OPENIMAGE |
            SDI_CHILDREN;     // cChildren is valid
        
        sdi.relativeID  = (HSCOPEITEM)parent;
        sdi.nImage      = m_pStaticNode->GetBitmapIndex();
        sdi.nOpenImage  = m_pStaticNode->GetBitmapIndex();
        sdi.displayname = MMC_CALLBACK;
        sdi.lParam      = (LPARAM) m_pStaticNode;
        sdi.cChildren   = 1;
        
        HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
		m_pStaticNode->SetScopeItemValue( sdi.ID );
		m_pStaticNode->SetParentScopeItem( sdi.relativeID );
        
        _ASSERT( SUCCEEDED(hr) );
    }
    
    return S_OK;
}

HRESULT CComponentData::Destroy( void )
{
	//
    // Free interfaces
	//
    if( m_ipConsoleNameSpace )
	{
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if( m_ipConsole )
	{
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */LPDATAOBJECT *ppDataObject )
{
    CDataObject *pObj = NULL;

    if( 0 == cookie )
        pObj = new CDataObject( (MMC_COOKIE) m_pStaticNode, type );
    else
        pObj = new CDataObject( cookie, type );

    if( !pObj )
        return E_OUTOFMEMORY;

    pObj->QueryInterface( IID_IDataObject, (void **) ppDataObject );

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo( SCOPEDATAITEM *pScopeDataItem )
{
    HRESULT hr = S_FALSE;

	//
    // If they are asking for the SDI_STR we have one of those to give
	//
    if( pScopeDataItem->lParam ) 
	{
        CDelegationBase *base = (CDelegationBase *) pScopeDataItem->lParam;
		if( NULL == base )
		{
			return hr;
		}

        if( pScopeDataItem->mask & SDI_STR ) 
		{
            LPCTSTR pszT = base->GetDisplayName();
			if( NULL == pszT )
			{
				return E_OUTOFMEMORY;
			}

            pScopeDataItem->displayname = const_cast<LPOLESTR>( pszT );
        }

        if( pScopeDataItem->mask & SDI_IMAGE )
		{
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects( LPDATAOBJECT piDataObjectA, LPDATAOBJECT piDataObjectB )
{
	if( ( NULL == piDataObjectA ) || ( NULL == piDataObjectB ) )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObjectA = GetOurDataObject( piDataObjectA );
	if( NULL == pDataObjectA )
	{
		return E_FAIL;
	}

	CDataObject *pDataObjectB = GetOurDataObject( piDataObjectB );
	if( NULL == pDataObjectB )
	{
		return E_FAIL;
	}


    CDelegationBase *baseA = pDataObjectA->GetBaseNodeObject();
	if( NULL == baseA )
	{
		return E_FAIL;
	}

    CDelegationBase *baseB = pDataObjectB->GetBaseNodeObject();
	if( NULL == baseB )
	{
		return E_FAIL;
	}

	//
    // Compare the object pointers
	//
    if( baseA->GetCookie() == baseB->GetCookie() )
	{
        return S_OK;
	}
	else
	{
	    return S_FALSE;
	}
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT piDataObject )
{
	if( ( NULL == lpProvider ) || ( NULL == handle ) || ( NULL == piDataObject ) )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->CreatePropertyPages( lpProvider, handle );
}

HRESULT CComponentData::QueryPagesFor( LPDATAOBJECT piDataObject )
{
	if( NULL == piDataObject )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT piDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
	if( ( NULL == piDataObject ) || ( NULL == lphWatermark ) || ( NULL == lphHeader ) || ( NULL == lphPalette ) || ( NULL == bStretch ) )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->GetWatermarks( lphWatermark, lphHeader, lphPalette, bStretch );
}

///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////
HRESULT CComponentData::AddMenuItems(
                                     /* [in] */ LPDATAOBJECT piDataObject,
                                     /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
                                     /* [out][in] */ long __RPC_FAR *pInsertionAllowed)
{
	if( ( NULL == piDataObject ) || ( NULL == piCallback ) || ( NULL == pInsertionAllowed ) )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->OnAddMenuItems( piCallback, pInsertionAllowed );
}

HRESULT CComponentData::Command( long lCommandID, LPDATAOBJECT piDataObject )
{
	if( NULL == piDataObject )
	{
		return E_INVALIDARG;
	}

	CDataObject *pDataObject = GetOurDataObject( piDataObject );
	if( NULL == pDataObject )
	{
		return E_FAIL;
	}

    CDelegationBase *base = pDataObject->GetBaseNodeObject();
	if( NULL == base )
	{
		return E_FAIL;
	}

    return base->OnMenuCommand( m_ipConsole, m_ipConsoleNameSpace, lCommandID, piDataObject );
}

///////////////////////////////
// Interface IPersistStream
///////////////////////////////
HRESULT CComponentData::GetClassID( /*[out]*/ CLSID *pClassID )
{
	*pClassID = m_pStaticNode->getNodeType();
	return S_OK;
}

HRESULT CComponentData::IsDirty()
{
	return m_pStaticNode->IsDirty() ? S_OK : S_FALSE;
}

HRESULT CComponentData::Load( /*[unique][in]*/ IStream *pStm )
{
	return m_pStaticNode->Load( pStm );
}

HRESULT CComponentData::Save( /*[unique][in]*/ IStream *pStm, /*[in]*/ BOOL fClearDirty )
{
	return m_pStaticNode->Save( pStm, fClearDirty );
}

HRESULT CComponentData::GetSizeMax( /*[out]*/ ULARGE_INTEGER *pcbSize )
{
	ULARGE_INTEGER cbSize = { m_pStaticNode->GetSizeMax(), 0 };
	*pcbSize = cbSize;

	return S_OK;
}

///////////////////////////////
// Interface ISnapinHelp
///////////////////////////////
HRESULT CComponentData::GetHelpTopic( LPOLESTR* lpCompiledHelpFile )
{
	try
	{
		if( NULL == lpCompiledHelpFile )
		{
			return E_INVALIDARG;
		}

		//
		// Determine the help file location based
		// on the install root
		//
		WCHAR szWindowsDir[ MAX_PATH ];
		szWindowsDir[ 0 ] = 0x00;
		UINT nSize = GetWindowsDirectoryW( szWindowsDir, MAX_PATH );
		if( 0 == nSize || nSize > MAX_PATH )
			return E_FAIL;

		wstring strHelpFile = szWindowsDir;
		strHelpFile += L"\\Help\\";

		WCHAR szHelpFileName[ 100 ];
		szHelpFileName[ 0 ] = 0x00;
		LoadString( g_hinst, IDS_UDDIMMC_HELPFILE, szHelpFileName, ARRAYLEN( szHelpFileName ) );

		strHelpFile += szHelpFileName;

		UINT nBytes = ( strHelpFile.length() + 1 ) * sizeof(WCHAR);
		*lpCompiledHelpFile = (LPOLESTR) CoTaskMemAlloc( nBytes );
		if( NULL == *lpCompiledHelpFile )
		{
			return E_OUTOFMEMORY;
		}

		memcpy( *lpCompiledHelpFile, strHelpFile.c_str(), nBytes );

		return S_OK;
	}
	catch( ... )
	{
		return E_OUTOFMEMORY;
	}
}

HRESULT CComponentData::GetLinkedTopics( LPOLESTR* lpCompiledHelpFiles  )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\uddi\source\mmc\basesnap.cpp ===
#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "comp.h"
#include "compdata.h"
#include "about.h"
#include "uddi.h"
#include <assert.h>

LONG UnRegisterServer( const CLSID& clsid );

//
// Globals Variables
//
HINSTANCE g_hinst;

BOOL WINAPI DllMain( HINSTANCE hinst, DWORD fdwReason, void* lpvReserved )
{
    if( DLL_PROCESS_ATTACH == fdwReason )
	{
		g_hinst = hinst;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if( ( rclsid != CLSID_CUDDIServices ) && ( rclsid != CLSID_CSnapinAbout ) )
        return CLASS_E_CLASSNOTAVAILABLE;
    
    if( !ppvObj )
        return E_FAIL;
    
    *ppvObj = NULL;

	//
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
	//
    if( !IsEqualIID(riid, IID_IUnknown) && !IsEqualIID( riid, IID_IClassFactory ) )
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
	//
    // make the factory passing in the creation function for the type of object they want
	//
    if( CLSID_CUDDIServices == rclsid )
        pFactory = new CClassFactory( CClassFactory::COMPONENT );
    else if( CLSID_CSnapinAbout == rclsid )
        pFactory = new CClassFactory( CClassFactory::ABOUT );
    
    if( NULL == pFactory )
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface( riid, ppvObj );
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if( ( 0 == g_uObjects ) && ( 0 == g_uSrvLock ) )
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
	: m_cref(0)
	, m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if( !ppv )
        return E_FAIL;
    
    *ppv = NULL;
    
    if( IsEqualIID( riid, IID_IUnknown ) )
        *ppv = static_cast<IClassFactory *>(this);
    else
        if( IsEqualIID(riid, IID_IClassFactory ) )
            *ppv = static_cast<IClassFactory *>(this);
        
        if( *ppv )
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement( (LONG*)&m_cref );
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if( 0 == InterlockedDecrement( (LONG *)&m_cref ) )
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj )
{
    HRESULT  hr;
    void* pObj;
    
    if( !ppvObj )
        return E_FAIL;
    
    *ppvObj = NULL;
    
	//
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
	//
    if( pUnkOuter )
        return CLASS_E_NOAGGREGATION;
    
    if( COMPONENT == m_factoryType )
	{
        pObj = new CComponentData();
    }
	else
	{
        pObj = new CSnapinAbout();
    }
    
    if( !pObj )
        return E_OUTOFMEMORY;
    
	//
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
	//
    hr = ( (LPUNKNOWN) pObj )->QueryInterface( riid, ppvObj );
    
    if( FAILED(hr) )
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
        InterlockedIncrement( (LONG *) &g_uSrvLock );
    else
        InterlockedDecrement( (LONG *) &g_uSrvLock);
    
    return S_OK;
}

//
// Register the component in the registry.
//
HRESULT RegisterServer( HMODULE hModule,				// DLL module handle
                        const CLSID& clsid,				// Class ID
                        const _TCHAR* szFriendlyName )  // IDs
{
	LPOLESTR wszCLSID = NULL;
	try
	{
		//
		// Get server location.
		//
		_TCHAR szModule[ MAX_PATH + 1];

		DWORD dwResult =
			::GetModuleFileName( hModule,
			szModule,
			sizeof(szModule)/sizeof(_TCHAR) );
		szModule[ MAX_PATH ] = NULL;

		assert( 0 != dwResult );

		//
		// Get CLSID
		//
		HRESULT hr = StringFromCLSID( clsid, &wszCLSID );
		if( FAILED(hr) || ( NULL == wszCLSID ) )
		{
			return hr;
		}

		//
		// Build the key CLSID\\{...}
		//
		tstring strKey( _T("CLSID\\") );
		strKey += wszCLSID;
		
		CUDDIRegistryKey::Create( HKEY_CLASSES_ROOT, strKey );
		CUDDIRegistryKey key( HKEY_CLASSES_ROOT, strKey );
		key.SetValue( _T(""), szFriendlyName );
		key.Close();

		strKey += _T( "\\InprocServer32" );
		CUDDIRegistryKey::Create( HKEY_CLASSES_ROOT, strKey );
		CUDDIRegistryKey keyInprocServer32( HKEY_CLASSES_ROOT, strKey );
		keyInprocServer32.SetValue( _T(""), szModule );
		keyInprocServer32.SetValue( _T("ThreadingModel"), _T("Apartment") );
		keyInprocServer32.Close();

		//
		// Free memory.
		//
		CoTaskMemFree( wszCLSID );
		return S_OK;
	}
	catch( ... )
	{
		CoTaskMemFree( wszCLSID );
		return E_OUTOFMEMORY;
	}
}


//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
	try
	{
		HRESULT hr = S_OK;
		_TCHAR szName[ 256 ];
		_TCHAR szSnapInName[ 256 ];
		_TCHAR szAboutName[ 256 ];
		_TCHAR szProvider[ 256 ];
		//
		// TODO: Fix the version thing here
		//
		//_TCHAR szVersion[ 100 ];

		LoadString( g_hinst, IDS_UDDIMMC_NAME, szName, ARRAYLEN( szName ) );
		LoadString( g_hinst, IDS_UDDIMMC_SNAPINNAME, szSnapInName, ARRAYLEN( szSnapInName ) );
		LoadString( g_hinst, IDS_UDDIMMC_ABOUTNAME, szAboutName, ARRAYLEN( szAboutName ) );
		LoadString( g_hinst, IDS_UDDIMMC_PROVIDER, szProvider, ARRAYLEN( szProvider ) );

		//
		// TODO: Fix the version thing here
		//
		//LoadString( g_hinst, IDS_UDDIMMC_VERSION, szVersion, ARRAYLEN( szVersion ) );
		
		//
		// Register our Components
		//
		hr = RegisterServer( g_hinst, CLSID_CUDDIServices, szName );
		if( FAILED(hr) )
			return hr;

		hr = RegisterServer( g_hinst, CLSID_CSnapinAbout, szAboutName );
		if( FAILED(hr) )
			return hr;

		//
		// Create the primary snapin nodes
		//
		LPOLESTR wszCLSID = NULL;
		hr = StringFromCLSID( CLSID_CUDDIServices, &wszCLSID );
		if( FAILED(hr) )
		{
			return hr;
		}

		LPOLESTR wszCLSIDAbout = NULL;
		hr = StringFromCLSID( CLSID_CSnapinAbout, &wszCLSIDAbout );
		if( FAILED(hr) )
		{
			CoTaskMemFree( wszCLSID );
			return hr;
		}

		TCHAR szPath[ MAX_PATH + 1 ];
		GetModuleFileName( g_hinst, szPath, MAX_PATH );

		tstring strNameStringIndirect( _T("@") );
		strNameStringIndirect += szPath;
		strNameStringIndirect += _T(",-");

		_TCHAR szNameResourceIndex[ 10 ];
		strNameStringIndirect += _itot( IDS_UDDIMMC_NAME, szNameResourceIndex, 10 );

		tstring strMMCKey( g_szMMCBasePath );
		strMMCKey += _T("\\SnapIns\\");
		strMMCKey += wszCLSID;

		CUDDIRegistryKey::Create( HKEY_LOCAL_MACHINE, strMMCKey );
		CUDDIRegistryKey keyMMC( strMMCKey );
		keyMMC.SetValue( _T("About"), wszCLSIDAbout );
		keyMMC.SetValue( _T("NameString"), szName );
		keyMMC.SetValue( _T("NameStringIndirect"), strNameStringIndirect.c_str() );
		keyMMC.SetValue( _T("Provider"), szProvider );
		//
		// TODO: Fix the version thing here
		//
		keyMMC.SetValue( _T("Version" ), _T("1.0") );
		keyMMC.Close();

		tstring strStandAlone( strMMCKey );
		strStandAlone += _T("\\StandAlone");
		CUDDIRegistryKey::Create( HKEY_LOCAL