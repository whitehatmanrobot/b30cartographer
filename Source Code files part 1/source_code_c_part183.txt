            TraceDebug((1, "WmipStartLogger: Referenced FDO %X %X %d\n",
                        FileObject, LoggerInfo->LogFileHandle,
                        ((POBJECT_HEADER)FileObject)->PointerCount));
            if (RequestorMode != KernelMode) {
                grantedAccess = handleInformation.GrantedAccess;
                if (!SeComputeGrantedAccesses(grantedAccess, FILE_WRITE_DATA)) {
                    TraceDebug((1, "WmipStartLogger: Deref FDO %x %d\n",
                                FileObject,
                                ((POBJECT_HEADER)FileObject)->PointerCount));
                    Status = STATUS_ACCESS_DENIED;
                }
            }
            ObDereferenceObject(FileObject);
        }

        if (!NT_SUCCESS(Status)) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipStartLogger: Status2=%X %d %d->%d\n",
                            Status, LoggerId, RefCount+1, RefCount));
            ContextTable[LoggerId] = NULL;
            return Status;
        }
    }

    LoggerContext = WmipInitContext();
    if (LoggerContext == NULL) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        Status = STATUS_NO_MEMORY;
        TraceDebug((1, "WmipStartLogger: Status5=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        return Status;
    }
#ifndef WMI_MUTEX_FREE
    WmipInitializeMutex(&LoggerContext->LoggerMutex);
#endif

    if (LogFileMode & EVENT_TRACE_USE_PAGED_MEMORY) {
        LoggerContext->PoolType = PagedPool;
        LoggerContext->LoggerMode |= EVENT_TRACE_USE_PAGED_MEMORY;
    }
    else {
        LoggerContext->PoolType = NonPagedPool;
    }

    if (LogFileMode & EVENT_TRACE_KD_FILTER_MODE) {
        LoggerContext->LoggerMode |= EVENT_TRACE_KD_FILTER_MODE;
        LoggerContext->BufferCallback = &KdReportTraceData;
    }
    LoggerContext->InstanceGuid = InstanceGuid;
    // By now, the slot will be allocated properly

    LoggerContext->MaximumFileSize = LoggerInfo->MaximumFileSize;
    LoggerContext->BuffersWritten  = LoggerInfo->BuffersWritten;

    LoggerContext->LoggerMode |= LoggerInfo->LogFileMode & 0x0000FFFF;

    // For circular logging with persistent events.
    if (!EnableKernel && LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_CIRCULAR_PERSIST) {
        LoggerContext->RequestFlag |= REQUEST_FLAG_CIRCULAR_PERSIST;
    }

    // LoggerInfo->Wow is set by the kernel in IOCTL
    LoggerContext->Wow = LoggerInfo->Wow;

    WmipValidateClockType(LoggerInfo);

    LoggerContext->UsePerfClock = LoggerInfo->Wnode.ClientContext;

    if (LoggerInfo->FlushTimer > 0)
        LoggerContext->FlushTimer = LoggerInfo->FlushTimer;

    if (LoggerInfo->AgeLimit >= 0) { // minimum is 15 minutes
        LoggerContext->BufferAgeLimit.QuadPart
            = max (DEFAULT_AGE_LIMIT, LoggerInfo->AgeLimit)
                     * WmiOneSecond.QuadPart * 60;
    }
    else if (LoggerInfo->AgeLimit < 0) {
        LoggerContext->BufferAgeLimit.QuadPart = 0;
    }

    LoggerContext->LoggerId = LoggerId;
    LoggerContext->EnableFlags = EnableFlags;
    LoggerContext->KernelTraceOn = EnableKernel;
    LoggerContext->MaximumIrql = DEFAULT_MAX_IRQL;

    if (EnableKernel) {
        //
        // Always reserve space for FileTable to allow file trace
        // to be turn on/off dynamically
        //
        WmipFileTable
            = (PFILE_OBJECT*) WmipExtendBase(
                 LoggerContext, MAX_FILE_TABLE_SIZE * sizeof(PVOID));

        Status = (WmipFileTable == NULL) ? STATUS_NO_MEMORY : STATUS_SUCCESS;
        if (NT_SUCCESS(Status)) {
            if (! RtlCreateUnicodeString(
                    &LoggerContext->LoggerName, KERNEL_LOGGER_CAPTION)) {
                Status = STATUS_NO_MEMORY;
            }
        }

        if (!NT_SUCCESS(Status)) {
            ExFreePool(LoggerContext);      // free the partial context
#if DBG
        RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipStartLogger: Status6=%X %d %d->%d\n",
                           Status, LoggerId, RefCount+1, RefCount));
            ContextTable[LoggerId] = NULL;
            return Status;
        }
    }

//
// Next, if user provided acceptable default buffer parameters, use them.
// Otherwise,  set them to predetermined default values.
//
    if (LoggerInfo->BufferSize > 0) {
        if (LoggerInfo->BufferSize > MAX_WMI_BUFFER_SIZE) {
            LoggerInfo->BufferSize = MAX_WMI_BUFFER_SIZE;
        }
        LoggerContext->BufferSize = LoggerInfo->BufferSize * 1024;
    }

    LoggerInfo->BufferSize = LoggerContext->BufferSize / 1024;
    if (LoggerInfo->MaximumBuffers >= 2) {
        LoggerContext->MaximumBuffers = LoggerInfo->MaximumBuffers;
    }

    if (LoggerInfo->MinimumBuffers >= 2 &&
        LoggerInfo->MinimumBuffers <= LoggerContext->MaximumBuffers) {
        LoggerContext->MinimumBuffers = LoggerInfo->MinimumBuffers;
    }

    RtlInitUnicodeString(&FileName, NULL);
    if (LoggerName.Buffer != NULL) {
        if (LoggerContext->KernelTraceOn) {
            RtlFreeUnicodeString(&LoggerName);
            LoggerName.Buffer = NULL;
        }
        else {
            RtlInitUnicodeString(&LoggerContext->LoggerName, LoggerName.Buffer);
        }
    }

    try {
        if (LoggerInfo->Checksum != NULL) {
            ULONG SizeNeeded = sizeof(WNODE_HEADER)
                             + sizeof(TRACE_LOGFILE_HEADER);
            if (RequestorMode != KernelMode) {
                ProbeForRead(LoggerInfo->Checksum, SizeNeeded, sizeof(UCHAR));
            }
            LoggerContext->LoggerHeader =
                    ExAllocatePoolWithTag(PagedPool, SizeNeeded, TRACEPOOLTAG);
            if (LoggerContext->LoggerHeader != NULL) {
                RtlCopyMemory(LoggerContext->LoggerHeader,
                              LoggerInfo->Checksum,
                              SizeNeeded);
            }
        }
        if (LoggerContext->KernelTraceOn) {
            if (RequestorMode != KernelMode) {
                ProbeForWrite(
                    LoggerInfo->LoggerName.Buffer,
                    LoggerContext->LoggerName.Length + sizeof(WCHAR),
                    sizeof (UCHAR) );
            }
            RtlCopyUnicodeString(
                &LoggerInfo->LoggerName, &LoggerContext->LoggerName);
        }
        if (LoggerInfo->LogFileName.Length > 0) {
            if (RequestorMode != KernelMode) {
                ProbeForRead(
                    LoggerInfo->LogFileName.Buffer,
                    LoggerInfo->LogFileName.Length,
                    sizeof (UCHAR) );
            }
            if (! RtlCreateUnicodeString(
                    &FileName,
                    LoggerInfo->LogFileName.Buffer) ) {
                Status = STATUS_NO_MEMORY;
            }
        }

        //
        // Set up the Global mask for Perf traces
        //
        if (IsGlobalForKernel || IsKernelRealTimeNoFile) {
            if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                GroupMaskSize = FlagExt->Length * sizeof(ULONG);
                if (GroupMaskSize < sizeof(PERFINFO_GROUPMASK)) {
                    GroupMaskSize = sizeof(PERFINFO_GROUPMASK);
                }
            } else {
                GroupMaskSize = sizeof(PERFINFO_GROUPMASK);
            }
    
            LoggerContext->EnableFlagArray = (PULONG) WmipExtendBase(LoggerContext, GroupMaskSize);
    
            if (LoggerContext->EnableFlagArray) {
                PCHAR FlagArray;

                RtlZeroMemory(LoggerContext->EnableFlagArray, GroupMaskSize);
                if (EnableFlags & EVENT_TRACE_FLAG_EXTENSION) {
                    FlagArray = (PCHAR) (FlagExt->Offset + (PCHAR) LoggerInfo);
    
                    //
                    // Copy only the bytes actually supplied
                    //
                    RtlCopyMemory(LoggerContext->EnableFlagArray, FlagArray, FlagExt->Length * sizeof(ULONG));

                    LoggerContext->EnableFlags = LoggerContext->EnableFlagArray[0];
    
                } else {
                    LoggerContext->EnableFlagArray[0] = EnableFlags;
                }
    
                PerfGroupMasks = (PERFINFO_GROUPMASK *) &LoggerContext->EnableFlagArray[0];
            } else {
                Status = STATUS_NO_MEMORY;
            }
        } else {
            ASSERT((EnableFlags & EVENT_TRACE_FLAG_EXTENSION) ==0);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
    //
    // The context is partially set up by now, so have to clean up
    //
        if (LoggerContext->LoggerName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerContext->LoggerName);
        }
        if (FileName.Buffer != NULL) {
            RtlFreeUnicodeString(&FileName);
        }

        if (LoggerContext->LoggerHeader != NULL) {
            ExFreePool(LoggerContext->LoggerHeader);
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipStartLogger: Status7=EXCEPTION %d %d->%d\n",
                       LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        ExFreePool(LoggerContext);      // free the partial context
        return GetExceptionCode();
    }

    if (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE) {
        RtlInitUnicodeString(&LoggerContext->LogFilePattern, FileName.Buffer);
        Status = WmipGenerateFileName(
                    &LoggerContext->LogFilePattern,
                    &LoggerContext->FileCounter,
                    &LoggerContext->LogFileName);
        if (!NT_SUCCESS(Status)) {
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipStartLogger: Status8=%X %d %d->%d\n",
                            Status, LoggerId, RefCount+1, RefCount));
            ContextTable[LoggerId] = NULL;
            if (LoggerContext->LoggerHeader != NULL) {
                ExFreePool(LoggerContext->LoggerHeader);
            }
            if (LoggerContext->LoggerName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LoggerName);
            }
            if (LoggerContext->LogFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFileName);
            }
            if (LoggerContext->LogFilePattern.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFilePattern);
            }
            ExFreePool(LoggerContext);
            return(Status);
        }
    }
    else {
        RtlInitUnicodeString(&LoggerContext->LogFileName, FileName.Buffer);
    }

    if (NT_SUCCESS(Status)) {
        // Obtain the security context here so we can use it
        // later to impersonate the user, which we will do
        // if we cannot access the file as SYSTEM.  This
        // usually occurs if the file is on a remote machine.
        //
        ServiceQos.Length  = sizeof(SECURITY_QUALITY_OF_SERVICE);
        ServiceQos.ImpersonationLevel = SecurityImpersonation;
        ServiceQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        ServiceQos.EffectiveOnly = TRUE;
        Status = SeCreateClientSecurity(
                    CONTAINING_RECORD(KeGetCurrentThread(), ETHREAD, Tcb),
                    &ServiceQos,
                    FALSE,
                    &LoggerContext->ClientSecurityContext);
    }
    if (!NT_SUCCESS(Status)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipStartLogger: Status8=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        if (LoggerContext != NULL) {
            if (LoggerContext->LoggerHeader != NULL) {
                ExFreePool(LoggerContext->LoggerHeader);
            }
            if (LoggerContext->LoggerName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LoggerName);
            }
            if (LoggerContext->LogFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFileName);
            }
            if (LoggerContext->LogFilePattern.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFilePattern);
            }
            ExFreePool(LoggerContext);
        }
        return(Status);
    }

    //
    // Now, allocate the buffer pool and associated buffers.
    // Note that buffer allocation routine will also set NumberOfBuffers and
    // MaximumBuffers.
    //

    InitializeSListHead (&LoggerContext->FreeList);
    InitializeSListHead (&LoggerContext->FlushList);
    InitializeSListHead (&LoggerContext->WaitList);
    InitializeSListHead (&LoggerContext->GlobalList);

#ifdef NTPERF
    //
    // Check if we are logging into perfmem.
    //
    if (PERFINFO_IS_PERFMEM_ALLOCATED()) {
        if (NT_SUCCESS(PerfInfoStartPerfMemLog())) {
            LoggerContext->MaximumBuffers = PerfQueryBufferSizeBytes()/LoggerContext->BufferSize;
        }
    }
#endif //NTPERF

    Status = WmipAllocateTraceBufferPool(LoggerContext);
    if (!NT_SUCCESS(Status)) {
        if (LoggerContext != NULL) {
            if (LoggerContext->LoggerHeader != NULL) {
                ExFreePool(LoggerContext->LoggerHeader);
            }
            if (LoggerContext->LoggerName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LoggerName);
            }
            if (LoggerContext->LogFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFileName);
            }
            if (LoggerContext->LogFilePattern.Buffer != NULL) {
                RtlFreeUnicodeString(&LoggerContext->LogFilePattern);
            }
            ExFreePool(LoggerContext);
        }
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipStartLogger: Status9=%X %d %d->%d\n",
                        Status, LoggerId, RefCount+1, RefCount));
        ContextTable[LoggerId] = NULL;
        return Status;
    }

    //
    // From this point on, LoggerContext is a valid structure
    //
    LoggerInfo->NumberOfBuffers = (ULONG) LoggerContext->NumberOfBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->FreeBuffers     = (ULONG) LoggerContext->BuffersAvailable;
    LoggerInfo->EnableFlags     = LoggerContext->EnableFlags;
    LoggerInfo->AgeLimit        = (ULONG) (LoggerContext->BufferAgeLimit.QuadPart
                                    / WmiOneSecond.QuadPart / 60);
    LoggerInfo->BufferSize = LoggerContext->BufferSize / 1024;

    WmiSetLoggerId(LoggerId,
                (PTRACE_ENABLE_CONTEXT)&LoggerInfo->Wnode.HistoricalContext);

    if (LoggerContext->LoggerMode & EVENT_TRACE_USE_LOCAL_SEQUENCE)
        LoggerContext->SequencePtr = (PLONG) &LoggerContext->LocalSequence;
    else if (LoggerContext->LoggerMode & EVENT_TRACE_USE_GLOBAL_SEQUENCE)
        LoggerContext->SequencePtr = (PLONG) &WmipGlobalSequence;

// Initialize synchronization event with logger
    KeInitializeEvent(
        &LoggerContext->LoggerEvent,
        NotificationEvent,
        FALSE
        );
    KeInitializeEvent(
        &LoggerContext->FlushEvent,
        NotificationEvent,
        FALSE
        );

//
// Close file handle here so that it can be opened by system thread
//
    if (LoggerInfo->LogFileHandle != NULL) {
        ZwClose(LoggerInfo->LogFileHandle);
        LoggerInfo->LogFileHandle = NULL;
    }

    //
    // User Mode call always gets APPEND mode
    // 
    LogFileMode = LoggerContext->LoggerMode;

    if (RequestorMode != KernelMode) {
        LoggerContext->LoggerMode |= EVENT_TRACE_FILE_MODE_APPEND;
    }

    //
    // Lock down the routines that need to be non-pageable
    //
    KeAcquireGuardedMutex(&WmipTraceGuardedMutex);
    if (++WmipLoggerCount == 1) {

        ASSERT(EtwpPageLockHandle);
        MmLockPagableSectionByHandle(EtwpPageLockHandle);
        WmipGlobalSequence = 0;
    }
    KeReleaseGuardedMutex(&WmipTraceGuardedMutex);

//
// Start up the logger as a system thread
//
    if (NT_SUCCESS(Status)) {
        Status = PsCreateSystemThread(
                    &ThreadHandle,
                    THREAD_ALL_ACCESS,
                    NULL,
                    NULL,
                    NULL,
                    WmipLogger,
                    LoggerContext );

        if (NT_SUCCESS(Status)) {  // if SystemThread is started
            ZwClose (ThreadHandle);

        // Wait for Logger to start up properly before proceeding
        //
            KeWaitForSingleObject(
                        &LoggerContext->LoggerEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        &TimeOut
                        );

            KeResetEvent(&LoggerContext->LoggerEvent);
        //
        // If the logger is up and running properly, we can now turn on
        // event tracing if kernel tracing is requested
        //
            if (NT_SUCCESS(LoggerContext->LoggerStatus)) {
                LoggerContext->LoggerMode = LogFileMode;

                LoggerContext->WriteFailureLimit = 100;
#ifdef NTPERF
                if (EnableKernel) {
                    WmiGetCpuClock = &PerfGetCycleCount;
                }
                LoggerContext->GetCpuClock = &PerfGetCycleCount;
#else
                switch (LoggerContext->UsePerfClock) {
                    case EVENT_TRACE_CLOCK_PERFCOUNTER: 
                            if (EnableKernel) {
                                WmiGetCpuClock = &WmipGetPerfCounter; 
                            }
                            LoggerContext->GetCpuClock = &WmipGetPerfCounter;
                            break;
                    case EVENT_TRACE_CLOCK_SYSTEMTIME: 
                    default : 
                            if (EnableKernel) {
                                WmiGetCpuClock = &WmipGetSystemTime;
                            }
                            LoggerContext->GetCpuClock = &WmipGetSystemTime;
                            break;
                }
#endif //NTPERF

                //
                // At this point, the clock type should be set and we take a
                // reference timesamp, which should be the earliest timestamp 
                // for the logger.  The order is this way sine SystemTime
                // is typically cheaper to obtain. 
                // 

#ifdef NTPERF
                PerfTimeStamp(LoggerContext->ReferenceTimeStamp);
#else
                LoggerContext->ReferenceTimeStamp.QuadPart = (*LoggerContext->GetCpuClock)();
#endif
                KeQuerySystemTime(&LoggerContext->ReferenceSystemTime);

                //
                // After we release this mutex, any other thread can acquire
                // the valid logger context and call the shutdown path for 
                // this logger.  Until this, no other thread can call the enable
                // or disable code for this logger.
                //
                WmipAcquireMutex( &LoggerContext->LoggerMutex );
                InterlockedIncrement(&LoggerContext->MutexCount);

                LoggerInfo->BuffersWritten = LoggerContext->BuffersWritten;

                WmipLoggerContext[LoggerId] = LoggerContext;
                TraceDebug((1, "WmipStartLogger: Started %X %d\n",
                            LoggerContext, LoggerContext->LoggerId));
                if (LoggerContext->KernelTraceOn) {
                    EnableFlags = LoggerContext->EnableFlags;
                    if (EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO)
                        EnableFlags |= EVENT_TRACE_FLAG_DISK_IO;
                    WmipEnableKernelTrace(EnableFlags);
                }

                if (IsEqualGUID(&InstanceGuid, &WmiEventLoggerGuid)) {
                    WmipEventLogger = LoggerId;
                    EnableFlags = EVENT_TRACE_FLAG_PROCESS |
                                  EVENT_TRACE_FLAG_THREAD |
                                  EVENT_TRACE_FLAG_IMAGE_LOAD;
                    WmipEnableKernelTrace(EnableFlags);
                    LoggerContext->EnableFlags = EnableFlags;
                }

                if (LoggerContext->LoggerThread) {
                    LoggerInfo->LoggerThreadId
                        = LoggerContext->LoggerThread->Cid.UniqueThread;
                }

                //
                // Logger is started properly, now turn on perf trace
                //
                if (IsGlobalForKernel) {
                    ASSERT(LoggerContext->KernelTraceOn);
                    ASSERT(EnableKernel);
                    Status = PerfInfoStartLog(PerfGroupMasks, 
                                              PERFINFO_START_LOG_FROM_GLOBAL_LOGGER);
                    if (!NT_SUCCESS(Status)) {
                        //
                        // Turning on tracing failed, needs to clean up.
                        // Logger Thread has been created at this point.
                        // Just do WmipStopLoggerInstance and let Logger Thread
                        // handle all the cleanup work.
                        //
                        LoggerContext->LoggerStatus = Status;
                        WmipStopLoggerInstance(LoggerContext);
                    }
                } else if (IsKernelRealTimeNoFile) {
                    //
                    // We need to protect PerfInfoStartLog from stopping thread.
                    //
                    LONG PerfLogInTransition;

                    ASSERT(LoggerContext->KernelTraceOn);
                    ASSERT(EnableKernel);
                    PerfLogInTransition = InterlockedCompareExchange(
                                                &LoggerContext->PerfLogInTransition,
                                                PERF_LOG_START_TRANSITION,
                                                PERF_LOG_NO_TRANSITION);

                    if (PerfLogInTransition != PERF_LOG_NO_TRANSITION) {
                        Status = STATUS_ALREADY_DISCONNECTED;
                        LoggerContext->LoggerStatus = Status;
                    } else {
                        Status = PerfInfoStartLog(PerfGroupMasks, 
                                                  PERFINFO_START_LOG_POST_BOOT);
                        PerfLogInTransition =
                                InterlockedExchange(&LoggerContext->PerfLogInTransition,
                                                    PERF_LOG_NO_TRANSITION);
                        ASSERT(PerfLogInTransition == PERF_LOG_START_TRANSITION);
                        if (!NT_SUCCESS(Status)) {
                            //
                            // Turning on tracing failed, needs to clean up.
                            // Logger Thread has been created at this point.
                            // Just do WmipStopLoggerInstance and let Logger Thread
                            // handle all the cleanup work.
                            //
                            LoggerContext->LoggerStatus = Status;
                            WmipStopLoggerInstance(LoggerContext);
                        }
                    }
                }

                InterlockedDecrement(&LoggerContext->MutexCount);
                WmipReleaseMutex(&LoggerContext->LoggerMutex);

                // LoggerContext refcount is now >= 1 until it is stopped
                return Status;
            }
            Status = LoggerContext->LoggerStatus;
        }
    }
    TraceDebug((2, "WmipStartLogger: %d %X failed with status=%X ref %d\n",
                    LoggerId, LoggerContext, Status, WmipRefCount[LoggerId]));
//
// will get here if Status has failed earlier.
    if (LoggerContext != NULL) { // should not be NULL
//        WmipReferenceLogger(LoggerId); // Below will deref twice
        WmipFreeLoggerContext(LoggerContext);
    }
    else {
        WmipDereferenceLogger(LoggerId);
        ContextTable[LoggerId] = NULL;
    }
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
WmipQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine is called to control the data collection and logger.
    It is called by WmipIoControl in wmi.c, with IOCTL_WMI_QUERY_LOGGER.
    Caller must pass in either the Logger Name or a valid Logger Id/Handle.

Arguments:

    LoggerInfo     a pointer to the structure for the logger's control
                    and status information

    LoggerContext  if this is provided, it assumes it is a valid one

Return Value:

    The status of performing the action requested.

--*/

{
    NTSTATUS            Status;
    ULONG               LoggerId, NoContext;
    ACCESS_MASK         DesiredAccess = WMIGUID_QUERY;
    KPROCESSOR_MODE     RequestorMode;
#if DBG
    LONG                RefCount;
#endif

    PAGED_CODE();

    NoContext = (LoggerContext == NULL);
    if (NoContext) {
    
if ((LoggerInfo->Wnode.HistoricalContext == 0XFFFF) || (LoggerInfo->Wnode.HistoricalContext < 1))
        TraceDebug((2, "WmipQueryLogger: %d\n",
                        LoggerInfo->Wnode.HistoricalContext));
#if DBG
        Status = WmipVerifyLoggerInfo(
                    LoggerInfo, &LoggerContext, "WmipQueryLogger");
#else
        Status = WmipVerifyLoggerInfo( LoggerInfo, &LoggerContext );
#endif

        if (!NT_SUCCESS(Status) || (LoggerContext == NULL))
            return Status;        // cannot find by name nor logger id

        LoggerInfo->Wnode.Flags = 0;
        LoggerInfo->EnableFlags = 0;
        LoggerId = (ULONG) LoggerContext->LoggerId;

        if (LoggerContext->KernelTraceOn) {
            DesiredAccess |= TRACELOG_ACCESS_KERNEL_LOGGER;
        }

        Status = WmipCheckGuidAccess(
                    &LoggerContext->InstanceGuid,
                    DesiredAccess,
                    EtwpDefaultTraceSecurityDescriptor
                    );
        if (!NT_SUCCESS(Status)) {
#ifndef WMI_MUTEX_FREE
            InterlockedDecrement(&LoggerContext->MutexCount);
            TraceDebug((1, "WmipQueryLogger: Release mutex1 %d %d\n",
                LoggerId, LoggerContext->MutexCount));
            WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipQueryLogger: Status1=%X %d %d->%d\n",
                            Status, LoggerId, RefCount+1, RefCount));
            return Status;
        }
    }
    else {
        LoggerId = LoggerContext->LoggerId;
    }

    if (LoggerContext->KernelTraceOn) {
        LoggerInfo->Wnode.Guid = SystemTraceControlGuid;
        LoggerInfo->EnableFlags = LoggerContext->EnableFlags;
    }
    else
        LoggerInfo->Wnode.Guid = LoggerContext->InstanceGuid;

    LoggerInfo->LogFileMode     = LoggerContext->LoggerMode;
    LoggerInfo->MaximumFileSize = LoggerContext->MaximumFileSize;
    LoggerInfo->FlushTimer      = LoggerContext->FlushTimer;

    LoggerInfo->BufferSize      = LoggerContext->BufferSize / 1024;
    LoggerInfo->NumberOfBuffers = (ULONG) LoggerContext->NumberOfBuffers;
    LoggerInfo->MinimumBuffers  = LoggerContext->MinimumBuffers;
    LoggerInfo->MaximumBuffers  = LoggerContext->MaximumBuffers;
    LoggerInfo->EventsLost      = LoggerContext->EventsLost;
    LoggerInfo->FreeBuffers     = (ULONG) LoggerContext->BuffersAvailable;
    LoggerInfo->BuffersWritten  = LoggerContext->BuffersWritten;
    LoggerInfo->Wow             = LoggerContext->Wow;
    LoggerInfo->LogBuffersLost  = LoggerContext->LogBuffersLost;
    LoggerInfo->RealTimeBuffersLost = LoggerContext->RealTimeBuffersLost;
    LoggerInfo->AgeLimit        = (ULONG)
                                  (LoggerContext->BufferAgeLimit.QuadPart
                                    / WmiOneSecond.QuadPart / 60);
    WmiSetLoggerId(LoggerId,
                (PTRACE_ENABLE_CONTEXT)&LoggerInfo->Wnode.HistoricalContext);

    if (LoggerContext->LoggerThread) {
        LoggerInfo->LoggerThreadId
            = LoggerContext->LoggerThread->Cid.UniqueThread;
    }

    LoggerInfo->Wnode.ClientContext = LoggerContext->UsePerfClock;

//
// Return LogFileName and Logger Caption here
//
    RequestorMode = KeGetPreviousMode();
    try {
        if (LoggerContext->LogFileName.Length > 0 &&
            LoggerInfo->LogFileName.MaximumLength > 0) {
            if (RequestorMode != KernelMode) {
                ProbeForWrite(
                    LoggerInfo->LogFileName.Buffer,
                    LoggerContext->LogFileName.Length + sizeof(WCHAR),
                    sizeof (UCHAR) );
            }
            RtlCopyUnicodeString(
                &LoggerInfo->LogFileName,
                &LoggerContext->LogFileName);
        }
        if (LoggerContext->LoggerName.Length > 0 &&
            LoggerInfo->LoggerName.MaximumLength > 0) {
            if (RequestorMode != KernelMode) {
                ProbeForWrite(
                    LoggerInfo->LoggerName.Buffer,
                    LoggerContext->LoggerName.Length + sizeof(WCHAR),
                    sizeof(UCHAR));
            }
            RtlCopyUnicodeString(
                &LoggerInfo->LoggerName,
                &LoggerContext->LoggerName);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (NoContext) {
#ifndef WMI_MUTEX_FREE
            InterlockedDecrement(&LoggerContext->MutexCount);
            TraceDebug((1, "WmipQueryLogger: Release mutex3 %d %d\n",
                LoggerId, LoggerContext->MutexCount));
            WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif
#if DBG
            RefCount =
#endif
            WmipDereferenceLogger(LoggerId);
            TraceDebug((1, "WmipQueryLogger: Status3=EXCEPTION %d %d->%d\n",
                            LoggerId, RefCount+1, RefCount));
        }
        return GetExceptionCode();
    }

    if (NoContext) {
#ifndef WMI_MUTEX_FREE
        InterlockedDecrement(&LoggerContext->MutexCount);
        TraceDebug((1, "WmipQueryLogger: Release mutex %d %d\n",
            LoggerId, LoggerContext->MutexCount));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
#endif
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((1, "WmipQueryLogger: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
    }
    return STATUS_SUCCESS;
}


NTSTATUS
WmipStopLoggerInstance(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    LONG               LoggerOn;

    PAGED_CODE();
    if (LoggerContext == NULL) {    // just in case
        return STATUS_INVALID_HANDLE;
    }

    if (LoggerContext->KernelTraceOn) {
        // PerfInfoStopLog should not be executed when perf logging is starting
        // or stopping by other thread. PerfLogInTransition flag in the logger
        // context should only be used here and UpdateTrace and NO WHERE ELSE.
        LONG PerfLogInTransition = 
            InterlockedCompareExchange(&LoggerContext->PerfLogInTransition,
                                    PERF_LOG_STOP_TRANSITION,
                                    PERF_LOG_NO_TRANSITION);
        if (PerfLogInTransition == PERF_LOG_START_TRANSITION) {
            // This is the logger thread, and it is terminating. 
            // UpdateTrace call is enabling perf logging at the moment. 
            // Come back later.
            return STATUS_UNSUCCESSFUL;
        }
        else if (PerfLogInTransition == PERF_LOG_STOP_TRANSITION) {
            return STATUS_ALREADY_DISCONNECTED;
        }
        //
        // Time to turn off trace in perf tools
        //
        PerfInfoStopLog();
    }

    //
    // turn off data tracing first
    //
    LoggerOn = InterlockedExchange(&LoggerContext->CollectionOn, FALSE);
    if (LoggerOn == FALSE) {
        // This happens if another stoplogger already in progress
        return STATUS_ALREADY_DISCONNECTED;
    }
    if (LoggerContext->KernelTraceOn) {
        //
        // Turn off everything, just to be on the safe side
        // NOTE: If we start sharing callouts, the argument should be
        // LoggerContext->EnableFlags
        //
        WmipDisableKernelTrace(LoggerContext->EnableFlags);
    }
    if (LoggerContext->LoggerId == WmipEventLogger) {
        WmipDisableKernelTrace(EVENT_TRACE_FLAG_PROCESS |
                               EVENT_TRACE_FLAG_THREAD |
                               EVENT_TRACE_FLAG_IMAGE_LOAD);
        WmipEventLogger = 0xFFFFFFFF;
    }

    //
    // Mark the table entry as in-transition
    // From here on, the stop operation will not fail
    //
    WmipLoggerContext[LoggerContext->LoggerId] = (PWMI_LOGGER_CONTEXT)
                                                 &WmipLoggerContext[0];

    WmipNotifyLogger(LoggerContext);

    WmipSendNotification(LoggerContext, STATUS_THREAD_IS_TERMINATING, 0);
    return STATUS_SUCCESS;
}


NTSTATUS
WmipVerifyLoggerInfo(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
#if DBG
    OUT PWMI_LOGGER_CONTEXT *pLoggerContext,
    IN  LPSTR Caller
#else
    OUT PWMI_LOGGER_CONTEXT *pLoggerContext
#endif
    )
{
    NTSTATUS Status = STATUS_SEVERITY_ERROR;
    ULONG LoggerId;
    UNICODE_STRING LoggerName;
    KPROCESSOR_MODE     RequestorMode;
    PWMI_LOGGER_CONTEXT LoggerContext, CurrentContext;
    LONG            MutexCount = 0;
#if DBG
    LONG            RefCount;
#endif

    PAGED_CODE();

    *pLoggerContext = NULL;

    if (LoggerInfo == NULL)
        return STATUS_SEVERITY_ERROR;

    //
    // try and check for bogus parameter
    // if the size is at least what we want, we have to assume it's valid
    //

    if (LoggerInfo->Wnode.BufferSize < sizeof(WMI_LOGGER_INFORMATION))
        return STATUS_INVALID_BUFFER_SIZE;

    if (! (LoggerInfo->Wnode.Flags & WNODE_FLAG_TRACED_GUID) )
        return STATUS_INVALID_PARAMETER;

    RtlInitUnicodeString(&LoggerName, NULL);

    RequestorMode = KeGetPreviousMode();
    try {
        if (LoggerInfo->LoggerName.Length > 0) {
            if (RequestorMode != KernelMode) {
                ProbeForRead(
                    LoggerInfo->LoggerName.Buffer,
                    LoggerInfo->LoggerName.Length,
                    sizeof (UCHAR) );
            }
            RtlCreateUnicodeString(
                &LoggerName,
                LoggerInfo->LoggerName.Buffer);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (LoggerName.Buffer != NULL) {
            RtlFreeUnicodeString(&LoggerName);
        }
        return GetExceptionCode();
    }
    Status = STATUS_SUCCESS;
    if (IsEqualGUID(&LoggerInfo->Wnode.Guid, &SystemTraceControlGuid)) {
        LoggerId = WmipKernelLogger;
    }
    else if (LoggerName.Length > 0) { // Logger Name is passed
        Status =  WmipLookupLoggerIdByName(&LoggerName, &LoggerId);
    }
    else {
        LoggerId = WmiGetLoggerId(LoggerInfo->Wnode.HistoricalContext);
        if (LoggerId == KERNEL_LOGGER_ID) {
            LoggerId = WmipKernelLogger;
        }
        else if (LoggerId < 1 || LoggerId >= MAXLOGGERS) {
            Status  = STATUS_INVALID_HANDLE;
        }
    }
    if (LoggerName.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerName);
    }
    if (!NT_SUCCESS(Status)) { // cannot find by name nor logger id
        return Status;
    }

#if DBG
    RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((2, "WmipVerifyLoggerInfo(%s): %d %d->%d\n",
                    Caller, LoggerId, RefCount-1, RefCount));

    LoggerContext = WmipGetLoggerContext( LoggerId );
    if (!WmipIsValidLogger(LoggerContext)) {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((2, "WmipVerifyLoggerInfo(%s): Status=%X %d %d->%d\n",
                        Caller, STATUS_WMI_INSTANCE_NOT_FOUND,
                        LoggerId, RefCount+1, RefCount));
        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }

#ifndef WMI_MUTEX_FREE
    InterlockedIncrement(&LoggerContext->MutexCount);
    TraceDebug((1, "WmipVerifyLoggerInfo: Acquiring mutex... %d %d\n",
                    LoggerId, LoggerContext->MutexCount));
    WmipAcquireMutex (&LoggerContext->LoggerMutex);
    TraceDebug((1, "WmipVerifyLoggerInfo: Acquired mutex %d %d %X\n",
                    LoggerId, LoggerContext->MutexCount, LoggerContext));
#endif

    // Need to check for validity of LoggerContext in mutex
    CurrentContext = WmipGetLoggerContext( LoggerId );
    if (!WmipIsValidLogger(CurrentContext) ||
        !LoggerContext->CollectionOn ) {
#ifndef WMI_MUTEX_FREE
        TraceDebug((1, "WmipVerifyLoggerInfo: Released mutex %d %d\n",
            LoggerId, LoggerContext->MutexCount-1));
        WmipReleaseMutex(&LoggerContext->LoggerMutex);
        MutexCount = InterlockedDecrement(&LoggerContext->MutexCount);
#endif
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((2, "WmipVerifyLoggerInfo(%s): Status2=%X %d %d->%d\n",
                        Caller, STATUS_WMI_INSTANCE_NOT_FOUND,
                        LoggerId, RefCount+1, RefCount));

        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }
    *pLoggerContext = LoggerContext;
    return STATUS_SUCCESS;
}

PVOID
WmipExtendBase(
    IN PWMI_LOGGER_CONTEXT Base,
    IN ULONG Size
    )
{
//
// This private routine only return space from the Base by extending its
// offset. It does not actually try and allocate memory from the system
//
// It rounds the size to a ULONGLONG alignment and expects EndPageMarker
// to already be aligned.
//
    PVOID Space = NULL;
    ULONG SpaceLeft;

    PAGED_CODE();

    ASSERT(((ULONGLONG) Base->EndPageMarker % sizeof(ULONGLONG)) == 0);

    //
    // Round up to pointer boundary
    //
#ifdef _WIN64
    Size = ALIGN_TO_POWER2(Size, 16);
#else
    Size = ALIGN_TO_POWER2(Size, DEFAULT_TRACE_ALIGNMENT);
#endif

    SpaceLeft = CONTEXT_SIZE - (ULONG) (Base->EndPageMarker - (PUCHAR)Base);

    if ( SpaceLeft > Size ) {
        Space = Base->EndPageMarker;
        Base->EndPageMarker += Size;
    }

    return Space;
}

VOID
WmipFreeLoggerContext(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG LoggerId;
    LONG  RefCount;
    LARGE_INTEGER Timeout = {(ULONG)(-50 * 1000 * 10), -1}; // 50 ms
    NTSTATUS Status = STATUS_TIMEOUT;

    PAGED_CODE();

    if (LoggerContext == NULL)
        return;             // should not happen

    if (LoggerContext->LoggerHeader != NULL) {
        ExFreePool(LoggerContext->LoggerHeader);
    }

    LoggerId = LoggerContext->LoggerId;

    //
    // The RefCount must be at least 2 at this point.
    // One was set by WmipStartLogger() in the beginning, and the
    // second must be done normally by WmiStopTrace() or anybody who
    // needs to call this routine to free the logger context
    //
    //  RefCount = WmipDereferenceLogger(LoggerId);

    KeResetEvent(&LoggerContext->LoggerEvent);
    RefCount = WmipRefCount[LoggerId];
    WmipAssert(RefCount >= 1);
    TraceDebug((1, "WmipFreeLoggerContext: %d %d->%d\n",
                    LoggerId, RefCount+1, RefCount));

    while (RefCount > 1) {
        Status = KeWaitForSingleObject(
                    &LoggerContext->LoggerEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    &Timeout);
        KeResetEvent(&LoggerContext->LoggerEvent);
        KeSetEvent(&LoggerContext->FlushEvent, 0, FALSE);     // Just to be sure

#ifndef WMI_MUTEX_FREE
        if (LoggerContext->MutexCount >= 1) {
            KeResetEvent(&LoggerContext->LoggerEvent);
            Status = STATUS_TIMEOUT;
            continue;
        }
#endif
        if (WmipRefCount[LoggerId] <= 1)
            break;
        RefCount = WmipRefCount[LoggerId];
    }

    KeAcquireGuardedMutex(&WmipTraceGuardedMutex);
    if (--WmipLoggerCount == 0) {
        if (EtwpPageLockHandle) {
            MmUnlockPagableImageSection(EtwpPageLockHandle);
        }
#if DBG
        else {
            ASSERT(EtwpPageLockHandle);
        }
#endif
    }
    KeReleaseGuardedMutex(&WmipTraceGuardedMutex);

    WmipFreeTraceBufferPool(LoggerContext);

    if (LoggerContext->LoggerName.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerContext->LoggerName);
    }
    if (LoggerContext->LogFileName.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerContext->LogFileName);
    }
    if (LoggerContext->LogFilePattern.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerContext->LogFilePattern);
    }
    if (LoggerContext->NewLogFileName.Buffer != NULL) {
        RtlFreeUnicodeString(&LoggerContext->NewLogFileName);
    }
#if DBG
        RefCount =
#endif
    //
    // Finally, decrement the refcount incremented by WmipStartLogger()
    //
    WmipDereferenceLogger(LoggerId);

#if DBG
    TraceDebug((2, "WmipFreeLoggerContext: Freeing pool %X %d %d->%d\n",
                    LoggerContext, LoggerId, RefCount+1, RefCount));
    if (LoggerContext->CollectionOn) {
        TraceDebug((1,
            "WmipFreeLoggerContext: %X %d still active\n", LoggerContext,
            LoggerId));
    }
#ifndef WMI_MUTEX_FREE
    if (LoggerContext->MutexCount >= 1) {
        TraceDebug((0, "****ERROR**** Mutex count is %d for %d\n", LoggerId,
            LoggerContext->MutexCount));
    }
#endif // WMI_MUTEX_FREE
#endif // DBG
    ExFreePool(LoggerContext);
    WmipLoggerContext[LoggerId] = NULL;
}


PWMI_LOGGER_CONTEXT
WmipInitContext(
    )

/*++

Routine Description:

    This routine is called to initialize the context of LoggerContext

Arguments:

    None

Returned Value:

    Status of STATUS_SUCCESS if the allocation was successful

--*/

{
    PWMI_LOGGER_CONTEXT LoggerContext;

    PAGED_CODE();

    LoggerContext = (PWMI_LOGGER_CONTEXT)
                    ExAllocatePoolWithTag(NonPagedPool,
                         CONTEXT_SIZE, TRACEPOOLTAG);

// One page is reserved to store the buffer pool pointers plus anything
// else that we need. Should experiment a little more to reduce it further

    if (LoggerContext == NULL) {
        return NULL;
    }

    RtlZeroMemory(LoggerContext, CONTEXT_SIZE);

    LoggerContext->EndPageMarker =
        (PUCHAR) LoggerContext + 
                 ALIGN_TO_POWER2(sizeof(WMI_LOGGER_CONTEXT), DEFAULT_TRACE_ALIGNMENT);

    LoggerContext->BufferSize     = PAGE_SIZE;
    LoggerContext->MinimumBuffers = (ULONG)KeNumberProcessors + DEFAULT_BUFFERS;
    // 20 additional buffers for MaximumBuffers
    LoggerContext->MaximumBuffers
       = LoggerContext->MinimumBuffers + DEFAULT_BUFFERS + 20;

    KeQuerySystemTime(&LoggerContext->StartTime);

    KeInitializeSemaphore( &LoggerContext->LoggerSemaphore,
                           0,
                           SEMAPHORE_LIMIT  );

    KeInitializeSpinLock(&LoggerContext->BufferSpinLock);

    return LoggerContext;
}


NTSTATUS
WmipAllocateTraceBufferPool(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )

/*++

Routine Description:
    This routine is used to set up the circular trace buffers

Arguments:

    LoggerContext       Context of the logger to own the buffers.

Returned Value:

    STATUS_SUCCESS if the initialization is successful

--*/

{
    ULONG NumberProcessors, SysMax_Buffers, SysMin_Buffers;
    LONG i;
    PWMI_BUFFER_HEADER Buffer;
    ULONG AllocatedBuffers, NumberOfBuffers;
    SIZE_T WmiMaximumPoolInBytes;

    PAGED_CODE();
//
// Allocate the pointers the each buffer here by sharing the same page
//    with LoggerContext context pointer
//
    NumberProcessors = (ULONG) KeNumberProcessors;

    // This does not keep track of the amount already used by other sessions
    if (LoggerContext->LoggerMode & EVENT_TRACE_USE_PAGED_MEMORY) {
        WmiMaximumPoolInBytes = MmSizeOfPagedPoolInBytes;
    }
    else {
        WmiMaximumPoolInBytes = MmMaximumNonPagedPoolInBytes;
    }

    // Compute System limits for min and max

    // This is the absolute maximum that ANYONE can use
    SysMax_Buffers = (ULONG) (WmiMaximumPoolInBytes
                            / TRACE_MAXIMUM_NP_POOL_USAGE
                            / LoggerContext->BufferSize);

    // This is the absolute minimum that ANYONE MUST have
    SysMin_Buffers = NumberProcessors + DEFAULT_BUFFERS;

    // Sanity check to ensure that we have at least the minimum available
    if (SysMin_Buffers > SysMax_Buffers) {
        return STATUS_NO_MEMORY;
    }


    // Cover the case if the caller did not specify any values
    LoggerContext->MaximumBuffers = max(LoggerContext->MaximumBuffers,
                                    NumberProcessors + DEFAULT_BUFFERS +
                                    DEFAULT_MAX_BUFFERS);

    LoggerContext->MinimumBuffers = max(LoggerContext->MinimumBuffers,
                                        SysMin_Buffers);


    // Ensure each parameter is in range of SysMin and SysMax

    LoggerContext->MaximumBuffers = max (LoggerContext->MaximumBuffers, 
                                         SysMin_Buffers);
    LoggerContext->MaximumBuffers = min (LoggerContext->MaximumBuffers, 
                                         SysMax_Buffers);

    LoggerContext->MinimumBuffers = max (LoggerContext->MinimumBuffers, 
                                         SysMin_Buffers);
    LoggerContext->MinimumBuffers = min (LoggerContext->MinimumBuffers, 
                                         SysMax_Buffers);

    // In case the MaximumBuffers and MinimumBuffers got reversed pick the 
    // larger value

    if (LoggerContext->MinimumBuffers > LoggerContext->MaximumBuffers) {
        LoggerContext->MaximumBuffers = LoggerContext->MinimumBuffers;
    }

    // NOTE: We do not return anything if we reset MaximumBuffers or MinimumBuffers
    // provided by the caller.

    LoggerContext->NumberOfBuffers = (LONG) LoggerContext->MinimumBuffers;
    LoggerContext->BuffersAvailable = LoggerContext->NumberOfBuffers;

#ifdef NTPERF
    if (PERFINFO_IS_LOGGING_TO_PERFMEM()) {
        //
        // Logging to Perfmem.  The Maximum should be the perfmem size.
        //
        LoggerContext->MaximumBuffers = PerfQueryBufferSizeBytes()/LoggerContext->BufferSize;
    }
#endif //NTPERF

    //
    // Allocate the buffers now
    //
    //
    // Now determine the initial number of buffers
    //
    NumberOfBuffers = LoggerContext->NumberOfBuffers;
    LoggerContext->NumberOfBuffers = 0;
    LoggerContext->BuffersAvailable = 0;

    AllocatedBuffers = WmipAllocateFreeBuffers(LoggerContext,
                                              NumberOfBuffers);

    if (AllocatedBuffers < NumberOfBuffers) {
        //
        // No enough buffer is allocated.
        //
        WmipFreeTraceBufferPool(LoggerContext);
        return STATUS_NO_MEMORY;
    }

//
// Allocate Per Processor Buffer pointers
//

    LoggerContext->ProcessorBuffers
        = (PWMI_BUFFER_HEADER *)
          WmipExtendBase(LoggerContext,
                         sizeof(PWMI_BUFFER_HEADER)*NumberProcessors);


    if (LoggerContext->ProcessorBuffers == NULL) {
        WmipFreeTraceBufferPool(LoggerContext);
        return STATUS_NO_MEMORY;
    }

    //
    // NOTE: We already know that we have allocated > number of processors
    // buffers
    //
    for (i=0; i<(LONG)NumberProcessors; i++) {
        Buffer = (PWMI_BUFFER_HEADER) WmipGetFreeBuffer(LoggerContext);
        LoggerContext->ProcessorBuffers[i] = Buffer;
        Buffer->ClientContext.ProcessorNumber = (UCHAR)i;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
WmipFreeTraceBufferPool(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG i;
    PSLIST_ENTRY Entry;
    PWMI_BUFFER_HEADER* ProcessorBuffers;
    PWMI_BUFFER_HEADER Buffer;

    PAGED_CODE();

    TraceDebug((2, "Free Buffer Pool: %2d, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                    LoggerContext->LoggerId,
                    LoggerContext->BuffersAvailable,
                    LoggerContext->BuffersInUse,
                    LoggerContext->BuffersDirty,
                    LoggerContext->NumberOfBuffers));

    while (Entry = InterlockedPopEntrySList(&LoggerContext->FreeList)) {

        Buffer = CONTAINING_RECORD(Entry,
                                   WMI_BUFFER_HEADER,
                                   SlistEntry);

        InterlockedDecrement(&LoggerContext->NumberOfBuffers);
        InterlockedDecrement(&LoggerContext->BuffersAvailable);

        TraceDebug((2, "WmipFreeTraceBufferPool (Free): %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                        LoggerContext->LoggerId,
                        Buffer,
                        LoggerContext->BuffersAvailable,
                        LoggerContext->BuffersInUse,
                        LoggerContext->BuffersDirty,
                        LoggerContext->NumberOfBuffers));

        WMI_FREE_TRACE_BUFFER(Buffer);
    }

    while (Entry = InterlockedPopEntrySList(&LoggerContext->FlushList)) {

        Buffer = CONTAINING_RECORD(Entry,
                                   WMI_BUFFER_HEADER,
                                   SlistEntry);

        InterlockedDecrement(&LoggerContext->NumberOfBuffers);
        InterlockedDecrement(&LoggerContext->BuffersDirty);

        TraceDebug((2, "WmipFreeTraceBufferPool (Flush): %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                        LoggerContext->LoggerId,
                        Buffer,
                        LoggerContext->BuffersAvailable,
                        LoggerContext->BuffersInUse,
                        LoggerContext->BuffersDirty,
                        LoggerContext->NumberOfBuffers));

         WMI_FREE_TRACE_BUFFER(Buffer);
    }

    while (Entry = InterlockedPopEntrySList(&LoggerContext->WaitList)) {

        Buffer = CONTAINING_RECORD(Entry,
                                   WMI_BUFFER_HEADER,
                                   SlistEntry);

        InterlockedDecrement(&LoggerContext->NumberOfBuffers);
        InterlockedDecrement(&LoggerContext->BuffersDirty);

        TraceDebug((2, "WmipFreeTraceBufferPool (Wait): %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                        LoggerContext->LoggerId,
                        Buffer,
                        LoggerContext->BuffersAvailable,
                        LoggerContext->BuffersInUse,
                        LoggerContext->BuffersDirty,
                        LoggerContext->NumberOfBuffers));

         WMI_FREE_TRACE_BUFFER(Buffer);
    }

    ProcessorBuffers = LoggerContext->ProcessorBuffers;
    if (ProcessorBuffers != NULL) {
        for (i=0; i<(ULONG)KeNumberProcessors; i++) {
            Buffer = InterlockedExchangePointer(&ProcessorBuffers[i], NULL);
            if (Buffer) {
                InterlockedDecrement(&LoggerContext->NumberOfBuffers);
                InterlockedDecrement(&LoggerContext->BuffersInUse);

                TraceDebug((2, "WmipFreeTraceBufferPool (CPU %2d): %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n",
                                i,
                                LoggerContext->LoggerId,
                                Buffer,
                                LoggerContext->BuffersAvailable,
                                LoggerContext->BuffersInUse,
                                LoggerContext->BuffersDirty,
                                LoggerContext->NumberOfBuffers));

                WMI_FREE_TRACE_BUFFER(Buffer);
            }
        }
    }

    ASSERT(LoggerContext->BuffersAvailable == 0);
    ASSERT(LoggerContext->BuffersInUse == 0);
    ASSERT(LoggerContext->BuffersDirty == 0);
    ASSERT(LoggerContext->NumberOfBuffers == 0);

    return STATUS_SUCCESS;
}


NTSTATUS
WmipLookupLoggerIdByName(
    IN PUNICODE_STRING Name,
    OUT PULONG LoggerId
    )
{
    ULONG i;
    PWMI_LOGGER_CONTEXT *ContextTable;

    PAGED_CODE();
    if (Name == NULL) {
        *LoggerId = (ULONG) -1;
        return STATUS_WMI_INSTANCE_NOT_FOUND;
    }
    ContextTable = (PWMI_LOGGER_CONTEXT *) &WmipLoggerContext[0];
    for (i=0; i<MAXLOGGERS; i++) {
        if (ContextTable[i] == NULL ||
            ContextTable[i] == (PWMI_LOGGER_CONTEXT) ContextTable)
            continue;
        if (RtlEqualUnicodeString(&ContextTable[i]->LoggerName, Name, TRUE) ) {
            *LoggerId = i;
            return STATUS_SUCCESS;
        }
    }
    *LoggerId = (ULONG) -1;
    return STATUS_WMI_INSTANCE_NOT_FOUND;
}

NTSTATUS
WmipShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
//
// Shutdown all loggers cleanly. If a logger is in transition, it may
// not be stopped properly.
//
{
    ULONG LoggerCount;
    USHORT i;
    PWMI_LOGGER_CONTEXT LoggerContext;
    WMI_LOGGER_INFORMATION LoggerInfo;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    PAGED_CODE();

    TraceDebug((2, "WmipShutdown called\n"));
    if (WmipLoggerCount > 0) {
        RtlZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
        LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
        LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;

        LoggerCount = 0;
        for (i=0; i<MAXLOGGERS; i++) {
            LoggerContext = WmipLoggerContext[i];
            if ((LoggerContext != NULL) &&
                (LoggerContext != (PWMI_LOGGER_CONTEXT)&WmipLoggerContext[0])) {
                WmiSetLoggerId(i, &LoggerInfo.Wnode.HistoricalContext);
                LoggerInfo.Wnode.Guid = LoggerContext->InstanceGuid;
                WmiStopTrace(&LoggerInfo);
                if (++LoggerCount == WmipLoggerCount)
                    break;
            }
#if DBG
            else if (LoggerContext
                        == (PWMI_LOGGER_CONTEXT)&WmipLoggerContext[0]) {
                TraceDebug((4, "WmipShutdown: Logger %d in transition\n", i));
            }
#endif
        }
    }
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}

NTSTATUS
WmipFlushLogger(
    IN OUT PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG Wait
    )
{
    LARGE_INTEGER TimeOut = {(ULONG)(-20 * 1000 * 1000 * 10), -1};
    NTSTATUS Status;

    PAGED_CODE();

    KeResetEvent(&LoggerContext->FlushEvent);

    LoggerContext->RequestFlag |= REQUEST_FLAG_FLUSH_BUFFERS;
    Status = WmipNotifyLogger(LoggerContext);
    if (!NT_SUCCESS(Status))
        return Status;
    if (Wait) {
        Status = KeWaitForSingleObject(
                    &LoggerContext->FlushEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    & TimeOut
                    );
#if DBG
        if (Status == STATUS_TIMEOUT) {
            TraceDebug((1, "WmiFlushLogger: Wait status=%X\n",Status));
        }
#endif 
        KeResetEvent(&LoggerContext->FlushEvent);
        Status = LoggerContext->LoggerStatus;
    }
    return Status;
}

NTSTATUS
FASTCALL
WmipNotifyLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
// Routine can be called at DISPATCH_LEVEL
{
    LONG SemCount = KeReadStateSemaphore(&LoggerContext->LoggerSemaphore);
    if (SemCount >= SEMAPHORE_LIMIT/2) {
        return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
    }
    {
        KeReleaseSemaphore(&LoggerContext->LoggerSemaphore, 0, 1, FALSE);
        return STATUS_SUCCESS;
    }
}

/*
Note: Sep. 6th, 2001
We do not need the following two functions after removing GuidMaps from the kernel.
However, we feel that these two may provide useful code samples in case we need to
do RunDown. Hence we're keeping the codes in comments.

PVOID
WmipGetTraceBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN HANDLE LogFileHandle,
    IN PWMI_BUFFER_HEADER Buffer,
    IN ULONG GroupType,
    IN ULONG RequiredSize,
    OUT PULONG GuidMapBuffers
    )
{
    PSYSTEM_TRACE_HEADER Header;
    NTSTATUS Status;
    ULONG BytesUsed;
    PETHREAD Thread;

    PAGED_CODE();

    RequiredSize += sizeof (SYSTEM_TRACE_HEADER);   // add in header

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

    if (RequiredSize > LoggerContext->BufferSize - sizeof(WMI_BUFFER_HEADER)) {
        return NULL;
    }

    if (RequiredSize > (LoggerContext->BufferSize - Buffer->Offset)) {
        IO_STATUS_BLOCK IoStatus;

        if (Buffer->Offset < LoggerContext->BufferSize) {
            RtlFillMemory(
                    (char *) Buffer + Buffer->Offset,
                    LoggerContext->BufferSize - Buffer->Offset,
                    0xFF);
        }

        Status = ZwWriteFile(
                    LogFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    Buffer,
                    LoggerContext->BufferSize,
                    &LoggerContext->ByteOffset,
                    NULL);
        Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
        LoggerContext->ByteOffset.QuadPart += LoggerContext->BufferSize;
        if (!NT_SUCCESS(Status)) {
            return NULL;
        }
        *GuidMapBuffers++;
    }

    Header = (PSYSTEM_TRACE_HEADER) ((char*)Buffer + Buffer->Offset);
    Header->Header = (GroupType << 16) + RequiredSize;
    Header->Marker = SYSTEM_TRACE_MARKER;

  
    Thread = PsGetCurrentThread();
       
    Header->SystemTime.QuadPart = (*LoggerContext->GetCpuClock)();

      
    Header->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
    Header->ProcessId    = HandleToUlong(Thread->Cid.UniqueProcess);
    Header->KernelTime   = Thread->Tcb.KernelTime;
    Header->UserTime     = Thread->Tcb.UserTime;
    Header->Packet.Size  = (USHORT) RequiredSize;


    Buffer->Offset += RequiredSize;
    // If there is room, throw in a end of buffer marker.

    BytesUsed = Buffer->Offset;
    if ( BytesUsed <= (LoggerContext->BufferSize-sizeof(ULONG)) ) {
        *((long*)((char*)Buffer+Buffer->Offset)) = -1;
    }
    return (PVOID) ( (char*) Header + sizeof(SYSTEM_TRACE_HEADER) );
}


ULONG
WmipDumpGuidMaps(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PLIST_ENTRY TraceGMHeadPtr
    )
{
    PWMI_BUFFER_HEADER Buffer;
    HANDLE LogFileHandle = NULL;
    PWCHAR LogFileName = NULL;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG GuidMapBuffers = 0;
    PGUIDMAPENTRY  GuidMap;
    PLIST_ENTRY    GuidMapList;
    IO_STATUS_BLOCK IoStatus;

    PAGED_CODE();

    if ( (LoggerContext == NULL)  || (TraceGMHeadPtr == NULL) )
        return 0;


    //
    // If this a realtime logger only, then simply free the GuidMaps. 
    //

    if ( (LoggerContext->LoggerMode & EVENT_TRACE_REAL_TIME_MODE)  && 
         ((LoggerContext->LogFileName.Buffer == NULL) ||
           (LoggerContext->LogFileName.Length == 0)) ){

        GuidMapList = TraceGMHeadPtr->Flink;
        while (GuidMapList != TraceGMHeadPtr)
        {
            GuidMap = CONTAINING_RECORD(GuidMapList,
                                        GUIDMAPENTRY,
                                        Entry);

            GuidMapList = GuidMapList->Flink;

            RemoveEntryList(&GuidMap->Entry);
            WmipFree(GuidMap);
        }
        return 0;
    }


    BufferSize = LoggerContext->BufferSize;

    if ( BufferSize == 0) 
        return 0;

    Buffer = ExAllocatePoolWithTag(PagedPool,
                BufferSize, TRACEPOOLTAG);
    if (Buffer == NULL) {

    //
    // No buffer available.
    //
        return 0;
    }

    RtlZeroMemory(Buffer, BufferSize);

    Buffer->CurrentOffset = sizeof(WMI_BUFFER_HEADER);
    Buffer->Offset = sizeof(WMI_BUFFER_HEADER);
    Buffer->Wnode.BufferSize = BufferSize;
    Buffer->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Buffer->ClientContext.Alignment = (UCHAR)WmiTraceAlignment;
    Buffer->Wnode.Guid   = LoggerContext->InstanceGuid;

    KeQuerySystemTime(&Buffer->TimeStamp);

    Status = WmipCreateNtFileName( LoggerContext->LogFileName.Buffer,
                                   &LogFileName);
        
    if (!NT_SUCCESS(Status)) {
        ExFreePool(Buffer);
        return 0;
    }

    Status = WmipCreateDirectoryFile (
                            LogFileName,
                            FALSE,
                            &LogFileHandle,
                            TRUE );

    if (NT_SUCCESS(Status)) {
        PULONG AuxInfo;
        if ((LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) &&
            (LoggerContext->MaximumFileSize > (((LONGLONG) LoggerContext->BuffersWritten * (LONGLONG) LoggerContext->BufferSize) / (1024 * 1024)))) {
            LoggerContext->ByteOffset.QuadPart = ((LONGLONG) LoggerContext->BufferSize) * 
                                                 ((LONGLONG) LoggerContext->BuffersWritten);
        }
        else {
            FILE_STANDARD_INFORMATION FileSize;

            Status = ZwQueryInformationFile(
                            LogFileHandle,
                            &IoStatus,
                            &FileSize,
                            sizeof (FILE_STANDARD_INFORMATION),
                            FileStandardInformation
                            );
            if (!NT_SUCCESS(Status)) {
                ZwClose(LogFileHandle);
                ExFreePool(LogFileName);
                ExFreePool(Buffer);
                return 0;
            }

            LoggerContext->ByteOffset = FileSize.EndOfFile;
        }
        //
        // Do the RunDown of GuidMaps
        //

        GuidMapList = TraceGMHeadPtr->Flink;
        while (GuidMapList != TraceGMHeadPtr)
        {
            GuidMap = CONTAINING_RECORD(GuidMapList,
                                        GUIDMAPENTRY,
                                        Entry);

            GuidMapList = GuidMapList->Flink;

            RemoveEntryList(&GuidMap->Entry);

            AuxInfo =  (PULONG) WmipGetTraceBuffer(LoggerContext, 
                                     LogFileHandle,
                                     Buffer, 
                                     EVENT_TRACE_GROUP_HEADER + EVENT_TRACE_TYPE_GUIDMAP,
                                     sizeof(TRACEGUIDMAP),
                                     &GuidMapBuffers
                                     );

            if (AuxInfo != NULL) {
                RtlCopyMemory(AuxInfo, &GuidMap->GuidMap, sizeof(TRACEGUIDMAP) );
            }

            WmipFree(GuidMap);
        }
       
        //
        // Flush the last buffer if needed
        //

        if (Buffer->Offset > sizeof(WMI_BUFFER_HEADER) ) {
            Status = ZwWriteFile(
                        LogFileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        Buffer,
                        LoggerContext->BufferSize,
                        &LoggerContext->ByteOffset,
                        NULL);
            LoggerContext->ByteOffset.QuadPart += LoggerContext->BufferSize;
            GuidMapBuffers++;

        }
    
        ZwClose(LogFileHandle);
    }
                        
    ExFreePool(LogFileName);
    ExFreePool(Buffer);

    return GuidMapBuffers;
}
*/

NTSTATUS
WmipNtDllLoggerInfo(
    IN OUT PWMINTDLLLOGGERINFO Buffer
    )
{

    NTSTATUS            Status = STATUS_SUCCESS;

    KPROCESSOR_MODE     RequestorMode;
    PBGUIDENTRY         GuidEntry;    
    ULONG               SizeNeeded;
    GUID                Guid;
    ACCESS_MASK         DesiredAccess = TRACELOG_GUID_ENABLE;

    PAGED_CODE();

    RequestorMode = KeGetPreviousMode();

    SizeNeeded = sizeof(WMI_LOGGER_INFORMATION);

    __try {

        if (RequestorMode != KernelMode){
            ProbeForRead(Buffer->LoggerInfo, SizeNeeded, sizeof(ULONGLONG));
        }

        RtlCopyMemory(&Guid, &Buffer->LoggerInfo->Wnode.Guid, sizeof(GUID));

        if(!IsEqualGUID(&Guid, &NtdllTraceGuid)){

            return STATUS_UNSUCCESSFUL;

        }

        SizeNeeded = Buffer->LoggerInfo->Wnode.BufferSize;

    }  __except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    WmipEnterTLCritSection();
    WmipEnterSMCritSection();

    GuidEntry = WmipFindGEByGuid(&Guid, FALSE);

    if(Buffer->IsGet){

        if( GuidEntry ){

            if(GuidEntry->LoggerInfo){

                SizeNeeded = GuidEntry->LoggerInfo->Wnode.BufferSize;

                __try {

                    if (RequestorMode != KernelMode){
                        ProbeForWrite(Buffer->LoggerInfo, SizeNeeded, sizeof(ULONGLONG));
                    }

                    RtlCopyMemory(Buffer->LoggerInfo,GuidEntry->LoggerInfo,SizeNeeded);

                } __except(EXCEPTION_EXECUTE_HANDLER) {

                    WmipUnreferenceGE(GuidEntry);
                    WmipLeaveSMCritSection();
                    WmipLeaveTLCritSection();
                    return GetExceptionCode();
                } 
            }

            WmipUnreferenceGE(GuidEntry);

        }  else {

            Status = STATUS_UNSUCCESSFUL;
        }

    } else {

        //
        // This must be a control operation.
        // Check to see if heap/critsec controller has access 
        // to proper Guids.
        //
        Status = WmipCheckGuidAccess(
                    &Guid,
                    DesiredAccess,
                    EtwpDefaultTraceSecurityDescriptor
                    );
        if (!NT_SUCCESS(Status)) {
            if( GuidEntry ){
                WmipUnreferenceGE(GuidEntry);
            }
            WmipLeaveSMCritSection();
            WmipLeaveTLCritSection();
            return Status;
        }

        if(SizeNeeded){

            if(GuidEntry == NULL){

                GuidEntry = WmipAllocGuidEntry();

                if (GuidEntry){

                    //
                    // Initialize the guid entry and keep the ref count
                    // from creation. When tracelog enables we take a ref
                    // count and when it disables we release it
                    //
                    GuidEntry->Guid = Guid;
                    GuidEntry->EventRefCount = 1;
                    GuidEntry->Flags |= GE_NOTIFICATION_TRACE_FLAG;
                    InsertHeadList(WmipGEHeadPtr, &GuidEntry->MainGEList);

                    //
                    // Take Extra Refcount so that we release it at stoplogger call
                    //

                    WmipReferenceGE(GuidEntry); 

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            if(NT_SUCCESS(Status)){

                if(GuidEntry->LoggerInfo) {
                    Status = STATUS_UNSUCCESSFUL;
                } else {

                    GuidEntry->LoggerInfo = WmipAlloc(SizeNeeded);

                    if(GuidEntry->LoggerInfo){

                        WMITRACEENABLEDISABLEINFO TraceEnableInfo;
                        PTRACE_ENABLE_CONTEXT pContext;

                        __try {

                            pContext = (PTRACE_ENABLE_CONTEXT)&Buffer->LoggerInfo->Wnode.HistoricalContext;

                            pContext->InternalFlag |= EVENT_TRACE_INTERNAL_FLAG_PRIVATE;
                            pContext->LoggerId = 1;

                            RtlCopyMemory(GuidEntry->LoggerInfo,Buffer->LoggerInfo,SizeNeeded);

                        } __except(EXCEPTION_EXECUTE_HANDLER) {

                            WmipUnreferenceGE(GuidEntry);
                            WmipLeaveSMCritSection();
                            WmipLeaveTLCritSection();
                            return GetExceptionCode();
                        }

                        TraceEnableInfo.Guid = GuidEntry->Guid;
                        TraceEnableInfo.Enable = TRUE;
                        TraceEnableInfo.LoggerContext = 0;
                        Status = WmipEnableDisableTrace(IOCTL_WMI_ENABLE_DISABLE_TRACELOG, &TraceEnableInfo);

                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                WmipUnreferenceGE(GuidEntry);
            }
        } else {

            //
            // This is stop logger call.
            //

            if(GuidEntry){

                WMITRACEENABLEDISABLEINFO TraceEnableInfo;

                if(GuidEntry->LoggerInfo) {

                    __try{

                        if (RequestorMode != KernelMode){
                            ProbeForWrite(Buffer->LoggerInfo, sizeof(WMI_LOGGER_INFORMATION), sizeof(ULONGLONG));
                        }

                        Buffer->LoggerInfo->BufferSize     = GuidEntry->LoggerInfo->BufferSize;
                        Buffer->LoggerInfo->MinimumBuffers = GuidEntry->LoggerInfo->MinimumBuffers;
                        Buffer->LoggerInfo->MaximumBuffers = GuidEntry->LoggerInfo->MaximumBuffers;

                        WmipFree(GuidEntry->LoggerInfo);
                        GuidEntry->LoggerInfo = NULL;

                    } __except(EXCEPTION_EXECUTE_HANDLER) {

                            WmipUnreferenceGE(GuidEntry);
                            WmipLeaveSMCritSection();
                            WmipLeaveTLCritSection();
                            return GetExceptionCode();
                    }
                }

                TraceEnableInfo.Guid = GuidEntry->Guid;
                TraceEnableInfo.Enable = FALSE;
                TraceEnableInfo.LoggerContext = 0;

                //
                //  The Extra Refcount taken at logger start is released by calling
                //  Disable trace. 
                //
    
                Status = WmipEnableDisableTrace(IOCTL_WMI_ENABLE_DISABLE_TRACELOG, &TraceEnableInfo);
                WmipUnreferenceGE(GuidEntry); 
            } 
        }
    }
    
    WmipLeaveSMCritSection();
    WmipLeaveTLCritSection();

    return Status;
}

VOID
WmipValidateClockType(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    )
/*++

Routine Description:

    This routine is called to validate the requested clock type in the
    LoggerInfo. If the requested type can not be handled, we will override
    to a type that this system will support. 

    This routine assumes that LoggerInfo pointer is a valid one. 

Arguments:

    LoggerInfo - a pointer to the structure for the logger's control
                 and status information

Returned Value:

    Status of STATUS_SUCCESS 

--*/
{
#ifdef NTPERF
    //
    // For private kernel, use EVENT_TRACE_CLOCK_CPUCYCLE no matter
    // what the user sets
    // This mechanism need to considered again
    //
    LoggerInfo->Wnode.ClientContext = EVENT_TRACE_CLOCK_CPUCYCLE;
#else
    //
    // For retail kernel, if not EVENT_TRACE_CLOCK_SYSTEMTIME,
    // force it to be EVENT_TRACE_CLOCK_PERFCOUNTER.
    //
    if (LoggerInfo->Wnode.ClientContext != EVENT_TRACE_CLOCK_SYSTEMTIME) {
        LoggerInfo->Wnode.ClientContext = EVENT_TRACE_CLOCK_PERFCOUNTER;
    }
#endif //NTPERF

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\tracelog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    This is the source file that implements the private routines for 
    the performance event tracing and logging facility.
    The routines here work on a single event tracing session, the logging
    thread, and buffer synchronization within a session.

Author:

    Jee Fung Pang (jeepang) 03-Dec-1996

Revision History:

--*/

// TODO: In future, may need to align buffer size to larger of disk alignment
//       or 1024.

#pragma warning(disable:4214)
#pragma warning(disable:4115)
#pragma warning(disable:4201)
#pragma warning(disable:4127)
#include "ntverp.h"
#include "ntos.h"
#include "wmikmp.h"
#include <zwapi.h>
#pragma warning(default:4214)
#pragma warning(default:4115)
#pragma warning(default:4201)
#pragma warning(default:4127)

#ifndef _WMIKM_
#define _WMIKM_
#endif

#include "evntrace.h"

//
// Constants and Types used locally
//
#if DBG
ULONG WmipTraceDebugLevel=0;
// 5 All messages
// 4 Messages up to event operations
// 3 Messages up to buffer operations
// 2 Flush operations
// 1 Common operations and debugging statements
// 0 Always on - use for real error
#endif

#define ERROR_RETRY_COUNT       100

#include "tracep.h"

// Non-paged global variables
//
ULONG WmiTraceAlignment = DEFAULT_TRACE_ALIGNMENT;
ULONG WmiUsePerfClock = EVENT_TRACE_CLOCK_SYSTEMTIME;      // Global clock switch
LONG  WmipRefCount[MAXLOGGERS];
ULONG WmipGlobalSequence = 0;
PWMI_LOGGER_CONTEXT WmipLoggerContext[MAXLOGGERS];
PWMI_BUFFER_HEADER WmipContextSwapProcessorBuffers[MAXIMUM_PROCESSORS];

//
// Paged global variables
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG WmiWriteFailureLimit = ERROR_RETRY_COUNT;
ULONG WmipFileSystemReady  = FALSE;
WMI_TRACE_BUFFER_CALLBACK WmipGlobalBufferCallback = NULL;
PVOID WmipGlobalCallbackContext = NULL;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// Function prototypes for routines used locally
//

NTSTATUS
WmipSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER *BufferPointer,
    IN PVOID BufferPointerLocation,
    IN ULONG ProcessorNumber
    );

NTSTATUS
WmipPrepareHeader(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN OUT PWMI_BUFFER_HEADER Buffer,
    IN USHORT BufferFlag
    );

VOID
FASTCALL
WmipPushDirtyBuffer (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer
    );

VOID
FASTCALL
WmipPushFreeBuffer (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer
    );

//
// Logger functions
//

NTSTATUS
WmipCreateLogFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG SwitchFile,
    IN ULONG Append
    );

NTSTATUS
WmipSwitchToNewFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipRequestLogFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipFinalizeHeader(
    IN HANDLE FileHandle,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipFlushBuffersWithMarker (
    IN PWMI_LOGGER_CONTEXT  LoggerContext,
    IN PSLIST_ENTRY         List,
    IN USHORT               BufferFlag
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,    WmipLogger)
#pragma alloc_text(PAGE,    WmipSendNotification)
#pragma alloc_text(PAGE,    WmipCreateLogFile)
#pragma alloc_text(PAGE,    WmipFlushActiveBuffers)
#pragma alloc_text(PAGE,    WmipGenerateFileName)
#pragma alloc_text(PAGE,    WmipPrepareHeader)
#pragma alloc_text(PAGE,    WmiBootPhase1)
#pragma alloc_text(PAGE,    WmipFinalizeHeader)
#pragma alloc_text(PAGE,    WmipSwitchToNewFile)
#pragma alloc_text(PAGE,    WmipRequestLogFile)
#pragma alloc_text(PAGE,    WmipAdjustFreeBuffers)
#pragma alloc_text(PAGEWMI, WmipFlushBuffer)
#pragma alloc_text(PAGEWMI, WmipReserveTraceBuffer)
#pragma alloc_text(PAGEWMI, WmipGetFreeBuffer)
#pragma alloc_text(PAGEWMI, WmiReserveWithPerfHeader)
#pragma alloc_text(PAGEWMI, WmiReserveWithSystemHeader)
#pragma alloc_text(PAGEWMI, WmipAllocateFreeBuffers)
#pragma alloc_text(PAGEWMI, WmipSwitchBuffer)
#pragma alloc_text(PAGEWMI, WmipReleaseTraceBuffer)
#pragma alloc_text(PAGEWMI, WmiReleaseKernelBuffer)
#pragma alloc_text(PAGEWMI, WmipResetBufferHeader)
#pragma alloc_text(PAGEWMI, WmipPushDirtyBuffer)
#pragma alloc_text(PAGEWMI, WmipPushFreeBuffer)
#pragma alloc_text(PAGEWMI, WmipPopFreeContextSwapBuffer)
#pragma alloc_text(PAGEWMI, WmipPushDirtyContextSwapBuffer)
#pragma alloc_text(PAGEWMI, WmipFlushBuffersWithMarker)
#ifdef NTPERF
#pragma alloc_text(PAGEWMI, WmipSwitchPerfmemBuffer)
#endif //NTPERF
#endif

//
// Actual code starts here
//

PWMI_BUFFER_HEADER
WmipGetFreeBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
//
// This routine works at any IRQL
//
{
    PWMI_BUFFER_HEADER Buffer;
    PSLIST_ENTRY Entry;
    if (LoggerContext->SwitchingInProgress == 0) {
        //
        // Not in the middle of switching.
        //

        Entry = InterlockedPopEntrySList(&LoggerContext->FreeList);

        if (Entry != NULL) {
            Buffer = CONTAINING_RECORD (Entry,
                                        WMI_BUFFER_HEADER,
                                        SlistEntry);
    
            //
            // Reset the buffer. 
            // For circular persist mode, we want to write the buffers as
            // RunDown buffers so that post processing would work properly. 
            //

            if (LoggerContext->RequestFlag & REQUEST_FLAG_CIRCULAR_PERSIST) {
                WmipResetBufferHeader( LoggerContext, Buffer, WMI_BUFFER_TYPE_RUNDOWN);
            }
            else {
                WmipResetBufferHeader( LoggerContext, Buffer, WMI_BUFFER_TYPE_GENERIC);
            }

            //
            // Maintain some Wmi logger context buffer counts
            //
            InterlockedDecrement((PLONG) &LoggerContext->BuffersAvailable);
            InterlockedIncrement((PLONG) &LoggerContext->BuffersInUse);

            TraceDebug((2, "WmipGetFreeBuffer: %2d, %p, Free: %d, InUse: %d, Dirty: %d, Total: %d\n", 
                            LoggerContext->LoggerId,
                            Buffer,
                            LoggerContext->BuffersAvailable,
                            LoggerContext->BuffersInUse,
                            LoggerContext->BuffersDirty,
                            LoggerContext->NumberOfBuffers));

            return Buffer;
        } else {
            if (LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE) {
                //
                // If we are in BUFFERING Mode, put all buffers from
                // Flushlist into FreeList.
                //
            
                if (InterlockedIncrement((PLONG) &LoggerContext->SwitchingInProgress) == 1) {
                    while (Entry = InterlockedPopEntrySList(&LoggerContext->FlushList)) {
                        Buffer = CONTAINING_RECORD (Entry,
                                                    WMI_BUFFER_HEADER,
                                                    SlistEntry);
                
                        WmipPushFreeBuffer (LoggerContext, Buffer);
                    }
                }
                InterlockedDecrement((PLONG) &LoggerContext->SwitchingInProgress);
            }
            return NULL;
        }
    } else {
        return NULL;
    }
}


ULONG
WmipAllocateFreeBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG NumberOfBuffers
    )                

/*++

Routine Description:

    This routine allocate addition buffers into the free buffer list.
    Logger can allocate more buffer to handle bursty logging behavior.
    This routine can be called by multiple places and counters must be
    manipulated using interlocked operations.

Arguments:

    LoggerContext - Logger Context
    NumberOfBuffers - Number of buffers to be allocated.

Return Value:

    The total number of buffers actually allocated.  When it is fewer than the requested number:
    If this is called when trace is turned on, we fail to turn on trace.
    If this is called by walker thread to get more buffer, it is OK.

Environment:

    Kernel mode.

--*/
{
    ULONG i;
    PWMI_BUFFER_HEADER Buffer;
    ULONG TotalBuffers;

    for (i=0; i<NumberOfBuffers; i++) {
        //
        // Multiple threads can ask for more buffers, make sure
        // we do not go over the maximum.
        //
        TotalBuffers = InterlockedIncrement(&LoggerContext->NumberOfBuffers);
        if (TotalBuffers <= LoggerContext->MaximumBuffers) {

#ifdef NTPERF
            if (PERFINFO_IS_LOGGING_TO_PERFMEM()) {
                Buffer = (PWMI_BUFFER_HEADER)
                         PerfInfoReserveBytesFromPerfMem(LoggerContext->BufferSize);
            } else {
#endif //NTPERF
                Buffer = (PWMI_BUFFER_HEADER)
                        ExAllocatePoolWithTag(LoggerContext->PoolType,
                                              LoggerContext->BufferSize, 
                                              TRACEPOOLTAG);
#ifdef NTPERF
            }
#endif //NTPERF
    
            if (Buffer != NULL) {
    
                TraceDebug((3,
                    "WmipAllocateFreeBuffers: Allocated buffer size %d type %d\n",
                    LoggerContext->BufferSize, LoggerContext->PoolType));
                InterlockedIncrement(&LoggerContext->BuffersAvailable);
                //
                // Initialize newly created buffer
                //
                RtlZeroMemory(Buffer, sizeof(WMI_BUFFER_HEADER));
                Buffer->CurrentOffset = sizeof(WMI_BUFFER_HEADER);
                KeQuerySystemTime(&Buffer->TimeStamp);
                Buffer->State.Free = 1;
    
                //
                // Insert it into the free List
                //
                InterlockedPushEntrySList(&LoggerContext->FreeList,
                                          (PSLIST_ENTRY) &Buffer->SlistEntry);
    
                InterlockedPushEntrySList(&LoggerContext->GlobalList,
                                          (PSLIST_ENTRY) &Buffer->GlobalEntry);
            } else {
                //
                // Allocation failed, decrement the NumberOfBuffers
                // we increment earlier.
                //
                InterlockedDecrement(&LoggerContext->NumberOfBuffers);
                break;
            } 
        } else {
            //
            // Maximum is reached, decrement the NumberOfBuffers
            // we increment earlier.
            //
            InterlockedDecrement(&LoggerContext->NumberOfBuffers);
            break;
        }
    }

    TraceDebug((2, "WmipAllocateFreeBuffers %3d (%3d): Free: %d, InUse: %d, Dirty: %d, Total: %d\n", 
                    NumberOfBuffers,
                    i,
                    LoggerContext->BuffersAvailable,
                    LoggerContext->BuffersInUse,
                    LoggerContext->BuffersDirty,
                    LoggerContext->NumberOfBuffers));

    return i;
}

NTSTATUS
WmipAdjustFreeBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine does buffer management.  It checks the number of free buffers and
    will allocate additonal or free some based on the situation.

Arguments:

    LoggerContext - Logger Context

Return Value:

    Status

Environment:

    Kernel mode.

--*/
{
    ULONG FreeBuffers;
    ULONG AdditionalBuffers;
    NTSTATUS Status = STATUS_SUCCESS;
    //
    //  Check if we need to allocate more buffers
    //

    FreeBuffers = ExQueryDepthSList(&LoggerContext->FreeList);
    if (FreeBuffers <  LoggerContext->MinimumBuffers) {
        AdditionalBuffers = LoggerContext->MinimumBuffers - FreeBuffers;
        if (AdditionalBuffers != WmipAllocateFreeBuffers(LoggerContext, AdditionalBuffers)) {
            Status = STATUS_NO_MEMORY;
        }
    }
    return Status;
}


//
// Event trace/record and buffer related routines
//

PSYSTEM_TRACE_HEADER
FASTCALL
WmiReserveWithSystemHeader(
    IN ULONG LoggerId,
    IN ULONG AuxSize,
    IN PETHREAD Thread,
    OUT PWMI_BUFFER_HEADER *BufferResource
    )
//
// It returns with LoggerContext locked, so caller must explicitly call
// WmipDereferenceLogger() after call WmipReleaseTraceBuffer()
//
{
    PSYSTEM_TRACE_HEADER Header;
    PWMI_LOGGER_CONTEXT LoggerContext;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG RefCount;
#endif

#if DBG
    RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiReserveWithSystemHeader: %d %d->%d\n",
                    LoggerId, RefCount-1, RefCount));

    LoggerContext = WmipGetLoggerContext(LoggerId);

    AuxSize += sizeof(SYSTEM_TRACE_HEADER);    // add header size first
    Header = WmipReserveTraceBuffer( LoggerContext, 
                                     AuxSize, 
                                     BufferResource,
                                     &TimeStamp);
    if (Header != NULL) {

        //
        // Now copy the necessary information into the buffer
        //

        Header->SystemTime = TimeStamp;
        if (Thread == NULL) {
            Thread = PsGetCurrentThread();
        }

        Header->Marker       = SYSTEM_TRACE_MARKER;
        Header->ThreadId     = HandleToUlong(Thread->Cid.UniqueThread);
        Header->ProcessId    = HandleToUlong(Thread->Cid.UniqueProcess);
        Header->KernelTime   = Thread->Tcb.KernelTime;
        Header->UserTime     = Thread->Tcb.UserTime;
        Header->Packet.Size  = (USHORT) AuxSize;
    }
    else {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);                             //Interlocked decrement
        TraceDebug((4, "WmiReserveWithSystemHeader: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
    }
// NOTE: Caller must still put in a proper MARKER
    return Header;
}


PPERFINFO_TRACE_HEADER
FASTCALL
WmiReserveWithPerfHeader(
    IN ULONG AuxSize,
    OUT PWMI_BUFFER_HEADER *BufferResource
    )
//
// It returns with LoggerContext locked, so caller must explicitly call
// WmipDereferenceLogger() after call WmipReleaseTraceBuffer()
//
{
    PPERFINFO_TRACE_HEADER Header;
    ULONG LoggerId = WmipKernelLogger;
    LARGE_INTEGER TimeStamp;
#if DBG
    LONG RefCount;
#endif
//
// We must have this check here to see the logger is still running
// before calling ReserveTraceBuffer.
// The stopping thread may have cleaned up the logger context at this 
// point, which will cause AV.
// For all other kernel events, this check is made in callouts.c.
//
    if (WmipIsLoggerOn(LoggerId) == NULL) {
        return NULL;
    }

#if DBG
    RefCount =
#endif
    WmipReferenceLogger(LoggerId);
    TraceDebug((4, "WmiReserveWithPerfHeader: %d %d->%d\n",
                    LoggerId, RefCount-1, RefCount));

    AuxSize += FIELD_OFFSET(PERFINFO_TRACE_HEADER, Data);    // add header size first
    Header = WmipReserveTraceBuffer( WmipGetLoggerContext(LoggerId), 
                                     AuxSize, 
                                     BufferResource,
                                     &TimeStamp);
    if (Header != NULL) {
        //
        // Now copy the necessary information into the buffer
        //
        Header->SystemTime = TimeStamp;
        Header->Marker = PERFINFO_TRACE_MARKER;
        Header->Packet.Size = (USHORT) AuxSize;
    } else {
#if DBG
        RefCount =
#endif
        WmipDereferenceLogger(LoggerId);
        TraceDebug((4, "WmiWmiReserveWithPerfHeader: %d %d->%d\n",
                        LoggerId, RefCount+1, RefCount));
    }
// NOTE: Caller must still put in a proper MARKER
    return Header;
}


PVOID
FASTCALL
WmipReserveTraceBuffer(
    IN  PWMI_LOGGER_CONTEXT LoggerContext,
    IN  ULONG RequiredSize,
    OUT PWMI_BUFFER_HEADER *BufferResource,
    OUT PLARGE_INTEGER TimeStamp
    )
/*++

Routine Description:
    This function is the main logging function that reserves spaces for any events.
    The algorithm is as follows:

    Every time a space is needed, we InterlockedExchangeAdd CurrentOffset.
    A local variable Offset is used to track the initial value when 
    InterlockedExchangeAdd is taken.  If there is enough space for this
    event (i.e., (Offset + RequiredSize) <= BufferSize), then we have successfully
    reserved the space.
    
    If there is not enough space left on this buffer, we will call WmipSwitchBuffer 
    for a new buffer.  In this case, CurrentOffset should be larger than the buffersize.
    Since other thread can still be trying to reserve space using thie buffer, we
    saved the offset on SavedOffset the the logger thread knows the real offset to be
    written to disk.

    Note that, since the CurrentOffset if growing monotonically, only one thread is
    advancing the CurrentOffset from below BufferSize to beyond BufferSize.  
    It is this thread's responsibility to set the SavedOffset properly.

Arguments:

    LoggerContext - Logger context from current logging session.

    RequiredSize  - The space needed for logging the data.

    Buffer        - Pointer to a buffer header

    TimeStamp     - TimeStamp of the event

Return Value:

    The status of running the buffer manager

Environment:

    Kernel mode.  This routine should work at any IRQL.

--*/
{
    PVOID       ReservedSpace;
    PWMI_BUFFER_HEADER Buffer = NULL;
    ULONG       Offset;
    //
    // ISSUES: shsiao 2002/07/26
    // Mark it volatile to work around compiler bug.
    //
    volatile ULONG Processor;
    NTSTATUS    Status;

    if (!WmipIsValidLogger(LoggerContext)) {
        return NULL;
    }
    if (!LoggerContext->CollectionOn) {
        return NULL;
    }

    *BufferResource = NULL;

    RequiredSize = (ULONG) ALIGN_TO_POWER2(RequiredSize, WmiTraceAlignment);

    if (RequiredSize > LoggerContext->BufferSize - sizeof (WMI_BUFFER_HEADER)) {
        goto LostEvent;
    }

    //
    // Get processor number again here due to possible context switch
    //
    Processor = KeGetCurrentProcessorNumber();

    //
    // Get the processor specific buffer pool
    //
    Buffer = LoggerContext->ProcessorBuffers[Processor];

    if (Buffer == NULL) {
        //
        // Nothing in per process list, ask to get a new buffer
        //
        Status = WmipSwitchBuffer(LoggerContext, 
                                  &Buffer,
                                  &LoggerContext->ProcessorBuffers[Processor],
                                  Processor);

        if (!NT_SUCCESS(Status)) {
            //
            // Nothing available
            //
            goto LostEvent;
        }

        ASSERT(Buffer != NULL);
    }

TryFindSpace:

    //
    // Increment refcount to buffer first to prevent it from going away
    //
    InterlockedIncrement(&Buffer->ReferenceCount);
    
    //
    // Check if there is enough space in this buffer.
    //
    Offset = (ULONG) InterlockedExchangeAdd(
                     (PLONG) &Buffer->CurrentOffset, RequiredSize);
    
    if (Offset+RequiredSize <= LoggerContext->BufferSize) {
        //
        // Successfully reserved the space
        // Get the timestamp of the event
        //
        if (TimeStamp) {
#ifdef NTPERF
            PerfTimeStamp((*TimeStamp));
#else
            TimeStamp->QuadPart = (*LoggerContext->GetCpuClock)();
#endif
        }

        //
        // Set up the space pointer
        //
        ReservedSpace = (PVOID) (Offset +  (char*)Buffer);
    
        if (LoggerContext->SequencePtr) {
            *((PULONG) ReservedSpace) =
                (ULONG)InterlockedIncrement(LoggerContext->SequencePtr);
        }
        goto FoundSpace;
    } else {
        //
        // There is not enough space left to log this event,
        // Ask for buffer switch.  The WmipSwitchBuffer()
        // will push this current buffer into Dirty list.
        //
        // Before asking for buffer switch, 
        // check if I am the one that got overboard.  
        // If yes, put the correct offset back.
        //
        if (Offset <= LoggerContext->BufferSize) {
            Buffer->SavedOffset = Offset;
        }

        //
        // Also, dereference the buffer, so it can be freed.
        //
        InterlockedDecrement((PLONG) &Buffer->ReferenceCount);

        //
        // Nothing in per process list, ask to get a new buffer
        //
        Status = WmipSwitchBuffer(LoggerContext, 
                                  &Buffer,
                                  &LoggerContext->ProcessorBuffers[Processor],
                                  Processor);

        if (!NT_SUCCESS(Status)) {
            //
            // Nothing available
            //
            goto LostEvent;
        }

        ASSERT (Buffer != NULL);
        goto TryFindSpace;
    }

LostEvent:
    //
    // Will get here it we are throwing away the event
    //
    ASSERT(Buffer == NULL);
    LoggerContext->EventsLost++;    // best attempt to be accurate
    ReservedSpace = NULL;
    if (LoggerContext->SequencePtr) {
        InterlockedIncrement(LoggerContext->SequencePtr);
    }

FoundSpace:
    //
    // notify the logger after critical section
    //
    *BufferResource = Buffer;

    return ReservedSpace;
}

NTSTATUS
WmipSwitchToNewFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine is called to get a LogFileHandle for GlobalLogger or
    when a fileswitch is needed for NEWFILE mode. It will create the file
    and add logfileheader to it. It closes the oldfile by properly
    finalizing its header.  

Arguments:

    LoggerContext - Logger Context

Return Value:

    Status

Environment:

    Kernel mode.

--*/
{
    IO_STATUS_BLOCK IoStatus;
    HANDLE OldHandle, NewHandle;
    UNICODE_STRING NewFileName, OldFileName;
    ULONG BufferSize = LoggerContext->BufferSize;
    PWMI_BUFFER_HEADER NewHeaderBuffer;
    NTSTATUS Status=STATUS_SUCCESS;

    PAGED_CODE();

    NewFileName.Buffer = NULL;

    if (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE) {

        Status = WmipGenerateFileName(
                                      &LoggerContext->LogFilePattern,
                                      (PLONG) &LoggerContext->FileCounter,
                                      &NewFileName
                                     );

        if (!NT_SUCCESS(Status)) {
            TraceDebug((1, "WmipSwitchToNewFile: Error %x generating filename\n", Status));
            return Status;
        }

    }
    else {
        //
        // GlobalLogger path. It is executed only once to set up 
        // the logfile. 
        //
        if (LoggerContext->LogFileHandle != NULL) {
            LoggerContext->RequestFlag &= ~REQUEST_FLAG_NEW_FILE;
            return STATUS_SUCCESS;
        }
        if (LoggerContext->LogFileName.Buffer == NULL) {
            TraceDebug((1, "WmipSwitchToNewFile: No LogFileName\n"));
            return STATUS_INVALID_PARAMETER;
        }
        if (! RtlCreateUnicodeString( &NewFileName, 
                                      LoggerContext->LogFileName.Buffer) ) {
            TraceDebug((1, "WmipSwitchToNewFile: No Memory for NewFileName\n"));
            return STATUS_NO_MEMORY;
        }
    }

    //
    // We have a NewFileName. Create the File 
    //
    Status = WmipDelayCreate(&NewHandle, &NewFileName, FALSE);

    if (NT_SUCCESS(Status)) {
        NewHeaderBuffer = (PWMI_BUFFER_HEADER)
                           ExAllocatePoolWithTag(LoggerContext->PoolType,
                                              LoggerContext->BufferSize,
                                              TRACEPOOLTAG);
        if (NewHeaderBuffer != NULL) {
        //
        // Now we have all the resources we need for the new file. 
        // Let's close out the old file, if necessary and switch
        //
            OldFileName = LoggerContext->LogFileName;
            OldHandle = LoggerContext->LogFileHandle;
            if (OldHandle) {
                WmipFinalizeHeader(OldHandle, LoggerContext);
                ZwClose(OldHandle);
            }

            // NOTE: Assumes LogFileName cannot be changed
            //  for NEWFILE mode!!!
            if (OldFileName.Buffer != NULL) {
                RtlFreeUnicodeString(&OldFileName);
            }

            LoggerContext->BuffersWritten = 1;
            LoggerContext->LogFileHandle = NewHandle;
            LoggerContext->LogFileName = NewFileName;

            NewFileName.Buffer = NULL;

            RtlZeroMemory( NewHeaderBuffer, LoggerContext->BufferSize );
            WmipResetBufferHeader(LoggerContext, 
                                  NewHeaderBuffer, 
                                  WMI_BUFFER_TYPE_RUNDOWN);

            WmipAddLogHeader(LoggerContext, NewHeaderBuffer);

            LoggerContext->LastFlushedBuffer = 1;
            LoggerContext->ByteOffset.QuadPart = BufferSize;
            LoggerContext->RequestFlag &= ~REQUEST_FLAG_NEW_FILE;
            LoggerContext->LoggerMode &= ~EVENT_TRACE_DELAY_OPEN_FILE_MODE;
            LoggerContext->LoggerMode &= ~EVENT_TRACE_ADD_HEADER_MODE;

            Status = WmipPrepareHeader(LoggerContext,  
                                       NewHeaderBuffer, 
                                       WMI_BUFFER_TYPE_RUNDOWN);
            if (NT_SUCCESS(Status)) {
                Status = ZwWriteFile(
                                     NewHandle,
                                     NULL, NULL, NULL,
                                     &IoStatus,
                                     NewHeaderBuffer,
                                     BufferSize,
                                     NULL, NULL);
            }
            if (!NT_SUCCESS(Status) ) {
                TraceDebug((1, "WmipSwitchToNewFile: Write Failed\n", Status));
            }

            WmipSendNotification(LoggerContext, 
                                 STATUS_MEDIA_CHANGED, 
                                 STATUS_SEVERITY_INFORMATIONAL);

            ExFreePool(NewHeaderBuffer);
        }
    }
    
    if (NewFileName.Buffer != NULL) {
        ExFreePool(NewFileName.Buffer);
    }

    return Status;
}


NTSTATUS
WmipRequestLogFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
/*++

Routine Description:

    This routine switches logfiles for an active logger. This routine must   
    be called only by the Logger Thread. It will close the previous logfile,
    if any, properly by terminating it with FLUSH_MARKER and Finalizing the
    LogHeader. 

    Two different cases to consider here are: 
        1. The newfile was created in user mode with headers and rundown data
        2. The newfile is created in kernel (need to add LogFileHeader)

    The callers of this function are
        1. UpdateLogger: Sets the REQUEST_FLAG_NEW_FILE after presenting
           a user mode created logfile in NewLogFile.
        2. NT Kernel Logger session: Switches from DELAY_OPEN mode with 
           a user mode created logfile 
        3. FILE_MODE_NEWFILE: When current logfile reaches the FileLimit
           FlushBuffer requests a newfile. 
        4. GlobalLogger: Started in DELAY_OPEN && ADD_HEADER mode needs
           to create the logfile when the FileSystem is ready. 

    In all cases, when the switch is made the old logfile needs to be 
    properly closed after Finalizing its header. 



Arguments:

    LoggerContext - Logger Context

Return Value:

    Status

Environment:

    Kernel mode.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (!WmipFileSystemReady) {
    //
    // FileSystem is not ready yet, so return for now.
    //
        return Status;
    }

    //
    // In order for us to act on this request we need something to create
    // a file with, such as FileName, Pattern etc., 
    //

    if ((LoggerContext->LogFileName.Buffer == NULL ) &&
        (LoggerContext->LogFilePattern.Buffer == NULL)  &&
        (LoggerContext->NewLogFileName.Buffer == NULL) ) {

        return Status;
    }
        
    //
    // With the REQUEST_FLAG_NEW_FILE set, flush all active buffers. 
    //

    if (LoggerContext->LogFileHandle != NULL ) {
        Status = WmipFlushActiveBuffers(LoggerContext, TRUE);
    }

    if (NT_SUCCESS(Status)) {
        if ( (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE) ||
             ( (LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE) &&
               (LoggerContext->LoggerMode & EVENT_TRACE_ADD_HEADER_MODE))) {  

            Status = WmipSwitchToNewFile(LoggerContext);
        }
        else {
            //
            // UpdateTrace case
            //
            TraceDebug((3, "WmipLogger: New File\n"));
            Status = WmipCreateLogFile(LoggerContext,
                                       TRUE,
                                       EVENT_TRACE_FILE_MODE_APPEND);
            if (NT_SUCCESS(Status)) {
                LoggerContext->LoggerMode &= ~EVENT_TRACE_DELAY_OPEN_FILE_MODE;
            }
            //
            // This is to release the Update thread from the wait
            //
            KeSetEvent(&LoggerContext->FlushEvent, 0, FALSE);
        }
    }

    if (! NT_SUCCESS(Status)) {
        LoggerContext->LoggerStatus = Status;
    }
    return Status;
}


//
// Actual Logger code starts here
//


VOID
WmipLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )

/*++

Routine Description:
    This function is the logger itself. It is started as a system thread.
    It will not return until someone has stopped data collection or it
    is not successful is flushing out a buffer (e.g. disk is full).

Arguments:

    None.

Return Value:

    The status of running the buffer manager

--*/

{
    NTSTATUS Status;
    ULONG ErrorCount;
    ULONG FlushTimeOut;
    ULONG64 LastFlushTime=0;

    PAGED_CODE();

    LoggerContext->LoggerThread = PsGetCurrentThread();

    if ((LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)
        || (LoggerContext->LogFileName.Length == 0)) {

        // If EVENT_TRACE_DELAY_OPEN_FILE_MODE is specified, WMI does not
        // need to create logfile now.
        //
        // If there is no LogFileName specified, WMI does not need to create
        // logfile either. WmipStartLogger() already checks all possible
        // combination of LoggerMode and LogFileName, so we don't need to
        // perform the same check again.
        //
        Status = STATUS_SUCCESS;
    } else {
        Status = WmipCreateLogFile(LoggerContext, 
                                   FALSE,
                                   LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_APPEND);
    }


    LoggerContext->LoggerStatus = Status;
    if (NT_SUCCESS(Status)) {
        //
        // This is the only place where CollectionOn will be turn on!!!
        //
        LoggerContext->CollectionOn = TRUE;
        KeSetEvent(&LoggerContext->LoggerEvent, 0, FALSE);
    } else {
        if (LoggerContext->LogFileHandle != NULL) {
            Status = ZwClose(LoggerContext->LogFileHandle);
            LoggerContext->LogFileHandle = NULL;
        }
        KeSetEvent(&LoggerContext->LoggerEvent, 0, FALSE);
        PsTerminateSystemThread(Status);
        return;
    }

    ErrorCount = 0;
// by now, the caller has been notified that the logger is running

//
// Loop and wait for buffers to be filled until someone turns off CollectionOn
//
    KeSetBasePriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY-1);

    while (LoggerContext->CollectionOn) {

        if (LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE) {
            //
            // Wait forever until signalled by when logging is terminated.
            //
            Status = KeWaitForSingleObject(
                        &LoggerContext->LoggerSemaphore,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL);
            LoggerContext->LoggerStatus = STATUS_SUCCESS;
        } else {
            ULONG FlushAll = 0;
            ULONG FlushFlag;

            FlushTimeOut = LoggerContext->FlushTimer;
            //
            // Wake up every second to see if there are any buffers in
            // flush list.
            //
            Status = KeWaitForSingleObject(
                        &LoggerContext->LoggerSemaphore,
                        Executive,
                        KernelMode,
                        FALSE,
                        &WmiOneSecond);
    
            //
            //  Check if number of buffers need to be adjusted.
            //
            WmipAdjustFreeBuffers(LoggerContext);

            LoggerContext->LoggerStatus = STATUS_SUCCESS;

            if ((LoggerContext->RequestFlag & REQUEST_FLAG_NEW_FILE)  ||
                ((LoggerContext->LoggerMode & EVENT_TRACE_DELAY_OPEN_FILE_MODE)
                && (LoggerContext->LoggerMode & EVENT_TRACE_ADD_HEADER_MODE)) ) {
                Status = WmipRequestLogFile( LoggerContext);
            }

            //
            // Check to see if we need to FlushAll 
            //
            if (FlushTimeOut) {
                ULONG64 Now;
                KeQuerySystemTime((PLARGE_INTEGER) &Now);
                if ( ((Now - LastFlushTime) / 10000000) >= FlushTimeOut) { 
                    FlushAll = 1;
                    LastFlushTime = Now;
                }
                else {
                    FlushAll = 0;
                }
            }

            FlushFlag = (LoggerContext->RequestFlag & REQUEST_FLAG_FLUSH_BUFFERS);
            if (  FlushFlag ) 
                FlushAll = TRUE;

#ifdef NTPERF
            if (!PERFINFO_IS_LOGGING_TO_PERFMEM()) {
#endif //NTPERF
                Status = WmipFlushActiveBuffers(LoggerContext, FlushAll);
                //
                // Should check the status, and if failed to write a log file
                // header, should clean up.  As the log file is bad anyway.
                //
                if (  FlushFlag )  {
                    LoggerContext->RequestFlag &= ~REQUEST_FLAG_FLUSH_BUFFERS;
                    //
                    // If this was a flush for persistent events, this request 
                    // flag must be reset here.
                    //
                    if (LoggerContext->RequestFlag & 
                                       REQUEST_FLAG_CIRCULAR_TRANSITION) {
                        if (LoggerContext->LogFileHandle != NULL) {
                            WmipFinalizeHeader(LoggerContext->LogFileHandle, 
                                               LoggerContext);
                        }

                        LoggerContext->RequestFlag &= ~REQUEST_FLAG_CIRCULAR_TRANSITION;
                    }

                    LoggerContext->LoggerStatus = Status;
                    KeSetEvent(&LoggerContext->FlushEvent, 0, FALSE);

                }
                if (!NT_SUCCESS(Status)) {
                    LoggerContext->LoggerStatus = Status;
                    WmipStopLoggerInstance(LoggerContext);
                }
#ifdef NTPERF
            }
#endif //NTPERF
        }
    } // while loop

    if (Status == STATUS_TIMEOUT) {
        Status = STATUS_SUCCESS;
    }
//
// if a normal collection end, flush out all the buffers before stopping
//

    TraceDebug((2, "WmipLogger: Flush all buffers before stopping...\n"));
//
// First, move the per processor buffer out to FlushList
//
    // This is to force buffers to be written
    // in FlushBuffer without snapping back to this routine to create a file. 
    LoggerContext->RequestFlag |= REQUEST_FLAG_NEW_FILE;

    while ((LoggerContext->NumberOfBuffers > 0) &&
           (LoggerContext->NumberOfBuffers > LoggerContext->BuffersAvailable)) {
        Status = KeWaitForSingleObject(
                    &LoggerContext->LoggerSemaphore,
                    Executive,
                    KernelMode,
                    FALSE,
                    &WmiOneSecond);
        WmipFlushActiveBuffers(LoggerContext, 1);
        TraceDebug((2, "WmipLogger: Stop %d %d %d %d %d\n",
                        LoggerContext->LoggerId,
                        LoggerContext->BuffersAvailable,
                        LoggerContext->BuffersInUse,
                        LoggerContext->BuffersDirty,
                        LoggerContext->NumberOfBuffers));
    }

    //
    // Note that LoggerContext->LogFileObject needs to remain set
    //    for QueryLogger to work after close
    //
    if (LoggerContext->LogFileHandle != NULL) {
        ZwClose(LoggerContext->LogFileHandle);
        TraceDebug((1, "WmipLogger: Close logfile with status=%X\n", Status));
    }
    LoggerContext->LogFileHandle = NULL;
    KeSetEvent(&LoggerContext->FlushEvent, 0, FALSE);
    KeSetEvent(&LoggerContext->LoggerEvent, 0, FALSE);
#if DBG
    if (!NT_SUCCESS(Status)) {
        TraceDebug((1, "WmipLogger: Aborting %d %X\n",
                        LoggerContext->LoggerId, LoggerContext->LoggerStatus));
    }
#endif

    WmipFreeLoggerContext(LoggerContext);

#ifdef NTPERF
    //
    // Check if we are logging into perfmem.
    //
    if (PERFINFO_IS_LOGGING_TO_PERFMEM()) {
        PerfInfoStopPerfMemLog();
    }
#endif //NTPERF

    PsTerminateSystemThread(Status);
}

NTSTATUS
WmipSendNotification(
    PWMI_LOGGER_CONTEXT LoggerContext,
    NTSTATUS            Status,
    ULONG               Flag
    )
{
    WMI_TRACE_EVENT WmiEvent;

    RtlZeroMemory(& WmiEvent, sizeof(WmiEvent));
    WmiEvent.Status = Status;
    KeQuerySystemTime(& WmiEvent.Wnode.TimeStamp);

    WmiEvent.Wnode.BufferSize = sizeof(WmiEvent);
    WmiEvent.Wnode.Guid       = TraceErrorGuid;
    WmiSetLoggerId(
          LoggerContext->LoggerId,
          (PTRACE_ENABLE_CONTEXT) & WmiEvent.Wnode.HistoricalContext);

    WmiEvent.Wnode.ClientContext = 0XFFFFFFFF;
    WmiEvent.TraceErrorFlag = Flag;

    WmipProcessEvent(&WmiEvent.Wnode,
                     FALSE,
                     FALSE);
    

    return STATUS_SUCCESS;
}

//
// convenience routine to flush the current buffer by the logger above
//

NTSTATUS
WmipFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER Buffer,
    IN USHORT BufferFlag
    )
/*++

Routine Description:
    This function is responsible for flushing a filled buffer out to
    disk, or to a real time consumer.

Arguments:

    LoggerContext -      Context of the logger

    Buffer - 

    BufferFlag -

Return Value:

    The status of flushing the buffer

--*/
{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status;
    ULONG BufferSize;
    ULONG BufferPersistenceData = LoggerContext->RequestFlag
                                & (  REQUEST_FLAG_CIRCULAR_PERSIST
                                   | REQUEST_FLAG_CIRCULAR_TRANSITION);

    ASSERT(LoggerContext != NULL);
    ASSERT(Buffer != NULL);

    if (LoggerContext == NULL || Buffer == NULL) {
        return STATUS_SEVERITY_ERROR;
    }

    //
    // Grab the buffer to be flushed
    //
    BufferSize = LoggerContext->BufferSize;

    //
    // Put end of record marker in buffer if available space
    //

    TraceDebug((2, "WmipFlushBuffer: %p, Flushed %X %8x %8x %5d\n",
                Buffer,
                Buffer->ClientContext, Buffer->SavedOffset,
                Buffer->CurrentOffset, LoggerContext->BuffersWritten));

    Status = WmipPrepareHeader(LoggerContext, Buffer, BufferFlag);

    if (Status == STATUS_SUCCESS) {

        //
        // Buffering mode is mutually exclusive with REAL_TIME_MODE
        //
        if (!(LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE)) {
            if (LoggerContext->LoggerMode & EVENT_TRACE_REAL_TIME_MODE) {

                if (LoggerContext->UsePerfClock == EVENT_TRACE_CLOCK_PERFCOUNTER) {
                    Buffer->Wnode.Flags |= WNODE_FLAG_USE_TIMESTAMP;
                }

                // need to see if we can send anymore
                // check for queue length
                if (! NT_SUCCESS(WmipProcessEvent((PWNODE_HEADER)Buffer,
                                                  FALSE,
                                                  FALSE))) {
                    LoggerContext->RealTimeBuffersLost++;
                }
            }
        }

        if (LoggerContext->LogFileHandle != NULL) {

            if (LoggerContext->MaximumFileSize > 0) { // if quota given
                ULONG64 FileSize = LoggerContext->LastFlushedBuffer * BufferSize;
                ULONG64 FileLimit = LoggerContext->MaximumFileSize * BYTES_PER_MB;
                if (LoggerContext->LoggerMode & EVENT_TRACE_USE_KBYTES_FOR_SIZE) {
                    FileLimit = LoggerContext->MaximumFileSize * 1024;
                }

                if ( FileSize >= FileLimit ) {

                    ULONG LoggerMode = LoggerContext->LoggerMode & 0X000000FF;
                    //
                    // Files from user mode always have the APPEND flag. 
                    // We mask it out here to simplify the testing below.
                    //
                    LoggerMode &= ~EVENT_TRACE_FILE_MODE_APPEND;
                    //
                    // PREALLOCATE flag has to go, too. 
                    //
                    LoggerMode &= ~EVENT_TRACE_FILE_MODE_PREALLOCATE;

                    if (LoggerMode == EVENT_TRACE_FILE_MODE_SEQUENTIAL) {
                        // do not write to logfile anymore

                        Status = STATUS_LOG_FILE_FULL; // control needs to stop logging
                        // need to fire up a Wmi Event to control console
                        WmipSendNotification(LoggerContext,
                            Status, STATUS_SEVERITY_ERROR);
                    }
                    else if (LoggerMode == EVENT_TRACE_FILE_MODE_CIRCULAR ||
                             LoggerMode == EVENT_TRACE_FILE_MODE_CIRCULAR_PERSIST) {
                        if (BufferPersistenceData > 0) {
                            // treat circular logfile as sequential logfile if
                            // logger still processes Persistence events (events
                            // that cannot be overwritten in circular manner).
                            //
                            Status = STATUS_LOG_FILE_FULL;
                            WmipSendNotification(LoggerContext,
                                Status, STATUS_SEVERITY_ERROR);
                        }
                        else {
                            // reposition file

                            LoggerContext->ByteOffset
                                    = LoggerContext->FirstBufferOffset;
                            LoggerContext->LastFlushedBuffer = (ULONG)
                                      (LoggerContext->FirstBufferOffset.QuadPart
                                    / LoggerContext->BufferSize);
                        }
                    }
                    else if (LoggerMode & EVENT_TRACE_FILE_MODE_NEWFILE) {

                        //
                        // We will set the RequestFlag to initiate a file switch. 
                        // If that flag is already set, then we continnue to flush
                        // past the FileLimit.  
                        //
                        // There should be no race condition with an UpdateTrace
                        // setting the RequestFlag since we do not allow change of
                        // filename for NEWFILE mode. 
                        //

                        if ( (LoggerContext->RequestFlag & REQUEST_FLAG_NEW_FILE) != 
                             REQUEST_FLAG_NEW_FILE) 
                        {
                            LoggerContext->RequestFlag |= REQUEST_FLAG_NEW_FILE;
                        }
                    }
                }
            }

            if (NT_SUCCESS(Status)) {
                Status = ZwWriteFile(
                            LoggerContext->LogFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatus,
                            Buffer,
                            BufferSize,
                            &LoggerContext->ByteOffset,
                            NULL);
                if (NT_SUCCESS(Status)) {
                    LoggerContext->ByteOffset.QuadPart += BufferSize;
                    if (BufferPersistenceData > 0) {
                        // update FirstBufferOffset so that persistence event will
                        // not be overwritten in circular logfile
                        //
                        LoggerContext->FirstBufferOffset.QuadPart += BufferSize;
                    }
                }
                else if (Status == STATUS_LOG_FILE_FULL ||
                         Status == STATUS_DISK_FULL) {
                    // need to fire up a Wmi Event to control console
                    WmipSendNotification(LoggerContext,
                        STATUS_LOG_FILE_FULL, STATUS_SEVERITY_ERROR);
                }
                else {
                    TraceDebug((2, "WmipFlushBuffer: Unknown WriteFile Failure with status=%X\n", Status));
                }
            }
        }

        // Now do callbacks. This happens whether a file exists or not.
        if (WmipGlobalBufferCallback) {
            (WmipGlobalBufferCallback) (Buffer, WmipGlobalCallbackContext);
        }
        if (LoggerContext->BufferCallback) {
            (LoggerContext->BufferCallback) (Buffer, LoggerContext->CallbackContext);
        }
    }

    if (NT_SUCCESS(Status)) {
        LoggerContext->BuffersWritten++;
        LoggerContext->LastFlushedBuffer++;
    }
    else {
#if DBG
        if (Status == STATUS_NO_DATA_DETECTED) {
            TraceDebug((2, "WmipFlushBuffer: Empty buffer detected\n"));
        }
        else if (Status == STATUS_SEVERITY_WARNING) {
            TraceDebug((2, "WmipFlushBuffer: Buffer could be corrupted\n"));
        }
        else {
            TraceDebug((2,
                "WmipFlushBuffer: Unable to write buffer: status=%X\n",
                Status));
        }
#endif
        if ((Status != STATUS_NO_DATA_DETECTED) &&
            (Status != STATUS_SEVERITY_WARNING))
            LoggerContext->LogBuffersLost++;
    }

    return Status;
}

NTSTATUS
WmipCreateLogFile(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG SwitchFile,
    IN ULONG Append
    )
{
    NTSTATUS Status;
    HANDLE newHandle = NULL;
    IO_STATUS_BLOCK IoStatus;
    FILE_STANDARD_INFORMATION FileSize = {0};
    LARGE_INTEGER ByteOffset;
    BOOLEAN FileSwitched = FALSE;
    UNICODE_STRING OldLogFileName;

    PWCHAR            strLogFileName = NULL;
    PUCHAR            pFirstBuffer = NULL;

    PAGED_CODE();

    RtlZeroMemory(&OldLogFileName, sizeof(UNICODE_STRING));
    LoggerContext->RequestFlag &= ~REQUEST_FLAG_NEW_FILE;

    pFirstBuffer = (PUCHAR) ExAllocatePoolWithTag(
            PagedPool, LoggerContext->BufferSize, TRACEPOOLTAG);
    if(pFirstBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pFirstBuffer, LoggerContext->BufferSize);

    if (SwitchFile) {
        Status = WmipCreateNtFileName(
                        LoggerContext->NewLogFileName.Buffer,
                        & strLogFileName);
    }
    else {
        Status = WmipCreateNtFileName(
                        LoggerContext->LogFileName.Buffer,
                        & strLogFileName);
    }
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    if (LoggerContext->ClientSecurityContext.ClientToken != NULL) {
        Status = SeImpersonateClientEx(
                        &LoggerContext->ClientSecurityContext, NULL);
    }
    if (NT_SUCCESS(Status)) {
        // first open logfile using user security context
        //
        Status = WmipCreateDirectoryFile(strLogFileName, FALSE, & newHandle, Append);
        PsRevertToSelf();
    }
    if (!NT_SUCCESS(Status)) {
        // if using user security context fails to open logfile,
        // then try open logfile again using local system security context
        //
        Status = WmipCreateDirectoryFile(strLogFileName, FALSE, & newHandle, Append);
    }

    if (NT_SUCCESS(Status)) {
        HANDLE tempHandle = LoggerContext->LogFileHandle;
        PWMI_BUFFER_HEADER    BufferChecksum;
        PTRACE_LOGFILE_HEADER LogfileHeaderChecksum;
        ULONG BuffersWritten = 0;

        BufferChecksum = (PWMI_BUFFER_HEADER) LoggerContext->LoggerHeader;
        LogfileHeaderChecksum = (PTRACE_LOGFILE_HEADER)
                (((PUCHAR) BufferChecksum) + sizeof(WNODE_HEADER));
        if (LogfileHeaderChecksum) {
            BuffersWritten = LogfileHeaderChecksum->BuffersWritten;
        }

        ByteOffset.QuadPart = 0;
        Status = ZwReadFile(
                    newHandle,
                    NULL,
                    NULL,
                    NULL,
                    & IoStatus,
                    pFirstBuffer,
                    LoggerContext->BufferSize,
                    & ByteOffset,
                    NULL);
        if (NT_SUCCESS(Status)) {
            PWMI_BUFFER_HEADER    BufferFile;
            PTRACE_LOGFILE_HEADER LogfileHeaderFile;
            ULONG Size;

            BufferFile =
                    (PWMI_BUFFER_HEADER) pFirstBuffer;

            if (BufferFile->Wnode.BufferSize != LoggerContext->BufferSize) {
                TraceDebug((1,
                        "WmipCreateLogFile::BufferSize check fails (%d,%d)\n",
                        BufferFile->Wnode.BufferSize,
                        LoggerContext->BufferSize));
                Status = STATUS_FAIL_CHECK;
                ZwClose(newHandle);
                goto Cleanup;
            }

            if (RtlCompareMemory(BufferFile,
                                 BufferChecksum,
                                 sizeof(WNODE_HEADER))
                        != sizeof(WNODE_HEADER)) {
                TraceDebug((1,"WmipCreateLogFile::WNODE_HEAD check fails\n"));
                Status = STATUS_FAIL_CHECK;
                ZwClose(newHandle);
                goto Cleanup;
            }

            LogfileHeaderFile = (PTRACE_LOGFILE_HEADER)
                    (((PUCHAR) BufferFile) + sizeof(WMI_BUFFER_HEADER)
                                          + sizeof(SYSTEM_TRACE_HEADER));

            // We can only validate part of the header because a 32-bit
            // DLL will be passing in 32-bit pointers
            Size = FIELD_OFFSET(TRACE_LOGFILE_HEADER, LoggerName);
            if (RtlCompareMemory(LogfileHeaderFile,
                                  LogfileHeaderChecksum,
                                  Size)
                        != Size) {
                TraceDebug((1,
                    "WmipCreateLogFile::TRACE_LOGFILE_HEAD check fails\n"));
                Status = STATUS_FAIL_CHECK;
                ZwClose(newHandle);
                goto Cleanup;
            }
        }
        else {
            ZwClose(newHandle);
            goto Cleanup;
        }

        if (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) {
            ByteOffset.QuadPart = ((LONGLONG) LoggerContext->BufferSize) * BuffersWritten;
        }
        else {
            Status = ZwQueryInformationFile(
                            newHandle,
                            &IoStatus,
                            &FileSize,
                            sizeof (FILE_STANDARD_INFORMATION),
                            FileStandardInformation
                            );
            if (!NT_SUCCESS(Status)) {
                ZwClose(newHandle);
                goto Cleanup;
            }

            ByteOffset = FileSize.EndOfFile;
        }

        //
        // Force to 1K alignment. In future, if disk alignment exceeds this,
        // then use that
        //
        if ((ByteOffset.QuadPart % 1024) != 0) {
            ByteOffset.QuadPart = ((ByteOffset.QuadPart / 1024) + 1) * 1024;
        }

        if (!(LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_PREALLOCATE)) {
            // NOTE: Should also validate BuffersWritten from logfile header with
            // the end of file to make sure that no one else has written garbage
            // to it
            //
            if (ByteOffset.QuadPart !=
                        (  ((LONGLONG) LoggerContext->BufferSize)
                         * BuffersWritten)) {
                TraceDebug((1,
                        "WmipCreateLogFile::FileSize check fails (%I64d,%I64d)\n",
                        ByteOffset.QuadPart,
                        (  ((LONGLONG) LoggerContext->BufferSize)
                         * BuffersWritten)));
                Status = STATUS_FAIL_CHECK;
                ZwClose(newHandle);
                goto Cleanup;
            }
        }

        //
        // Before Switching to the newfile, let's finalize the old file
        //

        if ( SwitchFile && (tempHandle != NULL) ) {
            WmipFinalizeHeader(tempHandle, LoggerContext);
        }

        LoggerContext->FirstBufferOffset = ByteOffset;
        LoggerContext->ByteOffset        = ByteOffset;

        if (LoggerContext->LoggerMode & EVENT_TRACE_FILE_MODE_PREALLOCATE) {
            LoggerContext->BuffersWritten = BuffersWritten;
        }
        else {
            LoggerContext->BuffersWritten = (ULONG) (FileSize.EndOfFile.QuadPart / LoggerContext->BufferSize);
        }

        LoggerContext->LastFlushedBuffer = LoggerContext->BuffersWritten;

        // Update the log file handle and log file name in the LoggerContext
        LoggerContext->LogFileHandle = newHandle;

        if (SwitchFile) {

            OldLogFileName = LoggerContext->LogFileName;
            LoggerContext->LogFileName = LoggerContext->NewLogFileName;
            FileSwitched = TRUE;

            if ( tempHandle != NULL) {
                //
                // just to be safe, close old file after the switch
                //
                TraceDebug((1, "WmipCreateLogFile: Closing handle %X\n",
                    tempHandle));
                ZwClose(tempHandle);
            }
        }
    }

#if DBG
    else {
        TraceDebug((1,
            "WmipCreateLogFile: ZwCreateFile(%ws) failed with status=%X\n",
            LoggerContext->LogFileName.Buffer, Status));
    }
#endif

Cleanup:
    if (LoggerContext->ClientSecurityContext.ClientToken != NULL) {
        SeDeleteClientSecurity(& LoggerContext->ClientSecurityContext);
        LoggerContext->ClientSecurityContext.ClientToken = NULL;
    }

    // Clean up unicode strings.
    if (SwitchFile) {
        if (!FileSwitched) {
            RtlFreeUnicodeString(&LoggerContext->NewLogFileName);
        }
        else if (OldLogFileName.Buffer != NULL) {
            // OldLogFileName.Buffer can still be NULL if it is the first update
            // for the Kernel Logger.
            RtlFreeUnicodeString(&OldLogFileName);
        }
        // Must do this for the next file switch.
        RtlZeroMemory(&LoggerContext->NewLogFileName, sizeof(UNICODE_STRING));
    }

    if (strLogFileName != NULL) {
        ExFreePool(strLogFileName);
    }
    if (pFirstBuffer != NULL) {
        ExFreePool(pFirstBuffer);
    }
    LoggerContext->LoggerStatus = Status;
    return Status;
}

ULONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER BufferResource,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    ULONG BufRefCount;
    LONG  ReleaseQueue;

    ASSERT(LoggerContext);
    ASSERT(BufferResource);

    BufRefCount = InterlockedDecrement((PLONG) &BufferResource->ReferenceCount);

    //
    // Check if there are buffers to be flushed.
    //
    if (LoggerContext->ReleaseQueue) {
        if (KeGetCurrentIrql() <= DISPATCH_LEVEL) {
            WmipNotifyLogger(LoggerContext);
            LoggerContext->ReleaseQueue = 0;
        }
    }

    ReleaseQueue = LoggerContext->ReleaseQueue;
    WmipDereferenceLogger(LoggerContext->LoggerId);
    return (ReleaseQueue);
}

NTKERNELAPI
ULONG
FASTCALL
WmiReleaseKernelBuffer(
    IN PWMI_BUFFER_HEADER BufferResource
    )
{
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext[WmipKernelLogger];
    if (LoggerContext == (PWMI_LOGGER_CONTEXT) &WmipLoggerContext[0]) {
        LoggerContext = BufferResource->LoggerContext;
    }
    WmipAssert(LoggerContext != NULL);
    WmipAssert(LoggerContext != (PWMI_LOGGER_CONTEXT) &WmipLoggerContext[0]);
    return WmipReleaseTraceBuffer(BufferResource, LoggerContext);
}

NTSTATUS
WmipFlushBuffersWithMarker (
    IN PWMI_LOGGER_CONTEXT  LoggerContext,
    IN PSLIST_ENTRY         List,
    IN USHORT               BufferFlag
    ) 
{
    PSLIST_ENTRY  LocalList, Entry;
    PWMI_BUFFER_HEADER Buffer;
    PWMI_BUFFER_HEADER TmpBuffer=NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Retry;
    ULONG BufferCounts = 0;
    USHORT Flag = WMI_BUFFER_FLAG_NORMAL;
    ULONG ErrorCount = 0;

    LocalList = List;

    //
    // Reverse the list to preserve the FIFO order
    //
    Entry = NULL;
    while (LocalList!=NULL) {
        PSLIST_ENTRY  Next;
        Next = LocalList->Next;
        LocalList->Next = Entry;
        Entry = LocalList;
        LocalList = Next;
        BufferCounts++;
    }
    LocalList = Entry;

    //
    // Write all buffers into disk
    //
    while (LocalList != NULL){
        BufferCounts--;
        if (BufferCounts == 0) {
            //
            // Only set the flag at the last buffer.
            //
            Flag = BufferFlag;
        }

        Entry = LocalList;
        LocalList = LocalList->Next;

        Buffer = CONTAINING_RECORD(Entry,
                                   WMI_BUFFER_HEADER,
                                   SlistEntry);

        if (!(LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE)) {
            //
            // When there is a bursty logging, we can be stuck in this loop.
            // Check if we need to allocate more buffers
            //
            // Only do buffer adjustment if we are not in buffering mode
            //
            WmipAdjustFreeBuffers(LoggerContext);
        }
    

        //
        //
        // Wait until no one else is using the buffer before
        // writing it out.
        //
             
        Retry = 0;
        TmpBuffer = Buffer;
        while (Buffer->ReferenceCount) {
            TraceDebug((1,"Waiting for reference count %3d, retry: %3d\n", 
                        Buffer->ReferenceCount, Retry));
            //
            //
            //
            KeDelayExecutionThread (KernelMode,
                                    FALSE, 
                                    (PLARGE_INTEGER)&WmiShortTime);
            Retry++;
            if (Retry > 10) {
                //
                // The buffer is still in use, we cannot overwite the header.
                // Otherwise it will cause buffer corrution.
                // Use a tempamory buffer instead.
                //
                ULONG BufferSize = LoggerContext->BufferSize;
                TmpBuffer = ExAllocatePoolWithTag(NonPagedPool, 
                                                  BufferSize,
                                                  TRACEPOOLTAG);
    
                if (TmpBuffer) {
                    TraceDebug((1,"Buffer %p has ref count %3d, Tmporary buffer %p Allocated\n", 
                                   Buffer,
                                   Buffer->ReferenceCount,
                                   TmpBuffer));

                    RtlCopyMemory(TmpBuffer, Buffer, BufferSize);
                } else {
                    Status = STATUS_NO_MEMORY;
                }
                break;
            }
        }

        if (TmpBuffer) {
            Status = WmipFlushBuffer(LoggerContext, TmpBuffer, Flag);
        } else {
            //
            // The buffer still in use but allocation of temporary
            // buffer failed.
            // Cannot write this buffer out, claim it as buffer lost
            //

            // If this were the last buffer on file, post processing can
            // fail due to marker buffer failing.  

            LoggerContext->LogBuffersLost++;
        }

        if (TmpBuffer != Buffer) {
            if (TmpBuffer != NULL) {
                ExFreePool(TmpBuffer);
            }
            InterlockedPushEntrySList(&LoggerContext->WaitList,
                                      (PSLIST_ENTRY) &Buffer->SlistEntry);
        } else {
            //
            // Reference count is overwriten during the flush,
            // Set it back.
            //
            Buffer->ReferenceCount = 0;
            WmipPushFreeBuffer (LoggerContext, Buffer);
        }

        if ((Status == STATUS_LOG_FILE_FULL) ||
            (Status == STATUS_DISK_FULL) ||
            (Status == STATUS_NO_DATA_DETECTED) ||
            (Status == STATUS_SEVERITY_WARNING)) {
 
            TraceDebug((1,
                "WmipFlushActiveBuffers: Buffer flushed with status=%X\n",
                Status));
            if ((Status == STATUS_LOG_FILE_FULL) ||
                (Status == STATUS_DISK_FULL)) {
                ErrorCount ++;
            } else {
                ErrorCount = 0; // reset to zero otherwise
            }

            if (ErrorCount <= WmiWriteFailureLimit) {
                Status = STATUS_SUCCESS;     // Let tracing continue
                continue;       // for now. Should raise WMI event
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        TraceDebug((1,
            "WmipLogger: Flush failed, status=%X LoggerContext=%X\n",
                 Status, LoggerContext));
        if (LoggerContext->LogFileHandle != NULL) {
#if DBG
            NTSTATUS CloseStatus = 
#endif
            ZwClose(LoggerContext->LogFileHandle);
            TraceDebug((1,
                "WmipLogger: Close logfile with status=%X\n", CloseStatus));
        }
        LoggerContext->LogFileHandle = NULL;

        WmipSendNotification(LoggerContext,
            Status, (Status & 0xC0000000) >> 30);

    }

    return Status;
}

NTSTATUS
WmipFlushActiveBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG FlushAll
    )
{
    PWMI_BUFFER_HEADER Buffer;
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LoggerMode;
    PSLIST_ENTRY  LocalList, Entry;


    PAGED_CODE();

    //
    // If we have no LogFileHandle or RealTime mode, and the collection
    // is still on, we simply return and let the buffers back up potentially
    // losing events. If the Collection is Off under these conditions
    // we will simply move the FlushList to FreeList as in Buffering mode. 
    //

    LoggerMode = LoggerContext->LoggerMode;

    if ( (LoggerContext->LogFileHandle == NULL)       &&
         (!(LoggerMode & EVENT_TRACE_REAL_TIME_MODE)) &&
         (LoggerContext->CollectionOn) ) 
    {
        return Status;
    }


    LocalList = NULL;
    if (FlushAll) {
        PWMI_BUFFER_HEADER Buffers[MAXIMUM_PROCESSORS];
        //
        // First switch all in-used buffers.
        // Put them in a tighter loop to minimize the chance of
        // events out of order.
        //
        for (i=0; i<(ULONG)KeNumberProcessors; i++) {
            Buffers[i] = InterlockedExchangePointer(&LoggerContext->ProcessorBuffers[i], NULL);
        }

        //
        // Put all in-used buffers into flush list
        //
        for (i=0; i<(ULONG)KeNumberProcessors; i++) {
            if (Buffers[i]) {
                WmipPushDirtyBuffer ( LoggerContext, Buffers[i] );
            }
        }

        if (LoggerContext->LoggerId == WmipKernelLogger) {
            if ( PERFINFO_IS_GROUP_ON(PERF_CONTEXT_SWITCH) ) {
                for (i=0; i<(ULONG)KeNumberProcessors; i++) {
                    //
                    // Flush all Buffers used for Context swaps
                    //
                    Buffer = InterlockedExchangePointer(&WmipContextSwapProcessorBuffers[i], NULL);
                    if (Buffer) {
                        WmipPushDirtyBuffer ( LoggerContext, Buffer);
                    }
                }
            }
#ifdef NTPERF
            //
            // Flush all buffer logging from user mode
            //
            if (PERFINFO_IS_LOGGING_TO_PERFMEM()) {
                PPERFINFO_TRACEBUF_HEADER pPerfBufHdr;
                pPerfBufHdr = PerfBufHdr();

                for (i=0; i<(ULONG)KeNumberProcessors; i++) {
                    Buffer = pPerfBufHdr->UserModePerCpuBuffer[i];
                    if (Buffer) {
                        pPerfBufHdr->UserModePerCpuBuffer[i] = NULL;
                        WmipPushDirtyBuffer ( LoggerContext, Buffer);
                    }
                }
            }
#endif //NTPERF
        }

        //
        //  Now push all dirty buffers in the local list.
        //  This almost guarantees that the flush marker will work.
        //
        if (ExQueryDepthSList(&LoggerContext->FlushList) != 0) {
            LocalList = ExInterlockedFlushSList (&LoggerContext->FlushList);
            WmipFlushBuffersWithMarker (LoggerContext, LocalList, WMI_BUFFER_FLAG_FLUSH_MARKER);
        }

    } else if (ExQueryDepthSList(&LoggerContext->FlushList) != 0) {
        LocalList = ExInterlockedFlushSList (&LoggerContext->FlushList);
        WmipFlushBuffersWithMarker (LoggerContext, LocalList, WMI_BUFFER_FLAG_NORMAL);
    }

    //
    // Now check if any of the in-used buffer is freed.
    //
    if (ExQueryDepthSList(&LoggerContext->WaitList) != 0) {
        LocalList = ExInterlockedFlushSList (&LoggerContext->WaitList);
        while (LocalList != NULL){
            Entry = LocalList;
            LocalList = LocalList->Next;

            Buffer = CONTAINING_RECORD(Entry,
                                       WMI_BUFFER_HEADER,
                                       SlistEntry);

            TraceDebug((1,"Wait List Buffer %p RefCount: %3d\n", 
                           Buffer,
                           Buffer->ReferenceCount));

            if (Buffer->ReferenceCount) {

                //
                // Still in use, put it back to WaitList
                //
                InterlockedPushEntrySList(&LoggerContext->WaitList,
                                          (PSLIST_ENTRY) &Buffer->SlistEntry);

            } else {
                //
                // Push it to free list
                //
                WmipPushFreeBuffer (LoggerContext, Buffer);
            }
        }

    }
    return Status;
}

NTSTATUS
WmipGenerateFileName(
    IN PUNICODE_STRING FilePattern,
    IN OUT PLONG FileCounter,
    OUT PUNICODE_STRING FileName
    )
{
    LONG FileCount, Size;
    PWCHAR Buffer = NULL;
    HRESULT hr;
    PWCHAR wcptr;

    PAGED_CODE();

    if (FilePattern->Buffer == NULL)
        return STATUS_INVALID_PARAMETER_MIX;

    // Check for valid format string
    wcptr = wcschr(FilePattern->Buffer, L'%');
    if (NULL == wcptr || wcptr != wcsrchr(FilePattern->Buffer, L'%')) {
        return STATUS_OBJECT_NAME_INVALID;
    }
    else if (NULL == wcsstr(FilePattern->Buffer, L"%d")) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    FileCount = InterlockedIncrement(FileCounter);
    Size = FilePattern->MaximumLength + 64; // 32 digits: plenty for ULONG

    Buffer = ExAllocatePoolWithTag(PagedPool, Size, TRACEPOOLTAG);
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    hr = StringCbPrintfW(Buffer, Size, FilePattern->Buffer, FileCount);

    if (FAILED(hr) || RtlEqualMemory(FilePattern->Buffer, Buffer, FilePattern->Length)) {
        ExFreePool(Buffer);
        return STATUS_INVALID_PARAMETER_MIX;
    }
    RtlInitUnicodeString(FileName, Buffer);
    return STATUS_SUCCESS;
}

NTSTATUS
WmipPrepareHeader(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN OUT PWMI_BUFFER_HEADER Buffer,
    IN USHORT BufferFlag
    )
/*++

Routine Description:
    This routine prepares the buffer header before writing the
    buffer out to Disk.

    If (SavedOffset > 0), it must be the case the we have overflown
    CurrentOffset during WmipReserveTraceBuffer.  SavedOffset should
    be the real offset of dirty buffer area.

    If SavedOffset is not set, it is either a ContextSwap buffer
    or a buffer flushed due to flush timer.  CurrentOffset should
    be used for writting it out.


Calling Functions:
    - WmipFlushBuffer

Arguments:

    LoggerContext - Logger context

    Buffer        - Pointer to a buffer header that we wish to write to disk

Return Value:

    NtStatus.

--*/
{
    ULONG BufferSize;
    PAGED_CODE();

    BufferSize = LoggerContext->BufferSize;

    if (Buffer->SavedOffset > 0) {
        Buffer->Offset = Buffer->SavedOffset;
    }
    else {
        if (Buffer->CurrentOffset > BufferSize) {
            //
            // Some thread has incremented CurrentOffset but was swapped out 
            // and did not come back until the buffer is about to be flushed.
            // We will correct the CurrentOffset here and hope that post
            // processing will handle this correctly.
            //
            TraceDebug((3, "WmipPrepareHeader: correcting Buffer Offset %d, RefCount: %d\n",
                        Buffer->CurrentOffset, Buffer->ReferenceCount));
            Buffer->Offset = BufferSize;
        }
        else {
            Buffer->Offset = Buffer->CurrentOffset;
        }
    }

    ASSERT (Buffer->Offset >= sizeof(WMI_BUFFER_HEADER));
    ASSERT (Buffer->Offset <= LoggerContext->BufferSize);


    //
    // We write empty buffers if they have FLUSH_MARKER to facilitate 
    // post processing
    //

    if ( (BufferFlag != WMI_BUFFER_FLAG_FLUSH_MARKER) && (Buffer->Offset == sizeof(WMI_BUFFER_HEADER)) ) { // empty buffer
        return STATUS_NO_DATA_DETECTED;
    }

    //
    // Fill the rest of buffer with 0XFF
    //
    if ( Buffer->Offset < BufferSize ) {
        RtlFillMemory(
            (char *) Buffer + Buffer->Offset,
            BufferSize - Buffer->Offset,
            0XFF);
    }

    Buffer->Wnode.BufferSize = BufferSize;
    Buffer->ClientContext.LoggerId = (USHORT) LoggerContext->LoggerId;
    if (Buffer->ClientContext.LoggerId == 0)
        Buffer->ClientContext.LoggerId = (USHORT) KERNEL_LOGGER_ID;

    Buffer->ClientContext.Alignment = (UCHAR) WmiTraceAlignment;
    Buffer->Wnode.Guid = LoggerContext->InstanceGuid;
    Buffer->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    Buffer->Wnode.ProviderId = LoggerContext->BuffersWritten+1;
    Buffer->BufferFlag = BufferFlag;

    KeQuerySystemTime(&Buffer->Wnode.TimeStamp);
    return STATUS_SUCCESS;
}

NTKERNELAPI
VOID
WmiBootPhase1(
    )                
/*++

Routine Description:

    NtInitializeRegistry to inform WMI that autochk is performed
    and it is OK now to write to disk.

Arguments:

    None

Return Value:

    None

--*/

{
    PAGED_CODE();

    WmipFileSystemReady = TRUE;
}


NTSTATUS
WmipFinalizeHeader(
    IN HANDLE FileHandle,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    )
{
    LARGE_INTEGER ByteOffset;
    NTSTATUS Status;
    PTRACE_LOGFILE_HEADER FileHeader;
    IO_STATUS_BLOCK IoStatus;
    CHAR Buffer[PAGE_SIZE];     // Assumes Headers less than PAGE_SIZE

    PAGED_CODE();

    ByteOffset.QuadPart = 0;
    Status = ZwReadFile(
                FileHandle,
                NULL,
                NULL,
                NULL,
                & IoStatus,
                &Buffer[0],
                PAGE_SIZE,
                & ByteOffset,
                NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    FileHeader = (PTRACE_LOGFILE_HEADER)
                 &Buffer[sizeof(WMI_BUFFER_HEADER) + sizeof(SYSTEM_TRACE_HEADER)];
    FileHeader->BuffersWritten = LoggerContext->BuffersWritten;

    if (LoggerContext->RequestFlag & REQUEST_FLAG_CIRCULAR_TRANSITION) {
        FileHeader->StartBuffers = (ULONG) 
                                   (LoggerContext->FirstBufferOffset.QuadPart
                                   / LoggerContext->BufferSize);
    }

    KeQuerySystemTime(&FileHeader->EndTime);
    if (LoggerContext->Wow && !LoggerContext->KernelTraceOn) {
        // We need to adjust a log file header for a non-kernel WOW64 logger.
        *((PULONG)((PUCHAR)(&FileHeader->BuffersLost) - 8)) 
                                            = LoggerContext->LogBuffersLost;
    }
    else {
        FileHeader->BuffersLost = LoggerContext->LogBuffersLost;
    }
    FileHeader->EventsLost = LoggerContext->EventsLost;
    Status = ZwWriteFile(
                FileHandle,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                &Buffer[0],
                PAGE_SIZE,
                &ByteOffset,
                NULL);
    return Status;
}

#if DBG

#define DEBUG_BUFFER_LENGTH 1024
UCHAR TraceDebugBuffer[DEBUG_BUFFER_LENGTH];

VOID
TraceDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all DiskPerf

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    LARGE_INTEGER Clock;
    ULONG Tid;
    va_list ap;

    va_start(ap, DebugMessage);


    if  (WmipTraceDebugLevel >= DebugPrintLevel) {

        StringCbVPrintfA((PCHAR)TraceDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        Clock = KeQueryPerformanceCounter(NULL);
        Tid = HandleToUlong(PsGetCurrentThreadId());
        DbgPrintEx(DPFLTR_WMILIB_ID, DPFLTR_INFO_LEVEL,
                   "%u (%5u): %s", Clock.LowPart, Tid, TraceDebugBuffer);
    }

    va_end(ap);

}
#endif //DBG


VOID
FASTCALL
WmipResetBufferHeader (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer,
    USHORT                  BufferType
    )
/*++

Routine Description:
    This is a function which initializes a few buffer header values
    that are used by both WmipGetFreeBuffer and WmipPopFreeContextSwapBuffer

    Note that this function increments a few logger context reference counts

Calling Functions:
    - WmipGetFreeBuffer
    - WmipPopFreeContextSwapBuffer

Arguments:

    LoggerContext - Logger context from where we have acquired a free buffer

    Buffer        - Pointer to a buffer header that we wish to reset

    BufferType    - Buffer type (e.g., Generic, ContextSwap, etc.).
                    This is to make postprocessing easier.

Return Value:

    None

--*/
{
    ASSERT (BufferType < WMI_BUFFER_TYPE_MAXIMUM);
    Buffer->SavedOffset = 0;
    Buffer->CurrentOffset = sizeof(WMI_BUFFER_HEADER);
    Buffer->Wnode.ClientContext = 0;
    Buffer->LoggerContext = LoggerContext;
    Buffer->BufferType = BufferType;
       
    Buffer->State.Free = 0;
    Buffer->State.InUse = 1;

}


VOID
FASTCALL
WmipPushDirtyBuffer (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer
)
/*++

Routine Description:
    This is a function which prepares a buffer's header and places it on a
    logger's flush list.  

    Note that this function manages a few logger context reference counts

Calling Functions:
    - WmipFlushActiveBuffers
    - WmipPushDirtyContextSwapBuffer

Arguments:

    LoggerContext - Logger context from which we originally acquired a buffer

    Buffer        - Pointer to a buffer that we wish to flush

Return Value:

    None

--*/
{
    ASSERT(Buffer->State.Flush == 0);
    ASSERT(Buffer->State.Free == 0);
    ASSERT(Buffer->State.InUse == 1);
    //
    // Set the buffer flags to "flush" state
    //
    Buffer->State.InUse = 0;
    Buffer->State.Flush = 1;

    //
    // Push the buffer onto the flushlist.  This could only
    // fail if the Wmi kernel logger shut down without notifying us.
    // If this happens, there is nothing we can do about it anyway.
    // If Wmi is well behaved, this will never fail.
    //
    InterlockedPushEntrySList(
        &LoggerContext->FlushList,
        (PSLIST_ENTRY) &Buffer->SlistEntry);

    //
    // Maintain some reference counts
    //
    InterlockedDecrement((PLONG) &LoggerContext->BuffersInUse);
    InterlockedIncrement((PLONG) &LoggerContext->BuffersDirty);


    TraceDebug((2, "Flush Dirty Buffer: %p, Free: %d, InUse: %d, %Dirty: %d, Total: %d, (Thread: %p)\n",
                    Buffer,
                    LoggerContext->BuffersAvailable,
                    LoggerContext->BuffersInUse,
                    LoggerContext->BuffersDirty,
                    LoggerContext->NumberOfBuffers,
                    PsGetCurrentThread()));
}


VOID
FASTCALL
WmipPushFreeBuffer (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer
)
/*++

Routine Description:
    This is a function which prepares a buffer's header and places it on a
    logger's Free list.  

    Note that this function manages a few logger context reference counts

Calling Functions:
    - WmipFlushActiveBuffers
    - WmipGetFreeBuffer

Arguments:

    LoggerContext - Logger context from which we originally acquired a buffer

    Buffer        - Pointer to a buffer that we wish to flush

Return Value:

    None

--*/
{
    //
    // Set the buffer flags to "free" state and save the offset
    //
    Buffer->State.Flush = 0;
    Buffer->State.InUse = 0;
    Buffer->State.Free = 1;

    //
    // Push the buffer onto the free list.  
    //
    InterlockedPushEntrySList(&LoggerContext->FreeList,
                              (PSLIST_ENTRY) &Buffer->SlistEntry);

    //
    // Maintain the reference counts
    //
    InterlockedIncrement((PLONG) &LoggerContext->BuffersAvailable);
    InterlockedDecrement((PLONG) &LoggerContext->BuffersDirty);

    TraceDebug((2, "Push Free Buffer: %p, Free: %d, InUse: %d, %Dirty: %d, Total: %d, (Thread: %p)\n",
                    Buffer,
                    LoggerContext->BuffersAvailable,
                    LoggerContext->BuffersInUse,
                    LoggerContext->BuffersDirty,
                    LoggerContext->NumberOfBuffers,
                    PsGetCurrentThread()));
}


PWMI_BUFFER_HEADER
FASTCALL
WmipPopFreeContextSwapBuffer
    ( UCHAR CurrentProcessor
    )
/*++

Routine Description:

    Attempts to remove a buffer from the kernel logger free buffer list.
    We confirm that logging is on, that buffer switching is
    not in progress and that the buffers available count is greater than
    zero.  If we are unable to acquire a buffer, we increment LostEvents
    and return.  Otherwise, we initialize the buffer and pass it back.

    Assumptions:
    - This routine will only be called from WmiTraceContextSwap
    - Inherits all assumptions listed in WmiTraceContextSwap

    Calling Functions:
    - WmiTraceContextSwap

Arguments:

    CurrentProcessor- The current processor number (0 to (NumProc - 1))

Return Value:

    Pointer to the newly acquired buffer.  NULL on failure.

--*/
{
    PWMI_LOGGER_CONTEXT LoggerContext;
    PWMI_BUFFER_HEADER  Buffer;
        
    LoggerContext = WmipLoggerContext[WmipKernelLogger];
    
    //
    // Could only happen if for some reason the logger has not been initialized
    // before we see the global context swap flag set.  This should not happen.
    //
    if(! WmipIsValidLogger(LoggerContext) ) {
        return NULL;
    }

    //
    // "Switching" is a Wmi state available only while BUFFERING is
    // enabled that occurs when the free buffer list is empty. During switching
    // all the buffers in the flushlist are simply moved back to the free list.
    // Normally if we found that the free list was empty we would perform the
    // switch here, and if the switch was already occuring we would spin until
    // it completed.  Instead of introducing an indefinite spin, as well as a
    // ton of interlocked pops and pushes, we opt to simply drop the event.
    //
    if ( !(LoggerContext->SwitchingInProgress) 
        && LoggerContext->CollectionOn
        && LoggerContext->BuffersAvailable > 0) {

        //
        // Attempt to get a free buffer from the Kernel Logger FreeList
        //
        Buffer = (PWMI_BUFFER_HEADER)InterlockedPopEntrySList(
            &LoggerContext->FreeList);

        //
        // This second check is necessary because
        // LoggerContext->BuffersAvailable may have changed.
        //
        if(Buffer != NULL) {

            Buffer = CONTAINING_RECORD (Buffer, WMI_BUFFER_HEADER, SlistEntry);

            //
            // Reset the buffer header
            //
            WmipResetBufferHeader( LoggerContext, Buffer, WMI_BUFFER_TYPE_CTX_SWAP);
            //
            // Maintain some Wmi logger context buffer counts
            //
            InterlockedDecrement((PLONG) &LoggerContext->BuffersAvailable);
            InterlockedIncrement((PLONG) &LoggerContext->BuffersInUse);

            Buffer->ClientContext.ProcessorNumber = CurrentProcessor;
            Buffer->Offset = LoggerContext->BufferSize;

            ASSERT( Buffer->Offset % WMI_CTXSWAP_EVENTSIZE_ALIGNMENT == 0);

            // Return our buffer
            return Buffer;
        }
    }
    
    LoggerContext->EventsLost++;
    return NULL;
}

VOID
FASTCALL
WmipPushDirtyContextSwapBuffer (
    UCHAR               CurrentProcessor,
    PWMI_BUFFER_HEADER  Buffer
    )
/*++

Routine Description:

    Prepares the current buffer to be placed on the Wmi flushlist
    and then pushes it onto the flushlist.  Maintains some Wmi
    Logger reference counts.

    Assumptions:
    - The value of WmipContextSwapProcessorBuffers[CurrentProcessor]
      is not equal to NULL, and the LoggerContext reference count
      is greater than zero.

    - This routine will only be called when the KernelLogger struct
      has been fully initialized.

    - The Wmi kernel WMI_LOGGER_CONTEXT object, as well as all buffers
      it allocates are allocated from nonpaged pool.  All Wmi globals
      that we access are also in nonpaged memory

    - This code has been locked into paged memory when the logger started

    - The logger context reference count has been "Locked" via the 
      InterlockedIncrement() operation in WmipReferenceLogger(WmipLoggerContext)

    Calling Functions:
    - WmiTraceContextSwap

    - WmipStopContextSwapTrace

Arguments:

    CurrentProcessor    Processor we are currently running on

    Buffer              Buffer to be flushed
    
Return Value:

    None
    
--*/
{
    PWMI_LOGGER_CONTEXT     LoggerContext;

    UNREFERENCED_PARAMETER (CurrentProcessor);

    //
    // Grab the kernel logger context
    // This should never be NULL as long as we keep the KernelLogger
    // reference count above zero via "WmipReferenceLogger"
    //
    LoggerContext = WmipLoggerContext[WmipKernelLogger];
    if( ! WmipIsValidLogger(LoggerContext) ) {
        return;
    }

    WmipPushDirtyBuffer( LoggerContext, Buffer );

    //
    // Increment the ReleaseQueue count here. We can't signal the 
    // logger semaphore here while holding the context swap lock.
    //
    InterlockedIncrement(&LoggerContext->ReleaseQueue);

    return;
}

NTSTATUS
WmipSwitchBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER *BufferPointer,
    IN PVOID BufferPointerLocation,
    IN ULONG ProcessorNumber
    ) 
/*++

Routine Description:

    This routine is used to switch buffers when a buffer is Full.
    
    The mechanism is as follows:

    1. The caller gives us a buffer (OldBuffer) that needs to be switched.
    2. Get a new buufer and use InterlockedCompareExchangePointer to switch buffers
       only if the OldBuffer is still not switched.
    3. If the OldBuffer has been switched, ask the caller to try using the newly
       switched buffer for logging.
    
Assumptions:

    - The LoggerContext is locked before this routine is called.

Arguments:

    LoggerContext - Logger Context.

    BufferPointer - The Old buffer that needs to be switched.

    BufferPointerLocation - The location of the buffer pointer for switching.

    ProcessorNumber - Processor Id. Processor Id is set before switching.

Return Value:

    Status
    
--*/
{
    PWMI_BUFFER_HEADER CurrentBuffer, NewBuffer, OldBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    //
    // Get a new buffer from Free List
    //

    if (!LoggerContext->CollectionOn) {
        Status = STATUS_WMI_ALREADY_DISABLED;
        NewBuffer = NULL;
    } else {
        //
        // Allocate a buffer.
        //

        NewBuffer = WmipGetFreeBuffer (LoggerContext);
        if (NewBuffer) {
            NewBuffer->ClientContext.ProcessorNumber = (UCHAR) ProcessorNumber;

            OldBuffer = *BufferPointer;
    
            CurrentBuffer = InterlockedCompareExchangePointer(
                                BufferPointerLocation,
                                NewBuffer,
                                OldBuffer);
            //
            // There are 3 cases that we need to consider depending on the outcome
            // of InterlockedCompareExchangePointer.
            //
            // 1. CurrentBuffer is NULL and OldBuffer is not. This means FlushAll 
            //    Code path has replaced ProcessorBuffers with NULL after this 
            //    thread got into WmipReserveTraceBuffer. If this is the case, we 
            //    need to do InterlockedCompareExchangePointer with NULL pointer 
            //    one more time to push the good free buffer into ProcessorBuffer.
            // 2. CurrentBuffer is not NULL, but it is not the same buffer we had, 
            //    which means somebody already switched the buffer with a new one.
            //    We push the new buffer we have into FreeList and use 
            //    the current ProcessorBuffer.
            // 3. CurrentBuffer is the same as OldBuffer and it is not NULL, which
            //    means Switching succeeded. Push the old buffer into FlushList and 
            //    wake up the logger thread.
            //
            // If both CurrentBuffer and OldBuffer are NULL, we just switch.
            //
            if (OldBuffer != NULL && CurrentBuffer == NULL) {
                CurrentBuffer = InterlockedCompareExchangePointer(
                                    BufferPointerLocation,
                                    NewBuffer,
                                    NULL);

                //
                // If CurrentBuffer is NULL, we successfully pushed the clean free 
                // buffer into ProcessorBuffer. NewBuffer already points to a new clean
                // Buffer, and WmipFlushActiveBuffers already handled the old buffer 
                // (Pusing to FlushList and all), so there is no need to do anything.
                //

                if (CurrentBuffer != NULL) {
                    //
                    // Somebody pushed a new buffer to ProcessorBuffer between two
                    // InterlockedCompareExchangePointer calls.
                    // We will use the ProcessorBuffer and push our new buffer into
                    // FreeList.
                    //
                    InterlockedPushEntrySList(&LoggerContext->FreeList,
                                        (PSLIST_ENTRY) &NewBuffer->SlistEntry);
                    InterlockedIncrement((PLONG) &LoggerContext->BuffersAvailable);
                    InterlockedDecrement((PLONG) &LoggerContext->BuffersInUse);
    
                    NewBuffer = CurrentBuffer;
                }
            } else if (OldBuffer != CurrentBuffer) {
                //
                // Someone has switched the buffer, use this one
                // and push the new allocated buffer back to free list.
                //
                InterlockedPushEntrySList(&LoggerContext->FreeList,
                                    (PSLIST_ENTRY) &NewBuffer->SlistEntry);
                InterlockedIncrement((PLONG) &LoggerContext->BuffersAvailable);
                InterlockedDecrement((PLONG) &LoggerContext->BuffersInUse);
    
                NewBuffer = CurrentBuffer;
            } else if (OldBuffer != NULL) {
                //
                // Successfully switched the buffer, push the current buffer into
                // flush list
                //
                WmipPushDirtyBuffer( LoggerContext, OldBuffer );

                if (!(LoggerContext->LoggerMode & EVENT_TRACE_BUFFERING_MODE)) {
                    if (KeGetCurrentIrql() <= DISPATCH_LEVEL) {
                        //
                        // Wake up the walker thread to write it out to disk.
                        //
                        WmipNotifyLogger(LoggerContext);
                    } else {
                        //
                        // Queue the item.
                        //
                        InterlockedIncrement(&LoggerContext->ReleaseQueue);
                    }
                }
            }
        } else {
            //
            // There is no free buffer to switch with. NewBuffer is NULL.
            // We just push the processor buffer into FlushList and exit.
            // If we don't do this, CurrentOffset in the processor buffer header 
            // may overflow. 
            //
            OldBuffer = *BufferPointer;
            CurrentBuffer = InterlockedCompareExchangePointer(
                                BufferPointerLocation,
                                NULL,
                                OldBuffer);
            //
            // CurrentBuffer is not NULL, so either we switched it to NULL 
            // ourselves, or someone else has done so right before us.
            //
            if (CurrentBuffer != NULL) {
                if (CurrentBuffer == OldBuffer) {
                    // We switched successfully.
                    // Push the processor buffer to FlushList.
                    WmipPushDirtyBuffer (LoggerContext, OldBuffer);
                    Status = STATUS_NO_MEMORY;
                }
                else { 
                    // Someone has pushed a new free buffer to a processor.
                    // We will try using this buffer.
                    NewBuffer = CurrentBuffer;
                }
            }
            else {
                Status = STATUS_NO_MEMORY;
            }
        }
    }

    TraceDebug((2, "Switching CPU Buffers, CurrentOne: %p\n", *BufferPointer));

    *BufferPointer = NewBuffer;

    TraceDebug((2, "Switching CPU Buffers, New One  : %p, %x\n", *BufferPointer, Status));

    return(Status); 
}

#ifdef NTPERF
NTSTATUS
WmipSwitchPerfmemBuffer(
    PWMI_SWITCH_BUFFER_INFORMATION SwitchBufferInfo
    )

/*++

Routine Description:

    This routine is used to switch buffers when

Assumptions:

    -

Arguments:

    The WMI_SWITCH_PERFMEM_BUFFER_INFORMATION structure which contains

    - The buffer pointer the user mode code currently has.

    - The hint to which CPU for this thread

Return Value:

    Status

--*/
{
    PWMI_LOGGER_CONTEXT LoggerContext = WmipLoggerContext[WmipKernelLogger];
    NTSTATUS Status = STATUS_SUCCESS;
    PPERFINFO_TRACEBUF_HEADER pPerfBufHdr;

    WmipReferenceLogger(WmipKernelLogger);

    if ((PERFINFO_IS_LOGGING_TO_PERFMEM()) &&
        (SwitchBufferInfo->ProcessorId <= MAXIMUM_PROCESSORS)) {

        pPerfBufHdr = PerfBufHdr();

        if( (SwitchBufferInfo->Buffer == NULL)) {
            //
            // Must be first time, initialize the buffer size
            //
            pPerfBufHdr->TraceBufferSize = LoggerContext->BufferSize;
        }

        Status = WmipSwitchBuffer(LoggerContext,
                                  &SwitchBufferInfo->Buffer,
                                  &pPerfBufHdr->UserModePerCpuBuffer[SwitchBufferInfo->ProcessorId],
                                  SwitchBufferInfo->ProcessorId);
    }

    WmipDereferenceLogger(WmipKernelLogger);
    
    return (Status);
}
#endif //NTPERF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\tracep.h ===
#ifndef _TRACEP_H
#define _TRACEP_H
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tracep.h

Abstract:

    Private header for trace component

Author:

    JeePang

Environment:

Revision History:


--*/
#pragma warning(disable:4127)   // condition expression is constant

#include <strsafe.h>

#define MAX_WMI_BUFFER_SIZE     1024    // in KBytes
#define MAX_FILE_TABLE_SIZE     64
#define KERNEL_LOGGER           (0)

// NOTE: Consider allowing user to change the two values below
#define TRACE_MAXIMUM_NP_POOL_USAGE     10  // maximum per cent of NP used
#define BYTES_PER_MB            1048576     // Conversion for FileSizeLimit

#define REQUEST_FLAG_NEW_FILE            0x00000001  // request for new file
#define REQUEST_FLAG_FLUSH_BUFFERS       0x00000002  // request for flush
#define REQUEST_FLAG_CIRCULAR_PERSIST    0x00010000
#define REQUEST_FLAG_CIRCULAR_TRANSITION 0x00020000
#define TRACEPOOLTAG            'timW'

//
// Time constants
//

extern LARGE_INTEGER WmiOneSecond;
extern LARGE_INTEGER WmiShortTime; //10 Milliseconds


//
// Increase refcount on a logger context
#define WmipReferenceLogger(Id) InterlockedIncrement(&WmipRefCount[Id])

// Decrease refcount on a logger context
#define WmipDereferenceLogger(Id) InterlockedDecrement(&WmipRefCount[Id])

// Macro to retrieve Logger Context from LoggerId as index
//
#define WmipGetLoggerContext(LoggerId) \
        (LoggerId < MAXLOGGERS) ? \
            WmipLoggerContext[LoggerId] : NULL

#define WmipIsValidLogger(L) \
        (((L) != NULL) && ((L) != (PWMI_LOGGER_CONTEXT) &WmipLoggerContext[0])\
        ? TRUE : FALSE)

#define WmipInitializeMutex(x) KeInitializeMutex((x), 0)
#define WmipAcquireMutex(x) KeWaitForSingleObject((x), Executive, KernelMode,\
                            FALSE, NULL)
#define WmipReleaseMutex(x) KeReleaseMutex((x), FALSE)

//
// Context Swap Trace Constants
//
#define WMI_CTXSWAP_EVENTSIZE_ALIGNMENT         8


//
// Buffer managements
//
#ifdef NTPERF
#define WMI_FREE_TRACE_BUFFER(Buffer)\
    if (!PERFINFO_IS_LOGGING_TO_PERFMEM()) { \
        ExFreePool(Buffer); \
    }
#else
#define WMI_FREE_TRACE_BUFFER(Buffer) ASSERT(Buffer->ReferenceCount == 0);\
                                      ExFreePool(Buffer); 
#endif //NTPERF

//
// Private local data structures used
//
__inline
__int64
WmipGetSystemTime(
    VOID
    )
{
    LARGE_INTEGER Time;
    KiQuerySystemTime((PLARGE_INTEGER)&Time);
    return Time.QuadPart;
}

__inline
__int64
WmipGetPerfCounter(
    VOID
    )
{
    LARGE_INTEGER Time;
    Time = KeQueryPerformanceCounter(NULL);
    return Time.QuadPart;
}

#if _MSC_VER >= 1200
#pragma warning( push )
#endif
#pragma warning( disable:4214 )
#pragma warning( disable:4201 )

//
// Perf logging states
//
#define PERF_LOG_NO_TRANSITION      0               // No Perf Logging transition
#define PERF_LOG_START_TRANSITION   1               // Perf Logging is starting 
#define PERF_LOG_STOP_TRANSITION    2               // Perf Logging is ending

typedef struct _WMI_LOGGER_MODE {
   ULONG               SequentialFile:1;
   ULONG               CircularFile:1;
   ULONG               AppendFile:1;
   ULONG               Unused1:5;
   ULONG               RealTime:1;
   ULONG               DelayOpenFile:1;
   ULONG               BufferOnly:1;
   ULONG               PrivateLogger:1;
   ULONG               AddHeader:1;
   ULONG               UseExisting:1;
   ULONG               UseGlobalSequence:1;
   ULONG               UseLocalSequence:1;
   ULONG               Unused2:16;
} WMI_LOGGER_MODE, *PWMI_LOGGER_MODE;

typedef struct _WMI_LOGGER_CONTEXT {
//
// the following are private context used by the buffer manager
//
    KSPIN_LOCK                  BufferSpinLock;
    LARGE_INTEGER               StartTime;
    HANDLE                      LogFileHandle;
    KSEMAPHORE                  LoggerSemaphore;
    PETHREAD                    LoggerThread;
    KEVENT                      LoggerEvent;
    KEVENT                      FlushEvent;
    NTSTATUS                    LoggerStatus;
    ULONG                       LoggerId;

    LONG                        BuffersAvailable;
    ULONG                       UsePerfClock;
    ULONG                       WriteFailureLimit;
    LONG                        BuffersDirty;
    LONG                        BuffersInUse;
    ULONG                       SwitchingInProgress;
    SLIST_HEADER                FreeList;
    SLIST_HEADER                FlushList;
    SLIST_HEADER                WaitList;
    SLIST_HEADER                GlobalList;
    PWMI_BUFFER_HEADER*         ProcessorBuffers;   // Per Processor Buffer
    UNICODE_STRING              LoggerName;         // points to paged pool
    UNICODE_STRING              LogFileName;
    UNICODE_STRING              LogFilePattern;
    UNICODE_STRING              NewLogFileName;     // for updating log file name
    PUCHAR                      EndPageMarker;

    LONG                        CollectionOn;
    ULONG                       KernelTraceOn;
    LONG                        PerfLogInTransition;    // Perf Logging transition status
    ULONG                       RequestFlag;
    ULONG                       EnableFlags;
    ULONG                       MaximumFileSize;
    union {
        ULONG                   LoggerMode;
        WMI_LOGGER_MODE         LoggerModeFlags;
    };
    ULONG                       Wow;                // TRUE if the logger started under Wow64
                                                    // Set by the kernel once and never changed.
    ULONG                       LastFlushedBuffer;
    ULONG                       RefCount;
    ULONG                       FlushTimer;
    LARGE_INTEGER               FirstBufferOffset;
    LARGE_INTEGER               ByteOffset;
    LARGE_INTEGER               BufferAgeLimit;

// the following are attributes available for query
    ULONG                       MaximumBuffers;
    ULONG                       MinimumBuffers;
    ULONG                       EventsLost;
    ULONG                       BuffersWritten;
    ULONG                       LogBuffersLost;
    ULONG                       RealTimeBuffersLost;
    ULONG                       BufferSize;
    LONG                        NumberOfBuffers;
    PLONG                       SequencePtr;

    GUID                        InstanceGuid;
    PVOID                       LoggerHeader;
    WMI_GET_CPUCLOCK_ROUTINE    GetCpuClock;
    SECURITY_CLIENT_CONTEXT     ClientSecurityContext;
// logger specific extension to context
    PVOID                       LoggerExtension;
    LONG                        ReleaseQueue;
    TRACE_ENABLE_FLAG_EXTENSION EnableFlagExtension;
    ULONG                       LocalSequence;
    ULONG                       MaximumIrql;
    PULONG                      EnableFlagArray;
#ifndef WMI_MUTEX_FREE
    KMUTEX                      LoggerMutex;
    LONG                        MutexCount;
#endif
    LONG                        FileCounter;
    WMI_TRACE_BUFFER_CALLBACK   BufferCallback;
    PVOID                       CallbackContext;
    POOL_TYPE                   PoolType;
    LARGE_INTEGER               ReferenceSystemTime;  // always in SystemTime
    LARGE_INTEGER               ReferenceTimeStamp;   // by specified clocktype
} WMI_LOGGER_CONTEXT, *PWMI_LOGGER_CONTEXT;

#if _MSC_VER >= 1200
#pragma warning( pop )
#endif

extern LONG WmipRefCount[MAXLOGGERS];      // Global refcount on loggercontext
extern PWMI_LOGGER_CONTEXT WmipLoggerContext[MAXLOGGERS];
extern PWMI_BUFFER_HEADER WmipContextSwapProcessorBuffers[MAXIMUM_PROCESSORS];
extern PFILE_OBJECT* WmipFileTable;         // Filename hashing table

extern ULONG WmipGlobalSequence;
extern ULONG WmipPtrSize;       // temporary for wmikd to work
extern ULONG WmipKernelLogger;
extern ULONG WmipEventLogger;

extern ULONG WmiUsePerfClock;
extern ULONG WmiTraceAlignment;
extern ULONG WmiWriteFailureLimit;
extern KGUARDED_MUTEX WmipTraceGuardedMutex;
extern WMI_TRACE_BUFFER_CALLBACK WmipGlobalBufferCallback;
extern PSECURITY_DESCRIPTOR EtwpDefaultTraceSecurityDescriptor;

//
// Private routines for tracing support
//

//
// from tracelog.c
//

NTSTATUS
WmipFlushBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN PWMI_BUFFER_HEADER Buffer,
    IN USHORT BufferFlag
    );

NTSTATUS
WmipStartLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

NTSTATUS
WmipQueryLogger(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

#if DBG
NTSTATUS
WmipVerifyLoggerInfo(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
    OUT PWMI_LOGGER_CONTEXT *LoggerContext,
    LPSTR Caller
    );
#else
NTSTATUS
WmipVerifyLoggerInfo(
    IN PWMI_LOGGER_INFORMATION LoggerInfo,
    OUT PWMI_LOGGER_CONTEXT *LoggerContext
    );
#endif

VOID
WmipFreeLoggerContext(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipStopLoggerInstance(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipFlushActiveBuffers(
    IN PWMI_LOGGER_CONTEXT,
    IN ULONG FlushAll
    );

PSYSTEM_TRACE_HEADER
FASTCALL
WmiReserveWithSystemHeader(
    IN ULONG LoggerId,
    IN ULONG AuxSize,
    IN PETHREAD Thread,
    OUT PVOID *BufferResource
    );

PVOID
FASTCALL
WmipReserveTraceBuffer(
    IN  PWMI_LOGGER_CONTEXT LoggerContext,
    IN  ULONG RequiredSize,
    OUT PWMI_BUFFER_HEADER *BufferResource,
    OUT PLARGE_INTEGER TimeStamp
    );

ULONG
FASTCALL
WmipReleaseTraceBuffer(
    IN PWMI_BUFFER_HEADER Buffer,
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

PWMI_BUFFER_HEADER
WmipGetFreeBuffer(
    IN PWMI_LOGGER_CONTEXT LoggerContext
);

ULONG
WmipAllocateFreeBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG NumberOfBuffers
    );

NTSTATUS
WmipAdjustFreeBuffers(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
WmipLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

NTSTATUS
WmipSendNotification(
    PWMI_LOGGER_CONTEXT LoggerContext,
    NTSTATUS            Status,
    ULONG               Flag
	);

#if DBG
VOID
TraceDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define TraceDebug(x) TraceDebugPrint x
#else
#define TraceDebug(x)
#endif

PWMI_BUFFER_HEADER
FASTCALL
WmipPopFreeContextSwapBuffer
    (UCHAR CurrentProcessor
    );

VOID
FASTCALL
WmipPushDirtyContextSwapBuffer
    (UCHAR CurrentProcessor,
     PWMI_BUFFER_HEADER Buffer
    );

VOID
FASTCALL
WmipResetBufferHeader (
    PWMI_LOGGER_CONTEXT     LoggerContext,
    PWMI_BUFFER_HEADER      Buffer,
    USHORT                  BufferType
    );

// from callouts.c

VOID
WmipSetTraceNotify(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG TraceClass,
    IN ULONG Enable
    );

VOID
FASTCALL
WmipEnableKernelTrace(
    IN ULONG EnableFlags
    );

VOID
FASTCALL
WmipDisableKernelTrace(
    IN ULONG EnableFlags
    );

NTSTATUS
WmipDelayCreate(
    OUT PHANDLE FileHandle,
    IN OUT PUNICODE_STRING FileName,
    IN ULONG Append
    );


PWMI_LOGGER_CONTEXT
FASTCALL
WmipIsLoggerOn(IN ULONG LoggerId);

// from globalog.c

VOID
WmipStartGlobalLogger();

NTSTATUS
WmipQueryGLRegistryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
WmipAddLogHeader(
    IN PWMI_LOGGER_CONTEXT LoggerContext,
    IN OUT PWMI_BUFFER_HEADER Buffer
    );

NTSTATUS
WmipCreateDirectoryFile(
    IN PWCHAR DirFileName,
    IN BOOLEAN IsDirectory,
    OUT PHANDLE FileHandle,
    ULONG Append
    );

NTSTATUS
WmipCreateNtFileName(
    IN  PWCHAR   strFileName,
    OUT PWCHAR * strNtFileName
    );

NTSTATUS
WmipFlushLogger(
    IN OUT PWMI_LOGGER_CONTEXT LoggerContext,
    IN ULONG Wait
    );

NTSTATUS
FASTCALL
WmipNotifyLogger(
    IN PWMI_LOGGER_CONTEXT LoggerContext
    );

PVOID
WmipExtendBase(
    IN PWMI_LOGGER_CONTEXT Base,
    IN ULONG Size
    );

NTSTATUS
WmipGenerateFileName(
    IN PUNICODE_STRING FilePattern,
    IN OUT PLONG FileCounter,
    OUT PUNICODE_STRING FileName
    );

VOID
WmipValidateClockType(
    IN OUT PWMI_LOGGER_INFORMATION LoggerInfo
    );

#ifdef NTPERF
NTSTATUS
WmipSwitchPerfmemBuffer(
    PWMI_SWITCH_PERFMEM_BUFFER_INFORMATION SwitchBufferInfo
    );
#endif //NTPERF

NTSTATUS
WmipNtDllLoggerInfo(
    PWMINTDLLLOGGERINFO Buffer
    );

#endif // _TRACEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\wmi.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

   wmi.c

Abstract:

    Device driver interface for WMI

Author:

    AlanWar

Environment:

    Kernel mode

Revision History:


--*/

#include "wmikmp.h"
#ifndef MEMPHIS
#include "evntrace.h"
#include "tracep.h"
#endif

NTSTATUS
WmipOpenCloseCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
WmipIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS WmipObjectToPDO(
    PFILE_OBJECT FileObject,
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *PDO
    );

BOOLEAN
WmipFastIoDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


NTSTATUS WmipProbeWnodeAllData(
    PWNODE_ALL_DATA Wnode,
    ULONG InBufferLen,
    ULONG OutBufferLen
    );

NTSTATUS WmipProbeWnodeSingleInstance(
    PWNODE_SINGLE_INSTANCE Wnode,
    ULONG InBufferLen,
    ULONG OutBufferLen,
    BOOLEAN OutBound
    );

NTSTATUS WmipProbeWnodeSingleItem(
    PWNODE_SINGLE_ITEM Wnode,
    ULONG InBufferLen
    );


NTSTATUS WmipProbeWnodeMethodItem(
    PWNODE_METHOD_ITEM Wnode,
    ULONG InBufferLen,
    ULONG OutBufferLen
    );

NTSTATUS WmipProbeWnodeWorker(
    PWNODE_HEADER WnodeHeader,
    ULONG MinWnodeSize,
    ULONG InstanceNameOffset,
    ULONG DataBlockOffset,
    ULONG DataBlockSize,
    ULONG InBufferLen,
    ULONG OutBufferLen,
    BOOLEAN CheckOutBound,
    BOOLEAN CheckInBound
    );


NTSTATUS
WmipSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS WmipSendWmiIrp(
    UCHAR MinorFunction,
    ULONG ProviderId,
    PVOID DataPath,
    ULONG BufferLength,
    PVOID Buffer,
    PIO_STATUS_BLOCK Iosb
    );

NTSTATUS WmipProbeWmiRegRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PWMIREGREQUEST Buffer,
    IN ULONG InBufferLen,
    IN ULONG OutBufferLen,
    OUT PBOOLEAN MofIgnored    
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,WmipDriverEntry)
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGE,WmipOpenCloseCleanup)
#pragma alloc_text(PAGE,WmipIoControl)
#pragma alloc_text(PAGE,WmipForwardWmiIrp)
#pragma alloc_text(PAGE,WmipObjectToPDO)
#pragma alloc_text(PAGE,WmipTranslateFileHandle)
#pragma alloc_text(PAGE,WmipProbeWnodeAllData)
#pragma alloc_text(PAGE,WmipProbeWnodeSingleInstance)
#pragma alloc_text(PAGE,WmipProbeWnodeSingleItem)
#pragma alloc_text(PAGE,WmipProbeWnodeMethodItem)
#pragma alloc_text(PAGE,WmipProbeWnodeWorker)
#pragma alloc_text(PAGE,WmipProbeWmiOpenGuidBlock)
#pragma alloc_text(PAGE,WmipProbeAndCaptureGuidObjectAttributes)
#pragma alloc_text(PAGE,WmipUpdateDeviceStackSize)
#pragma alloc_text(PAGE,WmipSystemControl)
#pragma alloc_text(PAGE,WmipGetDevicePDO)
#pragma alloc_text(PAGE,WmipSendWmiIrp)
#pragma alloc_text(PAGE,WmipProbeWmiRegRequest)

#ifndef MEMPHIS
#pragma alloc_text(PAGE,WmipFastIoDeviceControl)
#endif

#endif


PDEVICE_OBJECT WmipServiceDeviceObject;
PDEVICE_OBJECT WmipAdminDeviceObject;

//
// This specifies the maximum size that an event can be
ULONG WmipMaxKmWnodeEventSize = DEFAULTMAXKMWNODEEVENTSIZE;



#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

#if defined(_AMD64_) || defined(_IA64_) || defined(i386)
PVOID WmipDockUndockNotificationEntry;
#endif

KMUTEX WmipSMMutex;
KMUTEX WmipTLMutex;

//
// This maintains the registry path for the wmi device
UNICODE_STRING WmipRegistryPath;

#ifndef MEMPHIS
FAST_IO_DISPATCH WmipFastIoDispatch;
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);
    // Never called
    return(STATUS_SUCCESS);
}


NTSTATUS
WmipDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    WMI Driver Object.  In this function, we need to remember the
    DriverObject, create a device object and then create a Win32 visible
    symbolic link name so that the WMI user mode component can access us.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING DeviceName;
    UNICODE_STRING ServiceSymbolicLinkName;
    UNICODE_STRING AdminSymbolicLinkName;
#ifndef MEMPHIS
    PSECURITY_DESCRIPTOR AdminDeviceSd;
    PFAST_IO_DISPATCH fastIoDispatch;
#endif
    ANSI_STRING AnsiString;

    PAGED_CODE();
    UNREFERENCED_PARAMETER(RegistryPath);

    //
    // First thing to do is make sure our critical section has been initalized
    //
    KeInitializeMutex(&WmipSMMutex, 0);
    KeInitializeMutex(&WmipTLMutex, 0);

    //
    // Initialize internal WMI data structrurs
    //
    WmipInitializeRegistration(0);
    WmipInitializeNotifications();
    Status = WmipInitializeDataStructs();
    if (! NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // Since Io does not pass a registry path for this device we need to make
    // up one
    RtlInitAnsiString(&AnsiString,
                         "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\WMI");
    Status = RtlAnsiStringToUnicodeString(&WmipRegistryPath,
                                          &AnsiString,
                                          TRUE);
#ifndef MEMPHIS
    Status = WmipInitializeSecurity();
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    //
    // We allocate a security descriptor to be placed on the Admin device.
    // It will allow only Administrators access to the device and
    // no access to anyone else. 
    //
    Status = WmipCreateAdminSD(&AdminDeviceSd);
    if (! NT_SUCCESS(Status))
    {
        return(Status);
    }
#endif

    //
    // Create the service device object and symbolic link
    //
    RtlInitUnicodeString( &DeviceName, WMIServiceDeviceObjectName );
    Status = IoCreateDevice(
                 DriverObject,
                 0,
                 &DeviceName,
                 FILE_DEVICE_UNKNOWN,
#ifdef MEMPHIS
                 0,
#else
                 FILE_DEVICE_SECURE_OPEN, // No standard device characteristics
#endif
                 FALSE,                   // This isn't an exclusive device
                 &WmipServiceDeviceObject
                 );

    if (! NT_SUCCESS(Status))
    {
        ExFreePool(AdminDeviceSd);
        return(Status);
    }

    RtlInitUnicodeString( &ServiceSymbolicLinkName,
                          WMIServiceSymbolicLinkName );
    Status = IoCreateSymbolicLink( &ServiceSymbolicLinkName,
                                   &DeviceName );
    if (! NT_SUCCESS(Status))
    {
        IoDeleteDevice( WmipServiceDeviceObject );
        ExFreePool(AdminDeviceSd);
        return(Status);
    }


    //
    // Now create an admin-only device object and symbolic link
    //
    RtlInitUnicodeString( &DeviceName, WMIAdminDeviceObjectName );
    Status = IoCreateDevice(
                 DriverObject,
                 0,
                 &DeviceName,
                 FILE_DEVICE_UNKNOWN,
                 FILE_DEVICE_SECURE_OPEN, // No standard device characteristics
                 FALSE,                   // This isn't an exclusive device
                 &WmipAdminDeviceObject
                 );

    if (! NT_SUCCESS(Status))
    {
        IoDeleteDevice( WmipServiceDeviceObject );
        IoDeleteSymbolicLink(&ServiceSymbolicLinkName);
        ExFreePool(AdminDeviceSd);
        return(Status);
    }


    Status = ObSetSecurityObjectByPointer(WmipAdminDeviceObject,
                                          DACL_SECURITY_INFORMATION |
                                              OWNER_SECURITY_INFORMATION,
                                          AdminDeviceSd);
    
    ExFreePool(AdminDeviceSd);
    AdminDeviceSd = NULL;
    
    if (! NT_SUCCESS(Status))
    {
        IoDeleteDevice( WmipServiceDeviceObject );
        IoDeleteDevice( WmipAdminDeviceObject );
        IoDeleteSymbolicLink(&ServiceSymbolicLinkName);
        return(Status);
    }
    
    RtlInitUnicodeString( &AdminSymbolicLinkName,
                          WMIAdminSymbolicLinkName );
    Status = IoCreateSymbolicLink( &AdminSymbolicLinkName,
                                   &DeviceName );
    if (! NT_SUCCESS(Status))
    {
        IoDeleteSymbolicLink( &ServiceSymbolicLinkName );
        IoDeleteDevice( WmipServiceDeviceObject );
        IoDeleteDevice( WmipAdminDeviceObject );
        return(Status);
    }
    
    //
    // Establish an initial irp stack size
    WmipServiceDeviceObject->StackSize = WmiDeviceStackSize;
    WmipAdminDeviceObject->StackSize = WmiDeviceStackSize;

    //
    // Create dispatch entrypoints
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE] = WmipOpenCloseCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = WmipOpenCloseCleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = WmipIoControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = WmipOpenCloseCleanup;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = WmipSystemControl;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = WmipShutdown;

    //
    // Register for notification of docking events
#if  defined(_AMD64_) || defined(_IA64_) || defined(i386)
    IoRegisterPlugPlayNotification(
                                  EventCategoryHardwareProfileChange,
                                  0,
                                  NULL,
                                  DriverObject,
                                  WmipDockUndockEventCallback,
                                  NULL,
                                  &WmipDockUndockNotificationEntry);
#endif
    //
    // We reset this flag to let the IO manager know that the device
    // is ready to receive requests. We only do this for the kernel
    // dll since the IO manager does it when WMI loads as a normal
    // device.
    WmipServiceDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    WmipAdminDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

#ifndef MEMPHIS
    IoWMIRegistrationControl(WmipServiceDeviceObject,
                             WMIREG_ACTION_REGISTER);
#endif

#ifndef MEMPHIS
    fastIoDispatch = &WmipFastIoDispatch;
    RtlZeroMemory(fastIoDispatch, sizeof(FAST_IO_DISPATCH));
    fastIoDispatch->SizeOfFastIoDispatch = sizeof(FAST_IO_DISPATCH);
    fastIoDispatch->FastIoDeviceControl = WmipFastIoDeviceControl;
    DriverObject->FastIoDispatch = fastIoDispatch;
    RtlZeroMemory(&WmipRefCount[0], MAXLOGGERS*sizeof(ULONG));
    RtlZeroMemory(&WmipLoggerContext[0], MAXLOGGERS*sizeof(PWMI_LOGGER_CONTEXT));
    WmipStartGlobalLogger();        // Try and see if we need to start this
    IoRegisterShutdownNotification(WmipServiceDeviceObject);
#endif // MEMPHIS

    SharedUserData->TraceLogging = 0; //Initialize the Heap and Crisec Coll tracing status off

    return(Status);
}

NTSTATUS
WmipOpenCloseCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}

void WmipUpdateDeviceStackSize(
    CCHAR NewStackSize
    )
/*++

Routine Description:

    This routine will update the stack size that is specified in the WMI
    device's device object. This needs to be protected since it can be updated
    when a device registers and whenever an irp is forwarded to a device.
    WMI needs to maintain a stack size one greater than the stack size of the
    largest device stack to which it forwards irps to. Consider a bottom
    driver that registers with WMI and has a stack size of 1. If 2 device
    attach on top of it then WMI will forward to the topmost in the stack
    which would need a stack size of 3, so the original WMI irp (ie the one
    created by the IOCTL to the WMI device) would need a stack size of 4.

Arguments:

    NewStackSize is the new stack size needed

Return Value:

    NT status ccode

--*/
{
    PAGED_CODE();

    WmipEnterSMCritSection();
    if (WmipServiceDeviceObject->StackSize < NewStackSize)
    {
        WmipServiceDeviceObject->StackSize = NewStackSize;
    }
    WmipLeaveSMCritSection();
}


NTSTATUS
WmipIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG InBufferLen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG OutBufferLen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    PVOID Buffer =  Irp->AssociatedIrp.SystemBuffer;
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    ULONG Ioctl;

    PAGED_CODE();

    Ioctl = irpStack->Parameters.DeviceIoControl.IoControlCode;

    switch (Ioctl)
    {
#ifndef MEMPHIS
        case IOCTL_WMI_OPEN_GUID:
        case IOCTL_WMI_OPEN_GUID_FOR_QUERYSET:
        case IOCTL_WMI_OPEN_GUID_FOR_EVENTS:
        {
            OBJECT_ATTRIBUTES CapturedObjectAttributes;
            UNICODE_STRING CapturedGuidString;
            WCHAR CapturedGuidBuffer[WmiGuidObjectNameLength + 1];
            PWMIOPENGUIDBLOCK InGuidBlock;
            HANDLE Handle;
            ULONG DesiredAccess;

            InGuidBlock = (PWMIOPENGUIDBLOCK)Buffer;

            Status = WmipProbeWmiOpenGuidBlock(&CapturedObjectAttributes,
                                               &CapturedGuidString,
                                               CapturedGuidBuffer,
                                               &DesiredAccess,
                                               InGuidBlock,
                                               InBufferLen,
                                               OutBufferLen);

            if (NT_SUCCESS(Status))
            {
                Status = WmipOpenBlock(Ioctl,
                                       UserMode,
                                       &CapturedObjectAttributes,
                                       DesiredAccess,
                                       &Handle);
                if (NT_SUCCESS(Status))
                {
#if defined(_WIN64)
                    if (IoIs32bitProcess(NULL))
                    {
                        ((PWMIOPENGUIDBLOCK32)InGuidBlock)->Handle.Handle32 = PtrToUlong(Handle);
                    }
                    else
#endif
                    {
                        InGuidBlock->Handle.Handle = Handle;
                    }
                }
            }
            break;
        }
#endif

        case IOCTL_WMI_QUERY_ALL_DATA:
        {
            if (OutBufferLen < sizeof(WNODE_ALL_DATA))
            {
                //
                // WMI will not send any request whose output buffer is not
                // at least the size of a WNODE_ALL_DATA.
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Status = WmipProbeWnodeAllData((PWNODE_ALL_DATA)Wnode,
                                             InBufferLen,
                                             OutBufferLen);

            if (NT_SUCCESS(Status))
            {
                Status = WmipQueryAllData(NULL,
                                          Irp,
                                          UserMode,
                                          (PWNODE_ALL_DATA)Wnode,
                                          OutBufferLen,
                                          &OutBufferLen);

            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid IOCTL_WMI_QUERY_ALL_DATA Wnode\n"));
            }
            break;
        }

        case IOCTL_WMI_QAD_MULTIPLE:
        {
            PWMIQADMULTIPLE QadMultiple;

            if ((InBufferLen >= sizeof(WMIQADMULTIPLE)) &&
                (OutBufferLen >= sizeof(WNODE_TOO_SMALL)))
            {
                QadMultiple = (PWMIQADMULTIPLE)Buffer;
                if ((QadMultiple->HandleCount < QUERYMULIPLEHANDLELIMIT) &&
                    (InBufferLen >= (FIELD_OFFSET(WMIQADMULTIPLE, Handles) +
                                     (QadMultiple->HandleCount * sizeof(HANDLE3264)))))
                {
                    Status = WmipQueryAllDataMultiple(0,
                                                      NULL,
                                                      Irp,
                                                      UserMode,
                                                      Buffer,
                                                      OutBufferLen,
                                                      QadMultiple,
                                                      &OutBufferLen);
                } else {
                    Status = STATUS_INVALID_PARAMETER;
                }
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;
        }


        case IOCTL_WMI_QUERY_SINGLE_INSTANCE:
        {
            if (OutBufferLen < sizeof(WNODE_TOO_SMALL))
            {
                //
                // WMI will not send any request whose output buffer is not
                // at least the size of a WNODE_TOO_SMALL.
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Status = WmipProbeWnodeSingleInstance((PWNODE_SINGLE_INSTANCE)Wnode,
                                                  InBufferLen,
                                                  OutBufferLen,
                                                  TRUE);

            if (NT_SUCCESS(Status))
            {
                Status = WmipQuerySetExecuteSI(NULL,
                                               Irp,
                                               UserMode,
                                               IRP_MN_QUERY_SINGLE_INSTANCE,
                                               Wnode,
                                               OutBufferLen,
                                               &OutBufferLen);

                if (NT_SUCCESS(Status))
                {
                    WmipAssert(Irp->IoStatus.Information <= OutBufferLen);
                }
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid IOCTL_WMI_SINGLE_INSTANCE Wnode\n"));
            }
            break;
        }

        case IOCTL_WMI_QSI_MULTIPLE:
        {
            PWMIQSIMULTIPLE QsiMultiple;

            if ((InBufferLen >= sizeof(WMIQSIMULTIPLE)) &&
                (OutBufferLen >= sizeof(WNODE_TOO_SMALL)))
            {
                QsiMultiple = (PWMIQSIMULTIPLE)Buffer;

                if ((QsiMultiple->QueryCount < QUERYMULIPLEHANDLELIMIT) &&
                    (InBufferLen >= (FIELD_OFFSET(WMIQSIMULTIPLE, QsiInfo) +
                                     (QsiMultiple->QueryCount * sizeof(WMIQSIINFO)))))
                {
                    Status = WmipQuerySingleMultiple(Irp,
                                                     UserMode,
                                                     Buffer,
                                                     OutBufferLen,
                                                     QsiMultiple,
                                                     QsiMultiple->QueryCount,
                                                     NULL,
                                                     NULL,
                                                     &OutBufferLen);

                } else {
                    Status = STATUS_INVALID_PARAMETER;
                }

            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;
        }

        case IOCTL_WMI_SET_SINGLE_INSTANCE:
        {
            Status = WmipProbeWnodeSingleInstance((PWNODE_SINGLE_INSTANCE)Wnode,
                                                  InBufferLen,
                                                  OutBufferLen,
                                                  FALSE);

            if (NT_SUCCESS(Status))
            {
                Status = WmipQuerySetExecuteSI(NULL,
                                               Irp,
                                               UserMode,
                                               IRP_MN_CHANGE_SINGLE_INSTANCE,
                                               Wnode,
                                               InBufferLen,
                                               &OutBufferLen);

                OutBufferLen = 0;
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid IOCTL_WMI_SET_SINGLE_INSTANCE Wnode\n"));
            }
            break;
        }


        case IOCTL_WMI_SET_SINGLE_ITEM:
        {
            Status = WmipProbeWnodeSingleItem((PWNODE_SINGLE_ITEM)Wnode,
                                              InBufferLen);

            if (NT_SUCCESS(Status))
            {
                Status = WmipQuerySetExecuteSI(NULL,
                                               Irp,
                                               UserMode,
                                               IRP_MN_CHANGE_SINGLE_ITEM,
                                               Wnode,
                                               InBufferLen,
                                               &OutBufferLen);

                OutBufferLen = 0;
            } else {
                WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid IOCTL_WMI_SET_SINGLE_ITEM Wnode\n"));
            }
            break;
        }

        case IOCTL_WMI_EXECUTE_METHOD:
        {
            //
            // The buffer passed is the InputWnode directly followed by the
            // method wnode. This is so that the driver can fill in the
            // output WNODE directly on top of the input wnode.
            PWNODE_METHOD_ITEM MethodWnode = (PWNODE_METHOD_ITEM)Wnode;

            Status = WmipProbeWnodeMethodItem(MethodWnode,
                                              InBufferLen,
                                              OutBufferLen);
            if (NT_SUCCESS(Status))
            {
                Status = WmipQuerySetExecuteSI(NULL,
                                               Irp,
                                               UserMode,
                                               IRP_MN_EXECUTE_METHOD,
                                               Wnode,
                                               OutBufferLen,
                                               &OutBufferLen);

                if (NT_SUCCESS(Status))
                {
                    WmipAssert(Irp->IoStatus.Information <= OutBufferLen);
                }
            }
            break;
        }

        case IOCTL_WMI_TRANSLATE_FILE_HANDLE:
        {
            if (InBufferLen != FIELD_OFFSET(WMIFHTOINSTANCENAME,
                                            InstanceNames))
            {
                Status = STATUS_UNSUCCESSFUL;
            } else {
                Status = WmipTranslateFileHandle((PWMIFHTOINSTANCENAME)Buffer,
                                                 &OutBufferLen,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL);
            }
            break;
        }

        case IOCTL_WMI_GET_VERSION:
        {
            if (OutBufferLen < sizeof(WMIVERSIONINFO))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                ((PWMIVERSIONINFO)Buffer)->Version = WMI_CURRENT_VERSION;
                OutBufferLen = sizeof(WMIVERSIONINFO);
                Status = STATUS_SUCCESS;
            }
            break;
        }


        case IOCTL_WMI_ENUMERATE_GUIDS_AND_PROPERTIES:
        case IOCTL_WMI_ENUMERATE_GUIDS:
        {
            if (OutBufferLen < FIELD_OFFSET(WMIGUIDLISTINFO, GuidList))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                Status = WmipEnumerateGuids(Ioctl,
                                            (PWMIGUIDLISTINFO)Buffer,
                                            OutBufferLen,
                                            &OutBufferLen);

            }
            break;
        }

        case IOCTL_WMI_QUERY_GUID_INFO:
        {
            if (OutBufferLen < sizeof(WMIQUERYGUIDINFO))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                Status = WmipQueryGuidInfo((PWMIQUERYGUIDINFO)Buffer);
                OutBufferLen = sizeof(WMIQUERYGUIDINFO);

            }
            break;
        }

        case IOCTL_WMI_ENUMERATE_MOF_RESOURCES:
        {
            if (OutBufferLen >= sizeof(WMIMOFLIST))
            {
                Status = WmipEnumerateMofResources((PWMIMOFLIST)Buffer,
                                                   OutBufferLen,
                                                      &OutBufferLen);
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;
        }

        case IOCTL_WMI_RECEIVE_NOTIFICATIONS:
        {
            PWMIRECEIVENOTIFICATION ReceiveNotification;
            ULONG CountExpected;

            if ((InBufferLen >= sizeof(WMIRECEIVENOTIFICATION)) &&
                (OutBufferLen >= sizeof(WNODE_TOO_SMALL)))
            {
                ReceiveNotification = (PWMIRECEIVENOTIFICATION)Buffer;
                
                CountExpected = (InBufferLen -
                                 FIELD_OFFSET(WMIRECEIVENOTIFICATION, Handles)) /
                                sizeof(HANDLE3264);

                if (ReceiveNotification->HandleCount <= CountExpected)
                {
                    Status = WmipReceiveNotifications(ReceiveNotification,
                                                      &OutBufferLen,
                                                      Irp);
                } else {
                     //
                    // Input buffer not large enough which is an error
                    //
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                }
            } else {
                //
                // Input and or output buffers not large enough
                // which is an error
                //
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        }

        case IOCTL_WMI_MARK_HANDLE_AS_CLOSED:
        {
            PWMIMARKASCLOSED MarkAsClosed;

            if (InBufferLen >= sizeof(WMIMARKASCLOSED))
            {
                MarkAsClosed = (PWMIMARKASCLOSED)Buffer;
                Status = WmipMarkHandleAsClosed(MarkAsClosed->Handle.Handle);
                OutBufferLen = 0;
            } else {
                Status = STATUS_INVALID_DEVICE_REQUEST;             
            }
            break;
        }
        
        case IOCTL_WMI_NOTIFY_LANGUAGE_CHANGE:
        {
            LPGUID LanguageGuid;
            PWMILANGUAGECHANGE LanguageChange;
            
            if (DeviceObject == WmipAdminDeviceObject)
            {
                //
                // Only allow this ioctl to be executed on the admin
                // device object
                //
                if (InBufferLen == sizeof(WMILANGUAGECHANGE))
                {
                    LanguageChange = (PWMILANGUAGECHANGE)Buffer;
                    if (LanguageChange->Flags & WMILANGUAGECHANGE_FLAG_ADDED)
                    {
                        LanguageGuid = &GUID_MOF_RESOURCE_ADDED_NOTIFICATION;
                    } else if (LanguageChange->Flags & WMILANGUAGECHANGE_FLAG_REMOVED) {
                        LanguageGuid = &GUID_MOF_RESOURCE_REMOVED_NOTIFICATION;
                    } else {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        break;
                    }

                    //
                    // Ensure that language is nul terminated
                    //
                    LanguageChange->Language[MAX_LANGUAGE_SIZE-1] = 0;
                    WmipGenerateMofResourceNotification(LanguageChange->Language,
                                                        L"",
                                                        LanguageGuid,
                                                        MOFEVENT_ACTION_LANGUAGE_CHANGE);

                    OutBufferLen = 0;
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                }
            } else {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            break;
        }

#ifndef MEMPHIS
        // Event trace logging IOCTLS

        case IOCTL_WMI_UNREGISTER_GUIDS:
        {
            if ((InBufferLen == sizeof(WMIUNREGGUIDS)) &&
                (OutBufferLen == sizeof(WMIUNREGGUIDS)))
            {
                Status = WmipUnregisterGuids((PWMIUNREGGUIDS)Buffer);
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }

            break;
        }
        
        case IOCTL_WMI_REGISTER_GUIDS:
        {
            BOOLEAN MofIgnored = FALSE;
            //
            // Register guids for user mode provider
            //
            Status = WmipProbeWmiRegRequest(
                                            DeviceObject,
                                            Buffer,
                                            InBufferLen,
                                            OutBufferLen,
                                            &MofIgnored
                                           );
            if (NT_SUCCESS(Status))
            {
                HANDLE RequestHandle;
                PWMIREGREQUEST WmiRegRequest;
                PWMIREGINFOW WmiRegInfo;
                ULONG WmiRegInfoSize;
                ULONG GuidCount;
                PWMIREGRESULTS WmiRegResults;
                PWMIREGINFOW WmiRegInfoThunk = NULL;

                WmiRegRequest = (PWMIREGREQUEST)Buffer;
                WmiRegInfo = (PWMIREGINFOW)OffsetToPtr(Buffer, sizeof(WMIREGREQUEST));
                WmiRegInfoSize = InBufferLen - sizeof(WMIREGREQUEST);
                GuidCount = WmiRegInfo->GuidCount;
                WmiRegResults = (PWMIREGRESULTS)Buffer;

                //
                // For WOW64, WMIREGINFOW and WMIREGGUIDW structures both need
                // to be thunked here because of padding and ULONG_PTR in them.
                //
#if defined(_WIN64)
                if (IoIs32bitProcess(NULL))
                {
                    ULONG SizeNeeded, SizeToCopy, i;
                    PWMIREGGUIDW WmiRegGuid;
                    PUCHAR pSource, pTarget;
                    ULONG ImageNameLength = 0;
                    ULONG ResourceNameLength = 0;
                    ULONG Offset = 0;
                    //
                    // Find the GuidCount and allocate storage here.
                    //

                    if (WmiRegInfo->RegistryPath > 0) 
                    {
                        pSource = OffsetToPtr(WmiRegInfo, WmiRegInfo->RegistryPath);
                        ImageNameLength = *( (PUSHORT) pSource) + sizeof(USHORT);
                    }

                    if (WmiRegInfo->MofResourceName > 0)
                    {
                        pSource = OffsetToPtr(WmiRegInfo, WmiRegInfo->MofResourceName);
                        ResourceNameLength = *((PUSHORT)pSource) + sizeof(USHORT);
                    }

                    SizeNeeded = sizeof(WMIREGINFOW) + 
                                         GuidCount * sizeof(WMIREGGUIDW) +
                                         ImageNameLength + ResourceNameLength;

                    SizeNeeded = (SizeNeeded + 7) & ~7;

                    WmiRegInfoThunk = (PWMIREGINFOW) WmipAlloc(SizeNeeded);

                    if (WmiRegInfoThunk == NULL)
                    {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        OutBufferLen = 0;
                        break;
                    }
                    RtlZeroMemory(WmiRegInfoThunk, SizeNeeded);
                    pTarget = (PUCHAR)WmiRegInfoThunk;
                    pSource = (PUCHAR)WmiRegInfo;
                    SizeToCopy = WmiRegRequest->WmiRegInfo32Size;
                    RtlCopyMemory(pTarget, pSource, SizeToCopy);

                    pTarget += FIELD_OFFSET(WMIREGINFOW, WmiRegGuid);
                    pSource += SizeToCopy;
                    SizeToCopy = WmiRegRequest->WmiRegGuid32Size;
                    Offset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid);

                    for (i=0; i < GuidCount; i++)
                    {
                        RtlCopyMemory(pTarget, pSource, SizeToCopy);

                        //
                        // The InstanceCount checks are done here because the
                        // source may not be aligned. 
                        //
                        WmiRegGuid = (PWMIREGGUIDW) pTarget;
                        if ( (WmiRegGuid->InstanceCount > 0) ||
                             (WmiRegGuid->InstanceNameList > 0) )
                        {
                            return STATUS_UNSUCCESSFUL;
                        }
                        pTarget += sizeof(WMIREGGUIDW);
                        pSource += SizeToCopy;
                        Offset += sizeof(WMIREGGUIDW);
                    }

                    if (ImageNameLength > 0) 
                    {
                        pSource = OffsetToPtr(WmiRegInfo, WmiRegInfo->RegistryPath);
                        RtlCopyMemory(pTarget, pSource, ImageNameLength);
                        pTarget += ImageNameLength;
                        WmiRegInfoThunk->RegistryPath = Offset;
                        Offset += ImageNameLength;
                    }

                    if (ResourceNameLength > 0) 
                    {
                        pSource = OffsetToPtr(WmiRegInfo, WmiRegInfo->MofResourceName);
                        RtlCopyMemory(pTarget, pSource, ResourceNameLength);
                        pTarget += ResourceNameLength;
                        WmiRegInfoThunk->MofResourceName = Offset;
                        Offset += ResourceNameLength;
                    }

                    WmiRegInfo = WmiRegInfoThunk;
                    WmiRegInfoSize = SizeNeeded;
                    WmiRegInfo->BufferSize = SizeNeeded;
                }
#endif

                Status = WmipRegisterUMGuids(WmiRegRequest->ObjectAttributes,
                                         WmiRegRequest->Cookie,
                                         WmiRegInfo,
                                         WmiRegInfoSize,
                                         &RequestHandle,
                                         &WmiRegResults->LoggerContext);

                if (NT_SUCCESS(Status))
                {
#if defined(_WIN64)
                    if (IoIs32bitProcess(NULL))
                    {
                        WmiRegResults->RequestHandle.Handle64 = 0;
                        WmiRegResults->RequestHandle.Handle32 = PtrToUlong(RequestHandle);
                    }
                    else
#endif
                    {
                        WmiRegResults->RequestHandle.Handle = RequestHandle;
                    }
                    WmiRegResults->MofIgnored = MofIgnored;

                    OutBufferLen = sizeof(WMIREGRESULTS);
                }

                if (WmiRegInfoThunk != NULL)
                {
                    WmipFree(WmiRegInfoThunk);
                }
            }

            break;
        }

        case IOCTL_WMI_CREATE_UM_LOGGER:
        {
            //
            // Create User mode logger
            //
            PWNODE_HEADER Wnode;
            ULONG MinLength;

#if defined(_WIN64)
            if (IoIs32bitProcess(NULL))
            {
                ULONG SizeNeeded; 
                PUCHAR src, dest;
                PWMICREATEUMLOGGER32 WmiCreateUmLogger32 = (PWMICREATEUMLOGGER32)Buffer;
                PWMICREATEUMLOGGER WmiCreateUmLoggerThunk;

                MinLength = sizeof(WMICREATEUMLOGGER32) + sizeof(WNODE_HEADER);
                if (InBufferLen < MinLength) {
                    Status = STATUS_INVALID_PARAMETER;
                    OutBufferLen = 0;
                    break;
                }

                Wnode = (PWNODE_HEADER)((PUCHAR)WmiCreateUmLogger32 + sizeof(WMICREATEUMLOGGER32));

                if (Wnode->BufferSize > (InBufferLen-sizeof(WMICREATEUMLOGGER32)) ) {
                    Status = STATUS_INVALID_PARAMETER;
                    OutBufferLen = 0;
                    break;
                }

                SizeNeeded = InBufferLen + sizeof(WMICREATEUMLOGGER) - sizeof(WMICREATEUMLOGGER32);

                SizeNeeded = (SizeNeeded + 7) & ~7;

                WmiCreateUmLoggerThunk = (PWMICREATEUMLOGGER) WmipAlloc(SizeNeeded);

                if (WmiCreateUmLoggerThunk == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    OutBufferLen = 0;
                    break;
                }

                RtlZeroMemory(WmiCreateUmLoggerThunk, SizeNeeded);
                WmiCreateUmLoggerThunk->ObjectAttributes = 
                                        UlongToPtr(WmiCreateUmLogger32->ObjectAttributes);
                WmiCreateUmLoggerThunk->ControlGuid = WmiCreateUmLogger32->ControlGuid;

                dest = (PUCHAR)WmiCreateUmLoggerThunk + sizeof(WMICREATEUMLOGGER);
                src = (PUCHAR)WmiCreateUmLogger32 + sizeof(WMICREATEUMLOGGER32);

                RtlCopyMemory(dest, src, Wnode->BufferSize); 

                Status = WmipCreateUMLogger(WmiCreateUmLoggerThunk);
                WmiCreateUmLogger32->ReplyHandle.Handle64 = 0;
                WmiCreateUmLogger32->ReplyHandle.Handle32 = PtrToUlong(WmiCreateUmLoggerThunk->ReplyHandle.Handle);
                WmiCreateUmLogger32->ReplyCount = WmiCreateUmLoggerThunk->ReplyCount;

                WmipFree(WmiCreateUmLoggerThunk);
            }
            else 
#endif
            {
                MinLength = sizeof(WMICREATEUMLOGGER) + sizeof(WNODE_HEADER);
                if (InBufferLen < MinLength) {
                    Status = STATUS_INVALID_PARAMETER;
                    OutBufferLen = 0;
                    break;
                }

                Wnode = (PWNODE_HEADER) ((PUCHAR)Buffer + sizeof(WMICREATEUMLOGGER));

                if (Wnode->BufferSize > (InBufferLen-sizeof(WMICREATEUMLOGGER)) ) {
                    Status = STATUS_INVALID_PARAMETER;
                    OutBufferLen = 0;
                    break;
                }
                Status = WmipCreateUMLogger((PWMICREATEUMLOGGER)Buffer);
            }

            break;
        }

        case IOCTL_WMI_MB_REPLY:
        {
            //
            // MB Reply message
            //
            PUCHAR Message;
            ULONG MessageSize;
            PWMIMBREPLY WmiMBReply;

            if (InBufferLen >= FIELD_OFFSET(WMIMBREPLY, Message))
            {
                WmiMBReply = (PWMIMBREPLY)Buffer;
                Message = (PUCHAR)Buffer + FIELD_OFFSET(WMIMBREPLY, Message);
                MessageSize = InBufferLen - FIELD_OFFSET(WMIMBREPLY, Message);

                Status = WmipMBReply(WmiMBReply->Handle.Handle,
                                     WmiMBReply->ReplyIndex,
                                     Message,
                                     MessageSize);
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            OutBufferLen = 0;
        }


        case IOCTL_WMI_ENABLE_DISABLE_TRACELOG:
        {
            PWMITRACEENABLEDISABLEINFO TraceEnableInfo;

            OutBufferLen = 0;
            if (InBufferLen == sizeof(WMITRACEENABLEDISABLEINFO))
            {
                TraceEnableInfo = (PWMITRACEENABLEDISABLEINFO)Buffer;
                Status = WmipEnableDisableTrace(Ioctl,
                                                TraceEnableInfo);
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
            break;
        }


        case IOCTL_WMI_START_LOGGER:
        {
            PWMI_LOGGER_INFORMATION LoggerInfo;
#ifdef _WIN64
            ULONG LoggerBuf, LogFileBuf;
#endif

            if ((InBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ||
                (OutBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if ( !(Wnode->Flags & WNODE_FLAG_TRACED_GUID) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            LoggerInfo = (PWMI_LOGGER_INFORMATION) Wnode;
            LoggerInfo->Wow = FALSE;
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                LoggerBuf = ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer;
                LoggerInfo->LoggerName.Buffer = UlongToPtr(LoggerBuf);
                LogFileBuf = ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer;
                LoggerInfo->LogFileName.Buffer = UlongToPtr(LogFileBuf);
                LoggerInfo->Wow = TRUE;
            }
            else {
                LoggerBuf = 0;
                LogFileBuf = 0;
            }
#endif
            Status = WmipStartLogger( LoggerInfo );
            OutBufferLen = sizeof (WMI_LOGGER_INFORMATION);
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer = LoggerBuf;
                ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer = LogFileBuf;
            }
#endif
            break;
        }

        case IOCTL_WMI_STOP_LOGGER:
        {
            PWMI_LOGGER_INFORMATION LoggerInfo;
#ifdef _WIN64
            ULONG LoggerBuf, LogFileBuf;
#endif

            if ((InBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ||
                (OutBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if ( !(Wnode->Flags & WNODE_FLAG_TRACED_GUID) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            LoggerInfo = (PWMI_LOGGER_INFORMATION) Wnode;
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                LoggerBuf = ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer;
                LoggerInfo->LoggerName.Buffer = UlongToPtr(LoggerBuf);
                LogFileBuf = ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer;
                LoggerInfo->LogFileName.Buffer = UlongToPtr(LogFileBuf);
            }
            else {
                LoggerBuf = 0;
                LogFileBuf = 0;
            }
#endif
            Status = WmiStopTrace( LoggerInfo );
            OutBufferLen = sizeof (WMI_LOGGER_INFORMATION);
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer = LoggerBuf;
                ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer = LogFileBuf;
            }
#endif
            break;
        }

        case IOCTL_WMI_QUERY_LOGGER:
        {
            PWMI_LOGGER_INFORMATION LoggerInfo;
#ifdef _WIN64
            ULONG LoggerBuf, LogFileBuf;
#endif

            if ((InBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ||
                (OutBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if ( !(Wnode->Flags & WNODE_FLAG_TRACED_GUID) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            LoggerInfo = (PWMI_LOGGER_INFORMATION) Wnode;
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                LoggerBuf = ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer;
                LoggerInfo->LoggerName.Buffer = UlongToPtr(LoggerBuf);
                LogFileBuf = ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer;
                LoggerInfo->LogFileName.Buffer = UlongToPtr(LogFileBuf);
            }
            else {
                LoggerBuf = 0;
                LogFileBuf = 0;
            }
#endif
            Status = WmipQueryLogger( LoggerInfo, NULL );
            OutBufferLen = sizeof (WMI_LOGGER_INFORMATION);
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer = LoggerBuf;
                ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer = LogFileBuf;
            }
#endif
            break;
        }

        case IOCTL_WMI_UPDATE_LOGGER:
        {
            PWMI_LOGGER_INFORMATION LoggerInfo;
#ifdef _WIN64
            ULONG LoggerBuf, LogFileBuf;
#endif

            if ((InBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ||
                (OutBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if ( !(Wnode->Flags & WNODE_FLAG_TRACED_GUID) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            LoggerInfo = (PWMI_LOGGER_INFORMATION) Wnode;
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                LoggerBuf = ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer;
                LoggerInfo->LoggerName.Buffer = UlongToPtr(LoggerBuf);
                LogFileBuf = ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer;
                LoggerInfo->LogFileName.Buffer = UlongToPtr(LogFileBuf);
            }
            else {
                LoggerBuf = 0;
                LogFileBuf = 0;
            }
#endif
            Status = WmiUpdateTrace( LoggerInfo );
            OutBufferLen = sizeof (WMI_LOGGER_INFORMATION);
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer = LoggerBuf;
                ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer = LogFileBuf;
            }
#endif
            break;
        }

        case IOCTL_WMI_FLUSH_LOGGER:
        {
            PWMI_LOGGER_INFORMATION LoggerInfo;
#ifdef _WIN64
            ULONG LoggerBuf, LogFileBuf;
#endif

            if ((InBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ||
                (OutBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if ( !(Wnode->Flags & WNODE_FLAG_TRACED_GUID) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            LoggerInfo = (PWMI_LOGGER_INFORMATION) Wnode;
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                LoggerBuf = ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer;
                LoggerInfo->LoggerName.Buffer = UlongToPtr(LoggerBuf);
                LogFileBuf = ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer;
                LoggerInfo->LogFileName.Buffer = UlongToPtr(LogFileBuf);
            }
            else {
                LoggerBuf = 0;
                LogFileBuf = 0;
            }
#endif
            Status = WmiFlushTrace( LoggerInfo );
            OutBufferLen = sizeof (WMI_LOGGER_INFORMATION);
#ifdef _WIN64
            if (IoIs32bitProcess(Irp)) {
                ( (PUNICODE_STRING32) &LoggerInfo->LoggerName)->Buffer = LoggerBuf;
                ( (PUNICODE_STRING32) &LoggerInfo->LogFileName)->Buffer = LogFileBuf;
            }
#endif
            break;
        }

        case IOCTL_WMI_TRACE_EVENT:
        { // NOTE: This relies on WmiTraceEvent to probe the buffer!
            OutBufferLen = 0;
            if ( InBufferLen < sizeof(WNODE_HEADER) ) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            Status = WmiTraceEvent(
                        (PWNODE_HEADER)
                        irpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                        KeGetPreviousMode()
                        );
            break;
        }

        case IOCTL_WMI_TRACE_MESSAGE:
        { // NOTE: This relies on WmiTraceUserMessage to probe the buffer!
            OutBufferLen = 0;
            if ( InBufferLen < sizeof(MESSAGE_TRACE_USER) ) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            Status = WmiTraceUserMessage(
                        (PMESSAGE_TRACE_USER)
                        irpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                        InBufferLen
                        );
            break;
        }

        case IOCTL_WMI_SET_MARK:
        {
            OutBufferLen = 0;
            if ( InBufferLen <= FIELD_OFFSET(WMI_SET_MARK_INFORMATION, Mark)) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            Status = WmiSetMark( (PVOID) Wnode, InBufferLen );
            break;
        }

        case IOCTL_WMI_CLOCK_TYPE:
        {
            if ((InBufferLen < sizeof(WMI_LOGGER_INFORMATION)) ||
                (OutBufferLen < sizeof(WMI_LOGGER_INFORMATION))) {
                OutBufferLen = 0;
                Status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            WmipValidateClockType((PWMI_LOGGER_INFORMATION) Wnode);

            Status = STATUS_SUCCESS;
            break;
        }

#ifdef NTPERF
        case IOCTL_WMI_SWITCH_BUFFER:
        {
            if ((InBufferLen < sizeof(PWMI_SWITCH_BUFFER_INFORMATION)) ||
                (OutBufferLen < sizeof(PWMI_SWITCH_BUFFER_INFORMATION)) ) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            Status = WmipSwitchPerfmemBuffer((PWMI_SWITCH_BUFFER_INFORMATION) Wnode );
            OutBufferLen = sizeof (PVOID);
            break;
        }
#endif

        

#endif // if not MEMPHIS
        case IOCTL_WMI_NTDLL_LOGGERINFO:
        {

            if ((InBufferLen < sizeof(WMINTDLLLOGGERINFO)) ||
                (OutBufferLen < sizeof(WMINTDLLLOGGERINFO))) {
                OutBufferLen = 0;
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            
            Status = WmipNtDllLoggerInfo((PWMINTDLLLOGGERINFO)Buffer);

            break;
        }

        default:
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Unsupported IOCTL %x\n",
                     irpStack->Parameters.DeviceIoControl.IoControlCode));

            Status = STATUS_INVALID_DEVICE_REQUEST;

        }
    }

    if (Status != STATUS_PENDING)
    {
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = NT_SUCCESS(Status) ? OutBufferLen : 0;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return(Status);
}

NTSTATUS
WmipSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PAGED_CODE();

    return(IoWMISystemControl((PWMILIB_INFO)&WmipWmiLibInfo,
                               DeviceObject,
                               Irp));
}


NTSTATUS WmipWmiIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    WMI forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. WmipForwardWmiIrp will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:

    DeviceObject is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that WmipForwardWmiIrp will wait on


Return Value:

    NT status code

--*/
{
    PIRPCOMPCTX IrpCompCtx;
    PREGENTRY RegEntry;
    PKEVENT Event;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    IrpCompCtx = (PIRPCOMPCTX)Context;
    RegEntry = IrpCompCtx->RegEntry;
    Event = &IrpCompCtx->Event;

    WmipDecrementIrpCount(RegEntry);

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS WmipGetDevicePDO(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *PDO
    )
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    IO_STATUS_BLOCK IoStatusBlock;
    PDEVICE_RELATIONS DeviceRelations;
    NTSTATUS Status;
    KEVENT Event;

    PAGED_CODE();

    *PDO = NULL;
    KeInitializeEvent( &Event,
                       NotificationEvent,
                       FALSE );

    Irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                           DeviceObject,
                                           NULL,
                                           0,
                                           NULL,
                                           &Event,
                                           &IoStatusBlock );

    if (Irp == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IrpSp = IoGetNextIrpStackLocation( Irp );
    IrpSp->MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    IrpSp->Parameters.QueryDeviceRelations.Type = TargetDeviceRelation;

    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    Status = IoCallDriver( DeviceObject, Irp );

    if (Status == STATUS_PENDING)
    {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL );
        Status = IoStatusBlock.Status;

    }

    if (NT_SUCCESS(Status))
    {
        DeviceRelations = (PDEVICE_RELATIONS)IoStatusBlock.Information;
        ASSERT(DeviceRelations);
        ASSERT(DeviceRelations->Count == 1);
        *PDO = DeviceRelations->Objects[0];
        ExFreePool(DeviceRelations);
    }
    return(Status);
}

NTSTATUS WmipObjectToPDO(
    PFILE_OBJECT FileObject,
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *PDO
    )
/*++

Routine Description:

    This routine will determine the PDO which is the target of a file handle.
    The mechananism is to build a IRP_MJ_PNP irp with IRP_MN_QUERY_RELATIONS
    and query for TargetDeviceRelation. This irp is supposed to be passed down
    a device stack until it hits the PDO which will fill in its device object
    and return. Note that some drivers may not support this.

Arguments:

    FileObject is the file object for device that is being queried

    DeviceObject is the device object that is being queried

    *PDO returns with the PDO that is targeted by the file object. When
        the caller has finished using the PDO it must ObDereferenceObject it.

Return Value:

    NT status code

--*/
{
    NTSTATUS Status;

    PAGED_CODE();


    if (DeviceObject == NULL)
    {
        DeviceObject = IoGetRelatedDeviceObject(FileObject);
    }

    if (DeviceObject != NULL)
    {
        Status = WmipGetDevicePDO(DeviceObject, PDO);
    } else {
        Status = STATUS_NO_SUCH_DEVICE;
    }
    return(Status);
}


NTSTATUS WmipForwardWmiIrp(
    PIRP Irp,
    UCHAR MinorFunction,
    ULONG ProviderId,
    PVOID DataPath,
    ULONG BufferLength,
    PVOID Buffer
    )
/*++

Routine Description:

    If the provider is a driver then this routine will allocate a new irp
    with the correct stack size and send it to the driver. If the provider
    is a callback then it is called directly.

    It is assumed that the caller has performed any security checks required

Arguments:

    Irp is the IOCTL irp that initiated the request
    MinorFunction specifies the minor function code of the WMI Irp
    WmiRegistrationId is the id passed by the user mode code. This routine
        will look it up to determine the device object pointer.
    DataPath is the value for the DataPath parameter of the WMI irp
    BufferLength is the value for the BufferLength parameter of the WMI irp
    Buffer is the value for the Buffer parameter of the WMI irp

Return Value:

    NT status code

--*/
{
    PREGENTRY RegEntry;
    NTSTATUS Status;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT TargetDeviceObject;
    CCHAR DeviceStackSize;
    IRPCOMPCTX IrpCompCtx;
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    LOGICAL IsPnPIdRequest;
    PDEVICE_OBJECT DeviceObject;

    PAGED_CODE();


    WmipAssert( (MinorFunction >= IRP_MN_QUERY_ALL_DATA) &&
                (MinorFunction <= IRP_MN_REGINFO_EX) );

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // For non-file handle based requests we get the registration entry
    // to validate the target and check for a callback

    RegEntry = WmipFindRegEntryByProviderId(ProviderId, TRUE);

    if (RegEntry != NULL)
    {
        if (RegEntry->Flags & REGENTRY_FLAG_NOT_ACCEPTING_IRPS)
        {
            WmipUnreferenceRegEntry(RegEntry);
            WmipDecrementIrpCount(RegEntry);

            if ((MinorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
                (MinorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE))
            {
                Status = STATUS_WMI_INSTANCE_NOT_FOUND;
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }

            return(Status);
        }

        DeviceObject = RegEntry->DeviceObject;
        
#ifndef MEMPHIS
        if (RegEntry->Flags & REGENTRY_FLAG_CALLBACK)
        {
            ULONG Size = 0;
            //
            // This guy registered as a callback so do the callback and go.
            Status = (*RegEntry->WmiEntry)(MinorFunction,
                                           DataPath,
                                           BufferLength,
                                           Buffer,
                                           RegEntry->WmiEntry,
                                           &Size
                                           );
            Irp->IoStatus.Status = Status;
            Irp->IoStatus.Information = Size;

            WmipUnreferenceRegEntry(RegEntry);
            WmipDecrementIrpCount(RegEntry);

            return(Status);
        }
#endif
    } else {
        WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: Invalid device object passed from user mode %x\n",
             ProviderId));
        if ((MinorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
            (MinorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE))
        {
            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        return(Status);
    }

    //
    // Determine if this is a query for the device pnp id guid
    IsPnPIdRequest = ((MinorFunction != IRP_MN_REGINFO) &&
                      (MinorFunction != IRP_MN_REGINFO_EX)) &&
                  ((IsEqualGUID(&Wnode->Guid, &WmipDataProviderPnpidGuid)) ||
                   (IsEqualGUID(&Wnode->Guid, &WmipDataProviderPnPIdInstanceNamesGuid)));
    if (IsPnPIdRequest && (RegEntry->PDO != NULL))
    {
        //
        // Its the PnPId request and WMI is handling it on behalf of the
        // device then switch the device object to our own
        DeviceObject = WmipServiceDeviceObject;
        IsPnPIdRequest = FALSE;
    }

    //
    // Get the top of the device stack for our targer WMI device. Note that
    // IoGetAttachedDeviceReference also takes an object reference
    // which we get rid of after the the irp is completed by the
    // data provider driver.
    TargetDeviceObject = IoGetAttachedDeviceReference(DeviceObject);
    DeviceStackSize = TargetDeviceObject->StackSize + 1;

    //
    // Check that there are enough stack locations in our irp so that we
    // can forward it to the top of the device stack. We must also check
    // if our target device is the WMI data or service device otherwise
    // the number of stack locations for it will keep increementing until
    // the machine crashes
    if ((DeviceStackSize <= WmipServiceDeviceObject->StackSize) ||
        (TargetDeviceObject == WmipServiceDeviceObject))
    {
        //
        // There are enough stack locations in the WMI irp to forward
        // Remember some context information in our irp stack and use
        // it as our completion context value

        KeInitializeEvent( &IrpCompCtx.Event,
                       SynchronizationEvent,
                       FALSE );

        IrpCompCtx.RegEntry = RegEntry;

        IoSetCompletionRoutine(Irp,
                                   WmipWmiIrpCompletion,
                                   (PVOID)&IrpCompCtx,
                                   TRUE,
                                   TRUE,
                                   TRUE);

        //
        // Setup next irp stack location with WMI irp info
        irpStack = IoGetNextIrpStackLocation(Irp);
        irpStack->MajorFunction = IRP_MJ_SYSTEM_CONTROL;
        irpStack->MinorFunction = MinorFunction;
        irpStack->Parameters.WMI.ProviderId = (ULONG_PTR)DeviceObject;
        irpStack->Parameters.WMI.DataPath = DataPath;
        irpStack->Parameters.WMI.BufferSize = BufferLength;
        irpStack->Parameters.WMI.Buffer = Buffer;

        //
        // Initialize irp status to STATUS_NOT_SUPPORTED so that we can
        // detect the case where no data provider responded to the irp
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        IoMarkIrpPending(Irp);
        Status = IoCallDriver(TargetDeviceObject, Irp);

        if (Status == STATUS_PENDING) {
             KeWaitForSingleObject( &IrpCompCtx.Event,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER) NULL );
             Status = Irp->IoStatus.Status;
        }

        //
        // Check if the status code is still STATUS_NOT_SUPPORTED. If this is
        // the case then most likely no data provider responded to the irp.
        // So we want to change the status code to something more relevant
        // to WMI like STATUS_WMI_GUID_NOT_FOUND
        if (Status == STATUS_NOT_SUPPORTED)
        {
            Status = STATUS_WMI_GUID_NOT_FOUND;
            Irp->IoStatus.Status = STATUS_WMI_GUID_NOT_FOUND;
        }

#if DBG
        if (((MinorFunction == IRP_MN_REGINFO) || (MinorFunction == IRP_MN_REGINFO_EX))  &&
            (NT_SUCCESS(Status)) &&
            (Irp->IoStatus.Information == 0))
        {
            WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL,"WMI: %p completed IRP_MN_REGINFO with size 0 (%p, %x)\n",
                     DeviceObject, Buffer, BufferLength));
        }
#endif

        //
        // If this was a registration request then we need to see if there are
        // any PDOs that need to be translated into static instance names.
        if (((MinorFunction == IRP_MN_REGINFO) ||
             (MinorFunction == IRP_MN_REGINFO_EX)) &&
            (NT_SUCCESS(Status)) &&
            (Irp->IoStatus.Information > FIELD_OFFSET(WMIREGINFOW,
                                                      WmiRegGuid)))
        {
            WmipTranslatePDOInstanceNames(Irp,
                                          MinorFunction,
                                          BufferLength,
                                          RegEntry);
        }

        //
        // Dereference regentry which was taken when forwarding the irp
        WmipUnreferenceRegEntry(RegEntry);
    } else {
        //
        // There are not enough stack locations to forward this irp.
        // We bump the stack count for the WMI device and return
        // an error asking to try the irp again.
        WmipUnreferenceRegEntry(RegEntry);
        WmipDecrementIrpCount(RegEntry);

        WmipUpdateDeviceStackSize(DeviceStackSize);
        Status = STATUS_WMI_TRY_AGAIN;
    }

    //
    // Dereference the target device which was the top of the stack to
    // which we forwarded the irp.
    ObDereferenceObject(TargetDeviceObject);

    return(Status);
}

NTSTATUS WmipSendWmiIrp(
    UCHAR MinorFunction,
    ULONG ProviderId,
    PVOID DataPath,
    ULONG BufferLength,
    PVOID Buffer,
    PIO_STATUS_BLOCK Iosb
    )
/*++

Routine Description:

    This routine will allocate a new irp and then forward it on as a WMI
    irp appropriately. The routine handles the case where the stack size
    is too small and will retry the irp.

Arguments:

    See WmipForwardWmiIrp

Return Value:

    NT status code

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS Status;

    PAGED_CODE();

    Irp = NULL;
    do
    {
           Irp = IoAllocateIrp((CCHAR)(WmipServiceDeviceObject->StackSize+1),
                            FALSE);

        if (Irp == NULL)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        IoSetNextIrpStackLocation(Irp);
        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        IrpStack->DeviceObject = WmipServiceDeviceObject;
        Irp->Tail.Overlay.Thread = PsGetCurrentThread();
        Irp->AssociatedIrp.SystemBuffer = Buffer;

        Status = WmipForwardWmiIrp(
                                   Irp,
                                   MinorFunction,
                                   ProviderId,
                                   DataPath,
                                   BufferLength,
                                   Buffer);

        *Iosb = Irp->IoStatus;

        IoFreeIrp(Irp);
    } while (Status == STATUS_WMI_TRY_AGAIN);

    return(Status);
}


NTSTATUS WmipTranslateFileHandle(
    IN OUT PWMIFHTOINSTANCENAME FhToInstanceName,
    IN OUT PULONG OutBufferLen,
    IN HANDLE FileHandle,
    IN PDEVICE_OBJECT DeviceObject,
    IN PWMIGUIDOBJECT GuidObject,
    OUT PUNICODE_STRING InstanceNameString
    )
/*++

Routine Description:

    This routine will translate a file handle or device object into the
    device instance name for the target PDO of the device object
    pointed to by the file handle.

Arguments:

    FhToInstanceName passes in the file handle and returns the device
        instance name.

Return Value:

    NT status code

--*/
{
    PDEVICE_OBJECT PDO;
    UNICODE_STRING DeviceInstanceName;
    PFILE_OBJECT FileObject = NULL;
    NTSTATUS Status;
    ULONG SizeNeeded;
    PWCHAR InstanceName;
    ULONG Length;
    PWCHAR HandleName;
    ULONG HandleNameLen;
    PWCHAR BaseName;
    SIZE_T BaseNameLen;
    PBGUIDENTRY GuidEntry;
    PLIST_ENTRY InstanceSetList;
    PBINSTANCESET InstanceSet;
    ULONG BaseIndex;

    PAGED_CODE();


    if (FhToInstanceName != NULL)
    {
        WmipAssert(FileHandle == NULL);
        WmipAssert(GuidObject == NULL);
        WmipAssert(InstanceNameString == NULL);
        WmipAssert(DeviceObject == NULL);
        FileHandle = FhToInstanceName->FileHandle.Handle;
        if (FileHandle == NULL)
        {
            return(STATUS_INVALID_HANDLE);
        }
    }

    if (FileHandle != NULL)
    {
        //
        // Make reference to the file object so it doesn't go away
        //
        Status = ObReferenceObjectByHandle(FileHandle,
                                           0,
                                           IoFileObjectType,
                                           KernelMode,
                                           &FileObject,
                                           NULL);
    } else {
        //
        // Make reference to the device object so it doesn't go away
        //
        Status = ObReferenceObjectByPointer(DeviceObject,
                                            FILE_ALL_ACCESS,
                                            NULL,
                                            KernelMode);
    }

    if (NT_SUCCESS(Status))
    {
        Status = WmipObjectToPDO(FileObject,
                                 DeviceObject,
                                 &PDO);
        if (NT_SUCCESS(Status))
        {
            //
            // Map file object to PDO
            Status = WmipPDOToDeviceInstanceName(PDO,
                                                 &DeviceInstanceName);
            if (NT_SUCCESS(Status))
            {
                //
                // Now see if we can find an instance name
                //
                HandleName = DeviceInstanceName.Buffer;
                HandleNameLen = DeviceInstanceName.Length / sizeof(WCHAR);
                if (FhToInstanceName != NULL)
                {
                    Status = ObReferenceObjectByHandle(FhToInstanceName->KernelHandle.Handle,
                                                       WMIGUID_QUERY,
                                                       WmipGuidObjectType,
                                                       UserMode,
                                                       &GuidObject,
                                                       NULL);
                } else {
                    Status = ObReferenceObjectByPointer(GuidObject,
                                                        WMIGUID_QUERY,
                                                        WmipGuidObjectType,
                                                        KernelMode);
                }

                if (NT_SUCCESS(Status))
                {
                    Status = STATUS_WMI_INSTANCE_NOT_FOUND;
                    GuidEntry = GuidObject->GuidEntry;
                    BaseIndex = 0;

                    WmipEnterSMCritSection();
                    if (GuidEntry->ISCount > 0)
                    {
                        InstanceSetList = GuidEntry->ISHead.Flink;
                        while ((InstanceSetList != &GuidEntry->ISHead) &&
                               ! NT_SUCCESS(Status))
                        {
                            InstanceSet = CONTAINING_RECORD(InstanceSetList,
                                                        INSTANCESET,
                                                        GuidISList);
                            if (InstanceSet->Flags & IS_INSTANCE_BASENAME)
                            {
                                BaseName = InstanceSet->IsBaseName->BaseName;
                                BaseNameLen = wcslen(BaseName);

                                //
                                // If the instance set has a base name
                                // and the beginning of it matches the
                                // PnPId and it has only an _ after it
                                // then we have got a match
                                //
                                if ((_wcsnicmp(BaseName,
                                              HandleName,
                                              HandleNameLen) == 0) &&
                                    (BaseNameLen == (HandleNameLen+1)) &&
                                    (BaseName[BaseNameLen-1] == L'_'))
                                {
                                    BaseIndex = InstanceSet->IsBaseName->BaseIndex;
                                    Status = STATUS_SUCCESS;
                                }
                            }
                            InstanceSetList = InstanceSetList->Flink;
                        }
                    }

                    WmipLeaveSMCritSection();

                    if (NT_SUCCESS(Status))
                    {
                        if (FhToInstanceName != NULL)
                        {
                            FhToInstanceName->BaseIndex = BaseIndex;
                            SizeNeeded = DeviceInstanceName.Length + 2 * sizeof(WCHAR) +
                                  FIELD_OFFSET(WMIFHTOINSTANCENAME,
                                               InstanceNames);
                            if (*OutBufferLen >= SizeNeeded)
                            {
                                InstanceName = &FhToInstanceName->InstanceNames[0];
                                Length = DeviceInstanceName.Length;

                                FhToInstanceName->InstanceNameLength = (USHORT)(Length + 2 * sizeof(WCHAR));
                                RtlCopyMemory(InstanceName,
                                              DeviceInstanceName.Buffer,
                                              DeviceInstanceName.Length);

                                //
                                // Double NUL terminate string
                                //
                                Length /= 2;
                                InstanceName[Length++] = UNICODE_NULL;
                                InstanceName[Length] = UNICODE_NULL;

                                *OutBufferLen = SizeNeeded;
                            } else if (*OutBufferLen >= sizeof(ULONG)) {
                                FhToInstanceName->SizeNeeded = SizeNeeded;
                                *OutBufferLen = sizeof(ULONG);
                            } else {
                                Status = STATUS_UNSUCCESSFUL;
                            }
                        } else {
                            InstanceNameString->MaximumLength = DeviceInstanceName.Length + 32;
                            InstanceName = ExAllocatePoolWithTag(PagedPool,
                                                                 InstanceNameString->MaximumLength,
                                                                 WmipInstanceNameTag);
                            if (InstanceName != NULL)
                            {
                                StringCbPrintf(InstanceName,
                                                    InstanceNameString->MaximumLength,
                                                    L"%ws_%d",
                                                    DeviceInstanceName.Buffer,
                                                    BaseIndex);
                                InstanceNameString->Buffer = InstanceName;
                                InstanceNameString->Length = (USHORT)wcslen(InstanceName) * sizeof(WCHAR);
                            } else {
                                Status = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                    }

                    ObDereferenceObject(GuidObject);
                }
                RtlFreeUnicodeString(&DeviceInstanceName);
            }
            ObDereferenceObject(PDO);
        }

        if (FileHandle != NULL)
        {
            ObDereferenceObject(FileObject);
        } else {
            ObDereferenceObject(DeviceObject);
        }
    }
    return(Status);
}

#ifndef MEMPHIS
BOOLEAN
WmipFastIoDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(FileObject);
    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(OutputBuffer);
    UNREFERENCED_PARAMETER(OutputBufferLength);
    UNREFERENCED_PARAMETER(DeviceObject);

    if (IoControlCode == IOCTL_WMI_TRACE_EVENT) {
        if (InputBufferLength < sizeof(EVENT_TRACE_HEADER))
            return FALSE;

        IoStatus->Status = WmiTraceEvent( InputBuffer, KeGetPreviousMode() );
        return TRUE;
    } else if (IoControlCode == IOCTL_WMI_TRACE_MESSAGE) {
        if (InputBufferLength < sizeof(MESSAGE_TRACE_USER))
            return FALSE;

        IoStatus->Status = WmiTraceUserMessage( InputBuffer, InputBufferLength );
        return TRUE;
    }
    return FALSE;
}
#endif

NTSTATUS WmipProbeWnodeWorker(
    PWNODE_HEADER WnodeHeader,
    ULONG MinWnodeSize,
    ULONG InstanceNameOffset,
    ULONG DataBlockOffset,
    ULONG DataBlockSize,
    ULONG InBufferLen,
    ULONG OutBufferLen,
    BOOLEAN CheckOutBound,
    BOOLEAN CheckInBound
    )
/*++

Routine Description:

    Probe the incoming Wnode to ensure that any offsets in the
    header point to memory that is valid within the buffer. Also validate
    that the Wnode is properly formed.

    This routine assumes that the input and output buffers has been
    probed enough to determine that it is at least as large as
    MinWnodeSize and MinWnodeSize must be at least as large as
    sizeof(WNODE_HEADER)

    WNODE Rules:

    9. For outbound data WnodeDataBlockOffset != 0
    5. For inbound Wnode->DataBlockOffset must be 0 (implying no data) or
       Wnode->DataBlockOffset must be <= incoming buffer size and >=
       sizeof(WNODE_SINGLE_INSTANCE), that is
       the data block must start in the incoming buffer, but after the
       WNODE_SINGLE_INSTANCE header.
    6. Wnode and Wnode->DataBlockOffset must be aligned on an 8 byte boundry.
    7. For inbound data (SetSingleInstance) (Wnode->DataBlockOffset +
       Wnode->DataBlockSize) < incoming buffer length. That is the entire
       data block must fit within the incoming buffer.
    8. For outbound data (QuerySingleInstance) Wnode->DataBlockOffset
       must be <= outgoing buffer length. That is the start of the outgoing
       data block must fit within the outgoing data buffer. Note that it is
       the provider's responsibility to determine if there will be enough
       space in the outgoing buffer to write the returned data.

    10. Wnode->OffsetInstanceNames must be aligned on a 2 byte boundry
    11. Wnode->OffsetInstanceNames must be <= (incoming buffer size) +
        sizeof(USHORT), that is it must start within the incoming buffer and
        the USHORT that specifies the length must be within the incoming
        buffer.
    12. The entire instance name string must fit with the incoming buffer
    13. For outbound data (QuerySingleInstance) the entire instance name
        must start and fit within the output buffer.
    14. Wnode->DataBlockOffset must be placed after any instance name and
        not overlap the instance name.



Arguments:

    WnodeHeader - pointer to WNODE to be probed

    InBufferLen - Size of the incoming buffer

    OutBufferLen - Size of the outgoing buffer

    MinWnodeSize - minimum size that the WNODE can be

    InstanceNameOffset - Offset within WNODE to instance name

    DataBlockOffset - Offset within WNODE to data block

     DataBlockSize - Size of data block

    CheckOutBound - If TRUE, WNODE needs to be validated for provider to
                    return data.

    CheckInBound - If TRUE WNODE needs to be validated for provider to
                   receive data

Return Value:

    NT status code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWCHAR InstanceNamePtr;

    PAGED_CODE();

    if (InstanceNameOffset != 0)
    {
        //
        // Validate instance name begins beyond WNODE header
        if (InstanceNameOffset < MinWnodeSize)
        {
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // Validate InstanceName is aligned properly. This is left
        // in the free build since alphas may have alignment requiremnts
        // in handling USHORTs and WCHARs

        //
        // Validate that USHORT holding instance name length is within
        // WNODE
        if (( ! WmipIsAligned(InstanceNameOffset, 2)) ||
            (InstanceNameOffset > InBufferLen - sizeof(USHORT)) )
        {
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // Validate Dynamic Instance Name text is fully within
        // input buffer and output buffer for outbound WNODEs
        InstanceNamePtr = (PWCHAR)OffsetToPtr(WnodeHeader,
                                                  InstanceNameOffset);
        InstanceNameOffset += sizeof(USHORT) + *InstanceNamePtr;
        if ( (InstanceNameOffset > InBufferLen) ||
             ( (CheckOutBound) && (InstanceNameOffset > OutBufferLen)) )
        {
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // If data block is specified then it must be placed after the
        // end of the instance name
        if ((DataBlockOffset != 0) &&
            (DataBlockOffset < InstanceNameOffset))
        {
            return(STATUS_UNSUCCESSFUL);
        }

    }

    //
    // Ensure data block offset is placed after the WNODE header
    // header
    if ((DataBlockOffset != 0) &&
        (DataBlockOffset < MinWnodeSize))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Ensure data block is aligned properly
    if (! WmipIsAligned(DataBlockOffset, 8))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // For incoming WNODE, make sure the data block
    // does not extend beyond the input buffer.
    if ((CheckInBound) &&
        (DataBlockOffset != 0) &&
        ( (DataBlockSize > InBufferLen) ||
          (DataBlockOffset > InBufferLen - DataBlockSize) ) )
    {
        return(STATUS_UNSUCCESSFUL);
    }

    if (CheckOutBound)
    {
        //
        // For outgoing WNODE make sure there is
        // enough room to write the WNODE header

        //
        // For outgoing WNODE make sure the data block
        // offset is within the bounds of the output buffer
        if ( (OutBufferLen < MinWnodeSize) ||
             (DataBlockOffset > OutBufferLen) )
        {
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // Make sure that the data block offset is specified so provider
        // can know where to write data
        if (DataBlockOffset == 0)
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }

    return(Status);
}
NTSTATUS WmipProbeWnodeAllData(
    PWNODE_ALL_DATA Wnode,
    ULONG InBufferLen,
    ULONG OutBufferLen
    )
/*++

Routine Description:

    Probe the incoming WNODE_ALL_DATA to ensure that any offsets in the
    header point to memory that is valid within the buffer. Also validate
    that the WNODE_ALL_DATA is properly formed.

    This routine MUST succeed before any fields in the WNODE_ALL_DATA can be
    used by any  kernel components when passed in from user mode. Note that
    we can trust that the input and output buffer are properly sized since
    the WMI IOCTLs are METHOD_BUFFERED and the IO manager does that for us.


    WNODE_ALL_DATA_RULES:

    1. Wnode is aligned on a 8 byte boundry
    2. The incoming buffer must be at least as large as sizeof(WNODE_HEADER)
    3. The outgoing buffer must be at least as large as sizeof(WNODE_ALL_DATA)
    5. WnodeHeader->BufferSize must equal incoming bufffer size

Arguments:

    Wnode - WNODE_ALL_DATA to be validated

    InBufferLen - Size of the incoming buffer

    OutBufferLen - Size of the outgoing buffer


Return Value:

    NT status code

--*/
{
    NTSTATUS Status;
    PWNODE_HEADER WnodeHeader = (PWNODE_HEADER)Wnode;

    PAGED_CODE();

    //
    // Io is supposed to guarantee this
    //
    WmipAssert(WmipIsAligned(Wnode, 8));
    
    //
    // Make sure that enough of the WNODE_ALL_DATA was passed so that we
    // can look at it and the drivers can fill it in
    //
    if (OutBufferLen < sizeof(WNODE_ALL_DATA))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    Status = WmipValidateWnodeHeader(WnodeHeader,
                                         InBufferLen,
                                         sizeof(WNODE_HEADER),
                                         WNODE_FLAG_ALL_DATA,
                                         0xffffff7e);
    return(Status);
}

NTSTATUS WmipProbeWnodeSingleInstance(
    PWNODE_SINGLE_INSTANCE Wnode,
    ULONG InBufferLen,
    ULONG OutBufferLen,
    BOOLEAN OutBound
    )
/*++

Routine Description:

    Probe the incoming WNODE_SINGLE_INSTANCE to ensure that any offsets in the
    header point to memory that is valid within the buffer. Also validate
    that the WNODE_SINGLE_INSTANCE is properly formed.

    This routine MUST succeed before any fields in the WNODE_SINGLE_INSTANCE
    can be used by any  kernel components when passed in from user mode.
    Note that we can trust that the input and output buffer are properly
    sized since the WMI IOCTLs are METHOD_BUFFERED and the IO manager does
    that for us.

    WNODE_SINGLE_INSTANCE Rules:

    1. The incoming buffer must be at least as large as
       sizeof(WNODE_SINGLE_INSTANCE)
    2. The outgoing buffer must be at least as large as
       sizeof(WNODE_SINGLE_INSTANCE)
    3. WnodeHeader->ProviderId must be non null, Actual value validated when
       irp is forwarded.
    4. WnodeHeader->BufferSize must equal incoming bufffer size
    5. Wnode->DataBlockOffset must be 0 (implying no data) or
       Wnode->DataBlockOffset must be <= incoming buffer size and >=
       sizeof(WNODE_SINGLE_INSTANCE), that is
       the data block must start in the incoming buffer, but after the
       WNODE_SINGLE_INSTANCE header.
    6. Wnode and Wnode->DataBlockOffset must be aligned on an 8 byte boundry.
    7. For inbound data (SetSingleInstance) (Wnode->DataBlockOffset +
       Wnode->DataBlockSize) <= incoming buffer length. That is the entire
       data block must fit within the incoming buffer.
    8. For outbound data (QuerySingleInstance) Wnode->DataBlockOffset
       must be <= outgoing buffer length. That is the start of the outgoing
       data block must fit within the outgoing data buffer. Note that it is
       the provider's responsibility to determine if there will be enough
       space in the outgoing buffer to write the returned data.
    9. For outbound data (QuerySingleInstance) WnodeDataBlockOffset != 0

    10. Wnode->OffsetInstanceNames must be aligned on a 2 byte boundry
    11. Wnode->OffsetInstanceNames + sizeof(USHORT) must be <= incoming
        buffer size, that is it must start within the incoming buffer and
        the USHORT that specifies the length must be within the incoming
        buffer.
    12. The entire instance name string must fit with the incoming buffer
    13. For outbound data (QuerySingleInstance) the entire instance name
        must start and fit within the output buffer.
    14. Wnode->DataBlockOffset must be placed after any instance name and
        not overlap the instance name.



Arguments:

    Wnode - WNODE_SINGLE_INSTANCE to be validated

    InBufferLen - Size of the incoming buffer

    OutBufferLen - Size of the outgoing buffer

    OutBound - If FALSE, WNODE_SINGLE_INSTANCE has inbound data that must be
              validated to be within the input buffer. If FALSE,
              WNODE_SINGLE_INSTANCE is expected to be filled with data
              by the driver so insure that data buffer is validated to
              be within the output buffer.

Return Value:

    NT status code

--*/
{
    PWNODE_HEADER WnodeHeader = (PWNODE_HEADER)Wnode;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Io makes sure WNODE is on a 8 byte boundry
    //
    WmipAssert(WmipIsAligned((PUCHAR)Wnode, 8));

    //
    // Make sure that enough of the WNODE_SINGLE_INSTANCE was passed
    // so that we can look at it
    //
    if ((InBufferLen < FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData)) ||
        ( (OutBound) && (OutBufferLen < FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                     VariableData))))
    {
        return(STATUS_UNSUCCESSFUL);
    }


    Status = WmipProbeWnodeWorker(WnodeHeader,
                                  FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                               VariableData),
                                  Wnode->OffsetInstanceName,
                                  Wnode->DataBlockOffset,
                                  Wnode->SizeDataBlock,
                                  InBufferLen,
                                  OutBufferLen,
                                  OutBound,
                                  (BOOLEAN)(! OutBound));

    if (NT_SUCCESS(Status))
    {
        Status = WmipValidateWnodeHeader(WnodeHeader,
                                 InBufferLen,
                                 FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                              VariableData),
                                 WNODE_FLAG_SINGLE_INSTANCE,
                                 0xffffff7d);
    }

    return(Status);
}

NTSTATUS WmipProbeWnodeSingleItem(
    PWNODE_SINGLE_ITEM Wnode,
    ULONG InBufferLen
    )
/*++

Routine Description:

    Probe the incoming WNODE_SINGLE_ITEM to ensure that any offsets in the
    header point to memory that is valid within the buffer. Also validate
    that the WNODE_SINGLE_ITEM is properly formed.

    This routine MUST succeed before any fields in the WNODE_SINGLE_INSTANCE
    can be used by any  kernel components when passed in from user mode.
    Note that we can trust that the input and output buffer are properly
    sized since the WMI IOCTLs are METHOD_BUFFERED and the IO manager does
    that for us.

WNODE_SINGLE_ITEM rules:

    1. The incoming buffer must be at least as large as
       sizeof(WNODE_SINGLE_ITEM)
    2. The outgoing buffer must be at least as large as
       sizeof(WNODE_SINGLE_ITEM)
    3. WnodeHeader->ProviderId must be non null, Actual value validated when
       irp is forwarded.
    4. WnodeHeader->BufferSize must equal incoming bufffer size
    5. Wnode->DataBlockOffset must be 0 (implying no data) or
       Wnode->DataBlockOffset must be <= incoming buffer size and >=
       sizeof(WNODE_SINGLE_ITEM), that is
       the data block must start in the incoming buffer, but after the
       WNODE_SINGLE_ITEM header.
    6. Wnode and Wnode->DataBlockOffset must be aligned on an 8 byte boundry.
    7. (Wnode->DataBlockOffset + Wnode->SizeDataItem) <
       incoming buffer length. That is the entire
       data block must fit within the incoming buffer.
    8. Wnode->DataItemId must not be 0

    9. Wnode->OffsetInstanceNames must be aligned on a 2 byte boundry
    10. Wnode->OffsetInstanceNames must be <= (incoming buffer size) +
        sizeof(USHORT), that is it must start within the incoming buffer and
        the USHORT that specifies the length must be within the incoming
        buffer.
    11. The entire instance name string must fit with the incoming buffer
    12. Wnode->DataBlockOffset must be placed after any instance name and
        not overlap the instance name.

Arguments:

    Wnode - WNODE_SINGLE_ITEM to be validated

    InBufferLen - Size of the incoming buffer

Return Value:

    NT status code

--*/
{
    PWNODE_HEADER WnodeHeader = (PWNODE_HEADER)Wnode;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Io Makes sure WNODE is on a 8 byte boundry
    //
    WmipAssert(WmipIsAligned((PUCHAR)Wnode, 8));

    //
    // Make sure that enough of the WNODE_SINGLE_ITEM was passed
    // so that we can look at it
    //
    if (InBufferLen < FIELD_OFFSET(WNODE_SINGLE_ITEM, VariableData))
    {
        return(STATUS_UNSUCCESSFUL);
    }


    //
    // We don't use sizeof(WNODE_SINGLE_ITEM), but rather use the offset
    // to the variable data since in the case of WNODE_SINGLE_ITEM they are
    // different. The C compiler will round up the packing to 8 bytes so
    // the former is 48 and the later is 44.
    //
    Status = WmipProbeWnodeWorker(WnodeHeader,
                                  (ULONG)((ULONG_PTR)(&((PWNODE_SINGLE_ITEM)0)->VariableData)),
                                  Wnode->OffsetInstanceName,
                                  Wnode->DataBlockOffset,
                                  Wnode->SizeDataItem,
                                  InBufferLen,
                                  0,
                                  FALSE,
                                  TRUE);

    if (NT_SUCCESS(Status))
    {
        Status = WmipValidateWnodeHeader(WnodeHeader,
                                     InBufferLen,
                                     FIELD_OFFSET(WNODE_SINGLE_ITEM,
                                                  VariableData),
                                     WNODE_FLAG_SINGLE_ITEM,
                                     0xffffff7b);
    }

    return(Status);
}


NTSTATUS WmipProbeWnodeMethodItem(
    PWNODE_METHOD_ITEM Wnode,
    ULONG InBufferLen,
    ULONG OutBufferLen
    )
/*++

Routine Description:

    Probe the incoming WNODE_METHOD_ITEM to ensure that any offsets in the
    header point to memory that is valid within the buffer. Also validate
    that the WNODE_METHOD_ITEM is properly formed.

    This routine MUST succeed before any fields in the WNODE_METHOD_INSTANCE
    can be used by any  kernel components when passed in from user mode.
    Note that we can trust that the input and output buffer are properly
    sized since the WMI IOCTLs are METHOD_BUFFERED and the IO manager does
    that for us.

    WNODE_METHOD_ITEM Rules:

    1. The incoming buffer must be at least as large as
       sizeof(WNODE_METHOD_ITEM)
    2. The outgoing buffer must be at least as large as
       sizeof(WNODE_METHOD_ITEM)
    3. WnodeHeader->ProviderId must be non null, Actual value validated when
       irp is forwarded and Wnode->MethodId must not be 0
    4. WnodeHeader->BufferSize must equal incoming bufffer size
    5. Wnode->DataBlockOffset must be 0 (implying no data) or
       Wnode->DataBlockOffset must be <= incoming buffer size and >=
       sizeof(WNODE_METHOD_ITEM), that is
       the data block must start in the incoming buffer, but after the
       WNODE_METHOD_ITEM header.
    6. Wnode and Wnode->DataBlockOffset must be aligned on an 8 byte boundry.
    7. For inbound data (Wnode->DataBlockOffset +
       Wnode->DataBlockSize) < incoming buffer length. That is the entire
       data block must fit within the incoming buffer.
    8. For outbound data Wnode->DataBlockOffset
       must be <= outgoing buffer length. That is the start of the outgoing
       data block must fit within the outgoing data buffer. Note that it is
       the provider's responsibility to determine if there will be enough
       space in the outgoing buffer to write the returned data.
    9. WnodeDataBlockOffset != 0

    10. Wnode->OffsetInstanceNames must be aligned on a 2 byte boundry
    11. Wnode->OffsetInstanceNames must be <= (incoming buffer size) +
        sizeof(USHORT), that is it must start within the incoming buffer and
        the USHORT that specifies the length must be within the incoming
        buffer.
    12. The entire instance name string must fit with the incoming buffer
    13. For outbound data the entire instance name
        must start and fit within the output buffer.
    14. Wnode->DataBlockOffset must be placed after any instance name and
        not overlap the instance name.


Arguments:

    Wnode - WNODE_METHOD_ITEM to be validated

    InBufferLen - Size of the incoming buffer

    OutBufferLen - Size of the Output buffer

Return Value:

    NT status code

--*/
{
    PWNODE_HEADER WnodeHeader = (PWNODE_HEADER)Wnode;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Make sure WNODE is on a 8 byte boundry
    //
    WmipAssert(WmipIsAligned((PUCHAR)Wnode, 8));

    //
    // Make sure that enough of the WNODE_METHOD_ITEM was passed
    // so that we can look at it
    //
    if (InBufferLen < FIELD_OFFSET(WNODE_METHOD_ITEM, VariableData))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    Status = WmipProbeWnodeWorker(WnodeHeader,
                                  (ULONG)((ULONG_PTR)(&((PWNODE_METHOD_ITEM)0)->VariableData)),
                                  Wnode->OffsetInstanceName,
                                  Wnode->DataBlockOffset,
                                  Wnode->SizeDataBlock,
                                  InBufferLen,
                                  OutBufferLen,
                                  TRUE,
                                  TRUE);

    if (NT_SUCCESS(Status))
    {
        Status = WmipValidateWnodeHeader(WnodeHeader,
                                 InBufferLen,
                                 FIELD_OFFSET(WNODE_METHOD_ITEM,
                                              VariableData),
                                 WNODE_FLAG_METHOD_ITEM,
                                 0xffff7f7f);
    }

    return(Status);
}

NTSTATUS WmipProbeAndCaptureGuidObjectAttributes(
    POBJECT_ATTRIBUTES CapturedObjectAttributes,
    PUNICODE_STRING CapturedGuidString,
    PWCHAR CapturedGuidBuffer,
    POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    PAGED_CODE();
    
#if defined(_WIN64)
    if (IoIs32bitProcess(NULL))
    {
        POBJECT_ATTRIBUTES32 ObjectAttributes32;
        PUNICODE_STRING32 GuidString32;

        //
        // Probe the embedded object attributes and string name
        //
        ObjectAttributes32 = (POBJECT_ATTRIBUTES32)ObjectAttributes;

        try
        {
            //
            // Probe, capture and validate the OBJECT_ATTRIBUTES
            //
            ProbeForRead( ObjectAttributes32,
                          sizeof(OBJECT_ATTRIBUTES32),
                          sizeof(ULONG) );

            CapturedObjectAttributes->Length = sizeof(OBJECT_ATTRIBUTES);
            CapturedObjectAttributes->RootDirectory = UlongToPtr(ObjectAttributes32->RootDirectory);
            CapturedObjectAttributes->Attributes = ObjectAttributes32->Attributes;
            CapturedObjectAttributes->SecurityDescriptor = UlongToPtr(ObjectAttributes32->SecurityDescriptor);
            CapturedObjectAttributes->SecurityQualityOfService = UlongToPtr(ObjectAttributes32->SecurityQualityOfService);

            //
            // Now probe and validate the guid nane string passed
            //
            GuidString32 = UlongToPtr(ObjectAttributes32->ObjectName);
            ProbeForRead(GuidString32,
                         sizeof(UNICODE_STRING32),
                         sizeof(ULONG));

            CapturedGuidString->Length = GuidString32->Length;
            CapturedGuidString->MaximumLength = GuidString32->MaximumLength;
            CapturedGuidString->Buffer = UlongToPtr(GuidString32->Buffer);

            if (CapturedGuidString->Length != ((WmiGuidObjectNameLength) * sizeof(WCHAR)))
            {
                return(STATUS_INVALID_PARAMETER);
            }

            ProbeForRead(CapturedGuidString->Buffer,
                         CapturedGuidString->Length,
                         sizeof(UCHAR));

            RtlCopyMemory(CapturedGuidBuffer,
                          CapturedGuidString->Buffer,
                          WmiGuidObjectNameLength * sizeof(WCHAR));

            CapturedGuidBuffer[WmiGuidObjectNameLength] = UNICODE_NULL;
            CapturedGuidString->Buffer = CapturedGuidBuffer;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return(GetExceptionCode());
        }

    }
    else
#endif
    {
        PUNICODE_STRING GuidString;

        //
        // Probe the embedded object attributes and string name
        //
        try
        {
            //
            // Probe, capture and validate the OBJECT_ATTRIBUTES
            //
            *CapturedObjectAttributes = ProbeAndReadStructure( ObjectAttributes,
                                                              OBJECT_ATTRIBUTES);

            //
            // Now probe and validate the guid nane string passed
            //
            GuidString = CapturedObjectAttributes->ObjectName;
            *CapturedGuidString = ProbeAndReadUnicodeString(GuidString);

            if (CapturedGuidString->Length != ((WmiGuidObjectNameLength) * sizeof(WCHAR)))
            {
                return(STATUS_INVALID_PARAMETER);
            }

            ProbeForRead(CapturedGuidString->Buffer,
                         CapturedGuidString->Length,
                         sizeof(UCHAR));

            RtlCopyMemory(CapturedGuidBuffer,
                          CapturedGuidString->Buffer,
                          WmiGuidObjectNameLength * sizeof(WCHAR));

            CapturedGuidBuffer[WmiGuidObjectNameLength] = UNICODE_NULL;
            CapturedGuidString->Buffer = CapturedGuidBuffer;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return(GetExceptionCode());
        }
    }

    CapturedObjectAttributes->ObjectName = CapturedGuidString;
    
    return(STATUS_SUCCESS);
}

NTSTATUS WmipProbeWmiOpenGuidBlock(
    POBJECT_ATTRIBUTES CapturedObjectAttributes,
    PUNICODE_STRING CapturedGuidString,
    PWCHAR CapturedGuidBuffer,
    PULONG DesiredAccess,
    PWMIOPENGUIDBLOCK InGuidBlock,
    ULONG InBufferLen,
    ULONG OutBufferLen
    )
{
    NTSTATUS Status;
    POBJECT_ATTRIBUTES ObjectAttributes;
    
    PAGED_CODE();

#if defined(_WIN64)
    if (IoIs32bitProcess(NULL))
    {
        PWMIOPENGUIDBLOCK32 InGuidBlock32;

        if ((InBufferLen != sizeof(WMIOPENGUIDBLOCK32)) ||
            (OutBufferLen != sizeof(WMIOPENGUIDBLOCK32)))
        {
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // Probe the embedded object attributes and string name
        //
        InGuidBlock32 = (PWMIOPENGUIDBLOCK32)InGuidBlock;
        ObjectAttributes = ULongToPtr(InGuidBlock32->ObjectAttributes);
        *DesiredAccess = InGuidBlock32->DesiredAccess;
    }
    else
#endif
    {
        //
        // Ensure the input and output buffer sizes are correct
        //
        if ((InBufferLen != sizeof(WMIOPENGUIDBLOCK)) ||
            (OutBufferLen != sizeof(WMIOPENGUIDBLOCK)))
        {
            return(STATUS_UNSUCCESSFUL);
        }

        //
        // Probe the embedded object attributes and string name
        //
        ObjectAttributes = InGuidBlock->ObjectAttributes;
        *DesiredAccess = InGuidBlock->DesiredAccess;
    }

    Status = WmipProbeAndCaptureGuidObjectAttributes(CapturedObjectAttributes,
                                                     CapturedGuidString,
                                                     CapturedGuidBuffer,
                                                     ObjectAttributes);

    if (NT_SUCCESS(Status))
    {
        if ((CapturedObjectAttributes->RootDirectory != NULL) ||
            (CapturedObjectAttributes->Attributes != 0) ||
            (CapturedObjectAttributes->SecurityDescriptor != NULL) ||
            (CapturedObjectAttributes->SecurityQualityOfService != NULL))
        {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return(Status);
}

NTSTATUS WmipProbeWmiRegRequest(
    PDEVICE_OBJECT DeviceObject, 
    PWMIREGREQUEST Buffer,
    ULONG InBufferLen,
    ULONG OutBufferLen,
    PBOOLEAN pMofIgnored
    )
/*++

Routine Description:

    Probe the incoming WMIREGREQUEST to ensure that any offsets in the
    header point to memory that is valid within the buffer. Also validate
    that the WMIREGINFO is properly formed.

    This routine MUST succeed before any fields in the WMI_REG_INFO
    can be used by any  kernel components when passed in from user mode.
    Note that we can trust that the input and output buffer are properly
    sized since the WMI IOCTLs are METHOD_BUFFERED and the IO manager does
    that for us.

    WMIREGREQUEST Rules:

    1. The incoming buffer must be at least as large as
       sizeof(WMIREGREQUEST) + sizeof(WMIREGINFOW)
    2. The outgoing buffer must be at least as large as
       sizeof(WMIREGRESULTS)
    3. WmiRegInfo->BufferSize must be less than incoming Buffer size minus
       sizeof(WMIREGREQUEST)
    4. GuidCount must be at least 1 and less than MAXWMIGUIDCOUNT
    5. WmiRegInfo->BufferSize must be greater than equal to
        sizeof(WMIREGINFOW) + WmiRegInfo->GuidCount * sizeof(WMIREGGUIDW)
    5. WmiRegInfo->RegistryPath offset must be within the incoming buffer
    6. WmiRegInfo->MofResourcePath offset must be within the incomoing buffer
    7. RegistryPath and MofResourceName strings are counted unicode strings. 
       Their length must be within the incoming buffer
    8. For WOW64, RefInfo32Size and RegGuid32Size passed in must be non-zero and 
       cannot be larger than their 64 bit counter part. 
    9. Since we decipher the counted strings at a buffer offset, the offset
       must be aligned to 2 bytes (for USHORT). 
   10. Trace Registrations do not use InstanceNames within REGGUIDW. 
       Therefore InstanceCount and InstanceNameList fields must be zero. 

Arguments:

    Buffer - WMIREGREQUEST to be validated

    InBufferLen - Size of the incoming buffer

    OutBufferLen - Size of the Output buffer

Return Value:

    NT status code

--*/

{
    ULONG WmiRegInfoSize;
    PWMIREGINFOW WmiRegInfo;
    PWMIREGREQUEST WmiRegRequest;
    PWMIREGGUIDW WmiRegGuid;
    ULONG GuidCount;
    ULONG SizeNeeded; 
    ULONG ImageNameLength=0;
    ULONG ResourceNameLength=0;
    PUCHAR pSource;
    ULONG i;

    PAGED_CODE();

    //
    // Incoming Buffer must be atleast the sizeof WMIREGREQUEST + WMIREGINFO
    //
    *pMofIgnored = FALSE;

    if (InBufferLen >= (sizeof(WMIREGREQUEST) + sizeof(WMIREGINFO)))
    {
        WmiRegRequest = (PWMIREGREQUEST)Buffer;
        WmiRegInfo = (PWMIREGINFOW) OffsetToPtr (Buffer, sizeof(WMIREGREQUEST));
        WmiRegInfoSize = WmiRegInfo->BufferSize;

        GuidCount = WmiRegInfo->GuidCount;

        //
        // BufferSize specified must be within the size of incoming Buffer.
        //

        if (WmiRegInfoSize  <= (InBufferLen - sizeof(WMIREGREQUEST)) )
        {
            if ((GuidCount == 0) || (GuidCount > WMIMAXREGGUIDCOUNT))
            {
                return STATUS_UNSUCCESSFUL;
            }

            //
            // If the Registration call came through Admin device, we are
            // okay to send the BinaryMof through. If it came through the
            // DataDevice, then we need to disable the Binary MOF. We do
            // that by simply zapping the MofResourceName and RegistryPath
            //
            if (DeviceObject != WmipAdminDeviceObject)
            {
                if (WmiRegInfo->MofResourceName > 0) 
                {
                    *pMofIgnored = TRUE;
                }
                WmiRegInfo->RegistryPath = 0;
                WmiRegInfo->MofResourceName = 0;
            }

            //
            // Make sure the RegistryPath and MofResourceName offsets are
            // within the REGINFO buffer.
            //

            if ( (WmiRegInfo->RegistryPath >= WmiRegInfoSize) ||
                 (WmiRegInfo->MofResourceName >= WmiRegInfoSize) ) {
               return STATUS_UNSUCCESSFUL;
            }

            //
            // Validate the Counted Strings. 
            // 

            if (WmiRegInfo->RegistryPath > 0) 
            {
                //
                // String Offsets need to be aligned to 2 Bytes
                //
                if (( WmiRegInfo->RegistryPath & 1) != 0) 
                {
                    return STATUS_UNSUCCESSFUL;
                }
                ImageNameLength = *((PUSHORT)OffsetToPtr(WmiRegInfo, WmiRegInfo->RegistryPath) );
                ImageNameLength += sizeof(USHORT);

                if ((WmiRegInfo->RegistryPath + ImageNameLength ) > WmiRegInfoSize) 
                {
                    return STATUS_UNSUCCESSFUL;
                }

            }

            if (WmiRegInfo->MofResourceName > 0) 
            {
                if ((WmiRegInfo->MofResourceName & 1) != 0) 
                {
                    return STATUS_UNSUCCESSFUL;
                }

                ResourceNameLength = *((PUSHORT)OffsetToPtr(WmiRegInfo, WmiRegInfo->MofResourceName)); 
                ResourceNameLength += sizeof(USHORT);

                if ( (WmiRegInfo->MofResourceName + ResourceNameLength) > WmiRegInfoSize)
                {
                    return STATUS_UNSUCCESSFUL;
                }
            }
            // Note: If the ImagePath and MofResource trample over each other but stayed
            // within BufferSize , we will not catch it. 

#if defined(_WIN64)
            if (IoIs32bitProcess(NULL))
            {
                //
                // Check to make sure the 32 bit structure sizes passed in 
                // by the caller is comparable to the 64-bit counterparts
                // 

                if ((WmiRegRequest->WmiRegInfo32Size == 0) || 
                    (WmiRegRequest->WmiRegInfo32Size > sizeof(WMIREGINFOW)) )
                {
                    return STATUS_UNSUCCESSFUL;
                }

                if ((WmiRegRequest->WmiRegGuid32Size == 0) ||
                    (WmiRegRequest->WmiRegGuid32Size > sizeof(WMIREGGUIDW)) )
                {
                    return STATUS_UNSUCCESSFUL;
                }

                //
                // InstanceCount and InstanceNameList in 
                // WMIREGGUIDW structure must be zero. This check is 
                // done after thunking gor WOW64. 
                //


                SizeNeeded =  WmiRegRequest->WmiRegInfo32Size +
                              GuidCount * WmiRegRequest->WmiRegGuid32Size +
                              ImageNameLength +
                              ResourceNameLength;
                if (SizeNeeded > WmiRegInfoSize) { 
                    return STATUS_UNSUCCESSFUL;
                }
                
            }
            else 
#endif
            {

                SizeNeeded = sizeof(WMIREGINFOW) + 
                             GuidCount * sizeof(WMIREGGUIDW) + 
                             ImageNameLength + 
                             ResourceNameLength;
                
                if (SizeNeeded > WmiRegInfoSize) { 
                    return STATUS_UNSUCCESSFUL;
                }
                
                //
                // Check to see if the InstanceCount and InstanceNameList in 
                // WMIREGGUIDW structure is zero
                //
                pSource = OffsetToPtr(WmiRegInfo, sizeof(WMIREGINFOW) );
                for (i=0; i < GuidCount; i++) {
                    WmiRegGuid = (PWMIREGGUIDW) pSource;
                    if ( (WmiRegGuid->InstanceCount > 0) ||
                         (WmiRegGuid->InstanceNameList > 0) )
                    {
                        return STATUS_UNSUCCESSFUL;
                    }
                    pSource += sizeof(WMIREGGUIDW);
                }

            }

            //
            // Now validate the OutBuffer size needed
            //

            if (sizeof(WMIREGRESULTS) > OutBufferLen) 
            {
                return STATUS_UNSUCCESSFUL;
            }

            //
            // All tests passed. Return SUCCESS
            //
            return STATUS_SUCCESS;
        }
    }
    return STATUS_UNSUCCESSFUL;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\wmidata.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    WmiData.c

Abstract:

    Define storage for Guids and common global structures

Author:

    JeePang

Environment:

    Kernel mode

Revision History:


--*/
#undef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#include <initguid.h>
#include <ntos.h>

//
// Time out constents
//
const LARGE_INTEGER WmiOneSecond = {(ULONG)(-1 * 1000 * 1000 * 10), -1};
const LARGE_INTEGER WmiShortTime = {(ULONG)(-10 * 1000 * 10), -1}; // 10 milliseconds

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
#include <wmistr.h>
#include <wmiguid.h>
#define _WMIKM_
#include <evntrace.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\kdexts\tracing\kdexts.c ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.
    
    These declarations and code should be moved into a header file.
    The declarations should have an optional "extern" in front of them.
    The code should be made __inline to avoid having multiple copies of it.
    N.B.: There are currently 80 copies of this code in the tree.

Author:

    Wesley Witt (wesw)      26-Aug-1993
    Glenn Peterson (glennp) 22-Mar-2000:    Trimmed down version from \nt\base\tools\kdexts2

Environment:

    User Mode

--*/

//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;

#define KDEXTS_EXTERN
#include    "kdExts.h"
#undef  KDEXTS_EXTERN

static USHORT           SavedMajorVersion;
static USHORT           SavedMinorVersion;


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
#if 0
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }
#endif

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}


VOID
wmiTraceDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}


VOID
CheckVersion(
    VOID
    )
{
}


BOOLEAN
IsCheckedBuild(
    PBOOLEAN Checked
    )
{
    BOOLEAN result;

    result = FALSE;
    if (HaveDebuggerData ()) {
        result = TRUE;
        *Checked = (KernelVersionPacket.MajorVersion == 0xc) ;
    }

   return (result);
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    static  EXT_API_VERSION ApiVersion = { (VER_PRODUCTVERSION_W >> 8),
                                           (VER_PRODUCTVERSION_W & 0xff),
                                           EXT_API_VERSION_NUMBER64,  0 };
    return (&ApiVersion);
}


BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 0) {
        if (!Ioctl (IG_GET_KERNEL_VERSION, &KernelVersionPacket, sizeof(KernelVersionPacket))) {
            havedata = 2;
        } else if (KernelVersionPacket.MajorVersion == 0) {
            havedata = 2;
        } else {
            havedata = 1;
        }
    }

    return ((havedata == 1) &&
            ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0));
}


USHORT
TargetMachineType(
    VOID
    )
{
    if (HaveDebuggerData()) {
        return (KernelVersionPacket.MachineType);
    } else {
        dprintf("Error - Cannot get Kernel Version.\n");
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\wmikmp.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    wmikmp.h

Abstract:

    Private header for WMI kernel mode component

Author:

    AlanWar

Environment:

Revision History:


--*/

#ifndef _WMIKMP_
#define _WMIKMP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4706)   // assignment inside conditional
#pragma warning(disable:4327)   // LHS indirection alignment is greater
#pragma warning(disable:4328)   // parameter alignment is greater

//
// Define this to cause no security descriptor to be placed on the service
// device. This should never be defined for released builds; it is only
// needed when debugging the service startup code.
//#define NO_SERVICE_DEVICE_SECURITY

//
// define this to get allocation debug info
//#define DEBUG_ALLOCS

#ifdef MEMPHIS
//
// In building for memphis we include WDM.h which defines the WMI apis as
// DECLSPEC_IMPORT which we don't want. So we redefine the api names around
// the inclusion of WDM.h.
//
#define IoWMIRegistrationControl IoWMIRegistrationControlImport
#define IoWMIAllocateInstanceIds IoWMIAllocateInstanceIdsImport
#define IoWMISuggestInstanceName IoWMISuggestInstanceNameImport
#define IoWMIWriteEvent IoWMIWriteEventImport
#endif

#ifdef MEMPHIS
#define UNICODE

#define WANTVXDWRAPS
#include <wdm.h>
#include <poclass.h>
#include <basedef.h>
#include <regstr.h>
#include <vmm.h>
#include <vmmreg.h>
#include <shell.h>
#include <vpicd.h>
#include <vxdldr.h>
#include <ntkern.h>
#include <vpowerd.h>
#include <vxdwraps.h>
#include <configmg.h>
#include <devinfo.h>
#include <stdarg.h>
#else
#include "ntos.h"
#include "zwapi.h"

#ifndef IsEqualGUID
            #define IsEqualGUID(guid1, guid2) \
                (!memcmp((guid1), (guid2), sizeof(GUID)))
#endif

#if DBG
//
// Debug levels are bit masks and are not cumulative. So if you want to see
// All errors and warnings you need to have bits 0 and 1 set.
//
// Mask for WMICORE is in variable nt!Kd_WMICORE_Mask
//
// Registry can be setup with initial mask value for nt!Kd_WMICORE_Mask by
// setting up a DWORD value named WMICORE under key
// HKLM\System\CurrnetControlSet\Control\Session Manager\Debug Print Filter
//
// Standard levels are
//    DPFLTR_ERROR_LEVEL     0   0x00000001
//    DPFLTR_WARNING_LEVEL   1   0x00000002
//    DPFLTR_TRACE_LEVEL     2   0x00000004
//    DPFLTR_INFO_LEVEL      3   0x00000008
//
// Custom debug print levels are 4 through 31
//
#define DPFLTR_MCA_LEVEL     4      // 0x00000010
#define DPFLTR_OBJECT_LEVEL  5      // 0x00000020
#define DPFLTR_API_INFO_LEVEL 6     // 0x00000040 
#define DPFLTR_EVENT_INFO_LEVEL 7   // 0x00000080
#define DPFLTR_REGISTRATION_LEVEL 8 // 0x00000100


#define WMICORE_INFO DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL
#define WmipDebugPrintEx(_x_) DbgPrintEx _x_
#else
#define WmipDebugPrintEx(_x_)
#endif  // if DBG
#endif  // ifdef MEMPHIS

#include "wmiguid.h"
#include "wmidata.h"

#include <stdio.h>

#ifndef MEMPHIS
extern POBJECT_TYPE IoFileObjectType;
#endif

#ifdef MEMPHIS
#undef IoWMIRegistrationControl
#undef IoWMIAllocateInstanceIds
#undef IoWMISuggestInstanceName
#undef IoWMIWriteEvent
#endif

#include "wmistr.h"
#include "wmiumkm.h"
#include <wmi.h>

NTSTATUS IoWMIAllocateInstanceIds(
    IN GUID *Guid,
    IN ULONG InstanceCount,
    OUT ULONG *FirstInstanceId
    );

NTKERNELAPI
NTSTATUS
IoCreateDriver (
    IN PUNICODE_STRING DriverName,   OPTIONAL
    IN PDRIVER_INITIALIZE InitializationFunction
    );

#define WmipAssert ASSERT

#define WMIPOOLTAG 'pimW'
#define WMINCPOOLTAG 'nimW'
#define WMINPPOOLTAG 'NimW'
#define WMINWPOOLTAG 'wimW'
#define WMIMSGPOOLTAG 'mimW'
#define WMIIIPOOLTAG 'iimW'
#define WMIREGPOOLTAG 'RimW'
#define WMISYSIDPOOLTAG 'simW'
#define WmipRegisterDSPoolTag 'DimW'
#define WMIPSCHEDPOOLTAG 'gaiD'
#define WmipMCAPoolTag 'acMW'
#define WmipInstanceNameTag 'IimW'
#define WMI_GM_POOLTAG    'jimW'
#define WMIPCREATETHREADTAG 'CimW'

#define OffsetToPtr(Base, Offset) ((PUCHAR)((PUCHAR)(Base) + (Offset)))

//
// Maximum size allowed for any WNODE_EVENT_ITEM
#define DEFAULTMAXKMWNODEEVENTSIZE 0x80000
#define LARGEKMWNODEEVENTSIZE 512

typedef struct
{
    ULONG BufferSize;
    PUCHAR Buffer;
} REGQUERYBUFFERXFER, *PREGQUERYBUFFERXFER;


//
// We have got a single Mutex/Critical Section for the entire WMI KM code
// It is used anytime that access needs to be serialized. Typically it is
// used in the following cases:
//
// 1. Access to the internal data structures that contain the registration
//    list, guid entries, data sources, etc.
//
// 2. Synchronize collecting SMBIOS information
//
// 3. Tracelog purposes
//
// 4. Updating the device stack size
//
extern KMUTEX WmipSMMutex;

_inline NTSTATUS WmipEnterCritSection(
    BOOLEAN AllowAPC
    )
{
    NTSTATUS status;

    do
    {
        status = KeWaitForMutexObject(&WmipSMMutex,
                                       Executive,
                                       KernelMode,
                                       AllowAPC,
                                       NULL);
    } while((status == STATUS_ALERTED) ||
            (status == STATUS_USER_APC));

    return(status);
}

_inline void WmipLeaveCritSection(
    )
{
    KeReleaseMutex(&WmipSMMutex,
                   FALSE);
}

//
// SMCritSection does not allows APCs to occur while the mutex is held.
//
#define WmipEnterSMCritSection() WmipEnterCritSection(FALSE)
#define WmipLeaveSMCritSection() WmipLeaveCritSection()



//
// Tracelog Critical section is to serialize the Enabling and disabling
// of trace control guids. Since we want to allow Updates (enable a 
// a Guid with a different set of flags and levels), we serialize this 
// operation to reduce complexity of code.
// 
// NOTE: TraceCritSection must not be taken with SMCritSection held. 
//       Bad Deadlocks will result if that happens. 
//

extern KMUTEX WmipTLMutex;

_inline NTSTATUS WmipEnterTraceCritSection(
    BOOLEAN AllowAPC
    )
{
    NTSTATUS status;

    do
    {
        status = KeWaitForMutexObject(&WmipTLMutex,
                                       Executive,
                                       KernelMode,
                                       AllowAPC,
                                       NULL);
    } while((status == STATUS_ALERTED) ||
            (status == STATUS_USER_APC));

    return(status);
}

_inline void WmipLeaveTraceCritSection(
    )
{
    KeReleaseMutex(&WmipTLMutex,
                   FALSE);
}

//
// TLCritSection does not allows APCs to occur while the mutex is held.
//
#define WmipEnterTLCritSection() WmipEnterTraceCritSection(FALSE);
#define WmipLeaveTLCritSection() WmipLeaveTraceCritSection();


//
// This defines the stack size that the WMI device starts with. Since
// WMI irps will be forwarded any WMI data provider the WMI device must have
// more stack locations than the largest driver to which it forwards irps.
#define WmiDeviceStackSize 2

/////////////////////////////////////////////////////////////////////////////
// Device Registration Data structures

//
// Each WMI providing device object and callback is maintained in a REGENTRY
// structure which is allocated in chunks. Each entry is referenced by the
// Device object or the callback address. The WMI user mode service is given
// info from RegEntry structure, and is generally only interested in the
// DeviceObject (or WmiEntry) and flags. The user mode side uses the device
// object (or WmiEntry) as its "handle" to the data provider and is referred
// to as ProviderId in the user mode code.
//

struct tagDATASOURCE;

typedef struct _REGENTRY
{
    LIST_ENTRY InUseEntryList;    // Node in list of in use entries

    union
    {
        PDEVICE_OBJECT DeviceObject;    // Device object of registered device
#ifndef MEMPHIS
        WMIENTRY * WmiEntry;         // Pointer to a pointer to Callback function
#endif
    };
    LONG RefCount;                      // Reference Count
    LONG Flags;                         // Registration flags
    PDEVICE_OBJECT PDO;                 // PDO associated with device
    ULONG MaxInstanceNames;             // # instance names for device
    LONG IrpCount;                      // Count of IRPs currently active
    ULONG ProviderId;                   // Provider Id
    struct tagDATASOURCE *DataSource;   // Datasource associated with regentry
    KEVENT Event;                       // Event used to synchronize unloading
} REGENTRY, *PREGENTRY;

#define REGENTRY_FLAG_INUSE      0x00000001   // Entry is in use (not free)
#define REGENTRY_FLAG_CALLBACK   0x00000002   // Entry represents a callback
#define REGENTRY_FLAG_NEWREGINFO 0x00000004   // Entry has new registration info
#define REGENTRY_FLAG_UPDREGINFO 0x00000008   // Entry has updated registration info
                                // When set do not forward irps to the device
#define REGENTRY_FLAG_NOT_ACCEPTING_IRPS   0x00000010
#define REGENTRY_FLAG_TOO_SMALL  0x00000020
#define REGENTRY_FLAG_TRACED     0x00000040   // Entry represents traced device
                                // When set device is being rundown.
#define REGENTRY_FLAG_RUNDOWN    0x00000080

                                        // Entry is in process of registering
#define REGENTRY_FLAG_REG_IN_PROGRESS 0x00000100

                                       // Entry is UM data provider
#define REGENTRY_FLAG_UM_PROVIDER 0x00000200

#define REGENTRY_FLAG_TRACE_NOTIFY_MASK 0x000F0000  // Reserved for callouts

#define WmipSetKmRegInfo(KmRegInfoPtr, RegEntryPtr) \
{ \
    (KmRegInfoPtr)->ProviderId = (RegEntryPtr)->ProviderId; \
    (KmRegInfoPtr)->Flags = (RegEntryPtr)->Flags; \
}


typedef enum _REGOPERATION
{
    RegisterAllDrivers,
    RegisterSingleDriver,
    RegisterUpdateSingleDriver,
    RegisterDeleteSingleDriver
} REGOPERATION, *PREGOPERATION;

typedef struct _REGISTRATIONWORKITEM
{
    LIST_ENTRY ListEntry;
    REGOPERATION RegOperation;
    PREGENTRY RegEntry;
} REGISTRATIONWORKITEM, *PREGISTRATIONWORKITEM;


typedef struct
{
    LIST_ENTRY ListEntry;
    PREGENTRY RegEntry;
    PWNODE_HEADER Wnode;
} EVENTWORKCONTEXT, *PEVENTWORKCONTEXT;

typedef struct
{
    WORK_QUEUE_ITEM WorkItem;
    PVOID Object;
} CREATETHREADWORKITEM, *PCREATETHREADWORKITEM;


/////////////////////////////////////////////////////////////////////////////
// InstanceId management data structures

//
// This defines the number of INSTID structures in a chunk
#define INSTIDSPERCHUNK 8

typedef struct
{
    GUID Guid;            // Guid
    ULONG BaseId;         // Next instance id for guid
} INSTID, *PINSTID;

typedef struct tagINSTIDCHUNK
{
    struct tagINSTIDCHUNK *Next;    // Next chunk of INSTIDS
    INSTID InstId[INSTIDSPERCHUNK];
} INSTIDCHUNK, *PINSTIDCHUNK;

//
// TODO: Move from separate header into here
#include "wmiumds.h"

#define WmipBuildWnodeTooSmall(Wnode, BufferSizeNeeded) \
 ((PWNODE_TOO_SMALL)Wnode)->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);\
 ((PWNODE_TOO_SMALL)Wnode)->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL; \
 ((PWNODE_TOO_SMALL)Wnode)->SizeNeeded = BufferSizeNeeded;



typedef struct
{
    BOOLEAN Used20CallingMethod;
    UCHAR SMBiosMajorVersion;
    UCHAR SMBiosMinorVersion;
    UCHAR DMIBiosRevision;
} SMBIOSVERSIONINFO, *PSMBIOSVERSIONINFO;


//
// See smbios spec for System Event Log (Type 15) for detailed information
// on the contents of this structurre. The layout from element LogAreaLength
// to VariableData must match the layout of the SMBIOS System Eventlog
// structure as defined in the smbios spec and smbios.h.
//
typedef struct
{
    USHORT LogTypeDescLength;

    UCHAR LogHeaderDescExists;

    UCHAR Reserved;

    USHORT LogAreaLength;

    USHORT LogHeaderStart;

    USHORT LogDataStart;

    UCHAR AccessMethod;

    UCHAR LogStatus;

    ULONG LogChangeToken;

    ULONG AccessMethodAddress;

    //
    // LogHeaderFormat, NumberLogTypeDesc, LengthEachLogTypeDesc and
    // ListLogTypeDesc are only valid if LogHeaderDescExists is TRUE.
    // This means that SMBIOS is revision 2.1
    //
    UCHAR LogHeaderFormat;

    UCHAR NumberLogTypeDesc;

    UCHAR LengthEachLogTypeDesc;

    //
    // Within the variable data is the Log Type descriptors immediately
    // followed by the Eventlog area. The size of the Log Type Descriptors
    // is LogTypeDescLength bytes and the size of the Eventlog area is
    // LogAreaLength
    //
    UCHAR VariableData[1];

} SMBIOS_EVENTLOG_INFO, *PSMBIOS_EVENTLOG_INFO;

//
// WMI service device extension
extern PDEVICE_OBJECT WmipServiceDeviceObject;

#define WmipIsWmiNotSetupProperly() (WmipServiceDeviceObject == NULL)

typedef struct
{
    PREGENTRY RegEntry;
    KEVENT Event;
} IRPCOMPCTX, *PIRPCOMPCTX;


//
// This defines the WMI Guid object. There are really 5 different type of
// objects that are created from this data structure:
//
//     QuerySet Object returned to the data consumer to allow them to
//         send queries and sets to a particular set of providers. It
//         does not use a flag.
//
//     Notification Object is used by data consumers to receive events. It
//         is created when a data consumer wants to receive an event for a
//         particular guid and queues up the received events until they are
//         retrieved by the consumer. When the object is deleted it is
//         removed from the list of objects maintianed by a GuidEntry and
//         a event disable request is sent to the devices that expose
//         the events if this is the last object open to the event.
//         These have no flag set
//
//     Request Object is created on behalf of a user mode data provider
//         when it registers its guids with WMI. It acts like a Notification
//         object in that requests (in the form of events) are received
//         by it and then can be picked up by the user mode creator. It uses
//         the WMIGUID_FLAG_REQUEST_OBJECT flag. When a Request Object is
//         being deleted it will clean up any guids registered for it and
//         send a reply message to any reply objects waiting to receive
//         a message from it.
//
//     Reply Object is created as a product of Creating a user mode logger.
//         This object acts as a notification object to deliver replies
//         sent by request objects. When it is closed it will remove itself
//         from any request list that it may be part of and clear the
//         reference to it in any request objects and deref itself to account
//         for that. These use the WMIGUID_FLAG_REPLY_OBJECT flag
//
//      Security Objects are created so that the security apis can have
//         a mechanism to change the security descriptors for the guids
//         These have the WMIGUID_FLAG_SECURITY_OBJECT


// This defines the maximum number of outstanding requests that can
// be sent to a request object
#define MAXREQREPLYSLOTS  4

typedef struct
{
    struct _WMIGUIDOBJECT *ReplyObject;
    LIST_ENTRY RequestListEntry;
} MBREQUESTS, *PMBREQUESTS;

//
// This data structure is used to maintain a fixed sized queue of events
// waiting to be delivered to a user mdoe consumer.
//
typedef struct
{
    PUCHAR Buffer;               // Buffer that holds events waiting
    PWNODE_HEADER LastWnode;     // Last event so we can link to next
    ULONG MaxBufferSize;         // Max size of events that can be held
    ULONG NextOffset;             // Offset in buffer to next place to store
    ULONG EventsLost;            // # events lost
} WMIEVENTQUEUE, *PWMIEVENTQUEUE;


typedef struct _WMIGUIDOBJECT
{
    KEVENT Event;

    union
    {
        GUID Guid;
        PREGENTRY RegEntry;
    };

                             // Entry in linked list of objects for this guid
    LIST_ENTRY GEObjectList;
    PBGUIDENTRY GuidEntry;
    ULONG Type;              // Type of object

    union
    {
        //
        // Kernel mode event receiver - all we need is a callback &
        // context
        //
        struct
        {
            WMI_NOTIFICATION_CALLBACK Callback;
            PVOID CallbackContext;
        };
                
        struct
        {
            //
            // User mode Queued up event management
            //
            
            //
            // Info on how to startup a new pump thread
            //
            LIST_ENTRY ThreadObjectList;
            HANDLE UserModeProcess;
            PUSER_THREAD_START_ROUTINE UserModeCallback;
            SIZE_T StackSize;
            SIZE_T StackCommit;

            //
            // Info for request waiting to be completed
            //
            PIRP Irp;   // Irp waiting for event from this object

                        // Entry in list objects associated with an irp
            LIST_ENTRY IrpObjectList;

                                // What to do when an event is queued
            ULONG EventQueueAction;
            
            WMIEVENTQUEUE HiPriority;// Hi priority event queue
            WMIEVENTQUEUE LoPriority;// Lo priority event queue
        };
    };

    
    BOOLEAN EnableRequestSent;

    //
    // MB management
    //
    union
    {
        LIST_ENTRY RequestListHead; // Head of request list (reply object)
                                    // (request object)
        MBREQUESTS MBRequests[MAXREQREPLYSLOTS];
    };
    ULONG Cookie;

    ULONG Flags;

} WMIGUIDOBJECT, *PWMIGUIDOBJECT;

// Set if the guid is a request object, that is receives requests
#define WMIGUID_FLAG_REQUEST_OBJECT    0x00000001

// Set if the guid is a reply object, that is receives replies
#define WMIGUID_FLAG_REPLY_OBJECT      0x00000002

// Set if the guid is a security object
#define WMIGUID_FLAG_SECURITY_OBJECT   0x00000004

// Set if the guid is a kernel mode notification object, that is there
// is kernel mode code that wants a callback when an event is received
#define WMIGUID_FLAG_KERNEL_NOTIFICATION 0x00000008

// Set if the guid object is marked for pending closure, so no events
// should be queued to it
#define WMIGUID_FLAG_RECEIVE_NO_EVENTS   0x00000010

typedef struct
{
    PWMIGUIDOBJECT GuidObject;
    PWNODE_HEADER NextWnode;
} OBJECT_EVENT_INFO, *POBJECT_EVENT_INFO;



// NTSTATUS ValidateWnodeHeader(
//   PWNODE_HEADER Wnode,
//      ULONG BufSize,
//      ULONG BufferSizeMin,
//      ULONG RequiredFlags,
//     ULONG ProhibitedFlags
//      );

#define WmipValidateWnodeHeader( \
    Wnode, \
    BufSize, \
    BufferSizeMin, \
    RequiredFlags, \
    ProhibitedFlags \
    ) \
     (( (BufSize < BufferSizeMin) || \
        ( (Wnode->Flags & RequiredFlags) != RequiredFlags) || \
        (BufSize != Wnode->BufferSize) || \
        ( (Wnode->Flags & ProhibitedFlags) != 0))  ? \
                                   STATUS_UNSUCCESSFUL : STATUS_SUCCESS)

#define WmipIsAligned( Value, Alignment ) \
        ( ( (((ULONG_PTR)Value)+(Alignment-1)) & ~(Alignment-1) ) == ((ULONG_PTR)Value) )



typedef struct
{
    GUID Guid;               // Guid to registered
    ULONG InstanceCount;     // Count of Instances of Datablock
    ULONG Flags;             // Additional flags (see WMIREGINFO in wmistr.h)
} GUIDREGINFO, *PGUIDREGINFO;

typedef
NTSTATUS
(*PQUERY_WMI_REGINFO) (
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING Name,
    OUT PUNICODE_STRING *RegistryPath
    );
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    Name returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

Return Value:

    status

--*/

typedef
NTSTATUS
(*PQUERY_WMI_DATABLOCK) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call IoWMICompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry. If
        this is NULL then there was not enough space in the output buffer
        to fufill the request so the irp should be completed with the buffer
        needed.


Return Value:

    status

--*/

typedef
NTSTATUS
(*PSET_WMI_DATABLOCK) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call IoWMICompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/

typedef
NTSTATUS
(*PSET_WMI_DATAITEM) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call IoWMICompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/

typedef
NTSTATUS
(*PEXECUTE_WMI_METHOD) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    IoWMICompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being called.

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer on entry has the input data block and on return has the output
        output data block.


Return Value:

    status

--*/

typedef enum
{
    WmiEventGeneration,
    WmiDataBlockCollection
} WMIENABLEDISABLEFUNCTION;

typedef
NTSTATUS
(*PWMI_FUNCTION_CONTROL) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    );
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/

typedef struct _WMILIB_INFO
{
    //
    // Next device lower in the stack
    PDEVICE_OBJECT LowerDeviceObject;

    //
    // PDO associated with device
    PDEVICE_OBJECT LowerPDO;

    //
    // WMI data block guid registration info
    ULONG GuidCount;
    PGUIDREGINFO GuidList;

    //
    // WMI functionality callbacks
    PQUERY_WMI_REGINFO       QueryWmiRegInfo;
    PQUERY_WMI_DATABLOCK     QueryWmiDataBlock;
    PSET_WMI_DATABLOCK       SetWmiDataBlock;
    PSET_WMI_DATAITEM        SetWmiDataItem;
    PEXECUTE_WMI_METHOD      ExecuteWmiMethod;
    PWMI_FUNCTION_CONTROL    WmiFunctionControl;
} WMILIB_INFO, *PWMILIB_INFO;

NTSTATUS
IoWMICompleteRequest(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    );

NTSTATUS
IoWMISystemControl(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IoWMIFireEvent(
    IN PWMILIB_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG GuidIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    );

NTSTATUS IoWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Action
);

NTSTATUS IoWMIWriteEvent(
    IN PVOID WnodeEventItem
    );


// ds.c


extern GUID GUID_REGISTRATION_CHANGE_NOTIFICATION;
extern GUID GUID_MOF_RESOURCE_ADDED_NOTIFICATION;
extern GUID GUID_MOF_RESOURCE_REMOVED_NOTIFICATION;

NTSTATUS WmipEnumerateMofResources(
    PWMIMOFLIST MofList,
    ULONG BufferSize,
    ULONG *RetSize
    );

NTSTATUS WmipInitializeDataStructs(
    void
);

NTSTATUS WmipRemoveDataSource(
    PREGENTRY RegEntry
    );

NTSTATUS WmipUpdateDataSource(
    PREGENTRY RegEntry,
    PWMIREGINFOW RegistrationInfo,
    ULONG RetSize
    );

NTSTATUS WmipAddDataSource(
    IN PREGENTRY RegEntry,
    IN PWMIREGINFOW WmiRegInfo,
    IN ULONG BufferSize,
    IN PWCHAR RegPath,
    IN PWCHAR ResourceName,
    IN PWMIGUIDOBJECT RequestObject,
    IN BOOLEAN IsUserMode
    );

#define WmiInsertTimestamp(WnodeHeader) KeQuerySystemTime(&(WnodeHeader)->TimeStamp)


// consumer.c
NTSTATUS WmipMarkHandleAsClosed(
    HANDLE Handle
    );

NTSTATUS WmipUMProviderCallback(
    IN WMIACTIONCODE ActionCode,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer
);

NTSTATUS WmipOpenBlock(
    IN ULONG Ioctl,
    IN KPROCESSOR_MODE AccessMode,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG DesiredAccess,
    OUT PHANDLE Handle
    );

NTSTATUS WmipQueryAllData(
    IN PWMIGUIDOBJECT GuidObject,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN PWNODE_ALL_DATA Wnode,
    IN ULONG OutBufferLen,
    OUT PULONG RetSize
    );

NTSTATUS WmipQueryAllDataMultiple(
    IN ULONG ObjectCount,
    IN PWMIGUIDOBJECT *ObjectList,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PUCHAR BufferPtr,        
    IN ULONG BufferSize,
    IN PWMIQADMULTIPLE QadMultiple,
    OUT ULONG *ReturnSize
    );

NTSTATUS WmipQuerySingleMultiple(
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PUCHAR BufferPtr,
    IN ULONG BufferSize,
    IN PWMIQSIMULTIPLE QsiMultiple,
    IN ULONG QueryCount,
    IN PWMIGUIDOBJECT *ObjectList,
    IN PUNICODE_STRING InstanceNames,
    OUT ULONG *ReturnSize
    );

NTSTATUS WmipQuerySetExecuteSI(
    IN PWMIGUIDOBJECT GuidObject,
    IN PIRP Irp,
    IN KPROCESSOR_MODE AccessMode,
    IN UCHAR MinorFunction,
    IN OUT PWNODE_HEADER Wnode,
    IN ULONG OutBufferSize,
    OUT PULONG RetSize
    );

NTSTATUS WmipEnumerateGuids(
    ULONG Ioctl,
    PWMIGUIDLISTINFO GuidList,
    ULONG MaxBufferSize,
    ULONG *OutBufferSize
);

NTSTATUS WmipProcessEvent(
    PWNODE_HEADER Wnode,
    BOOLEAN IsHiPriority,
    BOOLEAN FreeBuffer
    );

NTSTATUS WmipQueryGuidInfo(
    IN OUT PWMIQUERYGUIDINFO QueryGuidInfo
    );

NTSTATUS WmipReceiveNotifications(
    PWMIRECEIVENOTIFICATION ReceiveNotification,
    PULONG OutBufferSize,
    PIRP Irp
    );

void WmipClearIrpObjectList(
    PIRP Irp
    );

NTSTATUS WmipWriteWnodeToObject(
    PWMIGUIDOBJECT Object,
    PWNODE_HEADER Wnode,
    BOOLEAN IsHighPriority
);

NTSTATUS WmipRegisterUMGuids(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Cookie,
    IN PWMIREGINFO RegInfo,
    IN ULONG RegInfoSize,
    OUT HANDLE *RequestHandle,
    OUT ULONG64 *LoggerContext
    );

NTSTATUS WmipUnregisterGuids(
    PWMIUNREGGUIDS UnregGuids
    );

NTSTATUS WmipCreateUMLogger(
    IN OUT PWMICREATEUMLOGGER CreateInfo
    );

NTSTATUS WmipMBReply(
    IN HANDLE RequestHandle,
    IN ULONG ReplyIndex,
    IN PUCHAR Message,
    IN ULONG MessageSize
    );

void WmipClearObjectFromThreadList(
    PWMIGUIDOBJECT Object
    );

// enabdisa.c

#define WmipIsControlGuid(GuidEntry) WmipIsISFlagsSet(GuidEntry, (IS_TRACED | IS_CONTROL_GUID))

#define WmipIsTraceGuid(GuidEntry)  WmipIsISFlagsSet(GuidEntry, IS_TRACED)

BOOLEAN
WmipIsISFlagsSet(
    PBGUIDENTRY GuidEntry,
    ULONG Flags
    );

NTSTATUS WmipDisableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    ULONG64 LoggerContext
    );

NTSTATUS WmipEnableCollectOrEvent(
    PBGUIDENTRY GuidEntry,
    ULONG Ioctl,
    BOOLEAN *RequestSent,
    ULONG64 LoggerContext
    );

NTSTATUS WmipEnableDisableTrace(
    ULONG Ioctl,
    PWMITRACEENABLEDISABLEINFO TraceEnableInfo
    );

NTSTATUS WmipDeliverWnodeToDS(
    CHAR ActionCode,
    PBDATASOURCE DataSource,
    PWNODE_HEADER Wnode,
    ULONG BufferSize
   );

ULONG WmipDoDisableRequest(
    PBGUIDENTRY GuidEntry,
    BOOLEAN IsEvent,
    BOOLEAN IsTraceLog,
    ULONG64 LoggerContext,
    ULONG InProgressFlag
    );

void WmipReleaseCollectionEnabled(
    PBGUIDENTRY GuidEntry
    );


NTSTATUS
WmipDisableTraceProviders (
    ULONG StopLoggerId
    );

// register.c

extern KSPIN_LOCK WmipRegistrationSpinLock;

extern LIST_ENTRY WmipInUseRegEntryHead;
extern LONG WmipInUseRegEntryCount;
extern KMUTEX WmipRegistrationMutex;

extern const GUID WmipDataProviderPnpidGuid;
extern const GUID WmipDataProviderPnPIdInstanceNamesGuid;

#if DBG
#define WmipReferenceRegEntry(RegEntry) { \
    InterlockedIncrement(&(RegEntry)->RefCount); \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, \
                      "WMI: Ref RegEntry %p -> 0x%x in %s line %d\n", \
                      (RegEntry), (RegEntry)->RefCount, __FILE__, __LINE__)); \
    }
#else
#define WmipReferenceRegEntry(RegEntry) InterlockedIncrement(&(RegEntry)->RefCount)
#endif

PREGENTRY WmipAllocRegEntry(
    PDEVICE_OBJECT DeviceObject,
    ULONG Flags
    );

void WmipTranslatePDOInstanceNames(
    IN OUT PIRP Irp,
    IN UCHAR MinorFunction,
    IN ULONG BufferSize,
    IN OUT PREGENTRY RegEntry
    );

void WmipInitializeRegistration(
    ULONG Phase
    );

NTSTATUS WmipRegisterDevice(
    PDEVICE_OBJECT DeviceObject,
    ULONG RegistrationFlag
    );

NTSTATUS WmipDeregisterDevice(
    PDEVICE_OBJECT DeviceObject
    );


NTSTATUS WmipUpdateRegistration(
    PDEVICE_OBJECT DeviceObject
    );

#if DBG
#define WmipUnreferenceRegEntry(RegEntry) { \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, \
                      "WMI: UnRef RegEntry %p -> 0x%x in %s line %d\n", \
                      (RegEntry), (RegEntry)->RefCount, __FILE__, __LINE__)); \
    WmipDoUnreferenceRegEntry(RegEntry); \
    }
#else
#define WmipUnreferenceRegEntry WmipDoUnreferenceRegEntry
#endif

BOOLEAN WmipDoUnreferenceRegEntry(
    PREGENTRY RegEntry
    );

PREGENTRY WmipFindRegEntryByDevice(
    PDEVICE_OBJECT DeviceObject,
    BOOLEAN ReferenceIrp
    );

PREGENTRY WmipDoFindRegEntryByDevice(
    PDEVICE_OBJECT DeviceObject,
    ULONG InvalidFlags
    );

#if defined(_WIN64)
PREGENTRY WmipDoFindRegEntryByProviderId(
    ULONG ProviderId,
    ULONG InvalidFlags
    );

PREGENTRY WmipFindRegEntryByProviderId(
    ULONG ProviderId,
    BOOLEAN ReferenceIrp
    );
#else
#define WmipFindRegEntryByProviderId(ProviderId, ReferenceIrp) \
        WmipFindRegEntryByDevice( (PDEVICE_OBJECT)(ProviderId) , (ReferenceIrp) )

#define WmipDeviceObjectToProviderId(DeviceObject) ((ULONG)(DeviceObject))
#define WmipDoFindRegEntryByProviderId(ProviderId, InvalidFlags) \
        WmipDoFindRegEntryByDevice((PDEVICE_OBJECT)(ProviderId), InvalidFlags)
#endif


void WmipDecrementIrpCount(
    IN PREGENTRY RegEntry
    );

NTSTATUS WmipPDOToDeviceInstanceName(
    IN PDEVICE_OBJECT PDO,
    OUT PUNICODE_STRING DeviceInstanceName
    );

NTSTATUS WmipValidateWmiRegInfoString(
    PWMIREGINFO WmiRegInfo,
    ULONG BufferSize,
    ULONG Offset,
    PWCHAR *String
);

NTSTATUS WmipProcessWmiRegInfo(
    IN PREGENTRY RegEntry,
    IN PWMIREGINFO WmiRegInfo,
    IN ULONG BufferSize,
    IN PWMIGUIDOBJECT RequestObject,
    IN BOOLEAN Update,
    IN BOOLEAN IsUserMode
    );

//
// from notify.c

extern WORK_QUEUE_ITEM WmipEventWorkQueueItem;
extern LIST_ENTRY WmipNPEvent;
extern KSPIN_LOCK WmipNPNotificationSpinlock;
extern LONG WmipEventWorkItems;
extern ULONG WmipNSAllocCount, WmipNSAllocMax;

#if DBG
extern ULONG WmipNPAllocFail;
#endif

void WmipInitializeNotifications(
    void
    );

void WmipEventNotification(
    PVOID Context
    );

BOOLEAN WmipIsValidRegEntry(
    PREGENTRY CheckRegEntry
);

//
// from wmi.c

extern ULONG WmipMaxKmWnodeEventSize;

extern UNICODE_STRING WmipRegistryPath;

NTSTATUS
WmipDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

void WmipUpdateDeviceStackSize(
    CCHAR NewStackSize
    );

NTSTATUS WmipForwardWmiIrp(
    PIRP Irp,
    UCHAR MinorFunction,
    ULONG ProviderId,
    PVOID DataPath,
    ULONG BufferLength,
    PVOID Buffer
    );

NTSTATUS WmipSendWmiIrp(
    UCHAR MinorFunction,
    ULONG ProviderId,
    PVOID DataPath,
    ULONG BufferLength,
    PVOID Buffer,
    PIO_STATUS_BLOCK Iosb
    );

NTSTATUS WmipGetDevicePDO(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *PDO
    );

NTSTATUS WmipProbeWmiOpenGuidBlock(                         
    POBJECT_ATTRIBUTES CapturedObjectAttributes,
    PUNICODE_STRING CapturedGuidString,
    PWCHAR CapturedGuidBuffer,
    PULONG DesiredAccess,
    PWMIOPENGUIDBLOCK InBlock,
    ULONG InBufferLen,
    ULONG OutBufferLen
    );

NTSTATUS WmipProbeAndCaptureGuidObjectAttributes(
    POBJECT_ATTRIBUTES CapturedObjectAttributes,
    PUNICODE_STRING CapturedGuidString,
    PWCHAR CapturedGuidBuffer,
    POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSTATUS WmipTranslateFileHandle(
    IN OUT PWMIFHTOINSTANCENAME FhToInstanceName,
    IN OUT PULONG OutBufferLen,
    IN HANDLE FileHandle,
    IN PDEVICE_OBJECT DeviceObject,
    IN PWMIGUIDOBJECT GuidObject,
    OUT PUNICODE_STRING InstanceNameString
    );

//
// from smbios.c
BOOLEAN WmipFindSMBiosTable(
    PPHYSICAL_ADDRESS SMBiosTablePhysicalAddress,
    PUCHAR *SMBiosTableVirtualAddress,
    PULONG SMBiosTableLength,
    PSMBIOSVERSIONINFO SMBiosVersionInfo
    );

NTSTATUS WmipGetSMBiosTableData(
    PUCHAR Buffer,
    PULONG BufferSize,
    OUT PSMBIOSVERSIONINFO SMBiosVersionInfo
    );

NTSTATUS
WmipDockUndockEventCallback(
    IN PVOID NoificationStructure,
    IN PVOID Context
    );

NTSTATUS WmipGetSysIds(
    PSYSID_UUID *SysIdUuid,
    ULONG *SysIdUuidCount,
    PSYSID_1394 *SysId1394,
    ULONG *SysId1394Count
    );

NTSTATUS WmipGetSMBiosEventlog(
    PUCHAR Buffer,
    PULONG BufferSize
    );

void WmipGetSMBiosFromLoaderBlock(
    PVOID LoaderBlockPtr
    );

extern PHYSICAL_ADDRESS WmipSMBiosTablePhysicalAddress;
extern PUCHAR WmipSMBiosTableVirtualAddress;
extern ULONG WmipSMBiosTableLength;

//
// from dataprov.c
extern const WMILIB_INFO WmipWmiLibInfo;

// from secure.c

#ifndef MEMPHIS

extern POBJECT_TYPE WmipGuidObjectType;

NTSTATUS WmipCreateAdminSD(
    PSECURITY_DESCRIPTOR *Sd
    );

NTSTATUS WmipInitializeSecurity(
    void
    );

NTSTATUS WmipOpenGuidObject(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE AccessMode,
    OUT PHANDLE Handle,
    OUT PWMIGUIDOBJECT *ObjectPtr
    );

NTSTATUS
WmipCheckGuidAccess(
    IN LPGUID Guid,
    IN ACCESS_MASK DesiredAccess,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
WmipGetGuidSecurityDescriptor(
    IN PUNICODE_STRING GuidName,
    IN PSECURITY_DESCRIPTOR *SecurityDescriptor,
    IN PSECURITY_DESCRIPTOR UserDefaultSecurity
    );

// from mca.c
extern ULONG WmipCpePollInterval;

NTSTATUS WmipRegisterMcaHandler(
    ULONG Phase
    );

NTSTATUS WmipGetRawMCAInfo(
    OUT PUCHAR Buffer,
    IN OUT PULONG BufferSize
    );

void WmipGenerateMCAEventlog(
    PUCHAR ErrorLog,
    ULONG ErrorLogSize,
    BOOLEAN IsFatal
    );


#ifdef CPE_CONTROL
NTSTATUS WmipSetCPEPolling(
    IN BOOLEAN Enabled,
    IN ULONG Interval
    );
#endif


//
// From tracelog
//
typedef struct _tagWMI_Event {
    WNODE_HEADER Wnode;
    NTSTATUS     Status;
    ULONG        TraceErrorFlag;
}  WMI_TRACE_EVENT, *PWMI_TRACE_EVENT;

// From Traceapi.c, the Ioctl interface to TraceMessage

NTSTATUS
FASTCALL
WmiTraceUserMessage(
    IN PMESSAGE_TRACE_USER pMessage,
    IN ULONG               MessageSize
    );



#endif

#endif // _WMIKMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\kdexts\tracing\kdextsin.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    kdExtsIn.c

Abstract:

    This strange little file is used to include the actual (shared) source file.
    In the future, the standard KD Extension procedures should be made available
    as "inline" procedures defined in wdbgexts.h.

Author:

    Glenn R. Peterson (glennp)  2000 Apr 05

Environment:

    User Mode

--*/

#define KDEXT_64BIT
#define KDEXTS_EXTERN

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>

#undef  KDEXTS_EXTERN

#include <ntverp.h>

#include <kdexts.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\kdexts\tracing\kdexts.h ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    kdexts.h

Abstract:

    This header file contains declarations for the generic routines and initialization code
    
Author:

    Glenn Peterson (glennp) 27-Mar-2000:

Environment:

    User Mode

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>

//
// globals
//
#ifndef KDEXTS_EXTERN
#define KDEXTS_EXTERN extern
#endif

KDEXTS_EXTERN WINDBG_EXTENSION_APIS   ExtensionApis;

KDEXTS_EXTERN DBGKD_GET_VERSION64     KernelVersionPacket;


BOOL
HaveDebuggerData(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\wmiumds.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    wmikmp.h

Abstract:

    Private header for WMI kernel mode component

Author:

    AlanWar

Environment:

Revision History:


--*/

#ifndef _WMIUMDS_
#define _WMIUMDS_

//
// Define this to track reference counts
//#define TRACK_REFERNECES

#include <wchar.h>

extern const GUID WmipBinaryMofGuid;
extern const GUID RegChangeNotificationGuid;

//
// Chunk Management definitions
// All structures that rely upon the chunk allocator must be defined so that
// their members match that of ENTRYHEADER. These include DATASOURCE,
// GUIDENTRY, INSTANCESET, DCENTRY, NOTIFICATIONENTRY, MOFCLASS, MOFRESOURCE
// Also ENTRYHEADER reserves 0x80000000 for its own flag.

struct _CHUNKINFO;
struct _ENTRYHEADER;

typedef void (*ENTRYCLEANUP)(
    struct _CHUNKINFO *,
    struct _ENTRYHEADER *
    );

typedef struct _CHUNKINFO
{
    LIST_ENTRY ChunkHead;        // Head of list of chunks
    ULONG EntrySize;            // Size of a single entry
    ULONG EntriesPerChunk;        // Number of entries per chunk allocation
    ENTRYCLEANUP EntryCleanup;   // Entry cleanup routine
    ULONG InitialFlags;         // Initial flags for all entries
    ULONG Signature;
#if DBG
    LONG AllocCount;
    LONG FreeCount;
#endif
} CHUNKINFO, *PCHUNKINFO;

typedef struct
{
    LIST_ENTRY ChunkList;        // Node in list of chunks
    LIST_ENTRY FreeEntryHead;    // Head of list of free entries in chunk
    ULONG EntriesInUse;            // Count of entries being used
} CHUNKHEADER, *PCHUNKHEADER;

typedef struct _ENTRYHEADER
{
    union
    {
        LIST_ENTRY FreeEntryList;    // Node in list of free entries
        LIST_ENTRY InUseEntryList;   // Node in list ofin use entries
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;                // Flags
    LONG RefCount;                 // Reference Count
    ULONG Signature;
} ENTRYHEADER, *PENTRYHEADER;

                                // Set if the entry is free
#define FLAG_ENTRY_ON_FREE_LIST       0x80000000
#define FLAG_ENTRY_ON_INUSE_LIST      0x40000000
#define FLAG_ENTRY_INVALID            0x20000000
#define FLAG_ENTRY_REMOVE_LIST        0x10000000


#define WmipReferenceEntry(Entry) \
    InterlockedIncrement(&((PENTRYHEADER)(Entry))->RefCount)

// chunk.c
ULONG WmipUnreferenceEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry);

PENTRYHEADER WmipAllocEntry(
    PCHUNKINFO ChunkInfo
    );

void WmipFreeEntry(
    PCHUNKINFO ChunkInfo,
    PENTRYHEADER Entry
    );

PWCHAR WmipCountedToSz(
    PWCHAR Counted
    );

struct tagGUIDENTRY;
typedef struct tagGUIDENTRY GUIDENTRY, *PGUIDENTRY, *PBGUIDENTRY;



//
// An INSTANCESET contains the information a set of instances that is provided
// by a single data source. An instance set is part of two lists. One list is
// the set of instance sets for a particular guid. The other list is the list
// of instance sets supported by a data source.
//

//
// Instance names for an instance set registered with a base name and count
// are stored in a ISBASENAME structure. This structure is tracked by
// PDFISBASENAME in wmicore.idl.
typedef struct
{
    ULONG BaseIndex;            // First index to append to base name
    WCHAR BaseName[1];            // Actual base name
} ISBASENAME, *PISBASENAME, *PBISBASENAME;

//
// This defines the maximum number of characters that can be part of a suffix
// to a basename. The current value of 6 will allow up to 999999 instances
// of a guid with a static base name
#define MAXBASENAMESUFFIXSIZE    6
#define MAXBASENAMESUFFIXVALUE   999999
#define BASENAMEFORMATSTRING     L"%d"

//
// Instance names for an instance set registerd with a set of static names
// are kept in a ISSTATICNAMES structure. This structure is tracked by
// PDFISSTATICNAMES defined in wmicore.idl
typedef struct
{
    PWCHAR StaticNamePtr[1];     // pointers to static names
//    WCHAR StaticNames[1];
} ISSTATICENAMES, *PISSTATICNAMES, *PBISSTATICNAMES;

typedef struct tagInstanceSet
{
    union
    {
        // Entry in list of instances within a guid
        LIST_ENTRY GuidISList;

        // Entry in main list of free instances
        LIST_ENTRY FreeISList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    // Reference count of number of guids using this instance set
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    // Entry in list of instances within a data source
    LIST_ENTRY DSISList;

    // Back link to guid that this instance set is a member
    PBGUIDENTRY GuidEntry;

    // Back link to data source that this instance set is a member
    struct tagDATASOURCE *DataSource;

    // Count of instances in instance set
    ULONG Count;

    // Size needed to place all instance names in a WNODE_ALL_DATA
    ULONG WADInstanceNameSize;

    // ProviderId for the DS associated with this IS
    ULONG ProviderId;

    //
    // If IS_INSTANCE_BASENAME is set then IsBaseName pointe at instance base
    // name structure. Else if IS_INSTANCE_STATICNAME is set then
    // IsStaticNames points to static instance name list. If
    union
    {
        PBISBASENAME IsBaseName;
        PBISSTATICNAMES IsStaticNames;
    };

} INSTANCESET, *PINSTANCESET, *PBINSTANCESET;

#define IS_SIGNATURE 'SImW'

//
// Guid Map Entry List maintains the list of Guid and their maps.
// Only those Guids that are Unregistered while a logger session is in
// progress is kept in this list.
// It is also used as a placeholder for InstanceIds. Trace Guid Registration
// calls return a handle to a GUIDMAPENTRY which maintains the map and the
// Instance Ids.
//

typedef struct tagTRACE_REG_INFO
{
    ULONG       RegistrationCookie;
    HANDLE      InProgressEvent; // Registration is in Progress Event
    BOOLEAN     EnabledState;    // Indicates if this GUID is Enabled or not.
    PVOID       NotifyRoutine;
    PVOID       TraceCtxHandle;
} TRACE_REG_INFO, *PTRACE_REG_INFO;

typedef struct
{
    LIST_ENTRY      Entry;
    TRACEGUIDMAP    GuidMap;
    ULONG           InstanceId;
    ULONG64         LoggerContext;
    PTRACE_REG_INFO pControlGuidData;
} GUIDMAPENTRY, *PGUIDMAPENTRY;


//
// These flags are also by the WMIINSTANCEINFO structure in wmicore.idl
#define IS_INSTANCE_BASENAME        0x00000001
#define IS_INSTANCE_STATICNAMES     0x00000002
#define IS_EXPENSIVE                0x00000004    // set if collection must be enabled
#define IS_COLLECTING               0x00000008    // set when collecting

#define IS_KM_PROVIDER              0x00000080    // KM data provider
#define IS_SM_PROVIDER              0x00000100    // Shared memory provider
#define IS_UM_PROVIDER              0x00000200    // User mode provider
#define IS_NEWLY_REGISTERED         0x00000800    // set if IS is registering

//
// Any traced guids are used for trace logging and not querying
#define IS_TRACED                   0x00001000

// Set when events are enabled for instance set
#define IS_ENABLE_EVENT             0x00002000

// Set when events are enabled for instance set
#define IS_ENABLE_COLLECTION        0x00004000

// Set if guid is used only for firing events and not querying
#define IS_EVENT_ONLY               0x00008000

// Set if data provider for instance set is expecting ansi instsance names
#define IS_ANSI_INSTANCENAMES       0x00010000

// Set if instance names are originated from a PDO
#define IS_PDO_INSTANCENAME         0x00020000

// Set if a Traced Guid is also a Trace Control Guid
#define IS_CONTROL_GUID             0x00080000

#define IS_ON_FREE_LIST             0x80000000

typedef struct tagGUIDENTRY
{
    union
    {
        // Entry in list of all guids registered with WMI
        LIST_ENTRY MainGEList;

        // Entry in list of free guid entry blocks
        LIST_ENTRY FreeGEList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    // Count of number of data sources using this guid
    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    // Head of list of open objects to this guid
    LIST_ENTRY ObjectHead;

    // Count of InstanceSets headed by this guid
    ULONG ISCount;

    // Head of list of all instances for guid
    LIST_ENTRY ISHead;

    // Guid that represents data block
    GUID Guid;

    ULONG EventRefCount;                // Global count of event enables
    ULONG CollectRefCount;              // Global count of collection enables

    ULONG64 LoggerContext;              // Logger context handle

    PWMI_LOGGER_INFORMATION LoggerInfo; // LoggerInfo. Used in case of Ntdll tracing

    PKEVENT CollectInProgress;          // Event set when all collect complete

} GUIDENTRY, *PGUIDENTRY, *PBGUIDENTRY;

#define GE_SIGNATURE 'EGmW'

#define GE_ON_FREE_LIST        0x80000000

//
// When set this guid is an internally defined guid that has no data source
// attached to it.
#define GE_FLAG_INTERNAL    0x00000001

// Set when a notification request is being processed by the data providers
#define GE_FLAG_NOTIFICATION_IN_PROGRESS 0x00000002

// Set when a collection request is being processed by the data providers
#define GE_FLAG_COLLECTION_IN_PROGRESS 0x00000004

// Set when a trace disable is being processed by a worker thread
#define GE_FLAG_TRACEDISABLE_IN_PROGRESS 0x00000008

// Set when there is a wait in progress for collect/event enable/disable
#define GE_FLAG_WAIT_ENABLED 0x00000010

// Set when the guid has had an enable collection sent to it
#define GE_FLAG_COLLECTION_ENABLED 0x00000020

// Set when the guid has had an enable notifications sent to it
#define GE_FLAG_NOTIFICATIONS_ENABLED 0x00000040

#define GE_NOTIFICATION_TRACE_FLAG 0x00000080

// Set when an enabled guid receives another enable notification
#define GE_NOTIFICATION_TRACE_UPDATE 0x00000100

typedef struct
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainMRList;

        // Entry in list of free DS
        LIST_ENTRY FreeMRList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    // Signature to identify entry
    ULONG Signature;

    PWCHAR RegistryPath;           // Path to image file with resource
    PWCHAR MofResourceName;        // Name of resource containing mof data
} MOFRESOURCE, *PMOFRESOURCE;

#define MR_SIGNATURE 'RMmW'

//
// This is a user mode resource so the RegistryPath is really an image path
#define MR_FLAG_USER_MODE  0x00000001

#if DBG
#define AVGMOFRESOURCECOUNT 1
#else
#define AVGMOFRESOURCECOUNT 4
#endif
struct _WMIGUIDOBJECT;

typedef struct tagDATASOURCE
{
    union
    {
        // Entry in list of all DS
        LIST_ENTRY MainDSList;

        // Entry in list of free DS
        LIST_ENTRY FreeDSList;
    };
    PCHUNKHEADER Chunk;            // Chunk in which entry is located
    ULONG Flags;

    ULONG RefCount;

    ULONG Signature;

    // Head of list of instances for this DS
    LIST_ENTRY ISHead;

    // Provider id of kernel mode driver
    ULONG ProviderId;

    // Path to registry holding ACLs
    PTCHAR RegistryPath;

    // Head of list of MofResources attached to data source
    ULONG MofResourceCount;
    PMOFRESOURCE *MofResources;
    PMOFRESOURCE StaticMofResources[AVGMOFRESOURCECOUNT];
    
    // Guid object if this is a UM provider
    struct _WMIGUIDOBJECT *RequestObject;
};

#define DS_SIGNATURE 'SDmW'

#define VERIFY_DPCTXHANDLE(DsCtxHandle) \
    ( ((DsCtxHandle) == NULL) || \
      (((PBDATASOURCE)(DsCtxHandle))->Signature == DS_SIGNATURE) )
    
typedef struct tagDATASOURCE DATASOURCE, *PDATASOURCE, *PBDATASOURCE;

#define DS_ALLOW_ALL_ACCESS    0x00000001
#define DS_KERNEL_MODE         0x00000002

#define DS_USER_MODE           0x00000008

#define DS_ON_FREE_LIST        0x80000000

//
// AVGGUIDSPERDS defines a guess as to the number of guids that get registered
// by any data provider. It is used to allocate the buffer used to deliver
// registration change notifications.
#if DBG
#define AVGGUIDSPERDS    2
#else
#define AVGGUIDSPERDS    256
#endif

//
// Guid and InstanceSet cache
#if DBG
#define PTRCACHEGROWSIZE 2
#else
#define PTRCACHEGROWSIZE 64
#endif

typedef struct
{
    LPGUID Guid;
    PBINSTANCESET InstanceSet;
} PTRCACHE;

typedef struct
{
    ULONG ProviderId;
    ULONG Flags;
    ULONG InstanceCount;
    ULONG InstanceNameSize;
    PWCHAR **StaticNamePtr;
    ULONG BaseIndex;
    PWCHAR BaseName;
}    WMIINSTANCEINFO, *PWMIINSTANCEINFO;


// TODO: Since these were copied from wmium.h, we actually need to mov
//       them someplace else so they aren't copied

//extern GUID GUID_REGISTRATION_CHANGE_NOTIFICATION;
//extern GUID_MOF_RESOURCE_ADDED_NOTIFICATION;
//extern GUID_MOF_RESOURCE_REMOVED_NOTIFICATION;

//
// Location of built in MOF for the system
//
#define WMICOREIMAGEPATH L"advapi32.dll"
#define WMICORERESOURCENAME L"MofResourceName"


void WmipGenerateBinaryMofNotification(
    PBINSTANCESET BinaryMofInstanceSet,
    LPCGUID Guid        
    );

void WmipGenerateMofResourceNotification(
    LPWSTR ImagePath,
    LPWSTR ResourceName,
    LPCGUID Guid,
    ULONG ActionCode
    );

//
// alloc.c


extern LIST_ENTRY WmipGEHead;
extern PLIST_ENTRY WmipGEHeadPtr;
extern CHUNKINFO WmipGEChunkInfo;

extern LIST_ENTRY WmipDSHead;
extern PLIST_ENTRY WmipDSHeadPtr;
extern CHUNKINFO WmipDSChunkInfo;

extern LIST_ENTRY WmipMRHead;
extern PLIST_ENTRY WmipMRHeadPtr;
extern CHUNKINFO WmipMRChunkInfo;

extern CHUNKINFO WmipISChunkInfo;

extern LIST_ENTRY WmipGMHead;
extern PLIST_ENTRY WmipGMHeadPtr;

#ifdef TRACK_REFERNECES
#define WmipUnreferenceDS(DataSource) \
{ \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Unref DS %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), DataSource, DataSource->RefCount, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&WmipDSChunkInfo, (PENTRYHEADER)DataSource); \
}

#define WmipReferenceDS(DataSource) \
{ \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Ref DS %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), DataSource, DataSource->RefCount, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)DataSource); \
}

#define WmipUnreferenceGE(GuidEntry) \
{ \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Unref GE %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), GuidEntry, GuidEntry->RefCount, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&WmipGEChunkInfo, (PENTRYHEADER)GuidEntry); \
}

#define WmipReferenceGE(GuidEntry) \
{ \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Ref GE %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), GuidEntry, GuidEntry->RefCount, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)GuidEntry); \
}

#define WmipUnreferenceIS(InstanceSet) \
{ \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Unref IS %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), InstanceSet, InstanceSet->RefCount, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&WmipISChunkInfo, (PENTRYHEADER)InstanceSet); \
}

#define WmipReferenceIS(InstanceSet) \
{ \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Ref IS %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), InstanceSet, InstanceSet->RefCount, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)InstanceSet); \
}

#define WmipUnreferenceMR(MofResource) \
{ \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Unref MR %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), MofResource, MofResource->RefCount, __FILE__, __LINE__)); \
    WmipUnreferenceEntry(&WmipMRChunkInfo, (PENTRYHEADER)MofResource); \
}

#define WmipReferenceMR(MofResource) \
{ \
    WmipDebugPrintEx((DPFLTR_WMICORE_ID, DPFLTR_INFO_LEVEL, "WMI: %p.%p Ref MR %p (%x) at %s %d\n", PsGetCurrentProcessId(), PsGetCurrentThreadId(), MofResource, MofResource->RefCount, __FILE__, __LINE__)); \
    WmipReferenceEntry((PENTRYHEADER)MofResource); \
}

#else
#define WmipUnreferenceDS(DataSource) \
    WmipUnreferenceEntry(&WmipDSChunkInfo, (PENTRYHEADER)DataSource)

#define WmipReferenceDS(DataSource) \
    WmipReferenceEntry((PENTRYHEADER)DataSource)

#define WmipUnreferenceGE(GuidEntry) \
    WmipUnreferenceEntry(&WmipGEChunkInfo, (PENTRYHEADER)GuidEntry)

#define WmipReferenceGE(GuidEntry) \
    WmipReferenceEntry((PENTRYHEADER)GuidEntry)

#define WmipUnreferenceIS(InstanceSet) \
    WmipUnreferenceEntry(&WmipISChunkInfo, (PENTRYHEADER)InstanceSet)

#define WmipReferenceIS(InstanceSet) \
    WmipReferenceEntry((PENTRYHEADER)InstanceSet)

#define WmipUnreferenceDC(DataConsumer) \
    WmipUnreferenceEntry(&WmipDCChunkInfo, (PENTRYHEADER)DataConsumer)

#define WmipReferenceDC(DataConsumer) \
    WmipReferenceEntry((PENTRYHEADER)DataConsumer)

#define WmipUnreferenceMR(MofResource) \
    WmipUnreferenceEntry(&WmipMRChunkInfo, (PENTRYHEADER)MofResource)

#define WmipReferenceMR(MofResource) \
    WmipReferenceEntry((PENTRYHEADER)MofResource)

#endif

PBDATASOURCE WmipAllocDataSource(
    void
    );

PBGUIDENTRY WmipAllocGuidEntryX(
    ULONG Line,
    PCHAR File
    );

#define WmipAllocGuidEntry() WmipAllocGuidEntryX(__LINE__, __FILE__)

#define WmipAllocInstanceSet() ((PBINSTANCESET)WmipAllocEntry(&WmipISChunkInfo))

#define WmipAllocMofResource() ((PMOFRESOURCE)WmipAllocEntry(&WmipMRChunkInfo))

#define WmipAllocString(Size) \
    WmipAlloc((Size)*sizeof(WCHAR))

#define WmipFreeString(Ptr) \
    WmipFree(Ptr)

BOOLEAN WmipIsNumber(
    LPCWSTR String
    );
        
#ifdef HEAPVALIDATION
PVOID WmipAlloc(
    ULONG Size
    );

PVOID WmipAllocWithTag(
    ULONG Size,
    ULONG Tag
    );

void WmipFree(
    PVOID p
    );

#else

#define WmipAlloc(Size) \
    ExAllocatePoolWithTag(PagedPool, Size, 'pimW')

#define WmipAllocWithTag(Size, Tag) \
    ExAllocatePoolWithTag(PagedPool, Size, Tag)

#define WmipFree(Ptr) \
    ExFreePool(Ptr)

#endif

#define WmipAllocNP(Size) \
    ExAllocatePoolWithTag(NonPagedPool, Size, 'pimW')

#define WmipAllocNPWithTag(Size, Tag) \
    ExAllocatePoolWithTag(NonPagedPool, Size, Tag)


BOOLEAN WmipRealloc(
    PVOID *Buffer,
    ULONG CurrentSize,
    ULONG NewSize,
    BOOLEAN FreeOriginalBuffer
    );

PBGUIDENTRY WmipFindGEByGuid(
    LPGUID Guid,
    BOOLEAN MakeTopOfList
    );

PBDATASOURCE WmipFindDSByProviderId(
    ULONG_PTR ProviderId
    );

PBINSTANCESET WmipFindISByGuid(
    PBDATASOURCE DataSource,
    GUID UNALIGNED *Guid
    );

PMOFRESOURCE WmipFindMRByNames(
    LPCWSTR ImagePath,
    LPCWSTR MofResourceName
    );

PBINSTANCESET WmipFindISinGEbyName(
    PBGUIDENTRY GuidEntry,
    PWCHAR InstanceName,
    PULONG InstanceIndex
    );

// TODO: Implement this
#define WmipReportEventLog(a,b,c,d,e,f,g)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\kdexts\tracing\wmitrace.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    wmiTrace.h

Abstract:

    WMI-based TRACEing kd extension header file

Author:

    Glenn R. Peterson (glennp) 2000 Apr 27

Revision History:

--*/

#ifndef _WMITRACE_H
#define _WMITRACE_H

#include "dbgeng.h"
//
//  Data Structures
//
typedef struct sttWmiTracingKdSortEntry
{
    ULONGLONG   Address;
    union {
        LARGE_INTEGER   Key;
        ULONGLONG       Keyll;  // Sort Key 2
    };
    ULONG       SequenceNo;     // Sort Key 1
    ULONG       Ordinal;        // Sort Key 3
    ULONG       Offset;
    ULONG       Length;
    WMI_HEADER_TYPE HeaderType;
    WMI_BUFFER_SOURCE BufferSource;
    USHORT      CpuNo;
}  WMITRACING_KD_SORTENTRY,  *PWMITRACING_KD_SORTENTRY;


//
//  Procedure Parameters
//
typedef ULONGLONG (__cdecl *WMITRACING_KD_FILTER) (
    PVOID               UserContext,
    const PEVENT_TRACE  pstHeader
    );

typedef int       (__cdecl *WMITRACING_KD_COMPARE) (
    const WMITRACING_KD_SORTENTRY  *SortElement1,
    const WMITRACING_KD_SORTENTRY  *SortElement2
    );

typedef void      (__cdecl *WMITRACING_KD_OUTPUT) (
    PVOID                           UserContext,
    PLIST_ENTRY                     GuidListHeadPtr,
    const WMITRACING_KD_SORTENTRY  *SortInfo,
    const PEVENT_TRACE              pstEvent
    );

//
//  Procedures
//


VOID
wmiTraceDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    );

VOID
wmiLogDump(
    ULONG                   LoggerId,
    PVOID                   UserContext,
    PLIST_ENTRY             GuidListHeadPtr,
    WMITRACING_KD_FILTER    Filter,
    WMITRACING_KD_COMPARE   Compare,
    WMITRACING_KD_OUTPUT    Output
    );

ULONG
WmiFormatTraceData(
    PDEBUG_CONTROL     Ctrl,
    ULONG     Mask,
    ULONG     DataLen, 
    PVOID     Data
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\kdexts\tracing\wmitrace.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       wmiTrace.c
//
//  Contents:   windbg extension to dump WMI Trace Buffers
//
//  Classes:
//
//  Functions:  help        Standard KD Extension Function
//              strdump     Dump the Logger Structure
//              logdump     Dump the in-memory part of the TraceBuffers
//              logsave     Save the in-memory part of the TraceBuffers
//                          to a file.
//              wmiLogDump  Callable procedure used when caller wishes
//                          to replace the filter, sort, or output routines
//
//  Coupling:
//
//  Notes:
//
//  History:    04-27-2000   glennp Created
//              07-17-2000   glennp Added support for Stephen Hsiao's
//                                  Non-Blocking Buffers.
//              12-13-2000   glennp Changed from typedefs to struct tags
//                                  per change in compiler behavior.
//
//----------------------------------------------------------------------------


#include "kdExts.h"
#define _WMI_SOURCE_
#include <wmium.h>
#include <ntwmi.h>
#include <evntrace.h>
#include <wmiumkm.h>

#include <traceprt.h>

#include <tchar.h>

#include "wmiTrace.h"

#pragma hdrstop

typedef ULONG64 TARGET_ADDRESS;

typedef VOID (*WMITRACING_KD_LISTENTRY_PROC)
    ( PVOID             Context
    , TARGET_ADDRESS    Buffer
    , ULONG             Length
    , ULONG             CpuNo
    , ULONG             Align
    , WMI_BUFFER_SOURCE Source
    );

typedef struct _WMITRACING_BUFFER_SOURCES {
    ULONG   FreeBuffers:1;
    ULONG   FlushBuffers:1;
    ULONG   ActiveBuffers:1;
    ULONG   TransitionBuffer:1;

    ULONG   PrintInformation:1;
    ULONG   PrintProgressIndicator:1;
} WMITRACING_BUFFER_SOURCES;

struct sttSortControl
{
    ULONG   MaxEntries;
    ULONG   CurEntries;
    WMITRACING_KD_SORTENTRY *pstSortEntries;
};
    
struct sttTraceContext
{
    struct sttSortControl  *pstSortControl;
    PVOID                   UserContext;
    ULONG                   BufferSize;
    ULONG                   Ordinal;
    WMITRACING_KD_FILTER    Filter;
};
    
struct sttSaveContext
{
    FILE    *pfSaveFile;
};

extern DBGKD_GET_VERSION64  KernelVersionData;

TARGET_ADDRESS TransitionBuffer;

//Global guid filename
//LPSTR    g_pszGuidFileName = "default.tmf";
CHAR g_pszGuidFileName[MAX_PATH] = "default.tmf";

//Global guid list head pointer
PLIST_ENTRY g_GuidListHeadPtr = NULL;

//Global value to determine if dynamic printing is on or off
ULONG    g_ulPrintDynamicMessages = 1;

//Global handle to TracePrt.dll module
HMODULE g_hmTracePrtHandle = NULL;

//Global handle to WmiTrace.dll modlue
HMODULE g_hmWmiTraceHandle = NULL;

//Global proc address of TracePrt's FormatTraceEvent function
FARPROC g_fpFormatTraceEvent = NULL;

//Global proc address of TracePrt's SetTraceFormatParameter function
FARPROC g_fpSetTraceFormatParameter = NULL;

//Global proc address of TracePrt's GetTraceFormatParameter function
FARPROC g_fpGetTraceFormatSearchPath = NULL;

//Global proc address of TracePrt's GetTraceGuids function
FARPROC g_fpGetTraceGuids = NULL;

//Global proc address of TracePrt's CleanupTraceEventList function
FARPROC g_fpCleanupTraceEventList = NULL;

//Prototype for private function to get handle to TracePrt DLL
HMODULE getTracePrtHandle();

//Prototype for private function to get the address of a function in the TracePrt DLL
FARPROC GetAddr(LPCSTR lpProcName);

NTSTATUS
EtwpDeinitializeDll ();

NTSTATUS
EtwpInitializeDll ();


#ifdef UNICODE
#define FormatTraceEventString               "FormatTraceEventW"
#define GetTraceGuidsString                      "GetTraceGuidsW"
#else
#define FormatTraceEventString               "FormatTraceEventA"
#define GetTraceGuidsString                      "GetTraceGuidsA"
#endif



//+---------------------------------------------------------------------------
//
//  Function:   void printUnicodeFromAddress
//
//  Synopsis:   Prints a UNICODE string given the address of the UNICODE_STRING
//
//  Arguments:  ul64Address The Address of the UNICODE_STRING structure
//
//  Returns:    <VOID>
//
//  History:    04-05-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void printUnicodeFromAddress (TARGET_ADDRESS ul64Address)
{
    TARGET_ADDRESS ul64TarBuffer;
    ULONG   bufferOffset;
    ULONG   lengthRead;
    ULONG   ulInfo;

    USHORT  usLength;
    PWCHAR  buffer;

    ul64TarBuffer = 0;
    bufferOffset = 0;
    usLength = 0;
    buffer = NULL;

    GetFieldOffset ("UNICODE_STRING", "Buffer", &bufferOffset);
    ReadPtr (ul64Address + bufferOffset, &ul64TarBuffer);
    GetFieldValue (ul64Address, "UNICODE_STRING", "Length", usLength);

    buffer = LocalAlloc (LPTR, usLength + sizeof (UNICODE_NULL));
    if (buffer == NULL) {
        dprintf ("<Failed to Allocate Unicode String Buffer>");
        return;
    }

    if (usLength > 0) {
        lengthRead = 0;
        ulInfo = ReadMemory (ul64TarBuffer, buffer, usLength, &lengthRead);
        if ((!ulInfo) || (lengthRead != usLength)) {
            dprintf ("<Failed to Read Entire Unicode String>");
        }
    }

    buffer [usLength / 2] = 0;
    dprintf ("%ws", buffer);

    LocalFree(buffer);

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   ULONG lengthUnicodeFromAddress
//
//  Synopsis:   Get the Length (in bytes) of a UNICODE_STRING (NULL not included)
//
//  Arguments:  ul64Address The Address of the UNICODE_STRING structure
//
//  Returns:    Length of String in Bytes
//
//  History:    03-27-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG lengthUnicodeFromAddress (TARGET_ADDRESS ul64Address)
{
    USHORT  usLength;

    usLength = 0;
    GetFieldValue (ul64Address, "UNICODE_STRING", "Length", usLength);

    return ((ULONG) (usLength));
}



//+---------------------------------------------------------------------------
//
//  Function:   void printUnicodeFromStruct
//
//  Synopsis:   Prints a UNICODE string from an element in a structure
//
//  Arguments:  Address     The Address of the structure containing the US
//              Type        The Type of the structure containing the US
//              Field       The name of the field in the structure
//                          This must be a UNICODE_STRING substructure
//
//  Returns:    <VOID>
//
//  History:    04-05-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void printUnicodeFromStruct (TARGET_ADDRESS Address, PCHAR Type, PCHAR Field)
{
    ULONG   ulUnicodeOffset;

    GetFieldOffset (Type, Field, &ulUnicodeOffset);
    printUnicodeFromAddress (Address + ulUnicodeOffset);

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   ULONG GetWmiTraceAlignment
//
//  Synopsis:   Determines the Alignment modulus for events on the target
//
//  Arguments:  <NONE>
//
//  Returns:    The Alignment (normally 8 bytes)
//
//  History:    04-05-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG GetWmiTraceAlignment (void)
{
    ULONG           ulInfo;
    ULONG           ulBytesRead;
    UCHAR           alignment;
    TARGET_ADDRESS  tarAddress;

    alignment = 8;  // Set Default

    tarAddress = GetExpression ("NT!WmiTraceAlignment");
    ulInfo = ReadMemory (tarAddress, &alignment, sizeof (UCHAR), &ulBytesRead);
    if ((!ulInfo) || (ulBytesRead != sizeof (UCHAR))) {
        dprintf ("Failed to Read Alignment.\n");
    }
    
    return ((ULONG) alignment);
}

//+---------------------------------------------------------------------------
//
//  Function:   TARGET_ADDRESS FindLoggerContextArray
//
//  Synopsis:   Determines the location and size of the LoggerContext Array
//
//  Arguments:  -> ElementCount The number of elements in the array put here
//
//  Returns:    Target Address of the LoggerContext Array
//
//  History:    04-05-2000   glennp Created
//
//  Notes:      Returns 0 on error
//
//----------------------------------------------------------------------------

TARGET_ADDRESS FindLoggerContextArray (PULONG  ElementCount)

{
    TARGET_ADDRESS address;
    ULONG   pointerSize;
    ULONG   arraySize;

    address = 0;
    pointerSize = GetTypeSize ("PVOID");
    if ((arraySize = GetTypeSize ("NT!WmipLoggerContext") / pointerSize) != 0) {
        // Post Windows 2000 Version
        address = GetExpression ("NT!WmipLoggerContext");
    } else {
        // Windows 2000 and Before
        ULONG   ulOffset;
        address = GetExpression ("NT!WmipServiceDeviceObject");
        ReadPtr (address, &address);
        GetFieldOffset ("DEVICE_OBJECT", "DeviceExtension", &ulOffset);
        ReadPtr (address + ulOffset, &address);
        GetFieldOffset ("WMISERVDEVEXT", "LoggerContextTable", &ulOffset);
// ulOffset = 0x50;
        address += ulOffset;
        arraySize = GetTypeSize ("WMISERVDEVEXT.LoggerContextTable") / pointerSize;
// arraySize = 32;
    }

    *ElementCount = arraySize;
    return (address);
}

//+---------------------------------------------------------------------------
//
//  Function:   TARGET_ADDRESS FindLoggerContext
//
//  Synopsis:   Finds the Address of a specific LoggerContext
//
//  Arguments:  ulLoggerId  Ordinal of the specific LoggerContext
//
//  Returns:    Target Address of the LoggerContext
//
//  History:    04-05-2000   glennp Created
//
//  Notes:      Returns 0 on error
//
//----------------------------------------------------------------------------

TARGET_ADDRESS FindLoggerContext (ULONG ulLoggerId)

{
    TARGET_ADDRESS tarAddress;
    ULONG   ulMaxLoggerId;

    tarAddress = FindLoggerContextArray (&ulMaxLoggerId);

    if (tarAddress == 0) {
        dprintf ("  Unable to Access Logger Context Array\n");
    } else {
        if (ulLoggerId >= ulMaxLoggerId) {
            dprintf ("    Logger Id TOO LARGE\n");
        } else {
//            tarAddress += GetTypeSize ("PWMI_LOGGER_CONTEXT") * ulLoggerId;   //BUGBUG
            tarAddress += GetTypeSize ("PVOID") * ulLoggerId;
            ReadPointer (tarAddress, &tarAddress);
            if (tarAddress == 0) {
                dprintf ("    LOGGER ID %2d NOT RUNNING PRESENTLY\n", ulLoggerId);
            }
        }
    }

    return (tarAddress);
}

//+---------------------------------------------------------------------------
//
//  Function:   wmiDefaultFilter
//
//  Synopsis:   Filter procedure for wmiTracing.  Returns Key
//
//  Arguments:  Context     Arbitrary context: not used
//              pstEvent    -> to EventTrace
//
//  Returns:    Key
//
//  History:    04-05-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONGLONG __cdecl wmiDefaultFilter (
    PVOID               Context,
    const PEVENT_TRACE  pstEvent
    )

{
    union {
        LARGE_INTEGER   TimeStamp;
        ULONGLONG       Key;
    } Union;

    Union.TimeStamp = pstEvent->Header.TimeStamp;
    if (Union.Key == 0)  Union.Key = 1;

    return (Union.Key);
}

//+---------------------------------------------------------------------------
//
//  Function:   wmiDefaultCompare
//
//  Synopsis:   Performs comparision of three keys
//
//  Arguments:  SortElement1    -> to "Left" sort element to compare
//              SortElement2    -> to "Right" sort element to compare
//
//  Returns:    -3,-2,-1, 0, +1,+2,+3 for LessThan, Equal, GreaterThan (Left X Right)
//
//  History:    04-05-2000   glennp Created
//
//  Notes:      The first key, "SequenceNo", is compared in a manor that allows
//              wrapping around the 32 bit limit.
//              The last key, "Ordinal", cannot have equal values and the code
//              takes advantage of that fact.  This implies that 0 can never be returned.
//
//----------------------------------------------------------------------------

int __cdecl wmiDefaultCompare (
    const WMITRACING_KD_SORTENTRY  *SortElementL,
    const WMITRACING_KD_SORTENTRY  *SortElementR
    )
                    
{
    int iResult;
    ULONG   SequenceNoL;
    ULONG   SequenceNoR;

    SequenceNoL = SortElementL->SequenceNo;
    SequenceNoR = SortElementR->SequenceNo;

    if (SequenceNoL == SequenceNoR) {
        if (SortElementL->Keyll == SortElementR->Keyll) {
            iResult = (SortElementL->Ordinal <  SortElementR->Ordinal) ? -1 : +1;
        } else {
            iResult = (SortElementL->Keyll <  SortElementR->Keyll)  ? -2 : +2;
        }
    } else {
        iResult = ((SequenceNoL - SequenceNoR) > 0x80000000) ? -3 : +3; // See Notes
    }

    return (iResult);
}

//+---------------------------------------------------------------------------
//
//  Function:   wmiDefaultOutput
//
//  Synopsis:   Output procedure for wmiTracing.  Performs simple dprintf
//
//  Arguments:  Context     Arbitrary context: point to head of MOF list
//              SortElement -> sort element describing this event.  Not used.
//              pstEvent    -> to EventTrace
//
//  Returns:    <void>
//
//  History:    04-05-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void __cdecl wmiDefaultOutput (
    PVOID                           UserContext,
    PLIST_ENTRY                     GuidListHeadPtr,
    const WMITRACING_KD_SORTENTRY  *SortEntry,
    const PEVENT_TRACE              pstHeader
    )

{
    WCHAR       wcaOutputLine[4096];

    wcaOutputLine[0] = 0;

    if(g_fpFormatTraceEvent == NULL) {
        g_fpFormatTraceEvent = GetAddr(FormatTraceEventString);
    }
    if(g_fpFormatTraceEvent != NULL) {    
        g_fpFormatTraceEvent (GuidListHeadPtr, (PEVENT_TRACE) pstHeader,
        (TCHAR *) wcaOutputLine, sizeof (wcaOutputLine),
        (TCHAR *) NULL);
    } else {
        return;
    }


    dprintf ("%s\n", wcaOutputLine);

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   wmiKdProcessLinkList
//
//  Synopsis:   Calls supplied Procedure for each element in a linked list
//
//  Arguments:  TarLinklistHeadAddress  Target Address of Linklist Head
//              Procedure               Procedure to call for each Buffer
//              Context                 Procedure Context (passthrough)
//              Length                  Size of the Buffer
//              Alignment               Entry alignment in bytes
//              Source                  Enum specifying type of buffer
//              Offset                  Offset of LL entry in Buffer
//              Print                   Flag passed to Procedure
//
//  Returns:    Count of Buffers Processed
//
//  History:    04-05-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG wmiKdProcessLinkList (
    TARGET_ADDRESS                  TarLinklistHeadAddress,
    WMITRACING_KD_LISTENTRY_PROC    Procedure,
    PVOID                           Context,
    ULONG                           Length,
    ULONG                           Alignment,
    WMI_BUFFER_SOURCE               Source,
    ULONG                           Offset,
    ULONG                           Print
    )

{
    ULONG                   ulBufferCount;
    TARGET_ADDRESS          tarLinklistEntryAddress;

    ulBufferCount = 0;
    tarLinklistEntryAddress = TarLinklistHeadAddress;

    while (ReadPtr (tarLinklistEntryAddress, &tarLinklistEntryAddress), // NOTE COMMA!
           tarLinklistEntryAddress != TarLinklistHeadAddress) {
        if (CheckControlC())  break;
        ++ulBufferCount;
        if (Print)  { dprintf ("%4d\b\b\b\b", ulBufferCount); }
        Procedure (Context, tarLinklistEntryAddress - Offset, Length, ~0, Alignment, Source);
    }

    return ulBufferCount;
}

//+---------------------------------------------------------------------------
//
//  Function:   VOID wmiDumpProc
//
//  Synopsis:   Procedure passed to wmiKdProcessBuffers() when dumping the
//                  Buffers to the screen.  Performs Buffer Header fixup and
//                  then records sort keys for those entries that are selected.
//
//  Arguments:  Context     -> to struct sttTraceContext.  Used for 'static' memory
//              Buffer      Target Address of WMI Event buffer to analyze
//              Length      Length of the buffer (previous parameter)
//              Alignment   Alignment used by WMI on target machine
//              Source      Enum of: free, flush, transition, current buffer source
//
//  Returns:    <VOID>
//
//  History:    04-05-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID    wmiDumpProc
    ( PVOID             Context
    , TARGET_ADDRESS    Buffer
    , ULONG             Length
    , ULONG             CpuNo
    , ULONG             Alignment
    , WMI_BUFFER_SOURCE Source
    )
{
    ULONG           size;
    ULONG           offset;
    ULONG           ulInfo;
    ULONG           ulLengthRead;

    PUCHAR          pBuffer;
    WMI_HEADER_TYPE headerType;
    WMIBUFFERINFO   stBufferInfo;

    WMITRACING_KD_SORTENTRY*    pstSortEntries = NULL;

    struct sttTraceContext *pstContext;

    // Cast Context
    pstContext = (struct sttTraceContext *) Context;

    // Allocate Buffer
    pBuffer = LocalAlloc (LPTR, Length);
    if (pBuffer == NULL) {
        dprintf ("Failed to Allocate Buffer.\n");
        return;
    }

    // Copy Buffer from Target machine
    ulLengthRead = 0;
    ulInfo = ReadMemory (Buffer, pBuffer, Length, &ulLengthRead);
    if ((!ulInfo) || (ulLengthRead != Length)) {
        dprintf ("Failed to Read (Entire?) Buffer.\n");
    }

    // Get Initial Offset and Fixup Header
    memset (&stBufferInfo, 0, sizeof (stBufferInfo));
    stBufferInfo.BufferSource = Source;
    stBufferInfo.Buffer = pBuffer;
    stBufferInfo.BufferSize = Length;
    stBufferInfo.Alignment = Alignment;
    stBufferInfo.ProcessorNumber = CpuNo;
    offset = WmiGetFirstTraceOffset (&stBufferInfo);

    // Inspect Each Event
    while ((headerType = WmiGetTraceHeader (pBuffer, offset, &size)) != WMIHT_NONE) {
        ULONGLONG   ullKey;
        union {
            EVENT_TRACE stEvent;
            CHAR        caEvent[4096];
        } u;

        if (CheckControlC())  break;

        // Get a consistant header
        ulInfo = WmiParseTraceEvent (pBuffer, offset, headerType, &u, sizeof (u));

        // Filter and maybe Add to Sort Q
        if ((ullKey = pstContext->Filter (pstContext, &u.stEvent)) != 0) {
            ULONG                   CurIndex;
            PWMI_CLIENT_CONTEXT     pstClientContext;
            struct sttSortControl  *pstSortControl;
            PWMITRACING_KD_SORTENTRY pstSortEntry;

            pstClientContext = (PWMI_CLIENT_CONTEXT) &u.stEvent.Header.ClientContext;
            pstSortControl = pstContext->pstSortControl;
            CurIndex = pstSortControl->CurEntries;
            if (CurIndex >= pstSortControl->MaxEntries) {
                pstSortControl->MaxEntries = pstSortControl->MaxEntries * 2 + 64;
                pstSortEntries =
                    realloc (pstSortControl->pstSortEntries,
                             sizeof (WMITRACING_KD_SORTENTRY) * (pstSortControl->MaxEntries));
                if (pstSortEntries == NULL) {
                    dprintf ("Memory Allocation Failure\n");
                    goto error;
                }
                pstSortControl->pstSortEntries = pstSortEntries;    
            }
            pstSortEntry = &pstSortControl->pstSortEntries[CurIndex];
            memset (pstSortEntry, 0, sizeof (*pstSortEntry));
            pstSortEntry->Address = Buffer;
            pstSortEntry->Keyll   = ullKey;
            {   //BUGBUG: This code should be replaced after Ian/Melur supply a way to access SequenceNo
                PULONG  pulEntry;
                pulEntry = (PULONG) &pBuffer[offset];
                if (((pulEntry[0] & 0xFF000000) == 0x90000000) &&
                    ( pulEntry[1] & 0x00010000)) {
                    pstSortEntry->SequenceNo = pulEntry[2];
                } else {
                    pstSortEntry->SequenceNo = 0;
                }
            }
            pstSortEntry->Ordinal = pstContext->Ordinal++;
            pstSortEntry->Offset  = offset;
            pstSortEntry->Length  = size;
            pstSortEntry->BufferSource = Source;
            pstSortEntry->HeaderType = headerType;
            pstSortEntry->CpuNo   = (USHORT) CpuNo;
            pstSortControl->CurEntries++;
        }   // If passes Filtering

        size = ((size + (Alignment-1)) / Alignment) * Alignment; //BUGBUG: Need fix in GetTraceHeader or WmiFlush.  Then remove this line.
        offset += size; // Move to next entry.
    }

error:
    LocalFree (pBuffer);
    return;
}
//+---------------------------------------------------------------------------
//
//  Function:   ULONG   wmiKdWriteFileHeader
//
//  Synopsis:   Write the file header when performing a Save command.
//
//  Arguments:  SaveFile    Handle to a file where we will write the header
//              LoggerId    Ordinal of the Stream we are writing the header for
//              TarLoggerContext    TargetAddress of the LoggerContext
//
//  Returns:    <VOID>
//
//  History:    04-05-2000   glennp Created
//
//  Notes:      This code should really be in wmi somewhere.  It's here due to
//              the difficulty of creating a simply parameterized procedure.
//
//----------------------------------------------------------------------------

ULONG
wmiKdWriteFileHeader
    ( FILE             *SaveFile
    , ULONG             LoggerId
    , TARGET_ADDRESS    TarLoggerContext
    )

{
    ULONG   ulInfo;
    ULONG   ulBytesRead;
    ULONG   ulAlignment;
    ULONG   ulBufferSize;
    ULONG   ulBufferCount;
    ULONG   ulPointerSize;
    ULONG   ulHeaderWritten;

    ULONG   ulInstanceGuidOffset;

    UCHAR               MajorVersion;
    UCHAR               MinorVersion;
    PROCESSORINFO       ProcessorInfo;

    PCHAR   pcEnd;

    struct sttFileHeader {
        WMI_BUFFER_HEADER       Buffer;
        SYSTEM_TRACE_HEADER     Event;
        TRACE_LOGFILE_HEADER    Header;
        WCHAR                   LogName[256];   //BUGBUG: Size??
        WCHAR                   FileName[256];  //BUGBUG: Size??
    } stFileHeader;


    ZeroMemory (&stFileHeader, sizeof (stFileHeader));

    ulAlignment = GetWmiTraceAlignment ();
    ulPointerSize = GetTypeSize ("PVOID");
    GetFieldOffset ("NT!_WMI_LOGGER_CONTEXT", "InstanceGuid", &ulInstanceGuidOffset);

    // Get ProcessorInfo and Kernel-User Shared Data
    Ioctl (IG_KD_CONTEXT, &ProcessorInfo, sizeof (ProcessorInfo));

    // Get Version Info
    if (!HaveDebuggerData ()) {
        dprintf ("No Version Information Available.");
        MajorVersion = MinorVersion = 0;
    } else {
        MajorVersion = (UCHAR) KernelVersionPacket.MajorVersion;
        MinorVersion = (UCHAR) KernelVersionPacket.MinorVersion;
    }

    // Get Infomation from LoggerContext on Target
    InitTypeRead (TarLoggerContext, NT!_WMI_LOGGER_CONTEXT);
    ulBufferSize = (ULONG) ReadField (BufferSize);
    ulBufferCount = (ULONG) ReadField (NumberOfBuffers);

    stFileHeader.Buffer.Wnode.BufferSize = ulBufferSize;
    stFileHeader.Buffer.ClientContext.LoggerId =
        (USHORT) ((LoggerId) ? LoggerId : KERNEL_LOGGER_ID);

    stFileHeader.Buffer.ClientContext.Alignment = (UCHAR) ulAlignment;

    ulInfo = ReadMemory (TarLoggerContext + ulInstanceGuidOffset,
                         &stFileHeader.Buffer.Wnode.Guid,
                         sizeof (stFileHeader.Buffer.Wnode.Guid),
                         &ulBytesRead);
    if ((!ulInfo) || (ulBytesRead != sizeof (stFileHeader.Buffer.Wnode.Guid))) {
        dprintf ("Unable to Read Wnode.Guid\n");
    }
    stFileHeader.Buffer.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    ulInfo = ReadMemory (TarLoggerContext + ulInstanceGuidOffset,
                         &stFileHeader.Buffer.InstanceGuid,
                         sizeof (stFileHeader.Buffer.InstanceGuid),
                         &ulBytesRead);
    if ((!ulInfo) || (ulBytesRead != sizeof (stFileHeader.Buffer.InstanceGuid))) {
        dprintf ("Unable to Read InstanceGuid\n");
    }

    // Single Event (File Header)
    stFileHeader.Event.Marker = TRACE_HEADER_FLAG | TRACE_HEADER_EVENT_TRACE |
        ((ulPointerSize > 4) ? (TRACE_HEADER_TYPE_SYSTEM64 << 16)
                             : (TRACE_HEADER_TYPE_SYSTEM32 << 16));
    stFileHeader.Event.Packet.Group = (UCHAR) EVENT_TRACE_GROUP_HEADER >> 8;
    stFileHeader.Event.Packet.Type  = EVENT_TRACE_TYPE_INFO;

    stFileHeader.Header.StartTime.QuadPart = ReadField (StartTime);
    stFileHeader.Header.BufferSize = ulBufferSize;
    stFileHeader.Header.VersionDetail.MajorVersion = MajorVersion;
    stFileHeader.Header.VersionDetail.MinorVersion = MinorVersion;

//
// The following #if 0's show fields in the header difficult to access from the debugger.
//
#if 0
    stFileHeader.Header.VersionDetail.SubVersion = TRACE_VERSION_MAJOR;
    stFileHeader.Header.VersionDetail.SubMinorVersion = TRACE_VERSION_MINOR;
    stFileHeader.Header.ProviderVersion = NtBuildNumber;
#endif
    stFileHeader.Header.StartBuffers = 1;
#if 0
    stFileHeader.Header.BootTime = KeBootTime;
    stFileHeader.Header.LogFileMode = LocLoggerContext.LogFileMode &
        (~(EVENT_TRACE_REAL_TIME_MODE | EVENT_TRACE_FILE_MODE_CIRCULAR));
#endif
    stFileHeader.Header.NumberOfProcessors = ProcessorInfo.NumberProcessors;
    stFileHeader.Header.MaximumFileSize    = (ULONG) ReadField (MaximumFileSize);
#if 0   
    KeQueryPerformanceCounter (&stFileHeader.Header.PerfFreq);
    if (WmiUsePerfClock) {
        stFileHeader.Header.ReservedFlags = 1;
    }
    stFileHeader.Header.TimerResolution = KeMaximumIncrement;  // DO NOT CHANGE KDDEBUGGER_DATA32!!
#endif
#if 0
    stFileHeader.Header.LoggerName  = (PWCHAR) ( ( (PUCHAR) ( &stFileHeader.Header ) ) +
                                      sizeof(TRACE_LOGFILE_HEADER) );
    stFileHeader.Header.LogFileName = (PWCHAR) ( (PUCHAR)stFileHeader.Header.LoggerName +
                                      LocLoggerContext.LoggerName.Length +
                                      sizeof(UNICODE_NULL));

    if (!ReadTargetMemory (LocLoggerContext.LoggerName.Buffer,
                           stFileHeader.Header.LoggerName,
                           LocLoggerContext.LoggerName.Length + sizeof(UNICODE_NULL)) ) {
        dprintf ("Can't access LoggerName (LoggerContext.LoggerName.Buffer) memory.\n");
    }
    MultiByteToWideChar (
        CP_OEMCP, 0, 
        pszSaveFileName, -1,
        stFileHeader.Header.LogFileName, countof (stFileHeader.FileName));
#if 0
    RtlQueryTimeZoneInformation(&stFileHeader.Header.TimeZone);
    stFileHeader.Header.EndTime;
#endif
#endif

    stFileHeader.Header.PointerSize = ulPointerSize;

    pcEnd = (PCHAR) &stFileHeader.LogName;  //BUGBUG: Use Calculation Just Below
#if 0
    pcEnd = ((PCHAR) stFileHeader.Header.LogFileName) +
            ((strlen (pszSaveFileName) + 1) * sizeof (WCHAR));
    stFileHeader.Buffer.Offset = (ULONG) (pcEnd - ((PCHAR) &stFileHeader));

#endif
    stFileHeader.Event.Packet.Size = (USHORT) (pcEnd - ((PCHAR) &stFileHeader.Event));

    //
    // Fixup Lengths; Write out Header, 0xFF to length of buffer
    //
    ulHeaderWritten = (ULONG) (pcEnd - ((PCHAR) &stFileHeader));

    stFileHeader.Buffer.Offset = ulHeaderWritten;
    stFileHeader.Buffer.SavedOffset = ulHeaderWritten;
    stFileHeader.Buffer.CurrentOffset = ulHeaderWritten;

    fwrite (&stFileHeader, ulHeaderWritten, 1, SaveFile);

    while (ulHeaderWritten < ulBufferSize) {
        ULONG   ulAllOnes;
        ULONG   ulByteCount;

        ulAllOnes = ~((ULONG) 0);
        ulByteCount = ulBufferSize - ulHeaderWritten;
        if (ulByteCount > sizeof (ulAllOnes))  ulByteCount = sizeof (ulAllOnes);
        fwrite (&ulAllOnes, ulByteCount, 1, SaveFile);
        ulHeaderWritten += sizeof (ulAllOnes);
        }

    return (0);
}


//+---------------------------------------------------------------------------
//
//  Function:   VOID wmiSaveProc
//
//  Synopsis:   Procedure passed to wmiKdProcessBuffers() when saving the
//                  Buffers to a file for later processing.  Performs buffer
//                  Header fixup and then writes the buffer to the file.
//
//  Arguments:  Context     -> to struct sttSaveContext.  Used for 'static' memory
//              Buffer      Target Address of WMI Event buffer to save
//              Length      Length of the buffer (previous parameter)
//              Alignment   Alignment used by WMI on target machine
//              Source      Enum of: free, flush, transition, current: buffer source
//
//  Returns:    <VOID>
//
//  History:    04-05-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------


VOID    wmiSaveProc
    ( PVOID             Context
    , TARGET_ADDRESS    Buffer
    , ULONG             Length
    , ULONG             CpuNo
    , ULONG             Alignment
    , WMI_BUFFER_SOURCE Source
    )
{
    ULONG                   ulInfo;
    ULONG                   ulLengthRead;
    PCHAR                   pBuffer;
    struct sttSaveContext  *pstContext;
    WMIBUFFERINFO           stBufferInfo;

    pstContext = (struct sttSaveContext *) Context;

    // Allocate Buffer
    pBuffer = LocalAlloc (LPTR, Length);
    if (pBuffer == NULL) {
        dprintf ("Failed to Allocate Buffer.\n");
        return;
    }

    // Read Buffer
    ulLengthRead = 0;
    ulInfo = ReadMemory (Buffer, pBuffer, Length, &ulLengthRead);
    if ((!ulInfo) || (ulLengthRead != Length)) {
        dprintf ("Failed to Read (Entire?) Buffer.\n");
    }

    // Fixup Buffer Header
    memset (&stBufferInfo, 0, sizeof (stBufferInfo));
    stBufferInfo.BufferSource = Source;
    stBufferInfo.Buffer = pBuffer;
    stBufferInfo.BufferSize = Length;
    stBufferInfo.ProcessorNumber = CpuNo;
    stBufferInfo.Alignment = Alignment;
    WmiGetFirstTraceOffset (&stBufferInfo);

    // Write to Log File
    ulInfo = fwrite (pBuffer, 1, Length, pstContext->pfSaveFile);
    if (ulInfo != Length) {
        dprintf ("Failed to Write Buffer.\n");
    }

    // Free Buffer, Return
    LocalFree (pBuffer);
    return;
}



//+---------------------------------------------------------------------------
//
//  Function:   ULONG wmiKdProcessNonblockingBuffers
//
//  Synopsis:   Calls Caller-Supplied Procedure for each Buffer in Locations/
//                  Lists as specified by 'Sources'.  Walks lists, Enumerates
//                  CPU's buffers, and handles 'Transition Buffer' logic.
//
//  Arguments:  LoggerId
//              LoggerContext
//              Procedure
//              Context
//              Sources
//
//  Returns:    ULONG:  Number of Buffers Processed
//
//  History:    04-05-2000   glennp Created
//
//  Notes:      Sources also controls informational printing
//
//----------------------------------------------------------------------------


ULONG
wmiKdProcessNonblockingBuffers(
    ULONG                           LoggerId,
    TARGET_ADDRESS                  LoggerContext,
    WMITRACING_KD_LISTENTRY_PROC    Procedure,
    PVOID                           Context,
    WMITRACING_BUFFER_SOURCES       Sources
    )
{
    TARGET_ADDRESS  tarAddress;
    TARGET_ADDRESS  tarBufferListPointer;

    ULONG           pointerSize;

    PROCESSORINFO   ProcessorInfo;

    ULONG           ulOrdinal;
    ULONG           ulAlignment;
    ULONG           ulBufferSize;
    ULONG           ulLoopCount;
    ULONG           ulBufferCount;
    ULONG           ulBufferNumber;

    ULONG           tarBufferListOffset;


    // Get Pointer to Context Structure
    tarAddress = LoggerContext;
    if (tarAddress == 0)  return (0);

    // Initialize Locals
    ulBufferNumber = 0;
    ulBufferCount  = 0;
    ulLoopCount  = 0;

    // Get Sizes, Offsets, Alignments from Target
    pointerSize = GetTypeSize ("PVOID");
    ulAlignment = GetWmiTraceAlignment ();
    GetFieldOffset ("NT!_WMI_BUFFER_HEADER", "GlobalEntry", &tarBufferListOffset);

    // Optionally Print LoggerId, Context Address, Logger name
    if (Sources.PrintInformation) {
        dprintf ("    Logger Id %2d @ 0x%P Named '", LoggerId, tarAddress);
        printUnicodeFromStruct (tarAddress, "NT!_WMI_LOGGER_CONTEXT", "LoggerName");
        dprintf ("'\n");
    }

    // Setup ReadField's Context, Find Buffer Size
    InitTypeRead (tarAddress, NT!_WMI_LOGGER_CONTEXT);
    ulBufferSize = (ULONG) ReadField (BufferSize);

    // Optionally Print a few interesting numbers
    if (Sources.PrintInformation) {
        dprintf ("      Alignment         = %ld\n", ulAlignment);
        dprintf ("      BufferSize        = %ld\n", ulBufferSize);
        dprintf ("      BufferCount       = %ld\n", (ULONG) ReadField (NumberOfBuffers));
        dprintf ("      MaximumBuffers    = %ld\n", (ULONG) ReadField (MaximumBuffers));
        dprintf ("      MinimumBuffers    = %ld\n", (ULONG) ReadField (MinimumBuffers));
        dprintf ("      EventsLost        = %ld\n", (ULONG) ReadField (EventsLost));
        dprintf ("      LogBuffersLost    = %ld\n", (ULONG) ReadField (LogBuffersLost));
        dprintf ("      RealTimeBuffersLost=%ld\n", (ULONG) ReadField (RealTimeBuffersLost));
        dprintf ("      BuffersAvailable  = %ld\n", (ULONG) ReadField (BuffersAvailable));
        dprintf ("      LastFlushedBuffer = %ld\n", (ULONG) ReadField (LastFlushedBuffer));
    }
    dprintf ("    Processing Global List:   0");

    tarBufferListPointer = 0;
    GetFieldValue (tarAddress, "NT!_WMI_LOGGER_CONTEXT", "GlobalList.Next", tarBufferListPointer);

    while (tarBufferListPointer != 0) {
        WMI_BUFFER_SOURCE   source;
        ULONG               ulCpuNumber;
        int                 iBufferUses;
        int                 iProcessBuffer;
        TARGET_ADDRESS      tarBufferPointer;
        ULONG               ulFree, ulInUse, ulFlush;

        iBufferUses = 0;
        ulCpuNumber = ~((ULONG) 0);
        iProcessBuffer = FALSE;
        source = WMIBS_TRANSITION_LIST;
        tarBufferPointer = tarBufferListPointer - tarBufferListOffset;
        dprintf ("\b\b\b%3d", ++ulLoopCount);

        InitTypeRead (tarBufferPointer, NT!_WMI_BUFFER_HEADER);
        ulFree  = (ULONG) ReadField (State.Free);
        ulInUse = (ULONG) ReadField (State.InUse);
        ulFlush = (ULONG) ReadField (State.Flush);

        // Decide on Buffer Processing based on Use Flags and 'Sources'
        if (ulFree ) iBufferUses += 1;
        if (ulInUse) iBufferUses += 2;
        if (ulFlush) iBufferUses += 4;

        switch (iBufferUses) {
            case 0: {   // No bits set, never used.
                break;
            }
            case 1: {   // Free
                iProcessBuffer = Sources.FreeBuffers;
                source = WMIBS_FREE_LIST;
                break;
            }
            case 2: {   // InUse
                iProcessBuffer = Sources.ActiveBuffers;
                source = WMIBS_CURRENT_LIST;
                //source = WMIBS_FLUSH_LIST;
                break;
            }
            case 3: {   // MULTIPLE BITS SET, ERROR
                dprintf ("\n***Error, Inconsistent Flags Bits (Free,InUse) Set.***\n");
                break;
            }
            case 4: {   // Flush
                iProcessBuffer = Sources.FlushBuffers;
                source = WMIBS_FLUSH_LIST;
                break;
            }
            case 5: {
                dprintf ("\n***Error, Inconsistent Flags Bits (Free,Flush) Set.***\n");
                break;
            }
            case 6: {
                dprintf ("\n***Error, Inconsistent Flags Bits (InUse,Flush) Set.***\n");
                break;
            }
            case 7: {
                dprintf ("\n***Error, Inconsistent Flags Bits (Free,InUse,Flush) Set.***\n");
                break;
            }
        }

        // ProcessBuffer as Decided Above
        if (iProcessBuffer) {
            ulBufferCount++;
            Procedure (Context, tarBufferPointer, ulBufferSize, ulCpuNumber, ulAlignment, source);
        }
        if (GetFieldValue (tarBufferPointer,
                           "NT!_WMI_BUFFER_HEADER", "GlobalEntry",
                           tarBufferListPointer) != 0) {
            dprintf ("\n***Error Following Global List.***\n");
            tarBufferListPointer = 0;
        }
    }
    dprintf (" Buffers\n");


    // Return w/ BufferCount
    return (ulBufferCount);
} // wmiKdProcessNonblockingBuffers

//+---------------------------------------------------------------------------
//
//  Function:   ULONG wmiKdProcessBlockingBuffers
//
//  Synopsis:   Calls Caller-Supplied Procedure for each Buffer in Locations/
//                  Lists as specified by 'Sources'.  Walks lists, Enumerates
//                  CPU's buffers, and handles 'Transition Buffer' logic.
//
//  Arguments:  LoggerId
//              LoggerContext
//              Procedure
//              Context
//              Sources
//
//  Returns:    ULONG:  Number of Buffers Processed
//
//  History:    04-05-2000   glennp Created
//
//  Notes:      Sources also controls informational printing
//
//----------------------------------------------------------------------------


ULONG
wmiKdProcessBlockingBuffers(
    ULONG                           LoggerId,
    TARGET_ADDRESS                  LoggerContext,
    WMITRACING_KD_LISTENTRY_PROC    Procedure,
    PVOID                           Context,
    WMITRACING_BUFFER_SOURCES       Sources
    )
{
    TARGET_ADDRESS  tarAddress;
    ULONG           pointerSize;

    PROCESSORINFO   ProcessorInfo;

    ULONG           ulOrdinal;
    ULONG           ulAlignment;
    ULONG           ulBufferSize;
    ULONG           ulBufferCount;
    ULONG           ulBufferNumber;
    ULONG           ulBufferCountTotal;

    ULONG           tarFlushListOffset;
    ULONG           tarBufferListOffset;


    // Get Pointer to Context Structure
    tarAddress = LoggerContext;
    if (tarAddress == 0)  return (0);

    // Initialize Locals
    ulBufferNumber = 0;
    ulBufferCount  = 0;
    ulBufferCountTotal = 0;

    // Get Sizes, Offsets, Alignments from Target
    pointerSize = GetTypeSize ("PVOID");
    ulAlignment = GetWmiTraceAlignment ();
    GetFieldOffset ("NT!_WMI_BUFFER_HEADER",  "Entry",     &tarBufferListOffset);
    GetFieldOffset ("NT!_WMI_LOGGER_CONTEXT", "FlushList", &tarFlushListOffset);

    // Optionally Print LoggerId, Context Address, Logger name
    if (Sources.PrintInformation) {
        dprintf ("    Logger Id %2d @ 0x%P Named '", LoggerId, tarAddress);
        printUnicodeFromStruct (tarAddress, "NT!_WMI_LOGGER_CONTEXT", "LoggerName");
        dprintf ("'\n");
    }

    // Setup ReadField's Context, Find Buffer Size
    InitTypeRead (tarAddress, NT!_WMI_LOGGER_CONTEXT);
    ulBufferSize = (ULONG) ReadField (BufferSize);

    // Optionally Print a few interesting numbers
    if (Sources.PrintInformation) {
        dprintf ("      Alignment         = %ld\n", ulAlignment);
        dprintf ("      BufferSize        = %ld\n", ulBufferSize);
        dprintf ("      BufferCount       = %ld\n", (ULONG) ReadField (NumberOfBuffers));
        dprintf ("      MaximumBuffers    = %ld\n", (ULONG) ReadField (MaximumBuffers));
        dprintf ("      MinimumBuffers    = %ld\n", (ULONG) ReadField (MinimumBuffers));
        dprintf ("      EventsLost        = %ld\n", (ULONG) ReadField (EventsLost));
        dprintf ("      LogBuffersLost    = %ld\n", (ULONG) ReadField (LogBuffersLost));
        dprintf ("      RealTimeBuffersLost=%ld\n", (ULONG) ReadField (RealTimeBuffersLost));
        dprintf ("      BuffersAvailable  = %ld\n", (ULONG) ReadField (BuffersAvailable));
        dprintf ("      LastFlushedBuffer = %ld\n", (ULONG) ReadField (LastFlushedBuffer));
    }

    // Setup for Checks against TransitionBuffer Address IF REQUESTED
    TransitionBuffer = 0;
    if (Sources.TransitionBuffer) {
        TARGET_ADDRESS tarTransitionBuffer;

        tarTransitionBuffer = ReadField (TransitionBuffer);
        if ((tarTransitionBuffer != 0) &&
            (tarTransitionBuffer != (tarAddress + tarFlushListOffset))) {

            ULONG   tarTransitionBufferOffset;
            GetFieldOffset ("NT!_WMI_BUFFER_HEADER", "Entry", &tarTransitionBufferOffset);
            tarTransitionBuffer = tarAddress - tarTransitionBufferOffset;
            TransitionBuffer = tarTransitionBuffer;
        }
    }

    // Access the Free Queue Buffers IF REQUESTED
    if (Sources.FreeBuffers) {
        ULONG           tarFreeListOffset;

        GetFieldOffset ("NT!_WMI_LOGGER_CONTEXT", "FreeList",  &tarFreeListOffset);

        dprintf ("    Processing FreeQueue: ");
        ulBufferCount = wmiKdProcessLinkList (tarAddress + tarFreeListOffset,
                                              Procedure, Context, ulBufferSize, ulAlignment, WMIBS_FREE_LIST,
                                              tarBufferListOffset, Sources.PrintProgressIndicator);
        dprintf ("%ld Buffers\n", ulBufferCount);
        ulBufferCountTotal += ulBufferCount;
        }

    // Access the Flush Queue Buffers IF REQUESTED
    if (Sources.FlushBuffers) {
        dprintf ("    Processing FlushQueue: ");
        ulBufferCount = wmiKdProcessLinkList (tarAddress + tarFlushListOffset,
                                              Procedure, Context, ulBufferSize, ulAlignment, WMIBS_FLUSH_LIST,
                                              tarBufferListOffset, Sources.PrintProgressIndicator);
        dprintf ("%ld Buffers\n", ulBufferCount);
        ulBufferCountTotal += ulBufferCount;
    }

    // Access the 'Live' buffers (one per cpu) IF REQUESTED
    if (Sources.ActiveBuffers) {
        TARGET_ADDRESS  tarProcessorArrayAddress;
    
        GetFieldValue (tarAddress,"NT!_WMI_LOGGER_CONTEXT", "ProcessorBuffers", tarProcessorArrayAddress);
        Ioctl (IG_KD_CONTEXT, &ProcessorInfo, sizeof (ProcessorInfo));
        for (ProcessorInfo.Processor = 0;
             ProcessorInfo.Processor < ProcessorInfo.NumberProcessors;
             ++ProcessorInfo.Processor) {
            TARGET_ADDRESS tarProcessorPointer;
            ReadPtr (tarProcessorArrayAddress + ProcessorInfo.Processor * pointerSize,
                     &tarProcessorPointer);
            dprintf ("    Cpu %d Buffer Header @ 0x%P ",
                     ProcessorInfo.Processor, tarProcessorPointer);
            Procedure (Context, tarProcessorPointer, ulBufferSize,
                       ProcessorInfo.Processor, ulAlignment, WMIBS_CURRENT_LIST);
            ulBufferCountTotal += 1;
            dprintf (" \b\n");
        }   // Cpu Loop
    }

    // Process the Transition Entry (if any).  Note 'IF REQUESTED' test above in Setup
    if (TransitionBuffer != 0) {
        dprintf ("    Transition Buffer @ 0x%P ", TransitionBuffer);
        Procedure (Context, TransitionBuffer, ulBufferSize, ~0, ulAlignment, WMIBS_TRANSITION_LIST);
        ulBufferCountTotal += 1;
    }

    // Return w/ BufferCount
    return (ulBufferCountTotal);
} // wmiKdProcessBlockingBuffers

//+---------------------------------------------------------------------------
//
//  Function:   ULONG wmiKdProcessBuffers
//
//  Synopsis:   Decides if the target system is using doubly-linked (blocking)
//                  or singly-linked (non-blocking) lists of buffers.  Then it
//                  calls the appropriate Buffer-Walking routine.  They:
//              Call Caller-Supplied Procedure for each Buffer in Locations/
//                  Lists as specified by 'Sources'.  Walk lists, Enumerates
//                  CPU's buffers, and handles 'Transition Buffer' logic.
//
//  Arguments:  LoggerId
//              LoggerContext
//              Procedure
//              Context
//              Sources
//
//  Returns:    ULONG:  Number of Buffers Processed
//
//  History:    04-05-2000   glennp Created
//
//  Notes:      Sources also controls informational printing
//
//----------------------------------------------------------------------------


ULONG
wmiKdProcessBuffers(
    ULONG                           LoggerId,
    TARGET_ADDRESS                  LoggerContext,
    WMITRACING_KD_LISTENTRY_PROC    Procedure,
    PVOID                           Context,
    WMITRACING_BUFFER_SOURCES       Sources
    )
{
    ULONG   ulBufferCountTotal;

    int     iBufferMechanism;
    ULONG   tarGlobalListOffset;
    ULONG   tarTransitionBufferOffset;

    iBufferMechanism = 0;
    ulBufferCountTotal = 0;

    if ((GetFieldOffset ("NT!_WMI_LOGGER_CONTEXT", "GlobalList", &tarGlobalListOffset) == 0) &&
        (tarGlobalListOffset != 0)) {
        iBufferMechanism += 1;
    }
    if ((GetFieldOffset ("NT!_WMI_LOGGER_CONTEXT", "TransitionBuffer", &tarTransitionBufferOffset) == 0) &&
        (tarTransitionBufferOffset != 0)) {
        iBufferMechanism += 2;
    }

    switch (iBufferMechanism) {
        case 0: {   // Neither, ???
            dprintf ("Unable to determine buffer mechanism.  "
                     "Check for complete symbol availability.\n");
            break;
        }

        case 1: {   // Global, no Transition
            ulBufferCountTotal = wmiKdProcessNonblockingBuffers (LoggerId, LoggerContext,
                                                                 Procedure, Context, Sources);
            break;
        }

        case 2: {   // Transition, no Global
            ulBufferCountTotal = wmiKdProcessBlockingBuffers (LoggerId, LoggerContext,
                                                              Procedure, Context, Sources);
            break;
        }

        case 3: {   // Both, ???
            dprintf ("Unable to determine buffer mechanism.  "
                     "Check for new wmiTrace debugger extension.  GO = %d, TB = %d\n",
                     tarGlobalListOffset, tarTransitionBufferOffset);
            break;
        }

    }

    // Return w/ BufferCount
    return (ulBufferCountTotal);
} // wmiKdProcessBuffers

//+---------------------------------------------------------------------------
//
//  Function:   VOID wmiLogDump
//
//  Synopsis:   callable procedure to dump the in-memory part of a tracelog.
//                  Caller can supply three procedures to:
//                      1. Filter and Select the Sort Key for VMI Events,
//                      2. Compare the Sort Keys, and
//                      3. Print the Output for each Selected Event.
//              this procedure is called by the built-in extension logdump.
//
//  Arguments:  LoggerId        -> the Id of the logger stream to process
//              Context         <OMITTED>
//              GuidListHeadPtr -> to a list of MOF Guids from GetTraceGuids
//              Filter          -> to a replacement Filter procedure
//              Compare         -> to a replacement Compare (for Sort) procedure
//              Output          -> to a replacement Output procedure
//
//  Returns:    VOID
//
//  History:    04-05-2000   glennp Created
//
//----------------------------------------------------------------------------


VOID wmiLogDump(
    ULONG                   LoggerId,
    PVOID                   UserContext,
    PLIST_ENTRY             GuidListHeadPtr,
    WMITRACING_KD_FILTER    Filter,
    WMITRACING_KD_COMPARE   Compare,
    WMITRACING_KD_OUTPUT    Output
    )
{
    ULONG           ulOrdinal;
    ULONG           ulSortIndex;
    ULONG           ulBufferSize;
    ULONG           ulBufferCountTotal;
    ULONG           ulAlignment;
    TARGET_ADDRESS  tarAddress;
    PCHAR           locBufferAddress;
    TARGET_ADDRESS  lastBufferAddress;

    struct sttSortControl   stSortControl;
    struct sttTraceContext  stTraceContext;
    WMITRACING_BUFFER_SOURCES   stSources;


    // Replace NULL procedures w/ defaults
    if (Filter  == NULL)   Filter  = wmiDefaultFilter;
    if (Compare == NULL)   Compare = wmiDefaultCompare;
    if (Output  == NULL)   Output  = wmiDefaultOutput;

    // Initialize Locals
    memset (&stSortControl,  0, sizeof (stSortControl));
    memset (&stTraceContext, 0, sizeof (stTraceContext));
    stTraceContext.pstSortControl = &stSortControl;
    stTraceContext.UserContext = UserContext;
  //stTraceContext.Ordinal = 0;
    stTraceContext.Filter = Filter;

    // Select (All) Sources
    stSources.FreeBuffers = 1;
    stSources.FlushBuffers = 1;
    stSources.ActiveBuffers = 1;
    stSources.TransitionBuffer = 1;

    // Print Summary and ProgressIndicator
    stSources.PrintInformation = 1;
    stSources.PrintProgressIndicator = 1;

    // Print Intro Message
    dprintf ("(WmiTrace)LogDump for Log Id %ld\n", LoggerId);

    // Get Pointer to Logger Context
    tarAddress = FindLoggerContext (LoggerId);
    ulAlignment = GetWmiTraceAlignment ();

    // Filter and Gather all Messages we want
    ulBufferCountTotal = wmiKdProcessBuffers (LoggerId, tarAddress,
                                              wmiDumpProc, &stTraceContext, stSources);

    // Sort the Entries just Gathered
    qsort (stSortControl.pstSortEntries, stSortControl.CurEntries,
           sizeof (stSortControl.pstSortEntries[0]), Compare);
    if (stSortControl.CurEntries > 0) {
        dprintf ("LOGGED MESSAGES (%ld):\n", stSortControl.CurEntries);
    }

    // Allocate Buffer
    GetFieldValue (tarAddress, "NT!_WMI_LOGGER_CONTEXT", "BufferSize", ulBufferSize);
    lastBufferAddress = 0;  // For the buffer 'cache' (one item for now)
    locBufferAddress = LocalAlloc (LPTR, ulBufferSize);
    if (locBufferAddress == NULL) {
        dprintf ("FAILED TO ALLOCATE NEEDED BUFFER!\n");
        goto Cleanup;
    }

    // Print each (Sorted) Entry
    for (ulSortIndex = 0; ulSortIndex < stSortControl.CurEntries; ++ulSortIndex) {
        const WMITRACING_KD_SORTENTRY  *sortEntry;
        union {
            EVENT_TRACE stEvent;
            CHAR        caEvent[4096];
        } u;

        if (CheckControlC())  break;

        sortEntry = &stSortControl.pstSortEntries[ulSortIndex];

        // Read the entire buffer if not same as last
        if (lastBufferAddress != sortEntry->Address) {

            {
                ULONG   ulInfo;
                ULONG   ulBytesRead;
    
                // Read Buffer
                ulBytesRead = 0;
                lastBufferAddress  = sortEntry->Address;
                ulInfo =
                    ReadMemory (lastBufferAddress, locBufferAddress, ulBufferSize, &ulBytesRead);
                if ((!ulInfo) || (ulBytesRead != ulBufferSize))  {
                    dprintf ("Failed to (Re)Read Buffer @ %P.\n", lastBufferAddress);
                    continue;   // Try for others
                }
            }

            {
                WMIBUFFERINFO   stBufferInfo;
    
                // Perform Fixup
                memset (&stBufferInfo, 0, sizeof (stBufferInfo));
                stBufferInfo.BufferSource = sortEntry->BufferSource;
                stBufferInfo.Buffer = locBufferAddress;
                stBufferInfo.BufferSize = ulBufferSize;
                stBufferInfo.ProcessorNumber = sortEntry->CpuNo;
                stBufferInfo.Alignment = ulAlignment;
                WmiGetFirstTraceOffset (&stBufferInfo);
            }
        }

        // Get a consistant header
        WmiParseTraceEvent (locBufferAddress, sortEntry->Offset, sortEntry->HeaderType,
                            &u, sizeof (u));

        // Output the Entry
        Output (UserContext, GuidListHeadPtr, sortEntry, &u.stEvent);
    }

Cleanup:
    // Free Buffer
    LocalFree (locBufferAddress);

    //  Print Summary
    dprintf ("Total of %ld Messages from %ld Buffers\n",
             stSortControl.CurEntries,
             ulBufferCountTotal);

    //  Free the sort elements (pointers + keys)
    free (stSortControl.pstSortEntries);
    return;
} // wmiLogDump


//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(help)
//
//  Synopsis:   list available functions and syntax
//
//  Arguments:  <NONE>
//
//  Returns:    <VOID>
//
//  History:    2-17-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( help )
{
    dprintf("WMI Tracing Kernel Debugger Extensions\n");
    dprintf("    logdump  <LoggerId> [<guid file name>] - Dump the in-memory portion of a log file\n");
    dprintf("    logsave  <LoggerId>  <Save file name>  - Save the in-memory portion of a log file in binary form\n");
    dprintf("    strdump [<LoggerId>]                   - Dump the Wmi Trace Event Structures\n");
    dprintf("    searchpath     <Path>                  - Set the trace format search path\n");
    dprintf("    guidfile <filename>                    - Set the guid file name (default is 'default.tmf')\n");
    dprintf("    dynamicprint <0|1>                     - Turn live tracing messages on (1) or off (0).  Default is on.\n");
    //dprintf("    kdtracing <LoggerId> <0|1>             - Turn live tracing messages on (1) or off (0) for a particular logger.\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(logdump)
//
//  Synopsis:   LOG DUMP: Dumps Trace Messages from a Log Stream to Stdout
//
//  Arguments:  <Stream Number> [<MofData.Guid File Name>]
//
//  Returns:    <VOID>
//
//  History:    2-17-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( logdump )
{
    ULONG_PTR      ulStatus = 0;
//    TARGET_ADDRESS     tarAddress = NULL;
    ULONG       ulLoggerId;

    const CHAR *argPtr = NULL;
    size_t      sztLen  = 0;
    
    // Defaults
    ulLoggerId = 1;


    // LoggerId ?
    if (args && args[0]) {
        ulLoggerId = (ULONG) GetExpression (args);
    }
    
    // LoggerId ?
    argPtr = args + strspn (args, " \t\n");
    sztLen = strspn (argPtr, "0123456789");
    if (sztLen > 0) {
//      ulLoggerId = atol (argPtr);
        argPtr += sztLen;
    }

    // Guid Definition File
    argPtr = argPtr + strspn (argPtr, " \t\n,");
    if (strlen (argPtr)) {
    	//only change name if it is different from what is already stored
        if(_stricmp(argPtr, g_pszGuidFileName)){
            sztLen = strcspn (argPtr, " \t\n,");
        
            //make sure name will not overrun buffer
            if(sztLen >= MAX_PATH) {
                sztLen = MAX_PATH - 1;
            }
            // lpFileName = (LPTSTR)malloc((sztLen + 1) * sizeof(TCHAR));
            memcpy(g_pszGuidFileName, argPtr, sztLen);
            g_pszGuidFileName[sztLen] = '\000';

            if(g_GuidListHeadPtr != NULL) {    
                if(g_fpCleanupTraceEventList == NULL) {
                    g_fpCleanupTraceEventList = GetAddr("CleanupTraceEventList");
                }
                if(g_fpCleanupTraceEventList != NULL) {    
                    g_fpCleanupTraceEventList (g_GuidListHeadPtr);
                    g_GuidListHeadPtr = NULL;
                } else {
                    dprintf ("ERROR: Failed to clean up Guid list.\n");
                    return;
                }
            }
        }
    } 


    // Show LoggerId, FileName
    dprintf ("WMI Generic Trace Dump: Debugger Extension. LoggerId = %ld, Guidfile = '%s'\n",
             ulLoggerId, g_pszGuidFileName);

    // Open Guid File, Dump Log, Cleanup
    if(g_GuidListHeadPtr == NULL) {
        if(g_fpGetTraceGuids == NULL) {
            g_fpGetTraceGuids = GetAddr(GetTraceGuidsString);
        }
        if(g_fpGetTraceGuids != NULL) {    
            ulStatus = g_fpGetTraceGuids ((TCHAR *) g_pszGuidFileName, &g_GuidListHeadPtr);
        }	
        if (ulStatus == 0) {
            dprintf ("Failed to open Guid file '%hs'\n", g_pszGuidFileName);
            return;
        }
    }
    dprintf ("Opened Guid File '%hs' with %d Entries.\n",
             g_pszGuidFileName, ulStatus);
    wmiLogDump (ulLoggerId, NULL, g_GuidListHeadPtr, NULL, NULL, NULL);

    /*if(g_fpCleanupTraceEventList == NULL) {
        g_fpCleanupTraceEventList = GetAddr("CleanupTraceEventList");
    }
    if(g_fpCleanupTraceEventList != NULL) {    
        g_fpCleanupTraceEventList (g_GuidListHeadPtr);
        g_GuidListHeadPtr = NULL;
    }*/
    return;
} // logdump

//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(logsave)
//
//  Synopsis:   LOG DUMP: Dumps Trace Messages from a Log Stream to Stdout
//
//  Arguments:  <Stream Number> [<MofData.Guid File Name>]
//
//  Returns:    <VOID>
//
//  History:    2-17-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( logsave )
{
    ULONG       ulStatus;
    TARGET_ADDRESS     tarAddress;
    ULONG       ulLoggerId;
    LPSTR       pszSaveFileName;

    const CHAR *argPtr;
    size_t      sztLen;
    CHAR        caFileName[256];

    // Defaults
    ulLoggerId = 1;
    pszSaveFileName = "LogData.elg";


    // LoggerId ?
    if (args && args[0]) {
        ulLoggerId = (ULONG) GetExpression (args);
    }
    
    // Point beyond LoggerId
    argPtr  = args + strspn (args, " \t\n");
    argPtr += strspn (argPtr, "0123456789");

    // Save File
    argPtr = argPtr + strspn (argPtr, " \t\n,");
    if (strlen (argPtr)) {
        sztLen = strcspn (argPtr, " \t\n,");
        memcpy (caFileName, argPtr, sztLen);
        caFileName[sztLen] = '\000';
        pszSaveFileName = caFileName;
    }


    // Show LoggerId, FileName
    dprintf ("WMI Trace Save: Debugger Extension. LoggerId = %ld, Save File = '%s'\n",
             ulLoggerId, pszSaveFileName);

    // Get Pointer to Logger Context
    tarAddress = FindLoggerContext (ulLoggerId);

    // Check if LoggerId Good
    if (tarAddress == 0) {
        dprintf ("Failed to Find Logger\n");
    } else {
        FILE       *pfSaveFile;

        // Open Guid File, Dump Log, Cleanup
        pfSaveFile = fopen (pszSaveFileName, "ab");
        if (pfSaveFile == NULL) {
            dprintf ("Failed to Open Save File '%hs'\n", pszSaveFileName);
        } else {
            WMITRACING_BUFFER_SOURCES   stSources;
            struct sttSaveContext       stSaveContext;
            ULONG                       ulTotalBufferCount;
            ULONG                       ulRealTime;

            // See if we are in "RealTime" mode (if so, we'll save FreeBuffers too)
            if (GetFieldValue (tarAddress,
                               "NT!_WMI_LOGGER_CONTEXT",
                               "LoggerModeFlags.RealTime",
                               ulRealTime)) {
                dprintf ("Unable to Retrieve 'RealTime' Flag.  Assuming Realtime Mode.\n");
                ulRealTime = 1; // Better to get too many than too few.
            }

            //Write Header
            wmiKdWriteFileHeader (pfSaveFile, ulLoggerId, tarAddress);
    
            // Select Sources
            stSources.FreeBuffers = (ulRealTime) ? 1 : 0;
            stSources.FlushBuffers = 1;
            stSources.ActiveBuffers = 1;
            stSources.TransitionBuffer = 1;

            stSources.PrintInformation = 1;
            stSources.PrintProgressIndicator = 1;

            // Setup SaveContext
            stSaveContext.pfSaveFile = pfSaveFile;
    
            // Write Buffers
            ulTotalBufferCount = wmiKdProcessBuffers (ulLoggerId, tarAddress,
                                                      wmiSaveProc, &stSaveContext, stSources);
            dprintf ("Saved %d Buffers\n", ulTotalBufferCount);
    
            // Close
            fclose (pfSaveFile);
        }
    }

    return;
} // logdump

//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(strdump)
//
//  Synopsis:   STRucture DUMP: dumps generic info (no arg) or stream info (arg)
//
//  Arguments:  [<Stream Number>]
//
//  Returns:    <VOID>
//
//  History:    2-17-2000   glennp Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( strdump )
/*
 *  dump the structures for trace logging
 *      strdump [<LoggerId>]
 *          If <LoggerId> present, dump structs for that Id
 *          Else                   dump generic structs
 */
{
    TARGET_ADDRESS tarAddress;
    DWORD   dwRead, Flags;

    ULONG   ulLoggerId;
    ULONG   ulMaxLoggerId;

    ULONG   pointerSize;


    // Defaults
    ulLoggerId = ~0;
    pointerSize = GetTypeSize ("PVOID");

    // LoggerId ?
    if (args && args[0]) {
        ulLoggerId = (ULONG) GetExpression (args);
    }

    if (ulLoggerId == ~0) {
        dprintf ("(WmiTracing)StrDump Generic\n");
        tarAddress = FindLoggerContextArray (&ulMaxLoggerId);
        dprintf ("  LoggerContext Array @ 0x%P [%d Elements]\n",
                 tarAddress, ulMaxLoggerId);
        if (tarAddress) {
            for (ulLoggerId = 0; ulLoggerId < ulMaxLoggerId; ++ulLoggerId) {
                TARGET_ADDRESS contextAddress;

                contextAddress = tarAddress + pointerSize * ulLoggerId;
                /*if (*/ReadPointer (contextAddress, &contextAddress)/*) {*/;
                    //dprintf ("UNABLE TO READ POINTER in ARRAY of POINTERS!, Addr = 0x%P\n", contextAddress);
                /*} else*/ if (contextAddress != 0) {
                    dprintf ("    Logger Id %2d @ 0x%P Named '", ulLoggerId, contextAddress);
                    printUnicodeFromStruct (contextAddress, "NT!_WMI_LOGGER_CONTEXT", "LoggerName");
                    dprintf ("'\n");
                }
            }
        }
    } else {
        dprintf ("(WmiTracing)StrDump for Log Id %ld\n", ulLoggerId);
        tarAddress = FindLoggerContext (ulLoggerId);
        if (tarAddress != 0) {
            dprintf ("    Logger Id %2d @ 0x%P Named '", ulLoggerId, tarAddress);
            printUnicodeFromStruct (tarAddress, "NT!_WMI_LOGGER_CONTEXT", "LoggerName");
            dprintf ("'\n");
            InitTypeRead (tarAddress, NT!_WMI_LOGGER_CONTEXT);
            dprintf ("      BufferSize        = %ld\n",     (ULONG) ReadField (BufferSize));
            dprintf ("      BufferCount       = %ld\n",     (ULONG) ReadField (NumberOfBuffers));
            dprintf ("      MaximumBuffers    = %ld\n",     (ULONG) ReadField (MaximumBuffers));
            dprintf ("      MinimumBuffers    = %ld\n",     (ULONG) ReadField (MinimumBuffers));
            dprintf ("      EventsLost        = %ld\n",     (ULONG) ReadField (EventsLost));
            dprintf ("      LogBuffersLost    = %ld\n",     (ULONG) ReadField (LogBuffersLost));
            dprintf ("      RealTimeBuffersLost=%ld\n",     (ULONG) ReadField (RealTimeBuffersLost));
            dprintf ("      BuffersAvailable  = %ld\n",     (ULONG) ReadField (BuffersAvailable));
            dprintf ("      LastFlushedBuffer = %ld\n",     (ULONG) ReadField (LastFlushedBuffer));
            dprintf ("      LoggerId          = 0x%02lX\n", (ULONG) ReadField (LoggerId));
            dprintf ("      CollectionOn      = %ld\n",     (ULONG) ReadField (CollectionOn));
            dprintf ("      KernelTraceOn     = %ld\n",     (ULONG) ReadField (KernelTraceOn));
            dprintf ("      EnableFlags       = 0x%08lX\n", (ULONG) ReadField (EnableFlags));
            dprintf ("      MaximumFileSize   = %ld\n",     (ULONG) ReadField (MaximumFileSize));
            dprintf ("      LogFileMode       = 0x%08lX\n", (ULONG) ReadField (LogFileMode));
            dprintf ("      LoggerMode       = 0x%08lX\n", (ULONG) ReadField (LoggerMode));
            dprintf ("      FlushTimer        = %I64u\n", ReadField (FlushTimer));
            dprintf ("      FirstBufferOffset = %I64u\n", ReadField (FirstBufferOffset));
            dprintf ("      ByteOffset        = %I64u\n", ReadField (ByteOffset));
            dprintf ("      BufferAgeLimit    = %I64d\n", ReadField (BufferAgeLimit));
            dprintf ("      LoggerName        = '");
            printUnicodeFromStruct (tarAddress, "NT!_WMI_LOGGER_CONTEXT", "LoggerName");
            dprintf (                           "'\n");
            dprintf ("      LogFileName       = '");
            printUnicodeFromStruct (tarAddress, "NT!_WMI_LOGGER_CONTEXT", "LogFileName");
            dprintf (                           "'\n");
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(searchpath)
//
//  Synopsis:   LOG DUMP: Sets the trace format search path
//
//  Arguments:  <Path>
//
//  Returns:    <VOID>
//
//  History:    7-03-2000   t-dbloom Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( searchpath )
{
    const CHAR *argPtr;
    size_t      sztLen;

    LPTSTR       lppath;
    LPWSTR       lppathW;
    int len, waslen = 0;

    // Defaults
    lppath = NULL;
    lppathW = NULL;

    // Path ?
    if (args) {
        argPtr = args + strspn (args, " \t\n");
        if (strlen (argPtr)) {
            sztLen = strcspn (argPtr, " \t\n,");
            lppath = (LPTSTR)malloc((sztLen + 1) * sizeof(TCHAR));
            if(lppath != NULL) {
                memcpy (lppath, argPtr, sztLen);
                lppath[sztLen] = '\000';
            }
        }
    }

    if(lppath != NULL) {
    	//Convert to Unicode
        while (((len = MultiByteToWideChar(CP_ACP, 0, lppath, sztLen, lppathW, waslen)) - waslen) > 0) {
				if (len - waslen > 0 ) {
					if (lppathW != NULL) {
						free(lppathW);
					}
					lppathW = (LPWSTR)malloc((len + 1) * sizeof(wchar_t)) ;

                                   if ( !lppathW ) {
                                   	dprintf("Memory allocation failed.\n");
                                   	return;
                                   }
                                   waslen = len;
				}
        }
        if(lppathW != NULL) {
            lppathW[len] = L'\000';
       }
        
        if(g_fpSetTraceFormatParameter == NULL) {
            g_fpSetTraceFormatParameter = GetAddr("SetTraceFormatParameter");
        }
        if(g_fpSetTraceFormatParameter != NULL) {
            g_fpSetTraceFormatParameter(ParameterTraceFormatSearchPath, lppathW);
        } 
        free(lppath);
        if(lppathW != NULL){
            free(lppathW);
        }
    }


    lppathW = NULL;

    if(g_fpGetTraceFormatSearchPath == NULL) {
            g_fpGetTraceFormatSearchPath = GetAddr("GetTraceFormatSearchPath");
    }
    if(g_fpGetTraceFormatSearchPath != NULL) {     
        lppathW = (LPWSTR)g_fpGetTraceFormatSearchPath();
    } 
    
    // Show new search path
    dprintf ("WMI Set Trace Format Search Path: Debugger Extension. Path = '%S'\n", lppathW);

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(guidfile)
//
//  Synopsis:   LOG DUMP: Sets guid file name (if not set, the default is "default.tmf")
//
//  Arguments:  <Path>
//
//  Returns:    <VOID>
//
//  History:    7-10-2000   t-dbloom Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( guidfile )
{
    const CHAR *argPtr;
    size_t sztLen;

    if (args) {
        argPtr = args + strspn (args, " \t\n");
        if (strlen (argPtr)) {
            //only change name if it is different from what is already stored
            if(_stricmp(argPtr, g_pszGuidFileName)){
                sztLen = strcspn (argPtr, " \t\n,");
                //make sure string length will not overrun buffer
                if(sztLen >= MAX_PATH) {
                    sztLen = MAX_PATH - 1;
                }
                memcpy (g_pszGuidFileName, argPtr, sztLen);
                g_pszGuidFileName[sztLen] = '\000';

                if(g_GuidListHeadPtr != NULL) {    
                    if(g_fpCleanupTraceEventList == NULL) {
                        g_fpCleanupTraceEventList = GetAddr("CleanupTraceEventList");
                    }
                    if(g_fpCleanupTraceEventList != NULL) {    
                        g_fpCleanupTraceEventList (g_GuidListHeadPtr);
                    } else {
                        dprintf ("ERROR: Failed to clean up Guid list.\n");
                    }
                    g_GuidListHeadPtr = NULL;
                }
            }
        }
    }
    dprintf("WMI Set Trace Guid File Name: Debugger Extension. File = '%s'\n", g_pszGuidFileName);
}

//+---------------------------------------------------------------------------
//
//  Function:   DECLARE_API(dynamicprint)
//
//  Synopsis:   LOG DUMP: Determines if dynamic tracing messaged are processed and printed, or just thrown away
//
//  Arguments:  <Path>
//
//  Returns:    <VOID>
//
//  History:    7-10-2000   t-dbloom Created
//
//  Notes:
//
//----------------------------------------------------------------------------

DECLARE_API( dynamicprint )
{
    const CHAR *argPtr;
    LPSTR lpValue = NULL;
    
    if (args) {
        argPtr = args + strspn (args, " \t\n");
    } else {
       dprintf("Invalid parameters\n");
       return;
    }

    if(!_stricmp(argPtr, "1") ){
        lpValue = "ON";
        g_ulPrintDynamicMessages = 1;
   } else if(!_stricmp(argPtr, "0")) {
        lpValue = "OFF";
        g_ulPrintDynamicMessages = 0;
   } else {
         dprintf("'%s' is not a valid value.  The valid values are 1 and 0 (on and off, respectively)\n", argPtr);
   }

    if(lpValue != NULL) {
        dprintf("WMI Set Trace Dynamic Print: Debugger Extension. Printing is now '%s'\n", lpValue);
    }
}


DECLARE_API( kdtracing )
{
    ULONG       ulStatus = 0;
    ULONG       ulLoggerId;
    LPSTR lpValue = NULL;
    ULONG ulTracingOn = 0;
    TARGET_ADDRESS LoggerContext;
    ULONG LoggerMode;
    ULONG Offset;
    ULONG ulBytesWritten;
    TARGET_ADDRESS PhysAddr;
    PVOID BufferCallback;
    PVOID fpKdReportTraceData;
    
    
    const CHAR *argPtr;
    size_t      sztLen;

    // Defaults
    ulLoggerId = 1;


    // LoggerId ?
    if (args && args[0]) {
        ulLoggerId = (ULONG) GetExpression (args);
    }
    
    
    argPtr = args + strspn (args, " \t\n");
    sztLen = strspn (argPtr, "0123456789");
    if (sztLen > 0) {
        argPtr += sztLen;
    }

    // Guid Definition File
    argPtr = argPtr + strspn (argPtr, " \t\n,");
    if(!_stricmp(argPtr, "1") ) {
        lpValue = "ON";
        ulTracingOn = 1;
    } else if(!_stricmp(argPtr, "0")) {
        lpValue = "OFF";
        ulTracingOn = 0;
    } else {
         dprintf("'%s' is not a valid value.  The valid values are 1 and 0 (on and off, respectively)\n", argPtr);
    }

    if(lpValue != NULL) {
        LoggerContext = FindLoggerContext(ulLoggerId);
        if(LoggerContext != 0) {
            // Setup ReadField's Context, Find Buffer Size
            InitTypeRead (LoggerContext, NT!_WMI_LOGGER_CONTEXT);
            LoggerMode = (ULONG)ReadField(LoggerMode);
            BufferCallback = (PVOID)ReadField(BufferCallback);
            
            if(GetTypeSize("KdReportTraceData") != 0){
                fpKdReportTraceData = (PVOID)GetExpression("KdReportTraceData");
            } else {
                dprintf("ERROR: Could not find proper callback function in symbol file\n");
                return;
            }
            if(ulTracingOn) {
                LoggerMode |= EVENT_TRACE_KD_FILTER_MODE;
                BufferCallback = fpKdReportTraceData;
            } else {
                LoggerMode &= ~EVENT_TRACE_KD_FILTER_MODE;
                if(BufferCallback == fpKdReportTraceData) {
                    BufferCallback = NULL;
                }
            }

            //Get the address of the LoggerMode by finding the offset into the structure
            //so it can be written to
            if(GetFieldOffset("NT!_WMI_LOGGER_CONTEXT", "LoggerMode", &Offset) == 0) {
            	//Add offset to base address and convert to physical
            	  if(TranslateVirtualToPhysical(LoggerContext + (TARGET_ADDRESS)Offset, &PhysAddr)){
                     WritePhysical(PhysAddr, &LoggerMode, sizeof(ULONG), &ulBytesWritten);
            	  }
            } else {
                 dprintf("ERROR:  Could not change tracing mode for logger %d\n", ulLoggerId);
                 return;
            }

            //Do the same for the BufferCallback as above
            if(GetFieldOffset("NT!_WMI_LOGGER_CONTEXT", "BufferCallback", &Offset) == 0) {
                if(TranslateVirtualToPhysical(LoggerContext + (TARGET_ADDRESS)Offset, &PhysAddr)){
                    WritePhysical(PhysAddr, &BufferCallback, sizeof(PVOID), &ulBytesWritten);
            	  }
            } else {
                 dprintf("ERROR:  Could not change tracing mode for logger &d\n", ulLoggerId);
                 return;
            }
             
             dprintf("WMI KD Tracing: Debugger Extension. KD tracing is now '%s' for logger %d\n", lpValue, ulLoggerId);
        }
    }
}

VOID 
wmiDynamicDumpProc(    
    PDEBUG_CONTROL     Ctrl,
    ULONG     Mask,
    PLIST_ENTRY g_GuidListHeadPtr,
    PVOID    pBuffer,
    ULONG    ulBufferLen
    )
//+---------------------------------------------------------------------------
//
//  Function:   wmiDynamicDumpProc
//
//  Synopsis:   Called by WmiFormatTraceData to process the buffers as the come in through a live
//                   debugging session
//
//  Arguments:  Ctrl -> used for the Output function
//                     Mask -> passed directly to the Output function
//                     g_GuidListHeadPtr
//                     pBuffer -> buffer to be processed
//                     ulBufferLen -> size of buffer
//
//  Returns:    <VOID>
//
//  History:    7-10-2000   t-dbloom Created
//
//  Notes:
//
//----------------------------------------------------------------------------
{

    WMIBUFFERINFO   stBufferInfo;
    ULONG           size;
    ULONG           offset;
    WMI_HEADER_TYPE headerType;
    ULONG Alignment;
    WCHAR       wcaOutputLine[4096];
     
    
    //Need to determine alignment based on architecture of target machine
    //I believe alignment is always 8 ??
    Alignment = 8;
 
    memset (&stBufferInfo, 0, sizeof (stBufferInfo));
    stBufferInfo.BufferSource = WMIBS_TRANSITION_LIST;
    stBufferInfo.Buffer = pBuffer;
    stBufferInfo.BufferSize = ulBufferLen;
    stBufferInfo.Alignment = Alignment;
    stBufferInfo.ProcessorNumber = ~((ULONG)0);
    offset = WmiGetFirstTraceOffset (&stBufferInfo);

    // Inspect Each Event
    while ((headerType = WmiGetTraceHeader (pBuffer, offset, &size)) != WMIHT_NONE) {
        ULONG       ulInfo;
        union {
            EVENT_TRACE stEvent;
            CHAR        caEvent[4096];
        } u;

        if (CheckControlC())  break;

        // Get a consistant header
        ulInfo = WmiParseTraceEvent (pBuffer, offset, headerType, &u, sizeof (u));


        wcaOutputLine[0] = 0;


    if(g_fpFormatTraceEvent == NULL) {
        g_fpFormatTraceEvent = GetAddr(FormatTraceEventString);
    }
    if(g_fpFormatTraceEvent != NULL) {    
    	g_fpFormatTraceEvent (g_GuidListHeadPtr, (PEVENT_TRACE) &u.stEvent,
                      (TCHAR *) wcaOutputLine, sizeof (wcaOutputLine),
                      (TCHAR *) NULL);
    } else {
        return;
    }
   	
       Ctrl->lpVtbl->Output(Ctrl, Mask, "%s\n", wcaOutputLine);
        
        size = ((size + (Alignment-1)) / Alignment) * Alignment; //BUGBUG: Need fix in GetTraceHeader or WmiFlush.  Then remove this line.
        offset += size; // Move to next entry.
        if(offset > ulBufferLen) {
            Ctrl->lpVtbl->Output(Ctrl, Mask, "Past buffer end.\n");
            break;
        }
    }

}

ULONG
WmiFormatTraceData(
    PDEBUG_CONTROL     Ctrl,
    ULONG     Mask,
    ULONG     DataLen, 
    PVOID     Data
    )
//+---------------------------------------------------------------------------
//
//  Function:   WmiFormatTraceData
//
//  Synopsis:   Implementation of function called by debugger when kd tracing is enabled through
//                   tracelog. 
//
//  Arguments:  Ctrl 
//                     Mask
//                     DataLen -> size of buffer
//                     Data -> buffer to be processed
//
//  Returns:    0  (has no meaning for now..)
//
//  History:    7-10-2000   t-dbloom Created
//
//  Notes:
//
//----------------------------------------------------------------------------
{
    int i = 1;

    ULONG_PTR    ulStatus = 0;
    
    if(g_ulPrintDynamicMessages) {

        if(g_GuidListHeadPtr == NULL) {
            if(g_fpGetTraceGuids == NULL) {
                g_fpGetTraceGuids = GetAddr(GetTraceGuidsString);
            }
            if(g_fpGetTraceGuids != NULL) {    
                ulStatus = g_fpGetTraceGuids ((TCHAR *) g_pszGuidFileName, &g_GuidListHeadPtr);
            }	
            if (ulStatus == 0) {
                dprintf ("Failed to open Guid file '%hs'\n", g_pszGuidFileName);
                return 0;
            }
        }
        wmiDynamicDumpProc (Ctrl, Mask, g_GuidListHeadPtr, Data, DataLen);
    }
    return 0;
}


FARPROC GetAddr(
	LPCSTR lpProcName
       )
//+---------------------------------------------------------------------------
//
//  Function:   GetAddr
//
//  Synopsis:   Used to get the proc addr of a function in TracePrt.  Prints error message when
//                   needed.
//
//  Arguments:  lpProcName -> name of procedure to be fetched
//
//  Returns:    <VOID>
//
//  History:    7-10-2000   t-dbloom Created
//
//  Notes:
//
//----------------------------------------------------------------------------
{
    FARPROC addr = NULL;

    //See if the handle to TracePrt has already been fetched    
    if(g_hmTracePrtHandle == NULL) {
            g_hmTracePrtHandle = getTracePrtHandle();
    }

    //If TracePrt handle exists, GetProcAddress
    if(g_hmTracePrtHandle != NULL) {
        addr = GetProcAddress(g_hmTracePrtHandle, lpProcName);
    }

    //Error if addr is null
    if(addr == NULL) {
        dprintf("ERROR:  Could not properly load traceprt.dll\n", lpProcName);
    }
    
    return addr;
}


HMODULE getTracePrtHandle(
	)
//+---------------------------------------------------------------------------
//
//  Function:   getTracePrtHandle
//
//  Synopsis:   Used to get a handle to the TracePrt dll.  First looks in the directory that wmitrace
//                   is in, and if it cannot find it there, it looks in the default location (no path given).
//
//  Arguments:  lpProcName -> name of procedure to be fetched
//
//  Returns:    Handle to TracePrt dll, if found
//
//  History:    7-10-2000   t-dbloom Created
//
//  Notes:
//
//----------------------------------------------------------------------------
{
	HMODULE handle = NULL;
       TCHAR drive[10];
       TCHAR filename[MAX_PATH];
       TCHAR path[MAX_PATH];
       TCHAR file[MAX_PATH];
       TCHAR ext[MAX_PATH];
	
	if(g_hmWmiTraceHandle == NULL) {
           g_hmWmiTraceHandle = GetModuleHandle("wmiTrace.dll");
	}

	if (GetModuleFileName(g_hmWmiTraceHandle, filename, MAX_PATH) == MAX_PATH) {
        filename[MAX_PATH-1] = '\0' ;
    }


	_splitpath( filename, drive, path, file, ext );
       strcpy(file, "traceprt");
       _makepath( filename, drive, path, file, ext );

       //Try to get a handle to traceprt using full path as obtained above using path of wmitrace
       handle = LoadLibrary(filename);

      //If this didn't work, just try traceprt.dll without a path
       if(handle == NULL) {
           handle = LoadLibrary("traceprt.dll");
       }

	return handle;

}

BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,  // handle to DLL module
    DWORD fdwReason,     // reason for calling function
    LPVOID lpReserved )  // reserved
{
    // Perform actions based on the reason for calling.
    switch( fdwReason ) 
    { 
        case DLL_PROCESS_ATTACH:
            EtwpInitializeDll();
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
         // Do thread-specific cleanup.
            break;

        case DLL_PROCESS_DETACH:
            EtwpDeinitializeDll();         // Perform any necessary cleanup.
            break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmifilt\filter.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.h

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <wmilib.h>
#include "filtdata.h"

enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};

//
// Data structures for storing WMI data



#define DEVICE_EXTENSION_SIGNATURE 'rtlF'

typedef struct DEVICE_EXTENSION {

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    /*
     *  The device object that this filter driver created.
     */
    PDEVICE_OBJECT filterDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG pendingActionCount;
    KEVENT removeEvent;

    ULONG TotalIrpCount;
    ULONG WmiIrpCount;
    
    /*
     * WMILIB callbacks and guid list
     */
    WMILIB_CONTEXT WmiLib;

    /*
     * Data storage for wmi data blocks
    */
    ULONG Ec1Count;
    ULONG Ec1Length[4];
    ULONG Ec1ActualLength[4];
    PEC1 Ec1[4];
    
    ULONG Ec2Count;
    ULONG Ec2Length[4];
    ULONG Ec2ActualLength[4];
    PEC2 Ec2[4];
    
    BOOLEAN NoClassEnabled;
    BOOLEAN ClassEnabled;

};


/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "Filt" in a little-endian memory byte dump.
 */
#define FILTER_TAG (ULONG)'tliF'


#if DBG
    #define DBGOUT(params_in_parentheses)   \
        {                                               \
            DbgPrint("'FILTER> "); \
            DbgPrint params_in_parentheses; \
            DbgPrint("\n"); \
        }
    #define TRAP(msg)  \
        {   \
            DBGOUT(("TRAP at file %s, line %d: '%s'.", __FILE__, __LINE__, msg)); \
            DbgBreakPoint(); \
        }
#else
    #define DBGOUT(params_in_parentheses)
    #define TRAP(msg)
#endif


/*
 *  Function externs
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    VA_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        VA_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    VA_SystemControl(struct DEVICE_EXTENSION *devExt, PIRP irp, PBOOLEAN passIrpDown);
NTSTATUS    GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt);
NTSTATUS    CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        RegistryAccessSample(PDEVICE_OBJECT devObj);
NTSTATUS    FilterInitializeWmiDataBlocks(struct DEVICE_EXTENSION *devExt);
void FilterWmiCleanup(
    struct DEVICE_EXTENSION *devExt
    );

extern UNICODE_STRING FilterRegistryPath;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmifilt\pnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pnp.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, VA_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
#endif

            
NTSTATUS VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    devExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_PnP, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 

    switch (irpSp->MinorFunction){

        case IRP_MN_START_DEVICE:
            DBGOUT(("START_DEVICE")); 

            devExt->state = STATE_STARTING;

            /*
             *  First, send the START_DEVICE irp down the stack
             *  synchronously to start the lower stack.
             *  We cannot do anything with our device object
             *  before propagating the START_DEVICE this way.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallNextDriverSync(devExt, irp);

            if (NT_SUCCESS(status)){
                /*
                 *  Now that the lower stack is started,
                 *  do any initialization required by this device object.
                 */
                status = GetDeviceCapabilities(devExt);
                if (NT_SUCCESS(status)){
                    devExt->state = STATE_STARTED;
                    /*
                     * Now that device is started, register with WMI
                    */
                    IoWMIRegistrationControl(devExt->filterDevObj,
                                             WMIREG_ACTION_REGISTER);
                }
                else {
                    devExt->state = STATE_START_FAILED;
                }
            }
            else {
                devExt->state = STATE_START_FAILED;
            }
            completeIrpHere = TRUE;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            break;

        case IRP_MN_STOP_DEVICE:
            if (devExt->state == STATE_SUSPENDED){
                status = STATUS_DEVICE_POWER_FAILURE;
                completeIrpHere = TRUE;
            }
            else {
                /*
                 *  Only set state to STOPPED if the device was
                 *  previously started successfully.
                 */
                if (devExt->state == STATE_STARTED){
                    devExt->state = STATE_STOPPED;
                }
            }
            break;
      
        case IRP_MN_QUERY_REMOVE_DEVICE:
            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            DBGOUT(("SURPRISE_REMOVAL")); 

            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;

            /*
             *  For now just set the STATE_REMOVING state so that
             *  we don't do any more IO.  We are guaranteed to get
             *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
             *  the remove processing there.
             */
            devExt->state = STATE_REMOVING;

            break;

        case IRP_MN_REMOVE_DEVICE:
            /*
             *  Check the current state to guard against multiple
             *  REMOVE_DEVICE IRPs.
             */
            DBGOUT(("REMOVE_DEVICE")); 
            if (devExt->state != STATE_REMOVED){

                devExt->state = STATE_REMOVED;

                /*
                 *  Send the REMOVE IRP down the stack asynchronously.
                 *  Do not synchronize sending down the REMOVE_DEVICE
                 *  IRP, because the REMOVE_DEVICE IRP must be sent
                 *  down and completed all the way back up to the sender
                 *  before we continue.
                 */
                IoCopyCurrentIrpStackLocationToNext(irp);
                status = IoCallDriver(devExt->physicalDevObj, irp);
                justReturnStatus = TRUE;

                DBGOUT(("REMOVE_DEVICE - waiting for %d irps to complete...",
                        devExt->pendingActionCount));  

                /*
                 *  We must for all outstanding IO to complete before
                 *  completing the REMOVE_DEVICE IRP.
                 *
                 *  First do an extra decrement on the pendingActionCount.
                 *  This will cause pendingActionCount to eventually
                 *  go to -1 once all asynchronous actions on this
                 *  device object are complete.
                 *  Then wait on the event that gets set when the
                 *  pendingActionCount actually reaches -1.
                 */
                DecrementPendingActionCount(devExt);
                KeWaitForSingleObject(  &devExt->removeEvent,
                                        Executive,      // wait reason
                                        KernelMode,
                                        FALSE,          // not alertable
                                        NULL );         // no timeout

                DBGOUT(("REMOVE_DEVICE - ... DONE waiting. ")); 

                /*
                 *  Now that the device is going away unregister with WMI
                 *  Note that we wait until all WMI irps are completed
                 *  before unregistering since unregistering will block
                 *  until all WMI irps are completed.
                 */
                FilterWmiCleanup(devExt);
                IoWMIRegistrationControl(devExt->filterDevObj,
                                             WMIREG_ACTION_DEREGISTER);
	
                /*
                 *  Detach our device object from the lower 
                 *  device object stack.
                 */
                IoDetachDevice(devExt->topDevObj);

                /*
                 *  Delete our device object.
                 *  This will also delete the associated device extension.
                 */
                IoDeleteDevice(devExt->filterDevObj);
            }
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
        default:
            break;


    }

    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack asynchronously.
         */
    }
    else if (completeIrpHere){
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(devExt->physicalDevObj, irp);
    }

    return status;
}





NTSTATUS GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    devExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(devExt->physicalDevObj->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        RtlZeroMemory(  &devExt->deviceCapabilities, 
                        sizeof(DEVICE_CAPABILITIES));
        nextSp->Parameters.DeviceCapabilities.Capabilities = 
                        &devExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(devExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmifilt\makefile.inc ===
#
# generate auxilary files from the binary mof (bmf) file
#
# filtdata.h has definitions for the guids, data structures and definitions
#                of the method ids.
#
# filter.vbs is a ready to run vbscript applet that will query all classes
#            in the mof. Once you install your driver, run the script
#            at the command line by typing: filter.vbs.

clean:
    del filtdata.h filter.vbs

$(O)\filter.bmf : $(O)\filter.mof

$(O)\filter.vbs $(O)\filtdata.h $(O)\filter.x: $(O)\filter.bmf
    wmimofck -hfiltdata.h -tfilter.vbs -xfilter.x $(O)\filter.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmifilt\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
#endif


NTSTATUS CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(devExt);
    status = CallDriverSync(devExt->physicalDevObj, irp);
    DecrementPendingActionCount(devExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedIncrement(&devExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedDecrement(&devExt->pendingActionCount);    

    if (devExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((devExt->state == STATE_REMOVING) || 
               (devExt->state == STATE_REMOVED));
        KeSetEvent(&devExt->removeEvent, 0, FALSE);
    }
}



VOID RegistryAccessSample(PDEVICE_OBJECT devObj)
/*++

Routine Description:

    SAMPLE showing how to access the device-specific registry key 

Arguments:

    devObj - device object pointer
             NOTE: This must not be the functional device object
                   created by this filter driver, because that
                   device object does not have a devnode area
                   in the registry; pass the device object of
                   the device object for which this driver is
                   a filter.  This is the device object passed
                   to VA_AddDevice.

Return Value:

    VOID

--*/
{
    NTSTATUS status;
    HANDLE hRegDevice;

    status = IoOpenDeviceRegistryKey(   devObj, 
                                        PLUGPLAY_REGKEY_DEVICE, 
                                        KEY_READ, 
                                        &hRegDevice);
    if (NT_SUCCESS(status)){
        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;

        RtlInitUnicodeString(&keyName, L"SampleFilterParam"); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            keyName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);
        keyValueInfo = ExAllocatePoolWithTag(   PagedPool,
                                                keyValueTotalSize,
                                                FILTER_TAG);
        if (keyValueInfo){
            status = ZwQueryValueKey(   hRegDevice,
                                        &keyName,
                                        KeyValueFullInformation,
                                        keyValueInfo,
                                        keyValueTotalSize,
                                        &actualLength); 
            if (NT_SUCCESS(status)){
                ULONG value;

                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));
                                
                value = *((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                DBGOUT(("RegistryAccessSample: value is %xh.", value));
            }
            else {
                DBGOUT(("ZwQueryValueKey failed with %xh.", status));
            }
	    
	    ExFreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGOUT(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmifilt\filter.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    filter.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
        #pragma alloc_text(PAGE, VA_AddDevice)
        #pragma alloc_text(PAGE, VA_DriverUnload)
#endif


NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);

    DBGOUT(("DriverEntry")); 

    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++){
        DriverObject->MajorFunction[i] = VA_Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = VA_AddDevice;
    DriverObject->DriverUnload = VA_DriverUnload;

    //
    // Remember registry path since it is needed for WMI registration
    FilterRegistryPath.Length = 0;
    FilterRegistryPath.MaximumLength = RegistryPath->Length;
    FilterRegistryPath.Buffer = ExAllocatePoolWithTag(PagedPool, 
                                                RegistryPath->Length+2,
                                                FILTER_TAG);
    RtlCopyUnicodeString(&FilterRegistryPath, RegistryPath);

    
    return STATUS_SUCCESS;
}


NTSTATUS VA_AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
    
    PAGED_CODE();

    DBGOUT(("VA_AddDevice: drvObj=%ph, pdo=%ph", driverObj, physicalDevObj)); 

    status = IoCreateDevice(    driverObj, 
                                sizeof(struct DEVICE_EXTENSION),
                                NULL,           // name for this device
                                FILE_DEVICE_UNKNOWN, 
                                FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                FALSE,          // not exclusive
                                &filterDevObj); // our device object

    if (NT_SUCCESS(status)){
        struct DEVICE_EXTENSION *devExt;

        ASSERT(filterDevObj);

        /*
         *  Initialize device extension for new device object
         */
        devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature = DEVICE_EXTENSION_SIGNATURE;
        devExt->state = STATE_INITIALIZED;
        devExt->filterDevObj = filterDevObj;
        devExt->physicalDevObj = physicalDevObj;
        
        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);

        /*
         *  Clear the initializing bit from the new device object's flags.
         */
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
         *  The DO_POWER_PAGABLE bit of a device object
         *  indicates to the kernel that the power-handling
         *  code of the corresponding driver is pageable, and
         *  so must be called at IRQL 0.
         *  As a filter driver, we do not want to change the power
         *  behavior of the driver stack in any way; therefore,
         *  we copy this bit from the lower device object.
         */
        ASSERT(!(filterDevObj->Flags & DO_POWER_PAGABLE)); 
        filterDevObj->Flags |= (physicalDevObj->Flags & DO_POWER_PAGABLE);

        /*
         *  Attach the new device object to the top of the device stack.
         */
        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
        DBGOUT(("created filterDevObj %ph attached to %ph.", filterDevObj, devExt->topDevObj));

        /*
         *  This is a do-nothing call to a sample function which
         *  demonstrates how to read the device's registry area.
         *  Note that you cannot make this call on devExt->filterDevObj
         *  because a filter device object does not have a devNode.
         *  We pass devExt->physicalDevObj, which is the device object
         *  for which this driver is a filter driver.
         */
        RegistryAccessSample(devExt->physicalDevObj);

        /*
         * WMI specific initialization
        */
        FilterInitializeWmiDataBlocks(devExt);  
    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID VA_DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    DBGOUT(("VA_DriverUnload")); 
    
    //
    // Free memory used by registry path
    ExFreePool(FilterRegistryPath.Buffer);
}


NTSTATUS VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    Irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    InterlockedIncrement(&devExt->TotalIrpCount);
    
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

    DBGOUT(("VA_Dispatch: majorFunc=%d, minorFunc=%d", 
            (ULONG)majorFunc, (ULONG)minorFunc)); 

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(devExt);
    }

    if ((majorFunc != IRP_MJ_PNP) &&
        (majorFunc != IRP_MJ_CLOSE) &&
        ((devExt->state == STATE_REMOVING) ||
         (devExt->state == STATE_REMOVED))){

        /*
         *  While the device is being removed, 
         *  we only pass down the PNP and CLOSE IRPs.
         *  We fail all other IRPs.
         */
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        passIrpDown = FALSE;
    }
    else {
        switch (majorFunc){

            case IRP_MJ_PNP:
                status = VA_PnP(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_POWER:
                status = VA_Power(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_SYSTEM_CONTROL:
                status = VA_SystemControl(devExt, Irp, &passIrpDown);
                break;
                
            case IRP_MJ_CREATE:
            case IRP_MJ_CLOSE:
            case IRP_MJ_DEVICE_CONTROL:
            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            default:
                /*
                 *  For unsupported IRPs, we simply send the IRP
                 *  down the driver stack.
                 */
                break;
        }
    }

    if (passIrpDown){
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = IoCallDriver(devExt->topDevObj, Irp);
    }

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(devExt);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmifilt\power.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.c

Abstract: NULL filter driver -- boilerplate code

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include "filter.h"



NTSTATUS VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for Power IRPs (MajorFunction == IRP_MJ_Power)

    Note: We may or may not have set the DO_POWER_PAGABLE bit
          for the filter device object in AddDevice().
          Therefore, we don't know whether or not this function
          can be called at DISPATCH_LEVEL; so the power-handling
          code must be locked.

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_Power, minorFunc = %d ", (ULONG)irpSp->MinorFunction)); 


    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    /*
                     *  For system power states, just pass the IRP down.
                     */
                    break;

                case DevicePowerState:

                    switch (irpSp->Parameters.Power.State.DeviceState) {

                        case PowerDeviceD0:
                            /*
                             *  Resume from APM Suspend
                             *
                             *  Do nothing here; 
                             *  Send down the read IRPs in the completion
                             *  routine for this (the power) IRP.
                             */
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (devExt->state == STATE_STARTED){
                                devExt->state = STATE_SUSPENDED;
                            }
                            break;

                    }
                    break;

            }
            break;

    }


    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp.
     */
    PoStartNextPowerIrp(irp);

    /*
     *  Send the IRP down the driver stack,
     *  using PoCallDriver (not IoCallDriver, as for non-power irps).
     */
    IoCopyCurrentIrpStackLocationToNext(irp);
    IncrementPendingActionCount(devExt);
    IoSetCompletionRoutine( irp, 
                            VA_PowerComplete, 
                            (PVOID)devExt,  // context
                            TRUE, 
                            TRUE, 
                            TRUE);
    status = PoCallDriver(devExt->physicalDevObj, irp);

    return status;
}


NTSTATUS VA_PowerComplete(
                            IN PDEVICE_OBJECT devObj, 
                            IN PIRP irp, 
                            IN PVOID context)
/*++

Routine Description:

      Completion routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devObj - targetted device object
    irp - Io Request Packet
    context - context value passed to IoSetCompletionRoutine by VA_Power

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    struct DEVICE_EXTENSION *devExt = (struct DEVICE_EXTENSION *)context;

    ASSERT(devExt);
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE); 

    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (devExt->state == STATE_SUSPENDED){
                                    devExt->state = STATE_STARTED;
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }

    /*
     *  Decrement the pendingActionCount, which we incremented in VA_Power.
     */
    DecrementPendingActionCount(devExt);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmifilt\wmisamp.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   wmisamp.c

Abstract:

    Sample device driver whose purpose is to show various mechanisms for
    using WMI in a kernel mode driver. Specific things shown are

    Events
    Event references
    Queries, Sets
    Methods
    Updating guid registration

Environment:

    WDM, NT and Windows 98

Revision History:


--*/

#include <WDM.H>

#include "filter.h"

#include <wmistr.h>
#include <wmiguid.h>

//
// default Date/Time structure
#define FilterDateTime L"19940525133015.000000-300"

NTSTATUS
FilterFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

NTSTATUS
FilterExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
FilterSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG InstanceIndex,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
FilterSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
FilterQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
FilterQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

void FilterSetEc1(
    struct DEVICE_EXTENSION * devExt,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    );

void FilterSetEc2(
    struct DEVICE_EXTENSION * devExt,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,FilterQueryWmiRegInfo)
#pragma alloc_text(PAGE,FilterQueryWmiDataBlock)
#pragma alloc_text(PAGE,FilterSetWmiDataBlock)
#pragma alloc_text(PAGE,FilterSetWmiDataItem)
#pragma alloc_text(PAGE,FilterExecuteWmiMethod)
#pragma alloc_text(PAGE,FilterFunctionControl)
#endif


#ifdef USE_BINARY_MOF_QUERY
//
// MOF data can be reported by a device driver via a resource attached to
// the device drivers image file or in response to a query on the binary
// mof data guid. Here we define global variables containing the binary mof
// data to return in response to a binary mof guid query. Note that this
// data is defined to be in a PAGED data segment since it does not need to
// be in nonpaged memory. Note that instead of a single large mof file
// we could have broken it into multiple individual files. Each file would
// have its own binary mof data buffer and get reported via a different
// instance of the binary mof guid. By mixing and matching the different
// sets of binary mof data buffers a "dynamic" composite mof would be created.

#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg("PAGED")
#endif

UCHAR FilterBinaryMofData[] =
{
    #include "filter.x"
};
#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif
#endif


//
// Create data structures for identifying the guids and reporting them to
// WMI. Since the WMILIB callbacks pass an index into the guid list we make
// definitions for the various guids indicies.
//
#define FilterClass1 0
#define FilterClass2 1
#define FilterClass3 2
#define FilterClass4 3
#define FilterClass5 4
#define FilterClass6 5
#define FilterClass7 6
#define FilterGetSetData   7
#define FilterFireEvent    8
#define FilterEventClass1  9
#define FilterEventClass2  10
#define FilterEventClass3  11
#define FilterEventClass4  12
#define FilterEventClass5  13
#define FilterEventClass6  14
#define FilterEventClass7  15
#define FilterEventReferenceClass  16
#define FilterIrpCount  17
#define BinaryMofGuid   18

GUID FilterClass1Guid = Vendor_SampleClass1Guid;
GUID FilterClass2Guid = Vendor_SampleClass2Guid;
GUID FilterClass3Guid = Vendor_SampleClass3Guid;
GUID FilterClass4Guid = Vendor_SampleClass4Guid;
GUID FilterClass5Guid = Vendor_SampleClass5Guid;
GUID FilterClass6Guid = Vendor_SampleClass6Guid;
GUID FilterClass7Guid = Vendor_SampleClass7Guid;
GUID FilterGetSetDataGuid =   Vendor_GetSetDataGuid;
GUID FilterFireEventGuid =    Vendor_FireEventGuid;
GUID FilterEventClass1Guid =  Vendor_EventClass1Guid;
GUID FilterEventClass2Guid =  Vendor_EventClass2Guid;
GUID FilterEventClass3Guid =  Vendor_EventClass3Guid;
GUID FilterEventClass4Guid =  Vendor_EventClass4Guid;
GUID FilterEventClass5Guid =  Vendor_EventClass5Guid;
GUID FilterEventClass6Guid =  Vendor_EventClass6Guid;
GUID FilterEventClass7Guid =  Vendor_EventClass7Guid;
GUID FilterEventReferenceClassGuid = Vendor_EventReferenceClassGuid;
GUID FilterIrpCountGuid = Vendor_IrpCounterGuid;
GUID FilterBinaryMofGuid =         BINARY_MOF_GUID;

WMIGUIDREGINFO FilterGuidList[] =
{
    {
        &FilterClass1Guid,            // Guid
        1,                               // # of instances in each device
        WMIREG_FLAG_EXPENSIVE            // Flag as expensive to collect
    },

    {
        &FilterClass2Guid,
        1,
        0
    },

    {
        &FilterClass3Guid,
        1,
        0
    },

    {
        &FilterClass4Guid,
        1,
        0
    },

    {
        &FilterClass5Guid,
        1,
        0
    },

    {
        &FilterClass6Guid,
        1,
        0
    },

    {
        &FilterClass7Guid,
        1,
        0
    },

    {
        &FilterGetSetDataGuid,
        1,
        0
    },

    {
        &FilterFireEventGuid,
        1,
        0
    },

    {
        &FilterEventClass1Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID            // Flag as an event
    },

    {
        &FilterEventClass2Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &FilterEventClass3Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &FilterEventClass4Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &FilterEventClass5Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &FilterEventClass6Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &FilterEventClass7Guid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &FilterEventReferenceClassGuid,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        &FilterIrpCountGuid,
        1,
        0
    },

    {
        &FilterBinaryMofGuid,
        1,
#ifdef USE_BINARY_MOF_QUERY
        0
#else
        WMIREG_FLAG_REMOVE_GUID
#endif
    }

};

#define FilterGuidCount (sizeof(FilterGuidList) / sizeof(WMIGUIDREGINFO))

//
// We need to hang onto the registry path passed to our driver entry so that
// we can return it in the QueryWmiRegInfo callback.
//
UNICODE_STRING FilterRegistryPath;

NTSTATUS VA_SystemControl(
    struct DEVICE_EXTENSION *devExt,
    PIRP irp,
    PBOOLEAN passIrpDown
    )
/*++

Routine Description:

    Dispatch routine for System Control IRPs (MajorFunction == IRP_MJ_SYSTEM_CONTROL)

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet
    *passIrpDown - returns with whether to pass irp down stack

Return Value:

    NT status code

--*/
{
    PWMILIB_CONTEXT wmilibContext;
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;

    InterlockedIncrement(&devExt->WmiIrpCount);

    wmilibContext = &devExt->WmiLib;

    //
    // Call Wmilib helper function to crack the irp. If this is a wmi irp
    // that is targetted for this device then WmiSystemControl will callback
    // at the appropriate callback routine.
    //
    status = WmiSystemControl(wmilibContext,
                              devExt->filterDevObj,
                              irp,
                              &disposition);

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            *passIrpDown = FALSE;
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now.
            *passIrpDown = FALSE;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            *passIrpDown = TRUE;
            break;
        }

        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            *passIrpDown = TRUE;
            break;
        }
    }

    return(status);
}

NTSTATUS
FilterInitializeWmiDataBlocks(
    IN struct DEVICE_EXTENSION *devExt
    )
/*++
Routine Description:
    This routine is called to create a new instance of the device

Arguments:
    devExt is device extension

Return Value:

--*/
{
    PWMILIB_CONTEXT wmilibInfo;
    ULONG i;
    PEC1 Ec1;
    PEC2 Ec2;
    UCHAR Ec[sizeof(EC2)];

    //
    // Fill in the WMILIB_CONTEXT structure with a pointer to the
    // callback routines and a pointer to the list of guids
    // supported by the driver
    //
    wmilibInfo = &devExt->WmiLib;
    wmilibInfo->GuidCount = FilterGuidCount;
    wmilibInfo->GuidList = FilterGuidList;
    wmilibInfo->QueryWmiRegInfo = FilterQueryWmiRegInfo;
    wmilibInfo->QueryWmiDataBlock = FilterQueryWmiDataBlock;
    wmilibInfo->SetWmiDataBlock = FilterSetWmiDataBlock;
    wmilibInfo->SetWmiDataItem = FilterSetWmiDataItem;
    wmilibInfo->ExecuteWmiMethod = FilterExecuteWmiMethod;
    wmilibInfo->WmiFunctionControl = FilterFunctionControl;

    //
    // Initialize the wmi data blocks with specific data
    //
    devExt->Ec1Count = 3;
    devExt->Ec2Count = 3;
    for (i = 0; i < 4; i++)
    {
        Ec1 = (PEC1)Ec;
        memset(Ec1, i, sizeof(EC1));
        memcpy(Ec1->Xdatetime, FilterDateTime, 25*sizeof(WCHAR));

        ASSERT(devExt->Ec1[i] == NULL);
        FilterSetEc1(devExt,
                      (PUCHAR)Ec1,
                      sizeof(EC1),
                      i);


        Ec2 = (PEC2)Ec;
        memset(Ec2, i, sizeof(EC2));
        memcpy(Ec2->Xdatetime, FilterDateTime, 25*sizeof(WCHAR));

        ASSERT(devExt->Ec2[i] == NULL);
        FilterSetEc2(devExt,
                      (PUCHAR)Ec2,
                      sizeof(EC2),
                      i);
    }
    return(STATUS_SUCCESS);
}

void FilterWmiCleanup(
    struct DEVICE_EXTENSION *devExt
    )
{
    ULONG i;

    for (i = 0; i < 4; i++)
    {
        if (devExt->Ec1[i] != NULL)
        {
            ExFreePool(devExt->Ec1[i]);
            devExt->Ec1[i] = NULL;
        }

        if (devExt->Ec2[i] != NULL)
        {
            ExFreePool(devExt->Ec2[i]);
            devExt->Ec2[i] = NULL;
        }
    }
}

NTSTATUS
FilterQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose registration info is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. The caller
         does NOT free this buffer.

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL. The caller does NOT free this
        buffer.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;

    //
    // Return the registry path for this driver. This is required so WMI
    // can find your driver image and can attribute any eventlog messages to
    // your driver.
    *RegistryPath = &FilterRegistryPath;

#ifndef USE_BINARY_MOF_QUERY
    //
    // Return the name specified in the .rc file of the resource which
    // contains the bianry mof data. By default WMI will look for this
    // resource in the driver image (.sys) file, however if the value
    // MofImagePath is specified in the driver's registry key
    // then WMI will look for the resource in the file specified there.
    RtlInitUnicodeString(MofResourceName, L"MofResourceName");
#endif

    //
    // Specify that the driver wants WMI to automatically generate instance
    // names for all of the data blocks based upon the device stack's
    // device instance id. Doing this is STRONGLY recommended since additional
    // information about the device would then be available to callers.
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *Pdo = devExt->physicalDevObj;

    return(STATUS_SUCCESS);
}


ULONG FilterGetEc1(
    struct DEVICE_EXTENSION * devExt,
    PUCHAR Buffer,
    ULONG Index
    )
{
    RtlCopyMemory(Buffer,
                  devExt->Ec1[Index],
                  devExt->Ec1Length[Index]);

    return(devExt->Ec1Length[Index]);
}

ULONG FilterGetActualEc1(
    struct DEVICE_EXTENSION * devExt,
    PUCHAR Buffer,
    ULONG Index
    )
{
    RtlCopyMemory(Buffer,
                  devExt->Ec1[Index],
                  devExt->Ec1ActualLength[Index]);

    return(devExt->Ec1ActualLength[Index]);
}

void FilterSetEc1(
    struct DEVICE_EXTENSION * devExt,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    )
{
    PEC1 New;
    ULONG NewLength;

    NewLength = (Length + 7) & ~7;

    New = ExAllocatePoolWithTag(PagedPool, NewLength, FILTER_TAG);
    if (New != NULL)
    {
        if (devExt->Ec1[Index] != NULL)
        {
            ExFreePool(devExt->Ec1[Index]);
        }
        devExt->Ec1[Index] = New;
        devExt->Ec1Length[Index] = NewLength;
        devExt->Ec1ActualLength[Index] = Length;
        RtlCopyMemory(New,
                  Buffer,
                  Length);
    }
}


ULONG FilterGetEc2(
    struct DEVICE_EXTENSION * devExt,
    PUCHAR Buffer,
    ULONG Index
    )
{
    RtlCopyMemory(Buffer,
                  devExt->Ec2[Index],
                  devExt->Ec2Length[Index]);

    return(devExt->Ec2Length[Index]);
}

ULONG FilterGetActualEc2(
    struct DEVICE_EXTENSION * devExt,
    PUCHAR Buffer,
    ULONG Index
    )
{
    RtlCopyMemory(Buffer,
                  devExt->Ec2[Index],
                  devExt->Ec2ActualLength[Index]);

    return(devExt->Ec2ActualLength[Index]);
}

void FilterSetEc2(
    struct DEVICE_EXTENSION * devExt,
    PUCHAR Buffer,
    ULONG Length,
    ULONG Index
    )
{
    PEC2 New;
    ULONG NewLength;

    NewLength = (Length + 7) & ~7;

    New = ExAllocatePoolWithTag(PagedPool, NewLength, FILTER_TAG);
    if (New != NULL)
    {
        if (devExt->Ec2[Index] != NULL)
        {
            ExFreePool(devExt->Ec2[Index]);
        }
        devExt->Ec2[Index] = New;
        devExt->Ec2Length[Index] = NewLength;
        devExt->Ec2ActualLength[Index] = Length;
        RtlCopyMemory(New,
                  Buffer,
                  Length);
    }
}

NTSTATUS
FilterQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. If the driver can satisfy the query within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the query is satisfied.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;
    ULONG sizeNeeded;
    ULONG i;
    ULONG LastInstanceIndex;
    ULONG sizeUsed, vlSize;

    switch(GuidIndex)
    {
        case FilterEventReferenceClass:
        case FilterClass1:
        case FilterClass2:
        {
            // plain EC1
            sizeNeeded = devExt->Ec1Length[0];
            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                *InstanceLengthArray = sizeNeeded;
                FilterGetEc1(devExt, Buffer, 0);
                status = STATUS_SUCCESS;
            }
            break;
        }

        case FilterClass3:
        {
            // fixed array of EC1
            sizeNeeded = 0;
            for (i = 0; i < 4; i++)
            {
                //
                // Each embedded class in an array of embedded classes
                // must be naturally aligned, and any padding between
                // the embedded classes must be included in the calculation
                // of the size of buffer needed to fufill the request.
                // Since the largest element in the embedded structure is
                // 8 bytes we pad the structure size out to 8 bytes.
                sizeNeeded += (devExt->Ec1Length[i] + 7) & ~7;
            }

            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                *InstanceLengthArray = sizeNeeded;
                for (i = 0; i < 4; i++)
                {
                    //
                    // Copy each embedded class from storage into the
                    // output buffer. Note that we make sure that each
                    // embedded class begins on a natural alignment, in
                    // this case an 8 byte boundry
                    sizeUsed = FilterGetEc1(devExt, Buffer, i);
                    Buffer += (sizeUsed+7) & ~7;
                }
                status = STATUS_SUCCESS;
            }
            break;
        }

        case FilterClass4:
        {
            // variable array of EC1

            //
            // Account for the size of the ULONG plus padding so that the
            // embedded classes start on an 8 byte boundry
            sizeNeeded = (sizeof(ULONG) + 7) & ~7;

            vlSize = devExt->Ec1Count;

            for (i = 0; i < vlSize; i++)
            {
                sizeNeeded += (devExt->Ec1Length[i] + 7) &~7;
            }

            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                *InstanceLengthArray = sizeNeeded;
                *((PULONG)Buffer) = vlSize;
                Buffer += (sizeof(ULONG) + 7) & ~7;
                for (i = 0; i < vlSize; i++)
                {
                    sizeUsed = FilterGetEc1(devExt, Buffer, i);
                    Buffer += (sizeUsed+7) & ~7;
                }
                status = STATUS_SUCCESS;
            }
            break;
        }

        case FilterClass5:
        {
            // plain EC2
            sizeNeeded = devExt->Ec2Length[0];
            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                *InstanceLengthArray = sizeNeeded;
                FilterGetEc2(devExt, Buffer, 0);
                status = STATUS_SUCCESS;
            }
            break;
        }

        case FilterClass6:
        {
            // fixed array EC2
            sizeNeeded = 0;
            for (i = 0; i < 4; i++)
            {
                sizeNeeded += (devExt->Ec2Length[i] + 7) & ~7;
            }

            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                *InstanceLengthArray = sizeNeeded;
                for (i = 0; i < 4; i++)
                {
                    sizeUsed = FilterGetEc2(devExt, Buffer, i);
                    Buffer += (sizeUsed + 7) & ~7;
                }
                status = STATUS_SUCCESS;
            }
            break;
        }

        case FilterClass7:
        {
            // VL array EC2


            sizeNeeded = (sizeof(ULONG) + 7) & ~7;

            vlSize = devExt->Ec2Count;
            for (i = 0; i < vlSize; i++)
            {
                sizeNeeded += devExt->Ec2Length[i];
            }

            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                *InstanceLengthArray = sizeNeeded;
                *((PULONG)Buffer) = vlSize;
                Buffer += (sizeof(ULONG)+7) & ~7;
                for (i = 0; i < vlSize; i++)
                {
                    sizeUsed = FilterGetEc2(devExt, Buffer, i);
                    Buffer += (sizeUsed + 7) & ~7;
                }
                status = STATUS_SUCCESS;
            }
            break;
        }

        case FilterIrpCount:
        {
            sizeNeeded = sizeof(Vendor_IrpCounter);
            if (BufferAvail >= sizeNeeded)
            {
                PVendor_IrpCounter IrpCounter = (PVendor_IrpCounter)Buffer;

                IrpCounter->TotalIrpCount = devExt->TotalIrpCount;
                IrpCounter->TotalIrpRate = devExt->TotalIrpCount;
                IrpCounter->WmiIrpCount = devExt->WmiIrpCount;
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }
        
        case FilterFireEvent:
        case FilterGetSetData:
        {
            //
            // Method classes do not have any data within them, but must
            // repond successfully to queries so that WMI method operation
            // work successfully.
            sizeNeeded = sizeof(USHORT);
            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            }
            break;
        }

#ifdef USE_BINARY_MOF_QUERY
        case BinaryMofGuid:
        {
            sizeNeeded = sizeof(FilterBinaryMofData);

            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                RtlCopyMemory(Buffer, FilterBinaryMofData, sizeNeeded);
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            }
            break;
        }
#endif

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    //
    // Complete the irp. If there was not enough room in the output buffer
    // then status is STATUS_BUFFER_TOO_SMALL and sizeNeeded has the size
    // needed to return all of the data. If there was enough room then
    // status is STATUS_SUCCESS and sizeNeeded is the actual number of bytes
    // being returned.
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}


//
// Use this size when checking that the input data block is the correct
// size. The compiler will add padding to the end of the structure if
// you use sizeof(EC1), but WMI may pass a data block that is the exact
// size of the data without padding.
//
#define EC1Size (FIELD_OFFSET(EC1, Xdatetime) + 25*sizeof(WCHAR))

NTSTATUS FilterSetEc1Worker(
    struct DEVICE_EXTENSION * devExt,
    ULONG BufferSize,
    ULONG Index,
    PUCHAR Buffer,
    PULONG BufferUsed
    )
{
    ULONG blockLen;
    NTSTATUS status;
    PEC1 Ec1;

    Ec1 = (PEC1)Buffer;
    if (BufferSize >= EC1Size)
    {
        blockLen = sizeof(EC1);

		FilterSetEc1(devExt,
                            Buffer,
                            blockLen,
                            Index);
		*BufferUsed = (blockLen+7) & ~7;
		status = STATUS_SUCCESS;
    } else {
        status = STATUS_INVALID_PARAMETER_MIX;
    }
    return(status);
}

//
// Use this size when checking that the input data block is the correct
// size. The compiler will add padding to the end of the structure if
// you use sizeof(EC2), but WMI may pass a data block that is the exact
// size of the data without padding.
//
#define EC2Size (FIELD_OFFSET(EC2, Xdatetime) + 25*sizeof(WCHAR))

NTSTATUS FilterSetEc2Worker(
    struct DEVICE_EXTENSION * devExt,
    ULONG BufferSize,
    ULONG Index,
    PUCHAR Buffer,
    PULONG BufferUsed
    )
{
    ULONG blockLen;
    NTSTATUS status;
    PUSHORT wPtr;
    PEC2 Ec2;

    Ec2 = (PEC2)Buffer;
    if (BufferSize >= EC2Size)
    {
        blockLen = sizeof(EC2);

		FilterSetEc2(devExt,
                            Buffer,
                            blockLen,
                            Index);
		*BufferUsed = (blockLen+7) & ~7;
		status = STATUS_SUCCESS;
    } else {
        status = STATUS_INVALID_PARAMETER_MIX;
    }
    return(status);
}



NTSTATUS
FilterSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to change the contents of
    a data block. If the driver can change the data block within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the data is changed.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG bufferUsed;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;
    ULONG i;
    ULONG vlSize;


    switch(GuidIndex)
    {
        case FilterClass1:
        case FilterClass2:
        {
            // plain EC1
            status = FilterSetEc1Worker(devExt,
                                         BufferSize,
                                         0,
                                         Buffer,
                                         &bufferUsed);
            break;
        }

        case FilterClass3:
        {
            // fixed array of EC1

            for (i = 0, status = STATUS_SUCCESS;
                 (i < 4) && NT_SUCCESS(status); i++)
            {
                status = FilterSetEc1Worker(devExt,
                                             BufferSize,
                                             i,
                                             Buffer,
                                             &bufferUsed);
                Buffer += bufferUsed;
                BufferSize -= bufferUsed;
            }
            break;
        }

        case FilterClass4:
        {
            // variable array of EC1

            if (BufferSize >= ((sizeof(ULONG) +7) & ~7))
            {
                vlSize = *((PULONG)Buffer);
                Buffer += ((sizeof(ULONG) +7) & ~7);

                if ((vlSize >= 1) && (vlSize <= 4))
                {
                    for (i = 0, status = STATUS_SUCCESS;
                         (i < vlSize) && NT_SUCCESS(status); i++)
                    {
                        status = FilterSetEc1Worker(devExt,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                                 &bufferUsed);
                        Buffer += bufferUsed;
                        BufferSize -= bufferUsed;
                    }
                    if (NT_SUCCESS(status))
                    {
                        devExt->Ec1Count = vlSize;
                    }
                } else {
                    KdPrint(("SetEc1 only up to [4] allowed, not %d\n",
                            vlSize));
                    status = STATUS_INVALID_PARAMETER_MIX;
                }
            } else {
                KdPrint(("SetEc1 size too small\n"));
                status = STATUS_INVALID_PARAMETER_MIX;
            }

            break;
        }

        case FilterClass5:
        {
            // plain EC2
            status = FilterSetEc2Worker(devExt,
                                         BufferSize,
                                             0,
                                         Buffer,
                                         &bufferUsed);
            break;
        }

        case FilterClass6:
        {
            // fixed array EC2
            for (i = 0, status = STATUS_SUCCESS;
                 (i < 4) && NT_SUCCESS(status); i++)
            {
                status = FilterSetEc2Worker(devExt,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                             &bufferUsed);
                Buffer += bufferUsed;
                BufferSize -= bufferUsed;
            }
            break;
        }

        case FilterClass7:
        {
            // VL array EC2
            if (BufferSize >= sizeof(ULONG))
            {
                vlSize = *((PULONG)Buffer);
                Buffer += (sizeof(ULONG) +7) & ~7;
                if ((vlSize >= 1) && (vlSize <= 4))
                {
                    for (i = 0, status = STATUS_SUCCESS;
                         (i < vlSize) && NT_SUCCESS(status); i++)
                    {
                        status = FilterSetEc2Worker(devExt,
                                             BufferSize,
                                                 i,
                                             Buffer,
                                             &bufferUsed);
                        Buffer += bufferUsed;
                        BufferSize -= bufferUsed;
                    }
                    if (NT_SUCCESS(status))
                    {
                        devExt->Ec1Count = vlSize;
                    }
                } else {
                    KdPrint(("SetEc2 only up to [4] allowed, not %d\n",
                            vlSize));
                    status = STATUS_INVALID_PARAMETER_MIX;
                }
            } else {
                KdPrint(("SetEc2 size too small\n"));
                status = STATUS_INVALID_PARAMETER_MIX;
            }

            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);


}

NTSTATUS
FilterSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to change the contents of
    a data block. If the driver can change the data block within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the data is changed.

Arguments:

    DeviceObject is the device whose data block is being changed

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    NTSTATUS status;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;
    ULONG sizeNeeded = 0;

    switch(GuidIndex)
    {
        case FilterClass1:
        case FilterClass2:
        case FilterClass3:
        case FilterClass4:
        case FilterClass5:
        case FilterClass6:
        case FilterClass7:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        case FilterFireEvent:
        case FilterGetSetData:
        {
            status = STATUS_WMI_READ_ONLY;
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}


NTSTATUS FilterDoFireEvent(
    struct DEVICE_EXTENSION * devExt,
    ULONG WnodeType,  // 0 - AllData, 1 - Single Instance
    ULONG DataType,   // 1,2,5,8 is guid id
    ULONG BlockIndex  // 0 - 3 is block index containing data
    )
{
    PWNODE_HEADER Wnode;
    PWNODE_ALL_DATA WnodeAD;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    PUCHAR dataPtr;
    PUCHAR WnodeDataPtr;
    ULONG dataSize;
    LPGUID Guid;
    NTSTATUS status;
    ULONG sizeNeeded;
    BOOLEAN isEventRef = FALSE;

    if (BlockIndex > 3)
    {
        return(STATUS_INVALID_PARAMETER_MIX);
    }

    switch(DataType)
    {
        case 1:
        {
            // EC1
            dataSize = devExt->Ec1Length[BlockIndex];
            dataPtr = (PUCHAR)devExt->Ec1[BlockIndex];
            Guid = &FilterEventClass1Guid;
            break;
        }

        case 2:
        {
            // EC1 (embedded)
            dataSize = devExt->Ec1Length[BlockIndex];
            dataPtr = (PUCHAR)devExt->Ec1[BlockIndex];
            Guid = &FilterEventClass2Guid;
            break;
        }

        case 5:
        {
            // EC2 (embedded)
            dataSize = devExt->Ec2Length[BlockIndex];
            dataPtr = (PUCHAR)devExt->Ec2[BlockIndex];
            Guid = &FilterEventClass5Guid;
            break;
        }

        case 8:
        {
            isEventRef = TRUE;
            Guid = &FilterEventReferenceClassGuid;
            break;
        }

        default:
        {
            return(STATUS_INVALID_PARAMETER_MIX);
        }
    }

    if (isEventRef) {
        Wnode = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(WNODE_EVENT_REFERENCE),
                                      FILTER_TAG);
        if (Wnode != NULL)
        {
            PWNODE_EVENT_REFERENCE WnodeER;

            sizeNeeded = sizeof(WNODE_EVENT_REFERENCE);


            //
            // Create a WNODE_EVENT_REFERENCE. First set the flags in the
            // header to specify an event reference with static instance
            // names.
            //
            Wnode->Flags = WNODE_FLAG_EVENT_REFERENCE |
                           WNODE_FLAG_STATIC_INSTANCE_NAMES;

            WnodeER = (PWNODE_EVENT_REFERENCE)Wnode;

            //
            // The target guid is almose always the same guid as the event
            // guid. To be most efficient we can set the size of the target
            // data block, but in any case if it is too small then WMI will
            // retry with a larger buffer.
            //
            WnodeER->TargetGuid = *Guid;
            WnodeER->TargetDataBlockSize = 0;

            //
            // Since the target guid is a static instance name guid we fill
            // in the instance index. If the target guid was dynamic instance
            // names we would have to setup the instance name as text.
            WnodeER->TargetInstanceIndex = 0;
            dataPtr = NULL;
        } else {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else if (WnodeType == 0)
    {
        sizeNeeded = FIELD_OFFSET(WNODE_ALL_DATA,
                                  OffsetInstanceDataAndLength) + dataSize;
        Wnode = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeNeeded,
                                      FILTER_TAG);

        if (Wnode == NULL)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        Wnode->Flags =  WNODE_FLAG_ALL_DATA |
                         WNODE_FLAG_FIXED_INSTANCE_SIZE |
                        WNODE_FLAG_EVENT_ITEM |
                        WNODE_FLAG_STATIC_INSTANCE_NAMES;
        WnodeAD = (PWNODE_ALL_DATA)Wnode;
        WnodeAD->DataBlockOffset = FIELD_OFFSET(WNODE_ALL_DATA,
                                                OffsetInstanceDataAndLength);
        WnodeAD->InstanceCount = 1;
        WnodeAD->FixedInstanceSize = dataSize;
        WnodeDataPtr = (PUCHAR)Wnode + WnodeAD->DataBlockOffset;

    } else if (WnodeType == 1) {
        sizeNeeded = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                  VariableData) + dataSize;
        Wnode = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeNeeded,
                                      FILTER_TAG);

        if (Wnode == NULL)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        Wnode->Flags =  WNODE_FLAG_SINGLE_INSTANCE |
                        WNODE_FLAG_EVENT_ITEM |
                        WNODE_FLAG_STATIC_INSTANCE_NAMES;
        WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
        WnodeSI->DataBlockOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE,
                                                VariableData);
        WnodeSI->InstanceIndex = 0;
        WnodeSI->SizeDataBlock = dataSize;
        WnodeDataPtr = (PUCHAR)Wnode + WnodeSI->DataBlockOffset;
    } else {
        return(STATUS_INVALID_PARAMETER_MIX);
    }


    Wnode->Guid = *Guid;
    Wnode->ProviderId = IoWMIDeviceObjectToProviderId(devExt->filterDevObj);
    Wnode->BufferSize = sizeNeeded;
    KeQuerySystemTime(&Wnode->TimeStamp);

    if (dataPtr != NULL)
    {
        RtlCopyMemory(WnodeDataPtr, dataPtr, dataSize);
    }

    status = IoWMIWriteEvent(Wnode);

    //
    // If IoWMIWriteEvent succeeds then WMI will free the event buffer. If
    // it fails then the caller frees the event buffer.
    //
    if (! NT_SUCCESS(status))
    {
        ExFreePool(Wnode);
    }
    return(status);
}

NTSTATUS
FilterExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. If
    the driver can complete the method within the callback it should
    call WmiCompleteRequest to complete the irp before returning to the
    caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device whose method is being executed

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the input buffer on entry and returns with
         the output data block

Return Value:

    status

--*/
{
    ULONG sizeNeeded = 0;
    NTSTATUS status;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;
    ULONG bufferUsed;
    ULONG blockIndex;
    ULONG UlongPadSize = (sizeof(ULONG) + 7) & ~7;


    if (GuidIndex == FilterGetSetData)
    {
        switch(MethodId)
        {
            case SetEC1:
            case SetEC1AsEc:
            {
                // SetEc1

                if (InBufferSize < UlongPadSize)
                {
                    status = STATUS_INVALID_PARAMETER_MIX;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = STATUS_INVALID_PARAMETER_MIX;
                        break;
                    }
                    Buffer += UlongPadSize;
                    InBufferSize -= UlongPadSize;
                }

                status = FilterSetEc1Worker(devExt,
                                         InBufferSize,
                                             blockIndex,
                                         Buffer,
                                         &bufferUsed);
                sizeNeeded = 0;
                break;
            }

            case SetEC2:
            case SetEC2AsEc:
            {
                // SetEc2

                if (InBufferSize < UlongPadSize)
                {
                    status = STATUS_INVALID_PARAMETER_MIX;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = STATUS_INVALID_PARAMETER_MIX;
                        break;
                    }
                    Buffer += UlongPadSize;
                    InBufferSize -= UlongPadSize;
                }

                status = FilterSetEc2Worker(devExt,
                                         InBufferSize,
                                             blockIndex,
                                         Buffer,
                                         &bufferUsed);
                sizeNeeded = 0;
                break;
            }

            case GetEC1:
            case GetEC1AsEc:
            {
                // GetEc1

                if (InBufferSize != sizeof(ULONG))
                {
                    status = STATUS_INVALID_PARAMETER_MIX;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = STATUS_INVALID_PARAMETER_MIX;
                        break;
                    }
                }

                sizeNeeded = devExt->Ec1ActualLength[blockIndex];
                if (OutBufferSize < sizeNeeded)
                {
                    status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    FilterGetActualEc1(devExt, Buffer, blockIndex);
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case GetEC2:
            case GetEC2AsEc:
            {
                // GetEc2
                if (InBufferSize != sizeof(ULONG))
                {
                    status = STATUS_INVALID_PARAMETER_MIX;
                    sizeNeeded = 0;
                    break;
                } else {
                    blockIndex = *((PULONG)Buffer);
                    if (blockIndex > 3)
                    {
                        status = STATUS_INVALID_PARAMETER_MIX;
                        break;
                    }
                }

                sizeNeeded = devExt->Ec2ActualLength[blockIndex];
                if (OutBufferSize < sizeNeeded)
                {
                    status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    FilterGetActualEc2(devExt, Buffer, blockIndex);
                    status = STATUS_SUCCESS;
                }
                break;
            }

            case DisableSampleClass7:
            {
                //
                // Mark the guid for FilterClass7 as not available and then
                // call WMI to inform it that the guid list has changed. WMI
                // will send a new IRP_MN_REGINFO which would cause the
                // QueryWmiRegInfo callback to be called and the new
                // guid list would be returned and the registration updated.
                FilterGuidList[FilterClass7].Flags |= WMIREG_FLAG_REMOVE_GUID;
                status = IoWMIRegistrationControl(devExt->filterDevObj,
                                         WMIREG_ACTION_UPDATE_GUIDS);
                sizeNeeded = 0;
                break;
            }

            case UnregisterFromWmi:
            {
                //
                // We must wait until AFTER the irp is completed before
                // calling IoWMIRegistrationControl to unregister. Since
                // that api will block until all WMI irps sent to the
                // device are completed we would become deadlocked.

                IoWMIRegistrationControl(devExt->filterDevObj,
                                         WMIREG_ACTION_BLOCK_IRPS);

                status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     STATUS_SUCCESS,
                                     0,
                                     IO_NO_INCREMENT);

                IoWMIRegistrationControl(devExt->filterDevObj,
                                         WMIREG_ACTION_DEREGISTER);
                return(status);
            }

            case EnableSampleClass7:
            {
                //
                // Mark the guid for FilterClass7 as available and then
                // call WMI to inform it that the guid list has changed. WMI
                // will send a new IRP_MN_REGINFO which would cause the
                // QueryWmiRegInfo callback to be called and the new
                // guid list would be returned and the registration updated.
                FilterGuidList[FilterClass7].Flags &= ~WMIREG_FLAG_REMOVE_GUID;
                status = IoWMIRegistrationControl(devExt->filterDevObj,
                                         WMIREG_ACTION_UPDATE_GUIDS);
                sizeNeeded = 0;
                break;
            }

            default:
            {
                status = STATUS_WMI_ITEMID_NOT_FOUND;
            }
        }
    } else if (GuidIndex == FilterFireEvent) {
        if (MethodId == FireEvent)
        {
            if (InBufferSize == 3*sizeof(ULONG))
            {
                ULONG wnodeType;
                ULONG dataType;
                ULONG blockIndexA;

                wnodeType = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);

                dataType = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);

                blockIndexA = *(PULONG)Buffer;
                Buffer += sizeof(ULONG);

                status = FilterDoFireEvent(devExt,
                                 wnodeType,
                                 dataType,
                                 blockIndexA);

                sizeNeeded = 0;

            } else {
                status = STATUS_INVALID_PARAMETER_MIX;
            }
        } else {
            status = STATUS_WMI_ITEMID_NOT_FOUND;
        }
    } else  {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
FilterFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it. If the driver can complete enabling/disabling within the callback it
    should call WmiCompleteRequest to complete the irp before returning to
    the caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device object

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
    NTSTATUS status;

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     STATUS_SUCCESS,
                                     0,
                                     IO_NO_INCREMENT);
    return(status);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\sources.inc ===
!include $(PROJECT_ROOT)\prerelease.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\addpath.c ===
#include <pch.h>
#include <windows.h>

//***************************************************************************
//*                                                                         *
//* NAME:       AddPath                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID AddPath(LPTSTR szPath, LPCTSTR szName )
{
    LPTSTR szTmp;

    // Find end of the string
    szTmp = szPath + lstrlen(szPath);

    // If no trailing backslash then add one
    if ( szTmp > szPath && *(CharPrev( szPath, szTmp )) != TEXT('\\') )
        *(szTmp++) = TEXT('\\');

    // Add new name to existing path string
    while ( *szName == TEXT(' ') ) szName++;
        lstrcpy( szTmp, szName );
}

// function will upated the given buffer to parent dir
//
BOOL GetParentDir( LPTSTR szFolder )
{
    LPTSTR lpTmp;
    BOOL  bRet = FALSE;

    // remove the trailing '\\'
    lpTmp = CharPrev( szFolder, (szFolder + lstrlen(szFolder)) );
    lpTmp = CharPrev( szFolder, lpTmp );

    while ( (lpTmp > szFolder) && (*lpTmp != TEXT('\\')) )
    {
       lpTmp = CharPrev( szFolder, lpTmp );
    }

    if ( *lpTmp == TEXT('\\') )
    {
        if ( (lpTmp == szFolder) || (*CharPrev(szFolder, lpTmp) == TEXT(':')) )
            lpTmp = CharNext( lpTmp );
        *lpTmp = TEXT('\0');
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\animate.h ===
#ifndef _ANIMATE_H_
#define _ANIMATE_H_

extern UINT    g_uiAnimateIndex;
extern UINT    g_uiLastAnimateIndex;

BOOL InitAnimate(HWND hwnd, HDC hdc);
void Animate(HDC hdc);
void AnimateNext();
void TerminateAnimate();

#define LEFT    0
#define CENTER  1

BOOL DisplayString(
    HDC         hdc,
    int         x,
    int         y,
    TEXTMETRIC* lptm,
    int         iLineSpace, 
    RECT*       lprc,
    LPINT       pNumLines,
    LPTSTR      szTextOut,
    WORD wfPlacement
    );

int WrapText(
    IN HDC          hdc,
    IN int          x,
    IN RECT*        lprc,
    IN OUT LPTSTR   szBBResource);

BOOL DrawWrapText(
    IN HDC          hdc,
    IN TEXTMETRIC*  lptm,
    IN int          iLineSpace, 
    IN int          x,
    IN int          y,
    IN RECT*        lprc,
    IN WORD         wfPlacement,
    IN int          iLineCount,
    IN LPTSTR       szLines);

VOID ImproveWrap(
    IN OUT LPTSTR szLines,
    IN OUT PINT   piNumLine,
    IN     LPTSTR szOrigText,
    IN     INT    cchOrigText
    );

#endif _ANIMATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\animate.c ===
#include <pch.h>
#include <tchar.h>
#include "resource.h"
#include "dibutil.h"
#include "billbrd.h"
#include "animate.h"

#define MAX_ANIMSTRING MAX_STRING
#define MyWait(c) {int __nCnt = (c); while(__nCnt) __nCnt--;}
#define GetInvertRGB(rgb) (RGB(255 - GetRValue(rgb), 255 - GetGValue(rgb), 255 - GetBValue(rgb)))

#define CX_MOVE 4
#define CY_MOVE 4
#define CX_SHADOW 4
#define CY_SHADOW 4

#define FONT_TITLE      0
#define FONT_TEXT       1
#define FONT_DELETE     10

// AnimateBlt Index
#define AB_HOR_POS      1
#define AB_HOR_NEG      2
#define AB_VER_POS      3
#define AB_VER_NEG      4

typedef struct _tagANISTRINGFORM { 
    COLORREF    col;
    BOOL        bShadow;
    COLORREF    colShadow;
    RECT        rc;
    UINT        uiLineHeightx2;
    HFONT       hFont;
} ANISTRINGFORM, FAR *LPANISTRINGFORM;



HDC     g_hdcCache = NULL;
HBITMAP g_hbmp = NULL;
HBITMAP g_hbmpOldCache = NULL;
LOGFONT g_lfTemp = {0};
BOOL    g_fBullet = FALSE;

UINT    g_uiAnimateIndex = (UINT)-1;
UINT    g_uiLastAnimateIndex = (UINT)-1;

void RestoreCachedRect()
{
    HWND    hwndBB;
    HDC     hdcBB;
    int     cxBB;
    int     cyBB;
    RECT    rcBB;

    hwndBB = GetBBHwnd();
    
    if (GetClientRect(hwndBB, &rcBB))
    {
    
        cxBB = rcBB.right - rcBB.left;
        cyBB = rcBB.bottom - rcBB.top;

        hdcBB = GetDC(hwndBB);
        if (hdcBB)
        {
            // Init cached bitmap
            BitBlt(hdcBB, 0, 0, cxBB, cyBB, g_hdcCache, 0, 0, SRCCOPY);
            ReleaseDC(hwndBB, hdcBB);
        }

    }

}

void AnimateBlt(HDC hdcDest, int x, int y, int w, int h, HDC hdcSrc, int xSrc, int ySrc, int nPattern)
{
    int i;

    switch (nPattern)
    {
        case AB_HOR_POS:
            for (i = 0; i < w; i++)
            {
                BitBlt(hdcDest, x + i, y, 1, h, 
                       hdcSrc, xSrc + i, ySrc, SRCCOPY);
                MyWait(10000);
            }
            break;

        case AB_VER_POS:
            for (i = 0; i < h; i++)
            {
                BitBlt(hdcDest, x, y + 1, w, 1, 
                       hdcSrc, xSrc + i, ySrc, SRCCOPY);
                MyWait(10000);
            }
            break;
    }

}

void RestoreRect(HDC hdc, LPRECT lprc, int nPat)
{
    int     cx      = lprc->right - lprc->left + 1;
    int     cy      = lprc->bottom - lprc->top + 1;
    
    if (hdc)
    {
        BitBlt(hdc, lprc->left, lprc->top, cx, cy, 
                   g_hdcCache, lprc->left, lprc->top, SRCCOPY);
    }

}

/**********************************************************************
* CheckForBulletAndRemoveMarker()
*
* This function checks if the line of text has a bullet preceding it
* if so it removes the bullet identifier from the string. This function
* also sets the value of piWidth to the width of the bitmap.
*
* Returns:  TRUE    == Bullet needed
*           FALSE   == No bullet
*
**********************************************************************/
BOOL CheckForBulletAndRemoveMarker(LPTSTR lpstr, LPINT lpiWidth)
{
    BOOL bRet = FALSE;
    LPTSTR   p = NULL;
    HBITMAP hBmp = NULL;
    BITMAP  bm;
    
    p = lpstr;
    *lpiWidth = 0;
    g_fBullet = FALSE;
    
    if(*p)
    {
        while(*p == TEXT(' '))
            p = CharNext(p);
        if(*p == '-')
        {
            lstrcpy(p, CharNext(p));
            bRet = TRUE;
            hBmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BULLET_1));
            GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bm);
            *lpiWidth = bm.bmWidth;
            DeleteObject(hBmp);
            g_fBullet = TRUE;
        }
    }
    return bRet;
}

/**********************************************************************
* CheckForBulletAndReturnWidth()
*
* This function checks if the line of text has a bullet preceding it
* if so figures out the bullet bitmaps width and returns it.
*
* Returns:  TRUE    == Bullet needed
*           FALSE   == No bullet
*
**********************************************************************/
int CheckForBulletAndReturnWidth(LPTSTR lpstr)
{
    int     iWidth = 0;
    LPTSTR   p = NULL;
    HBITMAP hBmp = NULL;
    BITMAP  bm;
    
    p = lpstr;
    
    if(*p)
    {
        while(*p == TEXT(' '))
            p = CharNext(p);
        if(*p == TEXT('-'))
        {
            hBmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BULLET_1));
            GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bm);
            iWidth = bm.bmWidth;
            DeleteObject(hBmp);
        }
    }
    return iWidth;
}

/**********************************************************************
* PaintBulletIfNeeded()
*
* This function checks if the line of text needs a bullet to be painted
* if so paints the bullet bitmap on the given coords on the given dc.
*
* Returns:  None
*
**********************************************************************/
void PaintBulletIfNeeded(HDC hdc, int x, int y , int iHeight)
{
    HBITMAP hBmp = NULL;
    BITMAP  bm;
    
    if(g_fBullet)
    {
        hBmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BULLET_1));
        if(hBmp)
        {
            GetObject(hBmp, sizeof(BITMAP), &bm);
            DrawBitmap(hdc, hBmp, x, y + (iHeight - bm.bmHeight)/2);
            DeleteObject(hBmp);
            g_fBullet = FALSE;
        }
    }   
}


void GetPanelSectionName(int nPanel, LPTSTR lpszKey)
{
    wsprintf(lpszKey, TEXT("Panel%d"), nPanel);
}

int GetTextCount(int nPanel)
{
    TCHAR szKey[80];
    GetPanelSectionName(nPanel, szKey);
    return GetPrivateProfileInt(szKey, TEXT("Count"), 0, g_szFileName);
}

int GetTitle(int nPanel, LPTSTR lpStr)
{
    TCHAR szKey[80];
    GetPanelSectionName(nPanel, szKey);
    return GetPrivateProfileString(szKey, TEXT("Title"), TEXT(""), 
                           lpStr, MAX_ANIMSTRING, g_szFileName);
}

int GetPanelText(int nPanel, int nCnt, LPTSTR lpStr)
{
    TCHAR szKey[16];
    TCHAR szSec[16];
    GetPanelSectionName(nPanel, szKey);
    wsprintf(szSec, TEXT("Text%d"), nCnt);
    return GetPrivateProfileString(szKey, szSec, TEXT(""), 
                           lpStr, MAX_ANIMSTRING, g_szFileName);
}

BOOL CALLBACK GetLogFontEnumProc(LPLOGFONT lplf, LPTEXTMETRIC lptm, int wType, LPARAM lpData)
{
    g_lfTemp = *lplf;
    return 0;
}

BOOL GetLogFontFromFaceName(LPLOGFONT lplf, LPTSTR lpszFaceName)
{
    HWND hwndBB = NULL;
    HDC  hdcBB  = NULL;
    FONTENUMPROC lpEnumFontsCallBack = NULL;

    hwndBB = GetBBHwnd();
    hdcBB = GetDC(hwndBB);
    
    lpEnumFontsCallBack = (FONTENUMPROC)MakeProcInstance((FARPROC)GetLogFontEnumProc, g_hInstance);

    EnumFonts((HDC)hdcBB, (LPCTSTR)lpszFaceName, (FONTENUMPROC)lpEnumFontsCallBack, 0L);

    FreeProcInstance((FARPROC)lpEnumFontsCallBack);

    *lplf = g_lfTemp;
    ReleaseDC(hwndBB, hdcBB);

    return TRUE;
}


/**********************************************************************
* GetDeleteFontHandle()
*
* This function checks if the font specified by iFontnum exists already.
* if so returns its handle if not it creates the font and return the 
* handle. returns NULL in error case. if Function is called with 
* iFontNum = FONT_DELETE then the existing fonts are deleted.
*
*   INPUT:      iFontNum
*   Returns:    HFONT
*
*   10/08/97        hanumany        created
**********************************************************************/
HFONT GetDeleteFontHandle(int iFontNum)
{
    static HFONT   hFontTitle = NULL;
    static HFONT   hFontText = NULL;    
    
    switch(iFontNum)
    {
        case FONT_TITLE:
        {
            if(hFontTitle)
            {
                return hFontTitle;
            }
            else
            {
                LOGFONT lf = {0};
            
                GetLogFontFromFaceName(&lf, g_szTFont);
                lf.lfHeight = -MulDiv(g_nTFontHeight, 96, 72);
                lf.lfWidth = g_nTFontWidth;
                lf.lfWeight = g_nTFontWeight;
                lf.lfQuality = ANTIALIASED_QUALITY;
                lf.lfCharSet = g_bCharSet;
                hFontTitle = CreateFontIndirect(&lf); 
                return hFontTitle;
            }
        }

        case FONT_TEXT:
        {
            
            if(hFontText)
            {
                return hFontText;
            }
            else
            {
                LOGFONT lf = {0};

                GetLogFontFromFaceName(&lf, g_szBFont);
                lf.lfHeight = -MulDiv(g_nBFontHeight, 96, 72);
                lf.lfWidth = g_nBFontWidth;
                lf.lfWeight = g_nBFontWeight;
                lf.lfQuality = PROOF_QUALITY;
                lf.lfCharSet = g_bCharSet;
                hFontText = CreateFontIndirect(&lf);  
                return hFontText;
            }    
        }

        case FONT_DELETE:
        {
            if(hFontTitle)
            {
                DeleteObject(hFontTitle);
                hFontTitle = NULL;
            }
            if(hFontText)
            {
                DeleteObject(hFontText);
                hFontText = NULL;
            }
            break;
        }
    }

    return NULL;
}

/************************************************************************
* RemoveLineBreakChar()
*
* This function copies lpszCurr to lpszFixed without the line break char's
*
************************************************************************/
void RemoveLineBreakChar(LPCTSTR lpszCurr, LPTSTR lpszFixed)
{
    while (*lpszCurr != TEXT('\0'))
    {
        if(*lpszCurr != TEXT('|'))
        {
            *lpszFixed = *lpszCurr;
#ifndef UNICODE
            if(IsDBCSLeadByte(*lpszFixed))
            {
                *(lpszFixed+1) = *(lpszCurr+1);
            }
#endif
            lpszFixed = CharNext(lpszFixed);
            lpszCurr = CharNext(lpszCurr);
        }
        else
        {
            lpszCurr = CharNext(lpszCurr);
        }
    }
    *lpszFixed = '\0';

    return;

}

void MergeBlt(LPTSTR lpstr,
              HDC hdcDst, int x0, int y0, int cx0, int cy0, 
              HDC hdcSrc, int x1, int y1, int cx1, int cy1,
              COLORREF rgb, COLORREF rgbShadow, 
              BOOL fShadow, BOOL fStretch,
              TEXTMETRIC* lptm, int iLineSpace, RECT* lprc
             )
{
    int nNumLines = 0;

    if (fShadow)
    {
        SetTextColor(hdcSrc, 0);
        DisplayString(hdcSrc, x1 + CX_SHADOW, y1 + CY_SHADOW, lptm, iLineSpace, lprc, &nNumLines, lpstr, LEFT);

        if (fStretch)
        {
            StretchBlt(hdcDst, x0, 0, cx0, cy0, 
                   hdcSrc, x1, y1, cx1, cy1, SRCAND);
        }
        else
        {
            BitBlt(hdcDst, x0, 0, cx0, cy0, 
                   hdcSrc, x1, y1, SRCAND);
        }

        SetTextColor(hdcSrc, GetInvertRGB(rgbShadow));
        DisplayString(hdcSrc, x1 + CX_SHADOW, y1 + CY_SHADOW, lptm, iLineSpace, lprc, &nNumLines, lpstr, LEFT);

        if (fStretch)
        {
            StretchBlt(hdcDst, y0, y0, cx0, cy0, 
                   hdcSrc, x1, y1, cx1, cy1, MERGEPAINT);
        }
        else
        {
            BitBlt(hdcDst, y0, y0, cx0, cy0, 
                   hdcSrc, x1, y1, MERGEPAINT);
        }
    }

    SetTextColor(hdcSrc, 0);
    DisplayString(hdcSrc, x1, y1, lptm, iLineSpace, lprc, &nNumLines, lpstr, LEFT);

    if (fStretch)
    {
        StretchBlt(hdcDst, x0, 0, cx0, cy0, 
               hdcSrc, x1, y1, cx1, cy1, SRCAND);
    }
    else
    {
        BitBlt(hdcDst, x0, 0, cx0, cy0, 
               hdcSrc, x1, y1, SRCAND);
    }
    SetTextColor(hdcSrc, GetInvertRGB(rgb));
    DisplayString(hdcSrc, x1, y1, lptm, iLineSpace, lprc, &nNumLines, lpstr, LEFT);

    if (fStretch)
    {
        StretchBlt(hdcDst, y0, y0, cx0, cy0, 
               hdcSrc, x1, y1, cx1, cy1, MERGEPAINT);
    }
    else
    {
        BitBlt(hdcDst, y0, y0, cx0, cy0, 
               hdcSrc, x1, y1, MERGEPAINT);
    }
}

int AnimateString(
    HDC             hdc,
    LPTSTR          lpstr,
    LPANISTRINGFORM lpani,
    int             iLineSpace,
    int             nPat
    )
{
    HWND    hwndBB  = NULL;
    int     cxBB;
    int     cyBB;
    RECT    rcBB;
    
    HDC     hdcMem = NULL;
    HDC     hdcText = NULL;
    HBITMAP hbmpMem = NULL;
    HBITMAP hbmpText = NULL;
    HBITMAP hbmpOld = NULL;
    HBITMAP hbmpOldText = NULL;
    HFONT   hfont = NULL;
    HFONT   hfontOld = NULL;
    HBRUSH  hbrBlack = NULL;
    HBRUSH  hbrWhite = NULL;
    HBRUSH  hbrOldText = NULL;
    int     cx;
    int     cy;
    int     i,j;
    TEXTMETRIC tm;
    int x0;
    int nLen;
    int nWait;
    int nDelta;
    RECT rc;
    int nNumLines = 0;
    int ibmWidth = 0;
    SIZE    size;

    hwndBB = GetBBHwnd();
    
    if (!GetClientRect(hwndBB, &rcBB))
    {
        goto exit;
    }
    
    cxBB = rcBB.right - rcBB.left;
    cyBB = rcBB.bottom - rcBB.top;

    hbrWhite = GetStockObject(WHITE_BRUSH);
    if (hbrWhite == NULL)
    {
        goto exit;
    }
    
    hbrBlack = GetStockObject(BLACK_BRUSH);
    if (!hbrBlack)
    {
        goto exit;
    }
    
    hdcText = CreateCompatibleDC(hdc);
    if (!hdcText)
    {
        goto exit;
    }

    hbmpText = CreateCompatibleBitmap(hdc, cxBB, cyBB);
    if (!hbmpText)
    {
        goto exit;
    }

    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem)
    {
        goto exit;
    }

    cx = lpani->rc.right - lpani->rc.left + 1;
    cy = lpani->rc.bottom - lpani->rc.top + 1;

    if (lpani->bShadow)
    {
        cx += CX_SHADOW;
        cy += CY_SHADOW;
    }

    hbmpMem = CreateCompatibleBitmap(hdc, cxBB, cyBB);
    if (!hbmpMem)
    {
        goto exit;
    }

    hbmpOld = SelectObject(hdcMem, hbmpMem);
    SetBkMode(hdcMem, TRANSPARENT);

    hfont = lpani->hFont;
    if (!hfont)
    {
       goto exit;
    }

    hfontOld = SelectObject(hdcMem, hfont);
    GetTextMetrics(hdcMem, &tm);

    nLen = lstrlen(lpstr);
    GetTextExtentPoint32(hdcMem, lpstr, nLen, &size);

    ibmWidth = CheckForBulletAndReturnWidth(lpstr);
    
    if (cx  > (int)size.cx + ibmWidth + 10)
    {
        cx = (int)size.cx + ibmWidth + 10;
    }

    if (cy > (int)size.cy)
    {
        cy = (int)size.cy;
    }

    hfontOld = SelectObject(hdcText, hfont);
    hbmpOldText = SelectObject(hdcText, hbmpText);
    hbrOldText = SelectObject(hdcText, hbrWhite);
    rc.left = 0;
    rc.top = 0;
    rc.right = cx;
    rc.bottom = cy;
    FillRect(hdcText, &rc, hbrWhite);

    DisplayString(hdcText, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

    if(nNumLines > 1)
    {
        cy = cy + (tm.tmHeight * lpani->uiLineHeightx2 * nNumLines / 2);
        rc.left = 0;
        rc.top = 0;
        rc.right = cx;
        rc.bottom = cy;
        FillRect(hdcText, &rc, hbrWhite);

        DisplayString(hdcText, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

    }

    switch (nPat)
    {

        default:
        case 7:
        case 0:
        {
            COLORREF crOld = 0;

            if (g_bBiDi)
            {
                BitBlt(hdcMem, 0, 0, cx, cy, 
                    g_hdcCache, lpani->rc.right-cx, lpani->rc.top, SRCCOPY);
            }
            else
            {
                BitBlt(hdcMem, 0, 0, cx, cy, 
                    g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            }

            if (lpani->bShadow)
            {
                CONST int SHADOW_OFFSET = 2;
                RECT  rcShadow;
                
                if (SetRect(&rcShadow,
                            rc.left,
                            rc.top,
                            rc.right + SHADOW_OFFSET,
                            rc.bottom + SHADOW_OFFSET))
                {
                    crOld = SetTextColor(hdcMem, lpani->colShadow);
                
                    DisplayString(hdcMem,
                                  SHADOW_OFFSET,
                                  SHADOW_OFFSET,
                                  &tm,
                                  iLineSpace,
                                  &rcShadow,
                                  &nNumLines,
                                  lpstr, LEFT);
                
                    SetTextColor(hdcMem, crOld);
                }
            }

            crOld = SetTextColor(hdcMem, lpani->col);
            DisplayString(hdcMem, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

            if (g_bBiDi)
            {
                BitBlt(hdc,
                       lpani->rc.right-cx,
                       lpani->rc.top - tm.tmInternalLeading,
                       cx,
                       cy,
                       hdcMem,
                       0,
                       0,
                       SRCCOPY);
            }
            else
            {
                BitBlt(hdc,
                       lpani->rc.left,
                       lpani->rc.top - tm.tmInternalLeading,
                       cx,
                       cy,
                       hdcMem,
                       0,
                       0,
                       SRCCOPY);
            }

            SetTextColor(hdcMem, crOld);
            break;
        }

        case 1:

            if (g_bBiDi)
                BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.right-cx, lpani->rc.top, SRCCOPY);
            else
                BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            for (i = 0; i < cy ; i+=4)
            {
                if (g_bBiDi)
                    BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.right-cx, lpani->rc.top, SRCCOPY);
                else
                    BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);

                MergeBlt(lpstr, hdcMem, 0, 0, cx, i, hdcText, 0, 0, cx, cy, 
                        lpani->col, lpani->colShadow, lpani->bShadow, TRUE, &tm, iLineSpace, &rc);
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                if (g_bBiDi)
                    BitBlt(hdc, lpani->rc.right-cx, lpani->rc.top, cx, cy, hdcMem, 0, 0, SRCCOPY);
                else
                    BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, hdcMem, 0, 0, SRCCOPY);


                MyWait(10000);
            }
            if (g_bBiDi)
                BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.right-cx, lpani->rc.top, SRCCOPY);
            else
                BitBlt(hdcMem, 0, 0, cx, cy, g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);

            MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, hdcText, 0, 0, cx, cy, 
                     lpani->col, lpani->colShadow, lpani->bShadow, FALSE, &tm, iLineSpace, &rc);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

            if (g_bBiDi)
                BitBlt(hdc, lpani->rc.right-cx, lpani->rc.top, cx, cy, hdcMem, 0, 0, SRCCOPY);
            else
                BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, hdcMem, 0, 0, SRCCOPY);

            break;

        case 2:
            DisplayString(hdcText, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

            BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);

            for (i = 0; i < cx ; i+=4)
            {
                BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
                MergeBlt(lpstr, hdcMem, 0, 0, i, cy, 
                         hdcText, 0, 0, cx, cy, 
                         lpani->col, lpani->colShadow, lpani->bShadow, TRUE,
                         &tm, iLineSpace, &rc);
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);

                MyWait(10000);
            }
            BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                     hdcText, 0, 0, cx, cy, 
                     lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                     &tm, iLineSpace, &rc);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);

            break;

        case 3:
            nWait = 100;
            
            for (i = cxBB; i > lpani->rc.left; i -= CX_MOVE)
            {
                int xCur = i;


                BitBlt(hdc, xCur + cx, lpani->rc.top, CX_MOVE, cy, 
                           g_hdcCache, xCur + cx, lpani->rc.top, SRCCOPY);

                BitBlt(hdcMem, 0, 0, cxBB - xCur, cy, 
                       g_hdcCache, xCur, lpani->rc.top, SRCCOPY);

                MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                         hdcText, 0, 0, cx, cy, 
                         lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                         &tm, iLineSpace, &rc);
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                BitBlt(hdc, xCur, lpani->rc.top, cx, cy, 
                           hdcMem, 0, 0, SRCCOPY);

                MyWait(nWait * nWait);
                nWait++;
            }
            BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                     hdcText, 0, 0, cx, cy, 
                     lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                     &tm, iLineSpace, &rc);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);
            BitBlt(hdc, lpani->rc.left + cx, lpani->rc.top, CX_MOVE, cy, 
                       g_hdcCache, lpani->rc.left + cx, lpani->rc.top, SRCCOPY);
            
            break;

        case 4:
            nWait = 100;
            nDelta = (lpani->rc.right - lpani->rc.left) / 10;

            x0 = cxBB;
            while (abs(nDelta) > CX_MOVE)
            {
                for (i = x0; 
                     abs(i - (lpani->rc.left - nDelta)) > CX_MOVE; 
                     i -= (CX_MOVE * (nDelta/ abs(nDelta))))
                {
                    int xCur = i;

                    BitBlt(hdc, xCur + cx, lpani->rc.top, CX_MOVE, cy, 
                               g_hdcCache, xCur + cx, lpani->rc.top, SRCCOPY);

                    BitBlt(hdc, xCur - CX_MOVE, lpani->rc.top, CX_MOVE, cy, 
                               g_hdcCache, xCur - CX_MOVE, lpani->rc.top, SRCCOPY);


                    BitBlt(hdcMem, 0, 0, cxBB - xCur, cy, 
                       g_hdcCache, xCur, lpani->rc.top, SRCCOPY);
                    MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                             hdcText, 0, 0, cx, cy, 
                             lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                             &tm, iLineSpace, &rc);
                    PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
                    BitBlt(hdc, xCur, lpani->rc.top, cx, cy, 
                               hdcMem, 0, 0, SRCCOPY);
                    MyWait(nWait * nWait);
                    nWait++;
                }
                nDelta *= 2;
                nDelta /= 3;
                nDelta = 0 - nDelta;
                x0 = i;
            }
            BitBlt(hdcMem, 0, 0, cx, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            MergeBlt(lpstr, hdcMem, 0, 0, cx, cy, 
                     hdcText, 0, 0, cx, cy, 
                     lpani->col, lpani->colShadow, lpani->bShadow, FALSE,
                     &tm, iLineSpace, &rc);
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);
            BitBlt(hdc, lpani->rc.left + cx, lpani->rc.top, CX_MOVE, cy, 
                       g_hdcCache, lpani->rc.left + cx, lpani->rc.top, SRCCOPY);

            break;

        case 5:
    
            BitBlt(hdcMem, 0, 0, cxBB - lpani->rc.left, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            DisplayString(hdcMem, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

            for (i = 0; i < nLen; i++)
            {
                int nSize;
                int nNextSize;
                SIZE    size;

                GetTextExtentPoint32(hdcMem, lpstr, i, &size);
                nSize = size.cx;
                GetTextExtentPoint32(hdcMem, lpstr, i+1, &size);
                nNextSize = size.cx - nSize;

                if (nSize + nNextSize > cx)
                    break;
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                BitBlt(hdc, lpani->rc.left, lpani->rc.top, nSize, cy, 
                       hdcMem, 0, 0, SRCCOPY);

                BitBlt(hdc, lpani->rc.left + nSize, lpani->rc.top, CX_MOVE, cy, 
                       g_hdcCache, lpani->rc.left + nSize, lpani->rc.top, SRCCOPY);

                for (j = cxBB; j > lpani->rc.left+nSize ; j-=CX_MOVE)
                {
                    int xCur = j;
                    int xPrev = j + nNextSize;

                    PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);

                    BitBlt(hdc, xPrev, lpani->rc.top, CX_MOVE, cy, 
                           g_hdcCache, xPrev, lpani->rc.top, SRCCOPY);
                    BitBlt(hdc, xCur, lpani->rc.top, nNextSize, cy, 
                           hdcMem, nSize, 0, SRCCOPY);

                    MyWait(20000);
                }

            }
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);
            BitBlt(hdc, lpani->rc.left + cx, lpani->rc.top, CX_MOVE, cy, 
                       g_hdcCache, lpani->rc.left + cx, lpani->rc.top, SRCCOPY);

            break;

        case 6:

            BitBlt(hdcMem, 0, 0, cxBB - lpani->rc.left, cy, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top, SRCCOPY);
            DisplayString(hdcMem, 0, 0, &tm, iLineSpace, &rc, &nNumLines, lpstr, LEFT);

            for (i = 0; i < nLen; i++)
            {
                int nSize;
                int nNextSize;
                SIZE    size;

                GetTextExtentPoint32(hdcMem, lpstr, i, &size);
                nSize = size.cx;
                GetTextExtentPoint32(hdcMem, lpstr, i+1, &size);
                nNextSize = size.cx - nSize;

                if (nSize + nNextSize > cx)
                    break;
                PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
                BitBlt(hdc, lpani->rc.left, lpani->rc.top, nSize, cy, 
                       hdcMem, 0, 0, SRCCOPY);

                BitBlt(hdc, lpani->rc.left, lpani->rc.top - CY_MOVE, nSize, CY_MOVE, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top - CY_MOVE, SRCCOPY);

                for (j = cyBB; j > lpani->rc.top; j-=CY_MOVE)
                {
                    int yCur = j;
                    int yPrev = j + cy;

                    PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
                   
                    BitBlt(hdc, lpani->rc.left+nSize, yPrev, nNextSize, CY_MOVE, 
                           g_hdcCache, lpani->rc.left+nSize, yPrev, SRCCOPY);

                    BitBlt(hdc, lpani->rc.left+nSize, yCur, nNextSize, cy, 
                           hdcMem, nSize, 0, SRCCOPY);

                    MyWait(20000);
                }

            }
            PaintBulletIfNeeded(hdcMem, 0, 0, tm.tmHeight);
                   
            BitBlt(hdc, lpani->rc.left, lpani->rc.top, cx, cy, 
                       hdcMem, 0, 0, SRCCOPY);
            BitBlt(hdc, lpani->rc.left, lpani->rc.top + cy, cx, CY_MOVE, 
                       g_hdcCache, lpani->rc.left, lpani->rc.top + cy, SRCCOPY);
            break;

    }
    SelectObject(hdcMem, hbmpOld);
    SelectObject(hdcText, hbrOldText);
    SelectObject(hdcText, hbmpOldText);
    SelectObject(hdcText, hfontOld);
    SelectObject(hdcMem, hfontOld);

exit:
    if (hbmpText)
        DeleteObject(hbmpText);

    if (hdcText)
        DeleteDC(hdcText);

    if (hbmpMem)
        DeleteObject(hbmpMem);

    if (hdcMem)
        DeleteDC(hdcMem);

    if (hbrWhite)
    {
        DeleteObject(hbrWhite);
    }
    if (hbrBlack)
    {
        DeleteObject(hbrBlack);
    }

    return nNumLines;
}


void AnimateNext()
{
    if (g_uiAnimateIndex != (UINT)-1)
    {
        g_uiAnimateIndex++;
        if (bb_text[dwBBTextType][g_uiAnimateIndex].uiTitle == 0)
            g_uiAnimateIndex = 0;
    }
}

BOOL InitAnimate(HWND hwnd, HDC hdc)
{
    int     cxBB;
    int     cyBB;
    RECT    rcBB;
    HDC     hdcMem;
    RECT    rcBBToParent;
    BOOL    retval = FALSE;

    if (GetClientRect(hwnd, &rcBB))
    {
            
        cxBB = rcBB.right - rcBB.left;
        cyBB = rcBB.bottom - rcBB.top;

        if (g_hbmp)
        {
            SelectObject(g_hdcCache, g_hbmpOldCache);    
            DeleteObject(g_hbmp);
            g_hbmp = NULL;
        }

        if (g_hdcCache)
        {
            DeleteDC(g_hdcCache);
            g_hdcCache = NULL;
        }

        g_hdcCache = CreateCompatibleDC(hdc);
        g_hbmp = CreateCompatibleBitmap(hdc, cxBB, cyBB);
        if (g_hdcCache && g_hbmp)
        {
            g_hbmpOldCache = SelectObject(g_hdcCache, g_hbmp);

            hdcMem = GetBackgroundBuffer();
            
            GetRectInParent(hwnd, &rcBB, &rcBBToParent);
            
            retval = BitBlt(g_hdcCache,
                            0,
                            0,
                            cxBB,
                            cyBB,
                            hdcMem,
                            rcBBToParent.left,
                            rcBBToParent.top,
                            SRCCOPY);
        }                
        
    }

    return retval;
    
}

void TerminateAnimate()
{
    
    RestoreCachedRect();

    if (g_hbmp)
    {
        SelectObject(g_hdcCache, g_hbmpOldCache);    
        DeleteObject(g_hbmp);
        g_hbmp = NULL;
    }

    if (g_hdcCache)
    {
        DeleteDC(g_hdcCache);
        g_hdcCache = NULL;
    }
    
    GetDeleteFontHandle(FONT_DELETE);


}

/*********************************************************************************
*
* Animate()
*
* Main animation function.
*
*********************************************************************************/
void Animate(HDC hdc)
{
    RECT rc;
    ANISTRINGFORM ani;
    int nPadBuffer, nLinePad, nWndHeight, nNumLines = 0;
    TCHAR  sz[MAX_STRING];
    TCHAR  szText[MAX_STRING];
    int iOldMapMode;
    if (g_uiAnimateIndex == (UINT)-1)
        return;

    if (!GetClientRect(GetBBHwnd(), &rc))
    {
        return;
    }

    iOldMapMode = SetMapMode(hdc, MM_TEXT);
    
    if(g_nAnimID != 7)
    {
        RestoreRect(hdc, &rc, AB_HOR_POS);
    }
    
    rc.left = g_cxBillBrdHMargin;
    rc.top = g_cyBillBrdTitleTop;
    rc.right = g_cxBillBrdTitleWidth;
    rc.bottom = g_cyBillBrdHeight;
    
    nWndHeight = GetSystemMetrics(SM_CYSCREEN);
    nPadBuffer = nWndHeight / 80;    // 6 pixels @ 640x480
    nLinePad   = nWndHeight / 80;    // 6 pixels @ 640x480
    
    ani.col = g_colTitle;
    ani.colShadow = g_colTitleShadow;
    ani.bShadow = g_bTitleShadow;
    ani.uiLineHeightx2 = 2;
    ani.rc.top = rc.top;
    ani.rc.bottom = rc.bottom;
    ani.rc.left = rc.left;
    ani.rc.right = rc.right;
    ani.hFont = GetDeleteFontHandle(FONT_TITLE);
    if (LoadString(g_hInstance, bb_text[dwBBTextType][g_uiAnimateIndex].uiTitle, (LPTSTR)sz, sizeof(sz)/sizeof(TCHAR)))
    {
        nNumLines = AnimateString(hdc, sz, &ani, 0, g_nAnimID);
    }

    rc.top += (g_nTFontHeight * 2 + nLinePad) * nNumLines;
    rc.right = g_cxBillBrdBodyWidth;
    
    if (LoadString(g_hInstance, bb_text[dwBBTextType][g_uiAnimateIndex].uiText, (LPTSTR)sz, sizeof(sz)/sizeof(TCHAR)))
    {
        UINT i = 0;
        // Process the string so that we can have paragraphs.
        // /r/n marks end of line
        // 
        while (sz[i] != TEXT('\0'))
        {
            UINT j = 0;
            // see if the author has a hard line break
            // If, just give the line until the line break to display
            // The rest is done hte next time around.
            while ((sz[i] != TEXT('\0')) && (sz[i] != TEXT('\r')) && (sz[i] != TEXT('\n')) )
            {
                szText[j] = sz[i];
                j++;
                i++;
            }
            // if there is a line break character, skip this one.
            if (sz[i] != TEXT('\0'))
                i++;
            szText[j] = TEXT('\0');
            ani.col = g_colText;
            ani.colShadow = g_colTextShadow;
            ani.bShadow = g_bTextShadow;
            ani.uiLineHeightx2 = 3;
            ani.rc.top = rc.top;
            ani.rc.bottom = rc.bottom;
            ani.rc.left = rc.left;
            ani.rc.right = rc.right;
            ani.hFont = GetDeleteFontHandle(FONT_TEXT);
            nNumLines = AnimateString(hdc, szText, &ani, g_nBLineSpace, g_nAnimID);
            if (*szText)
            {
                rc.top += (g_nBFontHeight * (100 + g_nBLineSpace) / 100 + nLinePad) * nNumLines;
                rc.bottom += (g_nBFontHeight * (100 + g_nBLineSpace) / 100 + nLinePad) * nNumLines;
            }
            else
            {
                rc.top += g_nBFontHeight * (100 + g_nBLineSpace) / 100 + nPadBuffer;
                rc.bottom += g_nBFontHeight * (100 + g_nBLineSpace) / 100 + nPadBuffer;
            }
            // assume that there are allways \r\n for one line break. Skip the other one
            if ((sz[i] != TEXT('\0')) && ((sz[i] == TEXT('\r')) || (sz[i] == TEXT('\n')) ) )
                i++;
        }
    }

    SetMapMode(hdc, iOldMapMode);
    
}

/*****************************************************************************************
* This function displays a text string on the given coordinates. It figures
* out word wraping and distance between lines based on the font. the pNumLines
* param is set to indicate the num of lines output after wrapping text(NULL if failed).
* Returns The result from TextOut.
*****************************************************************************************/ 
BOOL DisplayString(
    HDC hdc,
    int x,
    int y,
    TEXTMETRIC* lptm,
    int iLineSpace,
    RECT* lprc,
    LPINT pNumLines,
    LPTSTR szTextOut,
    WORD wfPlacement)
{
    LPTSTR  szWorkBuffer = NULL;
    BOOL    ret = FALSE;
    int     newX = 0;

    // The multiplication factor 2 handle the worst case scenario, in which
    // every character can have a line break followed by it, but no '|'
    // character is specified in the string.
    szWorkBuffer = (LPTSTR)HeapAlloc(
        GetProcessHeap(),
        0,
        (lstrlen(szTextOut) + 1) * sizeof(TCHAR) * 2);
    
    if (szWorkBuffer)
    {       
        lstrcpy(szWorkBuffer, szTextOut);
        if(CheckForBulletAndRemoveMarker(szWorkBuffer, &newX))
        {
            newX += (x + 10); //leave space for the bullet bitmap
        }
        else
        {
            newX = x;
        }
        *pNumLines = WrapText(hdc, newX, lprc, szWorkBuffer);
        ret = DrawWrapText(hdc, lptm, iLineSpace, newX, y, lprc, wfPlacement, *pNumLines, szWorkBuffer);

        HeapFree(GetProcessHeap(), 0, szWorkBuffer);
    }

    return ret;
        
}

int WrapText(
    IN HDC          hdc,
    IN int          x,
    IN RECT*        lprc,
    IN OUT LPTSTR   szBBResource)
{
    BOOL    bDoneText = FALSE;
    int     iNumLines = 0;
    LPTSTR  pBBResource = szBBResource;
    LPTSTR  szRemainedWords = NULL;
    TCHAR   szCurrentLine[MAX_STRING];
    TCHAR   szCurrentLineWords[MAX_STRING];
    LPTSTR  pRemainedWords = NULL;
    LPTSTR  pCurrentLineWords = NULL;
    LPTSTR  pCurrentLine = NULL;
    SIZE    sz;
    LONG    uiRCWidth;

    szRemainedWords = (LPTSTR)HeapAlloc(
        GetProcessHeap(),
        0,
        (lstrlen(szBBResource) + 1) * sizeof(TCHAR));

    if(szRemainedWords)
    {
        lstrcpy(szRemainedWords, szBBResource);
    }
    else
    {
        return 0;
    }

    uiRCWidth = lprc->right - lprc->left - x;
    
    while(!bDoneText)
    {
        *szCurrentLine = TEXT('\0');
        
        pCurrentLineWords = szCurrentLineWords;
        pRemainedWords = szRemainedWords;
        pCurrentLine = szCurrentLine;
        
        RemoveLineBreakChar(pRemainedWords, pCurrentLine);
        GetTextExtentPoint32(hdc, pCurrentLine, lstrlen(pCurrentLine), &sz);

        ZeroMemory( szCurrentLine , sizeof(szCurrentLine));
        ZeroMemory( szCurrentLineWords , sizeof(szCurrentLineWords));

        if(uiRCWidth >= sz.cx)
        {
            RemoveLineBreakChar(pRemainedWords, pCurrentLine);
            bDoneText = TRUE;
        }
        else 
        {
            // break up string into displayable segment
            
            BOOL bDoneLine = FALSE;
        
            while(!bDoneLine)
            {
                BOOL bDoneWord = FALSE;
                
                while(!bDoneWord) 
                {
                    *pCurrentLineWords = TEXT('\0'); //null terminate for GetTextExtent

                    GetTextExtentPoint32(hdc, szCurrentLineWords, lstrlen(szCurrentLineWords), &sz);
                    
                    if(*pRemainedWords == TEXT('|')) //Line break char (potential line break)
                    {
                        pRemainedWords = CharNext(pRemainedWords);
                        bDoneWord = TRUE;
                    }
                    else if( *pRemainedWords == TEXT('\0')) //end of string
                    {
                        bDoneWord = TRUE;
                        bDoneLine = TRUE;
                    }
                    else if((sz.cx + 2 >= uiRCWidth ) && (lstrcmp(szCurrentLine, TEXT("") ) == 0))
                    //if the word is too big to fit on one line then break out. Code outside this
                    //loop will add a space in word and this will cause a line break.
                    {
                        bDoneWord = TRUE;
                    }
                    else
                    {
                        *pCurrentLineWords = *pRemainedWords;

#ifndef UNICODE
                        if(IsDBCSLeadByte(*pCurrentLineWords))
                        {
                            *(pCurrentLineWords+1) = *(pRemainedWords+1);
                        }
#endif
                        pCurrentLineWords = CharNext(pCurrentLineWords);
                        pRemainedWords = CharNext(pRemainedWords);
                    }
                }

                //Check if the current buffers extent is more than the width
                GetTextExtentPoint32(hdc, szCurrentLineWords, lstrlen(szCurrentLineWords), &sz);
            
                if((sz.cx >= uiRCWidth ) && (lstrcmp(szCurrentLine, TEXT("") ) != 0)) 
                {
                    //string is too big && saved str is not empty(use previously saved str)
                    bDoneLine = TRUE;
                }
                else
                {
                    *pCurrentLineWords = TEXT('\0');        //dont inc because we want to overwrite later
                    lstrcpy(szCurrentLine, szCurrentLineWords);    //append next word to string
                    lstrcpy(szRemainedWords, pRemainedWords);
                    pRemainedWords = szRemainedWords;
                }
            }
        }
        
        lstrcpy(pBBResource, szCurrentLine);
        pBBResource = &(pBBResource[lstrlen(szCurrentLine)+1]);
        iNumLines++;
        
    }

    HeapFree(GetProcessHeap(), 0, szRemainedWords);
    
    return iNumLines;

}

BOOL DrawWrapText(
    IN HDC          hdc,
    IN TEXTMETRIC*  lptm,
    IN int          iLineSpace,
    IN int          x,
    IN int          y,
    IN RECT*        lprc,
    IN WORD         wfPlacement,
    IN int          iLineCount,
    IN LPTSTR       szLines)
{
    UINT        uiTxtAlign = 0;
    BOOL        bRet = TRUE;
    SIZE        sz;
    int         Ly = 0;
    int         Lx = 0;
    LPTSTR      szText = szLines;
    int         i = 0;

    if (g_bBiDi)
    {
        uiTxtAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, uiTxtAlign|TA_RIGHT|TA_RTLREADING);
    }

    while (TRUE)
    {
        if(wfPlacement == CENTER)
        {
            //Get the dimensions of current string

            GetTextExtentPoint32(hdc, szText, lstrlen(szText), &sz);

            //x co-ord for TextOut 
            if (g_bBiDi)
                Lx = lprc->right - (((lprc->right - lprc->left) - sz.cx)/2);
            else
                Lx = lprc->left + (((lprc->right - lprc->left) - sz.cx)/2);
        }
        else
        {
            //x co-ord for TextOut 
            if (g_bBiDi)
                Lx = lprc->right - x;
            else
                Lx = lprc->left + x;
        }
        
        //calculate (y co-ord) for TextOut
        Ly = y + lptm->tmHeight * i + lptm->tmHeight * i * iLineSpace / 100;

        if (g_bBiDi)
        {
            bRet = ExtTextOut(hdc, Lx, Ly, ETO_RTLREADING, NULL, szText, lstrlen(szText), NULL);
        }
        else
        {
            bRet = TextOut(hdc, Lx, Ly, szText, lstrlen(szText));
        }

        if (!bRet) break;

        if (++i >= iLineCount) break;

        szText = &(szText[lstrlen(szText)+1]);

    }

    if (g_bBiDi)
    {
        SetTextAlign(hdc, uiTxtAlign);
    }

    return bRet;
}

LPTSTR
StringReverseChar(
    LPTSTR psz,
    TCHAR ch)
{
    PTCHAR pch;

    pch = psz + lstrlen(psz);
    while (pch != psz && *pch != ch)
    {
        pch = CharPrev(psz, pch);
    }

    if (*pch != ch)
    {
        pch = NULL;
    }

    return pch;
}

VOID ImproveWrap(
    IN OUT LPTSTR szLines,
    IN OUT PINT   piNumLine,
    IN     LPTSTR szOrigText,
    IN     INT    cchOrigText
    )

/*++

Routine Description:

    Force to wrap the last 'wrappable' part of the last line, if the last line
    contains more than one 'wrappable' parts.

Arguments:

    szLines     - The result of WrapText, contains lines delimited by '\0'

    iNumLine    - Number of line in szLines

    szOrigText  - The original text that produces szLines, null-terminated

    cchOrigText - Number of characters in szOrigText

Return Values:

    szLines     - if the last line contains more than one 'wrappable' parts,
                  szLines is modified.

--*/

{
#define NEAT_WRAPPING_RATIO  0.75

    PTCHAR pLastLineStart;
    int    cchLastLine;
    PTCHAR pLastWrapPartStart;
    int    cchLastWrapPart;
    int    iLineRemain;

    pLastLineStart = szLines;
    iLineRemain = *piNumLine;
    while (iLineRemain > 1)
    {
        pLastLineStart += lstrlen(pLastLineStart) + 1;
        iLineRemain--;
    }
    cchLastLine = lstrlen(pLastLineStart);

    pLastWrapPartStart = StringReverseChar(szOrigText, (TCHAR)'|');
    
    if (pLastWrapPartStart != NULL)
    {
        pLastWrapPartStart = CharNext(pLastWrapPartStart);
        cchLastWrapPart = lstrlen(pLastWrapPartStart);
        if ((cchLastLine * NEAT_WRAPPING_RATIO) > (double)cchLastWrapPart)
        {
            LPTSTR szTmp = pLastLineStart + (cchLastLine - cchLastWrapPart);

            MoveMemory(szTmp + 1, szTmp, (cchLastWrapPart + 1) * sizeof(TCHAR));
            szTmp[0] = (TCHAR)'\0';
            (*piNumLine)++;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\wmi\sample\wmilib\wmisamp.c ===
#include "ntos.h"
#include "io.h"

#include <stdarg.h>
#include <wmistr.h>

NTSTATUS
WmiSampSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WmiSampFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    );

NTSTATUS
WmiSampExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiSampSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiSampSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
WmiSampQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
WmiSampQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


NTSTATUS
WmiSampPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WmiSampForward(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
WmiSampUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
WmiSampCreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    LONG Instance
    );

NTSTATUS
WmiSampAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,WmiSampQueryWmiRegInfo)
#pragma alloc_text(PAGE,WmiSampQueryWmiDataBlock)
#pragma alloc_text(PAGE,WmiSampSetWmiDataBlock)
#pragma alloc_text(PAGE,WmiSampSetWmiDataItem)
#pragma alloc_text(PAGE,WmiSampExecuteWmiMethod)
#pragma alloc_text(PAGE,WmiSampFunctionControl)
#endif


// {15D851F1-6539-11d1-A529-00A0C9062910}

GUIDREGINFO WmiSampGuidList[] = 
{
    {
        { 0x15d851f1, 0x6539, 0x11d1, 0xa5, 0x29, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 },
        WMIREG_FLAG_EXPENSIVE
    },

};

ULONG WmiSampDummyData[4] = { 1, 2, 3, 4};

UNICODE_STRING WmiSampRegistryPath;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    Installable driver initialization entry point.
    This is where the driver is called when the driver is being loaded
    by the I/O system.  This entry point is called directly by the I/O system.

Arguments:
    DriverObject - pointer to the driver object
    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;
    
    WmiSampRegistryPath.Length = 0;
    WmiSampRegistryPath.MaximumLength = RegistryPath->Length;
    WmiSampRegistryPath.Buffer = ExAllocatePool(PagedPool, 
                                                RegistryPath->Length+2);
    RtlCopyUnicodeString(&WmiSampRegistryPath, RegistryPath);

    /*
    // Create dispatch points for the various events handled by this
    // driver.  For example, device I/O control calls (e.g., when a Win32
    // application calls the DeviceIoControl function) will be dispatched to
    // routine specified below in the IRP_MJ_DEVICE_CONTROL case.
    //
    // For more information about the IRP_XX_YYYY codes, please consult the
    // Windows NT DDK documentation.
    //
    */
    DriverObject->MajorFunction[IRP_MJ_CREATE] = WmiSampForward;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = WmiSampForward;
    DriverObject->DriverUnload = WmiSampUnload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = WmiSampForward;

    DriverObject->MajorFunction[IRP_MJ_PNP] = WmiSampPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = WmiSampForward;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = WmiSampSystemControl;
    DriverObject->DriverExtension->AddDevice = WmiSampAddDevice;

    return ntStatus;
}

NTSTATUS
WmiSampSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{	
    return(IoWMISystemControl((PWMILIB_INFO)DeviceObject->DeviceExtension,
                               DeviceObject,
                               Irp));
}


NTSTATUS
WmiSampPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description:
    Process the IRPs sent to this device.

Arguments:
    DeviceObject - pointer to a device object
    Irp          - pointer to an I/O Request Packet

Return Value:
    NTSTATUS
--*/
{
    PIO_STACK_LOCATION irpStack, nextStack;
    PWMILIB_INFO wmilibInfo;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    /*
    // Get a pointer to the device extension
    */
    wmilibInfo = (PWMILIB_INFO)DeviceObject->DeviceExtension;

    switch (irpStack->MinorFunction) 
    {
        case IRP_MN_START_DEVICE:
	{
            IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_REGISTER);
            break; //IRP_MN_START_DEVICE
        }
	
        case IRP_MN_REMOVE_DEVICE:
	{
            IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_DEREGISTER);
	    
            IoDetachDevice(wmilibInfo->LowerDeviceObject);
            IoDeleteDevice (DeviceObject);
	    
            break; //IRP_MN_REMOVE_DEVICE
        }
    }
    
    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(wmilibInfo->LowerDeviceObject, Irp);
    
    return(status);
}


NTSTATUS
WmiSampForward(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PIO_STACK_LOCATION irpStack, nextStack;
    PWMILIB_INFO wmilibInfo;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    /*
    // Get a pointer to the device extension
    */
    wmilibInfo = (PWMILIB_INFO)DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    
    status = IoCallDriver(wmilibInfo->LowerDeviceObject, Irp);
    
    return(status);
}


VOID
WmiSampUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++
Routine Description:
    Free all the allocated resources, etc.
    TODO: This is a placeholder for driver writer to add code on unload

Arguments:
    DriverObject - pointer to a driver object

Return Value:
    None
--*/
{
    ExFreePool(WmiSampRegistryPath.Buffer);
}



NTSTATUS
WmiSampCreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    LONG Instance
    )
/*++

Routine Description:
    Creates a Functional DeviceObject

Arguments:
    DriverObject - pointer to the driver object for device
    DeviceObject - pointer to DeviceObject pointer to return
                   created device object.
    Instance - instnace of the device create.

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise
--*/
{
    NTSTATUS status;
    WCHAR deviceNameBuffer[]  = L"\\Device\\Sample-0";
    UNICODE_STRING deviceNameUnicodeString;

    deviceNameBuffer[15] = (USHORT) ('0' + Instance);

    RtlInitUnicodeString (&deviceNameUnicodeString,
                          deviceNameBuffer);

    status = IoCreateDevice (DriverObject,
                               sizeof(WMILIB_INFO),
                               &deviceNameUnicodeString,
                               FILE_DEVICE_UNKNOWN,
                               0,
                               FALSE,
                               DeviceObject);


    return status;
}


ULONG Instance;

NTSTATUS
WmiSampAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:
    This routine is called to create a new instance of the device

Arguments:
    DriverObject - pointer to the driver object for this instance of Sample
    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                status;
    PDEVICE_OBJECT          deviceObject = NULL;
    PWMILIB_INFO            wmilibInfo;

    DbgBreakPoint();
    
    // create our functional device object (FDO)
    status = WmiSampCreateDeviceObject(DriverObject, &deviceObject, Instance++);

    if (NT_SUCCESS(status)) {
        wmilibInfo = deviceObject->DeviceExtension;

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
        // Add more flags here if your driver supports other specific
        // behavior.  For example, if your IRP_MJ_READ and IRP_MJ_WRITE
        // handlers support DIRECT_IO, you would set that flag here.
        //
        // Also, store away the Physical device Object
        */
        wmilibInfo->LowerPDO = PhysicalDeviceObject;

        //
        // Attach to the StackDeviceObject.  This is the device object that what we 
        // use to send Irps and Urbs down the USB software stack
        //
        wmilibInfo->LowerDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

    	wmilibInfo->GuidCount = 1;
    	wmilibInfo->GuidList = WmiSampGuidList;
		wmilibInfo->QueryWmiRegInfo = WmiSampQueryWmiRegInfo;
		wmilibInfo->QueryWmiDataBlock = WmiSampQueryWmiDataBlock;
		wmilibInfo->SetWmiDataBlock = WmiSampSetWmiDataBlock;
		wmilibInfo->SetWmiDataItem = WmiSampSetWmiDataItem;
		wmilibInfo->ExecuteWmiMethod = WmiSampExecuteWmiMethod;
		wmilibInfo->WmiFunctionControl = WmiSampFunctionControl; 
    }
    return(status);
}


NTSTATUS
WmiSampQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call 
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered 
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case 
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.
            
    InstanceName returns with the instance name for the guids if 
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver
        
Return Value:

    status

--*/
{
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &WmiSampRegistryPath;
    return(STATUS_SUCCESS);
}

NTSTATUS
WmiSampQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of 
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can 
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered
            
    BufferAvail on has the maximum size available to write the data
        block. 
            
    Buffer on return is filled with the returned data block
            
        
Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG sizeNeeded;
    
    switch (GuidIndex)
    {
        case 0:
        {
            sizeNeeded = 4 * sizeof(ULONG);
            if (BufferAvail >= sizeNeeded)
            {
                RtlCopyMemory(Buffer, WmiSampDummyData, sizeNeeded);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }
        
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
    
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);
    
    return(status);
}

NTSTATUS
WmiSampSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of 
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can 
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried
                
    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered
            
    BufferSize has the size of the data block passed
            
    Buffer has the new values for the data block
            
        
Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG sizeNeeded;
    
    switch(GuidIndex)
    {
        case 0:
        {
            sizeNeeded = 4 * sizeof(ULONG);
            if (BufferSize == sizeNeeded)
              {
                RtlCopyMemory(WmiSampDummyData, Buffer, sizeNeeded);
                status = STATUS_SUCCESS;
               } else {
                status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }
            
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
            
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);
    
    return(status);
}

NTSTATUS
WmiSampSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of 
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can 
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered
            
    DataItemId has the id of the data item being set
        
    BufferSize has the size of the data item passed
            
    Buffer has the new values for the data item
            
        
Return Value:

    status

--*/
{
    NTSTATUS status;
    
    switch(GuidIndex)
    {
        case 0:
        {
            if ((BufferSize == sizeof(ULONG)) &&
                (DataItemId <= 3))
              {
                  WmiSampDummyData[DataItemId] = *((PULONG)Buffer);
                   status = STATUS_SUCCESS;
               } else {
                   status = STATUS_INVALID_DEVICE_REQUEST;
               }
            break;
        }
            
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
        
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);
    
    return(status);
}


NTSTATUS
WmiSampExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the 
    driver has finished filling the data block it must call 
    ClassWmiCompleteRequest to complete the irp. The driver can 
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    Irp is the Irp that makes this request
        
    GuidIndex is the index into the list of guids provided when the
        device registered
            
    MethodId has the id of the method being called
            
    InBufferSize has the size of the data block passed in as the input to
        the method.
            
    OutBufferSize on entry has the maximum size available to write the
        returned data block. 
            
    Buffer is filled with the returned data block
            
        
Return Value:

    status

--*/
{
    ULONG sizeNeeded = 4 * sizeof(ULONG);
    NTSTATUS status;
    ULONG tempData[4];
    
    switch(GuidIndex)
    {
        case 0:
        {
            if (MethodId == 1)
            {            
                if (OutBufferSize >= sizeNeeded)
                {
        
                    if (InBufferSize == sizeNeeded)
                    {
                        RtlCopyMemory(tempData, Buffer, sizeNeeded);
                        RtlCopyMemory(Buffer, WmiSampDummyData, sizeNeeded);
                        RtlCopyMemory(WmiSampDummyData, tempData, sizeNeeded);
                
                        status = STATUS_SUCCESS;
                    } else {
                        status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
            } else {
                   status = STATUS_INVALID_DEVICE_REQUEST;
            }        
            break;
        }
        
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
    
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);
    
    return(status);
}

NTSTATUS
WmiSampFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a 
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

Arguments:

    DeviceObject is the device whose data block is being queried
        
    GuidIndex is the index into the list of guids provided when the
        device registered
            
    Function specifies which functionality is being enabled or disabled
            
    Enable is TRUE then the function is being enabled else disabled
        
Return Value:

    status

--*/
{
    NTSTATUS status;
    
    status = IoWMICompleteRequest((PWMILIB_INFO)DeviceObject->DeviceExtension,
		                             DeviceObject,
                                     Irp,
                                     STATUS_SUCCESS,
                                     0,
                                     IO_NO_INCREMENT);
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\basewin\basewin.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    basewin.c

Abstract:

    Program to run BaseWinOptions for a given inf file.

Author:

    Ted Miller (tedm) 27-Sep-1995


Revision History:

    Andrew Ritz (AndrewR) 13-Mar-2000  -- retool to call into syssetup export
                                          since basewinoptions is obsolete

--*/

#include <windows.h>
#include <tchar.h>
#include <setupapi.h>
#include <stdio.h>
#include "setuplog.h"
#include "sputils.h"

VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

BOOL
DoInstallComponentInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage,
    IN HINF     InfHandle,
    IN PCWSTR   InfSection
    );




VOID
Usage(
    VOID
    )
{
    _tprintf(TEXT("basewin installs the components in the specified inf\n"));
    _tprintf(TEXT("Usage: basewin <inf name> <section name>\n"));
}

VOID
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    PWSTR InfName;
    PWSTR SectionName;
    HINF InfHandle;
    BOOL b;
    SETUPLOG_CONTEXT Context;

    if(argc != 3) {
        Usage();
        goto c0;
    }

    if(!pSetupInitializeUtils()) {
        printf("Initialize failed\n");
        goto c0;
    }
    InitializeSetupLog(&Context);

    InfName = pSetupAnsiToUnicode(argv[1]);
    if(!InfName) {
        printf("Unable to convert %s to unicode\n",argv[1]);
        goto c1;
    }

    SectionName = pSetupAnsiToUnicode(argv[2]);
    if (!SectionName) {
        printf("Unable to convert %s to unicode\n",argv[2]);
        goto c2;
    }

    InfHandle = SetupOpenInfFile(InfName,NULL,INF_STYLE_WIN4,NULL);
    if(InfHandle == INVALID_HANDLE_VALUE) {
        printf("Unable to open inf %s\n",argv[1]);
        goto c3;
    }

    b = DoInstallComponentInfs(
                        NULL,
                        NULL,
                        0,
                        InfHandle,
                        SectionName);

    _tprintf(TEXT("DoInstallComponentInfs returns %s\n"),b? TEXT("TRUE") : TEXT("FALSE"));


    TerminateSetupLog(&Context);

    SetupCloseInfFile(InfHandle);

c3:
    pSetupFree(SectionName);
c2:
    pSetupFree(InfName);
c1:
    pSetupUninitializeUtils();
c0:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\billbrd.c ===
/*---------------------------------------------------------------------------
**
**-------------------------------------------------------------------------*/
#include <pch.h>
#include <commctrl.h>
#include "dibutil.h"
#include "billbrd.h"
#include "animate.h"

#ifdef  DBG

void _BB_Assert(LPCTSTR strFile, unsigned uLine)
{
    TCHAR   buf[512];
    
    wsprintf(buf, TEXT("Assertion failed: %s, line %u\n"),
        strFile, uLine);

    OutputDebugString(buf);    
}

#endif

#define     BILLBRD_TEXT_TIMERID        1
#define     WHISTLER_PROGRESS_TIMERID   2


// For how long is the text for the Billboard displayed
// before switching to the next text
#define BB_TEXT_DISPLAY   36000

// For how long is the whistler status move, in millis seconds
#define BB_WHISTLER_MOVE  100

// Name to the INI file which discribes the billboards
TCHAR g_szFileName[MAX_PATH];

// Path where to find the billboard bitmaps.
TCHAR g_szPath[MAX_PATH];

// this application instance
HINSTANCE g_hInstance = NULL;

// charset properties of font used by this application
BYTE g_bCharSet = 0;
BOOL g_bBiDi    = FALSE;


/**********************************************************************************
-----------------------------------------------------------------------------------
(LOGO)                      (banner)
-----------------------------------------------------------------------------------
STEP                         |BILLBRD (GetBBHwd)
                             |
                             |
                             |
-----------------------------|
ESTIMATE (TimeEstimate)      |
-----------------------------|
PROGRESSTEXT (ProgressText)  |
-----------------------------|
GAUGE (ProgressGauge)        |
-----------------------------|
INFOTEXT (InfoText)          |
                             |
-----------------------------------------------------------------------------------
                            (banner)
-----------------------------------------------------------------------------------

INFOBAR = STEP, ESTIMATE, GAUGE, PROGRESSTEXT and INFOTEXT

NOTE:
    Position of setup wizard is dependent on the the size and position of
    BILLBRD.
***********************************************************************************/
UINT g_cyBannerHeight = 0;
UINT g_cxLogo = 0;
UINT g_cyLogo = 0;
UINT g_cxInfoBarWidth  = 0;
UINT g_cyInfoBarHeight = 0;
UINT g_cxSteps         = 0;
UINT g_cySteps         = 0;
UINT g_cxStepsWidth    = 0;
UINT g_cyStepsHeight   = 0;
UINT g_cxProgressText          = 0;
UINT g_cyProgressText          = 0;
UINT g_cxProgressTextWidth     = 0;
UINT g_cyProgressTextHeight    = 0;
UINT g_cxGauge         = 0;
UINT g_cyGauge         = 0;
UINT g_cxGaugeWidth    = 0;
UINT g_cyGaugeHeight   = 0;
UINT g_cxEstimate          = 0;
UINT g_cyEstimate          = 0;
UINT g_cxEstimateWidth     = 0;
UINT g_cyEstimateHeight    = 0;
UINT g_cxInfoText           = 0;
UINT g_cyInfoText           = 0;
UINT g_cxInfoTextWidth      = 0;
UINT g_cyInfoTextHeight     = 0;
UINT g_cxBillBrd           = 0;
UINT g_cyBillBrd           = 0;
UINT g_cxBillBrdWidth      = 0;
UINT g_cyBillBrdHeight     = 0;
UINT g_cxBillBrdHMargin    = 0;
UINT g_cyBillBrdVMargin    = 0;
UINT g_cxBillBrdTitleWidth = 0;
UINT g_cyBillBrdTitleTop   = 0;
UINT g_cxBillBrdBodyWidth  = 0;

HWND g_hwndParent       = NULL;      // Parent of g_hwnd
HWND g_hwnd             = NULL;      // Parent of all the following windows
HWND g_hwndTimeEstimate = NULL;      // 'TIMEESTIMATE'
HWND g_hwndProgressText = NULL;      // 'PROGRESSTEXT'
HWND g_hwndProgressGauge= NULL;      // 'GAUGE'
HWND g_hwndInfoText     = NULL;      // 'INFOTEXT'
HWND g_hwndBB           = NULL;      // 'BILLBRD'
HWND g_hwndSteps        = NULL;      // 'STEP'
HWND g_hwndLogo         = NULL;      // 'LOGO'
HWND g_hwndStatus       = NULL;

UINT g_idbLogo           = 0;
UINT g_numBackground     = 0;
UINT g_idbBackground[3]  = {0, 0, 0};
UINT g_idbSelectedBullet = 0;
UINT g_idbReleasedBullet = 0;
UINT g_idbCurrentBullet  = 0;

const TCHAR g_cszClassName[]        = TEXT("RedCarpetWndClass");
const TCHAR g_szStepsClassName[]    = TEXT("InfoStepsWnd_Class");
const TCHAR g_szBillBoardClassName[]= TEXT("BillBoardWnd_Class");
const TCHAR g_szStatusClassName[]   = TEXT("BB_WhistlerStatus_Class");

LRESULT CALLBACK RedCarpetWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK BillBoardWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK AnimationWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK StatusSubClassWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK ProgressSubClassWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//----------
// BILLBRD
//----------
TCHAR   g_szTFont[32];
int     g_nTFontHeight;
int     g_nTFontWidth;
int     g_nTFontWeight;
BOOL    g_bTitleShadow = TRUE;
TCHAR   g_szBFont[32];
int     g_nBFontHeight;
int     g_nBFontWidth;
int     g_nBFontWeight;
BOOL    g_bTextShadow  = FALSE;
int     g_nBLineSpace;

int     g_nAnimID     = 0;
int     g_iCurPanel   = -1;           // Current billboard to show
int     g_nPanelCount = 0;            // how many billboards are there
int     g_nLogPixelsY = 1;

COLORREF g_colTitle       = 0;
COLORREF g_colTitleShadow = 0;
COLORREF g_colText        = 0;
COLORREF g_colTextShadow  = 0;


BB_TEXT bb_text_Personal[] = {
    {IDS_TITLE1_PER, IDS_TEXT1_PER, IDB_COLL1},
    {IDS_TITLE2_PER, IDS_TEXT2_PER, IDB_COLL2},
    {IDS_TITLE3_PER, IDS_TEXT3_PER, IDB_COLL2},
    {IDS_TITLE4_PER, IDS_TEXT4_PER, IDB_COLL3},
    {IDS_TITLE5_PER, IDS_TEXT5_PER, IDB_COLL3},
    {IDS_TITLE22_PER, IDS_TEXT22_PER, IDB_COLL10},
    {IDS_TITLE6_PER, IDS_TEXT6_PER, IDB_COLL4},
    {IDS_TITLE7_PER, IDS_TEXT7_PER, IDB_COLL4},
    {IDS_TITLE8_PER, IDS_TEXT8_PER, IDB_COLL5},
    {IDS_TITLE9_PER, IDS_TEXT9_PER, IDB_COLL5},
    {IDS_TITLE10_PER, IDS_TEXT10_PER, IDB_COLL6},
    {IDS_TITLE11_PER, IDS_TEXT11_PER, IDB_COLL6},
    {IDS_TITLE12_PER, IDS_TEXT12_PER, IDB_COLL7},
    {IDS_TITLE13_PER, IDS_TEXT13_PER, IDB_COLL7},
    {IDS_TITLE14_PER, IDS_TEXT14_PER, IDB_COLL8},
    {IDS_TITLE15_PER, IDS_TEXT15_PER, IDB_COLL8},
    {IDS_TITLE16_PER, IDS_TEXT16_PER, IDB_COLL9},
    {IDS_TITLE17_PER, IDS_TEXT17_PER, IDB_COLL9},
    {IDS_TITLE18_PER, IDS_TEXT18_PER, IDB_COLL10},
    {IDS_TITLE19_PER, IDS_TEXT19_PER, IDB_COLL10},
    {IDS_TITLE20_PER, IDS_TEXT20_PER, IDB_COLL10},
    {IDS_TITLE21_PER, IDS_TEXT21_PER, IDB_COLL10},
    {0,0,0}
};

BB_TEXT bb_text_Professional[] = {
    {IDS_TITLE1, IDS_TEXT1, IDB_COLL1},
    {IDS_TITLE2, IDS_TEXT2, IDB_COLL2},
    {IDS_TITLE3, IDS_TEXT3, IDB_COLL2},
    {IDS_TITLE4, IDS_TEXT4, IDB_COLL3},
    {IDS_TITLE5, IDS_TEXT5, IDB_COLL3},
    {IDS_TITLE6, IDS_TEXT6, IDB_COLL4},
    {IDS_TITLE7, IDS_TEXT7, IDB_COLL4},
    {IDS_TITLE8, IDS_TEXT8, IDB_COLL5},
    {IDS_TITLE9, IDS_TEXT9, IDB_COLL5},
    {IDS_TITLE18, IDS_TEXT18, IDB_COLL9},
    {IDS_TITLE10, IDS_TEXT10, IDB_COLL6},
    {IDS_TITLE11, IDS_TEXT11, IDB_COLL6},
    {IDS_TITLE12, IDS_TEXT12, IDB_COLL7},
    {IDS_TITLE13, IDS_TEXT13, IDB_COLL7},
    {IDS_TITLE14, IDS_TEXT14, IDB_COLL8},
    {IDS_TITLE15, IDS_TEXT15, IDB_COLL8},
    {IDS_TITLE16, IDS_TEXT16, IDB_COLL9},
    {IDS_TITLE17, IDS_TEXT17, IDB_COLL9},
    {0,0,0}
};

BB_TEXT bb_text_Blade[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE2_S, IDS_TEXT2_S, IDB_COLL2},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {IDS_TITLE10_S, IDS_TEXT10_S, IDB_COLL6},
    {0,0,0}
};

BB_TEXT bb_text_SmallBusiness[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {IDS_TITLE10_S, IDS_TEXT10_S, IDB_COLL6},
    {0,0,0}
};

BB_TEXT bb_text_Server[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE2_S, IDS_TEXT2_S, IDB_COLL2},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {IDS_TITLE10_S, IDS_TEXT10_S, IDB_COLL6},
    {0,0,0}
};

BB_TEXT bb_text_AdvancedServer[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE2_S, IDS_TEXT2_S, IDB_COLL2},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {IDS_TITLE10_S, IDS_TEXT10_S, IDB_COLL6},
    {0,0,0}
};

BB_TEXT bb_text_DataCenter[] = {
    {IDS_TITLE1_S, IDS_TEXT1_S, IDB_COLL1},
    {IDS_TITLE2_S, IDS_TEXT2_S, IDB_COLL2},
    {IDS_TITLE3_S, IDS_TEXT3_S, IDB_COLL2},
    {IDS_TITLE4_S, IDS_TEXT4_S, IDB_COLL3},
    {IDS_TITLE5_S, IDS_TEXT5_S, IDB_COLL3},
    {IDS_TITLE6_S, IDS_TEXT6_S, IDB_COLL4},
    {IDS_TITLE7_S, IDS_TEXT7_S, IDB_COLL4},
    {IDS_TITLE8_S, IDS_TEXT8_S, IDB_COLL5},
    {IDS_TITLE9_S, IDS_TEXT9_S, IDB_COLL5},
    {IDS_TITLE10_S, IDS_TEXT10_S, IDB_COLL6},
    {0,0,0}
};

BB_TEXT bb_text_Professional_IA64[] = {
    {IDS_TITLE1_64PRO, IDS_TEXT1_64PRO, IDB_COLL1},
    {IDS_TITLE2_64PRO, IDS_TEXT2_64PRO, IDB_COLL2},
    {IDS_TITLE3_64PRO, IDS_TEXT3_64PRO, IDB_COLL2},
    {IDS_TITLE4_64PRO, IDS_TEXT4_64PRO, IDB_COLL3},
    {IDS_TITLE5_64PRO, IDS_TEXT5_64PRO, IDB_COLL3},
    {IDS_TITLE6_64PRO, IDS_TEXT6_64PRO, IDB_COLL4},
    {IDS_TITLE7_64PRO, IDS_TEXT7_64PRO, IDB_COLL4},
    {IDS_TITLE8_64PRO, IDS_TEXT8_64PRO, IDB_COLL5},
    {IDS_TITLE9_64PRO, IDS_TEXT9_64PRO, IDB_COLL5},
    {IDS_TITLE10_64PRO, IDS_TEXT10_64PRO, IDB_COLL6},
    {IDS_TITLE11_64PRO, IDS_TEXT11_64PRO, IDB_COLL6},
    {IDS_TITLE12_64PRO, IDS_TEXT12_64PRO, IDB_COLL7},
    {IDS_TITLE13_64PRO, IDS_TEXT13_64PRO, IDB_COLL7},
    {0,0,0}
};

// 0 - professional,
// 1 - Server, 
// 2 - Advanced Server,
// 3 - Data Center,
// 4 - for personal
// 5 - for Blade
// 6 - for SmallBusiness
DWORD    dwBBTextType = 0; 

// Be careful with this order. It has to be the same as 
// *_PRODUCTTYPE in winnt32.h
#ifdef _X86_
BB_TEXT* bb_text[] = { bb_text_Professional,
                       bb_text_Server,
                       bb_text_AdvancedServer,
                       bb_text_DataCenter,
                       bb_text_Personal,
                       bb_text_Blade,
                       bb_text_SmallBusiness};
#else
BB_TEXT* bb_text[] = { bb_text_Professional_IA64,
                       bb_text_Server,
                       bb_text_AdvancedServer,
                       bb_text_DataCenter,
                       bb_text_Personal };
#endif

HDC     g_hdcBbMem     = NULL;
HBITMAP g_hbmpBbMemOld = NULL;

HDC 
GetBillboardBuffer();

BOOL
BufferBillboard(
    IN  HWND   hwnd,
    IN  HDC    hdc
    );

VOID
DestroyBillboardBuffer();

//---------
// INFOBAR
//---------
COLORREF g_colInfoText        = 0;
COLORREF g_colStepsTxt        = 0;
COLORREF g_colStepsMarkTxt    = 0;
COLORREF g_colStepsCurrentTxt = 0;
COLORREF g_colStepsTitle      = 0;
COLORREF g_colGaugeBg         = 0;
COLORREF g_colGauge           = 0;
COLORREF g_colBulletTrans     = 0;

//-------------
// TIMEESTIMATE
//-------------
// Original position of the progress text window
// Since we want the text adjusted to the bottom of the window
// we resize the window as needed, but should not grow it 
// beyond the original size.
RECT g_rcProgressText;

//-----
// LOGO
//-----
HBITMAP g_hbmWinLogo  = NULL;
COLORREF g_colLogoTransparency = RGB(0, 0, 0);
COLORREF g_colStatusTransperency = RGB(0, 0, 0);

//-----------
// background
//-----------
HDC     g_hdcMem     = NULL;
HBITMAP g_hbmpMemOld = NULL;
INT     g_iStretchMode = STRETCH_ANDSCANS;


BOOL
BufferBackground(
    IN  HWND   hwnd
    );

LRESULT
OnEraseBkgnd(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
DestroyBackgroundBuffer();

HBITMAP
MyLoadImage(
    IN HDC    hdc,
    IN UINT*  idbBackground,
    IN int    iNumImage
    );

void SetFontCharSet(void)
{
    HFONT   hFont = NULL;
    LOGFONT lf;

    //init font charset
    hFont = GetStockObject(SYSTEM_FONT);
    if(hFont)
    {
        if(GetObject(hFont, sizeof(lf), &lf))
            g_bCharSet = lf.lfCharSet;
        DeleteObject(hFont);
    }
}

void SetFontColor(HWND hwnd)
{
    HDC  hdc;
    UINT uiBitsPixel;

    hdc = GetDC(hwnd);
    uiBitsPixel = (UINT) GetDeviceCaps(hdc, BITSPIXEL);

    if (uiBitsPixel > 8)
    {
        g_colTitle = COLOR_TITLE_C16BIT;
        g_colTitleShadow = COLOR_SHADOW_C16BIT;
        g_colText = COLOR_TEXT_C16BIT;
        g_colTextShadow = COLOR_SHADOW_C16BIT;
        g_colInfoText = UI_INFOTEXT_COLOR_C16BIT;
        g_colStepsTxt = UI_STEPSTEXT_COLOR_C16BIT;
        g_colStepsMarkTxt = UI_STEPSTEXT_MARK_COLOR_C16BIT;
        g_colStepsCurrentTxt = UI_STEPSTEXT_CURRENT_COLOR_C16BIT;
        g_colStepsTitle = UI_STEPSTITLE_COLOR_C16BIT;
        g_colGaugeBg = UI_GAUGE_BACKGROUND_COLOR_C16BIT;
        g_colGauge = UI_GAUGE_COLOR_C16BIT;
        g_colStatusTransperency = UI_STATUS_TRANSPARENT_COLOR_C16BIT;
        g_colLogoTransparency = UI_LOGO_TRANSPARENT_COLOR_C16BIT;
        g_colBulletTrans = UI_BULLET_TRANPARENT_COLOR_C16BIT;
    } else {
        g_colTitle = COLOR_TITLE_C4BIT;
        g_colTitleShadow = COLOR_SHADOW_C4BIT;
        g_colText = COLOR_TEXT_C4BIT;
        g_colTextShadow = COLOR_SHADOW_C4BIT;
        g_colInfoText = UI_INFOTEXT_COLOR_C4BIT;
        g_colStepsTxt = UI_STEPSTEXT_COLOR_C4BIT;
        g_colStepsCurrentTxt = UI_STEPSTEXT_CURRENT_COLOR_C4BIT;
        g_colStepsMarkTxt = UI_STEPSTEXT_MARK_COLOR_C4BIT;
        g_colStepsTitle = UI_STEPSTITLE_COLOR_C4BIT;
        g_colGaugeBg = UI_GAUGE_BACKGROUND_COLOR_C4BIT;
        g_colGauge = UI_GAUGE_COLOR_C4BIT;
        g_colStatusTransperency = UI_STATUS_TRANSPARENT_COLOR_C4BIT;
        g_colLogoTransparency = UI_LOGO_TRANSPARENT_COLOR_C4BIT;
        g_colBulletTrans = UI_BULLET_TRANPARENT_COLOR_C4BIT;
    }

    ReleaseDC(hwnd, hdc);
}


typedef struct _RES_FONTSIZES {
    UINT    uiID;
    UINT    uiDefault;
} RES_FONTSIZES;

RES_FONTSIZES res_1024[] = {
    {IDS_TITLEFONTSIZE_1024, 24},
    {IDS_TITLEFONTWIDTH_1024, 0},
    {IDS_TEXTFONTSIZE_1024, 11},
    {IDS_TEXTFONTWIDTH_1024, 0}
};

RES_FONTSIZES res_800[] = {
    {IDS_TITLEFONTSIZE_800, 21},
    {IDS_TITLEFONTWIDTH_800, 0},
    {IDS_TEXTFONTSIZE_800, 10},
    {IDS_TEXTFONTWIDTH_800, 0}
};

RES_FONTSIZES res_640[] = {
    {IDS_TITLEFONTSIZE_640, 18},
    {IDS_TITLEFONTWIDTH_640, 0},
    {IDS_TEXTFONTSIZE_640, 9},
    {IDS_TEXTFONTWIDTH_640, 0}
};

void GetMyFontsFromFile()
{
    RECT          rc;
    int           iSize = 0;
    TCHAR         szBuf[25];
    RES_FONTSIZES *pres_fontsize = NULL;

    iSize = GetSystemMetrics(SM_CXSCREEN);

    if (iSize >= 1024)
    {
        pres_fontsize = res_1024;
    }
    else if (iSize == 800)
    {
        pres_fontsize = res_800;
    }
    else
    {
        pres_fontsize = res_640;
    }

    if (LoadString(g_hInstance, pres_fontsize[0].uiID, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nTFontHeight = MyAtoI((const TCHAR*)szBuf);
    else
        g_nTFontHeight = pres_fontsize[0].uiDefault;

    if (LoadString(g_hInstance, pres_fontsize[1].uiID, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nTFontWidth = MyAtoI((const TCHAR*)szBuf);
    else
        g_nTFontWidth = pres_fontsize[1].uiDefault;

    if (LoadString(g_hInstance, pres_fontsize[2].uiID, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nBFontHeight = MyAtoI((const TCHAR*)szBuf);
    else
        g_nBFontHeight = pres_fontsize[2].uiDefault;

    if (LoadString(g_hInstance, pres_fontsize[3].uiID, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nBFontWidth = MyAtoI((const TCHAR*)szBuf);
    else
        g_nBFontWidth = pres_fontsize[3].uiDefault;


    if (!(LoadString(g_hInstance, IDS_TITLEFONTNAME, (LPTSTR)g_szTFont, sizeof(g_szTFont)/sizeof(TCHAR))))
        lstrcpy(g_szTFont, TEXT("Arial"));

    if (LoadString(g_hInstance, IDD_TITLEFONTWEIGHT, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nTFontWeight = MyAtoI((const TCHAR*)szBuf);
    else
        g_nTFontWeight = FW_BOLD;

    if (!(LoadString(g_hInstance, IDS_TEXTFONTNAME, (LPTSTR)g_szBFont, sizeof(g_szBFont)/sizeof(TCHAR))))
        lstrcpy(g_szBFont, TEXT("Arial"));

    if (LoadString(g_hInstance, IDD_TEXTFONTWEIGHT, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nBFontWeight = MyAtoI((const TCHAR*)szBuf);
    else
        g_nBFontWeight = FW_BOLD;

    if (LoadString(g_hInstance, IDD_BIDI, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_bBiDi = (0 != MyAtoI((const TCHAR*)szBuf));
    else
        g_bBiDi = FALSE;

    if (LoadString(g_hInstance, IDS_TEXTFONT_LINESPACING, (LPTSTR)szBuf, sizeof(szBuf)/sizeof(TCHAR)))
        g_nBLineSpace = MyAtoI((const TCHAR*)szBuf);
    else
        g_nBLineSpace = 0;
    
    return;
}

void GetMyImagesFromFile(HWND hwnd)
{
    HDC     hdc;
    UINT    cxScreen;
    UINT    uiBitsPixel;

    cxScreen = (UINT) GetSystemMetrics(SM_CXSCREEN);
    
    hdc = GetDC(hwnd);
    if (hdc != NULL)
    {
        uiBitsPixel = (UINT) GetDeviceCaps(hdc, BITSPIXEL);
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        uiBitsPixel = 4;
    }

    if (uiBitsPixel > 8)
    {
        g_numBackground = 1;       
        g_iStretchMode  = STRETCH_DELETESCANS;

        if ((dwBBTextType == 0) ||
            (dwBBTextType == 4))
        {
            g_idbBackground[0] = IDB_BACKGROUND_C16BIT;
            g_idbSelectedBullet = IDB_SELECTEDBULLET_C16BIT;
            g_idbReleasedBullet = IDB_RELEASEDBULLET_C16BIT;
            g_idbCurrentBullet  = IDB_CURRENTBULLET_C16BIT;
            if (cxScreen >= 1024)
                g_idbLogo = IDB_LOGO1024_C16BIT;
            else if (cxScreen >= 800)
                g_idbLogo = IDB_LOGO800_C16BIT;
            else
                g_idbLogo = IDB_LOGO640_C16BIT;
        }
        else
        {
            g_idbBackground[0] = IDB_SRV_BACKGROUND_C16BIT;
            g_idbSelectedBullet = IDB_SRV_SELECTEDBULLET_C16BIT;
            g_idbReleasedBullet = IDB_SRV_RELEASEDBULLET_C16BIT;
            g_idbCurrentBullet  = IDB_SRV_CURRENTBULLET_C16BIT;
            if (cxScreen >= 1024)
                g_idbLogo = IDB_SRV_LOGO1024_C16BIT;
            else if (cxScreen >= 800)
                g_idbLogo = IDB_SRV_LOGO800_C16BIT;
            else
                g_idbLogo = IDB_SRV_LOGO640_C16BIT;
        }
    }
    else
    {
        g_numBackground = 1;
        g_iStretchMode  = STRETCH_ANDSCANS;    
        
        if ((dwBBTextType == 0) ||
            (dwBBTextType == 4))
        {
            g_idbBackground[0] = IDB_BACKGROUND_C4BIT;
            g_idbSelectedBullet = IDB_SELECTEDBULLET_C4BIT;
            g_idbReleasedBullet = IDB_RELEASEDBULLET_C4BIT;
            g_idbCurrentBullet  = IDB_CURRENTBULLET_C4BIT;
            if (cxScreen >= 1024)
                g_idbLogo = IDB_LOGO1024_C4BIT;
            else if (cxScreen >= 800)
                g_idbLogo = IDB_LOGO800_C4BIT;
            else
                g_idbLogo = IDB_LOGO640_C4BIT;
        }
        else
        {
            g_idbBackground[0] = IDB_SRV_BACKGROUND_C4BIT;
            g_idbSelectedBullet = IDB_SRV_SELECTEDBULLET_C4BIT;
            g_idbReleasedBullet = IDB_SRV_RELEASEDBULLET_C4BIT;
            g_idbCurrentBullet  = IDB_SRV_CURRENTBULLET_C4BIT;
            if (cxScreen >= 1024)
                g_idbLogo = IDB_SRV_LOGO1024_C4BIT;
            else if (cxScreen >= 800)
                g_idbLogo = IDB_SRV_LOGO800_C4BIT;
            else
                g_idbLogo = IDB_SRV_LOGO640_C4BIT;
        }
    }

}

/****************************************************************************
* SetLayoutParams()
*
* Set all the layout parameter for Billboard. All the floating point numbers
* come the design specification. This function uses the values of 
* g_nBFontHeight and g_nTFontHeight.

* NOTE: Call this function again and MoveWindow afterward, in case of 
* resolution changes
*
*****************************************************************************/
void 
SetLayoutParams()
{
    int cxScreen;
    int cyScreen;
    int iCommentLeft;
    int iCommonWidth;
    int iFontHeight;
    RECT rcSteps;
    UINT cySteps;
    
    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);
    iFontHeight = abs(GetInfoBarFontHeight());

    g_cyBannerHeight = cyScreen * 13 / 200;

    g_cxLogo = (UINT) (cxScreen * 0.0195);
    g_cyLogo = (UINT) (cyScreen * 0.0053);

    g_cxInfoBarWidth  = (cxScreen) * 28 / 100;
    g_cyInfoBarHeight = (cyScreen) - g_cyBannerHeight * 2;

    if (cxScreen < 800) 
    {        
        rcSteps.left   = g_cxInfoBarWidth * 3 / 20;
        rcSteps.top    = g_cyBannerHeight * 2;
        rcSteps.right  = g_cxInfoBarWidth - rcSteps.left;
        // Use 1.5 line height and reserve 2 lines for each step text, hence 7 / 2
        rcSteps.bottom = rcSteps.top + (iFontHeight * 7 / 2) * (UI_INFOBAR_NUM_STEPS) + 
                         (UINT) ((0.068) * cyScreen);
        
        iCommentLeft = rcSteps.left;
        iCommonWidth = g_cxInfoBarWidth - 2 * rcSteps.left;
        
    }
    else
    {
        rcSteps.left    = (UINT) (0.039 * cxScreen);
        rcSteps.top     = (UINT) (0.059 * cyScreen) + g_cyBannerHeight + 
                            g_nTFontHeight + g_nBFontHeight;
        rcSteps.right   = rcSteps.left + (UINT) (0.2005 * cxScreen);
        // Use 1.5 line height and reserve 1 line for each step text, hence 5 / 2
        rcSteps.bottom  = rcSteps.top + (iFontHeight * 5 / 2) * (UI_INFOBAR_NUM_STEPS) + 
                              (UINT) ((0.068) * cyScreen);
        
        iCommentLeft  = rcSteps.left;
        iCommonWidth  = (UINT) (0.1705 * cxScreen);
        
    }
       
    if (GetStepsHeight(g_cxInfoBarWidth, cyScreen, rcSteps, &cySteps))
    {
        rcSteps.bottom = cySteps;
    }
    
    g_cxSteps = rcSteps.left;
    g_cySteps = rcSteps.top;
    g_cxStepsWidth = rcSteps.right - rcSteps.left;
    g_cyStepsHeight = rcSteps.bottom - rcSteps.top;

       
    g_cxEstimate        = iCommentLeft;
    if (cxScreen < 800)
    {
        g_cyEstimate    = g_cyStepsHeight + g_cySteps + 3 * iFontHeight / 2;
    }
    else
    {
        g_cyEstimate    = g_cyStepsHeight + g_cySteps + (UINT) (0.063 * cyScreen);
    }
    g_cxEstimateWidth   = iCommonWidth;
    g_cyEstimateHeight  = iFontHeight * 5;

    g_cxProgressText        = iCommentLeft;
    g_cyProgressText        = g_cyEstimateHeight + g_cyEstimate;
    g_cxProgressTextWidth   = iCommonWidth;
    g_cyProgressTextHeight  = iFontHeight * 3;


    g_cxGauge         = iCommentLeft;
    g_cyGauge         = g_cyProgressTextHeight + g_cyProgressText + iFontHeight / 3;
    g_cxGaugeWidth    = iCommonWidth;
    g_cyGaugeHeight   = iFontHeight * 3 / 2;

    g_cxInfoText        = iCommentLeft;
    if (cxScreen < 800)
    {
        g_cyInfoText = g_cyGauge + g_cyGaugeHeight + iFontHeight;
        g_cyInfoTextHeight = cyScreen - g_cyInfoText - g_cyBannerHeight;
    }
    else
    {
        g_cyInfoTextHeight  = (cyScreen - g_cyGaugeHeight - iFontHeight / 3 -
                              g_cyGauge - g_cyBannerHeight) * 2 / 3 + iFontHeight;
        g_cyInfoText        = cyScreen - g_cyBannerHeight - g_cyInfoTextHeight;
    }
    g_cxInfoTextWidth   = iCommonWidth;

    if (g_bBiDi)
    {
        // mirroring along the center of infobar.
        int shiftAmt = g_cxInfoBarWidth - 2 * g_cxEstimate - g_cxEstimateWidth;
        if (shiftAmt < 0)
        {
            shiftAmt = 0;
        }
        g_cxSteps = g_cxInfoBarWidth - g_cxSteps - g_cxStepsWidth - shiftAmt;
        g_cxEstimate = g_cxInfoBarWidth - g_cxEstimate - g_cxEstimateWidth - shiftAmt;
        g_cxProgressText = g_cxInfoBarWidth - g_cxProgressText - g_cxProgressTextWidth - shiftAmt;
        g_cxGauge = g_cxInfoBarWidth - g_cxGauge - g_cxGaugeWidth - shiftAmt;
        g_cxInfoText = g_cxInfoBarWidth - g_cxInfoText - g_cxInfoTextWidth - shiftAmt;
    }

    g_cxBillBrd        = g_cxInfoBarWidth;
    g_cyBillBrd        = g_cyBannerHeight;
    g_cxBillBrdWidth   = cxScreen - g_cxBillBrd;
    g_cyBillBrdHeight  = g_cyInfoBarHeight;
    g_cxBillBrdHMargin = (UINT) (cxScreen * 0.06);
    g_cyBillBrdVMargin = 0;
    
    // Only substract 2*margin for the area for the billboard title
    // otherwise the new text does not fit on 640x480
    g_cxBillBrdTitleWidth = g_cxBillBrdWidth - (2 * g_cxBillBrdHMargin);
    g_cyBillBrdTitleTop   = g_cySteps - g_cyBillBrd;
    
    // Only substract 2*margin for the area for the billboard text
    // otherwise the new text does not fit on 640x480
    g_cxBillBrdBodyWidth  = g_cxBillBrdWidth - (2 * g_cxBillBrdHMargin);
   
}


HDC
GetBackgroundBuffer()
{
    return g_hdcMem;
}

VOID
DestroyBackgroundBuffer()
{
    HBITMAP hbmpMem;

    hbmpMem = SelectObject(g_hdcMem, g_hbmpMemOld);
    if (hbmpMem)
    {
        DeleteObject(hbmpMem);
    }
    g_hbmpMemOld = NULL;

    DeleteDC(g_hdcMem);
    g_hdcMem = NULL;

}

BOOL 
StretchBitmapAndDisplay(
    HDC hdcDest,
    int nXOriginDest,
    int nYOriginDest,
    int nWidthDest,
    int nHeightDest,
    HDC hdcSrc,
    int nXOriginSrc,
    int nYOriginSrc,
    int nWidthSrc,
    int nHeightSrc,
    DWORD fdwRop
    )

/*++

Routine Description:

    This function takes a bitmap that needs to be displayed and stretches it 
    using GDI. Once the bitmap is stretched to the required dimentions we display
    it using BitBlt. We have to do this decause some buggy video drivers and or
    hardware hang on using StretchBlt.
    Or the StretchBlt would generate a corupted bitmap.

Arguments:

    hdcDest         destination device-context handle    
    nXOriginDest    x-coordinate of origin of destination rectangle    
    nYOriginDest    y-coordinate of origin of destination rectangle    
    nWidthDest      width of destination rectangle    
    nHeightDest     height of destination rectangle    
    hdcSrc          source device-context handle    
    nXOriginSrc     x-coordinate of origin of source rectangle    
    nYOriginSrc     y-coordinate of origin of source rectangle    
    nWidthSrc       width of source rectangle    
    nHeightSrc      height of source rectangle    
    fdwRop          raster operation

Return value:

    TRUE == SUCCESS


Changes:

    10/11/97        hanumany        Created
    04/30/01        chunhoc         Modified
    
--*/

{
    HDC     hdcTemp = NULL;
    BOOL    bRet = FALSE;
    int     iOldStretchMode = 0;
    HBITMAP hBmp = NULL;
    HBITMAP hBmpOld = NULL;
    UINT    uiNumColors = 0;
    
    //Create the temp DC
    hdcTemp = CreateCompatibleDC(hdcDest);

    //Create a bitmap
    hBmp = CreateCompatibleBitmap(hdcSrc, nWidthDest, nHeightDest);

    
    if(hdcTemp && hBmp)
    {
        // Select it into the temp DC
        hBmpOld = SelectObject(hdcTemp, hBmp);

        //set stretch blt mode
        iOldStretchMode = SetStretchBltMode(hdcTemp, g_iStretchMode);

        //StretchBlt
        bRet = StretchBlt(hdcTemp,
                          0,
                          0,
                          nWidthDest,
                          nHeightDest,
                          hdcSrc,
                          nXOriginSrc,
                          nYOriginSrc,
                          nWidthSrc,
                          nHeightSrc,
                          fdwRop);
            
        // restore the old stretch mode
        SetStretchBltMode(hdcTemp, iOldStretchMode);

        if(bRet)
        {
            //We succeeded in stretching the bitmap on the temp DC. Now lets BitBlt it.
            bRet = BitBlt(hdcDest,
                          nXOriginDest,
                          nYOriginDest,
                          nWidthDest,
                          nHeightDest,
                          hdcTemp,
                          0,
                          0,
                          SRCCOPY);                
        }
    }

    
    //CleanUp
    if(hBmpOld)
    {
        SelectObject(hdcTemp, hBmpOld);
    }

    if(hBmp)
    {
        DeleteObject(hBmp);
    }
    
    if(hdcTemp)
    {
        DeleteDC(hdcTemp);
    }
    
    return bRet;
}

BOOL
BufferBackground(
    IN  HWND   hwnd
    )

/*++

Routine Description:

    Create a memory buffer for the stretched bitmap to improve performance.

Arguments:

    hwnd          - Handle to the window on which the background bitmap is drawn
    
Return Value:

    TRUE          - if the buffered background image is created successfully

    FALSE         - otherwise

    g_hdcMem      - The memory DC to receive the buffered bitmap if succeeeds,
                    NULL if fails.

    g_hbmpMemOld  - Save the old memory buffer of g_hdcMem

--*/

{
    BOOL    bRet      = FALSE;
    HDC     hdcMem    = NULL;
    HBITMAP hbmpMemOld= NULL;
    HBITMAP hbmpMem   = NULL; 
    HDC     hdc       = NULL;
    HDC     hdcImgSrc = NULL;
    BITMAP  bm;
    HBITMAP hbmBackground = NULL;
    HBITMAP hBitmapOld = NULL;
    RECT    rcBackground;

    if (!GetClientRect(hwnd, &rcBackground))
    {
        goto cleanup;
    }
    
    hdc = GetDC(hwnd);
    if (!hdc)
    {
        goto cleanup;
    }
    
    hbmpMem = CreateCompatibleBitmap(hdc,
                                     rcBackground.right - rcBackground.left,
                                     rcBackground.bottom - rcBackground.top);
    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem || !hbmpMem)
    {
        goto cleanup;
    }      
    hbmpMemOld = SelectObject(hdcMem, hbmpMem);

    if (g_numBackground > 1)
    {
        hbmBackground = MyLoadImage(hdc, g_idbBackground, g_numBackground);
    }
    else
    {
        hbmBackground = (HBITMAP) LoadImage(g_hInstance,
                                            MAKEINTRESOURCE(g_idbBackground[0]),
                                            IMAGE_BITMAP,
                                            0,
                                            0,
                                            LR_DEFAULTSIZE);
    }
    hdcImgSrc = CreateCompatibleDC(hdc);
    if (!hbmBackground || !hdcImgSrc)
    {
        goto cleanup;
    }
    hBitmapOld = (HBITMAP) SelectObject(hdcImgSrc, hbmBackground);
    
    GetObject(hbmBackground , sizeof(BITMAP), &bm);
    
    bRet = StretchBitmapAndDisplay(hdcMem,
                                   0,
                                   0,
                                   rcBackground.right - rcBackground.left,
                                   rcBackground.bottom - rcBackground.top,
                                   hdcImgSrc,
                                   0,
                                   0,
                                   bm.bmWidth,
                                   bm.bmHeight,
                                   SRCCOPY);

    SelectObject(hdcImgSrc, hBitmapOld);

    if (bRet)
    {
        g_hdcMem = hdcMem;
        g_hbmpMemOld = hbmpMemOld;
        hdcMem = NULL;
        hbmpMemOld = NULL;
        hbmpMem = NULL;
    }

cleanup:
    
    if (hdcImgSrc)
    {
        DeleteDC(hdcImgSrc);
    }

    if (hbmBackground)
    {
        DeleteObject(hbmBackground);
    }

    if (hbmpMemOld != NULL)
    {
        SelectObject(hdcMem, hbmpMemOld);
    }

    if (hbmpMem != NULL)
    {
        DeleteObject(hbmpMem);
    }

    if (hdcMem != NULL)
    {
        DeleteDC(hdcMem);
    }        

    if (hdc)
    {
        ReleaseDC(hwnd, hdc);
    }
    
    return bRet;
}

LRESULT
OnEraseBkgnd(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Handle the WM_ERASEBKGND for the child windows of the main window,
    RedCarpetWndClass

Arguments:

    hwnd   - hwnd to a child window of RedCarpetWndClass

    wParam - same as the wParam pass to WM_ERASEBKGND (see MSDN)

    lParam - same as the lParam pass to WM_ERASEBKGND (see MSDN)

Return Value:

    1 if the background is erased successfully, 0 otherwise. (see MSDN)
    
--*/

{
    LRESULT lRet = 0;
    RECT    rc;
    RECT    rcToParent;

    if (GetClientRect(hwnd, &rc))
    {
        HDC hdc    = (HDC) wParam;
        HDC hdcMem;

        hdcMem = GetBackgroundBuffer();

        GetRectInParent(hwnd, &rc, &rcToParent);

        lRet = (LRESULT) BitBlt(hdc,
                            rc.left,
                            rc.top,
                            rc.right - rc.left,
                            rc.bottom - rc.top,
                            hdcMem,
                            rcToParent.left,
                            rcToParent.top,
                            SRCCOPY);
    }

    return lRet;
}

HDC
GetBillboardBuffer()
{
    return g_hdcBbMem;
}

VOID
DestroyBillboardBuffer()
{
    HBITMAP hbmpMem;

    hbmpMem = SelectObject(g_hdcBbMem, g_hbmpBbMemOld);
    if (hbmpMem)
    {
        DeleteObject(hbmpMem);
    }
    g_hbmpBbMemOld = NULL;

    DeleteDC(g_hdcBbMem);
    g_hdcBbMem = NULL;

}

HBITMAP
MyLoadImage(
    IN HDC    hdc,
    IN UINT*  idbBackground,
    IN int    iNumImage
    )

/*++

Routine Description:

    OR all the specified bitmaps in the resource file and return the result
    image handle. This is particularly useful when we want to use RLE on a
    16 or 24-bit bitmap, because DIB format only permits RLE of 4bpp or 8bpp
    bitmap. 

Arguments:

    hdc            - a device context

    idbBackground  - list of bitmap resource id's

    iNumImage      - number of id in idbBackground

Return Values:

    the result image handle on success; NULL on failure

Note:

    Assume all the bitmaps have the same dimension.

--*/

{
    HBITMAP hbmBackground[] = {NULL, NULL, NULL};
    HBITMAP hbmpImgSrcOld = NULL;
    HDC     hdcImgSrc = NULL;
    HBITMAP hbmpMem = NULL;
    HBITMAP hbmpMemOld = NULL;
    HDC     hdcMem = NULL;
    HBITMAP hbmpRet = NULL;
    DWORD   dwRop;
    int     i;
    BITMAP  bm;

    for (i = 0; i < iNumImage; i++)
    {
        hbmBackground[i] = (HBITMAP) LoadImage(g_hInstance,
                                               MAKEINTRESOURCE(idbBackground[i]),
                                               IMAGE_BITMAP,
                                               0,
                                               0,
                                               LR_CREATEDIBSECTION | LR_DEFAULTSIZE);
        if (hbmBackground[i] == NULL)
        {
            goto cleanup;
        }
    }

    hdcImgSrc = CreateCompatibleDC(hdc);
    if (hdcImgSrc == NULL)
    {
        goto cleanup;
    }

    if (!GetObject(hbmBackground[0], sizeof(BITMAP), &bm))
    {
        goto cleanup;
    }    

    hbmpMem = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight);
    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem || !hbmpMem)
    {
        goto cleanup;
    }      

    i = 0;
    dwRop = SRCCOPY;
    hbmpMemOld = SelectObject(hdcMem, hbmpMem);
    hbmpImgSrcOld = (HBITMAP) SelectObject(hdcImgSrc, hbmBackground[i]);
    while (TRUE)
    {
        if (!BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcImgSrc, 0, 0, dwRop))
        {
            goto cleanup;
        }
        i++;
        if (i >= iNumImage)
        {
            break;
        }
        dwRop = SRCPAINT;
        SelectObject(hdcImgSrc, hbmBackground[i]);
    }

    hbmpRet = hbmpMem;
    hbmpMem = NULL;

cleanup:
    
    if (hbmpImgSrcOld)
    {
        SelectObject(hdcImgSrc, hbmpImgSrcOld);
    }

    if (hbmpMemOld)
    {
        SelectObject(hdcMem, hbmpMemOld);
    }

    if (hdcMem)
    {
        DeleteDC(hdcMem);
    }

    if (hbmpMem)
    {
        DeleteObject(hbmpMem);
    }

    if (hdcImgSrc)
    {
        DeleteDC(hdcImgSrc);
    }
    
    for (i = 0; i < iNumImage; i++)
    {
        if (hbmBackground[i])
        {
            DeleteObject(hbmBackground[i]);
        }
    }

    return hbmpRet;
}

BOOL
BufferBillboard(
    IN  HWND   hwnd,
    IN  HDC    hdc
    )

/*++

Routine Description:

    Create a memory buffer for the billboard.

Arguments:

    hwnd          - Handle to the window on which the Billboard bitmap is drawn

    hdc           - Handle to the screen DC of billboard
    
Return Value:

    TRUE          - if the buffered background image is created successfully

    FALSE         - otherwise

    g_hdcBbMem    - The memory DC to receive the buffered bitmap if succeeeds,
                    NULL if fails.

    g_hbmpBbMem   - Save the old memory buffer of g_hdcBbMem
    
--*/

{
    BOOL    bRet      = FALSE;
    HDC     hdcMem    = NULL;
    HBITMAP hbmpMem   = NULL; 
    RECT    rcBillboard;

    if (!GetClientRect(hwnd, &rcBillboard))
    {
        goto cleanup;
    }
        
    hbmpMem = CreateCompatibleBitmap(hdc,
                                     rcBillboard.right - rcBillboard.left,
                                     rcBillboard.bottom - rcBillboard.top);
    hdcMem = CreateCompatibleDC(hdc);
    if (!hdcMem || !hbmpMem)
    {
        goto cleanup;
    }      
    g_hbmpBbMemOld = SelectObject(hdcMem, hbmpMem);
  
    Animate(hdcMem);
    
    bRet = TRUE;
    g_hdcBbMem = hdcMem;
    hdcMem = NULL;
    hbmpMem = NULL;

cleanup:
    
    if (hbmpMem != NULL)
    {
        SelectObject(hdcMem, g_hbmpBbMemOld);
        DeleteObject(hbmpMem);
        g_hbmpBbMemOld = NULL;
    }

    if (hdcMem != NULL) {
        DeleteDC(hdcMem);
    }        
    
    return bRet;
}


/*****************************************************************************
*
* GetRectInParent(hwndChild, prcClip, pRect)
*
* This function gets the rect of child window relative to the client
* coordinate of the parent
*
******************************************************************************/
void GetRectInParent(HWND hwndChild, LPRECT prcClip, LPRECT pRect)
{
    RECT       rcChild;
    POINT      ptChild;
    HWND       hwnd;
    
    hwnd = GetParent(hwndChild);

    if (hwnd == NULL)
    {
        hwnd = hwndChild;
    }

    if ( prcClip == NULL ) {
        GetClientRect( hwndChild, &rcChild );
    } else {
        rcChild = *prcClip;
    }

    ptChild.x = rcChild.left;
    ptChild.y = rcChild.top;
    ClientToScreen( hwndChild, &ptChild );
    ScreenToClient( hwnd, &ptChild );
    pRect->left = ptChild.x;
    pRect->top = ptChild.y;

    ptChild.x = rcChild.right;
    ptChild.y = rcChild.bottom;
    ClientToScreen( hwndChild, &ptChild );
    ScreenToClient( hwnd, &ptChild );
    pRect->right = ptChild.x;
    pRect->bottom = ptChild.y;

}

BOOL WINAPI InitRealBillBoard(HWND hwndParent)
{
    WNDCLASS  wc;
    RECT    rc1;

    wc.style         = (UINT)CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = BillBoardWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = g_szBillBoardClassName;

    if (!RegisterClass (&wc))
        return FALSE;

    GetWindowRect(hwndParent, &rc1);
    rc1.left = rc1.left + g_cxBillBrd;
    rc1.top = rc1.top + g_cyBillBrd;
    rc1.bottom = rc1.top + g_cyBillBrdHeight;
    g_hwndBB = CreateWindow(
        g_szBillBoardClassName,
        TEXT(""),
        WS_CHILD,
        rc1.left,
        rc1.top,
        rc1.right - rc1.left,
        rc1.bottom - rc1.top,
        hwndParent, 
        NULL,
        g_hInstance,
        NULL);

    if (g_hwndBB == NULL)
    {
        UnregisterClass(g_szBillBoardClassName, g_hInstance);
        return FALSE;
    }
    ShowWindow( g_hwndBB, SW_HIDE );

    return TRUE;

}

BOOL WINAPI InitStatus(HWND hwndParent)
{
    WNDCLASS wc;
    RECT     rc1;

    wc.style         = (UINT)CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = AnimationWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = g_szStatusClassName;

    if (!RegisterClass (&wc))
    {
        return FALSE;
    }
    
    GetWindowRect(hwndParent, &rc1);
    g_hwndStatus = CreateWindowEx(
        WS_EX_TRANSPARENT,
        g_szStatusClassName,
        TEXT(""),
        WS_CHILD, 
        0,
        0,
        0,
        0,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndStatus == NULL)
    {
        UnregisterClass(g_szStatusClassName, g_hInstance);
        return FALSE;
    }
    ShowWindow( g_hwndStatus, SW_HIDE );

    return TRUE;

}

BOOL WINAPI InitProgressBar(HWND hwndParent)
{
    RECT    rc1;

    GetWindowRect(hwndParent, &rc1);
    
    g_hwndTimeEstimate = CreateWindowEx( 
        (g_bBiDi?WS_EX_RTLREADING:0),
        TEXT("STATIC"),
        NULL,
        WS_CHILD | (g_bBiDi?SS_RIGHT:SS_LEFT)| SS_NOPREFIX,
        rc1.left + g_cxEstimate,
        rc1.top + g_cyEstimate,
        g_cxEstimateWidth,
        g_cyEstimateHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndTimeEstimate)
    {
        // Set the font for the text in this window
        SendMessage(g_hwndTimeEstimate, WM_SETFONT, (WPARAM)g_hfont ,0L);

        SetWindowLongPtr(g_hwndTimeEstimate, GWLP_WNDPROC, (LONG_PTR) StatusSubClassWndProc);
        
        ShowWindow(g_hwndTimeEstimate, SW_SHOW);
        UpdateWindow(g_hwndTimeEstimate);
    }

    g_hwndProgressText = CreateWindowEx(
        (g_bBiDi?WS_EX_RTLREADING:0),
        TEXT("STATIC"),
        NULL,
        WS_CHILD | (g_bBiDi?SS_RIGHT:SS_LEFT)| SS_NOPREFIX,
        rc1.left + g_cxProgressText,
        rc1.top + g_cyProgressText,
        g_cxProgressTextWidth,
        g_cyProgressTextHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndProgressText)
    {
        // Save the original position
        GetWindowRect(g_hwndProgressText , &g_rcProgressText);
        
        SendMessage( g_hwndProgressText, WM_SETFONT, (WPARAM)g_hfont ,0L );

        SetWindowLongPtr(g_hwndProgressText, GWLP_WNDPROC, (LONG_PTR) StatusSubClassWndProc);
        
        ShowWindow( g_hwndProgressText, SW_SHOW );
        UpdateWindow( g_hwndProgressText );
    }

    g_hwndProgressGauge = CreateWindow(
        PROGRESS_CLASS,
        NULL,
        WS_CHILD | PBS_SMOOTH ,
        rc1.left + g_cxGauge, 
        rc1.top + g_cyGauge,
        g_cxGaugeWidth,
        g_cyGaugeHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndProgressGauge)
    {
        SetWindowLongPtr(g_hwndProgressGauge, GWLP_WNDPROC, (LONG_PTR) ProgressSubClassWndProc);
        SendMessage( g_hwndProgressGauge, PBM_SETBKCOLOR, 0L, (LPARAM) g_colGaugeBg );
        SendMessage( g_hwndProgressGauge, PBM_SETBARCOLOR, 0L, (LPARAM) g_colGauge );
    }

    g_hwndInfoText  = CreateWindowEx(
        (g_bBiDi?WS_EX_RTLREADING:0),
        TEXT("STATIC"),
        NULL,
        WS_CHILD | (g_bBiDi?SS_RIGHT:SS_LEFT)| SS_NOPREFIX, 
        rc1.left + g_cxInfoText, 
        rc1.top + g_cyInfoText,
        g_cxInfoTextWidth,
        g_cyInfoTextHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL);

    if (g_hwndInfoText)
    {
        // Set the font for the text in this window
        SendMessage(g_hwndInfoText, WM_SETFONT, (WPARAM)g_hfont ,0L);

        SetWindowLongPtr(g_hwndInfoText, GWLP_WNDPROC, (LONG_PTR) StatusSubClassWndProc);
        
        ShowWindow(g_hwndInfoText, SW_SHOW);
        UpdateWindow(g_hwndInfoText);
    }

    g_hbmWinLogo = LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(g_idbLogo),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR );

    if (g_hbmWinLogo)
    {
        BITMAP bm;

        if (GetObject(g_hbmWinLogo, sizeof(BITMAP), &bm))
        {
            g_hwndLogo = CreateWindow(TEXT("STATIC"),
                                      NULL,
                                      WS_VISIBLE | WS_CHILD | SS_OWNERDRAW,
                                      rc1.left + g_cxLogo,
                                      rc1.top + g_cyLogo,
                                      bm.bmWidth,
                                      bm.bmHeight,
                                      hwndParent,
                                      NULL,
                                      g_hInstance,
                                      NULL);

            if (g_hwndLogo)
            {
                SetWindowLongPtr(g_hwndLogo,
                                 GWLP_WNDPROC,
                                 (LONG_PTR) StatusSubClassWndProc);
            }
        }
    }
        
    return TRUE;

}

LRESULT CALLBACK 
StatusSubClassWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)

/*++

Routine Description:

    Subclass the Static Text control used in Billboard and override the
    WM_ERASEBKGND message, so that the bitmap background can be shown
    behind the text.

Arguments:

    hwnd   - hwnd to a static text window, which must be a child window of
            the main billboard window

    msg    - (see MSDN)

    wParam - (see MSDN)

    lParam - (see MSDN)

Return Value:

    (see MSDN)
    
--*/

{
    LRESULT lRet;

    // don't process any message before the CreateWindow of the
    // main window return and g_hwnd is set.
    if (g_hwnd != NULL && msg == WM_ERASEBKGND)
    {      
        lRet = OnEraseBkgnd(hwnd, wParam, lParam);   
    }
    else
    {
        WNDPROC fpStaticWndProc = (WNDPROC) GetClassLongPtr(hwnd, GCLP_WNDPROC);
        lRet = CallWindowProc(fpStaticWndProc, hwnd, msg, wParam, lParam);
    }

    return lRet;
}

LRESULT CALLBACK 
ProgressSubClassWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)

/*++

Routine Description:

    Subclass the Progress bar control used in Billboard and override the
    WM_NCPAINT message, so as to draw a flat progress bar.

Arguments:

    hwnd   - hwnd to a progress bar window

    msg    - (see MSDN)

    wParam - (see MSDN)

    lParam - (see MSDN)

Return Value:

    (see MSDN)
    
--*/

{
    LRESULT lRet;

    
    if (msg == WM_NCPAINT)
    {
        RECT rc;
        
        if (GetWindowRect(hwnd, &rc))
        {
            HDC hdc    = GetWindowDC(hwnd);
            if (hdc != NULL)
            {
                HBRUSH hbrOld;
                HPEN   hpnOld;

                hbrOld = SelectObject(hdc, GetStockObject(NULL_BRUSH));
                hpnOld = SelectObject(hdc, GetStockObject(BLACK_PEN));

                Rectangle(hdc, 0, 0, rc.right - rc.left, rc.bottom - rc.top);

                SelectObject(hdc, hpnOld);
                SelectObject(hdc, hbrOld);

                ReleaseDC(hwnd, hdc);
            }
        }

        lRet = 0;
    }
    else
    {
        WNDPROC fpStaticWndProc = (WNDPROC) GetClassLongPtr(hwnd, GCLP_WNDPROC);
        if (fpStaticWndProc)
        {
            lRet = CallWindowProc(fpStaticWndProc, hwnd, msg, wParam, lParam);
        }
    }

    return lRet;
}


//---------------------------------------------------------------------------
//
// RedCarpetWndProc
//
//---------------------------------------------------------------------------
LRESULT CALLBACK RedCarpetWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static  HBRUSH  hbr = NULL;
        
    switch (msg)
    {
        case WM_CREATE:
        {
            HDC hdc;
            
            hbr = (HBRUSH) GetStockObject( HOLLOW_BRUSH );

            // The order of the following function matters, because some
            // required global variables being initialized before it is
            // called
            
            SetFontCharSet();

            SetFontColor(hwnd);

            GetMyFontsFromFile();
          
            CreateInfoBarFonts();
            
            GetMyImagesFromFile(hwnd);
            
            if (BufferBackground(hwnd) == FALSE)
            {
                return -1;
            }
            
            SetLayoutParams();

            if (InitRealBillBoard(hwnd) == FALSE) {
                return -1;
            }
            
            if (InitInfoBar(hwnd) == FALSE) {
                return -1;
            }
            
            if (InitProgressBar(hwnd) == FALSE) {
                return -1;
            }
            
            if (InitStatus(hwnd) == FALSE) {
                return -1;
            }
            
            return 0;
        }
        
        case WM_DISPLAYCHANGE:
            // NOTE: Only top level window can receive this message
            // i.e. Assertion failure can't be caught if g_hwnd is not
            // a top-level window
            BB_ASSERT(FALSE);
            
            break;

        case WM_PAINT:
        {
            HDC             hdc;
            PAINTSTRUCT     ps;
            HDC             hdcMem;
            
            hdc = BeginPaint(hwnd, &ps);

            if (hdc != NULL)
            {
                hdcMem = GetBackgroundBuffer();

                BitBlt(hdc,
                       ps.rcPaint.left,
                       ps.rcPaint.top,
                       ps.rcPaint.right - ps.rcPaint.left,
                       ps.rcPaint.bottom - ps.rcPaint.top,
                       hdcMem,
                       ps.rcPaint.left,
                       ps.rcPaint.top,
                       SRCCOPY);
                
                EndPaint(hwnd, &ps);
            }
                        
            return(0);
        }

        case WM_CTLCOLORSTATIC:
        {
            HWND    hwndChild;
            HDC     hdcChild;

            hwndChild = (HWND) lParam;
            hdcChild = (HDC) wParam;

            SetTextColor(hdcChild, g_colInfoText);
            SetBkMode( hdcChild, TRANSPARENT );

            if (hwndChild == g_hwndTimeEstimate || hwndChild == g_hwndInfoText) {
                SelectObject(hdcChild, g_hfontBold);
            }
            
            return (LRESULT)(HBRUSH)hbr;

        }

        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT pDi = (LPDRAWITEMSTRUCT) lParam;
            RECT             rc;

            if (GetClientRect(pDi->hwndItem, &rc))
            {
                DrawTransparentBitmap(pDi->hDC,
                                      g_hbmWinLogo, 
                                      rc.left,
                                      rc.top,
                                      g_colLogoTransparency);
            }
            
            return TRUE;
            
        }

        case WM_DESTROY:

            if (GetBackgroundBuffer() != NULL)
            {
                DestroyBackgroundBuffer();
            }

            if (g_hbmWinLogo)
            {
                DeleteObject(g_hbmWinLogo);
                g_hbmWinLogo = NULL;
            }
            
            hbr = NULL;
            break;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

LRESULT CALLBACK BillBoardWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static BOOL     fTimerOn = FALSE;
    static BOOL     fAnimate = FALSE;
    HDC             hdc;

    switch (msg)
    {
        case WM_CREATE:
        {
            hdc = GetDC(NULL);
            g_nLogPixelsY = GetDeviceCaps(hdc, LOGPIXELSY);
            ReleaseDC(NULL, hdc);

            break;
        }

        case WM_PAINT:
        {
            PAINTSTRUCT     ps;
            
            hdc = BeginPaint(hwnd, &ps);

            if (hdc)
            {
                HDC hdcBillboardMem;

                if (fAnimate)
                {
                    if (GetBillboardBuffer())
                    {
                        DestroyBillboardBuffer();
                    }
                    if (InitAnimate(hwnd, hdc))
                    {
                        BufferBillboard(hwnd, hdc);
                    }
                    fAnimate = FALSE;
                }

                hdcBillboardMem = GetBillboardBuffer();
                if (hdcBillboardMem)
                {
                    BitBlt(hdc,
                           ps.rcPaint.left,
                           ps.rcPaint.top,
                           ps.rcPaint.right - ps.rcPaint.left,
                           ps.rcPaint.bottom - ps.rcPaint.top,
                           hdcBillboardMem,
                           ps.rcPaint.left,
                           ps.rcPaint.top,
                           SRCCOPY);
                }
                
            }

            EndPaint(hwnd, &ps);
            return(0);
        }

        case WM_START_TIMER:
        if (!fTimerOn)
        {
            
            if (g_uiLastAnimateIndex == (UINT)-1)
                g_uiAnimateIndex = 0;
            else
                g_uiAnimateIndex = g_uiLastAnimateIndex;
            
            if (SetTimer(hwnd, BILLBRD_TEXT_TIMERID, BB_TEXT_DISPLAY, NULL))
            {
                fTimerOn = TRUE;
                fAnimate = TRUE;
                ShowWindow(hwnd, SW_SHOW);
            }
            
        }
        return fTimerOn;

        case WM_STOP_TIMER:
        if (fTimerOn)
        {
            fTimerOn = FALSE;
            g_uiLastAnimateIndex = g_uiAnimateIndex;
            g_uiAnimateIndex = (UINT)-1;
            KillTimer(hwnd, BILLBRD_TEXT_TIMERID);

            ShowWindow(hwnd, SW_HIDE);

        }
        return fTimerOn == FALSE;

        case WM_TIMER:
        {                         
            AnimateNext();
            fAnimate = TRUE;
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);

        }
        break;

        case WM_DESTROY:
            TerminateAnimate();

            if (fTimerOn)
            {
                fTimerOn = FALSE;
                g_uiLastAnimateIndex = g_uiAnimateIndex;
                g_uiAnimateIndex = (UINT) -1;
                KillTimer(hwnd, BILLBRD_TEXT_TIMERID);
            }

            if (GetBillboardBuffer() != NULL)
            {
                DestroyBillboardBuffer();
            }

            break;

        default:
           return DefWindowProc(hwnd, msg, wParam, lParam);

    }
    return 0;
}


LRESULT CALLBACK
AnimationWndProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Hardcoded animation properties
    //
    static const DWORD BitmapIds[][4] =
    {
        {
            IDB_INTENSITY1_C16BIT,
            IDB_INTENSITY2_C16BIT,
            IDB_INTENSITY3_C16BIT,
            IDB_INTENSITY4_C16BIT
        },
        {
            IDB_INTENSITY1_C4BIT,
            IDB_INTENSITY2_C4BIT,
            IDB_INTENSITY3_C4BIT,
            IDB_INTENSITY4_C4BIT
        }
    };
    static const DWORD SrvBitmapIds[][4] =
    {
        {
            IDB_SRV_INTENSITY1_C16BIT,
            IDB_SRV_INTENSITY2_C16BIT,
            IDB_SRV_INTENSITY3_C16BIT,
            IDB_SRV_INTENSITY4_C16BIT
        },
        {
            IDB_SRV_INTENSITY1_C4BIT,
            IDB_SRV_INTENSITY2_C4BIT,
            IDB_SRV_INTENSITY3_C4BIT,
            IDB_SRV_INTENSITY4_C4BIT,
        }
    };
    static const int   OriginalBitmapSize = 9;
    
    static BOOL      fTimerOn = FALSE;
    static HBITMAP   Bitmaps[] = {NULL, NULL, NULL, NULL};
    static const int NumBitmaps = sizeof(Bitmaps) / sizeof(HBITMAP);
    static int       BoxToFade = 0;
    static int       BoxBitmapIndex[] = {0, 0, 0, 0, 0};
    static const int NumBoxes = sizeof(BoxBitmapIndex) / sizeof(DWORD);
    static int       BitmapSize = 0;
       

    switch (msg)
    {
        case WM_CREATE:
        {
            int  Set;
            int  i;
            int  Ret = 0;
            HDC  hdc;

            hdc = GetDC(hwnd);
            if (hdc != NULL)
            {
                Set = (GetDeviceCaps(hdc, BITSPIXEL) > 8) ? 0 : 1;
                ReleaseDC(hwnd, hdc);
            }
            else
            {
                Set = 1;
            }

            //
            // The bitmaps are designed for 640 x 480. We want to scale them by
            // 80% of the ratio between the current screen with and 640
            //
            BitmapSize = OriginalBitmapSize * GetSystemMetrics(SM_CXSCREEN) * 8 / 6400;

            for (i = 0; i < NumBitmaps; i++)
            {
                if ((dwBBTextType == 0) ||
                    (dwBBTextType == 4))
                {
                    Bitmaps[i] = LoadImage(
                        g_hInstance,
                        MAKEINTRESOURCE(BitmapIds[Set][i]),
                        IMAGE_BITMAP,
                        BitmapSize,
                        BitmapSize,
                        LR_DEFAULTCOLOR);
                }
                else
                {
                    Bitmaps[i] = LoadImage(
                        g_hInstance,
                        MAKEINTRESOURCE(SrvBitmapIds[Set][i]),
                        IMAGE_BITMAP,
                        BitmapSize,
                        BitmapSize,
                        LR_DEFAULTCOLOR);
                }

                if (!Bitmaps[i])
                {
                    Ret = -1;
                    break;
                }
            }

            if (Ret == 0)
            {
                int    Width;
                int    Height;
                
                BoxBitmapIndex[0] = NumBitmaps - 1;             
                for (i = 1; i < NumBoxes; i++)
                {
                    BoxBitmapIndex[i] = 0;
                }
                
                BoxToFade = 0;

                Width = BitmapSize * (NumBoxes * 2 - 1);
                Height = BitmapSize;
                
                MoveWindow(
                    hwnd,
                    GetSystemMetrics(SM_CXSCREEN) - g_cxSteps - Width,
                    g_cyBillBrd + g_cyBillBrdHeight + (g_cyBannerHeight - Height) / 2,
                    Width,
                    Height,
                    FALSE
                    );
                
            }
            else
            {
                int j;
                for (j = 0; j < i; j++)
                {
                    DeleteObject(Bitmaps[j]);
                }
            }
            
            return Ret;
        }

        case WM_ERASEBKGND:
        {
            return OnEraseBkgnd(hwnd, wParam, lParam);
        }

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC         hdc = NULL;
            int         i = 0;
            
            hdc = BeginPaint(hwnd, &ps);

            if (hdc != NULL)
            {
                for (i = 0; i < NumBoxes; i++)
                {
                    DrawBitmap(
                        hdc,
                        Bitmaps[BoxBitmapIndex[i]],
                        i * (BitmapSize * 2),
                        0
                        );
                }
                
            }

            EndPaint(hwnd, &ps);
            
            return(0);
        }

        case WM_START_TIMER:
        if (!fTimerOn)
        {            
            if (SetTimer(hwnd, WHISTLER_PROGRESS_TIMERID, BB_WHISTLER_MOVE, NULL))
            {
                fTimerOn = TRUE;
                ShowWindow(hwnd, SW_SHOW);
            }
        }
        return fTimerOn;

        case WM_STOP_TIMER:
        if (fTimerOn)
        {
            fTimerOn = FALSE;
            KillTimer(hwnd, WHISTLER_PROGRESS_TIMERID);
            ShowWindow(hwnd, SW_HIDE);
        }
        return fTimerOn == FALSE;

        case WM_TIMER:
        {
            if (BoxBitmapIndex[BoxToFade] == 0)
            {                
                BoxToFade = (BoxToFade + 1) % NumBoxes;
            }
            else
            {
                DWORD BoxToGrow = (BoxToFade + 1) % NumBoxes;
                BoxBitmapIndex[BoxToFade]--;
                BoxBitmapIndex[BoxToGrow]++;
            }

            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
        }
        break;

        case WM_DESTROY:
        {
            int i;
            
            if (fTimerOn)
            {
                fTimerOn = FALSE;
                KillTimer(hwnd, WHISTLER_PROGRESS_TIMERID);
            }

            for (i = 0; i < NumBitmaps; i++)
            {
                if (Bitmaps[i])
                {
                    DeleteObject(Bitmaps[i]);
                }
            }

        }
        break;

        default:
           return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

//---------------------
// DLL export functions
//---------------------

BOOL WINAPI TermBillBoard()
{
    BOOL b = TRUE;
    if (g_hwnd)
    {
        if (!DestroyWindow(g_hwnd)) {
            return FALSE;
        }
        g_hwnd = NULL;

        b = UnregisterClass(g_szStepsClassName, g_hInstance);
        b = b && UnregisterClass(g_szBillBoardClassName, g_hInstance);
        b = b && UnregisterClass(g_cszClassName, g_hInstance);
        b = b && UnregisterClass(g_szStatusClassName, g_hInstance);
    }

    return b;
}


BOOL WINAPI InitBillBoard(HWND hwndParent, LPCTSTR lpszPath, DWORD dwInstallType)
{
    WNDCLASS  wc;
    HWND      hwnd;
    TCHAR Buffer[128];

    if (dwInstallType < (sizeof(bb_text) / sizeof(bb_text[0])))
    {
        dwBBTextType = dwInstallType;
    }

    if (LoadString(g_hInstance, IDD_PANELCOUNT, (LPTSTR)Buffer, sizeof(Buffer)/sizeof(TCHAR)))
        g_nPanelCount = MyAtoI((const TCHAR*)Buffer);
    else
        g_nPanelCount = 0;
    
    g_nPanelCount++;

    if (LoadString(g_hInstance, IDD_ANIMATION, (LPTSTR)Buffer, sizeof(Buffer)/sizeof(TCHAR)))
        g_nAnimID = MyAtoI((const TCHAR*)Buffer);
    else
        g_nAnimID = 0;


    if ((g_szPath[0] == '\0') && (lpszPath == NULL)) //can't go on without path
        return FALSE;

    if (hwndParent == NULL)
        hwnd = GetDesktopWindow();
    else
        hwnd = hwndParent;


    if(g_szPath[0] == '\0')
    {
        lstrcpy((LPTSTR)g_szPath, (LPCTSTR)lpszPath);
        AddPath(g_szPath, TEXT("BILLBRD"));
        
        lstrcpy(g_szFileName, g_szPath);
        //append .ini filename to path
        AddPath(g_szFileName, TEXT("winntbb.ini"));
    }

    wc.style         = (UINT)CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = RedCarpetWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_hInstance;
    wc.hIcon         = LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_SETUP));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = g_cszClassName;

    if (!RegisterClass (&wc))
        return FALSE;

    LoadString(g_hInstance,IDS_WINNT_SETUP,(LPTSTR)Buffer,sizeof(Buffer)/sizeof(TCHAR));

    // If we have a parent, be a child window.
    // If not be a main window.
    g_hwnd = CreateWindow(
        g_cszClassName,
        (LPTSTR)Buffer,
        (hwndParent ? WS_CHILD : WS_POPUP) | WS_CLIPCHILDREN,
        0,
        0,
        GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN),
        hwnd,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwnd == NULL)
    {
        UnregisterClass(g_cszClassName, g_hInstance);
        return FALSE;
    }
    ShowWindow( g_hwnd, SW_SHOW );
    UpdateWindow( g_hwnd );

    g_hwndParent = hwnd;
    
    return TRUE;

}

HWND WINAPI GetBBMainHwnd()
{
    return g_hwnd;
}

HWND WINAPI GetBBHwnd()
{
    return g_hwndBB;
}


BOOL WINAPI ShowPanel(int iPanel)
{
    if (g_iCurPanel == iPanel)
        return FALSE;

    if ((iPanel >= 0) && (iPanel < g_nPanelCount))
    {
        if (g_hwndBB == NULL)
            return(FALSE);

        g_iCurPanel = iPanel;
    }
    else
    {
        if (g_hwnd)
        {
            DestroyWindow(g_hwnd);
            g_hwnd = NULL;
            g_iCurPanel = -1;
        }
    }
    return(TRUE);
}

int WINAPI GetPanelCount()
{
    return(g_nPanelCount);
}

void WINAPI BB_Refresh(void)
{
    if(g_hwnd)
    {
        RedrawWindow(
            g_hwnd,
            NULL,
            NULL,
            RDW_ALLCHILDREN | RDW_UPDATENOW | RDW_INVALIDATE);
    }
}

BOOL WINAPI SetProgress(WORD wProgress)
{

    if (wProgress == 0xffff)
    {
        // Kill the last panel...
        return ShowPanel(wProgress);
    }
    else if (wProgress & 0x8000)
    {
        // Display a specific panel
        return ShowPanel(wProgress & 0x7fff);
    }
    else
    {
        // Normal case of a percentage...
        return ShowPanel((g_nPanelCount * wProgress)/100);
    }
    
}

BOOL WINAPI StartBillBoard()
{
    BOOL    retval = FALSE;
    
    if(g_hwnd && g_hwndBB)
    {

        retval = (BOOL) SendMessage(g_hwndBB, WM_START_TIMER, 0, 0L);
        if (g_hwndStatus) {
            SendMessage(g_hwndStatus, WM_START_TIMER, 0, 0L);
        }
    }
    
    return retval;
}

BOOL WINAPI StopBillBoard()
{
    BOOL    retval = FALSE;
    
    if(g_hwnd && g_hwndBB)
    {
        retval = (BOOL) SendMessage(g_hwndBB, WM_STOP_TIMER, 0, 0L);        
        if (g_hwndStatus) {
            SendMessage(g_hwndStatus, WM_STOP_TIMER, 0, 0L);
        }
    }
    
    return retval;
}

BOOL WINAPI ShowProgressGaugeWindow(UINT uiShow)
{
    BOOL bRet;
    
    if (uiShow == SW_HIDE)
    {
        bRet = ShowWindow(g_hwndProgressGauge, uiShow);
        // If we hide the progress bar, reset the progress position
        // OC manager does a PBM_SETRANGE, but does not call PBM_SETPOS
        SendMessage(g_hwndProgressGauge, PBM_SETPOS, 0, 0);
    }
    else
    {
        bRet = ShowWindow(g_hwndProgressGauge, uiShow);
    }
    
    return bRet;
}

BOOL AdjustProgressTextWindow(HWND hwnd, LPCTSTR szText)
{
    BOOL rc;
    HDC hdc;
    RECT rect;
    RECT rect2;
    LONG height1,height2,delta;
    HFONT       hFontOld = NULL;

    // Use the original position to calc the new position
    rect.top = g_rcProgressText.top;
    rect.bottom = g_rcProgressText.bottom;
    rect.left = g_rcProgressText.left;
    rect.right = g_rcProgressText.right;
    rect2.top = g_rcProgressText.top;
    rect2.bottom = g_rcProgressText.bottom;
    rect2.left = g_rcProgressText.left;
    rect2.right = g_rcProgressText.right;

    hdc = GetDC(hwnd);
    if (hdc == NULL)
    {
        rc = FALSE;
    }
    else
    {
        // Select the font into the DC so that DrawText can calc the size correct.
        hFontOld = SelectObject(hdc, g_hfont);

        DrawText(hdc, szText, -1, &rect2, DT_CALCRECT|DT_EXTERNALLEADING|DT_WORDBREAK);
        if(hFontOld)
        {
            SelectObject(hdc, hFontOld);
        }
        ReleaseDC(hwnd, hdc);

        // Calc the new height for the string
        height2 = rect2.bottom - rect2.top;
        // get the old height
        height1 = rect.bottom - rect.top;
        // See how far we have to change the top of the rect.
        delta = (height1 - height2); 
        rect.top += delta;

        // If we would get above the original position, don't
        if (rect.top < g_rcProgressText.top)
        {
            rect.top = g_rcProgressText.top;
        }
        // Since the privous window position could be different from the original, always move 
        // the window.
        MoveWindow(hwnd, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top,TRUE);

        rc = TRUE;
    }

    return rc;
}

BOOL WINAPI SetProgressText(LPCTSTR szText)
{
    TCHAR Empty[] = TEXT("");
    
    if (g_hwndProgressText)
    {
        ShowWindow(g_hwndProgressText, SW_HIDE);
        if (szText)
        {
            AdjustProgressTextWindow(g_hwndProgressText, szText);
            SendMessage(g_hwndProgressText, WM_SETTEXT, 0, (LPARAM) szText);
        }
        else
        {
            SendMessage(g_hwndProgressText, WM_SETTEXT, 0, (LPARAM) Empty);
        }
        ShowWindow(g_hwndProgressText, SW_SHOW);

    }

    return TRUE;
}

LRESULT WINAPI ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam)
{
    LRESULT lresult = 0;

    if (g_hwndProgressGauge) {
        lresult = (LRESULT) SendMessage(g_hwndProgressGauge, msg, wparam, lparam);
    }
    
    return lresult;
}


BOOL WINAPI SetTimeEstimate(LPCTSTR szText)
{
    TCHAR Empty[] = TEXT("");
    
    if (g_hwndTimeEstimate )
    {
        ShowWindow(g_hwndTimeEstimate, SW_HIDE);
        if (szText)
        {
            SendMessage(g_hwndTimeEstimate , WM_SETTEXT, 0, (LPARAM) szText);
        }
        else
        {
            SendMessage(g_hwndTimeEstimate , WM_SETTEXT, 0, (LPARAM) Empty);
        }
        ShowWindow(g_hwndTimeEstimate, SW_SHOW);

    }
 
    return TRUE;
}

BOOL WINAPI SetStep(int iPanel)
{
    BOOL rc = FALSE;
    
    if (g_hwndSteps) 
    {
        rc = (BOOL) SendMessage(g_hwndSteps, WM_SETSTEP, 0, (LPARAM) iPanel);
    }
    
    return rc;
}

BOOL WINAPI SetInfoText(LPCTSTR szText)
{
    TCHAR Empty[] = TEXT("");
    
    if (g_hwndInfoText)
    {
        ShowWindow(g_hwndInfoText, SW_HIDE);
        if (szText)
        {
            SendMessage(g_hwndInfoText, WM_SETTEXT, 0, (LPARAM) szText);
        }
        else
        {
            SendMessage(g_hwndInfoText, WM_SETTEXT, 0, (LPARAM) Empty);
        }
        ShowWindow(g_hwndInfoText, SW_SHOW);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\dibutil.h ===
#ifndef _DIBUTIL_H_
#define _DIBUTIL_H_

/* DIB constants */
#define PALVERSION   0x300

/* DIB macros */
#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))

/* Handle to a DIB */
#define HDIB HANDLE

UINT GetDeviceNumColors(HDC hdc);
HANDLE LoadDIB(LPTSTR lpFileName);
HPALETTE CreateDIBPalette(HDIB hDIB);
HBITMAP DIBToBitmap(HDIB hDIB, HPALETTE hPal);
WORD DestroyDIB(HDIB hDib);
HPALETTE BuildPalette(HDC hdc);

void DrawBitmap (HDC hdc, HBITMAP hBitmap, int xStart, int yStart);
void DrawTransparentBitmap(
     HDC hdc,           // The destination DC.
     HBITMAP hBitmap,   // The bitmap to be drawn.
     int xPos,          // X coordinate.
     int yPos,          // Y coordinate.
     COLORREF col);     // The color for transparent



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\dibutil.c ===
/*---------------------------------------------------------------------------
**
**-------------------------------------------------------------------------*/
#include <pch.h>
#include "dibutil.h"

HANDLE ReadDIBFile(HANDLE hfile);

/*************************************************************************
*
* GetDeviceNumColors()
*
* Purpose:  Determines how many colors the video device supports
*
* Returns:  (int) Number of colors supported
*
* History:   Date      Author       Reason
*            2/28/97   hanumany     Created
*
*
*
*************************************************************************/
UINT GetDeviceNumColors(HDC hdc)
{
    static UINT iNumColors = 0;
    
    if(!iNumColors)
        iNumColors = GetDeviceCaps(hdc, NUMCOLORS);
        
    return iNumColors;    
}


HANDLE LoadDIB(LPTSTR lpFileName)
{
   HANDLE hDIB = NULL;
   HANDLE hFile;

   /*
    * Set the cursor to a hourglass, in case the loading operation
    * takes more than a sec, the user will know what's going on.
    */

    SetCursor(LoadCursor(NULL, IDC_WAIT));
    hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        hDIB = ReadDIBFile(hFile);
        CloseHandle(hFile);
    }
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    return hDIB;
}



/*
 * Dib Header Marker - used in writing DIBs to files
 */
#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

HANDLE ReadDIBFile(HANDLE hFile)
{
    BITMAPFILEHEADER bmfHeader;
    DWORD dwBitsSize;
    DWORD dwRead;
    HANDLE hDIB;

    /*
    * get length of DIB in bytes for use when reading
    */
    
    dwBitsSize = GetFileSize(hFile, NULL);
    
    /*
    * Go read the DIB file header and check if it's valid.
    */
    if ((ReadFile(hFile, (LPVOID)&bmfHeader, sizeof(bmfHeader), &dwRead, NULL) == 0) ||
        (sizeof (bmfHeader) != dwRead))
    {
        return NULL;
    }
    
    if (bmfHeader.bfType != DIB_HEADER_MARKER)
    {
        return NULL;
    }
    
    /*
    * Allocate memory for DIB
    */
    hDIB = (HANDLE) HeapAlloc(GetProcessHeap(), 0, dwBitsSize);
    if (hDIB == NULL)
    {
        return NULL;
    }
    
    /*
    * Go read the bits.
    */
    if ((ReadFile(hFile, (LPVOID)hDIB, dwBitsSize - sizeof(BITMAPFILEHEADER), &dwRead, NULL) == 0) ||
        (dwBitsSize - sizeof(BITMAPFILEHEADER)!= dwRead))
    {
        HeapFree(GetProcessHeap(), 0, hDIB);
        return NULL;
    }
    return hDIB;
}

/*************************************************************************
 *
 * DIBNumColors()
 *
 * Parameter:
 *
 * LPBYTE lpDIB      - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * WORD             - number of colors in the color table
 *
 * Description:
 *
 * This function calculates the number of colors in the DIB's color table
 * by finding the bits per pixel for the DIB (whether Win3.0 or OS/2-style
 * DIB). If bits per pixel is 1: colors=2, if 4: colors=16, if 8: colors=256,
 * if 24, no colors in color table.
 *
 * History:   Date      Author               Reason
 *            6/01/91   Garrett McAuliffe    Created
 *            9/15/91   Patrick Schreiber    Added header and comments
 *
 ************************************************************************/
WORD DIBNumColors(LPBYTE lpDIB)
{
   WORD wBitCount;  // DIB bit count

   /*  If this is a Windows-style DIB, the number of colors in the
    *  color table can be less than the number of bits per pixel
    *  allows for (i.e. lpbi->biClrUsed can be set to some value).
    *  If this is the case, return the appropriate value.
    */

   if (IS_WIN30_DIB(lpDIB))
   {
      DWORD dwClrUsed;

      dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;
      if (dwClrUsed)
      {
         return (WORD)dwClrUsed;
      }
   }

   /*  Calculate the number of colors in the color table based on
    *  the number of bits per pixel for the DIB.
    */
   if (IS_WIN30_DIB(lpDIB))
      wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;
   else
      wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;

   /* return number of colors based on bits per pixel */
   switch (wBitCount)
   {
       case 1:
          return 2;

       case 4:
          return 16;

       case 8:
          return 256;

       default:
          return 0;
   }
}

//-------------------------------------------------------------------------
//      B U I L D  P A L E T T E
//
//  Creates an HPALETTE from a bitmap in a DC
//-------------------------------------------------------------------------
HPALETTE BuildPalette(HDC hdc)
{
    DWORD adw[257];
    int i,n;

    n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]);
    if (n == 0)
        return CreateHalftonePalette(hdc);

    for (i=1; i<=n; i++)
    {
        adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));
    }
    adw[0] = MAKELONG(0x300, n);

    return CreatePalette((LPLOGPALETTE)&adw[0]);
}

/*************************************************************************
 *
 * CreateDIBPalette()
 *
 * Parameter:
 *
 * HDIB hDIB        - specifies the DIB
 *
 * Return Value:
 *
 * HPALETTE         - specifies the palette
 *
 * Description:
 *
 * This function creates a palette from a DIB by allocating memory for the
 * logical palette, reading and storing the colors from the DIB's color table
 * into the logical palette, creating a palette from this logical palette,
 * and then returning the palette's handle. This allows the DIB to be
 * displayed using the best possible colors (important for DIBs with 256 or
 * more colors).
 *
 * History:   Date      Author               Reason
 *            6/01/91   Garrett McAuliffe    Created
 *            9/15/91   Patrick Schreiber    Added header and comments
 *            10/08/97  hanumany             check GlobalLock return code
 *
 ************************************************************************/
HPALETTE CreateDIBPalette(HDIB hDIB)
{
    LPLOGPALETTE lpPal = NULL;      // pointer to a logical palette
    HANDLE hLogPal = NULL;          // handle to a logical palette
    HPALETTE hPal = NULL;           // handle to a palette
    int i = 0, wNumColors = 0;      // loop index, number of colors in color table
    LPBYTE lpbi = NULL;              // pointer to packed-DIB
    LPBITMAPINFO lpbmi = NULL;      // pointer to BITMAPINFO structure (Win3.0)
    LPBITMAPCOREINFO lpbmc = NULL;  // pointer to BITMAPCOREINFO structure (OS/2)
    BOOL bWinStyleDIB;              // flag which signifies whether this is a Win3.0 DIB
    
    /* if handle to DIB is invalid, return NULL */
    
    if (!hDIB)
        return NULL;
    
    /* get pointer to BITMAPINFO (Win 3.0) */
    lpbmi = (LPBITMAPINFO)hDIB;
    
    /* get pointer to BITMAPCOREINFO (OS/2 1.x) */
    lpbmc = (LPBITMAPCOREINFO)hDIB;
    
    /* get the number of colors in the DIB */
    wNumColors = DIBNumColors(hDIB);
    
    /* is this a Win 3.0 DIB? */
    bWinStyleDIB = IS_WIN30_DIB(hDIB);
    if (wNumColors)
    {
        /* allocate memory block for logical palette */
        lpPal = (HANDLE) HeapAlloc(GetProcessHeap(), 0, sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) *  wNumColors);
        
        /* if not enough memory, clean up and return NULL */
        if (!lpPal)
        {
            return NULL;
        }
        
        /* set version and number of palette entries */
        lpPal->palVersion = PALVERSION;
        lpPal->palNumEntries = (WORD)wNumColors;
        
        /*  store RGB triples (if Win 3.0 DIB) or RGB quads (if OS/2 DIB)
        *  into palette
        */
        for (i = 0; i < wNumColors; i++)
        {
            if (bWinStyleDIB)
            {
                lpPal->palPalEntry[i].peRed = lpbmi->bmiColors[i].rgbRed;
                lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
                lpPal->palPalEntry[i].peBlue = lpbmi->bmiColors[i].rgbBlue;
                lpPal->palPalEntry[i].peFlags = 0;
            }
            else
            {
                lpPal->palPalEntry[i].peRed = lpbmc->bmciColors[i].rgbtRed;
                lpPal->palPalEntry[i].peGreen = lpbmc->bmciColors[i].rgbtGreen;
                lpPal->palPalEntry[i].peBlue = lpbmc->bmciColors[i].rgbtBlue;
                lpPal->palPalEntry[i].peFlags = 0;
            }
        }
        
        /* create the palette and get handle to it */
        hPal = CreatePalette(lpPal);
    }
    
    /* clean up */
    HeapFree(GetProcessHeap(), 0, lpPal);
    
    /* return handle to DIB's palette */
    return hPal;
}


WORD PaletteSize(LPBYTE lpDIB)
{
   /* calculate the size required by the palette */
   if (IS_WIN30_DIB (lpDIB))
      return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));
   else
      return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));
}
/*************************************************************************
 *
 * FindDIBBits()
 *
 * Parameter:
 *
 * LPBYTE lpDIB      - pointer to packed-DIB memory block
 *
 * Return Value:
 *
 * LPBYTE            - pointer to the DIB bits
 *
 * Description:
 *
 * This function calculates the address of the DIB's bits and returns a
 * pointer to the DIB bits.
 *
 * History:   Date      Author              Reason
 *            6/01/91   Garrett McAuliffe   Created
 *            9/15/91   Patrick Schreiber   Added header and comments
 *
 ************************************************************************/
LPBYTE FindDIBBits(LPBYTE lpDIB)
{
   return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB));
}
/*************************************************************************
 *
 * DIBToBitmap()
 *
 * Parameters:
 *
 * HDIB hDIB        - specifies the DIB to convert
 *
 * HPALETTE hPal    - specifies the palette to use with the bitmap
 *
 * Return Value:
 *
 * HBITMAP          - identifies the device-dependent bitmap
 *
 * Description:
 *
 * This function creates a bitmap from a DIB using the specified palette.
 * If no palette is specified, default is used.
 *
 * NOTE:
 *
 * The bitmap returned from this funciton is always a bitmap compatible
 * with the screen (e.g. same bits/pixel and color planes) rather than
 * a bitmap with the same attributes as the DIB.  This behavior is by
 * design, and occurs because this function calls CreateDIBitmap to
 * do its work, and CreateDIBitmap always creates a bitmap compatible
 * with the hDC parameter passed in (because it in turn calls
 * CreateCompatibleBitmap).
 *
 * So for instance, if your DIB is a monochrome DIB and you call this
 * function, you will not get back a monochrome HBITMAP -- you will
 * get an HBITMAP compatible with the screen DC, but with only 2
 * colors used in the bitmap.
 *
 * If your application requires a monochrome HBITMAP returned for a
 * monochrome DIB, use the function SetDIBits().
 *
 * Also, the DIBpassed in to the function is not destroyed on exit. This
 * must be done later, once it is no longer needed.
 *
 * History:   Date      Author               Reason
 *            6/01/91   Garrett McAuliffe    Created
 *            9/15/91   Patrick Schreiber    Added header and comments
 *            3/27/92   Mark Bader           Added comments about resulting
 *                                           bitmap format
 *            10/08/97  hanumany             check GlobalLock return code.
 *
 ************************************************************************/
HBITMAP DIBToBitmap(HDIB hDIB, HPALETTE hPal)
{
   LPBYTE lpDIBHdr, lpDIBBits;  // pointer to DIB header, pointer to DIB bits
   HBITMAP hBitmap;            // handle to device-dependent bitmap
   HDC hDC;                    // handle to DC
   HPALETTE hOldPal = NULL;    // handle to a palette

   /* if invalid handle, return NULL */

   if (!hDIB)
      return NULL;

   /* get a pointer to the DIB bits */
   lpDIBBits = FindDIBBits(hDIB);

   /* get a DC */
   hDC = GetDC(NULL);
   if (!hDC)
   {
      return NULL;
   }

   /* select and realize palette */
   if (hPal)
      hOldPal = SelectPalette(hDC, hPal, FALSE);
   RealizePalette(hDC);

   /* create bitmap from DIB info. and bits */
   hBitmap = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)hDIB, CBM_INIT,
                (LPCVOID)lpDIBBits, (LPBITMAPINFO)hDIB, DIB_RGB_COLORS);

   /* restore previous palette */
   if (hOldPal)
      SelectPalette(hDC, hOldPal, FALSE);

   /* clean up */
   ReleaseDC(NULL, hDC);

   /* return handle to the bitmap */
   return hBitmap;
}

WORD DestroyDIB(HDIB hDib)
{
    HeapFree(GetProcessHeap(), 0, hDib);
    return 0;
}

/******************************************************************
 *
 * DrawBitmap()
 *
 * This function paints the given bitmap at the given coordinates.
 *
 ******************************************************************/
void  DrawBitmap (HDC hdc, HBITMAP hBitmap, int xStart, int yStart)
{
    BITMAP  bm;
    HDC     hdcMem;
    POINT   ptSize, ptOrg;
    HBITMAP hBitmapOld = NULL;

    if (hBitmap == NULL) {
        return;
    }

    hdcMem = CreateCompatibleDC (hdc);
    if (hdcMem == NULL)
    {
        return;
    }
    SetBkMode(hdcMem, TRANSPARENT);
    hBitmapOld = SelectObject(hdcMem, hBitmap);
    SetMapMode(hdcMem, GetMapMode(hdc));


    GetObject(hBitmap, sizeof(BITMAP), (LPVOID)&bm);
    ptSize.x = bm.bmWidth;
    ptSize.y = bm.bmHeight;
    DPtoLP(hdc, &ptSize, 1);

    ptOrg.x = 0;
    ptOrg.y = 0;
    DPtoLP(hdcMem, &ptOrg, 1);

    BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, ptOrg.x, ptOrg.y, SRCCOPY);

    SelectObject(hdcMem, hBitmapOld);
    DeleteDC(hdcMem);
}

/******************************************************************
 *
 * DrawTransparentBitmap()
 *
 * This function paints the given bitmap at the given coordinates.
 * and allow for one transparent color
 *
 ******************************************************************/
void DrawTransparentBitmap(
    HDC hdc,
    HBITMAP hBitmap,
    int xStart,
    int yStart,
    COLORREF cTransparentColor )
{
    BITMAP     bm;
    COLORREF   cColor;
    HBITMAP    bmAndBack, bmAndObject, bmAndMem, bmSave;
    HBITMAP    bmBackOld, bmObjectOld, bmMemOld, bmSaveOld;
    HDC        hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
    POINT      ptSize;
    COLORREF   cTransparentColor2;
    
    hdcTemp = CreateCompatibleDC(hdc);
    SelectObject(hdcTemp, hBitmap);

    cTransparentColor2 = GetPixel(hdcTemp, 0, 0);
    if (cTransparentColor2 == CLR_INVALID)
    {
        cTransparentColor2 = cTransparentColor;
    }
    
    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
    ptSize.x = bm.bmWidth;
    ptSize.y = bm.bmHeight;
    DPtoLP(hdcTemp, &ptSize, 1);
    
    hdcBack   = CreateCompatibleDC(hdc);
    hdcObject = CreateCompatibleDC(hdc);
    hdcMem    = CreateCompatibleDC(hdc);
    hdcSave   = CreateCompatibleDC(hdc);
    
    bmAndBack   = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);
    
    bmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);
    
    bmAndMem    = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
    bmSave      = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
    
    bmBackOld   = SelectObject(hdcBack, bmAndBack);
    bmObjectOld = SelectObject(hdcObject, bmAndObject);
    bmMemOld    = SelectObject(hdcMem, bmAndMem);
    bmSaveOld   = SelectObject(hdcSave, bmSave);
    
    SetMapMode(hdcTemp, GetMapMode(hdc));
    
    BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);
    
    cColor = SetBkColor(hdcTemp, cTransparentColor2);
    
    BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0,
        SRCCOPY);
    
    SetBkColor(hdcTemp, cColor);
    
    BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0,
        NOTSRCCOPY);
    
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart,
        SRCCOPY);
    
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);
    
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);
    
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT);
    
    BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0,
        SRCCOPY);
    
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);
    
    DeleteObject(SelectObject(hdcBack, bmBackOld));
    DeleteObject(SelectObject(hdcObject, bmObjectOld));
    DeleteObject(SelectObject(hdcMem, bmMemOld));
    DeleteObject(SelectObject(hdcSave, bmSaveOld));
    
    DeleteDC(hdcMem);
    DeleteDC(hdcBack);
    DeleteDC(hdcObject);
    DeleteDC(hdcSave);
    DeleteDC(hdcTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\billbrd.h ===
#ifndef _BILLBRD_H_
#define _BILLBRD_H_
#include "resource.h"

#ifdef UNICODE
#define MyAtoI(x) _wtoi(x)
#else
#define MyAtoI(x) atoi(x)
#endif

#ifdef DBG

    void _BB_Assert(LPCTSTR, unsigned);

    #define BB_ASSERT(f);       \
       {if (f)                  \
            {}                  \
        else                    \
            _BB_Assert(TEXT(__FILE__), __LINE__);}
#else

    #define BB_ASSERT(f);

#endif

#define RGB_BLACK           RGB(   0,   0,   0 )
#define RGB_RED             RGB( 255,   0,   0 )
#define RGB_GREEN           RGB(   0, 255,   0 )
#define RGB_BLUE            RGB(   0,   0, 255 )
#define RGB_WHITE           RGB( 255, 255, 255 )
#define RGB_GRAY            RGB( 128, 128, 128 )
#define RGB_YELLOW          RGB( 255, 255,   0 )
#define RGB_ORANGE          RGB( 255,  64,   0 )
#define RGB_DARKBLUE        RGB(   0,   0, 128 )

//----------
// billbrd.c
//----------
#define WM_START_TIMER      (WM_USER + 6)
#define WM_STOP_TIMER       (WM_USER + 7)
#define WM_SETSTEP          (WM_USER + 8)

#define MAX_STRING          1024

#define UI_WASH_PATTERN_FILL_COLOR_16BIT    RGB(90,121,198) 
#define UI_WASH_PATTERN_FILL_COLOR_4BIT     RGB_WHITE

extern HINSTANCE g_hInstance;
extern TCHAR     g_szFileName[MAX_PATH];
extern BYTE      g_bCharSet;
extern UINT      g_cxBillBrdHMargin;
extern UINT      g_cyBillBrdVMargin;
extern UINT      g_cxBillBrdWidth;
extern UINT      g_cyBillBrdHeight;
extern UINT      g_cxBillBrdTitleWidth;
extern UINT      g_cyBillBrdTitleTop;
extern UINT      g_cxBillBrdBodyWidth;

HWND WINAPI GetBBMainHwnd();
HWND WINAPI GetBBHwnd();
void WINAPI BB_Refresh(void);

HDC GetBackgroundBuffer();
void GetRectInParent(HWND hwndChild, LPRECT prcChild, LPRECT prcParent);

//-------
// info.c
//-------
#define UI_INFOBAR_NUM_STEPS           5
#define UI_INFOBAR_FONT_SIZE_640       8
#define UI_INFOBAR_FONT_SIZE_800      11
#define UI_INFOBAR_FONT_SIZE_1024     14
#define CY_DIST_LINES                 16

#define UI_STEPSTITLE_COLOR_C16BIT             RGB_WHITE
#define UI_STEPSTEXT_COLOR_C16BIT              RGB_WHITE
#define UI_STEPSTEXT_MARK_COLOR_C16BIT         RGB_WHITE
#define UI_STEPSTEXT_CURRENT_COLOR_C16BIT      RGB(255, 128, 0)
#define UI_INFOTEXT_COLOR_C16BIT               UI_STEPSTEXT_COLOR_C16BIT
#define UI_GAUGE_BACKGROUND_COLOR_C16BIT       RGB_WHITE
#define UI_GAUGE_COLOR_C16BIT                  RGB(7, 158, 5)
#define UI_STATUS_TRANSPARENT_COLOR_C16BIT     RGB(0, 50, 150)
#define UI_LOGO_TRANSPARENT_COLOR_C16BIT       RGB(0, 53, 154)
#define UI_BULLET_TRANPARENT_COLOR_C16BIT      RGB(78, 111, 214)

#define UI_STEPSTITLE_COLOR_C4BIT              RGB_WHITE
#define UI_STEPSTEXT_COLOR_C4BIT               RGB_WHITE
#define UI_STEPSTEXT_MARK_COLOR_C4BIT          RGB_WHITE
#define UI_STEPSTEXT_CURRENT_COLOR_C4BIT       RGB_ORANGE
#define UI_INFOTEXT_COLOR_C4BIT                UI_STEPSTEXT_COLOR_C4BIT
#define UI_GAUGE_BACKGROUND_COLOR_C4BIT        UI_STEPSTEXT_COLOR_C4BIT
#define UI_GAUGE_COLOR_C4BIT                   RGB(0, 128, 0)
#define UI_STATUS_TRANSPARENT_COLOR_C4BIT      RGB_DARKBLUE
#define UI_LOGO_TRANSPARENT_COLOR_C4BIT        RGB(255, 0, 255)
#define UI_BULLET_TRANPARENT_COLOR_C4BIT       RGB_DARKBLUE

extern UINT         g_cxSteps;
extern UINT         g_cySteps;
extern UINT         g_cxStepsWidth;
extern UINT         g_cyStepsHeight;
extern const TCHAR  g_szStepsClassName[];
extern COLORREF     g_colStepsTxt;
extern COLORREF     g_colStepsMarkTxt;
extern COLORREF     g_colStepsCurrentTxt;
extern UINT         g_idbSelectedBullet;
extern UINT         g_idbReleasedBullet;
extern UINT         g_idbCurrentBullet;
extern COLORREF     g_colInfoText;
extern HWND         g_hwndSteps;
extern HFONT        g_hfont;
extern HFONT        g_hfontBold;
extern COLORREF     g_colBulletTrans;

BOOL WINAPI InitInfoBar(HWND hwndParent);

int GetInfoBarFontHeight();

BOOL CreateInfoBarFonts();

BOOL GetStepsHeight(
    IN  UINT  cxScreen,
    IN  UINT  cyScreen,
    IN  RECT  rcSteps,
    OUT UINT* pcyBottom);

//----------
// animate.c
//----------
typedef struct _BB_TEXT { 
    UINT    uiTitle;
    UINT    uiText;
    UINT    uiBitmap;
} BB_TEXT;

#define COLOR_TEXT_C16BIT          RGB_WHITE
#define COLOR_TITLE_C16BIT         RGB_WHITE
#define COLOR_SHADOW_C16BIT        RGB( 0, 37, 109)
#define COLOR_TITLE_C4BIT          RGB_WHITE
#define COLOR_TEXT_C4BIT           RGB_WHITE
#define COLOR_SHADOW_C4BIT         RGB_BLACK

extern DWORD    dwBBTextType;
extern BB_TEXT* bb_text[];
extern COLORREF g_colTitle;
extern COLORREF g_colTitleShadow;
extern TCHAR    g_szTFont[32];
extern BOOL     g_bTitleShadow;
extern int      g_nTFontHeight;
extern int      g_nTFontWidth;
extern int      g_nTFontWeight;
extern COLORREF g_colText;
extern COLORREF g_colTextShadow;
extern BOOL     g_bTextShadow;
extern TCHAR    g_szBFont[32];
extern int      g_nBFontHeight;
extern int      g_nBFontWidth;
extern int      g_nBFontWeight;
extern int      g_nLogPixelsY;
extern int      g_nAnimID;
extern BOOL     g_bBiDi;
extern int      g_nBLineSpace;

//----------
// addpath.c
//----------
VOID AddPath(LPTSTR szPath, LPCTSTR szName );
BOOL GetParentDir( LPTSTR szFolder );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\dllinit.c ===
#include <pch.h>
#include "billbrd.h"    


//DLLInit(
DllMain(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
#ifdef UNICODE
    INITCOMMONCONTROLSEX ControlInit;
#endif


    ReservedAndUnused;
    

    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        g_hInstance = (HINSTANCE)DLLHandle;
        


#ifdef UNICODE
        
        // Need to initialize common controls in the comctl32 v6 case
        // in GUI mode setup. 

        ControlInit.dwSize = sizeof(INITCOMMONCONTROLSEX);
        ControlInit.dwICC = ICC_PROGRESS_CLASS;
        InitCommonControlsEx( &ControlInit );
#endif



        break;

    case DLL_PROCESS_DETACH:
        break ;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winntbb.rc
//
#define IDS_INFOFONTSIZE_1024           1
#define IDS_INFOFONTSIZE_800            2
#define IDS_INFOFONTSIZE_640            3
#define IDS_INFOFONTNAME                4
#define IDS_TITLEFONTNAME               5
#define IDS_TITLEFONTSIZE_1024          6
#define IDS_TITLEFONTWIDTH_1024         7
#define IDS_TEXTFONTSIZE_1024           8
#define IDS_TEXTFONTWIDTH_1024          9
#define IDS_TITLEFONTSIZE_800           10
#define IDS_TITLEFONTWIDTH_800          11
#define IDS_TEXTFONTSIZE_800            12
#define IDS_TEXTFONTWIDTH_800           13
#define IDS_TITLEFONTSIZE_640           14
#define IDS_TITLEFONTWIDTH_640          15
#define IDS_TEXTFONTSIZE_640            16
#define IDS_TEXTFONTWIDTH_640           17
#define IDD_TITLEFONTWEIGHT             18
#define IDS_TEXTFONTNAME                19
#define IDD_TEXTFONTWEIGHT              20
#define IDD_PANELCOUNT                  21
#define IDD_ANIMATION                   22
#define IDS_STEP1                       23
#define IDS_STEP2                       24
#define IDS_STEP3                       25
#define IDS_WINNT_SETUP                 26
#define IDS_TITLE1                      27
#define IDS_TEXT1                       28
#define IDS_TITLE2                      29
#define IDS_TEXT2                       30
#define IDS_TITLE3                      31
#define IDS_TEXT3                       32
#define IDS_TITLE4                      33
#define IDS_TEXT4                       34
#define IDS_TITLE5                      35
#define IDS_TEXT5                       36
#define IDS_TITLE6                      37
#define IDS_TEXT6                       38
#define IDS_TITLE7                      39
#define IDS_TEXT7                       40
#define IDS_TITLE8                      41
#define IDS_TEXT8                       42
#define IDS_TITLE9                      43
#define IDS_TEXT9                       44
#define IDS_TITLE10                     45
#define IDS_TEXT10                      46
#define IDS_TITLE11                     47
#define IDS_TEXT11                      48
#define IDS_TITLE12                     49
#define IDS_TEXT12                      50
#define IDS_TITLE13                     51
#define IDS_TEXT13                      52
#define IDS_TITLE14                     53
#define IDS_TEXT14                      54
#define IDS_TITLE15                     55
#define IDS_TEXT15                      56
#define IDS_TITLE16                     57
#define IDS_TEXT16                      58
#define IDS_TITLE17                     59
#define IDS_TEXT17                      60
#define IDS_TITLE18                     61
#define IDS_TEXT18                      62
#define IDS_STEP4                       63
#define IDS_STEP5                       64
#define IDS_TEXTFONT_LINESPACING        65

#define IDI_SETUP                       81

#define IDB_LOGO640_C16BIT              100
#define IDB_LOGO800_C16BIT              101  
#define IDB_LOGO1024_C16BIT             102  
#define IDB_BACKGROUND_C16BIT           103
#define IDB_SELECTEDBULLET_C16BIT       104
#define IDB_RELEASEDBULLET_C16BIT       105
#define IDB_CURRENTBULLET_C16BIT        109

#define IDB_SRV_LOGO640_C16BIT          120
#define IDB_SRV_LOGO800_C16BIT          121  
#define IDB_SRV_LOGO1024_C16BIT         122  
#define IDB_SRV_BACKGROUND_C16BIT       123
#define IDB_SRV_SELECTEDBULLET_C16BIT   124
#define IDB_SRV_RELEASEDBULLET_C16BIT   125
#define IDB_SRV_CURRENTBULLET_C16BIT    126


#define IDB_LOGO640_C4BIT               150
#define IDB_LOGO800_C4BIT               151
#define IDB_LOGO1024_C4BIT              152
#define IDB_BACKGROUND_C4BIT            153
#define IDB_SELECTEDBULLET_C4BIT        154
#define IDB_RELEASEDBULLET_C4BIT        155
#define IDB_CURRENTBULLET_C4BIT         156

#define IDB_SRV_LOGO640_C4BIT           160
#define IDB_SRV_LOGO800_C4BIT           161
#define IDB_SRV_LOGO1024_C4BIT          162
#define IDB_SRV_BACKGROUND_C4BIT            163
#define IDB_SRV_SELECTEDBULLET_C4BIT        164
#define IDB_SRV_RELEASEDBULLET_C4BIT        165
#define IDB_SRV_CURRENTBULLET_C4BIT         166

#define IDB_COLL1                       171
#define IDB_COLL2                       172
#define IDB_COLL3                       173
#define IDB_COLL4                       174
#define IDB_COLL5                       175
#define IDB_COLL6                       176
#define IDB_COLL7                       177
#define IDB_COLL8                       178
#define IDB_COLL9                       179
#define IDB_COLL10                      180

#define IDB_BULLET_1                    181

#define IDB_INTENSITY1_C16BIT           185
#define IDB_INTENSITY2_C16BIT           186
#define IDB_INTENSITY3_C16BIT           187
#define IDB_INTENSITY4_C16BIT           188
#define IDB_INTENSITY1_C4BIT            189
#define IDB_INTENSITY2_C4BIT            190
#define IDB_INTENSITY3_C4BIT            191
#define IDB_INTENSITY4_C4BIT            192

#define IDB_SRV_INTENSITY1_C16BIT       500
#define IDB_SRV_INTENSITY2_C16BIT       501
#define IDB_SRV_INTENSITY3_C16BIT       502
#define IDB_SRV_INTENSITY4_C16BIT       503
#define IDB_SRV_INTENSITY1_C4BIT        510
#define IDB_SRV_INTENSITY2_C4BIT        511
#define IDB_SRV_INTENSITY3_C4BIT        512
#define IDB_SRV_INTENSITY4_C4BIT        513

#define IDS_TITLE1_S                    200
#define IDS_TEXT1_S                     201
#define IDS_TITLE2_S                    202
#define IDS_TEXT2_S                     203
#define IDS_TITLE3_S                    204
#define IDS_TEXT3_S                     205
#define IDS_TITLE4_S                    206
#define IDS_TEXT4_S                     207
#define IDS_TITLE5_S                    208
#define IDS_TEXT5_S                     209
#define IDS_TITLE6_S                    210
#define IDS_TEXT6_S                     211
#define IDS_TITLE7_S                    212
#define IDS_TEXT7_S                     213
#define IDS_TITLE8_S                    214
#define IDS_TEXT8_S                     215
#define IDS_TITLE9_S                    216
#define IDS_TEXT9_S                     217
#define IDS_TITLE10_S                   218
#define IDS_TEXT10_S                    219

#define IDS_TITLE1_PER                  300
#define IDS_TEXT1_PER                   301
#define IDS_TITLE2_PER                  302
#define IDS_TEXT2_PER                   303
#define IDS_TITLE3_PER                  304
#define IDS_TEXT3_PER                   305
#define IDS_TITLE4_PER                  306
#define IDS_TEXT4_PER                   307
#define IDS_TITLE5_PER                  308
#define IDS_TEXT5_PER                   309
#define IDS_TITLE6_PER                  310
#define IDS_TEXT6_PER                   311
#define IDS_TITLE7_PER                  312
#define IDS_TEXT7_PER                   313
#define IDS_TITLE8_PER                  314
#define IDS_TEXT8_PER                   315
#define IDS_TITLE9_PER                  316
#define IDS_TEXT9_PER                   317
#define IDS_TITLE10_PER                 318
#define IDS_TEXT10_PER                  319
#define IDS_TITLE11_PER                 320
#define IDS_TEXT11_PER                  321
#define IDS_TITLE12_PER                 322
#define IDS_TEXT12_PER                  323
#define IDS_TITLE13_PER                 324
#define IDS_TEXT13_PER                  325
#define IDS_TITLE14_PER                 326
#define IDS_TEXT14_PER                  327
#define IDS_TITLE15_PER                 328
#define IDS_TEXT15_PER                  329
#define IDS_TITLE16_PER                 330
#define IDS_TEXT16_PER                  331
#define IDS_TITLE17_PER                 332
#define IDS_TEXT17_PER                  333
#define IDS_TITLE18_PER                 334
#define IDS_TEXT18_PER                  335
#define IDS_TITLE19_PER                 336
#define IDS_TEXT19_PER                  337
#define IDS_TITLE20_PER                 338
#define IDS_TEXT20_PER                  339
#define IDS_TITLE21_PER                 340
#define IDS_TEXT21_PER                  341
#define IDS_TITLE22_PER                 342
#define IDS_TEXT22_PER                  343

#define IDS_TITLE1_64PRO                400
#define IDS_TEXT1_64PRO                 401
#define IDS_TITLE2_64PRO                402
#define IDS_TEXT2_64PRO                 403
#define IDS_TITLE3_64PRO                404
#define IDS_TEXT3_64PRO                 405
#define IDS_TITLE4_64PRO                406
#define IDS_TEXT4_64PRO                 407
#define IDS_TITLE5_64PRO                408
#define IDS_TEXT5_64PRO                 409
#define IDS_TITLE6_64PRO                410
#define IDS_TEXT6_64PRO                 411
#define IDS_TITLE7_64PRO                412
#define IDS_TEXT7_64PRO                 413
#define IDS_TITLE8_64PRO                414
#define IDS_TEXT8_64PRO                 415
#define IDS_TITLE9_64PRO                416
#define IDS_TEXT9_64PRO                 417
#define IDS_TITLE10_64PRO               418
#define IDS_TEXT10_64PRO                419
#define IDS_TITLE11_64PRO               420
#define IDS_TEXT11_64PRO                421
#define IDS_TITLE12_64PRO               422
#define IDS_TEXT12_64PRO                423
#define IDS_TITLE13_64PRO               424
#define IDS_TEXT13_64PRO                425
#define IDS_TITLE14_64PRO               426
#define IDS_TEXT14_64PRO                427
#define IDS_TITLE15_64PRO               428
#define IDS_TEXT15_64PRO                429

#define IDD_BIDI                        1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\winntbb.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#define STRICT
#include <windows.h>

//---------------------------------------------------------------------------
// Global to the app.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\unicode\pch.h ===
#include <windows.h>
#include <stdlib.h>
#include <commctrl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\info.c ===
/*---------------------------------------------------------------------------
**
**-------------------------------------------------------------------------*/
#include <pch.h>
#include "dibutil.h"
#include "billbrd.h"
#include "animate.h"

const UINT  uiIDSteps[] = {
    IDS_STEP1,
    IDS_STEP2,
    IDS_STEP3,
    IDS_STEP4,
    IDS_STEP5 };
int     g_iCurrentStep  = 1;
HFONT   g_hfont         = NULL;
HFONT   g_hfontBold     = NULL;

TCHAR   g_szBuffer[MAX_STRING];

int GetStepText(int nStep, LPTSTR lpStr);

int PaintStepsText(HDC hdc, RECT rc);

BOOL GetStepsHeight(
    IN  UINT  cxScreen,
    IN  UINT  cyScreen,
    IN  RECT  rcSteps,
    OUT UINT* pcyBottom)
{
    HDC     hdcMem = NULL;
    HDC     hdcScreen = NULL;
    HBITMAP hbmpMem = NULL;
    BOOL    bRet = FALSE;

    hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        hdcMem = CreateCompatibleDC(hdcScreen);
        hbmpMem = CreateCompatibleBitmap(hdcScreen,
                                         cxScreen,
                                         cyScreen);

        if (hdcMem && hbmpMem)
        {           
            SelectObject(hdcMem, hbmpMem);
            *pcyBottom = (UINT) PaintStepsText(hdcMem, rcSteps);
            bRet = TRUE;
        }

        if (hbmpMem)
        {
            DeleteObject(hbmpMem);
        }

        if (hdcMem)
        {
            DeleteDC(hdcMem);
        }

        ReleaseDC(NULL, hdcScreen);
    }

    return bRet;

}
/*****************************************************************************
* GetInfoBarFontHeight
*
* Export this function to facilities size estimation of g_hwndSteps.
*
******************************************************************************/
int GetInfoBarFontHeight()
{
    int iInfobarRegularFontSize = 0;
    int idsInfobarFontSize;
    int iScreenSize;
    TCHAR szBuf[25];

    BB_ASSERT(g_hInstance != NULL);

    iScreenSize = GetSystemMetrics(SM_CXSCREEN);
    if(iScreenSize >= 1024)
    {
        idsInfobarFontSize = IDS_INFOFONTSIZE_1024;
        iInfobarRegularFontSize = UI_INFOBAR_FONT_SIZE_1024;
    }
    else if(iScreenSize == 800) 
    {
        idsInfobarFontSize = IDS_INFOFONTSIZE_800;
        iInfobarRegularFontSize = UI_INFOBAR_FONT_SIZE_800;
    }
    else
    {
        idsInfobarFontSize = IDS_INFOFONTSIZE_640;
        iInfobarRegularFontSize = UI_INFOBAR_FONT_SIZE_640;
    }

    if (LoadString(g_hInstance,
                    idsInfobarFontSize,
                    szBuf,
                    sizeof(szBuf)/sizeof(TCHAR)) != 0)
    {
        iInfobarRegularFontSize = MyAtoI((const TCHAR *)szBuf);
    }

    return -MulDiv(iInfobarRegularFontSize, 96, 72);

}

/******************************************************************
*
* CreateInfoBarFonts
*
* This function creates two fonts for the infobar based on the 
* screen resolution. The fonts are the same size, one is bold
* and the other is normal. These fonts are used throughout infobar.
*
*******************************************************************/
BOOL CreateInfoBarFonts()
{
    LOGFONT lf = {0};
    TCHAR szSetupFontName[MAX_PATH];
    int ifHeight = 0;
    
    ifHeight = GetInfoBarFontHeight();

    if (!(LoadString(g_hInstance, IDS_INFOFONTNAME, (LPTSTR)szSetupFontName, MAX_PATH)))
    {
        lstrcpy(szSetupFontName, TEXT("system"));
    }

    //Create a font that will be used in the Infobar ui
    /*keep font size constant, even with large fonts*/
    lf.lfHeight = ifHeight;
    lstrcpy(lf.lfFaceName, (LPTSTR)szSetupFontName);
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfWeight = FW_NORMAL;
    lf.lfQuality = PROOF_QUALITY;
#ifdef WINDOWS_THAI
    lf.lfCharSet = ANSI_CHARSET; //Thai Textout problem for Infobar font
#else
    lf.lfCharSet = g_bCharSet;
#endif
    g_hfont = CreateFontIndirect(&lf);

    //Create a Bold font 
    /*keep font size constant, even with large fonts*/
    lf.lfHeight = ifHeight;
    lstrcpy(lf.lfFaceName, (LPTSTR)szSetupFontName);
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfWeight = FW_SEMIBOLD;
    lf.lfQuality = PROOF_QUALITY;
#ifdef WINDOWS_THAI
    lf.lfCharSet = ANSI_CHARSET; //Thai Textout problem for Infobar font
#else
    lf.lfCharSet = g_bCharSet;
#endif
    g_hfontBold = CreateFontIndirect(&lf);

        
    if(g_hfont && g_hfontBold)
        return TRUE;
    else 
        return FALSE;
}

/******************************************************************
*
* DeleteInfoBarFonts()
*
* This function deletes the two global fonts for the infobar.
*
*******************************************************************/
void DeleteInfoBarFonts(void)
{
    if(g_hfont)
    {
        DeleteObject(g_hfont);
        g_hfont = NULL;
    }
    if(g_hfontBold)
    {
        DeleteObject(g_hfontBold);
        g_hfontBold = NULL;
    }
}


/**********************************************************************
* PaintStepsText()
*
* Paint the setup steps in the steps window. Highlites the current step.
*
**********************************************************************/
int PaintStepsText(HDC hdc, RECT rc)
{
    static TCHAR szSteps[UI_INFOBAR_NUM_STEPS][MAX_STRING];
    static int   iNumLines[UI_INFOBAR_NUM_STEPS];
    static int   iMaxNumLines = 1;
    static RECT  rcSteps = {0, 0, 0, 0};

    COLORREF    crOld = 0;
    int         cxStepText;
    int         cxStepBullet;
    int         cyStep;
    RECT        rcStepText;    
    HFONT       hfontOld = NULL;
    TEXTMETRIC  tm;
    BITMAP      bm;
    HBITMAP     hbitmapOn = NULL;
    HBITMAP     hbitmapOff = NULL;
    HBITMAP     hbitmapHalf = NULL;
    HBITMAP     hbitmap = NULL;
    
    int         iCurrentStep = 0;
    
    //do gdi stuff
    SaveDC(hdc);
    SetMapMode(hdc, MM_TEXT);
    SetBkMode( hdc, TRANSPARENT );
   
    hbitmapOn = LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(g_idbSelectedBullet),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR );
    hbitmapOff = LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(g_idbReleasedBullet),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR );
    hbitmapHalf = LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(g_idbCurrentBullet),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR );

    // select either one to get the width of the bullets
    // assume both type of bullet have same width    
    hbitmap = (hbitmapOn) ? hbitmapOn : hbitmapOff;
    if (hbitmap)
    {
        GetObject( hbitmap, sizeof(BITMAP), &bm );
    }
    else
    {
        bm.bmWidth = 0;
    }

    crOld = SetTextColor(hdc, g_colStepsTxt);
    SelectObject(hdc, g_hfontBold);
    GetTextMetrics(hdc, &tm);
    
    if (g_bBiDi)
    {
        cxStepBullet = rc.right - bm.bmWidth;
        cxStepText = 0;
        
        rcStepText.left = rc.left;
        rcStepText.right = rc.right - 3 * bm.bmWidth / 2;
        rcStepText.top = rc.top;
        rcStepText.bottom = rc.bottom;
    }
    else
    {
        cxStepBullet = rc.left;
        cxStepText = 3 * bm.bmWidth / 2;
        
        rcStepText.left = rc.left;
        rcStepText.right = rc.right;
        rcStepText.top = rc.top;
        rcStepText.bottom = rc.bottom;
    }        

    if (!EqualRect(&rcSteps, &rc))
    {        
        iMaxNumLines = 1;
        for (iCurrentStep = 1; iCurrentStep <= UI_INFOBAR_NUM_STEPS; iCurrentStep++)
        {
            if (!LoadString(g_hInstance, uiIDSteps[iCurrentStep-1],
                (LPTSTR)szSteps[iCurrentStep-1], MAX_STRING))
            {
                szSteps[iCurrentStep-1][0] = TEXT('\0');
            }
            
            iNumLines[iCurrentStep-1] = 
                WrapText(hdc, cxStepText, &rcStepText, szSteps[iCurrentStep-1]);
            
            if (iNumLines[iCurrentStep-1] > iMaxNumLines)
            {
                iMaxNumLines = iNumLines[iCurrentStep-1];
            }
        }
        
        for (iCurrentStep = 1; iCurrentStep <= UI_INFOBAR_NUM_STEPS; iCurrentStep++)
        {
            if (iNumLines[iCurrentStep-1] < iMaxNumLines)
            {
                TCHAR szStep[MAX_STRING];
                INT   cchStep;

                // ImproveWrap may add a null character to the string.
                cchStep = LoadString(g_hInstance, uiIDSteps[iCurrentStep-1],
                    (LPTSTR)szStep, MAX_STRING - 1);

                if (cchStep != 0)
                {
                    ImproveWrap(szSteps[iCurrentStep-1],
                                &iNumLines[iCurrentStep-1],
                                szStep,
                                cchStep);
                }
            }
        }
        
        CopyRect(&rcSteps, &rc);
    }

    cyStep = rc.top;
    
    for(iCurrentStep = 1; iCurrentStep <= UI_INFOBAR_NUM_STEPS; iCurrentStep++)
    {        
        if(iCurrentStep < g_iCurrentStep)
        {
            SetTextColor(hdc, g_colStepsMarkTxt);
            SelectObject(hdc, g_hfontBold);
            hbitmap = hbitmapOn;
        }
        else if (iCurrentStep == g_iCurrentStep)
        {
            SetTextColor(hdc, g_colStepsCurrentTxt);
            SelectObject(hdc, g_hfontBold);
            hbitmap = hbitmapHalf;
        }
        else
        {
            SetTextColor(hdc, g_colStepsTxt);
            SelectObject(hdc, g_hfont);
            hbitmap = hbitmapOff;
        }

        if(!hbitmap)
        {
            OutputDebugString(TEXT("Billboard: PaintStepsText failed to load bitmap\r\n"));
        }    
        else
        {
            DrawTransparentBitmap(
                hdc,
                hbitmap,
                cxStepBullet,
                cyStep,
                g_colBulletTrans);
        }

        DrawWrapText(
            hdc,
            &tm,
            0,
            cxStepText,
            cyStep,
            &rcStepText,
            LEFT,
            iNumLines[iCurrentStep-1],
            szSteps[iCurrentStep-1]);

        
        if (iCurrentStep != UI_INFOBAR_NUM_STEPS)
        {
            cyStep += tm.tmHeight * (iMaxNumLines + 1);
        }
        else
        {
            int inc = tm.tmHeight * iMaxNumLines;
            if (inc  < bm.bmHeight)
            {
                cyStep += bm.bmHeight;
            }
            else
            {
                cyStep += inc;
            }
        }
            
    }

    if (hbitmapOn)
    {
        DeleteObject(hbitmapOn);
        hbitmapOn = NULL;
    }

    if (hbitmapOff)
    {
        DeleteObject(hbitmapOff);
        hbitmapOff = NULL;
    }

    hbitmap = NULL;

    RestoreDC(hdc, -1);
    SelectObject(hdc, hfontOld);  // select the original font back into the DC
    SetTextColor(hdc, crOld);
    
    return cyStep;
}


LRESULT CALLBACK InfoBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

    switch (msg)
    {

        case WM_PAINT:
        {
            PAINTSTRUCT     ps;
            RECT            rc;
            HDC             hdc;
            RECT    rcToParent;
            HWND    hwndParent;
            HDC     hdcBG;
            HDC     hdcMem;
            HBITMAP hbmpMem;

            // try to draw steps without flickle
            
            hdc = BeginPaint(hwnd, &ps);

            GetClientRect(hwnd, &rc);
            GetRectInParent(hwnd, &rc, &rcToParent);
            
            hdcBG = GetBackgroundBuffer();
            
            hdcMem = CreateCompatibleDC(hdc);
            hbmpMem = CreateCompatibleBitmap(hdc, rc.right, rc.bottom);                        
            if (hdcMem && hbmpMem)
            {
                RECT    rcLP;
                                          
                SelectObject(hdcMem, hbmpMem);

                BitBlt(hdcMem,
                       rc.left,
                       rc.top,
                       rc.right - rc.left,
                       rc.bottom - rc.top,
                       hdcBG,
                       rcToParent.left,
                       rcToParent.top,
                       SRCCOPY);
                
                CopyRect(&rcLP, &rc);
                DPtoLP(hdcMem, (LPPOINT) &rcLP, 2);
                PaintStepsText(hdcMem, rcLP);
                
                BitBlt(hdc,
                       rc.left,
                       rc.top,
                       rc.right - rc.left,
                       rc.bottom - rc.top,
                       hdcMem,
                       rc.left,
                       rc.top,
                       SRCCOPY);
                
            }

            if (hbmpMem != NULL)
            {
                DeleteObject(hbmpMem);
                hbmpMem = NULL;
            }

            if (hdcMem != NULL) {
                DeleteDC(hdcMem);
                hdcMem = NULL;
            }

            EndPaint(hwnd, &ps);
            
            return(0);

        }

        case WM_SETSTEP:
        {
            int     iPanel;
            int     ret;
 
            iPanel = (int) lParam;
            if (iPanel <= UI_INFOBAR_NUM_STEPS)
            {                
                g_iCurrentStep = iPanel;
                ret = 1;
                InvalidateRect(hwnd, NULL, FALSE);
                UpdateWindow(hwnd);
            }
            else
            {
                ret = 0;
            }
    
            return ret;
        }
        
        case WM_DESTROY:
        {
            DeleteInfoBarFonts();

            return (DefWindowProc(hwnd, msg, wParam, lParam));
        }

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}


BOOL WINAPI InitInfoBar(HWND hwndParent)
{
    WNDCLASS  wc;
    RECT    rc1;

    wc.style         = (UINT)CS_BYTEALIGNWINDOW;
    wc.lpfnWndProc   = InfoBarWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = g_hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = g_szStepsClassName;

    if (!RegisterClass (&wc))
        return FALSE;

    GetWindowRect(hwndParent, &rc1);
    g_hwndSteps = CreateWindow(
        g_szStepsClassName,
        TEXT(""),
        WS_CHILD, 
        rc1.left + g_cxSteps,
        rc1.top + g_cySteps,
        g_cxStepsWidth,
        g_cyStepsHeight,
        hwndParent,
        NULL,
        g_hInstance,
        NULL );

    if (g_hwndSteps == NULL)
    {
        UnregisterClass(g_szStepsClassName, g_hInstance);
        return FALSE;
    }
    ShowWindow( g_hwndSteps, SW_SHOW );
    UpdateWindow( g_hwndSteps );

    return TRUE;

}


int GetStepText(int nStep, LPTSTR lpStr)
{
    TCHAR szStep[16];
    wsprintf(szStep, TEXT("Step%d"), nStep);
    return GetPrivateProfileString(TEXT("Steps"), szStep, TEXT(""), 
                           lpStr, MAX_PATH, g_szFileName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\sources.inc ===
MAJORCOMP=setup

TARGETPATH=..\obj
TARGETTYPE=DYNLINK

DLLDEF=..\winntbb.def
DLLENTRY=_DllMainCRTStartup

NO_NTDLL=1
USE_LIBCMT=1
SUBSYSTEM_VERSION=4.00
LINKER_FLAGS=/SWAPRUN:CD /SWAPRUN:NET

!include $(PROJECT_ROOT)\ntsetup\sources.inc

INCLUDES=\
    ..\..;                 \
    ..\..\..\inc;          \
    $(DS_INC_PATH);     \
    $(SHELL_INC_PATH);  \
    $(BASE_INC_PATH);   \
    $(WINDOWS_INC_PATH); \
    $(ENDUSER_INC_PATH); \
    $(NET_INC_PATH)

!ifdef USE_FAST_ALLOC
!if $(USE_FAST_ALLOC) == 0
C_DEFINES=$(C_DEFINES) -DUSE_FAST_ALLOC=0
!else
C_DEFINES=$(C_DEFINES) -DUSE_FAST_ALLOC=1
!endif
!endif

!ifdef _WIN32_IE
!undef _WIN32_IE
!endif

C_DEFINES=$(C_DEFINES) -DDBGHEAP_CHECK -D_WIN32_IE=0x0400

SOURCES= \
        dllinit.c \
        info.c    \
        addpath.c \
        billbrd.c \
        dibutil.c \
        animate.c \
        winntbb.rc

TARGETLIBS = \
              $(SDK_LIB_PATH)\user32.lib      \
              $(SDK_LIB_PATH)\gdi32.lib      \
              $(SDK_LIB_PATH)\advapi32.lib    \
              $(SDK_LIB_PATH)\kernel32.lib 
#              $(SDK_LIB_PATH)\ole32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\billbrd\ansi\pch.h ===
#include <windows.h>
#include <stdlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\checkhiv\checkhiv.c ===
/*

    5/06/99    AndrewR        Created.

*/

#include <windows.h>

#include <stdio.h>
#include <tchar.h>
#include <shellapi.h>

#if DBG

VOID
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else

#define ASSERT( exp )

#endif // DBG

void PrintUsage(void) {
    printf("retrieves information about a hive\n");
    printf("\n");
    printf("Usage: checkhiv -h HiveName -t TimeBomb -s Suite -p ProcCount -u Upgrade only\n");
    return;
}

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

BOOLEAN
AdjustPrivilege(
    PCTSTR   Privilege
    )
/*++

Routine Description:

    This routine tries to adjust the priviliege of the current process.


Arguments:

    Privilege - String with the name of the privilege to be adjusted.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               Privilege,
                               &( LuidAndAttributes.Luid ) ) ) {
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        return( FALSE );
    }

    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }
    return( TRUE );
}


BOOL
GetHiveData(
    IN  PCTSTR OriginalHiveName,
    OUT PDWORD SuiteMask,
    OUT PDWORD TimeBomb,
    OUT PDWORD ProcCount,
    OUT PBOOL  StepUp
    )
{

    TCHAR HiveTarget[MAX_PATH];
    TCHAR HiveName[MAX_PATH] = TEXT("xSETREG");
    TCHAR lpszSetupReg[MAX_PATH] = TEXT("xSETREG\\ControlSet001\\Services\\setupdd");
    TCHAR TargetPath[MAX_PATH];

    LONG rslt;
    HKEY hKey;
    DWORD Type;
    DWORD Buffer[4];
    DWORD BufferSize = sizeof(Buffer);
    DWORD tmp,i;

    BOOL RetVal = FALSE;
    TCHAR Dbg[1000];

    ASSERT(OriginalHiveName && SuiteMask && TimeBomb && ProcCount && StepUp);
    *SuiteMask = 0;
    *TimeBomb = 0;
    *ProcCount = 0;
    *StepUp = FALSE;

    //
    // copy the hive locally since you can only have one open on a hive at a time
    //
    GetTempPath(MAX_PATH,TargetPath);
    GetTempFileName(TargetPath,TEXT("set"),0,HiveTarget);

    CopyFile(OriginalHiveName,HiveTarget,FALSE);
    SetFileAttributes(HiveTarget,FILE_ATTRIBUTE_NORMAL);

    //
    // try to unload this first in case we faulted or something and the key is still loaded
    //
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HiveName );

    //
    // need SE_RESTORE_NAME priviledge to call this API!
    //
    AdjustPrivilege((PWSTR)SE_RESTORE_NAME);


    rslt = RegLoadKey( HKEY_LOCAL_MACHINE, HiveName, HiveTarget );
    if (rslt != ERROR_SUCCESS) {
#ifdef DBG
        wsprintf( Dbg, TEXT("Couldn't RegLoadKey, ec = %d\n"), rslt );
        OutputDebugString(Dbg);
#endif

        goto e1;
    }

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,lpszSetupReg,&hKey);
    if (rslt != ERROR_SUCCESS) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't RegOpenKey\n"));
#endif

        goto e2;
    }

    rslt = RegQueryValueEx(hKey, NULL, NULL, &Type, (LPBYTE) Buffer, &BufferSize);
    if (rslt != ERROR_SUCCESS || Type != REG_BINARY) {
#ifdef DBG
        OutputDebugString(TEXT("Couldn't RegQueryValueEx\n"));
#endif

        goto e3;
    }

    *TimeBomb  = Buffer[0];
    *StepUp    = (BOOL)Buffer[1];
    *ProcCount = Buffer[2];
    *SuiteMask = Buffer[3];

    RetVal = TRUE;

e3:
    RegCloseKey( hKey );
e2:
    RegUnLoadKey( HKEY_LOCAL_MACHINE, HiveName );

e1:
    if (GetFileAttributes(HiveTarget) != 0xFFFFFFFF) {
        SetFileAttributes(HiveTarget,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(HiveTarget);
    }

    return(RetVal);

}




int _cdecl
main(
    int argc,
    char *argvA[]
    )
{
    PTSTR *argv;
    PTSTR HiveName = NULL;
    PTSTR TimeBombString = NULL;
    PTSTR SuiteString = NULL;
    PTSTR ProcCountString = NULL;
    PTSTR UpgradeOnlyString = NULL;

    TCHAR TempFile[MAX_PATH];
    PTSTR p;

    DWORD SuiteMask;
    DWORD TimeBomb;
    DWORD ProcCount;
    BOOL  Upgrade;

    DWORD Result = 0;

    DWORD ActualSuiteMask, ActualTimeBomb, ActualProcCount;
    BOOL ActualStepUp;

    // do commandline stuff
#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    //
    // parse args
    //
    while (--argc) {

        argv++;

        if ((argv[0][0] == TEXT('-')) || (argv[0][0] == TEXT('/'))) {

            switch (argv[0][1]) {

                case TEXT('h'):
                case TEXT('H'):
                    HiveName = argv[1];
                    goto Next;
                    break;
                case TEXT('p'):
                case TEXT('P'):
                    ProcCountString = argv[1];
                    goto Next;
                    break;
                case TEXT('s'):
                case TEXT('S'):
                    SuiteString = argv[1];
                    goto Next;
                    break;
                case TEXT('t'):
                case TEXT('T'):
                    TimeBombString = argv[1];
                    goto Next;
                    break;
                case TEXT('u'):
                case TEXT('U'):
                    UpgradeOnlyString = argv[1];
                    goto Next;
                    break;
                default:
                    PrintUsage();
                    return ERROR_INVALID_PARAMETER;
            }

        }

Next:
    ;
    }

    //
    // Validate parameters
    //
    if (!HiveName || (!ProcCountString && !SuiteString && !TimeBombString && !UpgradeOnlyString)) {
        printf("Invalid usage\n" );
        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }

    GetFullPathName(HiveName,sizeof(TempFile)/sizeof(TCHAR),TempFile,&p);

    if (!FileExists(TempFile,NULL)) {
        printf("Could not find hive file %S\n", TempFile );
        PrintUsage();
        return ERROR_FILE_NOT_FOUND;
    }

    HiveName = TempFile;


    //
    // retrieve hive information
    //
    if (!GetHiveData(HiveName,
                     &ActualSuiteMask,
                     &ActualTimeBomb,
                     &ActualProcCount,
                     &ActualStepUp
                     )) {
        printf("Could not retrive information from hive\n" );
        return ERROR_INVALID_DATA;
    }

    //marrq result was init to 1, changed to 0
    Result = 0;

    if (UpgradeOnlyString) {
        Upgrade = !lstrcmpi(UpgradeOnlyString,L"TRUE");
        if (Upgrade != ActualStepUp) {
            printf("Upgrade only inconsistent --> hive says Upgrade = %s\n", ActualStepUp ? "TRUE" : "FALSE");
            Result = ERROR_INVALID_DATA;
        }
    }

    if (ProcCountString) {
        ProcCount = _ttoi(ProcCountString);
        if (ProcCount != ActualProcCount) {
            printf("Proc count inconsistent --> hive says Proc count = %d\n", ActualProcCount);
            Result = ERROR_INVALID_DATA;
        }
    }

    if (SuiteString) {
        SuiteMask = _ttoi(SuiteString);
        if (SuiteMask != ActualSuiteMask) {
            printf("Suite mask inconsistent --> hive says suite mask = %d\n", ActualSuiteMask);
            Result = ERROR_INVALID_DATA;
        }
    }

    if (TimeBombString) {
        TimeBomb = _ttoi(TimeBombString);
        //
        // convert to minutes
        //
        TimeBomb = TimeBomb * 60 * 24;
        if (TimeBomb != ActualTimeBomb) {
            printf("Time bomb inconsistent --> hive says Time bomb = %d days\n", (ActualTimeBomb / (60*24)));
            Result = ERROR_INVALID_DATA;
        }

    }

    //marrq this was checking for 1, changed to 0
    if (Result == 0) {
        printf("Hive is valid.\n");
    } else {
        printf("One or more inconsistencies detected in hive.\n");
    }

    return Result;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\makeboot.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      makeboot.h
//
// Description:
//      Local include file for DOS based MAKEBOOT program.
//
//      Contains all of the indexes into the string table array.
//
//----------------------------------------------------------------------------

#define NT_VERSION_NAME                 0
#define DISK_LABEL_1                    1
#define DISK_LABEL_2                    2
#define DISK_LABEL_3                    3
#define DISK_LABEL_4                    4

#define CANNOT_FIND_FILE                5
#define NOT_ENOUGH_MEMORY               6
#define NOT_EXEC_FORMAT                 7
#define STARS                           8

#define EXPLANATION_LINE_1              9
#define EXPLANATION_LINE_2              10
#define EXPLANATION_LINE_3              11
#define EXPLANATION_LINE_4              12

#define INSERT_FIRST_DISK_LINE_1        13
#define INSERT_FIRST_DISK_LINE_2        14

#define INSERT_ANOTHER_DISK_LINE_1      15
#define INSERT_ANOTHER_DISK_LINE_2      16

#define PRESS_ANY_KEY_TO_CONTINUE       17

#define COMPLETED_SUCCESSFULLY          18
#define COMPLETE                        19

#define UNKNOWN_SPAWN_ERROR             20
#define SPECIFY_DRIVE                   21
#define INVALID_DRIVE_LETTER            22
#define NOT_A_FLOPPY                    23

#define ATTEMPT_TO_CREATE_FLOPPY_AGAIN  24
#define PRESS_ENTER_OR_ESC              25

#define ERROR_DISK_WRITE_PROTECTED      26
#define ERROR_UNKNOWN_DISK_UNIT         27
#define ERROR_DRIVE_NOT_READY           28
#define ERROR_UNKNOWN_COMMAND           29
#define ERROR_DATA_ERROR                30
#define ERROR_BAD_REQUEST               31
#define ERROR_SEEK_ERROR                32
#define ERROR_MEDIA_TYPE_NOT_FOUND      33
#define ERROR_SECTOR_NOT_FOUND          34
#define ERROR_WRITE_FAULT               35
#define ERROR_GENERAL_FAILURE           36
#define ERROR_INVALID_REQUEST           37
#define ERROR_ADDRESS_MARK_NOT_FOUND    38
#define ERROR_DISK_WRITE_FAULT          39
#define ERROR_DMA_OVERRUN               40
#define ERROR_CRC_ERROR                 41
#define ERROR_CONTROLLER_FAILURE        42
#define ERROR_DISK_TIMED_OUT            43

#define DISK_LABEL_5                    44
#define DISK_LABEL_6                    45
#define DISK_LABEL_7                    46
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

SOURCES_USED=..\sources.inc

!IF $(386)
NTTARGETFILE1=$(O)\makeboot.exe
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\makeboot.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      makeboot.c
//
// Description:
//      This program copies the images of the 4 Windows NT setup disks to
//      floppy disk so the user can boot their system with them.
//
//  Assumptions:
//      The sector size is 512 and the sectors per track is 18
//
//      The floppy disk images are in the current dir and named CDBOOT1.IMG,
//      CDBOOT2.IMG, CDBOOT3.IMG and CDBOOT4.IMG.
//
//      The txtsetup.sif resides in ..\i386 or ..\alpha from where the
//      program is being run.
//     
//----------------------------------------------------------------------------

#include <bios.h>
#include <string.h>
#include <malloc.h>
#include <io.h>
#include <fcntl.h>
#include <process.h>
#include <errno.h>
#include <conio.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "makeboot.h"

//
//  Constants
//

//
//  To support disks other than 1.44 MB High-Density floppies, then these
//  numbers will have to be changed or determined at run-time.
//
#define SECTORS_PER_TRACK          18
#define SECTOR_SIZE                512
#define TRACK_SIZE                 SECTORS_PER_TRACK * SECTOR_SIZE
#define NUMBER_OF_TRACKS           80
#define SECTORS_TO_COPY_AT_A_TIME  18

//  we multiply by 2 because the disk is double-sided
#define NUMBER_OF_SECTORS_ON_DISK   NUMBER_OF_TRACKS * SECTORS_PER_TRACK * 2

#define NT_NAME_OF_MAKEBOOT  "makebt32.exe"

#define NT_IMAGE_1_NAME      "CDBOOT1.IMG"
#define NT_IMAGE_2_NAME      "CDBOOT2.IMG"
#define NT_IMAGE_3_NAME      "CDBOOT3.IMG"
#define NT_IMAGE_4_NAME      "CDBOOT4.IMG"
#define NT_IMAGE_5_NAME      "CDBOOT5.IMG"
#define NT_IMAGE_6_NAME      "CDBOOT6.IMG"
#define NT_IMAGE_7_NAME      "CDBOOT7.IMG"

#define MAX_INILINE_LENGTH    1023

#define ENTER_KEY             13
#define ESC_KEY               27

#define NUMBER_OF_ASCII_WHEEL_SYMBOLS  4

const char rgAsciiWheel[NUMBER_OF_ASCII_WHEEL_SYMBOLS] = { '|', '/', '-', '\\' };

//
//  Function prototypes
//
int WriteImageToFloppy( char *szFileName, int drive );
int DoesUserWantToTryCopyAgain( void );
void ReportBiosError( unsigned int iBiosErrorCode );
int  DoImageFilesExist( void );
unsigned int IsFloppyDrive( int DriveLetter );
void PressAnyKeyToContinue( void );
unsigned int AbsoluteDiskWrite( unsigned int *iErrorCode,
                                unsigned int iDrive, 
                                unsigned int iStartingSector,
                                unsigned int iNumberOfSectorsToWrite,
                                void far *Buffer_to_be_written );

unsigned DnGetCodepage(void);

//
//  Variables that are allocated in strings.c that are used to determine what
//  string table to use.
//

extern unsigned int CODEPAGE;

extern const char *EngStrings[];

extern const char *LocStrings[];

//
//  This var holds a pointer to the array of strings to be used
//
const char **StringTable;

//----------------------------------------------------------------------------
//
// Function: main
//
// Purpose: Instructs user to insert floppy disks to be copied and performs
//          the copy.
//
// Arguments: int argc - standard program argument, count of the command line args
//            char *argv[] - standard program argument, the 2nd argument is the
//                           floppy drive to copy the images to.
// Returns: int - zero on success, non-zero on error
//
//----------------------------------------------------------------------------
int 
main( int argc, char *argv[] )
{     

    char *szOsName;
    char Drive;
    char DriveLetter;
    int  bTryAgain;

    //
    //  Set the string table to the appropriate language depending on
    //  the code page.
    //
    if( *LocStrings[0] == '\0' )
    {
        StringTable = EngStrings;
    } 
    else {

        if( DnGetCodepage() != CODEPAGE )
        {
            StringTable = EngStrings;
        }
        else
        {
            StringTable = LocStrings;
        }

    }

    szOsName = getenv( "OS" );

    //
    //  See if we are on NT.  If we are, call the NT version and exit.
    //  If we aren't then just continue executing this program.
    //
    if( szOsName && ( stricmp( szOsName, "Windows_NT" ) == 0 ) )
    {

        int iRetVal;

        iRetVal = spawnl( P_WAIT, NT_NAME_OF_MAKEBOOT, NT_NAME_OF_MAKEBOOT, argv[1], NULL );

        if( iRetVal == -1 )
        {
            if( errno == ENOENT )
            {
                printf( StringTable[ CANNOT_FIND_FILE ], NT_NAME_OF_MAKEBOOT );

                exit( 1 );
            }
            else if( errno == ENOMEM )
            {
                printf( StringTable[ NOT_ENOUGH_MEMORY ] );

                exit( 1 );
            }
            else if( errno == ENOEXEC )
            {
                printf( StringTable[ NOT_EXEC_FORMAT ], NT_NAME_OF_MAKEBOOT );

                exit( 1 );
            }
            else
            {
                printf( StringTable[ UNKNOWN_SPAWN_ERROR ], NT_NAME_OF_MAKEBOOT );

                exit( 1 );
            }
        }

        // successful completion
        exit( 0 );

    }

    printf( "\n%s\n", StringTable[ STARS ]   );
    printf( "%s\n", StringTable[ EXPLANATION_LINE_1 ] );
    printf( StringTable[ EXPLANATION_LINE_2 ], StringTable[ NT_VERSION_NAME ] );
    printf( "\n\n" );

    printf( "%s\n", StringTable[ EXPLANATION_LINE_3 ] );
    printf( "%s\n\n", StringTable[ EXPLANATION_LINE_4 ] );

    //
    //  If they didn't specified the floppy drive on the command line then
    //  prompt them for it.
    //
    if( argc == 1 )
    {

        printf( StringTable[ SPECIFY_DRIVE ] );

        DriveLetter = (char) getche();

        printf( "\n\n" );

    }
    else
    {

        DriveLetter = argv[1][0];

    }

    //
    //  Make sure the character they entered is a possible drive letter
    //
    if( ! isalpha( DriveLetter ) )
    {

        printf( StringTable[ INVALID_DRIVE_LETTER ] );

        exit( 1 );

    }

    //
    //  Make sure the drive specified is actually a floppy drive
    //

    if( ! IsFloppyDrive( DriveLetter ) )
    {

        printf( StringTable[ NOT_A_FLOPPY ], DriveLetter );

        exit( 1 );

    }

    //
    //  map the drive letter a or A to 0, b or B to 1, etc.
    //
    Drive = (char) ( toupper( DriveLetter ) - (int)'A' );

    //
    //  Make sure all the images files exist in the current directory
    //
    if( ! DoImageFilesExist() ) 
    {
        exit( 1 );
    }

    printf( StringTable[ INSERT_FIRST_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );

    printf( StringTable[ INSERT_FIRST_DISK_LINE_2 ], StringTable[ DISK_LABEL_1 ] );
    printf( "\n\n" );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_1_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_2 ] );
    printf( "\n\n" );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_2_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_3 ] );
    printf( "\n\n" );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_3_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_4 ] );
    printf( "\n\n" );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_4_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_5 ] );
    printf( "\n\n" );
    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_5_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_6 ] );
    printf( "\n\n" );
    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_6_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_1 ], DriveLetter );
    printf( "\n" );
    printf( StringTable[ INSERT_ANOTHER_DISK_LINE_2 ], StringTable[ DISK_LABEL_7 ] );
    printf( "\n\n" );
    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_7_NAME, Drive ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    printf( "\n\n%s\n\n", StringTable[ COMPLETED_SUCCESSFULLY ] );

    printf( "%s\n", StringTable[ STARS ] );

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: WriteImageToFloppy
//
// Purpose:  Writes an image file to a floppy disk.  Handles all error
//           reporting to the user.
//
// Arguments: char *szFileName - filename to write to the floppy
//            int   drive - drive letter of the floppy to write to
//
// Returns: int - non-zero on success
//              - zero on error
//
//----------------------------------------------------------------------------
int
WriteImageToFloppy( char *szFileName, int drive )
{

    char         *pTrack;
    int          hImageFile;
    unsigned int iSuccess;
    unsigned int iErrorCode;
    unsigned int iBytesRead;
    unsigned int iTotalSectorsWritten;
    unsigned int iPercentComplete;
    unsigned int iWheelPosition;
    char         TrackBuffer[ TRACK_SIZE ];
    
    _fmode = O_BINARY; 

    //
    //  Open the image file
    //
    hImageFile = open( szFileName, O_RDONLY );

    if( hImageFile == -1 )
    {
        perror( szFileName );

        return( 0 );
    }

    iWheelPosition        = 0;
    iTotalSectorsWritten  = 0;

    //
    //  Loop reading a track and then writing SECTORS_TO_COPY_AT_A_TIME sectors
    //  out at a time until we reach the end of the file
    //
    while( ( iBytesRead = read( hImageFile, TrackBuffer, TRACK_SIZE ) ) > 0 )
    {

        pTrack = TrackBuffer;

        for( ;
             iBytesRead > 0;
             iTotalSectorsWritten += SECTORS_TO_COPY_AT_A_TIME )
        {

            iSuccess = AbsoluteDiskWrite( &iErrorCode,
                                          drive,
                                          iTotalSectorsWritten,
                                          SECTORS_TO_COPY_AT_A_TIME,
                                          (void far *) pTrack );

            if( ! iSuccess )
            {
                ReportBiosError( iErrorCode );

                close( hImageFile );

                return( 0 );
            }

            iBytesRead = iBytesRead - ( SECTOR_SIZE * SECTORS_TO_COPY_AT_A_TIME );

            pTrack = pTrack + ( SECTOR_SIZE * SECTORS_TO_COPY_AT_A_TIME );

        }

        iPercentComplete = (int) ( ( (double) (iTotalSectorsWritten) / (double) (NUMBER_OF_SECTORS_ON_DISK) ) * 100.0 );

        printf( "%c %3d%% %s\r",
                rgAsciiWheel[iWheelPosition], 
                iPercentComplete,
                StringTable[ COMPLETE ] );
                
        //
        //  Advance the ASCII wheel
        //

        iWheelPosition++;

        if( iWheelPosition >= NUMBER_OF_ASCII_WHEEL_SYMBOLS )
        {
            iWheelPosition = 0;                
        }

    }

    //
    //  We are done copying the disk so force it to read 100% and get rid of
    //  the ascii wheel symbol.
    //
    printf( " 100%% %s          \n", StringTable[ COMPLETE ] );

    close( hImageFile );

    return( 1 );

}

//----------------------------------------------------------------------------
//
//  Function: DoesUserWantToTryCopyAgain
//
//  Purpose:  Ask the user if they want to retry to copy the image to floppy.
//            Get the user input and return whether to copy again or not.
//
//  Arguments: void
//
//  Returns:  int - non-zero  if user wants to attempt to copy again
//                - zero if user does not want to attempt to copy again
//
//----------------------------------------------------------------------------
int
DoesUserWantToTryCopyAgain( void )
{

    int ch;

    //
    //  Clear the input stream by eating all the chars until there are none
    //  left.  Print the message and then wait for a key press.
    //
    while( kbhit() )
    {
        getch();
    }
    
    do
    {
        printf( "%s\n", StringTable[ ATTEMPT_TO_CREATE_FLOPPY_AGAIN ] );
        printf( "%s\n", StringTable[ PRESS_ENTER_OR_ESC ] );

        ch = getch();

    } while( ch != ENTER_KEY && ch != ESC_KEY  );

    if( ch == ENTER_KEY )
    {
        return( 1 );
    }
    else
    {
        return( 0 );
    }

}

//----------------------------------------------------------------------------
//
//  Function: PressAnyKeyToContinue
//
//  Purpose:  Print the "Press any key when ready" message and wait until the
//  user presses a key.
//
//  Arguments: void
//
//  Returns:  void
//
//----------------------------------------------------------------------------
void
PressAnyKeyToContinue( void )
{

    //
    //  Clear the input stream by eating all the chars until there are none
    //  left.  Print the message and then wait for a key press.
    //
    while( kbhit() )
    {
        getch();
    }

    printf( "%s\n", StringTable[ PRESS_ANY_KEY_TO_CONTINUE ] );

    //
    //  Spin until the keyboard is pressed
    //
    while( ! kbhit() )
    {
        ;
    }

}

//----------------------------------------------------------------------------
//
// Function: DoImageFilesExist
//
// Purpose:  Determines if all the image files are in the current directory or
//           not.  If an image file is missing, an error message is printed
//           to the user.
//
//           Note: it detemines if a file exists by seeing if it can open it
//           for reading.
//
// Arguments: void
//
// Returns: int -- non-zero on success, all images files exist in current dir
//                 zero on failure, 1 or more image files do not exist
//
//----------------------------------------------------------------------------
int
DoImageFilesExist( void ) 
{

    FILE *FileStream;
    int  iSuccess = 1;  // assume success
    
    if( ( FileStream = fopen( NT_IMAGE_1_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_1_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_2_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_2_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_3_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_3_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_4_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_4_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_5_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_5_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_6_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_6_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }

    if( ( FileStream = fopen( NT_IMAGE_7_NAME, "r" ) ) == NULL )
    {
        printf( StringTable[ CANNOT_FIND_FILE ], NT_IMAGE_7_NAME );

        printf( "\n" );

        iSuccess = 0;
    }
    else
    {
        fclose( FileStream );
    }
    
    return( iSuccess );

}

//----------------------------------------------------------------------------
//
// Function: IsFloppyDrive
//
// Purpose:  To determine if a particular drive is a floppy drive.
//
// Arguments:  int DriveLetter - the drive letter to test whether it is a
//                               floppy or not
//
// Returns: unsigned int -- non-zero if the specified drive is a floppy drive
//                          zero if the specified drive is not a floppy drive
//
//----------------------------------------------------------------------------
unsigned int
IsFloppyDrive( int DriveLetter )
{

    unsigned int drive;
    unsigned int iIsFloppy;
    
    //
    //  Convert the drive letter to a number.  1 = A, 2 = B, 3 = C, ...
    //
    drive = ( toupper( DriveLetter ) - (int)'A' ) + 1;

    //
    //  Assume it is not a floppy
    //
    iIsFloppy = 0;

    _asm {
        push    ds
        push    es
        push    bp

        mov     ah, 1Ch                 // going to call function 1Ch
        mov     dl, BYTE PTR [drive]

        int     21h                     // call Int 21h function 1Ch

        cmp     BYTE PTR ds:[bx], 0F8h  // test for fixed drive

        je      done

        mov     iIsFloppy, 1            // it is a floppy

done:

        pop     bp
        pop     es
        pop     ds
    }

    return( iIsFloppy );

}

//----------------------------------------------------------------------------
//
// Function: ReportBiosError
//
// Purpose:  To convert a BIOS error code to a error message and print it out
//           for the user to see.
//
// Arguments: unsigned int iBiosErrorCode - the BIOS error code to be looked up
//
// Returns: void
//
//----------------------------------------------------------------------------
void
ReportBiosError( unsigned int iBiosErrorCode )
{
    // 
    //  Print out the error code for the lower byte
    //
    switch( iBiosErrorCode & 0x00FF )
    {

        case 0x0000:    printf( StringTable[ ERROR_DISK_WRITE_PROTECTED ] );  break;
        case 0x0001:    printf( StringTable[ ERROR_UNKNOWN_DISK_UNIT    ] );  break;
        case 0x0002:    printf( StringTable[ ERROR_DRIVE_NOT_READY      ] );  break;
        case 0x0003:    printf( StringTable[ ERROR_UNKNOWN_COMMAND      ] );  break;
        case 0x0004:    printf( StringTable[ ERROR_DATA_ERROR           ] );  break;
        case 0x0005:    printf( StringTable[ ERROR_BAD_REQUEST          ] );  break;
        case 0x0006:    printf( StringTable[ ERROR_SEEK_ERROR           ] );  break;
        case 0x0007:    printf( StringTable[ ERROR_MEDIA_TYPE_NOT_FOUND ] );  break;
        case 0x0008:    printf( StringTable[ ERROR_SECTOR_NOT_FOUND     ] );  break;
        case 0x000A:    printf( StringTable[ ERROR_WRITE_FAULT          ] );  break;
        case 0x000C:    printf( StringTable[ ERROR_GENERAL_FAILURE      ] );  break;
    }

    // 
    //  Print out the error code for the upper byte
    //
    switch( iBiosErrorCode & 0xFF00 )
    {
        case 0x0100:    printf( StringTable[ ERROR_INVALID_REQUEST        ] );  break;
        case 0x0200:    printf( StringTable[ ERROR_ADDRESS_MARK_NOT_FOUND ] );  break;
        case 0x0300:    printf( StringTable[ ERROR_DISK_WRITE_FAULT       ] );  break;
        case 0x0400:    printf( StringTable[ ERROR_SECTOR_NOT_FOUND       ] );  break;
        case 0x0800:    printf( StringTable[ ERROR_DMA_OVERRUN            ] );  break;
        case 0x1000:    printf( StringTable[ ERROR_CRC_ERROR              ] );  break;
        case 0x2000:    printf( StringTable[ ERROR_CONTROLLER_FAILURE     ] );  break;
        case 0x4000:    printf( StringTable[ ERROR_SEEK_ERROR             ] );  break;
        case 0x8000:    printf( StringTable[ ERROR_DISK_TIMED_OUT         ] );  break;
    }

}

//----------------------------------------------------------------------------
//
// Function: AbsoluteDiskWrite
//
// Purpose:  To write a buffer in memory to a specific portion of a disk.
//
// Arguments:  unsigned int *iErrorCode - if an error occurs, the error code
//                   is returned in this OUT variable
//             unsigned int iDrive - drive to write the buffer to
//             unsigned int iStartingSector - sector where the write is to begin
//             unsigned int iNumberOfSectorsToWrite - the number of sectors
//                   to write
//
// Returns:  returns 1 on success, 0 on failure
//           If it fails, then the error code is returned in the argument
//           iErrorCode.
//           If it succeeds, iErrorCode is undefined.
//
//----------------------------------------------------------------------------
unsigned int
AbsoluteDiskWrite( unsigned int *iErrorCode,
                   unsigned int iDrive, 
                   unsigned int iStartingSector,
                   unsigned int iNumberOfSectorsToWrite,
                   void far *Buffer_to_be_written )
{
    //
    //  used to temporarily store the error code
    //
    unsigned int iTempErrorCode;

    unsigned int iRetVal;

    _asm
    {
        push    ds
        push    es
        push    bp

        mov     ax, WORD PTR [Buffer_to_be_written + 2]
        mov     ds, ax
        mov     bx, WORD PTR [Buffer_to_be_written]
        mov     dx, iStartingSector
        mov     cx, iNumberOfSectorsToWrite
        mov     al, BYTE PTR [iDrive]

        int     26h   // do the absolute disk write

        lahf
        popf
        sahf

        pop     bp
        pop     es
        pop     ds

        mov     iRetVal, 1   // assume success
        jnc     done         // see if an error occured
        mov     iRetVal, 0
        mov     iTempErrorCode, ax
done:
    }

    *iErrorCode = iTempErrorCode;

    return( iRetVal );

}

unsigned
DnGetCodepage(void)

/*++

Routine Description:

    Determine the currently active codepage.

Arguments:

    None.

Return Value:

    Currently active codepage. 0 if we can't determine it.

--*/

{

    unsigned int iRetVal;

    _asm {
        mov ax,06601h
        int 21h
        jnc ok
        xor bx,bx
    ok: mov iRetVal,bx
    }

    return( iRetVal );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\br\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP",
"Disco de inicializaao da instalaao do Windows XP",
"Disco de instalaao n2 do Windows XP",
"Disco de instalaao n3 do Windows XP",
"Disco de instalaao n4 do Windows XP",

"Nao  possvel encontrar o arquivo %s\n",
"Nao h espao na memria para concluir o pedido\n",
"%s nao  um formato de arquivo executvel\n",
"****************************************************",

"Este programa cria discos de inicializaao da instalaao",
"para Microsoft %s.",
"Para cri-los, voc precisa fornecer 6 discos em branco,",
"formatados, de alta densidade.",

"Insira um desses discos na unidade %c:.  Este disco",
"ser o disco %s.",

"Insira outro disco na unidade %c:.  Este disco",
"ser o disco %s.",

"Pressione qualquer tecla quando voc estiver pronto.",

"Os discos de inicializaao da instalaao foram criados com xito.",
"concludo",

"Erro desconhecido ao se tentar executar %s.",
"Especifique a unidade de disquete para onde copiar as imagens: ",
"Letra da unidade invlida\n",
"A unidade %c: nao  uma unidade de disquete\n",

"Deseja tentar criar este disquete novamente?",
"Pressione Enter para tentar novamente ou Esc para sair.",

"Erro: disco protegido contra gravaao\n",
"Erro: unidade de disco desconhecida\n",
"Erro: a unidade nao est pronta\n",
"Erro: comando desconhecido\n",
"Erro: erro de dados (CRC incorreto)\n",
"Erro: comprimento da estrutura do pedido incorreto\n",
"Erro: erro de busca\n",
"Erro: tipo de mdia nao encontrado\n",
"Erro: Setor nao encontrado\n",
"Erro: falha na gravaao\n",
"Erro: falha geral\n",
"Erro: pedido invlido ou comando incorreto\n",
"Erro: marca de endereo nao encontrada\n",
"Erro: falha na gravaao do disco\n",
"Erro: perda de acesso direto  memria (DMA)\n",
"Erro: erro na leitura de dados (CRC ou ECC)\n",
"Erro: falha do controlador\n",
"Erro: tempo limite do disco expirado ou falha para responder\n",

" Disco de instalaao n5 do Windows XP",
" Disco de instalaao n6 do Windows XP" 
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\makefile.inc ===
# Use specific 16-bit compiler/linker/masm
PATH=$(PATH_TOOLS16);$(PATH)

!IFNDEF DEBUG
DEBUG=0
!ENDIF

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IF $(DEBUG)
C_DBG_FLAGS= -Zi -Od -DDBG=1
LINK_DBG_FLAGS= /codeview
!ELSE
C_DBG_FLAGS=-DDBG=0
LINK_DBG_FLAGS=
!ENDIF

CC= cl16
CFCOMMON= -W3 -Zel -G2 -AC $(C_DBG_FLAGS)
CINC=-X -I.. -I..\..\..\..\textmode\winnt\c6\inc -I$(O) -I..\..\..\..\inc
CFLAGS= $(CFCOMMON) $(CFOPT)

{..}.c{$(O)}.obj:
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $<

{}.c{$(O)}.obj:
    $(CC) $(CFLAGS) $(CINC) -c /Fo$(@D)\ $<


LIBS = ..\..\..\..\textmode\winnt\c6\lib\clibce
OBJS = $(O)\makeboot.obj $(O)\strings.obj

$(O)\makeboot.exe: $(OBJS) makefile.inc $(PATH_TOOLS16)\$(CC).exe
    link @<<
$(OBJS) /NOI /STACK:0xE000 $(LINK_DBG_FLAGS)
$(O)\makeboot.exe
nul
$(LIBS)

<<
    -binplace -O $(ALT_PROJECT_TARGET) $@

$(O)\makeboot.obj: ..\makeboot.c       ..\makeboot.h
$(O)\strings.obj:  strings.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\gb\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\cs\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 852;

const char *EngStrings[] = {

"Windows XP",
"Spoutc instalan disketa systmu Windows XP",
"Instalan disketa . 2 systmu Windows XP",
"Instalan disketa . 3 systmu Windows XP",
"Instalan disketa . 4 systmu Windows XP",

"Nepodailo se nalzt soubor %s.\n",
"Pro dokonen poadavku nen dostatek pamti.\n",
"%s nen spustiteln soubor.\n",
"****************************************************",

"Tento program vytvo spoutc instalan diskety",
"pro systm Microsoft %s.",
"K vytvoen tchto disket budete potebovat sedm przdnch,",
"naformtovanch disket s vysokou hustotou zznamu.",

"Vlote jednu z disket do jednotky %c:. Pojmenujte disketu",
"%s.",

"Vlote dal disketu do jednotky %c:. Pojmenujte disketu",
"%s.",

"Pot stisknte libovolnou klvesu.",

"Spoutc instalan diskety byly spn vytvoeny.",
"Dokoneno",

"Pi pokusu spustit %s dolo k neznm chyb.",
"Zadejte clovou disketovou jednotku pro zkoprovn bitovch kopi: ",
"Psmeno jednotky je neplatn.\n",
"Jednotka %c: nen disketov jednotka.\n",

"Chcete se pokusit vytvoit disketu znovu?",
"Pokraujte stisknutm klvesy Enter, nebo klvesou Esc program ukonete.",

"Chyba: Disk je chrnn proti zpisu.\n",
"Chyba: Neznm diskov jednotka.\n",
"Chyba: Jednotka nen pipravena.\n",
"Chyba: Neznm pkaz.\n",
"Chyba: Chyba dat (chybn kontroln souet CRC).\n",
"Chyba: Chybn dlka dosti.\n",
"Chyba: Chyba vystaven.\n",
"Chyba: Typ mdia nebyl nalezen.\n",
"Chyba: Sektor nebyl nalezen.\n",
"Chyba: Chyba zpisu.\n",
"Chyba: Obecn chyba.\n",
"Chyba: Neplatn dost nebo chybn pkaz.\n",
"Chyba: Adresn znaka nebyla nalezena.\n",
"Chyba: Chyba zpisu na disk.\n",
"Chyba: Dolo k pebhu DMA (Direct Memory Access).\n",
"Chyba: Chyba ten dat (chybn CRC nebo ECC).\n",
"Chyba: Chyba adie.\n",
"Chyba: asov limit diskov operace vyprel nebo disk neodpovdl.\n",
"Instalan disketa . 5 systmu Windows XP",
"Instalan disketa . 6 systmu Windows XP",
"Instalan disketa . 7 systmu Windows XP"
};
const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\fr\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP",
"Disquette de dmarrage de l'installation de Windows XP",
"Disquette d'installation de Windows XP n2",
"Disquette d'installation de Windows XP n3",
"Disquette d'installation de Windows XP n4",

"Impossible de trouver le fichier %s\n",
"Mmoire libre insuffisante pour effectuer la requte\n",
"%s n'a pas un format de fichier excutable\n",
"****************************************************",

"Ce programme cre les disquettes de dmarrage d'installation",
"pour Microsoft %s.",
"Pour crer ces disquettes, vous devez fournir 7 disquettes",
"haute densit, vierges, formates.",

"Insrez l'une de ces disquettes dans le lecteur %c:. Cette disquette",
"deviendra la %s.",

"Insrez une autre disquette dans le lecteur %c:. Cette disquette",
"deviendra la %s.",

"Pressez une touche ds que vous tes prt.",

"Les disquettes de dmarrage d'installation ont t cres.",
"termin",

"Une erreur inconnue s'est produite lors de la tentative d'excuter %s.",
"Spcifiez le lecteur de disquettes vers lequel copier les images : ",
"Lettre de lecteur non valide\n",
"Le lecteur %c: n'est pas un lecteur de disquettes\n",

"Voulez-vous ressayer de crer cette disquette ?",
"Appuyez sur Entre pour ressayer ou sur Annuler pour quitter.",

"Erreur : disquette protge en criture\n",
"Erreur : unit de disquettes inconnue\n",
"Erreur : lecteur non prt\n",
"Erreur : commande inconnue\n",
"Erreur : erreur de donnes (CRC erron)\n",
"Erreur : longueur de structure de requte errone\n",
"Erreur : erreur de recherche\n",
"Erreur : type de mdia introuvable\n",
"Erreur : secteur introuvable\n",
"Erreur : erreur en criture\n",
"Erreur : dfaillance gnrale\n",
"Erreur : requte non valide ou commande errone\n",
"Erreur : marque d'adresse introuvable\n",
"Erreur : erreur en criture sur la disquette\n",
"Erreur : saturation DMA (Direct Memory Access)\n",
"Erreur : erreur de lecture de donnes (CRC ou ECC)\n",
"Erreur : dfaillance du contrleur\n",
"Erreur : le disque met trop de temps  rpondre ou ne rpond pas\n",

"Disquette d'installation de Windows XP n5",
"Disquette d'installation de Windows XP n6",
"Disquette d'installation de Windows XP n7"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\ger\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP",
"Windows XP Setup-Startdiskette",
"Windows XP Setup-Diskette 2",
"Windows XP Setup-Diskette 3",
"Windows XP Setup-Diskette 4",

"Datei wurde nicht gefunden: %s\n",
"Nicht gengend Arbeitsspeicher\n",
"%s ist keine ausfhrbare Datei.\n",
"****************************************************",

"Mit diesem Programm werden Setup-Startdisketten",
"fr Microsoft %s erstellt.",
"Sie bentigen 7 leere, formatierte HD-Disketten,",
"um die Disketten zu erstellen.",

"Legen Sie eine Diskette in das Laufwerk %c: ein.",
"Diese Diskette wird die %s.",

"Legen Sie eine andere Diskette in das Laufwerk %c: ein.",
"Diese Diskette wird die %s.",

"Drcken Sie eine beliebige Taste, um den Vorgang fortzusetzen.",

"Die Setup-Startdisketten wurden ordnungsgem erstellt.",
"abgeschlossen",

"Bei dem Versuch, %s auszufhren, ist ein unbekannter Fehler aufgetreten.",
"Geben Sie das Diskettenlaufwerk an, auf dem\ndie Startdisketten erstellt werden sollen: ",
"Ungltiger Laufwerkbuchstabe\n",
"Das angegebene Laufwerk %c ist kein Diskettenlaufwerk.\n",

"Mchten Sie nochmals versuchen, diese Diskette zu erstellen?",
"Drcken Sie die Eingabetaste, um den Vorgang zu wiederholen,\noder die ESC-Taste, um den Vorgang abzubrechen.",

"Fehler: Schreibgeschtzte Diskette\n",
"Fehler: Unbekanntes Laufwerk\n",
"Fehler: Laufwerk nicht bereit\n",
"Fehler: Unbekannter Befehl\n",
"Fehler: Datenfehler (Ungltiger CRC-Wert)\n",
"Fehler: Ungltige Lnge der Anfragestruktur\n",
"Fehler: Suchfehler\n",
"Fehler: Medientyp nicht gefunden\n",
"Fehler: Sektor nicht gefunden\n",
"Fehler: Schreibfehler\n",
"Fehler: Allgemeiner Fehler\n",
"Fehler: Ungltige Anforderung oder ungltiger Befehl\n",
"Fehler: Adressmarke nicht gefunden\n",
"Fehler: Diskettenschreibfehler\n",
"Fehler: DMA-berlauf\n",
"Fehler: Datenlesefehler (CRC- oder ECC-Wert)\n",
"Fehler: Controllerfehler\n",
"Fehler: Laufwerk nicht bereit, oder keine Antwort von Laufwerk\n"


"Windows XP Setup-Diskette 5",
"Windows XP Setup-Diskette 6",
"Windows XP Setup-Diskette 7"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\it\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP",
"Disco di avvio dell'installazione di Windows XP",
"Disco 2 - Installazione di Windows XP",
"Disco 3 - Installazione di Windows XP",
"Disco 4 - Installazione di Windows XP",

"Impossibile trovare file %s\n",
"Memoria insufficiente per completare la richiesta\n",
"%s: formato file non eseguibile\n",
"****************************************************",

"Questo programma crea dischi di installazione",
"per Microsoft %s.",
"Per creare questi dischi sono necessari 7 dischi floppy,",
"ad alta densit, formattati e vuoti.",

"Inserire un disco nell'unit %c:.  Questo disco",
"diverr il %s.",

"Inserire un altro disco nell'unit %c:.  Questo disco",
"diverr il %s.",

"Premere un tasto per continuare.",

"I dischi di avvio dell'installazione sono stati creati",
"completato",

"Errore sconosciuto durante l'esecuzione di %s.",
"Specificare l'unit floppy su cui copiare l'immagine: ",
"Lettera di unit non valida\n",
"L'unit %c: non  un'unit floppy\n",

"Creare di nuovo questo floppy?",
"Premere INVIO per riprovare o ESC per uscire.",

"Errore: disco protetto da scrittura\n",
"Errore: unit disco sconosciuta\n",
"Errore: unit non pronta\n",
"Errore: comando sconosciuto\n",
"Errore: errore di dati (CRC errato)\n",
"Errore: lunghezza struttura richiesta errata\n",
"Errore: errore ricerca\n",
"Errore: tipo supporto non trovato\n",
"Errore: settore non trovato\n",
"Errore: errore scrittura\n",
"Errore: errore generale\n",
"Errore: richiesta non valida o comando errato\n",
"Errore: segno indirizzo non trovato\n",
"Errore: errore scrittura disco\n",
"Errore: sovraccarico Direct Memory Access (DMA)\n",
"Errore: errore lettura dati (CRC o ECC)\n",
"Errore: errore controller\n",
"Errore: timeout o mancata risposta del disco\n",

"Disco 5 - Installazione di Windows XP",
"Disco 6 - Installazione di Windows XP",
"Disco 7 - Installazione di Windows XP"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\es\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP",
"Disco de inicio de instalacin de Windows XP",
"Disco de instalacin #2 de Windows XP",
"Disco de instalacin #3 de Windows XP",
"Disco de instalacin #4 de Windows XP",

"No se encuentra el archivo %s\n",
"Memoria insuficiente para satisfacer la solicitud\n",
"%s no est en un formato de archivo ejecutable\n",
"****************************************************",

"Este programa crea los discos de inicio de la instalacin",
"para Microsoft %s.",
"Para crearlos, necesita tener 7 discos",
"de alta densidad formateados.",

"Inserte uno de los discos en la unidad %c:.  Este disco",
"se convertir en el %s.",

"Inserte otro disco en la unidad %c:.  Este disco se",
"convertir en el %s.",

"Presione cualquier tecla cuando est listo.",

"Los discos de inicio de la instalacin se han creado correctamente.",
"completo",

"Error al intentar ejecutar %s.",
"Especifique la unidad de disquete donde copiar las imgenes: ",
"Letra de unidad no vlida\n",
"La unidad %c: no es una unidad de disquete\n",

"Desea volver a intentar crear este disco?",
"Presione Entrar para volver a intentarlo o Esc para salir.",

"Error: Disco protegido contra escritura\n",
"Error: Unidad de disco desconocida\n",
"Error: Unidad no preparada\n",
"Error: Comando desconocido\n",
"Error: Error de datos (CRC errneo)\n",
"Error: Longitud de estructura de solicitud errnea\n",
"Error: Error de bsqueda\n",
"Error: No se encuentra el tipo de medio\n",
"Error: No se encuentra el sector\n",
"Error: Error de escritura\n",
"Error: Error general\n",
"Error: Solicitud no vlida o comando errneo\n",
"Error: No se encuentra la marca de direccin\n",
"Error: Error de escritura en el disco\n",
"Error: Desbordamiento de Direct Memory Access (DMA)\n",
"Error: Error de lectura de datos (CRC o ECC)\n",
"Error: Error de la controladora\n",
"Error: Tiempo de espera de disco agotado o no hay respuesta\n",

"Disco 5 de instalacin de Windows XP"
"Disco 6 de isntalacin de Windows XP"
"Disco 7 de isntalacin de Windows XP"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\nl\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP",
"Windows XP Setup-opstartdiskette",
"Windows XP Setup-diskette 2",
"Windows XP Setup-diskette 3",
"Windows XP Setup-diskette 4",

"Kan het bestand %s niet vinden\n",
"Onvoldoende geheugen om de aanvraag te voltooien\n",
"%s heeft geen indeling als uitvoerbaar bestand\n",
"****************************************************",

"Dit programma maakt de Setup-diskettes",
"voor Microsoft %s.",
"U hebt 7 lege, geformatteerde diskettes met een hoge",
"dichtheid nodig om de Setup-diskettes te kunnen maken.",

"Plaats een van de diskettes in station %c:.",
"Deze diskette wordt: %s.",

"Plaats een andere diskette in station %c:.",
"Deze diskette wordt: %s.",

"Druk op een toets als u de diskette nu wilt maken.",

"De Setup-diskettes zijn gemaakt.",
"voltooid",

"Er is een onbekende fout opgetreden tijdens het\nuitvoeren van %s.",
"Geef op naar welke diskette de installatiekopie\nmoet worden gekopieerd: ",
"Ongeldige stationsletter\n",
"Station %c: is geen diskettestation\n",

"Wilt u opnieuw proberen deze diskette te maken?",
"Druk op Enter als u het opnieuw wilt proberen of\nop Esc als u dit niet wilt.",

"Fout: de diskette is tegen schrijven beveiligd\n",
"Fout: onbekende indelingseenheid op de diskette\n",
"Fout: het station is niet gereed\n",
"Fout: onbekende opdracht\n",
"Fout: gegevensfout (ongeldige CRC)\n",
"Fout: ongeldige structuurlengte van de aanvraag\n",
"Fout: zoekfout\n",
"Fout: mediumtype niet gevonden\n",
"Fout: sector niet gevonden\n",
"Fout: schrijffout\n",
"Fout: algemene fout\n",
"Fout: ongeldige aanvraag of opdracht\n",
"Fout: kan adresmarkering niet vinden\n",
"Fout: fout bij het schrijven\n",
"Fout: DMA-overloop (Direct Memory Access)\n",
"Fout: fout bij het lezen van gegevens (CRC of ECC)\n",
"Fout: storing bij de controller\n",
"Fout: time-out van de diskette of kan niet reageren\n",

"Windows XP Setup-diskette 5"
"Windows XP Setup-diskette 6"
"Windows XP Setup-diskette 7"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\hu\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 852;

const char *EngStrings[] = {

"Windows XP",
"Windows XP teleptsi indtlemez",
"Windows XP - 2. sz. teleptlemez",
"Windows XP - 3. sz. teleptlemez",
"Windows XP - 4. sz. teleptlemez",

"Nem tallhat a kvetkez fjl: %s\n",
"Nincs elg memria a krelem befejezshez\n",
"%s nem vgrehajthat formtum\n",
"****************************************************",

"Ez a program hozza ltre a teleptsi indtlemezeket a",
"kvetkezhz: Microsoft %s.",
"A lemezek ltrehozshoz ht res, formzott, nagykapacits",
"lemezre lesz szksg.",

"Helyezze be a lemezek egyikt a kvetkez meghajtba: %c:. Ez a",
"lemez lesz a %s.",

"Helyezzen be egy msik lemezt a kvetkez meghajtba: %c:. Ez a",
"lemez lesz a %s.",

"Ha elkszlt, nyomjon le egy billentyt.",

"A teleptsi indtlemezek ltrehozsa sikeren megtrtnt.",
"ksz",

"Ismeretlen hiba trtnt %s vgrehajtsa kzben.",
"Adja meg, mely hajlkonylemezre szeretn msolni a programkdot: ",
"rvnytelen meghajtbetjel\n",
"%c: meghajt nem hajlkonylemezmeghajt\n",

"Megprblja jra ltrehozni a hajlkonylemezt?",
"Az jraprblkozshoz nyomja le az Enter, a kilpshez az Esc billentyt.",

"Hiba: A lemez rsvdett\n",
"Hiba: Ismeretlen lemezegysg\n",
"Hiba: A meghajt nem ll kszen\n",
"Hiba: Ismeretlen parancs\n",
"Hiba: Adathiba (rossz CRC)\n",
"Hiba: Rossz a krelemstruktra hossza\n",
"Hiba: Pozicionlsi hiba\n",
"Hiba: A mdiatpus nem tallhat\n",
"Hiba: A szektor nem tallhat\n",
"Hiba: rsi hiba\n",
"Hiba: ltalnos hiba\n",
"Hiba: rvnytelen krelem, vagy rossz hiba\n",
"Hiba: A cmjel nem tallhat\n",
"Hiba: Lemezrsi hiba\n",
"Hiba: Kzvetlen memriahozzfrs (DMA) tlfutsa\n",
"Hiba: Adathiba (CRC vagy ECC)\n",
"Hiba: Vezrlhiba\n",
"Hiba: A lemez ideje lejrt, vagy nem vlaszolt\n",

"Windows XP - 5. sz. teleptlemez",
"Windows XP - 6. sz. teleptlemez",
"Windows XP - 7. sz. teleptlemez"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\pl\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 852;

const char *EngStrings[] = {

"Windows XP",
"Dysk rozruchowy Instalatora systemu Windows XP",
"Windows XP - dysk instalacyjny nr 2",
"Windows XP - dysk instalacyjny nr 3",
"Windows XP - dysk instalacyjny nr 4",

"Nie mona znale pliku %s\n",
"Za mao wolnej pamici do wykonania dania\n",
"%s nie ma formatu pliku wykonywalnego\n",
"****************************************************",

"Ten program tworzy dyskietki rozruchowe Instalatora",
"dla systemu Microsoft %s.",
"Aby utworzy te dyskietki, potrzebnych jest 6 pustych,",
"sformatowanych dyskietek duej gstoci.",

"W jedn z tych dyskietek do stacji dyskw %c:. Bdzie to",
"%s.",

"W kolejn dyskietk do stacji dyskw %c:. Bdzie to",
"%s.",

"Nacinij dowolny klawisz, gdy zechcesz kontynuowa.",

"Dyskietki rozruchowe Instalatora zostay utworzone pomylnie.",
"zakoczono",

"Podczas prby wykonania %s wystpi nieznany bd.",
"Okrel stacj dyskietek, do ktrej maj by skopiowane obrazy: ",
"Nieprawidowa litera stacji dyskw\n",
"Stacja dyskw %c: nie jest stacj dyskietek\n",

"Czy chcesz ponownie sprbowa utworzy t dyskietk?",
"Nacinij klawisz Enter, aby ponowi prb, lub klawisz Esc, aby zakoczy.",

"Bd: dysk jest zabezpieczony przed zapisem\n",
"Bd: nieznana jednostka dyskowa\n",
"Bd: stacja dyskw nie jest gotowa\n",
"Bd: nieznane polecenie\n",
"Bd: bd danych (za suma kontrolna CRC)\n",
"Bd: za dugo struktury dania\n",
"Bd: bd wyszukiwania\n",
"Bd: nie znaleziono typu nonika\n",
"Bd: nie znaleziono sektora\n",
"Bd: niepowodzenie zapisu\n",
"Bd: bd oglny\n",
"Bd: nieprawidowe danie lub ze polecenie\n",
"Bd: nie znaleziono znacznika adresu\n",
"Bd: niepowodzenie zapisu na dysku\n",
"Bd: przepenienie podczas bezporedniego dostpu do pamici (DMA)\n",
"Bd: bd odczytu danych (suma kontrolna CRC lub ECC)\n",
"Bd: bd kontrolera\n",
"Bd: upyn limit czasu dysku lub dysk nie odpowiada\n",

"Windows XP - dysk instalacyjny nr 5",
"Windows XP - dysk instalacyjny nr 6",
"Windows XP - dysk instalacyjny nr 7"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\_br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\jpn\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 932;

const char *EngStrings[] = {

"Windows XP",
"Windows XP Setup Boot Disk",
"Windows XP Setup Disk #2",
"Windows XP Setup Disk #3",
"Windows XP Setup Disk #4",

"Cannot find file %s\n",
"Not enough free memory to complete request\n",
"%s is not in an executable file format\n",
"****************************************************",

"This program creates the Setup boot disks",
"for Microsoft %s.",
"To create these disks, you need to provide 7 blank,",
"formatted, high-density disks.",

"Insert one of these disks into drive %c:.  This disk",
"will become the %s.",

"Insert another disk into drive %c:.  This disk will",
"become the %s.",

"Press any key when you are ready.",

"The setup boot disks have been created successfully.",
"complete",

"An unknown error has occurred trying to execute %s.",
"Please specify the floppy drive to copy the images to: ",
"Invalid drive letter\n",
"Drive %c: is not a floppy drive\n",

"Do you want to attempt to create this floppy again?",
"Press Enter to try again or Esc to exit.",

"Error: Disk write protected\n",
"Error: Unknown disk unit\n",
"Error: Drive not ready\n",
"Error: Unknown command\n",
"Error: Data error (Bad CRC)\n",
"Error: Bad request structure length\n",
"Error: Seek error\n",
"Error: Media type not found\n",
"Error: Sector not found\n",
"Error: Write fault\n",
"Error: General failure\n",
"Error: Invalid request or bad command\n",
"Error: Address mark not found\n",
"Error: Disk write fault\n",
"Error: Direct Memory Access (DMA) overrun\n",
"Error: Data read (CRC or ECC) error\n",
"Error: Controller failure\n",
"Error: Disk timed out or failed to respond\n",

"Windows XP Setup Disk #5",
"Windows XP Setup Disk #6",
"Windows XP Setup Disk #7"
};

const char *LocStrings[] = {
"Windows XP",
"Windows XP Setup Boot Disk",
"Windows XP Setup Disk #2",
"Windows XP Setup Disk #3",
"Windows XP Setup Disk #4",

"t@C %s ܂\n",
"ŝߗvł܂\n",
"%s ͎st@C`ł͂܂\n",
"****************************************************",

"̃vO̓ZbgAbv u[g fBXN",
"Microsoft %s pɍ쐬܂B",
"̃fBXN쐬ɂ́AtH[}bgς݂",
"̍x (HD) ̃fBXN 7 KvłB",

"̃fBXN 1 hCu %c: ɑ}ĂB",                              
"̃fBXN %s ɂȂ܂B",

"ʂ̃fBXNhCu %c: ɑ}ĂB",
"̃fBXN %s ɂȂ܂B",

"łL[ĂB",

"ZbgAbv u[g fBXN͐ɍ쐬܂B",
"",

"%s sɕsȃG[܂B",
"Rs[̃tbs[ hCuw肵Ă: ",
"hCuł\n",
"hCu %c: ̓tbs[ hCuł͂܂\n",

"̃tbs[ēx쐬Ă݂܂?",
"Ďs = [Enter]  I = [ESC]",

"G[: fBXN݋֎~ł\n",
"G[: fBXN jbgsł\n",
"G[: hCȕłĂ܂\n",
"G[: R}hsł\n",
"G[: f[^ G[ł (CRC ܂)\n",
"G[: v\\̂̒܂\n",
"G[: V[N G[ł\n",
"G[: fBA̎ނ܂\n",
"G[: ZN^܂\n",
"G[: ݃tHgł\n",
"G[: ʃG[ł\n",
"G[: vA܂̓R}h܂\n",
"G[: AhX }[N܂\n",
"G[: fBXN݃tHg\n",
"G[: DMA (Direct Memory Access) ߂Ă܂\n",
"G[: f[^ǂݎ (CRC ܂ ECC) G[\n",
"G[: Rg[̃G[ł\n",
"G[: fBXN^CAEgɂȂAł܂ł\n",

"Windows XP Setup Disk #5",
"Windows XP Setup Disk #6",
"Windows XP Setup Disk #7"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\_cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\sv\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP",
"Startdiskett fr installationsprogrammet fr Windows XP",
"Installationsdiskett nr 2 fr Windows XP",
"Installationsdiskett nr 3 fr Windows XP",
"Installationsdiskett nr 4 fr Windows XP",

"Fljande fil kan inte hittas: %s\n",
"Det saknas ledigt minne fr att utfra tgrden\n",
"%s r inte en krbar fil\n",
"****************************************************",

"Det hr programmet skapar startdisketter fr",
"installationsprogrammet fr Microsoft %s.",
"Om du vill skapa de hr disketterna behver du 7 tomma,",
"formaterade hgdensitetsdisketter.",

"Stt in en av disketterna i enhet %c:. Den hr disketten",
"kommer att bli %s.",

"Stt in en annan diskett i enhet %c:. Den hr disketten",
"kommer att bli %s.",

"Tryck ned valfri tangent nr du r redo.",

"Startdisketterna har nu skapats.",
"frdig",

"Ett oknt fel uppstod nr %s skulle kras.",
"Ange vilken enhet som avbildningen ska kopieras till: ",
"Felaktig enhetsbeteckning\n",
"Enhet %c: r inte en diskettenhet\n",

"Vill du frska skapa disketten igen?",
"Tryck ned Retur om du vill frska igen eller Esc om du vill avsluta.",

"Fel: Disketten r skrivskyddad\n",
"Fel: Oknd diskenhet\n",
"Fel: Enheten r inte redo\n",
"Fel: Oknt kommando\n",
"Fel: Data fel (felaktig CRC)\n",
"Fel: Begrandestrukturen har felaktig lngd\n",
"Fel: Skningsfel\n",
"Fel: Medietypen kan inte hittas\n",
"Fel: En sektor kan inte hittas\n",
"Fel: Skrivfel\n",
"Fel: Allmnt fel\n",
"Fel: Ogiltig begran eller felaktigt kommando\n",
"Fel: Adressmrke hittades inte\n",
"Fel: Diskskrivningsfel\n",
"Fel: DMA-verskridning (Direct Memory Access)\n",
"Fel: Datalsningsfel (CRC eller ECC)\n",
"Fel: Styrenhetsfel\n",
"Fel: Disken orsakade timeout eller svarade inte\n",

"Installationsdiskett nr 5 fr Windows XP",
"Installationsdiskett nr 6 fr Windows XP",
"Installationsdiskett nr 7 fr Windows XP"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\pt\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 850;

const char *EngStrings[] = {

"Windows XP",
"Disquete de arranque da configuraao do Windows XP",
"Disquete de arranque da configuraao do Windows XP n. 2",
"Disquete de arranque da configuraao do Windows XP n. 3",
"Disquete de arranque da configuraao do Windows XP n. 4",

"Nao  possvel encontrar o ficheiro %s\n",
"Ano existe memria livre disponvel para concluir o pedido\n",
"%s nao est num formato de ficheiro executvel\n",
"****************************************************",

"Este programa cria as disquetes de arranque da configuraao",
"para o Microsoft %s.",
"Para criar estas disquetes, necessita de fornecer sete",
"disquetes de alta densidade limpas e formatadas.",

"Insira uma dessas disquetes na unidade %c:. Esta disquete",
"ser a %s.",

"Insira outra disquete na unidade %c:. Esta disquete",
"ser a %s.",

"Prima uma tecla quando estiver preparado.",

"As disquetes de arranque da configuraao foram criadas com xito.",
"concludo",

"Ocorreu um erro desconhecido ao tentar executar %s.",
"Especifique a unidade de disquetes para copiar as imagens: ",
"Letra de unidade invlida\n",
"A unidade %c: nao  uma unidade de disquetes\n",

"Deseja tentar novamente a criaao desta disquete?",
"Prima Enter para tentar novamente ou Esc para sair.",

"Erro: A disquete est protegida contra a escrita\n",
"Erro: Unidade de disquete desconhecida\n",
"Erro: A unidade nao est  pronta\n",
"Erro: Comando desconhecido\n",
"Erro: Erro de dados (CRC invlido)\n",
"Erro: O comprimento da estrutura do pedido  invlido\n",
"Erro: Erro de procura\n",
"Erro: Nao foi encontrado o tipo de suporte de dados\n",
"Erro: Nao foi encontrado o sector\n",
"Erro: Falha na escrita\n",
"Erro: Falha geral\n",
"Erro: Pedido ou comando invlido\n",
"Erro: Nao foi encontrada a marca de endereo\n",
"Erro: Falha na escrita de disco\n",
"Erro: Transbordo na 'Memria de acesso directo' (DMA)\n",
"Erro: Erro na leitura de dados (CRC ou ECC)\n",
"Erro: Falha do controlador\n",
"Erro: A disquete ultrapassou o tempo limite ou nao respondeu\n",

"Disquete de arranque da configuraao do Windows XP n. 5",
"Disquete de arranque da configuraao do Windows XP n. 6",
"Disquete de arranque da configuraao do Windows XP n. 7"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\usa\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 437;

const char *EngStrings[] = {

"Windows XP",
"Windows XP Setup Boot Disk",
"Windows XP Setup Disk #2",
"Windows XP Setup Disk #3",
"Windows XP Setup Disk #4",

"Cannot find file %s\n",
"Not enough free memory to complete request\n",
"%s is not in an executable file format\n",
"****************************************************",

"This program creates the Setup boot disks",
"for Microsoft %s.",
"To create these disks, you need to provide 7 blank,",
"formatted, high-density disks.",

"Insert one of these disks into drive %c:.  This disk",
"will become the %s.",

"Insert another disk into drive %c:.  This disk will",
"become the %s.",

"Press any key when you are ready.",

"The setup boot disks have been created successfully.",
"complete",

"An unknown error has occurred trying to execute %s.",
"Please specify the floppy drive to copy the images to: ",
"Invalid drive letter\n",
"Drive %c: is not a floppy drive\n",

"Do you want to attempt to create this floppy again?",
"Press Enter to try again or Esc to exit.",

"Error: Disk write protected\n",
"Error: Unknown disk unit\n",
"Error: Drive not ready\n",
"Error: Unknown command\n",
"Error: Data error (Bad CRC)\n",
"Error: Bad request structure length\n",
"Error: Seek error\n",
"Error: Media type not found\n",
"Error: Sector not found\n",
"Error: Write fault\n",
"Error: General failure\n",
"Error: Invalid request or bad command\n",
"Error: Address mark not found\n",
"Error: Disk write fault\n",
"Error: Direct Memory Access (DMA) overrun\n",
"Error: Data read (CRC or ECC) error\n",
"Error: Controller failure\n",
"Error: Disk timed out or failed to respond\n",

"Windows XP Setup Disk #5",
"Windows XP Setup Disk #6",
"Windows XP Setup Disk #7"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\tr\strings.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      strings.c
//
// Description:
//      Contains all of the strings constants for DOS based MAKEBOOT program.
//
//      To localize this file for a new language do the following:
//           - change the unsigned int CODEPAGE variable to the code page
//             of the language you are translating to
//           - translate the strings in the EngStrings array into the
//             LocStrings array.  Be very careful that the 1st string in the
//             EngStrings array corresponds to the 1st string in the LocStrings
//             array, the 2nd corresponds to the 2nd, etc...
//
//----------------------------------------------------------------------------

//
//  NOTE: To add more strings to this file, you need to:
//          - add the new #define descriptive constant to the makeboot.h file
//          - add the new string to the English language array and then make
//            sure localizers add the string to the Localized arrays
//          - the #define constant must match the string's index in the array
//

#include <stdlib.h>

unsigned int CODEPAGE = 857;

const char *EngStrings[] = {

"Windows XP",
"Windows XP Kurulum nykleme Disketi",
"Windows XP Kurulum Disketi #2",
"Windows XP Kurulum Disketi #3",
"Windows XP Kurulum Disketi #4",

"%s dosyas bulunamyor\n",
"stei tamamlamak iin yeterli bellek yok\n",
"%s altrlabilir dosya biiminde deil\n",
"****************************************************",

"Bu program, unun iin Kurulum nykleme disketleri oluturur:",
"Microsoft %s.",
"Bu disketleri oluturmak iin biimlendirilmi, yksek younlukta",
"7 bo disket gerekir.",

"Bu disketlerden birini %c: srcsne yerletirin.  Bu",
"disket %s olur.",

"%c: srcsne baka bir disket yerletirin.  Bu",
"disket %s olur.",

"Hazr olduunuzda bir tua basn.",

"Kur nykleme disketleri baaryla oluturuldu.",
"tamamland",

"%s altrlmas denenirken bilinmeyen bir hata olutu.",
"Yansmalarn kopyalanaca disket srcsn belirtin: ",
"Geersiz src harfi\n",
"%c: bir disket srcs deildir\n",

"Bu disketi yeniden oluturmay denemek istiyor musunuz?",
"Yeniden denemek iin Enter'e, kmak iin Esc'ye basn.",

"Hata: Disket yazma korumal\n",
"Hata: Bilinmeyen disket birimi\n",
"Hata: Src hazr deil\n",
"Hata: Bilinmeyen komut\n",
"Hata: Veri hatas (Hatal CRC)\n",
"Hata: Hatal istek yaps uzunluu\n",
"Hata: Arama hatas\n",
"Hata: Ortam tr bulunamad\n",
"Hata: Kesim bulunamad\n",
"Hata: Yazma hatas\n",
"Hata: Genel hata\n",
"Hata: Geersiz istek ya da hatal komut\n",
"Hata: Adres iareti bulunamad\n",
"Hata: Disk yazma hatas\n",
"Hata: Dorudan Bellek Eriimi (DMA) tamas\n",
"Hata: Veri okuma (CRC ya da ECC) hatas\n",
"Hata: Denetleyici hatas\n",
"Hata: Disk zaman amna urad ya da yantlayamad\n",

"Windows XP Kurulum Disketi #5",
"Windows XP Kurulum Disketi #6"
"Windows XP Kurulum Disketi #7"
};

const char *LocStrings[] = {"\0"};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\32bit\resource.h ===
//---------------------------------------------------------------------------
//
// File: resource.h
//
// Description:
//      This file contatins all of the string constant IDs that go with
//      makebt32.rc
//
//---------------------------------------------------------------------------

#define IDS_OUT_OF_MEMORY                     101
#define IDS_144_NOT_SUPPORTED                 105
#define IDS_NO_ROOT_DIR                       107
#define IDS_DRIVE_NOT_FL0PPY                  108
#define IDS_CANNOT_FIND_FILE                  109
#define IDS_NT_VERSION_NAME_DEFAULT           110
#define IDS_DISK_LABEL_1_DEFAULT              111
#define IDS_DISK_LABEL_2_DEFAULT              112
#define IDS_DISK_LABEL_3_DEFAULT              113
#define IDS_DISK_LABEL_4_DEFAULT              114
#define IDS_STARS                             115
#define IDS_PROGRAM_EXPLANATION_LINE_1        116
#define IDS_PROGRAM_EXPLANATION_LINE_2        117
#define IDS_PROGRAM_EXPLANATION_LINE_3        118
#define IDS_PROGRAM_EXPLANATION_LINE_4        119

#define IDS_INSERT_FIRST_DISK_LINE_1          120
#define IDS_INSERT_FIRST_DISK_LINE_2          122

#define IDS_INSERT_ANOTHER_DISK_LINE_1        123
#define IDS_INSERT_ANOTHER_DISK_LINE_2        125

#define IDS_PRESS_ANY_KEY_WHEN_READY          126

#define IDS_COMPLETED_SUCCESSFULLY            127
#define IDS_COMPLETE                          128

#define IDS_SPECIFY_FLOPPY_DRIVE              129
#define IDS_INVALID_DRIVE_LETTER              130

#define IDS_ATTEMPT_TO_CREATE_FLOPPY_AGAIN    131
#define IDS_PRESS_ENTER_OR_ESC                132
#define IDS_DISK_LABEL_5_DEFAULT              133
#define IDS_DISK_LABEL_6_DEFAULT              134
#define IDS_DISK_LABEL_7_DEFAULT              135
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\32bit\makebt32.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      makebt32.c
//
// Description:
//      This program copies the images of the 4 Windows NT setup disks to
//      floppy disk so the user can boot their system with them.
//
//      All characters and strings are wide (UNICODE).  This file needs to be
//      compiled with UNICODE and _UNICODE defined.
//
// Assumptions:
//      This program will only run on NT 3.51 or later.  This is a result of
//      the CreateFile function call.  It is not available on DOS, Windows 3.1
//      or Windows 9x.
//
//      The floppy disk images are in the current dir and named CDBOOT1.IMG,
//      CDBOOT2.IMG, CDBOOT3.IMG and CDBOOT4.IMG.
//
//      Please note that there are a lot of places where I call exit() without
//      freeing memory for strings I have allocated.  This version of the
//      program only runs on NT so when the process exits it frees all its
//      memory so it is not a concern that I may not call free() on some memory.
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <setupapi.h>
#include <winioctl.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"

//
//  Constants
//
#define MAKEBOOT_MAX_STRING_LEN  1024
#define BYTES_PER_SECTOR         512
#define SECTORS_PER_TRACK        18
#define TRACK_SIZE               SECTORS_PER_TRACK * BYTES_PER_SECTOR
#define TRACKS_ON_DISK           80 * 2  // * 2 because it is double-sided

#define MAX_DISK_LABEL_LENGTH    256
#define MAX_INILINE_LENGTH       1023

#define ENTER_KEY                13
#define ESC_KEY                  27

#define NT_IMAGE_1_NAME               L"CDBOOT1.IMG"
#define NT_IMAGE_2_NAME               L"CDBOOT2.IMG"
#define NT_IMAGE_3_NAME               L"CDBOOT3.IMG"
#define NT_IMAGE_4_NAME               L"CDBOOT4.IMG"
#define NT_IMAGE_5_NAME               L"CDBOOT5.IMG"
#define NT_IMAGE_6_NAME               L"CDBOOT6.IMG"
#define NT_IMAGE_7_NAME               L"CDBOOT7.IMG"

#define NUMBER_OF_ASCII_WHEEL_SYMBOLS  4

const WCHAR rgAsciiWheel[NUMBER_OF_ASCII_WHEEL_SYMBOLS] = { '|', '/', '-', '\\' };

//
//  Function prototypes
//
BOOL   WriteImageToFloppy( WCHAR *szFileName, WCHAR *DrivePath );
VOID   PrintErrorMessage( VOID );
VOID   PrintErrorWrongDriveType( UINT iDriveType );
BOOL   IsDriveLargeEnough( WCHAR *DrivePath );
VOID   FreeStrings( VOID );
VOID   LoadStrings( VOID );
INT    DoImageFilesExist( VOID ) ;
VOID   CleanUp( HANDLE *hFloppyDrive, HANDLE *hFloppyImage );
BOOL   DoesUserWantToTryCopyAgain( VOID );
LPWSTR MyLoadString( UINT StringId );
VOID   print( WCHAR *szFirstString, ... );
BOOL   DoesFileExist( LPWSTR lpFileName );
VOID   PressAnyKeyToContinue( VOID );
void SetFarEastThread();
void ConsolePrint( WCHAR *szFirstString, ... );
//
//  Global Strings
//
WCHAR *StrOutOfMemory    = NULL;
WCHAR *StrComplete       = NULL;
WCHAR *StrNtVersionName  = NULL;
WCHAR *StrCanNotFindFile = NULL;
WCHAR *StrDiskLabel1     = NULL;
WCHAR *StrDiskLabel2     = NULL;
WCHAR *StrDiskLabel3     = NULL;
WCHAR *StrDiskLabel4     = NULL;
WCHAR *StrDiskLabel5     = NULL;
WCHAR *StrDiskLabel6     = NULL;
WCHAR *StrDiskLabel7     = NULL;

WCHAR *StrStars                         = NULL;
WCHAR *StrExplanationLine1              = NULL;
WCHAR *StrExplanationLine2              = NULL;
WCHAR *StrExplanationLine3              = NULL;
WCHAR *StrExplanationLine4              = NULL;
WCHAR *StrInsertFirstDiskLine1          = NULL;
WCHAR *StrInsertFirstDiskLine2          = NULL;
WCHAR *StrInsertAnotherDiskLine1        = NULL;
WCHAR *StrInsertAnotherDiskLine2        = NULL;
WCHAR *StrPressAnyKeyWhenReady          = NULL;
WCHAR *StrCompletedSuccessfully         = NULL;

//----------------------------------------------------------------------------
//
// Function: wmain
//
// Purpose: Instructs user to insert floppy disks to be copied and performs
//          the copy.
//
// Arguments: int argc - standard program argument, count of the command line args
//            char *argv[] - standard program argument, the 2nd argument is the
//                           floppy drive to copy the images to.
//
// Returns: INT - zero on successful program completion
//              - non-zero on unsuccessful program completion, program
//                terminated because of an error
//
//----------------------------------------------------------------------------
INT __cdecl
wmain( INT argc, WCHAR *argv[] )
{

    WCHAR *szOsName;
    WCHAR DriveLetter;
    WCHAR Drive[10];
    WCHAR DrivePath[10];
    UINT  iDriveType;
    BOOL  bTryAgain;

    szOsName = _wgetenv( L"OS" );

    //
    //  Make sure we are on NT.
    //
    if( ( szOsName == NULL ) || ( _wcsicmp( szOsName, L"Windows_NT" ) != 0 ) )
    {

        //  ******
        //  This string cannot be localized because if we are not on NT then
        //  we don't have wide chars.
        //
        printf( "This program only runs on Windows NT, Windows 2000 and Windows XP.\n" );

        exit( 1 );

    }

    SetFarEastThread();

    //
    //  Load all of the strings from the resource file
    //
    LoadStrings();

    //
    //  Don't allow the system to do any pop-ups.  We will handle all
    //  error messages
    //
    SetErrorMode( SEM_FAILCRITICALERRORS );

    print( L"" );

    print( StrStars );

    print( StrExplanationLine1 );

    print( StrExplanationLine2, StrNtVersionName );

    print( StrExplanationLine3 );
    print( StrExplanationLine4 );

    print( L"" );

    //
    //  If they didn't specified the floppy drive on the command line then
    //  prompt them for it.
    //
    if( argc == 1 )
    {

        WCHAR *StrSpecifyFloppyDrive = MyLoadString( IDS_SPECIFY_FLOPPY_DRIVE );

        ConsolePrint( L"%s", StrSpecifyFloppyDrive );

        DriveLetter = (WCHAR)_getche();

        ConsolePrint( L"\n\n" );

        free( StrSpecifyFloppyDrive );

    }
    else
    {

        DriveLetter = argv[1][0];

    }

    //
    //  Make sure the character they entered is a possible drive letter
    //
    if( ! isalpha( DriveLetter ) )
    {

        WCHAR *StrInvalidDriveLetter = MyLoadString( IDS_INVALID_DRIVE_LETTER );

        ConsolePrint( L"%s\n", StrInvalidDriveLetter );

        free( StrInvalidDriveLetter );

        exit( 1 );

    }

    //
    //  Make sure all the image files are in the current directory.
    //
    if( ! DoImageFilesExist() )
    {

        exit( 1 );

    }

    //
    //  Make the char DriveLetter into a string
    //
    Drive[0] = DriveLetter;
    Drive[1] = L'\0';

    //
    //  Build the drive path. For example the a: drive looks like \\.\a:
    //
    swprintf( DrivePath, L"\\\\.\\%c:", DriveLetter );

    //
    //  Make sure the drive is a floppy drive
    //
    iDriveType = GetDriveType( wcscat( Drive, L":\\" ) );

    if( iDriveType != DRIVE_REMOVABLE )
    {

        PrintErrorWrongDriveType( iDriveType );

        exit( 1 );

    }

    //
    //  Make sure the drive can hold at least 1.44 MB
    //
    if( ! IsDriveLargeEnough( DrivePath ) )
    {

        WCHAR *Str144NotSupported = MyLoadString( IDS_144_NOT_SUPPORTED );

        ConsolePrint( L"%s\n", Str144NotSupported );

        free( Str144NotSupported );

        exit( 1 );

    }

    print( StrInsertFirstDiskLine1, DriveLetter   );
    print( StrInsertFirstDiskLine2, StrDiskLabel1 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_1_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel2 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_2_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel3 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_3_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel4 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_4_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel5 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_5_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel6 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_6_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrInsertAnotherDiskLine1, DriveLetter   );
    print( StrInsertAnotherDiskLine2, StrDiskLabel7 );

    PressAnyKeyToContinue();

    while( ! WriteImageToFloppy( NT_IMAGE_7_NAME, DrivePath ) )
    {

        bTryAgain = DoesUserWantToTryCopyAgain();

        if( ! bTryAgain )
        {
            exit( 1 );
        }

    }

    print( L"" );

    print( StrCompletedSuccessfully );

    print( StrStars );

    FreeStrings();

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: WriteImageToFloppy
//
// Purpose:  Writes an image file to a floppy disk.  Handles all error
//           reporting to the user.
//
// Arguments: char *szFileName - filename to write to the floppy
//            char *DrivePath - drive path of the floppy to write to, it is of
//    the form \\.\x where x is the drive letter
//
// Returns: BOOL - TRUE  if image written to floppy properly
//                 FALSE if there were errors
//
//----------------------------------------------------------------------------
BOOL
WriteImageToFloppy( WCHAR *szFileName, WCHAR *DrivePath )
{

    INT    iCurrentTrack;
    INT    cBytesRead       = 0;
    INT    cBytesWritten    = 0;
    INT    iPercentComplete = 0;
    INT    iWheelPosition   = 0;
    HANDLE hFloppyImage     = NULL;
    HANDLE hFloppyDrive     = NULL;
    char   TrackBuffer[TRACK_SIZE];

    hFloppyImage = CreateFile( szFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL );

    if( hFloppyImage == INVALID_HANDLE_VALUE )
    {

        PrintErrorMessage();

        return( FALSE );

    }

    hFloppyDrive = CreateFile( DrivePath,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL );

    if( hFloppyDrive == INVALID_HANDLE_VALUE )
    {

        PrintErrorMessage();

        CleanUp( &hFloppyDrive, &hFloppyImage );

        return( FALSE );

    }

    for( iCurrentTrack = 0; iCurrentTrack < TRACKS_ON_DISK; iCurrentTrack++ )
    {
        if( ! ReadFile( hFloppyImage, TrackBuffer, TRACK_SIZE, &cBytesRead, NULL ) )
        {

            PrintErrorMessage();

            CleanUp( &hFloppyDrive, &hFloppyImage );

            return( FALSE );

        }

        if( ! WriteFile( hFloppyDrive, TrackBuffer, TRACK_SIZE, &cBytesWritten, NULL ) )
        {

            PrintErrorMessage();

            CleanUp( &hFloppyDrive, &hFloppyImage );

            return( FALSE );

        }

        iPercentComplete = (int) ( ( (double) (iCurrentTrack) / (double) (TRACKS_ON_DISK) ) * 100.0 );

        ConsolePrint( L"%c %3d%% %s.\r",
                 rgAsciiWheel[iWheelPosition],
                 iPercentComplete,
                 StrComplete );

        //
        //  Advance the ASCII wheel
        //

        iWheelPosition++;

        if( iWheelPosition >= NUMBER_OF_ASCII_WHEEL_SYMBOLS )
        {
            iWheelPosition = 0;
        }

    }

    //
    //  We are done copying the disk so force it to read 100% and get rid of
    //  the ascii wheel symbol.
    //
    ConsolePrint( L"  100%% %s.        \n", StrComplete );

    //
    //  Free allocated resources
    //
    CleanUp( &hFloppyDrive, &hFloppyImage );

    return TRUE;

}

//----------------------------------------------------------------------------
//
// Function: PrintErrorMessage
//
// Purpose:  To get the last system error, look up what it is and print it out
//           to the user.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
PrintErrorMessage( VOID )
{

    LPVOID lpMsgBuf = NULL;

    if(!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                       FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL,
                       GetLastError(),
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       (LPWSTR) &lpMsgBuf,
                       0,
                       NULL )) {
        // Great.  Not enough memory to format an error message.
        ConsolePrint( L"\nNot enough memory to format error message.\n" );
        if( lpMsgBuf )
	    LocalFree( lpMsgBuf );
    }
    else {

        ConsolePrint( L"\n%s\n", (LPCWSTR)lpMsgBuf );

        LocalFree( lpMsgBuf );
    }

}

//----------------------------------------------------------------------------
//
// Function: PrintErrorWrongDriveType
//
// Purpose:  To translate a drive type error code into a message and print it
//
// Arguments: UINT iDriveType - drive type error code to look-up
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
PrintErrorWrongDriveType( UINT iDriveType )
{

    if( iDriveType == DRIVE_NO_ROOT_DIR )
    {
        WCHAR *StrNoRootDir = MyLoadString( IDS_NO_ROOT_DIR );

        ConsolePrint( L"\n%s\n", StrNoRootDir );

        free( StrNoRootDir );
    }
    else
    {
        WCHAR *StrDriveNotFloppy = MyLoadString( IDS_DRIVE_NOT_FL0PPY );

        ConsolePrint( L"\n%s\n", StrDriveNotFloppy );

        free( StrDriveNotFloppy );
    }

}

//----------------------------------------------------------------------------
//
// Function: IsDriveLargeEnough
//
// Purpose:  To determine if the floppy drive supports 1.44 MB or larger disks
//
// Arguments: char* DrivePath - drive path of the floppy to write to, it is of
//    the form \\.\x where x is the drive letter
//
// Returns: BOOL - TRUE if the drive supports 1.44 MB or greater, FALSE if not
//
//----------------------------------------------------------------------------
BOOL
IsDriveLargeEnough( WCHAR *DrivePath )
{

    UINT i;
    HANDLE hFloppyDrive;
    DISK_GEOMETRY SupportedGeometry[20];
    DWORD SupportedGeometryCount;
    DWORD ReturnedByteCount;

    hFloppyDrive = CreateFile( DrivePath,
                               0,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               0,
                               NULL );

    if( hFloppyDrive == INVALID_HANDLE_VALUE )
    {

        PrintErrorMessage();

        exit( 1 );

    }

    if( DeviceIoControl( hFloppyDrive,
                         IOCTL_DISK_GET_MEDIA_TYPES,
                         NULL,
                         0,
                         SupportedGeometry,
                         sizeof( SupportedGeometry ),
                         &ReturnedByteCount,
                         NULL ) )
    {

        SupportedGeometryCount = ( ReturnedByteCount / sizeof( DISK_GEOMETRY ) );

    }
    else
    {
        SupportedGeometryCount = 0;
    }

    CloseHandle( hFloppyDrive );

    for( i = 0; i < SupportedGeometryCount; i++ )
    {

        if( SupportedGeometry[i].MediaType == F3_1Pt44_512 )
        {

            //
            // This drive supports 3.5,  1.44MB, 512 bytes/sector.
            //
            return( TRUE );

        }

    }

    return( FALSE );

}

//----------------------------------------------------------------------------
//
// Function: DoImageFilesExist
//
// Purpose:  Determines if all the image files are in the current directory or
//           not.  If an image file is missing, an error message is printed
//           to the user.
//
//           Note: it detemines if a file exists by seeing if it can open it
//           for reading.
//
// Arguments: VOID
//
// Returns: INT -- non-zero on success, all images files exist in current dir
//                 zero on failure, 1 or more image files do not exist
//
//----------------------------------------------------------------------------
INT
DoImageFilesExist( VOID )
{

    BOOL  bAllFilesExist = TRUE;

    if( ! DoesFileExist( NT_IMAGE_1_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_1_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_2_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_2_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_3_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_3_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_4_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_4_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_5_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_5_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_6_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_6_NAME );
        bAllFilesExist = FALSE;
    }
    if( ! DoesFileExist( NT_IMAGE_7_NAME ) )
    {
        print( StrCanNotFindFile, NT_IMAGE_7_NAME );
        bAllFilesExist = FALSE;
    }

    if( bAllFilesExist )
    {
        return( 1 );
    }
    else
    {
        return( 0 );
    }

}

//----------------------------------------------------------------------------
//
// Function: CleanUp
//
// Purpose:  Closes open handles.  This function should be called just before
//           exiting the program.
//
// Arguments:  HANDLE *hFloppyDrive - the floppy disk handle to be closed
//             HANDLE *hFloppyImage - the floppy image file handle to be closed
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
CleanUp( HANDLE *hFloppyDrive, HANDLE *hFloppyImage )
{

    if( *hFloppyDrive )
    {
        CloseHandle( *hFloppyDrive );
        *hFloppyDrive = NULL;
    }

    if( *hFloppyImage )
    {
        CloseHandle( *hFloppyImage );
        *hFloppyImage = NULL;
    }

}

//----------------------------------------------------------------------------
//
//  Function: FreeStrings
//
//  Purpose:  Deallocate the memory for all the strings.
//
//  Arguments: VOID
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
FreeStrings( VOID )
{

    free( StrNtVersionName );
    free( StrDiskLabel1 );
    free( StrDiskLabel2 );
    free( StrDiskLabel3 );
    free( StrDiskLabel4 );
    free( StrDiskLabel5 );
    free( StrDiskLabel6 );
    free( StrDiskLabel7 );

    free( StrStars );
    free( StrExplanationLine1 );
    free( StrExplanationLine2 );
    free( StrExplanationLine3 );
    free( StrExplanationLine4 );
    free( StrInsertFirstDiskLine1 );
    free( StrInsertFirstDiskLine2 );
    free( StrInsertAnotherDiskLine1 );
    free( StrInsertAnotherDiskLine2 );
    free( StrPressAnyKeyWhenReady );
    free( StrCompletedSuccessfully );
    free( StrComplete );

    free( StrCanNotFindFile );

    free( StrOutOfMemory );

}

//----------------------------------------------------------------------------
//
//  Function: LoadStrings
//
//  Purpose:  Load the string constants from the string table.
//
//  Arguments: VOID
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
LoadStrings( VOID )
{

    INT Length;

    //
    //  Loading the Out of Memory string is a little tricky because of the
    //  error that can occur while loading it.
    //
    //  For the other strings, just call the MyLoadString function to do
    //  the work
    //
    StrOutOfMemory = (WCHAR *) malloc( MAKEBOOT_MAX_STRING_LEN * sizeof(WCHAR) + 1 );

    if( StrOutOfMemory == NULL )
    {
        //
        //  Can't localize this string
        //
        ConsolePrint( L"\nOut of memory.  Please free more memory and run this program again.\n" );

        exit( 1 );
    }

    Length = LoadString( NULL,
                         IDS_OUT_OF_MEMORY,
                         StrOutOfMemory,
                         MAKEBOOT_MAX_STRING_LEN );

    if( ! Length )
    {
        //
        //  Can't localize this string
        //
        ConsolePrint( L"Unable to load resources.\n" );

        exit( 1 ) ;
    }

    StrStars                   = MyLoadString( IDS_STARS );
    StrExplanationLine1        = MyLoadString( IDS_PROGRAM_EXPLANATION_LINE_1 );
    StrExplanationLine2        = MyLoadString( IDS_PROGRAM_EXPLANATION_LINE_2 );
    StrExplanationLine3        = MyLoadString( IDS_PROGRAM_EXPLANATION_LINE_3 );
    StrExplanationLine4        = MyLoadString( IDS_PROGRAM_EXPLANATION_LINE_4 );

    StrInsertFirstDiskLine1    = MyLoadString( IDS_INSERT_FIRST_DISK_LINE_1 );
    StrInsertFirstDiskLine2    = MyLoadString( IDS_INSERT_FIRST_DISK_LINE_2 );

    StrInsertAnotherDiskLine1  = MyLoadString( IDS_INSERT_ANOTHER_DISK_LINE_1 );
    StrInsertAnotherDiskLine2  = MyLoadString( IDS_INSERT_ANOTHER_DISK_LINE_2 );

    StrPressAnyKeyWhenReady    = MyLoadString( IDS_PRESS_ANY_KEY_WHEN_READY );

    StrCompletedSuccessfully   = MyLoadString( IDS_COMPLETED_SUCCESSFULLY );
    StrComplete                = MyLoadString( IDS_COMPLETE );

    StrCanNotFindFile          = MyLoadString( IDS_CANNOT_FIND_FILE );

    StrNtVersionName           = MyLoadString( IDS_NT_VERSION_NAME_DEFAULT );
    StrDiskLabel1              = MyLoadString( IDS_DISK_LABEL_1_DEFAULT );
    StrDiskLabel2              = MyLoadString( IDS_DISK_LABEL_2_DEFAULT );
    StrDiskLabel3              = MyLoadString( IDS_DISK_LABEL_3_DEFAULT );
    StrDiskLabel4              = MyLoadString( IDS_DISK_LABEL_4_DEFAULT );
    StrDiskLabel5              = MyLoadString( IDS_DISK_LABEL_5_DEFAULT );
    StrDiskLabel6              = MyLoadString( IDS_DISK_LABEL_6_DEFAULT );
    StrDiskLabel7              = MyLoadString( IDS_DISK_LABEL_7_DEFAULT );

}

//----------------------------------------------------------------------------
//
//  Function: DoesUserWantToTryCopyAgain
//
//  Purpose:  Ask the user if they want to retry to copy the image to floppy.
//            Get the user input and return whether to copy again or not.
//
//  Arguments: VOID
//
//  Returns:  BOOL - TRUE  if user wants to attempt to copy again
//                 - FALSE if user does not want to attempt to copy again
//
//----------------------------------------------------------------------------
BOOL
DoesUserWantToTryCopyAgain( VOID )
{

    INT ch;

    WCHAR *StrAttemptToCreateFloppyAgain = MyLoadString( IDS_ATTEMPT_TO_CREATE_FLOPPY_AGAIN );
    WCHAR *StrPressEnterOrEsc = MyLoadString( IDS_PRESS_ENTER_OR_ESC );

    //
    //  Clear the input stream by eating all the chars until there are none
    //  left.  Print the message and then wait for a key press.
    //
    while( _kbhit() )
    {
        _getch();
    }

    do
    {
        ConsolePrint( L"%s\n", StrAttemptToCreateFloppyAgain );
        ConsolePrint( L"%s\n", StrPressEnterOrEsc );

        ch = _getch();

    } while( ch != ENTER_KEY && ch != ESC_KEY  );

    if( ch == ENTER_KEY )
    {
        return( TRUE );
    }
    else
    {
        return( FALSE );
    }

    free( StrAttemptToCreateFloppyAgain );
    free( StrPressEnterOrEsc );

}

//----------------------------------------------------------------------------
//
//  Function: PressAnyKeyToContinue
//
//  Purpose:  Print the "Press any key when ready" message and wait until the
//  user presses a key.
//
//  Arguments: VOID
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
PressAnyKeyToContinue( VOID )
{

    //
    //  Clear the input stream by eating all the chars until there are none
    //  left.  Print the message and then wait for a key press.
    //
    while( _kbhit() )
    {
        _getch();
    }

    print( StrPressAnyKeyWhenReady );

    //
    //  Spin until the keyboard is pressed
    //
    while( ! _kbhit() )
    {
        ;
    }

}

//----------------------------------------------------------------------------
//
//  Function: MyLoadString
//
//  Purpose: Loads a string resource given it's IDS_* and returns
//           a malloc'ed buffer with its contents.
//
//           The malloc()'ed buffer must be freed with free()
//
//           This function will either return the string or exit.  It will
//           never return NULL or a bad pointer.
//
//  Arguments: UINT StringId - the string ID to load
//
//  Returns:
//      Pointer to buffer.  An empty string is returned if the StringId
//      does not exist.  Null is returned if out of memory.
//
//----------------------------------------------------------------------------
LPWSTR
MyLoadString( UINT StringId )
{

    WCHAR Buffer[ MAKEBOOT_MAX_STRING_LEN ];
    WCHAR *String = NULL;
    UINT  Length;

    Length = LoadString( NULL,
                         StringId,
                         Buffer,
                         MAKEBOOT_MAX_STRING_LEN );

    if( Length )
    {

        String = (WCHAR *) malloc( Length * sizeof(WCHAR) + 1 );

        if( String == NULL )
        {

            ConsolePrint( L"%s\n", StrOutOfMemory );

            exit( 1 );

        }
        else
        {

            wcscpy( String, Buffer );
            String[Length] = L'\0';

            return( String );

        }

    }
    else
    {

        //
        //  Can't load the string so exit
        //  NOTE: this string will not be localized
        //
        ConsolePrint( L"Unable to load resources.\n" );

        exit( 1 );

    }

}

//----------------------------------------------------------------------------
//
//  Function: print
//
//  Purpose:  To print out strings to the user.  Useful when there is
//            embedded formatting characters in a string that was loaded from
//            a string table.
//
//  Arguments: szFirstString - the string that contains the embedded formatting
//                             characters (such as %s, %c, etc.)
//             ... - variable number of arguments that correspond to each
//                   formatting character
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
print( WCHAR *szFirstString, ... )
{

    WCHAR OutputBuffer[MAKEBOOT_MAX_STRING_LEN];
    va_list arglist;

    va_start( arglist, szFirstString );

    wvsprintf( OutputBuffer, szFirstString, arglist );

    ConsolePrint( L"%s\n", OutputBuffer );

    va_end( arglist );

}

//----------------------------------------------------------------------------
//
//  Function: DoesFileExist
//
//  Purpose:  To determine whether a file exists or not
//
//  Arguments: LPWSTR lpFileName - filename to see if it exists or not
//
//  Returns:  BOOL - TRUE  if the file exists
//                 - FALSE if the file does not exist
//
//----------------------------------------------------------------------------
BOOL
DoesFileExist( LPWSTR lpFileName )
{
    DWORD dwAttribs = GetFileAttributes( lpFileName );

    if( dwAttribs == (DWORD) -1 )
    {
        return( FALSE );
    }

    if( dwAttribs & FILE_ATTRIBUTE_DIRECTORY )
    {
        return( FALSE );
    }

    return( TRUE );
}

//----------------------------------------------------------------------------
//
//  Function: IsDBCSConsole
//
//  Purpose:  To determine whether a DBC console or not
//
//  Arguments: None
//
//  Returns:  BOOL - TRUE  if FE console codepage
//                 - FALSE if not FE console codepage
//
//----------------------------------------------------------------------------
BOOL
IsDBCSCodePage(UINT CodePage)
{
    switch(CodePage) {
        case 932:
        case 936:
        case 949:
        case 950:
            return TRUE;
    }
    return FALSE;
}

//----------------------------------------------------------------------------
//
//  Function: SetFarEastThread
//
//  Purpose:  FarEast version wants to display bi-lingual string according console OCP
//
//  Arguments: None
//
//  Returns:  None
//----------------------------------------------------------------------------
void SetFarEastThread()
{
    LANGID LangId = 0;

    switch(GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            {
                LANGID TmpLangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));

                if (TmpLangId == LANG_JAPANESE ||
                    TmpLangId == LANG_KOREAN   ||
                    TmpLangId == LANG_CHINESE    ) {
                    LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
                }
            }
            break;
    }

    if (LangId) {
        SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
    }
}

//----------------------------------------------------------------------------
//
//  Function: ConsolePrint
//
//  Purpose:  There is a bug in CRT library that unicode FE characters can't
//            convert correctly, so we output characters directly.
//
//  Arguments: None
//
//  Returns:  None
//----------------------------------------------------------------------------
void ConsolePrint( WCHAR *szFirstString, ... )
{
    HANDLE StdOut;
    DWORD WrittenCount;
    WCHAR OutputBuffer[MAKEBOOT_MAX_STRING_LEN];
    va_list arglist;

    if((StdOut = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
        return;
    }

    va_start( arglist, szFirstString );

    wvsprintf( OutputBuffer, szFirstString, arglist );

    WriteConsoleW(
            StdOut,
            OutputBuffer,
            lstrlenW(OutputBuffer),
            &WrittenCount,
            NULL
            );

    va_end( arglist );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\sbentry.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    sbentry.c

Abstract:

    Contains the OS boot entry and boot options
    abstraction implementation.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/


#include <sbentry.h>
#include <stdio.h>

SBEMemAllocateRoutine    AllocRoutine = NULL;
SBEMemFreeRoutine        FreeRoutine = NULL;

//
// OS_BOOT_ENTRY Methods
//
PCWSTR
OSBEAddOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    )
{
    PWSTR   Option = NULL;
    WCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        wcscpy(Buffer, BootOption);
        _wcsupr(Buffer);
        Length = wcslen(Buffer);

        if (Length) {
            //
            // Add a space at the end if required
            //
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            if ((!wcsstr(This->OsLoadOptions, Buffer)) &&
                ((wcslen(This->OsLoadOptions) + Length) < MAX_PATH)) {
                
                wcscat(This->OsLoadOptions, Buffer);                
                Option = This->OsLoadOptions;
            }

            OSBE_SET_DIRTY(This);
            OSBO_SET_DIRTY(This->BootOptions);
        }
    }

    return Option;
}

PCWSTR
OSBERemoveOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    )
{
    PWSTR   Option = NULL;
    WCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        wcscpy(Buffer, BootOption);
        _wcsupr(Buffer);
        Length = wcslen(Buffer);

        if (Length) {
            PWSTR   OldOption;
            
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {                
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            OldOption = wcsstr(This->OsLoadOptions, Buffer);

            if (OldOption) {
                
                PWSTR NextToken = wcschr(OldOption + 1, L'/');

                if (NextToken) {
                    wcscpy(OldOption, NextToken);
                } else {
                    *OldOption = UNICODE_NULL;
                }

                Option = This->OsLoadOptions;
                
                OSBE_SET_DIRTY(This);
                OSBO_SET_DIRTY(This->BootOptions);
            }                
        }
    }

    return Option;
}

BOOLEAN
OSBEIsOsLoadOptionPresent(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    )
{
    BOOLEAN Result = FALSE;
    WCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        
        ULONG   Length;
        
        wcscpy(Buffer, BootOption);
        _wcsupr(Buffer);
        Length = wcslen(Buffer);

        if (Length) {            
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            Result = wcsstr(This->OsLoadOptions, Buffer) ? TRUE : FALSE;            
        }
    }

    return Result;
}


//
// OS_BOOT_OPTIONS Methods
//
POS_BOOT_ENTRY
OSBOFindBootEntry(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {        
        for (Entry = This->BootEntries; Entry; Entry = Entry->NextEntry) {            
            if (Entry->Id == Id) {                
                break;  // found the required entry
            }
        }
    }

    return Entry;
}

ULONG
OSBOFindBootEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    ULONG Index = -1;

    if (This) {
        
        ULONG EntryIndex;
        
        for (EntryIndex = 0; 
            EntryIndex < OSBOGetOrderedBootEntryCount(This); 
            EntryIndex++) {

            if (This->BootOrder[EntryIndex] == Id) {                
                Index = EntryIndex;
                break;  // found the required entry
            }
        }
    }

    return Index;
}

BOOLEAN
OSBODeleteBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    )
{
    BOOLEAN Result = FALSE;

    if (This && BootEntry) {
        
        POS_BOOT_ENTRY  CurrEntry = NULL;
        POS_BOOT_ENTRY  PrevEntry = NULL;

        for (CurrEntry = This->BootEntries;
             CurrEntry != BootEntry;
             PrevEntry = CurrEntry, CurrEntry = CurrEntry->NextEntry) {
            // do nothing             
        }                

        if (CurrEntry) {
            
            ULONG Order;
            POS_BOOT_ENTRY  OrderedEntry;

            //
            // Set the required attributes
            //
            OSBE_SET_DELETED(BootEntry);            
            OSBE_SET_DIRTY(BootEntry);
            OSBO_SET_DIRTY(This);
            
            //
            // Flush the changes
            //
            Result = OSBEFlush(BootEntry);

            if (Result) {
                //
                // Remove references to the entries
                //
                if (PrevEntry) {                    
                    PrevEntry->NextEntry = BootEntry->NextEntry;
                } else {                
                    This->BootEntries = BootEntry->NextEntry;
                }  

                if (This->EntryCount) {                    
                    This->EntryCount--;
                }                    

                //
                // if this entry was ordered then remove
                // reference from the order too
                //
                Order = OSBOFindBootEntryOrder(This, OSBEGetId(BootEntry));

                if (Order != (-1)) {                    
                    ULONG   OrderCount = OSBOGetOrderedBootEntryCount(This);

                    OrderCount--;                    
                    if (OrderCount) {                        
                        PULONG  NewOrder = SBE_MALLOC(OrderCount * sizeof(ULONG));                

                        if (NewOrder) {
                            //
                            // copy entries before the current entry
                            //
                            memcpy(NewOrder, This->BootOrder, Order * sizeof(ULONG));

                            //
                            // copy entries after the current entry
                            //
                            memcpy(NewOrder + Order, This->BootOrder + Order + 1,
                                (OrderCount - Order) * sizeof(ULONG));

                            SBE_FREE(This->BootOrder);
                            This->BootOrder = NewOrder;
                            This->BootOrderCount = OrderCount;
                            Result = TRUE;
                        } else {                        
                            Result = FALSE;
                        }                            
                    } else {                    
                        SBE_FREE(This->BootOrder);
                        This->BootOrder = NULL;
                        This->BootOrderCount = 0;
                    }                        
                }


                if (BootEntry == OSBOGetActiveBootEntry(This)) {
                    
                    ULONG Index;
                    
                    //
                    // Update the active boot entry and the next boot entry
                    //
                    This->CurrentEntry = NULL;
                    Index = OSBOGetBootEntryIdByOrder(This, 0);

                    if (Index != (-1)) {
                        This->CurrentEntry = OSBOFindBootEntry(This, Index);
                    }
                }                    

                //
                // Since we updated some state mark it dirty
                //
                OSBO_SET_DIRTY(This);
                
                OSBEDelete(BootEntry);            
            }                
        }            
    }

    return Result;
}

POS_BOOT_ENTRY
OSBOSetActiveBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    )
{
    POS_BOOT_ENTRY  OldActiveEntry = NULL;

    if (This && BootEntry) {        
        ULONG   OrderCount = OSBOGetOrderedBootEntryCount(This);
        OldActiveEntry = OSBOGetActiveBootEntry(This);

        if ((OrderCount > 0) && (OldActiveEntry != BootEntry)) {            
            ULONG Index;
            ULONG ActiveIndex = OSBOFindBootEntryOrder(This,
                                    OSBEGetId(BootEntry));

            //
            // If the entry is already present in the boot order
            // and move it to the start of the list
            //
            if (ActiveIndex != (-1)) {                   
                for (Index = ActiveIndex; Index; Index--) {
                    
                    This->BootOrder[Index] = This->BootOrder[Index - 1];
                }

                This->BootOrder[0] = BootEntry->Id;
            } else {
                //
                // This is a new entry in ordered list. Grow the ordered boot
                // entry list with this new entry at the start
                //
                PULONG  NewBootOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

                memcpy(NewBootOrder + 1, This->BootOrder, sizeof(ULONG) * OrderCount);
                NewBootOrder[0] = BootEntry->Id;

                SBE_FREE(This->BootOrder);
                This->BootOrder = NewBootOrder;
            }

            //
            // Update the active boot entry and the next boot entry
            //
            This->CurrentEntry = NULL;
            Index = OSBOGetBootEntryIdByOrder(This, 0);

            if (Index != (-1)) {                
                This->CurrentEntry = OSBOFindBootEntry(This, Index);
            }

            //
            // Since we updated some state mark it dirty
            //
            OSBO_SET_DIRTY(This);
        }        
    }

    return OldActiveEntry;
}

POS_BOOT_ENTRY
OSBOGetFirstBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN OUT PULONG Index
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This && Index) {        
        *Index = 0;        
        Entry = OSBOGetNextBootEntry(This, Index);
    }                            

    return Entry;
}

POS_BOOT_ENTRY
OSBOGetNextBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PULONG Index
    )    
{
    POS_BOOT_ENTRY  Entry = NULL;

    //
    // TBD : Might want to optimize this, since
    // each boot entry now has a pointer to the next
    // boot entry
    //
    if (This && Index) {        
        ULONG   Count = *Index;
        POS_BOOT_ENTRY  CurrEntry;

        for (CurrEntry = This->BootEntries;
             CurrEntry;
             CurrEntry = CurrEntry->NextEntry, Count--) {

            if (!Count) {                
                Entry = CurrEntry;
                (*Index)++;

                break;
            }                
        }                     
    }        

    return Entry;
}

ULONG
OSBOFindDriverEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    ULONG Index = -1;

    if (This) {        
        ULONG EntryIndex;
        
        for (EntryIndex = 0; 
            EntryIndex < OSBOGetOrderedDriverEntryCount(This); 
            EntryIndex++) {

            if (This->DriverEntryOrder[EntryIndex] == Id) {                
                Index = EntryIndex;
                break;  // found the required entry
            }
        }
    }

    return Index;
}


PDRIVER_ENTRY
OSBOFindDriverEntryById(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    PDRIVER_ENTRY  Entry = NULL;

    if (This) {        
        for (Entry = This->DriverEntries; 
             Entry; 
             Entry = OSBOGetNextDriverEntry(This, Entry)) {
            
            if (Entry->Id == Id) {                
                break;  // found the required entry
            }
        }
    }

    return Entry;
}

PDRIVER_ENTRY    
OSBOFindDriverEntryByName(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            DriverName
    )
/*++
    Finds matching driver entry by driver file name.
--*/
{
    PDRIVER_ENTRY CurrentDriverEntry = NULL;
    
    if (This && DriverName && DriverName[0] != UNICODE_NULL){
        
        CurrentDriverEntry = This->DriverEntries;        
        while (CurrentDriverEntry){
             if (!_wcsicmp(CurrentDriverEntry->FileName ,DriverName)){
                break;
             }             
            CurrentDriverEntry = OSBOGetNextDriverEntry(This, CurrentDriverEntry);
        }
        
    }   
    return (CurrentDriverEntry);
}

BOOLEAN
OSBODeleteDriverEntry(
    IN POS_BOOT_OPTIONS This,
    IN ULONG            Id
    )
/*++
    Description:
        Used to delete a driver entry. Calls Flush to flush the entry out.

    Parameters:
        This - Pointer to OS boot options structure.

        Id   - Id for the drivr entry to be deleted.

    Return Value:
        TRUE if successful else FALSE.

--*/
{
    BOOLEAN Result = FALSE;
    
    if (This){
        //
        // Look up for the driver entry that has this ID set and mark it to 
        // be deleted. Then Flush it.
        //  
        PDRIVER_ENTRY CurrentEntry = This->DriverEntries;
        PDRIVER_ENTRY PreviousEntry = NULL;
        
        while (CurrentEntry){            
            if (Id == CurrentEntry->Id){
                
                DRIVERENT_SET_DIRTY(CurrentEntry);
                DRIVERENT_SET_DELETED(CurrentEntry);
                OSBO_SET_DIRTY(This);
                //
                // Flush The data.
                //
                Result = OSDriverEntryFlush(CurrentEntry);

                if (Result){                    
                    ULONG Order;
                    
                    //
                    //Remove it out of the Driver List.                
                    //
                    if (NULL == PreviousEntry){                        
                        This->DriverEntries = OSBOGetNextDriverEntry(This,CurrentEntry); 
                    } else {                    
                        PreviousEntry->NextEntry = OSBOGetNextDriverEntry(This, CurrentEntry);                        
                    }
                    
                    if (This->DriverEntryCount) {
                        
                        This->DriverEntryCount--;
                    }
                      
                    //
                    // if this entry was ordered then remove
                    // reference from the order too
                    //
                    Order = OSBOFindDriverEntryOrder(This, OSDriverGetId(CurrentEntry));
                                         
                    if (Order != (-1)) {                        
                        ULONG   OrderCount = OSBOGetOrderedDriverEntryCount(This);

                        OrderCount--;                        
                        if (OrderCount) {                            
                            PULONG  NewOrder = SBE_MALLOC(OrderCount * sizeof(ULONG));                

                            if (NewOrder) {
                                //
                                // copy entries before the current entry
                                //
                                memcpy(NewOrder, This->DriverEntryOrder, Order * sizeof(ULONG));

                                //
                                // copy entries after the current entry
                                //
                                memcpy(NewOrder + Order, This->DriverEntryOrder + Order + 1,
                                    (OrderCount - Order) * sizeof(ULONG));

                                SBE_FREE(This->DriverEntryOrder);
                                This->DriverEntryOrder = NewOrder;
                                This->DriverEntryOrderCount = OrderCount;
                                Result = TRUE;
                            } else {                            
                                Result = FALSE;
                            }                            
                        } else {
                        
                            SBE_FREE(This->DriverEntryOrder);
                            This->DriverEntryOrder = NULL;
                            This->DriverEntryOrderCount = 0;
                        }                        
                    }

                    SBE_FREE(CurrentEntry);
                    //
                    // Since we updated some state mark it dirty
                    //
                    OSBO_SET_DIRTY(This);
                }
                //
                // As we make sure that ID's are unique we can break and not process any more.
                //
                break;
            }
            PreviousEntry = CurrentEntry;
            CurrentEntry = OSBOGetNextDriverEntry(This, CurrentEntry);
        }
    }
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\sbentry.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    sbentry.h

Abstract:

    Contains the OS boot entry and boot options
    abstractions.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/

#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>

//
// Allocate & Deallocate routines
//
typedef void* (* SBEMemAllocateRoutine)(size_t  Size);
typedef void (* SBEMemFreeRoutine)(void *Memory);

extern SBEMemAllocateRoutine    AllocRoutine;
extern SBEMemFreeRoutine        FreeRoutine;


#define ARRAY_SIZE(x)   (sizeof((x))/sizeof((x)[0]))


//
// Internal attributes for the boot entry
//
#define OSBE_ATTRIBUTE_NEW      0x00000001
#define OSBE_ATTRIBUTE_DELETED  0x00000002
#define OSBE_ATTRIBUTE_WINDOWS  0x00000004
#define OSBE_ATTRIBUTE_DIRTY    0x10000000

//
//Internal attributes for the driver entry.
//
#define DRIVER_ATTRIBUTE_NEW      0x00000001
#define DRIVER_ATTRIBUTE_DELETED  0x00000002
#define DRIVER_ATTRIBUTE_DIRTY    0x10000000

//
// OS_BOOT_ENTRY abstraction
//
typedef struct _OS_BOOT_ENTRY   *POS_BOOT_ENTRY;
typedef struct _OS_BOOT_OPTIONS *POS_BOOT_OPTIONS;

typedef VOID (* OSBEDeleteMethod)(
                    IN POS_BOOT_ENTRY This
                    );

typedef BOOLEAN (* OSBEFlushMethod)(
                    IN POS_BOOT_ENTRY This
                    );

typedef struct _OS_BOOT_ENTRY {
    //
    // Data members
    //
    ULONG   Version;
    ULONG   Id;    
    WCHAR   FriendlyName[MAX_PATH];
    WCHAR   OsLoaderVolumeName[MAX_PATH];
    WCHAR   OsLoaderPath[MAX_PATH];
    WCHAR   BootVolumeName[MAX_PATH];
    WCHAR   BootPath[MAX_PATH];
    WCHAR   OsLoadOptions[MAX_PATH];
    ULONG   Attributes;
    POS_BOOT_OPTIONS    BootOptions;
    POS_BOOT_ENTRY      NextEntry;

    //
    // Methods
    //
    OSBEDeleteMethod    Delete;
    OSBEFlushMethod     Flush;
} OS_BOOT_ENTRY;

//
// Driver Entry abstraction.
//
typedef struct _DRIVER_ENTRY    *PDRIVER_ENTRY;

typedef VOID (* DriverEntryDeleteMethod)(
                    IN POS_BOOT_OPTIONS  This,
                    IN ULONG             Id
                    );

typedef BOOLEAN (* DriverEntryFlushMethod)(
                    IN PDRIVER_ENTRY This
                    );

typedef struct _DRIVER_ENTRY {
    ULONG               Id;
    WCHAR               FileName[MAX_PATH];
    WCHAR               NtDevicePath[MAX_PATH];
    WCHAR               DirPath[MAX_PATH];
    WCHAR               FriendlyName[MAX_PATH];
    ULONG               Attributes;
    
    POS_BOOT_OPTIONS    BootOptions;
    PDRIVER_ENTRY       NextEntry;
    //
    // Methods
    //
    DriverEntryDeleteMethod    Delete;
    DriverEntryFlushMethod     Flush;   
} DRIVER_ENTRY;

#define OSBE_IS_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_DIRTY)
#define OSBE_IS_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_NEW)
#define OSBE_IS_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_DELETED)
#define OSBE_IS_WINDOWS(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_WINDOWS)

#define OSBE_SET_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_DIRTY)
#define OSBE_SET_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_NEW)
#define OSBE_SET_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_DELETED)
#define OSBE_SET_WINDOWS(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_WINDOWS)

#define OSBE_RESET_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_DIRTY)
#define OSBE_RESET_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_NEW)
#define OSBE_RESET_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_DELETED)
#define OSBE_RESET_WINDOWS(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_WINDOWS)

#define DRIVERENT_IS_DIRTY(_de)    (((PDRIVER_ENTRY)(_de))->Attributes & DRIVER_ATTRIBUTE_DIRTY)
#define DRIVERENT_IS_NEW(_de)      (((PDRIVER_ENTRY)(_de))->Attributes & DRIVER_ATTRIBUTE_NEW)
#define DRIVERENT_IS_DELETED(_de)  (((PDRIVER_ENTRY)(_de))->Attributes & DRIVER_ATTRIBUTE_DELETED)

#define DRIVERENT_SET_DIRTY(_de)    (((PDRIVER_ENTRY)(_de))->Attributes |= DRIVER_ATTRIBUTE_DIRTY)
#define DRIVERENT_SET_NEW(_de)      (((PDRIVER_ENTRY)(_de))->Attributes |= DRIVER_ATTRIBUTE_NEW)
#define DRIVERENT_SET_DELETED(_de)  (((PDRIVER_ENTRY)(_de))->Attributes |= DRIVER_ATTRIBUTE_DELETED)

#define DRIVERENT_RESET_DIRTY(_de)    (((PDRIVER_ENTRY)(_de))->Attributes &= ~DRIVER_ATTRIBUTE_DIRTY)
#define DRIVERENT_RESET_NEW(_de)      (((PDRIVER_ENTRY)(_de))->Attributes &= ~DRIVER_ATTRIBUTE_NEW)
#define DRIVERENT_RESET_DELETED(_de)  (((PDRIVER_ENTRY)(_de))->Attributes &= ~DRIVER_ATTRIBUTE_DELETED)


//
// OS_BOOT_OPTIONS abstraction
//
typedef VOID (* OSBODeleteMethod)(
                    IN POS_BOOT_OPTIONS This
                    );

typedef POS_BOOT_ENTRY (* OSBOAddNewBootEntryMethod)(
                            IN POS_BOOT_OPTIONS  This,
                            IN PCWSTR            FriendlyName,
                            IN PCWSTR            OsLoaderVolumeName,
                            IN PCWSTR            OsLoaderPath,
                            IN PCWSTR            BootVolumeName,
                            IN PCWSTR            BootPath,
                            IN PCWSTR            OsLoadOptions
                            );

typedef BOOLEAN (* OSBODeleteBootEntryMethod)(
                        IN POS_BOOT_OPTIONS This,
                        IN POS_BOOT_ENTRY   BootEntry
                        );

typedef BOOLEAN (* OSBOFlushMethod)(
                        IN POS_BOOT_OPTIONS This 
                        );

typedef PDRIVER_ENTRY (* OSBOAddNewDriverEntryMethod)(
                        IN POS_BOOT_OPTIONS  This,
                        IN PCWSTR            FriendlyName,
                        IN PCWSTR            NtDevicePath,
                        IN PCWSTR            SrcNtFullPath
                        );

typedef BOOLEAN (* OSBODeleteDriverEntryMethod)(
                        IN POS_BOOT_OPTIONS This,
                        IN ULONG            Id
                        );

typedef struct _OS_BOOT_OPTIONS {
    //
    // Data members
    //
    ULONG               Version;
    ULONG               Attributes;
    ULONG               Timeout;

    POS_BOOT_ENTRY      BootEntries;
    POS_BOOT_ENTRY      CurrentEntry;    
    ULONG               EntryCount;
    PULONG              BootOrder;
    ULONG               BootOrderCount;

    PDRIVER_ENTRY       DriverEntries;
    ULONG               DriverEntryCount;    
    PULONG              DriverEntryOrder;
    ULONG               DriverEntryOrderCount;

    //
    // Methods
    //
    OSBODeleteMethod            Delete;
    OSBOFlushMethod             Flush;
    OSBOAddNewBootEntryMethod   AddNewBootEntry;
    OSBODeleteBootEntryMethod   DeleteBootEntry;
    OSBOAddNewDriverEntryMethod AddNewDriverEntry;
    OSBODeleteDriverEntryMethod DeleteDriverEntry;
} OS_BOOT_OPTIONS;


#define OSBO_IS_DIRTY(_osbo)        (((POS_BOOT_OPTIONS)(_osbo))->Attributes & OSBE_ATTRIBUTE_DIRTY)
#define OSBO_SET_DIRTY(_osbo)       (((POS_BOOT_OPTIONS)(_osbo))->Attributes |= OSBE_ATTRIBUTE_DIRTY)
#define OSBO_RESET_DIRTY(_osbo)     (((POS_BOOT_OPTIONS)(_osbo))->Attributes &= ~OSBE_ATTRIBUTE_DIRTY)

//
// OS_BOOT_ENTRY Methods
//
PCWSTR
OSBEAddOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    );

PCWSTR
OSBERemoveOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    );

BOOLEAN
OSBEIsOsLoadOptionPresent(
    IN  POS_BOOT_ENTRY  This,
    IN  PCWSTR           BootOption
    );

__inline
VOID
OSBEDelete(
    IN POS_BOOT_ENTRY This
    )
{
    if (This) {
        (This->Delete)(This);
    }
}

__inline
BOOLEAN
OSBEFlush(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->Flush(This) : FALSE;
}


__inline
ULONG
OSBEGetId(
    IN POS_BOOT_ENTRY   This
    )
{
    return (This) ? This->Id : (-1);
}

__inline
PCWSTR
OSBEGetFriendlyName(
    IN POS_BOOT_ENTRY   This
    )
{
    return (This) ? This->FriendlyName : NULL;
}

__inline
PCWSTR
OSBESetFriendlyName(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->FriendlyName);
        
        wcsncpy(This->FriendlyName, Name, Size - 1);
        This->FriendlyName[Size - 1] = UNICODE_NULL;
        NewName = This->FriendlyName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetOsLoaderVolumeName(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoaderVolumeName : NULL;
}

__inline
PCWSTR
OSBESetOsLoaderVolumeName(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->OsLoaderVolumeName);
        
        wcsncpy(This->OsLoaderVolumeName, Name, Size - 1);
        This->OsLoaderVolumeName[Size - 1] = UNICODE_NULL;
        NewName = This->OsLoaderVolumeName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetOsLoaderPath(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoaderPath : NULL;
}

__inline
PCWSTR
OSBESetOsLoaderPath(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->OsLoaderPath);
        
        wcsncpy(This->OsLoaderPath, Name, Size - 1);
        This->OsLoaderPath[Size - 1] = UNICODE_NULL;
        NewName = This->OsLoaderPath;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetBootVolumeName(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->BootVolumeName : NULL;
}

__inline
PCWSTR
OSBESetBootVolumeName(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->BootVolumeName);        
    
        wcsncpy(This->BootVolumeName, Name, Size - 1);
        This->BootVolumeName[Size - 1] = UNICODE_NULL;
        NewName = This->BootVolumeName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetBootPath(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->BootPath : NULL;
}

__inline
PCWSTR
OSBESetBootPath(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->BootPath);        
    
        wcsncpy(This->BootPath, Name, Size - 1);
        This->BootPath[Size - 1] = UNICODE_NULL;
        NewName = This->BootPath;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCWSTR
OSBEGetOsLoadOptions(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoadOptions : NULL;
}
    
__inline
PCWSTR
OSBESetOsLoadOptions(
    IN POS_BOOT_ENTRY This,
    IN PCWSTR LoadOptions
    )
{
    WCHAR Buffer[MAX_PATH];
    PWSTR NewOptions = NULL;
    
    if (This && LoadOptions) {
        ULONG   Size = ARRAY_SIZE(This->OsLoadOptions);
        
        wcscpy(Buffer, LoadOptions);
        _wcsupr(Buffer);
        wcsncpy(This->OsLoadOptions, Buffer, Size - 1);
        This->OsLoadOptions[Size - 1] = UNICODE_NULL;
        NewOptions = This->OsLoadOptions;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewOptions;
}

//
// OS_BOOT_OPTIONS Methods
//   
__inline
BOOLEAN
OSBOFlush(
    IN POS_BOOT_OPTIONS This
    )
{
    return (This) ? (This->Flush(This)) : FALSE;
}
    
__inline    
VOID
OSBODelete(
    IN POS_BOOT_OPTIONS This
    )
{
    if (This) {
        This->Delete(This);
    }        
}

__inline
POS_BOOT_ENTRY
OSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            OsLoaderVolumeName,
    IN PCWSTR            OsLoaderPath,
    IN PCWSTR            BootVolumeName,
    IN PCWSTR            BootPath,
    IN PCWSTR            OsLoadOptions
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->AddNewBootEntry(This,
                            FriendlyName,
                            OsLoaderVolumeName,
                            OsLoaderPath,
                            BootVolumeName,
                            BootPath,
                            OsLoadOptions);                    
        OSBO_SET_DIRTY(This);
    }

    return Entry;
}

__inline
POS_BOOT_ENTRY
OSBOGetActiveBootEntry(
    IN POS_BOOT_OPTIONS This
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->CurrentEntry;
    }
    
    return Entry;
}

BOOLEAN
OSBODeleteBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    );
    

POS_BOOT_ENTRY
OSBOSetActiveBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    );

POS_BOOT_ENTRY
OSBOGetFirstBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PULONG Index
    );

POS_BOOT_ENTRY
OSBOGetNextBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PULONG Index
    );

ULONG
OSBOGetBootEntryCount(
    IN POS_BOOT_OPTIONS This
    );

ULONG
OSBOGetOrderedBootEntryCount(
    IN POS_BOOT_OPTIONS This
    );

ULONG
OSBOGetBootEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    );

POS_BOOT_ENTRY
OSBOFindBootEntry(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );

ULONG
OSBOFindBootEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );  

__inline
ULONG
OSBOGetTimeOut(
    IN  POS_BOOT_OPTIONS    This
    )
{
    return (This) ? This->Timeout : 0;
}

__inline
ULONG
OSBOSetTimeOut(
    IN  POS_BOOT_OPTIONS    This,
    IN  ULONG Timeout
    )
{
    ULONG   OldTimeout = 0;

    if (This) {
        OldTimeout = This->Timeout;
        This->Timeout = Timeout;
        OSBE_SET_DIRTY(This);
    }

    return OldTimeout;
}

__inline
ULONG
OSBOGetBootEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->EntryCount;
    }

    return Count;
}


__inline
ULONG
OSBOGetOrderedBootEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->BootOrderCount;
    }

    return Count;
}

__inline
ULONG
OSBOGetBootEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    )
{
    ULONG Entry = -1;

    if (Index < OSBOGetOrderedBootEntryCount(This)) {            
        Entry = This->BootOrder[Index];
    }

    return Entry;
}

__inline
BOOLEAN
OSBOLibraryInit(
    SBEMemAllocateRoutine AllocFunction,
    SBEMemFreeRoutine FreeFunction
    )
{
    BOOLEAN Result = FALSE;

    if (AllocFunction && FreeFunction) {
        AllocRoutine = AllocFunction;
        FreeRoutine = FreeFunction;

        Result = TRUE;
    }

    return Result;
}
    
//
// Driver specific routines.
//
BOOLEAN
OSBODeleteDriverEntry(
    IN POS_BOOT_OPTIONS This,
    IN ULONG            Id
    );


__inline
PDRIVER_ENTRY
OSBOGetFirstDriverEntry(
    IN POS_BOOT_OPTIONS This
    )
{
   return (This) ? (This->DriverEntries) : NULL;
}

__inline
PDRIVER_ENTRY
OSBOGetNextDriverEntry(
    IN POS_BOOT_OPTIONS This,
    IN PDRIVER_ENTRY PrevDriverEntry
    )
{
   return (This && PrevDriverEntry) ? PrevDriverEntry->NextEntry : NULL;
}


PDRIVER_ENTRY    
OSBOFindDriverEntryByName(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            DriverName
);

PDRIVER_ENTRY
OSBOFindDriverEntryById(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );


__inline
ULONG
OSBOGetOrderedDriverEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->DriverEntryOrderCount;
    }

    return Count;
}

__inline
ULONG
OSBOGetDriverEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    )
{
    ULONG Entry = -1;

    if (Index < OSBOGetOrderedDriverEntryCount(This)) {            
        Entry = This->DriverEntryOrder[Index];
    }

    return Entry;
}

__inline
BOOLEAN
OSDriverEntryFlush(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->Flush(This) : FALSE;
}

__inline
PDRIVER_ENTRY
OSBOAddNewDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            NtDevicePath,
    IN PCWSTR            DirPath
    )
{
    PDRIVER_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->AddNewDriverEntry(This,
                                        FriendlyName,
                                        NtDevicePath,
                                        DirPath);                    
        OSBO_SET_DIRTY(This);
    }

    return Entry;
}

__inline
PCWSTR
OSDriverSetFriendlyName(
    IN PDRIVER_ENTRY This,
    IN PCWSTR Name
    )
{
    PWSTR NewName = NULL;
    
    if (This && Name) {        
        ULONG   Size = ARRAY_SIZE(This->FriendlyName);
        
        wcsncpy(This->FriendlyName, Name, Size - 1);
        This->FriendlyName[Size - 1] = UNICODE_NULL;
        NewName = This->FriendlyName;
        
        DRIVERENT_SET_DIRTY(This);
        DRIVERENT_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}


__inline
PCWSTR
OSDriverSetFileName(
    IN PDRIVER_ENTRY This,
    IN PCWSTR Path
    )
{   
    PWSTR Result = NULL;
    
    if (This && Path && (Path[0] != UNICODE_NULL)) {        
        PCWSTR FileName = wcsrchr((PCWSTR)Path, L'\\');

        if (FileName){
            ULONG  Size = ARRAY_SIZE(This->FileName);

            wcsncpy(This->FileName, FileName+1, Size - 1);
            This->FileName[Size - 1] = UNICODE_NULL;
            Result = This->FileName;
            
            DRIVERENT_SET_DIRTY(This);
            DRIVERENT_SET_DIRTY(This->BootOptions);
        }
    }

    return Result;;
}

__inline
BOOLEAN
OSDriverSetNtPath(
    IN PDRIVER_ENTRY This, 
    IN PCWSTR NtDevicePath
    )
{
    BOOLEAN Result = FALSE;
    
    if (This && NtDevicePath && (NtDevicePath[0] != UNICODE_NULL)){
        ULONG Size = ARRAY_SIZE(This->NtDevicePath);
        
        wcsncpy(This->NtDevicePath, NtDevicePath, Size-1);
        This->NtDevicePath[Size - 1] = UNICODE_NULL;
        
        DRIVERENT_SET_DIRTY(This);
        DRIVERENT_SET_DIRTY(This->BootOptions);
        
        Result = TRUE;
    }
    
    return Result;
}

__inline
BOOLEAN
OSDriverSetDirPath(
    IN PDRIVER_ENTRY This, 
    IN PCWSTR DirPath
    )
{
    BOOLEAN Result = FALSE;
    
    if (This && DirPath && (DirPath[0] != UNICODE_NULL)){
        ULONG Size = ARRAY_SIZE(This->DirPath);
        
        wcsncpy(This->DirPath, DirPath, Size-1);
        This->DirPath[Size - 1] = UNICODE_NULL;
        
        DRIVERENT_SET_DIRTY(This);
        DRIVERENT_SET_DIRTY(This->BootOptions);
        
        Result = TRUE;
    }
    
    return Result;
}

__inline
ULONG    
OSDriverGetId(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->Id : (-1);
}    

__inline
PCWSTR    
OSDriverGetFriendlyName(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->FriendlyName : NULL;
}

__inline
PCWSTR    
OSDriverGetFileName(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->FileName : NULL;
}

__inline
PCWSTR    
OSDriverGetDevicePath(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->NtDevicePath : NULL;
}

__inline
PCWSTR    
OSDriverGetFilePath(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->DirPath : NULL;
}

//
// memory allocation & deallocation routines
//
__inline
void*
__cdecl
SBE_MALLOC(
    IN  size_t  Size
    )
{
    return AllocRoutine ? AllocRoutine(Size) : NULL;
}

__inline
void    
__cdecl 
SBE_FREE(
    IN  void *Memory
    )
{
    if (Memory && FreeRoutine) {
        FreeRoutine(Memory);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\bootini\bootient.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    bootient.h

Abstract:

    Boot.ini boot options and boot entry abstractions

Author:


Revision History:

    None.

--*/

#pragma once

#include <sbentry.h>

//
// Boot.ini extra section abstraction
//
typedef struct _BOI_SECTION *PBOI_SECTION;

typedef struct _BOI_SECTION {
    PBOI_SECTION    Next;
    TCHAR           Name[MAX_PATH];
    PTSTR           Contents;
    DWORD           Size;
} BOI_SECTION;


//
// Boot.ini boot entry abstraction
//
typedef struct _BOI_OS_BOOT_ENTRY {
    OS_BOOT_ENTRY   OsBootEntry;    
} BOI_OS_BOOT_ENTRY, *PBOI_OS_BOOT_ENTRY;

//
// Boot.ini boot options abstraction
//
typedef struct _BOI_OS_BOOT_OPTIONS {
    OS_BOOT_OPTIONS     OsBootOptions;
    TCHAR               BootIniPath[MAX_PATH];
    PBOI_SECTION        Sections;
    ULONG               NextEntryId;
} BOI_OS_BOOT_OPTIONS, *PBOI_OS_BOOT_OPTIONS;


//
// BOI_OS_SECTION Methods
//
PBOI_SECTION
BOISectionCreate(
    IN PCTSTR   SectionData
    );

VOID
BOISectionDelete(
    IN PBOI_SECTION This
    );

__inline
PCTSTR
BOISectionGetName(
    IN PBOI_SECTION This
    )
{
    return (This) ? This->Name : NULL;
}

//
// BOI_OS_BOOT_ENTRY Methods
//
POS_BOOT_ENTRY
BOIOSBECreate(
    IN ULONG Id,
    IN PCTSTR EntryLine,
    IN PBOI_OS_BOOT_OPTIONS Container
    );

VOID
BOIOSBEDelete(
    IN  POS_BOOT_ENTRY  This
    );

BOOLEAN
BOIOSBEFlush(
    IN POS_BOOT_ENTRY This
    );

//
// BOI_OS_BOOT_OPTIONS Methods
//
POS_BOOT_OPTIONS
BOIOSBOCreate(
    IN PCTSTR BootIniPath,
    IN BOOLEAN OpenExisting
    );

    
BOOLEAN
BOIOSBOFlush(
    IN POS_BOOT_OPTIONS This
    );
    
VOID
BOIOSBODelete(
    IN POS_BOOT_OPTIONS This
    );

POS_BOOT_ENTRY
BOIOSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCTSTR            FriendlyName,
    IN PCTSTR            OsLoaderVolumeName,
    IN PCTSTR            OsLoaderPath,
    IN PCTSTR            BootVolumeName,
    IN PCTSTR            BootPath,
    IN PCTSTR            OsLoadOptions
    );

PDRIVER_ENTRY
BOIOSBOAddNewDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            NtDevicePath,
    IN PCWSTR            SrcNtFullPath
    );

BOOLEAN
OSBODeleteDriverEntry(
    IN POS_BOOT_OPTIONS This,
    IN ULONG            Id
    );


__inline
PBOI_SECTION
BOIOSGetFirstSection(
    IN PBOI_OS_BOOT_OPTIONS This
    )
{
    return (This) ? (This->Sections) : NULL;
}

__inline
PBOI_SECTION
BOIOSGetNextSection(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PBOI_SECTION Section
    )
{
    return (This && Section) ? (Section->Next) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\bootini\sbentry.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    sbentry.h

Abstract:

    Contains the OS boot entry and boot options
    abstractions.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/

#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>
#include <tchar.h>

//
// Allocate & Deallocate routines
//
typedef void* (* SBEMemAllocateRoutine)(size_t  Size);
typedef void (* SBEMemFreeRoutine)(void *Memory);

extern SBEMemAllocateRoutine    AllocRoutine;
extern SBEMemFreeRoutine        FreeRoutine;


#define ARRAY_SIZE(x)   (sizeof((x))/sizeof((x)[0]))


//
// Internal attributes for the boot entry
//
#define OSBE_ATTRIBUTE_NEW      0x00000001
#define OSBE_ATTRIBUTE_DELETED  0x00000002
#define OSBE_ATTRIBUTE_OLDOS    0x00000004
#define OSBE_ATTRIBUTE_DIRTY    0x10000000


//
// OS_BOOT_ENTRY abstraction
//
typedef struct _OS_BOOT_ENTRY   *POS_BOOT_ENTRY;
typedef struct _OS_BOOT_OPTIONS *POS_BOOT_OPTIONS;

typedef VOID (* OSBEDeleteMethod)(
                    IN POS_BOOT_ENTRY This
                    );

typedef BOOLEAN (* OSBEFlushMethod)(
                    IN POS_BOOT_ENTRY This
                    );

typedef struct _OS_BOOT_ENTRY {
    //
    // Data members
    //
    ULONG   Version;
    ULONG   Id;    
    TCHAR   FriendlyName[MAX_PATH];
    TCHAR   OsLoaderVolumeName[MAX_PATH];
    TCHAR   OsLoaderPath[MAX_PATH];
    TCHAR   BootVolumeName[MAX_PATH];
    TCHAR   BootPath[MAX_PATH];
    TCHAR   OsLoadOptions[MAX_PATH];
    ULONG   Attributes;
    POS_BOOT_OPTIONS    BootOptions;
    POS_BOOT_ENTRY      NextEntry;

    //
    // Methods
    //
    OSBEDeleteMethod    Delete;
    OSBEFlushMethod     Flush;
} OS_BOOT_ENTRY;

#define OSBE_IS_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_DIRTY)
#define OSBE_IS_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_NEW)
#define OSBE_IS_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_DELETED)
#define OSBE_IS_OLDOS(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes & OSBE_ATTRIBUTE_OLDOS)

#define OSBE_SET_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_DIRTY)
#define OSBE_SET_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_NEW)
#define OSBE_SET_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_DELETED)
#define OSBE_SET_OLDOS(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes |= OSBE_ATTRIBUTE_OLDOS)

#define OSBE_RESET_DIRTY(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_DIRTY)
#define OSBE_RESET_NEW(_osbe)      (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_NEW)
#define OSBE_RESET_DELETED(_osbe)  (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_DELETED)
#define OSBE_RESET_OLDOS(_osbe)    (((POS_BOOT_ENTRY)(_osbe))->Attributes &= ~OSBE_ATTRIBUTE_OLDOS)

//
// Driver Entry Abstraction.
//
typedef struct _DRIVER_ENTRY    *PDRIVER_ENTRY;

typedef VOID (* DriverEntryDeleteMethod)(
                    IN POS_BOOT_OPTIONS  This,
                    IN ULONG             Id
                    );

typedef BOOLEAN (* DriverEntryFlushMethod)(
                    IN PDRIVER_ENTRY This
                    );

typedef struct _DRIVER_ENTRY {
    ULONG               Id;

    WCHAR               FileName[MAX_PATH];
    WCHAR               NtDevicePath[MAX_PATH];
    WCHAR               DirPath[MAX_PATH];
    WCHAR               FriendlyName[MAX_PATH];
    ULONG               Attributes;
    ULONG               FullPathLength;
    ULONG               DevicePathLength;
    
    POS_BOOT_OPTIONS    BootOptions;
    PDRIVER_ENTRY       NextEntry;
    //
    // Methods
    //
    DriverEntryDeleteMethod    Delete;
    DriverEntryFlushMethod     Flush;   
} DRIVER_ENTRY;

//
// OS_BOOT_OPTIONS abstraction
//
typedef VOID (* OSBODeleteMethod)(
                    IN POS_BOOT_OPTIONS This
                    );

typedef BOOLEAN (* OSBOFlushMethod)(
                    IN POS_BOOT_OPTIONS This 
                    );

typedef POS_BOOT_ENTRY (* OSBOAddNewBootEntryMethod)(
                    IN POS_BOOT_OPTIONS This,
                    IN PCTSTR            FriendlyName,
                    IN PCTSTR            OsLoaderVolumeName,
                    IN PCTSTR            OsLoaderPath,
                    IN PCTSTR            BootVolumeName,
                    IN PCTSTR            BootPath,
                    IN PCTSTR            OsLoadOptions
                    );

typedef BOOLEAN (* OSBODeleteBootEntryMethod)(
                    IN POS_BOOT_OPTIONS This,
                    IN POS_BOOT_ENTRY   BootEntry
                    );

typedef PDRIVER_ENTRY (* OSBOAddNewDriverEntryMethod)(
                    IN POS_BOOT_OPTIONS  This,
                    IN PCWSTR            FriendlyName,
                    IN PCWSTR            NtDevicePath,
                    IN PCWSTR            SrcNtFullPath
                    );                        

typedef BOOLEAN (* OSBODeleteDriverEntryMethod)(
                    IN POS_BOOT_OPTIONS This,
                    IN ULONG            Id
                    );



typedef struct _OS_BOOT_OPTIONS {
    //
    // Data members
    //
    ULONG               Version;
    ULONG               Attributes;
    ULONG               Timeout;

    POS_BOOT_ENTRY      BootEntries;
    POS_BOOT_ENTRY      CurrentEntry;    
    ULONG               EntryCount;
    PULONG              BootOrder;
    ULONG               BootOrderCount;

    PDRIVER_ENTRY       DriverEntries;
    PDRIVER_ENTRY       CurrentDriverEntry; 
    ULONG               DriverEntryCount;
    PULONG              DriverEntryOrder;
    ULONG               DriverEntryOrderCount;


    //
    // Methods
    //
    OSBODeleteMethod            Delete;
    OSBOFlushMethod             Flush;
    OSBOAddNewBootEntryMethod   AddNewBootEntry;
    OSBODeleteBootEntryMethod   DeleteBootEntry;  
    OSBOAddNewDriverEntryMethod AddNewDriverEntry;
    OSBODeleteDriverEntryMethod DeleteDriverEntry;    
} OS_BOOT_OPTIONS;

#define OSBO_IS_DIRTY(_osbo)        (((POS_BOOT_OPTIONS)(_osbo))->Attributes & OSBE_ATTRIBUTE_DIRTY)
#define OSBO_SET_DIRTY(_osbo)       (((POS_BOOT_OPTIONS)(_osbo))->Attributes |= OSBE_ATTRIBUTE_DIRTY)
#define OSBO_RESET_DIRTY(_osbo)     (((POS_BOOT_OPTIONS)(_osbo))->Attributes &= ~OSBE_ATTRIBUTE_DIRTY)

//
// Dummy Driver Routines
//

PDRIVER_ENTRY    
OSBOFindDriverEntryByName(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            DriverName
);

//
// OS_BOOT_ENTRY Methods
//
PCTSTR
OSBEAddOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    );

PCTSTR
OSBERemoveOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    );

BOOLEAN
OSBEIsOsLoadOptionPresent(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    );

__inline
VOID
OSBEDelete(
    IN POS_BOOT_ENTRY This
    )
{
    if (This) {
        (This->Delete)(This);
    }
}

__inline
BOOLEAN
OSBEFlush(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->Flush(This) : FALSE;
}


__inline
ULONG
OSBEGetId(
    IN POS_BOOT_ENTRY   This
    )
{
    return (This) ? This->Id : (-1);
}

__inline
PCTSTR
OSBEGetFriendlyName(
    IN POS_BOOT_ENTRY   This
    )
{
    return (This) ? This->FriendlyName : NULL;
}

__inline
PCTSTR
OSBESetFriendlyName(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->FriendlyName);
        
        _tcsncpy(This->FriendlyName, Name, Size - 1);
        This->FriendlyName[Size - 1] = UNICODE_NULL;
        NewName = This->FriendlyName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetOsLoaderVolumeName(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoaderVolumeName : NULL;
}

__inline
PCTSTR
OSBESetOsLoaderVolumeName(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->OsLoaderVolumeName);
        
        _tcsncpy(This->OsLoaderVolumeName, Name, Size - 1);
        This->OsLoaderVolumeName[Size - 1] = UNICODE_NULL;
        NewName = This->OsLoaderVolumeName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetOsLoaderPath(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoaderPath : NULL;
}

__inline
PCTSTR
OSBESetOsLoaderPath(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->OsLoaderPath);
        
        _tcsncpy(This->OsLoaderPath, Name, Size - 1);
        This->OsLoaderPath[Size - 1] = UNICODE_NULL;
        NewName = This->OsLoaderPath;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetBootVolumeName(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->BootVolumeName : NULL;
}

__inline
PCTSTR
OSBESetBootVolumeName(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->BootVolumeName);        
    
        _tcsncpy(This->BootVolumeName, Name, Size - 1);
        This->BootVolumeName[Size - 1] = UNICODE_NULL;
        NewName = This->BootVolumeName;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetBootPath(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->BootPath : NULL;
}

__inline
PCTSTR
OSBESetBootPath(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR Name
    )
{
    PTSTR NewName = NULL;
    
    if (This && Name) {
        ULONG   Size = ARRAY_SIZE(This->BootPath);        
    
        _tcsncpy(This->BootPath, Name, Size - 1);
        This->BootPath[Size - 1] = UNICODE_NULL;
        NewName = This->BootPath;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewName;
}

__inline
PCTSTR
OSBEGetOsLoadOptions(
    IN POS_BOOT_ENTRY This
    )
{
    return (This) ? This->OsLoadOptions : NULL;
}
    
__inline
PCTSTR
OSBESetOsLoadOptions(
    IN POS_BOOT_ENTRY This,
    IN PCTSTR LoadOptions
    )
{
    TCHAR Buffer[MAX_PATH];
    PTSTR NewOptions = NULL;
    
    if (This && LoadOptions) {
        ULONG   Size = ARRAY_SIZE(This->OsLoadOptions);
        
        _tcscpy(Buffer, LoadOptions);
        _tcsupr(Buffer);
        _tcsncpy(This->OsLoadOptions, Buffer, Size - 1);
        This->OsLoadOptions[Size - 1] = UNICODE_NULL;
        NewOptions = This->OsLoadOptions;
        OSBE_SET_DIRTY(This);
        OSBO_SET_DIRTY(This->BootOptions);
    }

    return NewOptions;
}

//
// OS_BOOT_OPTIONS Methods
//   
__inline
BOOLEAN
OSBOFlush(
    IN POS_BOOT_OPTIONS This
    )
{
    return (This) ? (This->Flush(This)) : FALSE;
}
    
__inline    
VOID
OSBODelete(
    IN POS_BOOT_OPTIONS This
    )
{
    if (This) {
        This->Delete(This);
    }        
}

__inline
POS_BOOT_ENTRY
OSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCTSTR            FriendlyName,
    IN PCTSTR            OsLoaderVolumeName,
    IN PCTSTR            OsLoaderPath,
    IN PCTSTR            BootVolumeName,
    IN PCTSTR            BootPath,
    IN PCTSTR            OsLoadOptions
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->AddNewBootEntry(This,
                            FriendlyName,
                            OsLoaderVolumeName,
                            OsLoaderPath,
                            BootVolumeName,
                            BootPath,
                            OsLoadOptions);                    
        OSBO_SET_DIRTY(This);
    }

    return Entry;
}


__inline
POS_BOOT_ENTRY
OSBOGetActiveBootEntry(
    IN POS_BOOT_OPTIONS This
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        Entry = This->CurrentEntry;
    }
    
    return Entry;
}


BOOLEAN
OSBODeleteBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    );
    

POS_BOOT_ENTRY
OSBOSetActiveBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    );

ULONG
OSBOGetBootEntryCount(
    IN POS_BOOT_OPTIONS This
    );

ULONG
OSBOGetOrderedBootEntryCount(
    IN POS_BOOT_OPTIONS This
    );

ULONG
OSBOGetBootEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    );

POS_BOOT_ENTRY
OSBOFindBootEntry(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );

ULONG
OSBOFindBootEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    );    

__inline
ULONG
OSBOGetTimeOut(
    IN  POS_BOOT_OPTIONS    This
    )
{
    return (This) ? This->Timeout : 0;
}

__inline
ULONG
OSBOSetTimeOut(
    IN  POS_BOOT_OPTIONS    This,
    IN  ULONG Timeout
    )
{
    ULONG   OldTimeout = 0;

    if (This) {
        OldTimeout = This->Timeout;
        This->Timeout = Timeout;
        OSBE_SET_DIRTY(This);
    }

    return OldTimeout;
}

__inline
ULONG
OSBOGetBootEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->EntryCount;
    }

    return Count;
}


__inline
ULONG
OSBOGetOrderedBootEntryCount(
    IN POS_BOOT_OPTIONS This
    )
{
    ULONG Count = 0;

    if (This) {
        Count = This->BootOrderCount;
    }

    return Count;
}

__inline
ULONG
OSBOGetBootEntryIdByOrder(
    IN POS_BOOT_OPTIONS This,
    IN ULONG Index
    )
{
    ULONG Entry = -1;

    if (Index < OSBOGetOrderedBootEntryCount(This)) {            
        Entry = This->BootOrder[Index];
    }

    return Entry;
}

__inline
BOOLEAN
OSBOLibraryInit(
    SBEMemAllocateRoutine AllocFunction,
    SBEMemFreeRoutine FreeFunction
    )
{
    BOOLEAN Result = FALSE;

    if (AllocFunction && FreeFunction) {
        AllocRoutine = AllocFunction;
        FreeRoutine = FreeFunction;

        Result = TRUE;
    }

    return Result;
}

__inline
POS_BOOT_ENTRY
OSBOGetFirstBootEntry(
    IN POS_BOOT_OPTIONS This
    )
{
    return (This) ? (This->BootEntries) : NULL;
}
    

__inline
POS_BOOT_ENTRY
OSBOGetNextBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY PrevEntry
    )
{
    return (This && PrevEntry) ? PrevEntry->NextEntry : NULL;
}

//
// Driver dummy routines
//
__inline
ULONG    
OSDriverGetId(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->Id : (-1);
}    

__inline
PCWSTR    
OSDriverGetFriendlyName(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->FriendlyName : NULL;
}

__inline
PCWSTR    
OSDriverGetFileName(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->FileName : NULL;
}

__inline
PCWSTR    
OSDriverGetDevicePath(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? This->NtDevicePath : NULL;
}

__inline
PCWSTR    
OSDriverGetFilePath(
    IN PDRIVER_ENTRY This
    )
{
    return (This) ? (This->DirPath ) : NULL;
}

__inline
BOOLEAN
OSBODeleteDriverEntry(
    IN POS_BOOT_OPTIONS This,
    IN ULONG            Id
    );

//
// memory allocation & deallocation routines
//
__inline
void*
__cdecl
SBE_MALLOC(
    IN  size_t  Size
    )
{
    return AllocRoutine ? AllocRoutine(Size) : NULL;
}

__inline
void    
__cdecl 
SBE_FREE(
    IN  void *Memory
    )
{
    if (Memory && FreeRoutine) {
        FreeRoutine(Memory);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\efi\efidrvent.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    efidrvent.c

Abstract:

    Contains the EFI driver entry abstraction implementation.

Author:

    Mandar Gokhale (MandarG@microsoft.com) 14-June-2002

Revision History:

    None.

--*/

#include <efidrvent.h>
#include <ntosp.h>
#include <efi.h>
#include <stdio.h>


static
NTSTATUS
EFIDEAddOrUpdateDriverEntry(
    IN PDRIVER_ENTRY    This,
    IN BOOLEAN          IsUpdate
    )
/*++
    Description:
        Modify or update a driver entry.

    Arguments:
        This - Driver entry .

        IsUpdate -  whether this is a driver entry update or add.

    Return Value:
        NTSTATUS or add/modify driver operation.
--*/
{
    //
    // Add this as new boot entry
    //                
    ULONG               FullPathLength = 0;
    ULONG               DevicePathLength = 0;
    ULONG               SrcPathLength = 0;
    ULONG               FriendlyNameOffset = 0;
    ULONG               FriendlyNameLength = 0;
    ULONG               FilePathLength     = 0;   
    ULONG               EntryLength        = 0;   
    ULONG               DriverEntryLength  = 0;
    PEFI_DRIVER_ENTRY   DriverEntry = NULL;
    PFILE_PATH          FilePath;
    NTSTATUS            Status;

    DevicePathLength = (wcslen((PCWSTR)This->NtDevicePath)+ 1) * sizeof(WCHAR);
    SrcPathLength = (wcslen((PCWSTR)This->DirPath) + 1) * sizeof(WCHAR);
    FullPathLength = DevicePathLength + SrcPathLength;
    
    FriendlyNameOffset = ALIGN_UP(sizeof(EFI_DRIVER_ENTRY), WCHAR);
    FriendlyNameLength = (wcslen(This->FriendlyName) + 1) * sizeof(WCHAR);
    FilePathLength = FIELD_OFFSET(FILE_PATH, FilePath) + FullPathLength;
    EntryLength = FriendlyNameOffset + ALIGN_UP(FriendlyNameLength, ULONG) + FilePathLength;
    DriverEntry = SBE_MALLOC(EntryLength);

    DriverEntry->Version = EFI_DRIVER_ENTRY_VERSION;
    DriverEntry->Length = EntryLength;
    DriverEntry->FriendlyNameOffset = FriendlyNameOffset;
    DriverEntry->DriverFilePathOffset = FriendlyNameOffset + 
                                        ALIGN_UP(FriendlyNameLength, ULONG);
    RtlCopyMemory((PCHAR) DriverEntry + DriverEntry->FriendlyNameOffset, 
                  This->FriendlyName, 
                  FriendlyNameLength);

    FilePath = (PFILE_PATH) ((PCHAR) DriverEntry + DriverEntry->DriverFilePathOffset);
    FilePath->Version = FILE_PATH_VERSION;
    FilePath->Length = FilePathLength;
    FilePath->Type = FILE_PATH_TYPE_NT;
    RtlCopyMemory(FilePath->FilePath, This->NtDevicePath, DevicePathLength );
    RtlCopyMemory(FilePath->FilePath + DevicePathLength, This->DirPath, SrcPathLength);

    if (IsUpdate){
        //
        // Update the driver.
        //
        DriverEntry->Id = This->Id;
        Status = NtModifyDriverEntry(DriverEntry);
    } else {
        //
        // Add a new driver entry.
        //
        Status = NtAddDriverEntry(DriverEntry, &(This->Id));          
    }

    //
    // Free allocated memory.
    //
    if(DriverEntry){
        
        SBE_FREE(DriverEntry);
    }
    return Status;
}
    

static
BOOLEAN
EFIDEFlushDriverEntry(
    IN  PDRIVER_ENTRY  This    // Points to the driver List.
    )
{

    BOOLEAN Result = FALSE;
    if (This) {
        NTSTATUS Status = STATUS_SUCCESS;
        if (DRIVERENT_IS_DIRTY(This)) {
            
            if (DRIVERENT_IS_DELETED(This)) {
                //
                // Delete this entry
                //
                Status = NtDeleteDriverEntry(This->Id);
            } else if (DRIVERENT_IS_NEW(This)) {
                //
                // Add new Entry.
                //
                Status = EFIDEAddOrUpdateDriverEntry(This, FALSE);                                      
                
            } else {
                //
                // Just update this boot entry
                //
                Status = EFIDEAddOrUpdateDriverEntry(This, TRUE);                           
            }

            if (NT_SUCCESS(Status)) {
                
                DRIVERENT_RESET_DIRTY(This);
                Result = TRUE;
            }     
            
        } else {
            Result = TRUE;  // nothing to flush
        }
    }

    return Result;
}

__inline
BOOLEAN
EFIDEDriverMatch(
    IN PDRIVER_ENTRY    DriverEntry ,
    IN PCWSTR           SrcNtFullPath
    )
{
    BOOLEAN Result = FALSE;
    
    if (!_wcsicmp(DriverEntry->FileName, (wcsrchr(SrcNtFullPath,L'\\')+1))){
        
        Result = TRUE;
    }

    return(Result);
}

static
PDRIVER_ENTRY    
EFIDESearchForDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            SrcNtFullPath
    )
/*++
Description:
    Searches our internal list of driver entries for a match.
    It looks up the driver name (not including the path)
    for a match. so a\b\c\driver.sys and e\f\driver.sys would be a match.
--*/
{
    PDRIVER_ENTRY CurrentDriverEntry = NULL;   
    
    if (This && SrcNtFullPath){
        
        CurrentDriverEntry = This->DriverEntries;        
        while (CurrentDriverEntry){
            
            if (EFIDEDriverMatch(CurrentDriverEntry, 
                               SrcNtFullPath)){                               
                break;                               
            }
            CurrentDriverEntry = OSBOGetNextDriverEntry(This, CurrentDriverEntry);
        }
        
    }   
    return (CurrentDriverEntry);
}

PDRIVER_ENTRY
EFIDECreateNewDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            NtDevicePath,
    IN PCWSTR            DirPath    
    )
{
    PDRIVER_ENTRY DriverEntry = NULL;
    if (This && FriendlyName && DirPath && NtDevicePath){        
        PDRIVER_ENTRY CurrentDriverEntry = NULL;

        DriverEntry = (PDRIVER_ENTRY)SBE_MALLOC(sizeof(DRIVER_ENTRY));
        memset(DriverEntry, 0, sizeof(DRIVER_ENTRY));

        EFIDEDriverEntryInit(DriverEntry);
        DriverEntry->BootOptions = This;        
        //
        // Set information for the driver entry.
        //
        OSDriverSetFileName(DriverEntry, DirPath);
        OSDriverSetNtPath(DriverEntry, NtDevicePath);
        OSDriverSetDirPath(DriverEntry, DirPath);
        
        OSDriverSetFriendlyName(DriverEntry, FriendlyName);        

        
        //
        // Mark the driver entry new and dirty.
        //
        DRIVERENT_SET_NEW(DriverEntry);
        DRIVERENT_SET_DIRTY(DriverEntry);        
    }   
    return (DriverEntry);
}

PDRIVER_ENTRY
EFIOSBOInsertDriverListNewEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PDRIVER_ENTRY     DriverEntry
    )

{

    if (This && DriverEntry){        
        PDRIVER_ENTRY CurrentDriverEntry = NULL;        
        //
        // Insert into the list.
        //        
        if (NULL == This->DriverEntries){
            //
            // No driver entries, this is the first one.
            //
            This->DriverEntries = DriverEntry;
        }else{
            //
            // Insert in the existing list.
            //
            DriverEntry->NextEntry = This->DriverEntries;
            This->DriverEntries = DriverEntry;            
        }        
    }   
    return (DriverEntry);

}

PDRIVER_ENTRY
EFIDEAddNewDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            NtDevicePath,
    IN PCWSTR            SrcNtFullPath
    )
/*++

Description:
    Used to add a new driver entry in NVRAM.

--*/
{   
    PEFI_DRIVER_ENTRY_LIST DriverList = NULL;       // list of driver entries
    PDRIVER_ENTRY  DriverEntry = NULL;
    if (This && FriendlyName && SrcNtFullPath && NtDevicePath){
        
        DriverEntry = EFIDECreateNewDriverEntry(This,
                                                FriendlyName,
                                                NtDevicePath,
                                                SrcNtFullPath);
        //
        // Mark it as new
        //
        DRIVERENT_IS_NEW(DriverEntry);
       
        //
        // flush the entry, 
        // see status, if successful put it in the list (only if new) 
        // otherwise free it
        //
        if (!OSDriverEntryFlush(DriverEntry)){
            
            SBE_FREE(DriverEntry);
            DriverEntry = NULL;
        } else {
        
            ULONG   OrderCount;
            PULONG  NewOrder;
            //
            // If the driver was newly added one then insert it in the driver list.
            //
            if (DRIVERENT_IS_NEW(DriverEntry)){
                EFIOSBOInsertDriverListNewEntry(This,
                                                DriverEntry);                                         

                //
                // Increment the count of the number of driver entries in the list.
                //
                This->DriverEntryCount++;
                
                //
                // Put the new entry at the end of the boot order
                //
                OrderCount = OSBOGetOrderedDriverEntryCount(This);

                NewOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

                if (NewOrder) {
                    
                    memset(NewOrder, 0, sizeof(ULONG) * (OrderCount + 1));

                    //
                    // copy over the old ordered list
                    //
                    memcpy(NewOrder, This->DriverEntryOrder, sizeof(ULONG) * OrderCount);
                    NewOrder[OrderCount] = OSDriverGetId((PDRIVER_ENTRY)DriverEntry);
                    SBE_FREE(This->DriverEntryOrder);
                    This->DriverEntryOrder = NewOrder;
                    This->DriverEntryOrderCount = OrderCount + 1;
                } else {
                    //
                    // Remove the driver entry out of the link list.
                    // Just freeing it will cause memory leaks.
                    // TBD: decide if we want to delete this driver entry too
                    //
                    This->DriverEntries = DriverEntry->NextEntry;
                    SBE_FREE(DriverEntry);
                    DriverEntry = NULL;
                }  
            }
        }        
     }           
    return DriverEntry;
}

__inline
ULONG
EFIDESetDriverId(
    IN PDRIVER_ENTRY This,
    IN ULONG DriverId
    )
{
    if (This){        
        This->Id = DriverId;
    }
    return (DriverId);
}

PDRIVER_ENTRY
EFIDECreateDriverEntry(PEFI_DRIVER_ENTRY_LIST Entry, 
                       POS_BOOT_OPTIONS This )
/*++
    Description:
        Used to interpret a driver entry returned by NtEnumerateDriverEntries(..)
        into our format.

    Arguments:
        Entry - EFI format driver entry returned to us by NT.
        
        This - container for the driver entry list that we generate.

    Return:
        PDRIVER_ENTRY ( driver entry in our format).
--*/

{
    PDRIVER_ENTRY ResultDriverEntry = NULL;

    if (Entry && This){
        PFILE_PATH      FilePath = (PFILE_PATH) ((PCHAR) &Entry->DriverEntry + 
                                    Entry->DriverEntry.DriverFilePathOffset);
        PWCHAR          FriendlyName = (PWCHAR)((PCHAR)&Entry->DriverEntry + 
                                        Entry->DriverEntry.FriendlyNameOffset);
        ULONG           NtDevicePathLength = 0;
        PDRIVER_ENTRY   DriverEntry = NULL;    
        PFILE_PATH      DriverOptionPath = NULL;
        NTSTATUS   Status = STATUS_UNSUCCESSFUL;

        if(FilePath->Type != FILE_PATH_TYPE_NT) {                    
            PVOID Buffer;
            ULONG PathLength = 0;
            
            Status = NtTranslateFilePath(FilePath, FILE_PATH_TYPE_NT, NULL, &PathLength);

            if(NT_SUCCESS(Status)) {
                
                Status = STATUS_UNSUCCESSFUL;
            }

            if(STATUS_BUFFER_TOO_SMALL == Status) {
                
                ASSERT(PathLength != 0); 
                
                DriverOptionPath = (PFILE_PATH)SBE_MALLOC(PathLength);
                memset(DriverOptionPath, 0, sizeof(PathLength));
                Status = NtTranslateFilePath(FilePath, 
                                            FILE_PATH_TYPE_NT, 
                                            DriverOptionPath, 
                                            &PathLength);
            }

            if(!NT_SUCCESS(Status)) {                
                if(STATUS_OBJECT_PATH_NOT_FOUND == Status || STATUS_OBJECT_NAME_NOT_FOUND == Status) {
                    //
                    // This entry is stale; remove it
                    //
                    NtDeleteDriverEntry(Entry->DriverEntry.Id);
                }

                //
                // Free the DriverOptionPath memory
                //
                if(DriverOptionPath != NULL) {                    
                    SBE_FREE(DriverOptionPath);
                    DriverOptionPath = NULL;
                }
            }
            
        }
        if (DriverOptionPath){
            
            ULONG FilePathLength = 0;
            DriverEntry = (PDRIVER_ENTRY)SBE_MALLOC(sizeof(DRIVER_ENTRY));
            memset(DriverEntry, 0, sizeof(DRIVER_ENTRY));
            
            //
            // Set pointer back to boot options (container).
            //
            DriverEntry->BootOptions = This;

            EFIDEDriverEntryInit(DriverEntry);
        
            //
            // Set driver ID.
            //
            EFIDESetDriverId(DriverEntry, Entry->DriverEntry.Id);

            //
            // Set File Name.
            //
            NtDevicePathLength = wcslen((PCWSTR) DriverOptionPath->FilePath) + 1;
            OSDriverSetFileName(DriverEntry, 
                              (PCWSTR) DriverOptionPath->FilePath + NtDevicePathLength);                

            //
            // Set NT path and Driver dir.  
            //            
            OSDriverSetNtPath(DriverEntry, (PCWSTR)DriverOptionPath->FilePath);
            OSDriverSetDirPath(DriverEntry, (PCWSTR)(DriverOptionPath->FilePath) + NtDevicePathLength);

            //
            // Set Friendly Name.
            //
            OSDriverSetFriendlyName(DriverEntry, FriendlyName);   

            //
            // Free the DriverOptionPath memory
            //
            if(DriverOptionPath != NULL) {                    
                SBE_FREE(DriverOptionPath);
            }

            ResultDriverEntry = DriverEntry;
        }
    }
    return ResultDriverEntry;
}


NTSTATUS
EFIDEInterpretDriverEntries(
    IN POS_BOOT_OPTIONS         This,
    IN PEFI_DRIVER_ENTRY_LIST   DriverList
)
/*++
    Description:
        Used to interpret the driver entries returned by NtEnumerateDriverEntries(..)
        into our format.

    Arguments:
        This - container for the driver entry list that we generate.

        DriverList - Driver list returned by NtEnumerateDriverEntries(..).

    Return:
        NTSTATUS code.
--*/
{       
    NTSTATUS                Status = STATUS_UNSUCCESSFUL;
    
    if (This && DriverList){
        
        PEFI_DRIVER_ENTRY_LIST  Entry;   
        PDRIVER_ENTRY           DriverEntry = NULL;
        BOOLEAN                 Continue = TRUE;


        Status = STATUS_SUCCESS;
        for(Entry = DriverList; 
            Continue; 
            Entry = (PEFI_DRIVER_ENTRY_LIST) ((PCHAR) Entry + 
                                              Entry->NextEntryOffset)) {                                              

            Continue = (Entry->NextEntryOffset != 0);            
            DriverEntry = EFIDECreateDriverEntry(Entry, This);

            if (DriverEntry){
                //
                // Insert into the list of drivers in the OSBO structure.
                //
                if (NULL == This->DriverEntries){
                    This->DriverEntries = DriverEntry;                
                } else{
                    DriverEntry->NextEntry = This->DriverEntries;
                    This->DriverEntries = DriverEntry;
                }
                
                This->DriverEntryCount++;
            }
        }            
    }

    return Status;
}

static
VOID
EFIDEDriverEntryInit(
    IN PDRIVER_ENTRY This
    )
{ 
    This->Flush  = EFIDEFlushDriverEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\bootini\bootient.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    bootient.c

Abstract:

    Contains the Boot.ini OS boot entry and boot options
    abstraction implementation.

Author:


Revision History:

    None.

--*/

#include <bootient.h>

//
// defines
//
#define BOIOS_SECTION_NAME_START    TEXT('[')
#define BOIOS_SECTION_NAME_END      TEXT(']')
#define BOIOS_SECTION_NAME_START_STR    TEXT("[")
#define BOIOS_SECTION_NAME_END_STR      TEXT("]")


#define BOIOS_BOOTLOADER_SECTION    TEXT("boot loader")
#define BOIOS_OS_SECTION            TEXT("operating systems")
#define BOIOS_TIMEOUT_KEY           TEXT("timeout=")
#define BOIOS_DEFAULT_KEY           TEXT("default=")

#define MAX_BOOT_INI_SIZE           (4 * 1024)

static
PTSTR
BOIOSFixupString(
    IN PTSTR String,
    IN PTSTR SpecialChars
    )
{    
    PTSTR   ResultStr = String;

    //
    // Verify arguments
    //
    if (ResultStr && SpecialChars) {        
        ULONG   Index;
        BOOLEAN DoneWithStart = FALSE;
        TCHAR   Buffer[MAX_PATH * 4] = {0};
        TCHAR   NextIndex = 0;        

        //
        // skip unwanted characters
        //
        for (Index = 0; String[Index]; Index++) {
            if (!_tcschr(SpecialChars, String[Index])) {
                Buffer[NextIndex++] = String[Index];
            }
        }

        //
        // Null terminate the string
        //
        Buffer[NextIndex] = 0;

        if (!NextIndex) {
            ResultStr = NULL;
        } else {
            //
            // Copy back the new string to the 
            // input / output buffer
            //
            _tcscpy(ResultStr, Buffer);
        }
    }

    return ResultStr;
}

//
// BOI_OS_SECTION Methods
//
PBOI_SECTION
BOISectionCreate(
    IN PCTSTR   SectionData
    )
{
    PBOI_SECTION    This = NULL;

    if (SectionData) {
        PTSTR Buffer = (PTSTR)SBE_MALLOC((_tcslen(SectionData) + 1) * sizeof(TCHAR));

        if (Buffer && _tcscpy(Buffer, SectionData)) {
            PTSTR   SectionNameStart = _tcschr(Buffer, BOIOS_SECTION_NAME_START);
            PTSTR   SectionNameEnd = _tcschr(Buffer, BOIOS_SECTION_NAME_END);
            BOOLEAN Result = FALSE;

            if (SectionNameStart && SectionNameEnd && (SectionNameEnd > SectionNameStart)) {
                This = (PBOI_SECTION)SBE_MALLOC(sizeof(BOI_SECTION));

                if (*Buffer && This) {
                    DWORD   DataLength = (_tcslen(Buffer) + 1) * sizeof(TCHAR);

                    DataLength -= (((SectionNameEnd + 1) - Buffer) * sizeof(TCHAR));

                    //
                    // Init default object state
                    //
                    memset(This, 0, sizeof(BOI_SECTION));

                    //
                    // Get the name
                    //
                    _tcsncpy(This->Name, SectionNameStart + 1, 
                        SectionNameEnd - SectionNameStart - 1);


                    //
                    // Replicate the contents and keep it
                    //
                    This->Contents =  (PTSTR)SBE_MALLOC(DataLength);

                    if (This->Contents) {
                        _tcscpy(This->Contents, SectionNameEnd + 1);
                        Result = TRUE;
                    } else {
                        Result = FALSE;
                    }                    
                }

                if (!Result) {
                    BOISectionDelete(This);
                    This = NULL;
                }
            }

            SBE_FREE(Buffer);
        }            
    }

    return This;
}

VOID
BOISectionDelete(
    IN PBOI_SECTION This
    )
{
    if (This) {
        if (This->Contents) {
            SBE_FREE(This->Contents);
        }

        SBE_FREE(This);
    }
}

static
BOOLEAN
BOISectionWrite(
    IN PBOI_SECTION This,
    IN OUT PTSTR Buffer
    )
{
    BOOLEAN Result = FALSE;
    
    if (This && Buffer) {
        _tcscat(Buffer, BOIOS_SECTION_NAME_START_STR);
        _tcscat(Buffer, BOISectionGetName(This));
        _tcscat(Buffer, BOIOS_SECTION_NAME_END_STR);
        _tcscat(Buffer, TEXT("\r\n"));

        if (This->Contents) {
            _tcscat(Buffer, This->Contents);
        }            
    }

    return Result;
}


//
// BOI_OS_BOOT_ENTRY Methods
//

static
VOID
BOIOSBEInit(
    IN PBOI_OS_BOOT_ENTRY This
    )
{
    This->OsBootEntry.Delete = BOIOSBEDelete;
    This->OsBootEntry.Flush = BOIOSBEFlush;
}

PBOI_SECTION
BOIOSBOFindSection(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PTSTR SectionName
    )
{
    PBOI_SECTION Entry = NULL;

    for (Entry = This->Sections; Entry; Entry = Entry->Next) {
        if (!_tcsicmp(Entry->Name, SectionName)) {
            break;  // found the required section
        }
    }

    return Entry;
}

static
POS_BOOT_ENTRY
BOIOSBECreate(
    IN ULONG  Id,
    IN PCTSTR BootEntryLine,
    IN PBOI_OS_BOOT_OPTIONS Container
    )
{    
    POS_BOOT_ENTRY  Entry = NULL;

    if (BootEntryLine && Container) {
        BOOLEAN Result = FALSE;
        TCHAR   Buffer[MAX_PATH * 4];
        TCHAR   Token[MAX_PATH];
        PBOI_OS_BOOT_ENTRY  BootEntry = (PBOI_OS_BOOT_ENTRY)SBE_MALLOC(sizeof(BOI_OS_BOOT_ENTRY));
        POS_BOOT_ENTRY BaseBootEntry = (POS_BOOT_ENTRY)BootEntry;
                
        //
        // Replicate the input string
        //
        _tcsncpy(Buffer, BootEntryLine, sizeof(Buffer)/sizeof(TCHAR));

        //
        // Remove unwanted charcters in the string
        //
        if (BootEntry && BOIOSFixupString(Buffer, TEXT("\n\r"))) {
            PTSTR   EqualSign = _tcschr(Buffer, TEXT('='));

            //
            // Initialize object state
            //
            memset(BootEntry, 0, sizeof(BOI_OS_BOOT_ENTRY));
            BOIOSBEInit(BootEntry);            
            BaseBootEntry->Id = Id;
            BaseBootEntry->BootOptions = (POS_BOOT_OPTIONS)Container;

            if (EqualSign) {
                PTSTR Slash;
                
                *EqualSign = 0;                
                Slash = _tcschr(Buffer, TEXT('\\'));

                if (Slash) {
                    PTSTR   NameStart = NULL, NameEnd = NULL;
                    PTSTR   NextToken = NULL;

                    Result = TRUE;
                    *Slash = 0;

                    //
                    // Parse & set the boot device name
                    //
                    _tcscpy(Token, Buffer);
                    BOIOSFixupString(Token, TEXT("\n\r "));
                    _tcslwr(Token);
                    OSBESetBootVolumeName(BaseBootEntry, Token);

                    //
                    // if it starts with "C:" its either old OS,
                    // or CmdCons or WinPE or Setup entry
                    //
                    if (_tcschr(Token, TEXT(':'))) {
                        OSBE_SET_OLDOS(BaseBootEntry);
                    }

                    //
                    // Parse & set the boot path
                    //
                    _tcscpy(Token, Slash + 1);
                    BOIOSFixupString(Token, TEXT("\n\r "));
                    OSBESetBootPath(BaseBootEntry, Token);


                    //
                    // Parse & set the friendly name
                    //                    
                    NameStart = _tcschr(EqualSign + 1, TEXT('\"'));

                    //
                    // Set friendly name
                    //
                    if (NameStart) {                        
                        NameEnd = _tcschr(NameStart + 1, TEXT('\"'));
                    }                        

                    if (NameEnd) {  
                        _tcsncpy(Token, NameStart, NameEnd - NameStart);
                        Token[NameEnd - NameStart] = 0;
                        BOIOSFixupString(Token, TEXT("\r\n\""));
                        OSBESetFriendlyName(BaseBootEntry, Token);
                    } else {
                        Result = FALSE;
                    }                        

                    //
                    // Set osload options 
                    //                    
                    NextToken = _tcschr(EqualSign + 1, TEXT('/'));

                    if (NextToken) {  
                        _tcscpy(Token, NextToken);
                        BOIOSFixupString(Token, TEXT("\r\n"));
                        OSBESetOsLoadOptions(BaseBootEntry, Token);
                    }                        
                }                    
            }

            if (!Result) {
                SBE_FREE(BaseBootEntry);
                BaseBootEntry = NULL;
            } else {
                Entry = BaseBootEntry;
            }                
        }
    }

    return Entry;
}

static
VOID
BOIOSBEDelete(
    IN  POS_BOOT_ENTRY  Obj
    )
{
    PBOI_OS_BOOT_ENTRY  This = (PBOI_OS_BOOT_ENTRY)Obj;
    
    if (This) {
        SBE_FREE(This);
    }        
}

static
BOOLEAN
BOIOSBEWrite(
    IN POS_BOOT_ENTRY  This,
    IN OUT PTSTR Buffer
    )
{
    BOOLEAN Result = FALSE;

    if (This && Buffer && !OSBE_IS_DELETED(This)) {
        _tcscat(Buffer, OSBEGetBootVolumeName(This));
        _tcscat(Buffer, TEXT("\\"));
        _tcscat(Buffer, OSBEGetBootPath(This));
        _tcscat(Buffer, TEXT("="));
        _tcscat(Buffer, TEXT("\""));
        _tcscat(Buffer, OSBEGetFriendlyName(This));
        _tcscat(Buffer, TEXT("\""));
        _tcscat(Buffer, TEXT(" "));
        _tcscat(Buffer, OSBEGetOsLoadOptions(This));
        _tcscat(Buffer, TEXT("\r\n"));
        Result = TRUE;
    }

    return Result;
}


static
BOOLEAN
BOIOSBEFlush(
    IN  POS_BOOT_ENTRY  Obj
    )
{
    return TRUE;   // currently can't flush individual entries
}

//
// BOI_OS_BOOT_OPTIONS Methods
//
static
VOID
BOIOSBOInit(
    IN PBOI_OS_BOOT_OPTIONS  This
    )
{
    This->OsBootOptions.Delete = BOIOSBODelete;
    This->OsBootOptions.Flush = BOIOSBOFlush;
    This->OsBootOptions.AddNewBootEntry = BOIOSBOAddNewBootEntry;
    This->OsBootOptions.DeleteBootEntry = OSBODeleteBootEntry;
    This->OsBootOptions.AddNewDriverEntry = BOIOSBOAddNewDriverEntry;
    This->OsBootOptions.DeleteDriverEntry = OSBODeleteDriverEntry;
}

BOOLEAN
BOIOSBOParseAndCreateBootEntries(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PBOI_SECTION Section    
    )
{
    BOOLEAN Result = FALSE;

    if (This && Section) {
        Result = TRUE;
    
        if (Section->Contents) {
            PTSTR   NextLineStart = Section->Contents;
            PTSTR   NextLineEnd;
            TCHAR   OldChar;
            POS_BOOT_ENTRY  FirstBootEntry = NULL;
            POS_BOOT_ENTRY  BootEntry = NULL;
            POS_BOOT_ENTRY  LastBootEntry = NULL;
            ULONG BootEntryCount;

            while (NextLineStart) {
                NextLineEnd = _tcschr(NextLineStart, TEXT('\r'));

                if (NextLineEnd) {
                    if (*(NextLineEnd + 1) == TEXT('\n')) {
                        NextLineEnd++;
                    }

                    NextLineEnd++;
                    OldChar = *NextLineEnd;
                    *NextLineEnd = 0;
                }                    

                //
                // Each boot entry line needs to be more than 2 characters in 
                // length and contain an entry of "a=b" form
                //
                if ((!NextLineEnd || ((NextLineEnd - NextLineStart) > 2)) &&
                    (_tcschr(NextLineStart, TEXT('=')))) {
                    BootEntry = BOIOSBECreate(This->NextEntryId++, NextLineStart, This);

                    if (BootEntry) {
                        This->OsBootOptions.EntryCount++;

                        if (!FirstBootEntry) {
                            FirstBootEntry = LastBootEntry = BootEntry;
                        } else {
                            LastBootEntry->NextEntry = BootEntry;
                            LastBootEntry = BootEntry;
                        }                                            
                    } else {
                        Result = FALSE;

                        break;  // don't continue on
                    }                                                                            
                }                    

                if (NextLineEnd) {
                    *NextLineEnd = OldChar;
                }

                NextLineStart = NextLineEnd;
            }

            This->OsBootOptions.BootEntries = FirstBootEntry;
            
            //
            // Initialize the boot order array
            // NOTE : Doesn't make much sense with boot.ini currently
            //
            BootEntryCount = OSBOGetBootEntryCount((POS_BOOT_OPTIONS)This);

            if (BootEntryCount) {
                PULONG  BootOrder = (PULONG)SBE_MALLOC(BootEntryCount * sizeof(ULONG));

                if (BootOrder) {
                    ULONG Index = 0;
                    memset(BootOrder, 0, sizeof(ULONG) * BootEntryCount);

                    BootEntry = OSBOGetFirstBootEntry((POS_BOOT_OPTIONS)This);

                    while (BootEntry && (Index < BootEntryCount)) {
                        BootOrder[Index] = OSBEGetId(BootEntry);
                        BootEntry = OSBOGetNextBootEntry((POS_BOOT_OPTIONS)This, BootEntry);
                    }

                    This->OsBootOptions.BootOrder = BootOrder;
                    This->OsBootOptions.BootOrderCount = BootEntryCount;
                }
            }
        }
    }

    return Result;
}

BOOLEAN
BOIOSBOParseTimeoutAndActiveEntry(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PBOI_SECTION Section
    )
{
    BOOLEAN Result = FALSE;

    if (This && Section && !_tcsicmp(Section->Name, BOIOS_BOOTLOADER_SECTION)) {
        TCHAR   Buffer[MAX_PATH * 2];
        TCHAR   Timeout[MAX_PATH];
        TCHAR   Default[MAX_PATH];
        PTSTR   DefKey, TimeoutKey;
        PTSTR   DefValue;
        DWORD   TimeKeyLength = _tcslen(BOIOS_TIMEOUT_KEY);
        DWORD   DefKeyLength = _tcslen(BOIOS_DEFAULT_KEY);
        DWORD   CopyLength;

        Result = TRUE;
        
        _tcscpy(Buffer, Section->Contents);
        _tcslwr(Buffer);
        BOIOSFixupString(Buffer, TEXT("\r\n "));

        Timeout[0] = Default[0] = 0;
        
        DefKey = _tcsstr(Buffer, BOIOS_DEFAULT_KEY);
        TimeoutKey = _tcsstr(Buffer, BOIOS_TIMEOUT_KEY);
        
        if (DefKey && TimeoutKey) {
            if (DefKey > TimeoutKey) {        
                CopyLength = DefKey - TimeoutKey - TimeKeyLength;
                _tcsncpy(Timeout, TimeoutKey + TimeKeyLength, CopyLength);
                Timeout[CopyLength] = 0;                
                _tcscpy(Default, DefKey + DefKeyLength);
            } else {
                CopyLength = TimeoutKey - DefKey - DefKeyLength;
                _tcsncpy(Default, DefKey + DefKeyLength, CopyLength);
                Default[CopyLength] = 0;                
                _tcscpy(Timeout, TimeoutKey + TimeKeyLength);
            }
        } else if (DefKey) {
            _tcscpy(Default, DefKey + DefKeyLength);
        } else if (TimeoutKey) {
            _tcscpy(Timeout, TimeoutKey + TimeKeyLength);
        }                        

        if (TimeoutKey) {        
            ULONG TimeoutValue = _ttol(Timeout);

            OSBOSetTimeOut((POS_BOOT_OPTIONS)This, TimeoutValue);
        }

        if (DefKey) {
            PTSTR   BootPath = _tcschr(Default, TEXT('\\'));

            if (BootPath) {
                POS_BOOT_ENTRY CurrEntry;

                *BootPath = 0;                
                CurrEntry = OSBOGetFirstBootEntry((POS_BOOT_OPTIONS)This);                

                while (CurrEntry) {
                    if (_tcsstr(Default, OSBEGetBootVolumeName(CurrEntry)) &&
                        !_tcsicmp(OSBEGetBootPath(CurrEntry), BootPath + 1)) {
                        break;
                    }

                    CurrEntry = OSBOGetNextBootEntry((POS_BOOT_OPTIONS)This, CurrEntry);
                }

                if (CurrEntry) {
                    OSBOSetActiveBootEntry((POS_BOOT_OPTIONS)This, CurrEntry);
                }                        
            } else {
                Result = FALSE;
            }                    
        }            

        OSBO_RESET_DIRTY((POS_BOOT_OPTIONS)This);
    }

    return Result;
}

POS_BOOT_OPTIONS
BOIOSBOCreate(
    IN PCTSTR   BootIniPath,
    IN BOOLEAN  OpenExisting
    )
{
    POS_BOOT_OPTIONS This = NULL;

    if (BootIniPath) {
        BY_HANDLE_FILE_INFORMATION FileInfo = {0};
        PCHAR   FileContent = NULL;
        HANDLE  BootIniHandle;

        //
        // Open the file
        //
        BootIniHandle = CreateFile(BootIniPath,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL, 
                            OPEN_EXISTING,                                    
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if ((BootIniHandle != INVALID_HANDLE_VALUE) &&
            GetFileInformationByHandle(BootIniHandle,
                &FileInfo)){
            //
            // Map the file
            //
            HANDLE MapHandle = CreateFileMapping(BootIniHandle,
                                    NULL,
                                    PAGE_READONLY,
                                    FileInfo.nFileSizeHigh,
                                    FileInfo.nFileSizeLow,
                                    NULL);

            if (MapHandle) {
                //
                // Get hold of view for the file content
                //
                PVOID   FileView = MapViewOfFile(MapHandle,
                                        FILE_MAP_READ,
                                        0,
                                        0,
                                        0);

                if (FileView) {
                    DWORD BytesRead = 0;

                    //
                    // Allocate the buffer and read the file contents
                    //
                    FileContent = SBE_MALLOC(FileInfo.nFileSizeLow + 1);

                    if (FileContent) {
                        if (!ReadFile(BootIniHandle,
                                FileContent,
                                FileInfo.nFileSizeLow,
                                &BytesRead,
                                NULL)) {
                            SBE_FREE(FileContent);
                            FileContent = NULL;
                        } else {
                            FileContent[FileInfo.nFileSizeLow] = 0;
                        }                            
                    } 

                    UnmapViewOfFile(FileView);
                }

                CloseHandle(MapHandle);
            }
            
            CloseHandle(BootIniHandle);
        } else {
            //
            // Could be that user is creating boot options fresh
            //
            if (!OpenExisting) {        
                PBOI_OS_BOOT_OPTIONS Obj = (PBOI_OS_BOOT_OPTIONS)SBE_MALLOC(sizeof(BOI_OS_BOOT_OPTIONS));

                if (Obj) {
                    //
                    // Initialize object
                    //
                    memset(Obj, 0, sizeof(BOI_OS_BOOT_OPTIONS));
                    BOIOSBOInit(Obj);
                    _tcscpy(Obj->BootIniPath, BootIniPath);                    
                }                    

                This = (POS_BOOT_OPTIONS)Obj;
            }                    
        }

        //
        // If there is any file content then parse it
        //
        if (FileContent) {
#ifdef UNICODE
            PWSTR   Content = SBE_MALLOC((FileInfo.nFileSizeLow + 1) * sizeof(WCHAR));

            //
            // Convert the Ansi/OEM content to unicode content
            //
            if (Content) {
                if (MultiByteToWideChar(CP_OEMCP,
                        0,
                        FileContent,
                        FileInfo.nFileSizeLow,
                        Content,
                        FileInfo.nFileSizeLow + 1)) {
                    Content[FileInfo.nFileSizeLow ] = 0;                        
                } else {
                    SBE_FREE(Content);
                    Content = NULL;
                }                    
            } else {
                SBE_FREE(FileContent);
                FileContent = NULL;
            }   
            
#else
            PCHAR   Content = FileContent;
#endif

            if (Content && FileContent) {
                TCHAR   NextLine[MAX_PATH * 4];
                PTSTR   NextSectionStart = _tcschr(Content, BOIOS_SECTION_NAME_START);
                PTSTR   NextSectionEnd;
                PBOI_SECTION SectionList = NULL;
                PBOI_SECTION Section = NULL;
                PBOI_SECTION TailSection = NULL;
                BOOLEAN Result = TRUE;

                //
                // Prase the whole files and create section objects
                //
                while (NextSectionStart) {
                    TCHAR   OldChar;
                    
                    Section = NULL;
                    
                    NextSectionEnd = _tcschr(NextSectionStart + 1, BOIOS_SECTION_NAME_START);

                    if (NextSectionEnd) {                        
                        OldChar = *NextSectionEnd;
                        *NextSectionEnd = 0;    // null terminate                        
                    }                    

                    //
                    // Create the section object
                    //
                    Section = BOISectionCreate(NextSectionStart);

                    if (NextSectionEnd) {                        
                        *NextSectionEnd = OldChar; 
                    }                    
                    
                    if (Section) {
                        if (!SectionList) {
                            SectionList = Section;
                        } else {                            
                            TailSection->Next = Section;
                        }                            
                        
                        TailSection = Section;
                    } else {
                        Result = FALSE;
                        break;
                    }                       

                    NextSectionStart = NextSectionEnd;
                }                

                if (Result) {
                    PBOI_OS_BOOT_OPTIONS Obj = (PBOI_OS_BOOT_OPTIONS)SBE_MALLOC(sizeof(BOI_OS_BOOT_OPTIONS));

                    if (Obj) {
                        //
                        // Initialize object
                        //
                        memset(Obj, 0, sizeof(BOI_OS_BOOT_OPTIONS));
                        BOIOSBOInit(Obj);
                        _tcscpy(Obj->BootIniPath, BootIniPath);

                        Obj->Sections = SectionList;
                        SectionList = NULL;

                        //
                        // Get hold of [operating systems] section and
                        // parse its entries and create boot entries
                        //
                        Section = BOIOSBOFindSection(Obj, BOIOS_OS_SECTION);

                        if (Section) {
                            Result = BOIOSBOParseAndCreateBootEntries(Obj, Section);
                        }                                                        

                        //
                        // Get hold of [boot loader] section and prase its
                        // entries
                        //
                        if (Result) {
                            Section = BOIOSBOFindSection(Obj, BOIOS_BOOTLOADER_SECTION);

                            if (Section) {                                    
                                Result = BOIOSBOParseTimeoutAndActiveEntry(Obj, Section);
                            }
                        }

                        if (!Result) {
                            //
                            // Delete the object to free up all the sections
                            // and the entries
                            //
                            BOIOSBODelete((POS_BOOT_OPTIONS)Obj);
                            Obj = NULL;
                        } 

                        This = (POS_BOOT_OPTIONS)Obj;
                    } else {
                        Result = FALSE;
                    }                        
                }

                //
                // free up the allocated sections, in case of failure
                //
                if (!Result && SectionList) {
                    while (SectionList) {
                        Section = SectionList;
                        SectionList = SectionList->Next;
                        BOISectionDelete(Section);
                    }                                            
                }

                //
                // Free the content
                //
                if ((PVOID)Content != (PVOID)FileContent) {
                    SBE_FREE(Content);               
                }            
            }

            SBE_FREE(FileContent);
        }
    }
    
    return This;
}

static        
VOID
BOIOSBODelete(
    IN POS_BOOT_OPTIONS Obj
    )
{
    PBOI_OS_BOOT_OPTIONS This = (PBOI_OS_BOOT_OPTIONS)Obj;
    
    if (This) {
        PBOI_SECTION CurrSection, PrevSection;
        
        //
        // delete each boot entry 
        //
        POS_BOOT_ENTRY Entry = OSBOGetFirstBootEntry(Obj);
        POS_BOOT_ENTRY PrevEntry;

        while (Entry) {
            PrevEntry = Entry;
            Entry = OSBOGetNextBootEntry(Obj, Entry);
            OSBEDelete(PrevEntry);
        }

        //
        // delete all the sections
        //
        CurrSection = This->Sections;

        while (CurrSection) {
            PrevSection = CurrSection;
            CurrSection = CurrSection->Next;
            BOISectionDelete(PrevSection);
        }

        if (Obj->BootOrder) {
            SBE_FREE(Obj->BootOrder);
        }

        //
        // delete the main object
        //
        SBE_FREE(This);
    }        
}

static
POS_BOOT_ENTRY
BOIOSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCTSTR            FriendlyName,
    IN PCTSTR            OsLoaderVolumeName,
    IN PCTSTR            OsLoaderPath,
    IN PCTSTR            BootVolumeName,
    IN PCTSTR            BootPath,
    IN PCTSTR            OsLoadOptions
    )
{
    PBOI_OS_BOOT_ENTRY  Entry = NULL;

    if (This && FriendlyName && BootVolumeName && BootPath) {
        Entry = SBE_MALLOC(sizeof(BOI_OS_BOOT_ENTRY));

        if (Entry) {
            ULONG   OrderCount;
            PULONG  NewOrder;
            POS_BOOT_ENTRY BaseEntry = (POS_BOOT_ENTRY)Entry;
            PBOI_OS_BOOT_OPTIONS Obj = (PBOI_OS_BOOT_OPTIONS)This;
        
            //
            // init core fields
            //
            memset(Entry, 0, sizeof(BOI_OS_BOOT_ENTRY));
            BOIOSBEInit(Entry);            
            Entry->OsBootEntry.BootOptions = This;

            //
            // fill in the attributes
            //
            OSBESetFriendlyName((POS_BOOT_ENTRY)Entry, FriendlyName);
            OSBESetBootVolumeName((POS_BOOT_ENTRY)Entry, BootVolumeName);
            OSBESetBootPath((POS_BOOT_ENTRY)Entry, BootPath);            

            if (OsLoadOptions) {
                OSBESetOsLoadOptions((POS_BOOT_ENTRY)Entry, OsLoadOptions);
            }

            BaseEntry->Id = Obj->NextEntryId++;

            //
            // Flush the entry now to get a proper Id;
            //
                
            Entry->OsBootEntry.BootOptions = (POS_BOOT_OPTIONS)This;            
            Entry->OsBootEntry.NextEntry = This->BootEntries;
            This->BootEntries = (POS_BOOT_ENTRY)Entry;
            This->EntryCount++;

            //
            // Put the new entry at the end of the boot order
            //
            OrderCount = OSBOGetOrderedBootEntryCount(This);

            NewOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

            if (NewOrder) {
                memset(NewOrder, 0, sizeof(ULONG) * (OrderCount + 1));

                //
                // copy over the old ordered list
                //
                memcpy(NewOrder, This->BootOrder, sizeof(ULONG) * OrderCount);
                NewOrder[OrderCount] = OSBEGetId((POS_BOOT_ENTRY)Entry);
                SBE_FREE(This->BootOrder);
                This->BootOrder = NewOrder;
                This->BootOrderCount = OrderCount + 1;
            } else {
                OSBODeleteBootEntry(This, BaseEntry);
                Entry = NULL;
            }                    

            if (Entry) {
                //
                // mark it dirty and new for flushing
                //
                OSBE_SET_NEW(Entry);
                OSBE_SET_DIRTY(Entry);                                
            }                
        }
    }        
    
    return (POS_BOOT_ENTRY)Entry;
}

static
BOOLEAN
BOIOSBOWrite(
    IN PBOI_OS_BOOT_OPTIONS This,
    IN PCTSTR Buffer
    )
{
    BOOLEAN Result = FALSE;

    if (This && Buffer) {
        TCHAR   BackupFileName[MAX_PATH];
        PTSTR   Extension;
        HANDLE  FileHandle;

        //
        // Create a backup name
        //
        _tcscpy(BackupFileName, This->BootIniPath);
        Extension = _tcschr(BackupFileName, TEXT('.'));

        if (Extension) {
            _tcscpy(Extension, TEXT(".BAK"));
        } else {
            _tcscat(BackupFileName, TEXT(".BAK"));
        }            

        //
        // Delete the backup file if it exists
        //
        SetFileAttributes(BackupFileName, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(BackupFileName);

        //
        // Copy the existing boot.ini as backup file
        //
        SetFileAttributes(This->BootIniPath, FILE_ATTRIBUTE_NORMAL);
        CopyFile(This->BootIniPath, BackupFileName, FALSE);

        //
        // Create new boot.ini file
        //
        FileHandle = CreateFile(This->BootIniPath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (FileHandle && (FileHandle != INVALID_HANDLE_VALUE)) {
            PCHAR   AnsiBuffer;
            ULONG   BufferLength = _tcslen(Buffer);
            DWORD   BytesWritten = 0;

            Result = TRUE;
            
#ifdef UNICODE
            //
            // Convert the unicode buffer to ansi buffer
            //
            AnsiBuffer = (PCHAR)SBE_MALLOC(BufferLength + 1);

            if (AnsiBuffer) {
                memset(AnsiBuffer, 0, BufferLength);

                if (WideCharToMultiByte(CP_OEMCP,
                        0,
                        Buffer,
                        BufferLength,
                        AnsiBuffer,
                        BufferLength,
                        NULL,
                        NULL)) {
                    Result = TRUE;
                    AnsiBuffer[BufferLength] = 0;
                } else {
                    Result = FALSE;
                }                            
            }
#else   
            AnsiBuffer = Buffer;
#endif

            //
            // Write the buffer to the file
            //
            if (AnsiBuffer && 
                !WriteFile(FileHandle, 
                        AnsiBuffer,
                        BufferLength,
                        &BytesWritten,
                        NULL)) {
                Result = FALSE;                            
            }                  

            if ((PVOID)AnsiBuffer != (PVOID)Buffer) {
                SBE_FREE(AnsiBuffer);
                AnsiBuffer = NULL;
            }

            //
            // Done with the file handle
            //
            CloseHandle(FileHandle);

            SetFileAttributes(This->BootIniPath, 
                FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY |
                FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }            
    }        

    return Result;
}

static
BOOLEAN
BOIOSBOFlush(
    IN POS_BOOT_OPTIONS Obj
    )
{
    BOOLEAN Result = FALSE;
    PBOI_OS_BOOT_OPTIONS  This = (PBOI_OS_BOOT_OPTIONS)Obj;    

    if (This) { 
        PTSTR   Buffer = (PTSTR)SBE_MALLOC(MAX_BOOT_INI_SIZE * sizeof(TCHAR));

        if (Buffer) {
            TCHAR   ScratchBuffer[MAX_PATH * 2] = {0};
            POS_BOOT_ENTRY ActiveEntry = OSBOGetActiveBootEntry(Obj);
            POS_BOOT_ENTRY CurrentEntry;
            PBOI_SECTION   CurrentSection;

            Result = TRUE;
            
            memset(Buffer, 0, MAX_BOOT_INI_SIZE * sizeof(TCHAR));            

            //
            // first flush the boot options
            //
            _tcscat(Buffer, BOIOS_SECTION_NAME_START_STR);
            _tcscat(Buffer, BOIOS_BOOTLOADER_SECTION);
            _tcscat(Buffer, BOIOS_SECTION_NAME_END_STR);
            _tcscat(Buffer, TEXT("\r\n"));

            //
            // write time out
            //
            _tcscat(Buffer, BOIOS_TIMEOUT_KEY);
            _tcscat(Buffer, _ltot(Obj->Timeout, ScratchBuffer, 10));
            _tcscat(Buffer, TEXT("\r\n"));

            //
            // write active entry
            //
            if (ActiveEntry) {
                _tcscpy(ScratchBuffer, BOIOS_DEFAULT_KEY);
                _tcscat(ScratchBuffer, OSBEGetBootVolumeName(ActiveEntry));
                _tcscat(ScratchBuffer, TEXT("\\"));
                _tcscat(ScratchBuffer, OSBEGetBootPath(ActiveEntry));
                _tcscat(ScratchBuffer, TEXT("\r\n"));

                _tcscat(Buffer, ScratchBuffer);
            }                

            //
            // Write the boot entries section 
            //
            _tcscat(Buffer, BOIOS_SECTION_NAME_START_STR);
            _tcscat(Buffer, BOIOS_OS_SECTION);
            _tcscat(Buffer, BOIOS_SECTION_NAME_END_STR);
            _tcscat(Buffer, TEXT("\r\n"));

            //
            // write each boot entry now
            //

            //
            // First write the valid arc entries
            //
            CurrentEntry = OSBOGetFirstBootEntry(Obj);

            while (Result && CurrentEntry) {
                if (!OSBE_IS_DELETED(CurrentEntry) &&
                    !OSBE_IS_OLDOS(CurrentEntry)) {
                    Result = BOIOSBEWrite(CurrentEntry, Buffer);                    
                }
                
                CurrentEntry = OSBOGetNextBootEntry(Obj, CurrentEntry);
            }

            //
            // Now write the old OS entries
            // NOTE : We do this for backward compatabily reasons
            //
            CurrentEntry = OSBOGetFirstBootEntry(Obj);

            while (Result && CurrentEntry) {
                if (OSBE_IS_OLDOS(CurrentEntry)) {
                    Result = BOIOSBEWrite(CurrentEntry, Buffer);                    
                }
                
                CurrentEntry = OSBOGetNextBootEntry(Obj, CurrentEntry);
            }

            //
            // Write any additions sections which were present on the
            // 
            CurrentSection = BOIOSGetFirstSection(This);

            while (Result && CurrentSection) {
                //
                // Write all the other additional sections in boot.ini other
                // than [boot loader] and [operating systems]
                //
                if (_tcsicmp(BOISectionGetName(CurrentSection), BOIOS_BOOTLOADER_SECTION) &&
                    _tcsicmp(BOISectionGetName(CurrentSection), BOIOS_OS_SECTION)) {
                    Result = BOISectionWrite(CurrentSection, Buffer);
                }

                CurrentSection = BOIOSGetNextSection(This, CurrentSection);
            }         

            Result = BOIOSBOWrite(This, Buffer);

            //
            // Free the allocated buffer
            //
            SBE_FREE(Buffer);
        }
    }

    return Result;
}

//
// Dummy Driver Routines
//
PDRIVER_ENTRY
BOIOSBOAddNewDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            NtDevicePath,
    IN PCWSTR            SrcNtFullPath
    )
/*++
    Dummy routine
--*/
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bom\makeboot\16bit\usa\dntext.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      dntext.c
//
// Description:
//      Translatable text for DOS based MAKEBOOT program.
//
//----------------------------------------------------------------------------

const char szNtVersionName[]              = "Windows XP";
const char szDiskLabel1[]                 = "Windows XP Setup Boot Disk";
const char szDiskLabel2[]                 = "Windows XP Setup Disk #2";
const char szDiskLabel3[]                 = "Windows XP Setup Disk #3";
const char szDiskLabel4[]                 = "Windows XP Setup Disk #4";

const char szCannotFindFile[]             = "Cannot find file %s\n";
const char szNotEnoughMemory[]            = "Not enough free memory to complete request\n";
const char szNotExecFormat[]              = "%s is not in an executable file format\n";
const char szStars[]                      = "****************************************************";

const char szExplanationLine1[]           = "This program creates the Setup boot disks"; 
const char szExplanationLine2[]           = "for Microsoft %s.";
const char szExplanationLine3[]           = "To create these disks, you need to provide 7 blank,";
const char szExplanationLine4[]           = "formatted, high-density disks.";

const char szInsertFirstDiskLine1[]       = "Insert one of these disks into drive %c:.  This disk";                              
const char szInsertFirstDiskLine2[]       = "will become the %s.";

const char szInsertAnotherDiskLine1[]     = "Insert another disk into drive %c:.  This disk will";
const char szInsertAnotherDiskLine2[]     = "become the %s.";

const char szPressAnyKeyWhenReady[]       = "Press any key when you are ready.";

const char szCompletedSuccessfully[]      = "The setup boot disks have been created successfully.";
const char szComplete[]                   = "complete";

const char szUnknownSpawnError[]          = "An unknown error has occurred trying to execute %s.";
const char szSpecifyDrive[]               = "Please specify the floppy drive to copy the images to: ";
const char szInvalidDriveLetter[]         = "Invalid drive letter\n";
const char szNotAFloppy[]                 = "Drive %c: is not a floppy drive\n";

const char szAttemptToCreateFloppyAgain[] = "Do you want to attempt to create this floppy again?";
const char szPressEnterOrEsc[]            = "Press Enter to try again or Esc to exit.";

const char szErrorDiskWriteProtected[]    = "Error: Disk write protected\n";
const char szErrorUnknownDiskUnit[]       = "Error: Unknown disk unit\n";
const char szErrorDriveNotReady[]         = "Error: Drive not ready\n";
const char szErrorUnknownCommand[]        = "Error: Unknown command\n";
const char szErrorDataError[]             = "Error: Data error (Bad CRC)\n";
const char szErrorBadRequest[]            = "Error: Bad request structure length\n";
const char szErrorSeekError[]             = "Error: Seek error\n";
const char szErrorMediaTypeNotFound[]     = "Error: Media type not found\n";
const char szErrorSectorNotFound[]        = "Error: Sector not found\n";
const char szErrorWriteFault[]            = "Error: Write fault\n";
const char szErrorGeneralFailure[]        = "Error: General failure\n";
const char szErrorInvalidRequest[]        = "Error: Invalid request or bad command\n";
const char szErrorAddressMarkNotFound[]   = "Error: Address mark not found\n";
const char szErrorDiskWriteFault[]        = "Error: Disk write fault\n";
const char szErrorDmaOverrun[]            = "Error: Direct Memory Access (DMA) overrun\n";
const char szErrorCrcError[]              = "Error: Data read (CRC or ECC) error\n";
const char szErrorControllerFailure[]     = "Error: Controller failure\n";
const char szErrorDiskTimedOut[]          = "Error: Disk timed out or failed to respond\n";
const char szDiskLabel5[]                 = "Windows XP Setup Disk #5";
const char szDiskLabel6[]                 = "Windows XP Setup Disk #6";
const char szDiskLabel7[]                 = "Windows XP Setup Disk #7";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\bootini\sbentry.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    sbentry.c

Abstract:

    Contains the OS boot entry and boot options
    abstraction implementation.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/


#include <sbentry.h>
#include <stdio.h>

SBEMemAllocateRoutine    AllocRoutine = NULL;
SBEMemFreeRoutine        FreeRoutine = NULL;

//
// OS_BOOT_ENTRY Methods
//
PCTSTR
OSBEAddOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    )
{
    PTSTR   Option = NULL;
    TCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        _tcscpy(Buffer, BootOption);
        _tcsupr(Buffer);
        Length = _tcslen(Buffer);

        if (Length) {
            //
            // Add a space at the end if required
            //
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            if ((!_tcsstr(This->OsLoadOptions, Buffer)) &&
                ((_tcslen(This->OsLoadOptions) + Length) < MAX_PATH)) {
                _tcscat(This->OsLoadOptions, Buffer);                
                Option = This->OsLoadOptions;
            }

            OSBE_SET_DIRTY(This);
            OSBO_SET_DIRTY(This->BootOptions);
        }
    }

    return Option;
}

PCTSTR
OSBERemoveOsLoadOption(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    )
{
    PTSTR   Option = NULL;
    TCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        _tcscpy(Buffer, BootOption);
        _tcsupr(Buffer);
        Length = _tcslen(Buffer);

        if (Length) {
            PTSTR   OldOption;
            
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            OldOption = _tcsstr(This->OsLoadOptions, Buffer);

            if (OldOption) {
                PTSTR NextToken = _tcschr(OldOption + 1, L'/');

                if (NextToken) {
                    _tcscpy(OldOption, NextToken);
                } else {
                    *OldOption = UNICODE_NULL;
                }

                Option = This->OsLoadOptions;
                
                OSBE_SET_DIRTY(This);
                OSBO_SET_DIRTY(This->BootOptions);
            }                
        }
    }

    return Option;
}

BOOLEAN
OSBEIsOsLoadOptionPresent(
    IN  POS_BOOT_ENTRY  This,
    IN  PCTSTR           BootOption
    )
{
    BOOLEAN Result = FALSE;
    TCHAR   Buffer[MAX_PATH];

    if (This && BootOption) {
        ULONG   Length;
        
        _tcscpy(Buffer, BootOption);
        _tcsupr(Buffer);

        Length = _tcslen(Buffer);

        if (Length) {
            if ((Length < ARRAY_SIZE(Buffer)) && (Buffer[Length - 1] != L' ')) {
                Buffer[Length] = L' ';
                Buffer[Length + 1] = UNICODE_NULL;
                Length++;
            }                

            Result = _tcsstr(This->OsLoadOptions, Buffer) ? TRUE : FALSE;            
        }
    }

    return Result;
}


//
// OS_BOOT_OPTIONS Methods
//
POS_BOOT_ENTRY
OSBOFindBootEntry(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    POS_BOOT_ENTRY  Entry = NULL;

    if (This) {
        for (Entry = This->BootEntries; Entry; Entry = Entry->NextEntry) {
            if (Entry->Id == Id) {
                break;  // found the required entry
            }
        }
    }

    return Entry;
}

ULONG
OSBOFindBootEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    ULONG Index = -1;

    if (This) {
        ULONG EntryIndex;
        
        for (EntryIndex = 0; 
            EntryIndex < OSBOGetOrderedBootEntryCount(This); 
            EntryIndex++) {

            if (This->BootOrder[EntryIndex] == Id) {
                Index = EntryIndex;
                break;  // found the required entry
            }
        }
    }

    return Index;
}


BOOLEAN
OSBODeleteBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    )
{
    BOOLEAN Result = FALSE;

    if (This && BootEntry) {
        POS_BOOT_ENTRY  CurrEntry = NULL;
        POS_BOOT_ENTRY  PrevEntry = NULL;

        for (CurrEntry = This->BootEntries;
             CurrEntry != BootEntry;
             PrevEntry = CurrEntry, CurrEntry = CurrEntry->NextEntry) {
            // do nothing             
        }                

        if (CurrEntry) {
            ULONG Order;
            POS_BOOT_ENTRY  OrderedEntry;

            //
            // Set the required attributes
            //
            OSBE_SET_DELETED(BootEntry);            
            OSBE_SET_DIRTY(BootEntry);
            OSBO_SET_DIRTY(This);
            
            //
            // Flush the changes
            //
            Result = OSBEFlush(BootEntry);

            if (Result) {
                //
                // Remove references to the entries
                //
                if (PrevEntry) {
                    PrevEntry->NextEntry = BootEntry->NextEntry;
                } else {
                    This->BootEntries = BootEntry->NextEntry;
                }  

                if (This->EntryCount) {
                    This->EntryCount--;
                }                    

                //
                // if this entry was ordered then remove
                // reference from the order too
                //
                Order = OSBOFindBootEntryOrder(This, OSBEGetId(BootEntry));

                if (Order != (-1)) {
                    ULONG   OrderCount = OSBOGetOrderedBootEntryCount(This);

                    OrderCount--;
                    
                    if (OrderCount) {
                        PULONG  NewOrder = SBE_MALLOC(OrderCount * sizeof(ULONG));                

                        if (NewOrder) {
                            //
                            // copy entries before the current entry
                            //
                            memcpy(NewOrder, This->BootOrder, Order * sizeof(ULONG));

                            //
                            // copy entries after the current entry
                            //
                            memcpy(NewOrder + Order, This->BootOrder + Order + 1,
                                (OrderCount - Order) * sizeof(ULONG));

                            SBE_FREE(This->BootOrder);
                            This->BootOrder = NewOrder;
                            This->BootOrderCount = OrderCount;
                            Result = TRUE;
                        } else {
                            Result = FALSE;
                        }                            
                    } else {
                        SBE_FREE(This->BootOrder);
                        This->BootOrder = NULL;
                        This->BootOrderCount = 0;
                    }                        
                }


                if (BootEntry == OSBOGetActiveBootEntry(This)) {
                    ULONG Index;
                    
                    //
                    // Update the active boot entry and the next boot entry
                    //
                    This->CurrentEntry = NULL;
                    Index = OSBOGetBootEntryIdByOrder(This, 0);

                    if (Index != (-1)) {
                        This->CurrentEntry = OSBOFindBootEntry(This, Index);
                    }
                }                    

                //
                // Since we updated some state mark it dirty
                //
                OSBO_SET_DIRTY(This);
                
                OSBEDelete(BootEntry);            
            }                
        }            
    }

    return Result;
}

POS_BOOT_ENTRY
OSBOSetActiveBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN POS_BOOT_ENTRY   BootEntry
    )
{
    POS_BOOT_ENTRY  OldActiveEntry = NULL;

    if (This && BootEntry) {
        ULONG   OrderCount = OSBOGetOrderedBootEntryCount(This);
        OldActiveEntry = OSBOGetActiveBootEntry(This);

        if ((OrderCount > 0) && (OldActiveEntry != BootEntry)) {
            ULONG Index;
            ULONG ActiveIndex = OSBOFindBootEntryOrder(This,
                                    OSBEGetId(BootEntry));

            //
            // If the entry is already present in the boot order
            // and move it to the start of the list
            //
            if (ActiveIndex != (-1)) {                
                for (Index = ActiveIndex; Index; Index--) {
                    This->BootOrder[Index] = This->BootOrder[Index - 1];
                }

                This->BootOrder[0] = BootEntry->Id;
            } else {
                //
                // This is a new entry in ordered list. Grow the ordered boot
                // entry list with this new entry at the start
                //
                PULONG  NewBootOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

                memcpy(NewBootOrder + 1, This->BootOrder, sizeof(ULONG) * OrderCount);
                NewBootOrder[0] = BootEntry->Id;

                SBE_FREE(This->BootOrder);
                This->BootOrder = NewBootOrder;
            }

            //
            // Update the active boot entry and the next boot entry
            //
            This->CurrentEntry = NULL;
            Index = OSBOGetBootEntryIdByOrder(This, 0);

            if (Index != (-1)) {
                This->CurrentEntry = OSBOFindBootEntry(This, Index);
            }

            //
            // Since we updated some state mark it dirty
            //
            OSBO_SET_DIRTY(This);
        }        
    }

    return OldActiveEntry;
}

//
// Dummy Driver Routines
//
__inline
PDRIVER_ENTRY    
OSBOFindDriverEntryByName(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            DriverName
)
{
    return NULL;
}

__inline
BOOLEAN
OSBODeleteDriverEntry(
    IN POS_BOOT_OPTIONS This,
    IN ULONG            Id
    )

{
    return FALSE;
}

__inline
ULONG
OSBOFindDriverEntryOrder(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    return -1;
}

__inline
PDRIVER_ENTRY
OSBOFindDriverEntryById(
    IN  POS_BOOT_OPTIONS   This,
    IN  ULONG   Id
    )
{
    return NULL;
}

__inline
PDRIVER_ENTRY
OSBOGetFirstDriverEntry(
    IN POS_BOOT_OPTIONS OSBootOptions
    )
{
    return NULL;
}

__inline
PDRIVER_ENTRY
OSBOGetNextDriverEntry(
    IN POS_BOOT_OPTIONS This,
    IN PDRIVER_ENTRY PrevDriverEntry
    )
{
   return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\efi\efidrvent.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    efidrvent.h

Abstract:

    EFI driver entry abstractions.

Author:

    Mandar Gokhale (mandarg@microsoft.com)  14-June-2002

Revision History:

    None.

--*/

#pragma once
#include <sbentry.h>


static
BOOLEAN
EFIDEFlushDriverEntry(
    IN  PDRIVER_ENTRY  This    // Points to the driver List.
    );

static
PDRIVER_ENTRY    
EFIDESearchForDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            SrcNtFullPath
    );

PDRIVER_ENTRY
EFIDECreateNewDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            NtDevicePath,
    IN PCWSTR            SrcNtFullPath    
    );

PDRIVER_ENTRY
EFIOSBOInsertDriverListNewEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PDRIVER_ENTRY     DriverEntry
    );

PDRIVER_ENTRY
EFIDEAddNewDriverEntry(
    IN POS_BOOT_OPTIONS  This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            NtDevicePath,
    IN PCWSTR            SrcNtFullPath
    );

NTSTATUS
EFIDEInterpretDriverEntries(
    IN POS_BOOT_OPTIONS         This,
    IN PEFI_DRIVER_ENTRY_LIST   DriverList
    );

static
VOID
EFIDEDriverEntryInit(
    IN PDRIVER_ENTRY This
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\efi\efisbent.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    efisbent.c

Abstract:

    Contains the EFI OS boot entry and boot options
    abstraction implementation.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/
#include <efisbent.h>
#include <efidrvent.h>
#include <ntosp.h>
#include <efi.h>
#include <stdio.h>

//
// global variables
//
BOOLEAN PriviledgeSet = FALSE;

//
// Helper functions
//
static
BOOLEAN
EFIGetHardDrivePath(
    IN PFILE_PATH SrcFilePath,
    OUT PFILE_PATH NewFilePath 
    );

//
// EFI_OS_BOOT_ENTRY Methods
//

static
VOID
EFIOSBEInit(
    IN PEFI_OS_BOOT_ENTRY This
    )
{
    This->OsBootEntry.Delete = EFIOSBEDelete;
    This->OsBootEntry.Flush = EFIOSBEFlush;
}

static
POS_BOOT_ENTRY
EFIOSBECreate(
    IN PBOOT_ENTRY NtBootEntry,
    IN POS_BOOT_OPTIONS Container
    )
{    
    PEFI_OS_BOOT_ENTRY  Entry = NULL;

    if (NtBootEntry && Container) {        
        Entry = SBE_MALLOC(sizeof(EFI_OS_BOOT_ENTRY));

        if (Entry) {
            PWSTR       TempUniStr;
            NTSTATUS    Status = STATUS_SUCCESS;
            ULONG       Size;
            PFILE_PATH  FilePath;
                        
            memset(Entry, 0, sizeof(EFI_OS_BOOT_ENTRY));
            EFIOSBEInit(Entry);
            
            Entry->OsBootEntry.Id = NtBootEntry->Id;
            Entry->OsBootEntry.BootOptions = Container;

            //
            // If this is a Windows boot options set the windows attribute
            //
            if ( IS_BOOT_ENTRY_WINDOWS(NtBootEntry) ) {
                OSBE_SET_WINDOWS(Entry);
            }
            
            //
            // Get the friendly name
            //
            TempUniStr = ADD_OFFSET(NtBootEntry, FriendlyNameOffset);
            
            OSBESetFriendlyName((POS_BOOT_ENTRY)Entry, TempUniStr);

            //
            // Get the loader path
            //
            FilePath = ADD_OFFSET(NtBootEntry, BootFilePathOffset);            
            
            if (FilePath->Type != FILE_PATH_TYPE_NT) {            
                PFILE_PATH NewPath;

                Size = sizeof(FILE_PATH) + FilePath->Length;
                NewPath = SBE_MALLOC(Size);

                if (NewPath) {                                   
                    memset(NewPath, 0, Size);
                    
                    if (EFIGetHardDrivePath(FilePath, NewPath)) {
                        FilePath = NewPath;
                        Size = 0;                
                        
                        Status = NtTranslateFilePath(FilePath,
                                        FILE_PATH_TYPE_NT,
                                        NULL,
                                        &Size);
                        
                        if (Size != 0) {
                            PFILE_PATH NtFilePath = SBE_MALLOC(Size);

                            if (NtFilePath) {                        
                                Status = NtTranslateFilePath(FilePath,
                                            FILE_PATH_TYPE_NT,
                                            NtFilePath,
                                            &Size);

                                if (NT_SUCCESS(Status)) {            
                                    PWSTR   VolumeName = (PWSTR)(NtFilePath->FilePath);

                                    OSBESetOsLoaderVolumeName((POS_BOOT_ENTRY)Entry,                                
                                            VolumeName);

                                    OSBESetOsLoaderPath((POS_BOOT_ENTRY)Entry,
                                        VolumeName + wcslen(VolumeName) + 1);
                                }

                                SBE_FREE(NtFilePath);
                            } else {
                                Status = STATUS_NO_MEMORY;
                            }                        
                        }
                    }                        

                    SBE_FREE(NewPath);
                }

                //
                // Its possible for some reason we didn't get NT path
                // for loader volume, for e.g. it may not be present at all
                // So ignore such cases
                //
                Status = STATUS_SUCCESS;
            } else {
                PWSTR   VolumeName = (PWSTR)(FilePath->FilePath);
                
                OSBESetOsLoaderVolumeName((POS_BOOT_ENTRY)Entry,                                
                        VolumeName);

                OSBESetOsLoaderPath((POS_BOOT_ENTRY)Entry,
                    VolumeName + wcslen(VolumeName) + 1);
            }
            
            if (NT_SUCCESS(Status)) {
                PWINDOWS_OS_OPTIONS OsOptions;

                //
                // Get the OsLoadOptions & Boot path if its windows
                // entry
                //
                OsOptions = (PWINDOWS_OS_OPTIONS)NtBootEntry->OsOptions;

                if (IS_BOOT_ENTRY_WINDOWS(NtBootEntry)) {
                    OSBESetOsLoadOptions((POS_BOOT_ENTRY)Entry,
                        OsOptions->OsLoadOptions);

                    FilePath = ADD_OFFSET(OsOptions, OsLoadPathOffset);

                    if (FilePath->Type != FILE_PATH_TYPE_NT) {            
                        PFILE_PATH NewPath;

                        Size = sizeof(FILE_PATH) + FilePath->Length;
                        NewPath = SBE_MALLOC(Size);

                        if (NewPath) {
                            memset(NewPath, 0, Size);
                            
                            if (EFIGetHardDrivePath(FilePath, NewPath)) {                                   
                                FilePath = NewPath;
                                Size = 0;                
                            
                                Status = NtTranslateFilePath(FilePath,
                                                FILE_PATH_TYPE_NT,
                                                NULL,
                                                &Size);

                                if (Size != 0) {
                                    PFILE_PATH NtFilePath = SBE_MALLOC(Size);

                                    if (NtFilePath) {                                
                                        Status = NtTranslateFilePath(FilePath,
                                                    FILE_PATH_TYPE_NT,
                                                    NtFilePath,
                                                    &Size);

                                        if (NT_SUCCESS(Status)) {
                                            PWSTR   VolumeName = (PWSTR)(NtFilePath->FilePath);

                                            OSBESetBootVolumeName((POS_BOOT_ENTRY)Entry,                                        
                                                VolumeName);

                                            OSBESetBootPath((POS_BOOT_ENTRY)Entry,
                                                VolumeName + wcslen(VolumeName) + 1);
                                        }

                                        SBE_FREE(NtFilePath);
                                    } else {
                                        Status = STATUS_NO_MEMORY;
                                    }                        
                                }
                            }                                

                            SBE_FREE(NewPath);
                        } 

                        //
                        // Its possible for some reason we didn't get NT path
                        // for Boot volume, for e.g. it may not be present at all
                        // So ignore such cases
                        //
                        Status = STATUS_SUCCESS;
                    } else {
                        PWSTR   VolumeName = (PWSTR)(FilePath->FilePath);
                        
                        OSBESetBootVolumeName((POS_BOOT_ENTRY)Entry,                                        
                            VolumeName);

                        OSBESetBootPath((POS_BOOT_ENTRY)Entry,
                            VolumeName + wcslen(VolumeName) + 1);
                    }                            
                }
            }

            if (!NT_SUCCESS(Status)) {
                SBE_FREE(Entry);
                Entry = NULL;
            }
        }
    }

    return (POS_BOOT_ENTRY)Entry;
}

static
BOOLEAN
EFIOSBEFillNtBootEntry(
    IN PEFI_OS_BOOT_ENTRY Entry
    )
{
    BOOLEAN Result = FALSE;

    if (Entry) {
        ULONG   RequiredLength;
        ULONG   OsOptionsOffset;
        ULONG   OsOptionsLength;
        ULONG   FriendlyNameOffset;
        ULONG   BootPathOffset;
        ULONG   BootPathLength;
        ULONG   LoaderPathOffset;
        ULONG   LoaderPathLength;
        ULONG   WinOsOptionsLength;
        POS_BOOT_ENTRY  BaseEntry = (POS_BOOT_ENTRY)Entry;
        
        if (Entry->NtBootEntry) {
            SBE_FREE(Entry->NtBootEntry);
        }                

        RequiredLength = FIELD_OFFSET(BOOT_ENTRY, OsOptions);

        //
        // TDB : What about non windows OS options ?
        //
        OsOptionsOffset = RequiredLength;
        RequiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
        RequiredLength += (wcslen(OSBEGetOsLoadOptions(BaseEntry)) + 1) * sizeof(WCHAR);                
        
        //
        // for boot path as part of windows OS options
        //
        RequiredLength = BootPathOffset = ALIGN_UP(RequiredLength, ULONG);
        RequiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
        RequiredLength += (wcslen(OSBEGetBootVolumeName(BaseEntry)) + 1) * sizeof(WCHAR);
        RequiredLength += (wcslen(OSBEGetBootPath(BaseEntry)) + 1) * sizeof(WCHAR);
        BootPathLength = (RequiredLength - BootPathOffset);
        OsOptionsLength = (RequiredLength - OsOptionsOffset);

        //
        // for friendly name
        //
        RequiredLength = FriendlyNameOffset = ALIGN_UP(RequiredLength, ULONG);
        RequiredLength += (wcslen(OSBEGetFriendlyName(BaseEntry)) + 1) * sizeof(WCHAR);

        // 
        // for loader path
        //
        RequiredLength = LoaderPathOffset = ALIGN_UP(RequiredLength, ULONG);
        RequiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
        RequiredLength += (wcslen(OSBEGetOsLoaderVolumeName(BaseEntry)) + 1) * sizeof(WCHAR);
        RequiredLength += (wcslen(OSBEGetOsLoaderPath(BaseEntry)) + 1) * sizeof(WCHAR);       
        LoaderPathLength = (RequiredLength - LoaderPathOffset);


        Entry->NtBootEntry = (PBOOT_ENTRY)SBE_MALLOC(RequiredLength);

        if (Entry->NtBootEntry) {
            PBOOT_ENTRY NtBootEntry = Entry->NtBootEntry;
            PFILE_PATH  BootPath = ADD_BYTE_OFFSET(NtBootEntry, BootPathOffset);
            PFILE_PATH  LoaderPath = ADD_BYTE_OFFSET(NtBootEntry, LoaderPathOffset);
            PWSTR       FriendlyName = (PWSTR)(ADD_BYTE_OFFSET(NtBootEntry, FriendlyNameOffset));
            PWINDOWS_OS_OPTIONS WindowsOptions = ADD_BYTE_OFFSET(NtBootEntry, OsOptionsOffset);
            PWSTR   TempStr;

            memset(NtBootEntry, 0, RequiredLength);
            
            //
            // Fill the base part
            //
            NtBootEntry->Version = BOOT_ENTRY_VERSION;
            NtBootEntry->Length = RequiredLength;
            NtBootEntry->Id = OSBEGetId(BaseEntry);
            NtBootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE | BOOT_ENTRY_ATTRIBUTE_WINDOWS;
            NtBootEntry->OsOptionsLength = OsOptionsLength;
            NtBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)FriendlyName - (PUCHAR)NtBootEntry);
            NtBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)LoaderPath - (PUCHAR)NtBootEntry);
            
            //
            // Fill in the windows os options
            //
            strcpy(WindowsOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
            WindowsOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
            WindowsOptions->Length = OsOptionsLength;
            WindowsOptions->OsLoadPathOffset = (ULONG)((PUCHAR)BootPath - (PUCHAR)WindowsOptions);
            wcscpy(WindowsOptions->OsLoadOptions, OSBEGetOsLoadOptions(BaseEntry));

            //
            // Fill in the Boot path FILE_PATH
            //
            BootPath->Version = FILE_PATH_VERSION;
            BootPath->Length = BootPathLength;
            BootPath->Type = FILE_PATH_TYPE_NT;
            TempStr = (PWSTR)(BootPath->FilePath);
            wcscpy(TempStr, OSBEGetBootVolumeName(BaseEntry));
            TempStr += wcslen(TempStr) + 1;
            wcscpy(TempStr, OSBEGetBootPath(BaseEntry));

            //
            // Fill the friendly name
            //
            wcscpy(FriendlyName, OSBEGetFriendlyName(BaseEntry));

            //
            // Fill in the loader path FILE_PATH
            //
            LoaderPath->Version = FILE_PATH_VERSION;
            LoaderPath->Length = LoaderPathLength;
            LoaderPath->Type = FILE_PATH_TYPE_NT;
            TempStr = (PWSTR)(LoaderPath->FilePath);
            wcscpy(TempStr, OSBEGetOsLoaderVolumeName(BaseEntry));
            TempStr += wcslen(TempStr) + 1;
            wcscpy(TempStr, OSBEGetOsLoaderPath(BaseEntry));

            Result = TRUE;
        }
    }

    return Result;
}

static
VOID
EFIOSBEDelete(
    IN  POS_BOOT_ENTRY  Obj
    )
{
    PEFI_OS_BOOT_ENTRY  This = (PEFI_OS_BOOT_ENTRY)Obj;
    
    if (This) {
        if (This->NtBootEntry) {
            SBE_FREE(This->NtBootEntry);
        }
        
        SBE_FREE(This);
    }        
}

static
BOOLEAN
EFIOSBEFlush(
    IN  POS_BOOT_ENTRY  Obj
    )
{
    BOOLEAN Result = FALSE;
    PEFI_OS_BOOT_ENTRY  This = (PEFI_OS_BOOT_ENTRY)Obj;    

    if (This) {
        NTSTATUS Status = STATUS_SUCCESS;
        
        if (OSBE_IS_DIRTY(This)) {
            if (OSBE_IS_DELETED(This)) {
                //
                // Delete this entry
                //
                Status = NtDeleteBootEntry(This->OsBootEntry.Id);
            } else if (OSBE_IS_NEW(This)) {
                //
                // Add this as new boot entry
                //
                Status = EFIOSBEFillNtBootEntry(This);

                if (NT_SUCCESS(Status)) {
                    Status = NtAddBootEntry(This->NtBootEntry,
                                &(This->OsBootEntry.Id));
                }                                
            } else {
                //
                // Just change this boot entry
                //
                Status = EFIOSBEFillNtBootEntry(This);

                if (NT_SUCCESS(Status)) {
                    Status = NtModifyBootEntry(This->NtBootEntry);
                }                                
            }

            if (NT_SUCCESS(Status)) {
                OSBE_RESET_DIRTY(This);
                Result = TRUE;
            }             
        } else {
            Result = TRUE;  // nothing to flush
        }
    }

    return Result;
}

//
// EFI_OS_BOOT_OPTIONS Methods
//
static
VOID
EFIOSBOInit(
    IN PEFI_OS_BOOT_OPTIONS  This
    )
{
    This->OsBootOptions.Delete = EFIOSBODelete;
    This->OsBootOptions.Flush = EFIOSBOFlush;
    This->OsBootOptions.AddNewBootEntry = EFIOSBOAddNewBootEntry;
    This->OsBootOptions.DeleteBootEntry = OSBODeleteBootEntry;
    This->OsBootOptions.AddNewDriverEntry = EFIDEAddNewDriverEntry;
    This->OsBootOptions.DeleteDriverEntry = OSBODeleteDriverEntry;
}

POS_BOOT_OPTIONS
EFIOSBOCreate(
    VOID
    )
{
    PEFI_OS_BOOT_OPTIONS This = NULL;
    BOOLEAN WasEnabled = FALSE;

    if (PriviledgeSet || 
        NT_SUCCESS(RtlAdjustPrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE, 
                            TRUE,
                            FALSE,
                            &WasEnabled))) {
        PriviledgeSet = TRUE;    
        This = SBE_MALLOC(sizeof(EFI_OS_BOOT_OPTIONS));    
    } 
    
    if (This) {
        NTSTATUS    Status;
        ULONG       Length = 0;
        
        memset(This, 0, sizeof(EFI_OS_BOOT_OPTIONS));       
        EFIOSBOInit(This);

        //
        // Get hold of NT boot entries
        //
        Status = NtQueryBootOptions(NULL, &Length);

        if (Length) {
            This->NtBootOptions = SBE_MALLOC(Length);

            if (This->NtBootOptions) {
                Status = NtQueryBootOptions(This->NtBootOptions,
                                &Length);

                if (NT_SUCCESS(Status)) {
                    //
                    // save off the timeout period
                    //
                    This->OsBootOptions.Timeout = This->NtBootOptions->Timeout;

                    //
                    // enumerate all the boot entries
                    //
                    Length = 0;
                    Status = NtEnumerateBootEntries(NULL, &Length);

                    if (Length) {
                        This->NtBootEntries = SBE_MALLOC(Length);

                        if (This->NtBootEntries) {
                            Status = NtEnumerateBootEntries(This->NtBootEntries,
                                            &Length);
                        } else {
                            Status = STATUS_NO_MEMORY;
                        }                            
                    } 
                }
            } else {
                Status = STATUS_NO_MEMORY;
            }                
        }

        //
        // Convert the NT boot entries to our representation
        //
        if (NT_SUCCESS(Status) && (This->NtBootEntries)) {
            PBOOT_ENTRY_LIST    ListEntry = This->NtBootEntries;
            PBOOT_ENTRY         CurrentNtEntry = &(ListEntry->BootEntry);
            PEFI_OS_BOOT_ENTRY  CurrentOsEntry = NULL;
            PEFI_OS_BOOT_ENTRY  LastEntry = NULL;

            while (CurrentNtEntry) {
                //
                // Create the OS entry
                //
                CurrentOsEntry = (PEFI_OS_BOOT_ENTRY)EFIOSBECreate(CurrentNtEntry, 
                                                        (POS_BOOT_OPTIONS)This);

                if (!CurrentOsEntry)  {
                    Status = STATUS_NO_MEMORY;

                    break;
                }

                //
                // found one more valid entry
                //
                This->OsBootOptions.EntryCount++;
                CurrentOsEntry->OsBootEntry.BootOptions = (POS_BOOT_OPTIONS)This;

                //
                // If this is the first entry then setup the linked list head
                //
                if (!This->OsBootOptions.BootEntries) {
                    This->OsBootOptions.BootEntries = (POS_BOOT_ENTRY)(CurrentOsEntry);
                } 

                if (LastEntry) {
                    LastEntry->OsBootEntry.NextEntry = (POS_BOOT_ENTRY)CurrentOsEntry;
                }                    

                LastEntry = CurrentOsEntry;

                //
                // process the next entry, if available
                //
                if (ListEntry->NextEntryOffset) {
                    ListEntry = ADD_OFFSET(ListEntry, NextEntryOffset);
                    CurrentNtEntry = &(ListEntry->BootEntry);
                } else {
                    CurrentNtEntry = NULL;
                }                    
            }                                    
        }
        
        //
        // Now query the boot order
        //
        if (NT_SUCCESS(Status)) {
            Length = 0;

            Status = NtQueryBootEntryOrder(NULL,
                            &Length);

            if (Length) {
                PULONG  BootOrder = SBE_MALLOC(Length * sizeof(ULONG));

                if (BootOrder) {
                    memset(BootOrder, 0, Length);
                    This->OsBootOptions.BootOrder = BootOrder;
                    This->OsBootOptions.BootOrderCount = Length;

                    Status = NtQueryBootEntryOrder(BootOrder,
                                &Length);
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }

        //
        // Now setup the valid entries
        //
        if (NT_SUCCESS(Status)) {
            ULONG FirstEntryId = OSBOGetBootEntryIdByOrder((POS_BOOT_OPTIONS)This,
                                        0);

            if (FirstEntryId != (-1)) {
                This->OsBootOptions.CurrentEntry = 
                        OSBOFindBootEntry((POS_BOOT_OPTIONS)This,
                                FirstEntryId);
            } else {
                This->OsBootOptions.CurrentEntry = NULL;
            }
        }

        //
        // Enumerate the driver entries
        //
        if (NT_SUCCESS(Status)){            
            Status = NtEnumerateDriverEntries(NULL, &Length);
            
            if (!NT_SUCCESS(Status) && (STATUS_BUFFER_TOO_SMALL==Status)){                
                PEFI_DRIVER_ENTRY_LIST Entry;
                PEFI_DRIVER_ENTRY_LIST DriverList = (PEFI_DRIVER_ENTRY_LIST) SBE_MALLOC(Length);
                
                if (DriverList){
                    Status = NtEnumerateDriverEntries(DriverList, &Length);
                    
                    if (NT_SUCCESS(Status)){
                        This->DriverEntries = DriverList;
                        
                        //
                        // Convert driver enties to our internal format.
                        //
                        Status = EFIDEInterpretDriverEntries((POS_BOOT_OPTIONS)This,
                                                  DriverList);                    
                    }
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }

        //
        // Now query the driver entry order
        //
        if (NT_SUCCESS(Status)) {
            Length = 0;

            Status = NtQueryDriverEntryOrder(NULL,
                                            &Length);

            if (Length) {
                PULONG  DriverEntryOrder = SBE_MALLOC(Length * sizeof(ULONG));

                if (DriverEntryOrder) {
                    memset(DriverEntryOrder, 0, Length);
                    This->OsBootOptions.DriverEntryOrder = DriverEntryOrder;
                    This->OsBootOptions.DriverEntryOrderCount = Length;

                    Status = NtQueryDriverEntryOrder(DriverEntryOrder,
                                                    &Length);
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }
        
        if (!NT_SUCCESS(Status)) {
            EFIOSBODelete((POS_BOOT_OPTIONS)This);
            This = NULL;
        }
    }

    return (POS_BOOT_OPTIONS)This;
}

static        
VOID
EFIOSBODelete(
    IN POS_BOOT_OPTIONS Obj
    )
{
    PEFI_OS_BOOT_OPTIONS This = (PEFI_OS_BOOT_OPTIONS)Obj;
    
    if (This) {
        ULONG Index = 0;
        POS_BOOT_ENTRY Entry = OSBOGetFirstBootEntry(Obj, &Index);
        POS_BOOT_ENTRY NextEntry;
        PDRIVER_ENTRY  DriverEntries = OSBOGetFirstDriverEntry(Obj);
        PDRIVER_ENTRY  NextDrvEntry;

        //
        // delete each boot entry 
        //
        while (Entry) {
            NextEntry = Entry->NextEntry;
            OSBEDelete(Entry);
            Entry = NextEntry;
        }

        //
        // delete boot entry order.
        //
        if (This->OsBootOptions.BootOrder){
            SBE_FREE(This->OsBootOptions.BootOrder);                
        }

        //
        // Delete all the driver entries
        //
        while (DriverEntries){
            NextDrvEntry = DriverEntries->NextEntry;
            SBE_FREE(DriverEntries);
            DriverEntries = NextDrvEntry;               
        }

        //
        // delete driver entry order.
        //
        if (This->OsBootOptions.DriverEntryOrder){
            SBE_FREE(This->OsBootOptions.DriverEntryOrder);                
        }

        //
        // delete the options
        //
        if (This->NtBootOptions){
            SBE_FREE(This->NtBootOptions);
        }

        SBE_FREE(This);
    }        
}

static
POS_BOOT_ENTRY
EFIOSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            OsLoaderVolumeName,
    IN PCWSTR            OsLoaderPath,
    IN PCWSTR            BootVolumeName,
    IN PCWSTR            BootPath,
    IN PCWSTR            OsLoadOptions
    )
{
    PEFI_OS_BOOT_ENTRY  Entry = NULL;

    if (This && FriendlyName && OsLoaderVolumeName && OsLoaderPath &&
        BootVolumeName && BootPath) {
        Entry = SBE_MALLOC(sizeof(EFI_OS_BOOT_ENTRY));

        if (Entry) {
            memset(Entry, 0, sizeof(EFI_OS_BOOT_ENTRY));

            //
            // init core fields
            //
            EFIOSBEInit(Entry);            
            Entry->OsBootEntry.BootOptions = This;

            //
            // fill in the attributes
            //
            OSBESetFriendlyName((POS_BOOT_ENTRY)Entry, FriendlyName);
            OSBESetOsLoaderVolumeName((POS_BOOT_ENTRY)Entry, OsLoaderVolumeName);
            OSBESetOsLoaderPath((POS_BOOT_ENTRY)Entry, OsLoaderPath);
            OSBESetBootVolumeName((POS_BOOT_ENTRY)Entry, BootVolumeName);
            OSBESetBootPath((POS_BOOT_ENTRY)Entry, BootPath);            

            if (OsLoadOptions) {
                OSBESetOsLoadOptions((POS_BOOT_ENTRY)Entry, OsLoadOptions);
            }
            
            //
            // Set the attribute specifying that this is a Windows option
            //
            OSBE_SET_WINDOWS(Entry);

            //
            // mark it dirty and new for flushing
            //
            OSBE_SET_NEW(Entry);
            OSBE_SET_DIRTY(Entry);                    

            //
            // Flush the entry now to get a proper Id;
            //
            if (!OSBEFlush((POS_BOOT_ENTRY)Entry)) {
                SBE_FREE(Entry);
                Entry = NULL;
            } else {
                ULONG   OrderCount;
                PULONG  NewOrder;
                
                Entry->OsBootEntry.BootOptions = (POS_BOOT_OPTIONS)This;            
                Entry->OsBootEntry.NextEntry = This->BootEntries;
                This->BootEntries = (POS_BOOT_ENTRY)Entry;
                This->EntryCount++;

                //
                // Put the new entry at the end of the boot order
                //
                OrderCount = OSBOGetOrderedBootEntryCount(This);

                NewOrder = (PULONG)SBE_MALLOC((OrderCount + 1) * sizeof(ULONG));

                if (NewOrder) {
                    memset(NewOrder, 0, sizeof(ULONG) * (OrderCount + 1));

                    //
                    // copy over the old ordered list
                    //
                    memcpy(NewOrder, This->BootOrder, sizeof(ULONG) * OrderCount);
                    NewOrder[OrderCount] = OSBEGetId((POS_BOOT_ENTRY)Entry);
                    SBE_FREE(This->BootOrder);
                    This->BootOrder = NewOrder;
                    This->BootOrderCount = OrderCount + 1;
                } else {    
                    SBE_FREE(Entry);
                    Entry = NULL;
                }                    
            }                
        }
    }        
    
    return (POS_BOOT_ENTRY)Entry;
}

static
BOOLEAN
EFIOSBOFlush(
    IN POS_BOOT_OPTIONS Obj
    )
{
    BOOLEAN Result = FALSE;
    PEFI_OS_BOOT_OPTIONS  This = (PEFI_OS_BOOT_OPTIONS)Obj;


    if (This) { 
        ULONG Index;
        ULONG FieldsToChange = BOOT_OPTIONS_FIELD_COUNTDOWN |
                               BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID;
        ULONG OrderCount;                               
                               
        POS_BOOT_ENTRY  Entry = OSBOGetFirstBootEntry(Obj, &Index);

        //
        // First update the required entries
        //
        Result = TRUE;
        
        while (Entry) {
            if (!OSBE_IS_DELETED(Entry) && !OSBE_IS_NEW(Entry) &&
                !NT_SUCCESS(EFIOSBEFlush(Entry))) {
                Result = FALSE;
            }

            Entry = OSBOGetNextBootEntry(Obj, &Index);
        }

        if (Result) {
            Entry = OSBOGetFirstBootEntry(Obj, &Index);

            //
            // Next delete the required entries
            //
            Result = TRUE;
            
            while (Entry) {
                if (OSBE_IS_DELETED(Entry) && !NT_SUCCESS(EFIOSBEFlush(Entry))) {
                    Result = FALSE;
                }

                Entry = OSBOGetNextBootEntry(Obj, &Index);
            }
        }            

        if (Result) {
            POS_BOOT_ENTRY  TmpEntry = OSBOGetFirstBootEntry(Obj, &Index);

            //
            // Now create the required entries
            //            
            while (TmpEntry) {
                if (OSBE_IS_NEW(TmpEntry) && !NT_SUCCESS(EFIOSBEFlush(TmpEntry))) {
                    Result = FALSE;
                }

                TmpEntry = OSBOGetNextBootEntry(Obj, &Index);
            }
        }

        //
        // Safety check
        //
        OrderCount = min(Obj->BootOrderCount, Obj->EntryCount);
        
        //
        // Write the boot entry order
        //        
        if (!NT_SUCCESS(NtSetBootEntryOrder(Obj->BootOrder,
                            OrderCount))) {
            Result = FALSE;
        }

        //
        // Write the other boot options
        //
        This->NtBootOptions->Timeout = Obj->Timeout;

        //
        // Make sure NextBootEntry points to the active boot entry
        // so that we can boot the active boot entry
        //                
        if (Obj->BootOrderCount) {
            This->NtBootOptions->NextBootEntryId = Obj->BootOrder[0];
        }            
            
        if (!NT_SUCCESS(NtSetBootOptions(This->NtBootOptions,
                            FieldsToChange))) {
            Result = FALSE;
        }            

        //
        // Logic for drivers here so that they get flushed like boot entries.
        //

        //
        // Flush the modified entries.
        //
        if (Result){
            PDRIVER_ENTRY         DriverListEntry = NULL;
                
            DriverListEntry = Obj->DriverEntries;
            
            while (DriverListEntry){                
                if (!DRIVERENT_IS_DELETED(DriverListEntry) &&
                    !DRIVERENT_IS_NEW(DriverListEntry) &&
                    !NT_SUCCESS(OSDriverEntryFlush(DriverListEntry))){
                    
                    Result = FALSE;
                }
                DriverListEntry = OSBOGetNextDriverEntry(Obj, DriverListEntry);            
            }
        }

        //
        // Process Deleted driver entries.
        //
        if (Result){
            PDRIVER_ENTRY   DriverListEntry = NULL;
                
            DriverListEntry = Obj->DriverEntries;
            
            while (DriverListEntry){                
                if (DRIVERENT_IS_DELETED(DriverListEntry) &&                    
                    !NT_SUCCESS(OSDriverEntryFlush(DriverListEntry))){
                    
                    Result = FALSE;
                }
                DriverListEntry = OSBOGetNextDriverEntry(Obj, DriverListEntry);            
            }
            
        }

        //
        // Process new added driver entries.
        //
        if (Result){
            PDRIVER_ENTRY         DriverListEntry = NULL;
                
            DriverListEntry = Obj->DriverEntries;
            
            while (DriverListEntry){                
                if (DRIVERENT_IS_NEW(DriverListEntry) &&                    
                    !NT_SUCCESS(OSDriverEntryFlush(DriverListEntry))){
                    
                    Result = FALSE;
                }
                DriverListEntry = OSBOGetNextDriverEntry(Obj, DriverListEntry);            
            }
            
        }

        //
        // Safety check
        //
        OrderCount = min(Obj->DriverEntryOrderCount, Obj->DriverEntryCount);
        
        //
        // Write the driver entry order
        //        
        if (!NT_SUCCESS(NtSetDriverEntryOrder(Obj->DriverEntryOrder,
                                            OrderCount))) {
            Result = FALSE;
        }
        
    }

    return Result;
}

static
BOOLEAN
EFIGetHardDrivePath(
    IN PFILE_PATH SrcFilePath,
    OUT PFILE_PATH NewFilePath 
    )
{
    BOOLEAN Result = FALSE;

    if (SrcFilePath && NewFilePath) {
        EFI_DEVICE_PATH UNALIGNED *Node = (EFI_DEVICE_PATH UNALIGNED *)SrcFilePath->FilePath;
        
        while (FALSE == IsDevicePathEndType(Node)) {
            if ((DevicePathType(Node) == MEDIA_DEVICE_PATH) &&
                 (DevicePathSubType(Node) == MEDIA_HARDDRIVE_DP)) {
                ULONG LengthToDelete = (ULONG)((PUCHAR)Node - (PUCHAR)SrcFilePath->FilePath);
                
                NewFilePath->Version = SrcFilePath->Version;
                NewFilePath->Length = SrcFilePath->Length - LengthToDelete;
                NewFilePath->Type = SrcFilePath->Type;
                memcpy(NewFilePath->FilePath, Node,
                    NewFilePath->Length);

                Result = TRUE;
                break;
            }

            Node = NextDevicePathNode(Node);
        }
    }
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\efi\efisbent.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    efisbent.h

Abstract:

    EFI boot entry and EFI boot options abstractions.

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)  14 Feb 2001

Revision History:

    None.

--*/

#pragma once

#include <sbentry.h>

#if defined(EFI_NVRAM_ENABLED)       

//
// EFI boot entry abstraction
//
typedef struct _EFI_OS_BOOT_ENTRY {
    OS_BOOT_ENTRY   OsBootEntry;
    PBOOT_ENTRY     NtBootEntry;
} EFI_OS_BOOT_ENTRY, *PEFI_OS_BOOT_ENTRY;


//
// EFI boot options abstraction
//
typedef struct _EFI_OS_BOOT_OPTIONS {
    OS_BOOT_OPTIONS         OsBootOptions;
    PBOOT_OPTIONS           NtBootOptions;    
    PBOOT_ENTRY_LIST        NtBootEntries;
    PEFI_DRIVER_ENTRY_LIST  DriverEntries;
} EFI_OS_BOOT_OPTIONS, *PEFI_OS_BOOT_OPTIONS;


//
// EFI_OS_BOOT_ENTRY Methods
//
POS_BOOT_ENTRY
EFIOSBECreate(
    IN PBOOT_ENTRY Entry,
    IN POS_BOOT_OPTIONS Container
    );

VOID
EFIOSBEDelete(
    IN  POS_BOOT_ENTRY  This
    );

BOOLEAN
EFIOSBEFlush(
    IN POS_BOOT_ENTRY This
    );

//
// EFI_OS_BOOT_OPTIONS Methods
//
POS_BOOT_OPTIONS
EFIOSBOCreate(
    VOID
    );

    
BOOLEAN
EFIOSBOFlush(
    IN POS_BOOT_OPTIONS This
    );
    
VOID
EFIOSBODelete(
    IN POS_BOOT_OPTIONS This
    );

POS_BOOT_ENTRY
EFIOSBOAddNewBootEntry(
    IN POS_BOOT_OPTIONS This,
    IN PCWSTR            FriendlyName,
    IN PCWSTR            OsLoaderVolumeName,
    IN PCWSTR            OsLoaderPath,
    IN PCWSTR            BootVolumeName,
    IN PCWSTR            BootPath,
    IN PCWSTR            OsLoadOptions
    );

BOOLEAN
EFIOSBEFillNtBootEntry(
    IN PEFI_OS_BOOT_ENTRY Entry
    );
    
BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    );    

#define IS_BOOT_ENTRY_ACTIVE(_be) \
            (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
            
#define IS_BOOT_ENTRY_WINDOWS(_be) \
            (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_WINDOWS) != 0)
            
#define IS_BOOT_ENTRY_REMOVABLE_MEDIA(_be) \
            (((_be)->Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) != 0)    

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)   
#define ADD_BYTE_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_o))

    
#endif  // for EFI_NVRAM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bosprep\cmdline.h ===
#ifndef _CMDLINE_H
#define _CMDLINE_H

inline LPCTSTR _FindOption(LPCTSTR p1)
{
	if (p1 == NULL)
		return NULL;

	// loop until end of string
	while (*p1)
	{
		// if space then check next char for option (- or /)
		if (*p1 == _T(' '))
		{
			p1 = CharNext(p1);
			if (*p1 == _T('-') || *p1 == _T('/'))
				return CharNext(p1);
		}
		// if quote then skip over quoted string
		else if (*p1 == _T('"'))
		{
			// loop until single quote or end of string found
			p1 = CharNext(p1);
			while (*p1)
			{
				if (*p1 == _T('"'))
				{
					p1 = CharNext(p1);
					if (*p1 != _T('"'))
						break;
				}
				p1 = CharNext(p1);
			}
			
		}
		else
		{
			p1 = CharNext(p1);
		}
	}

	return NULL;
}


inline BOOL _ReadParam(/*in,out*/TCHAR* &pszIn, /*out*/TCHAR* pszOut)
{
    ATLASSERT(pszIn && pszOut);
    if (!pszIn || !pszOut) {
        return FALSE;
    }

    // skip the switch
    pszIn = CharNext(pszIn);

    // skip leading spaces
    while (*pszIn == _T(' '))
        pszIn = CharNext(pszIn);

    // deal with parameters enclosed in quotes to allow embedded spaces
    BOOL fQuoted = FALSE;
    if (*pszIn == _T('"')) {
        pszIn = CharNext(pszIn);
        fQuoted = TRUE;
    }

    // get the next arg (delimited by space or null or end quote)
    int nPos = 0;
    while (*pszIn && nPos < MAX_PATH) {
        if (fQuoted) {
            if (*pszIn == _T('"')) {
                // don't break on double quotes
                if (pszIn[1] == _T('"')) {
                    pszOut[nPos++] = *pszIn;
                    pszIn = CharNext(pszIn);
                    pszIn = CharNext(pszIn);
                    continue;
                }
                else {
                    pszIn = CharNext(pszIn);
                    break;
                }
            }
        }
        else { 
            if(*pszIn == _T(' '))
               break;
        }
        pszOut[nPos++] = *pszIn;
        pszIn = CharNext(pszIn);
    }
    pszOut[nPos] = 0;

    return TRUE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bootent\test\test.c ===
#include <efisbent.h>
#include <tchar.h>
#include <stdlib.h>


VOID
TraceResult(
    IN  PWSTR   Feature,
    IN BOOLEAN  Result
    )
{
    wprintf(L"%ws : %ws\n", Feature, Result ? L"Passed" : L"Failed");

    if (!Result) {
        exit(0);
    }        
}

VOID
DumpFilePath(
    IN  PFILE_PATH  FilePath
    )
{
    if (FilePath) {
        wprintf(L"%d:%ws\n", 
            FilePath->Type,
            FilePath->FilePath);
    }
}

VOID
DumpOsBootEntry(
    IN  POS_BOOT_ENTRY  Entry
    )
{
    if (Entry) {
        wprintf(L"%0d=>%ws,(%ws,%ws),(%ws,%ws),%ws\n", 
            OSBEGetId(Entry),
            OSBEGetFriendlyName(Entry),
            OSBEGetOsLoaderVolumeName(Entry),
            OSBEGetOsLoaderPath(Entry),
            OSBEGetBootVolumeName(Entry),
            OSBEGetBootPath(Entry),
            OSBEGetOsLoadOptions(Entry)
            );                       
    }
}

VOID
DumpDrvBootEntry(
    IN PDRIVER_ENTRY This
    )
{
    if (This){
        wprintf(L"%0d=>%ws, %ws,(%ws, %ws)\n", 
            OSDriverGetId(This),
            OSDriverGetFriendlyName(This),
            OSDriverGetFileName(This),
            OSDriverGetDevicePath(This),
            OSDriverGetFilePath(This));
        
    }
}
    
VOID
DumpOsBootOptions(
    IN  POS_BOOT_OPTIONS Options
    )
{
    if (Options) {
        ULONG   Index;
        POS_BOOT_ENTRY  Entry = OSBOGetFirstBootEntry(Options, &Index);
        PDRIVER_ENTRY   DrvEntry = OSBOGetFirstDriverEntry(Options);

        wprintf(L"\n");
        
        while (Entry) {
            DumpOsBootEntry(Entry);
            Entry = OSBOGetNextBootEntry(Options, &Index);
        }

        for (Index=0; 
            Index < OSBOGetOrderedBootEntryCount(Options);
            Index++) {
            wprintf(L"%04d,", OSBOGetBootEntryIdByOrder(Options, Index));
        }             

        wprintf(L"\n DriverEntries \n");

        for (DrvEntry; 
             DrvEntry != NULL; 
             DrvEntry = DrvEntry->NextEntry){
                
            DumpDrvBootEntry(DrvEntry);
            
        }

        wprintf(L"\n\n");
    }
}

INT
__cdecl 
main(
    IN  INT Argc,
    IN  CHAR *Argv[]
    )
{
    POS_BOOT_OPTIONS    OsBootOptions = NULL;
    POS_BOOT_ENTRY  NewEntry;
    POS_BOOT_ENTRY  ActiveBootEntry;
    POS_BOOT_ENTRY  ConvertedEntry;

    PDRIVER_ENTRY NewDriverEntry = NULL ;
    PDRIVER_ENTRY FindDrvEntry = NULL;

    if (OSBOLibraryInit((SBEMemAllocateRoutine)malloc, (SBEMemFreeRoutine)free)) {
            OsBootOptions = EFIOSBOCreate();
    }

    TraceResult(L"Creating EFI OS BootOptions", (OsBootOptions != NULL));

    DumpOsBootOptions(OsBootOptions);        

    //
    // Add test
    //
    NewEntry = OSBOAddNewBootEntry(OsBootOptions,
                    L"Add Testing",
                    L"\\Device\\HarddiskVolume1",
                    L"\\setupldr.efi",
                    L"\\Device\\HarddiskVolume3",
                    L"\\WINDOWS",
                    L"/dummy1 /dummy2");                
                    
    TraceResult(L"Add test : ", (NewEntry != NULL));    
    DumpOsBootEntry(NewEntry);
    
    //
    // Search test
    //
    ActiveBootEntry = OSBOFindBootEntry(OsBootOptions, 7);
    TraceResult(L"Getting boot entry 0", (ActiveBootEntry != NULL));    
    DumpOsBootEntry(ActiveBootEntry);

    //
    // Get active test
    //
    ActiveBootEntry = OSBOGetActiveBootEntry(OsBootOptions);
    TraceResult(L"Getting active boot entry", (ActiveBootEntry != NULL));    
    DumpOsBootEntry(ActiveBootEntry);

    //
    // Set active test
    //
    ActiveBootEntry = OSBOSetActiveBootEntry(OsBootOptions, NewEntry);
    TraceResult(L"Setting active boot entry", (ActiveBootEntry != NULL));
    ActiveBootEntry = OSBOGetActiveBootEntry(OsBootOptions);
    TraceResult(L"Getting active boot entry again", (ActiveBootEntry != NULL));    
    DumpOsBootEntry(ActiveBootEntry);    

    DumpOsBootOptions(OsBootOptions);   
    
    //
    // Delete boot entry test
    //
    TraceResult(L"Deleting new boot entry",
            OSBODeleteBootEntry(OsBootOptions, NewEntry));

    DumpOsBootOptions(OsBootOptions); 

    //
    // Add driver test entry
    //
    NewDriverEntry = OSBOAddNewDriverEntry(OsBootOptions, 
                                     L"My Test Driver Entry", 
                                     L"\\Device\\HarddiskVolume1",
                                     L"\\EFI\\Microsoft\\EFIDrivers\\fpswa.sys");

    
    TraceResult(L"Add Driver entry test : ", (NewDriverEntry != NULL));    
    DumpDrvBootEntry(NewDriverEntry);

    //
    // Delete Driver entry test
    //
    TraceResult(L"Deleting driver entry",
            OSBODeleteDriverEntry(OsBootOptions, NewDriverEntry->Id));

    DumpOsBootOptions(OsBootOptions); 

    OSBODelete(OsBootOptions);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bosprep\promptforpathdlg.h ===
//-----------------------------------------------------------------------------
// PromptForPathDlg.h
//-----------------------------------------------------------------------------


#ifndef _PROMPTFORPATHDLG_H
#define _PROMPTFORPATHDLG_H

class CPromptForPathDlg : public CDialogImpl< CPromptForPathDlg >
{
    //-------------------------------------------------------------------------
    // Functions
    //-------------------------------------------------------------------------
    public:

    BEGIN_MSG_MAP(CPromptForPathDlg)
        MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
        COMMAND_ID_HANDLER( IDOK, OnOK )
        COMMAND_ID_HANDLER( IDCANCEL, OnCancel )
        COMMAND_ID_HANDLER( IDC_BNBrowse, OnBrowse )
    END_MSG_MAP()

    CPromptForPathDlg       ( CComBSTR bszDef, HINSTANCE hInst, BOOL bWinSB );
    LRESULT OnInitDialog    ( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnOK            ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& handled );
    LRESULT OnCancel        ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& handled );
    LRESULT OnBrowse        ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& handled );
    void    GetInput        ( CComBSTR* bsz );

    //-------------------------------------------------------------------------
    // Variables
    //-------------------------------------------------------------------------
    public:

    typedef CDialogImpl< CPromptForPathDlg >        BC;
    enum { IDD = IDD_PromptForPath };

    CComBSTR                m_bszComp;
    CComBSTR                m_bszDef;
    HINSTANCE               m_hInst;
	BOOL					m_bWinSB;

};  // class CSmallProgressDlg


#endif  // _PROMPTFORPATHDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bosprep\promptforpathdlg.cpp ===
//-----------------------------------------------------------------------------
// PromptForPathDlg.cpp
//-----------------------------------------------------------------------------

#include "StdAfx.h"
#include "PromptForPathDlg.h"

#include <shlobj.h>

CPromptForPathDlg::CPromptForPathDlg( CComBSTR bszDef, HINSTANCE hInst, BOOL bWinSB ) :
	m_bWinSB(bWinSB)
{
    m_bszDef        = bszDef;
    m_hInst         = hInst;
}

LRESULT CPromptForPathDlg::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    USES_CONVERSION;
    CenterWindow( GetParent() );

    TCHAR szTitle[MAX_PATH];
    TCHAR szDlgPathText[MAX_PATH];

    LoadString( m_hInst, m_bWinSB ? IDS_WinSBTitle : IDS_SBSTitle, szTitle, sizeof(szTitle)/sizeof(TCHAR) );

    SetWindowText( szTitle );
    SetDlgItemText( IDC_EBPath, (TCHAR*)(OLE2T( (BSTR) m_bszDef )) );

	// depending on BOS or SBS, load the prompt
	UINT uPromptID = m_bWinSB ? IDS_WinSBPrompt : IDS_SBSPrompt;

	TCHAR szPrompt[MAX_PATH * 2];
	LoadString( m_hInst, uPromptID, szPrompt, MAX_PATH * 2 );
	SetDlgItemText( IDC_STPromptDlgText, szPrompt );

    return (0);
}

LRESULT CPromptForPathDlg::OnOK( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& handled )
{
    TCHAR* psz = new TCHAR[::GetWindowTextLength(GetDlgItem(IDC_EBPath)) + 1];
    if (psz)
	{
		GetDlgItemText( IDC_EBPath, psz, ::GetWindowTextLength(GetDlgItem(IDC_EBPath)) + 1 );
		m_bszDef = psz;
		delete[] psz;
	}
	else
	{
		m_bszDef = _T("");
	}
    EndDialog( IDOK );
    return (0);
}

LRESULT CPromptForPathDlg::OnCancel( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& handled )
{
    EndDialog( IDCANCEL );
    return (0);
}

LRESULT CPromptForPathDlg::OnBrowse( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& handled )
{
    CoInitialize(NULL);

    // Browse for folder.
    // If they pressed Cancel, change nothing.
    // If they chose a new folder, let's change our current path (m_bszDef).

    TCHAR pszDisplayName[MAX_PATH];
    int iImage = 0;

    LPMALLOC pMalloc;
    HRESULT hr = ::SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
        //CString csTitle;
        TCHAR szTitle[MAX_PATH];

        LoadString( m_hInst, IDS_ChooseFolderTitle, szTitle, sizeof(szTitle)/sizeof(TCHAR) );

        BROWSEINFO BrowseInfo;
        BrowseInfo.hwndOwner = m_hWnd;
        BrowseInfo.pidlRoot = NULL;
        BrowseInfo.pszDisplayName = pszDisplayName;
        BrowseInfo.lpszTitle = szTitle;
        BrowseInfo.ulFlags = BIF_RETURNONLYFSDIRS;
        BrowseInfo.lpfn = NULL;
        BrowseInfo.lParam = NULL;
        BrowseInfo.iImage = iImage;

        LPITEMIDLIST pList = ::SHBrowseForFolder(&BrowseInfo);

        TCHAR pBuffer[MAX_PATH];

        if (::SHGetPathFromIDList(pList, pBuffer))
        {
            m_bszDef = pBuffer;
            SetDlgItemText( IDC_EBPath, pBuffer );
        }

        pMalloc->Free(pList);
        pMalloc->Release();
    }
    else
    {
		TCHAR szErrTitle[1024] = { 0 };
		TCHAR szErrMsg[1024] = { 0 };
		LoadString( m_hInst, IDS_ErrorTitle, szErrTitle, 1024 );
		LoadString( m_hInst, IDS_BrowseFailed, szErrMsg, 1024 );

		::MessageBox(0, szErrMsg, szErrTitle, MB_OK | MB_ICONERROR);
    }

    CoUninitialize();
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bosprep\resource.h ===
#ifndef _RESOURCE_H
#define _RESOURCE_H


#define IDC_STATIC                              -1


//-----------------------------------------------------------------------------
// Dialogs
//-----------------------------------------------------------------------------
#define IDD_PromptForPath                       1001


//-----------------------------------------------------------------------------
// Controls
//-----------------------------------------------------------------------------
#define IDC_STPromptDlgText                     3001
#define IDC_EBPath                              3002
#define IDC_BNBrowse                            3003


//-----------------------------------------------------------------------------
// Localized Strings
//-----------------------------------------------------------------------------
#define IDS_BOSPrepFailed                       10
#define IDS_BOSCancelCDPrompt                   11
#define IDS_BOSPromptTitle                      13
#define IDS_PromptTitle2                        14
#define IDS_CantFindMsg                         15
#define IDS_ChooseFolderTitle                   17
#define IDS_BOSPrompt                           18
#define IDS_SBSPrompt                           19
#define IDS_BOSTitle                            20
#define IDS_SBSTitle                            21
#define IDS_SBSCancelCDPrompt                   22
#define IDS_SBSPromptTitle                      23
#define IDS_BrowseFailed                        24
#define IDS_ErrorTitle                          25

#define IDS_WinSBPrompt                         26
#define IDS_WinSBTitle                          27
#define IDS_WinSBCancelCDPrompt                 28
#define IDS_WinSBPromptTitle                    29


//-----------------------------------------------------------------------------
// Non-loc'd Strings
//-----------------------------------------------------------------------------
#define IDS_Version                             8000
#define IDS_UserInitKeyLoc                      8001
#define IDS_UserInitKeyName                     8002
#define IDS_CfgSrvKeyLoc                        8003
#define IDS_CfgSrvKeyName                       8004
#define IDS_SourcePathLoc                       8005
#define IDS_SourcePathName                      8006
#define IDS_SetupSwitch                         8007
#define IDS_BOSPrepLocEnd                       8008
#define IDS_BOlnk                               8009
#define IDS_SetupExe                            8010
#define IDS_SBSSwitch                           8011
#define IDS_EXEName                             8012

#define IDS_StoreExeKey                         8013
#define IDS_SBSUpgrade                          8014
#define IDS_SBSUpgradeVal                       8015
#define IDS_DllPatchSBSUpgrade                  8016
#define IDS_DllPatchVal                         8017
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bosprep\main.h ===
#ifndef _MAIN_H
#define _MAIN_H

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

//#include <applgroup.cpp>

// using tstring for all applicable wstrings
/*
#ifdef _UNICODE
	typedef	std::wstring	tstring;
#else
	typedef std::string		tstring;
#endif
*/

// Function Prototypes.
INT     ParseCmdLine( LPTSTR );
INT     RemoveFromUserinit(const TCHAR *);
INT     SuppressCfgSrvPage(void);
INT     GetSourcePath( TCHAR * , DWORD );
INT     PromptForPath( BSTR*  );
INT     VerifyPath( const TCHAR * );
HRESULT MakeLink(const TCHAR* const sourcePath, const TCHAR* const linkPath, const TCHAR* const args);
HRESULT	CheckDCPromoSwitch( TCHAR* pszCmdLine );
HRESULT CheckBOSSwitch( TCHAR* pszCmdLine );
VOID	GetParameter( TCHAR* pszCmdLine, TCHAR* pszSwitch, TCHAR* pszOut );
HRESULT CheckSuppressCYS( TCHAR* pszCmdLine );
VOID	GetSystemDrive(TCHAR** ppszDrive);

BOOL	g_bSBS;
BOOL    g_bWinSB;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bosprep\main.cpp ===
// main.cpp : Implementation of DLL Exports.

#include "StdAfx.h"
#include "resource.h"
#include "main.h"
#include "PromptForPathDlg.h"
#include "cmdline.h"
#include <shlobj.h>
#include "stdio.h"

CComModule _Module;

VOID DisableBalloons( BOOL bDisable );

/////////////////////////////////////////////////////////////////////////////
//

VOID AddBS( TCHAR* psz )
{
    if( !_tcslen(psz) )
    {
        return;
    }

    const TCHAR *szTemp = psz;
    const UINT iSize = _tcslen(psz);
    // MBCS-safe walk thru string to last char
    for (UINT ui = 0; ui < iSize; ui++)
        szTemp = CharNext(szTemp);

    // See if the last char is a "\"
    if (_tcsncmp( szTemp, _T("\\"), 1))
    {
        // Append a backslash
        _tcscat( psz, _T("\\") );
    }

}

int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    USES_CONVERSION;
    CoInitialize(NULL);
    _Module.Init(NULL, hInstance);
    TCHAR* pszLocation = NULL;

    // Necessary to grab argv[0] too so we can successfully parse argv[1] flag later... (_FindOption)
    lpCmdLine = GetCommandLine();

    if ( _tcsstr(lpCmdLine, _T("winsb")) ) 
    {
        g_bWinSB = TRUE;
    }
    else
    {
        g_bWinSB = FALSE;
    }

    INT     iRetVal = 0;
    TCHAR   szPath[MAX_PATH * 2];

    g_bSBS = FALSE;
    OSVERSIONINFO cInfo;
    cInfo.dwOSVersionInfoSize = sizeof( cInfo );
    if (!GetVersionEx( &cInfo ))
        goto CLEAN_UP;

    if( cInfo.dwMajorVersion >= 5 )
    {
        OSVERSIONINFOEX cInfoEx;
        cInfoEx.dwOSVersionInfoSize = sizeof( cInfoEx );
        GetVersionEx( (OSVERSIONINFO*)&cInfoEx );
        if( (cInfoEx.wSuiteMask & VER_SUITE_SMALLBUSINESS) || (cInfoEx.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED) )
        {
            g_bSBS = TRUE;
        }
    }
    
    // Supress the balloons!!
    DisableBalloons(TRUE);

    // look for the /suppresscys switch
    if( SUCCEEDED(CheckSuppressCYS(lpCmdLine)) )
    {
        goto CLEAN_UP;
    }

    // look for the /dcpromo switch on the command line.  if it's there, setup to re-startup
    //  with the rest of the command line, and then launch dcpromo.exe
    if( SUCCEEDED(CheckDCPromoSwitch(lpCmdLine)) )
    {
        // can check here for needing to show a message (i.e. if hr == S_FALSE)
        goto CLEAN_UP;
    }

    // if we didn't find /dcpromo, look for /bossetup and /bosunattend
    if( SUCCEEDED(CheckBOSSwitch(lpCmdLine)) )
    {
        // can check here for needing to show a message (i.e. if hr == S_FALSE)
        goto CLEAN_UP;
    }

    // Parse the cmdLine arguments to find out if we are setting up for BOS/SBS 5.0 Setup.
    INT iRunSetup = ParseCmdLine( lpCmdLine );

    // ------------------------------------------------------------------------
    // Parse command line the "real" way to look for the /l <setup location>
    // parameter.
    // ------------------------------------------------------------------------
    pszLocation = new TCHAR[_tcslen(lpCmdLine)+1];
    if ( !pszLocation )
    {
        goto CLEAN_UP;
    }
        
    _tcscpy( pszLocation, _T("") );
    if( pszLocation != NULL )
    {
        LPCTSTR lpszToken;
        LPTSTR pszCurrentPos;

        for ( lpszToken = _FindOption(lpCmdLine) ;                                      // Init to no bad usage and get the first param.
              (lpszToken != NULL) && (pszCurrentPos = const_cast<LPTSTR>(lpszToken)) ;  // While no bad usage and we still have a param...
              lpszToken = _FindOption(pszCurrentPos) )                                  // Get the next parameter.
        {
            switch(*pszCurrentPos)
            {
                case _T('l'):           // /l <setup location>
                case _T('L'):
                {
                    _ReadParam(pszCurrentPos, pszLocation);
                    break;
                }
            }
        }
    }   


    if ( iRunSetup )
    {
        // safely construct path from commandline if it exists.
        AddBS(pszLocation);

        INT         iLaunchSetup    = 1;
        CComBSTR    bszPath         = pszLocation ? pszLocation : _T("");
        CComBSTR    bszFilename     = _T("setup.exe");

        CComBSTR    bszSetupFile    = _T("");
        bszSetupFile += bszPath;
        bszSetupFile += bszFilename;            

        // First try out the path we got from the command line
        if( !VerifyPath((TCHAR*)OLE2T(bszSetupFile)) )
        {
            // If not, try getting one from the registry.
            TCHAR * szSourcePath = new TCHAR[MAX_PATH];
            if (szSourcePath)
            {
                if ( !GetSourcePath( szSourcePath, MAX_PATH ) )
                {
                    // Error reading the registry.
                    szSourcePath[0] = 0;
                }
                else
                {
                    AddBS(szSourcePath);
                }
    
                bszPath = szSourcePath;
                delete [] szSourcePath;
            }

            // Launch BO Setup
            bszSetupFile    = _T("");
            bszSetupFile += bszPath;
            bszSetupFile += bszFilename;

            // Try the default directory.
            if ( !VerifyPath((TCHAR*)OLE2T(bszSetupFile)) )
            {
                // If BOS/SBS setup.exe isn't there, prompt them for it.
                iLaunchSetup = PromptForPath( &bszPath );
            }
        }
        else
        {
            // clean off trailing backslash from bszPath so that the append of \setup.exe works.
            // the conditional logic here is a little ugly, but it works.
    
            WCHAR wszPath[MAX_PATH];
            int cbPathSize;
    
            wcscpy( wszPath, (WCHAR *)OLE2W(bszPath) );
            cbPathSize = wcslen( wszPath );
            wszPath[cbPathSize-1] = '\0';
            bszPath = wszPath;
        }
    

        // If the user wants to run setup...
        if ( iLaunchSetup )
        {
            CComBSTR bstrEXE = bszPath; 
//  NOTE:  No longer branching here because both WinSB and SBS have the same CD layout now.
//            if ( _tcsstr(lpCmdLine, _T("winsb")) ) // In the WinSB SKU, setup.exe is in a different dir.
//            {
                bstrEXE += _T("\\setup\\i386\\setup.exe");
//            }
//            else
//            {
//                bstrEXE += _T("\\sbs\\i386\\setup.exe");
//            }
            

            CComBSTR bstrRun = _T("setup.exe /chain");

            // CreateProcess.
            STARTUPINFO suinfo;
            memset( &suinfo, 0, sizeof(STARTUPINFO) );
            suinfo.cb = sizeof( STARTUPINFO );
            PROCESS_INFORMATION pinfo;

            if( CreateProcess( (TCHAR*)OLE2T(bstrEXE), (TCHAR*)OLE2T(bstrRun), NULL, NULL, FALSE, NULL, NULL, NULL, &suinfo, &pinfo) )
            {
                CloseHandle(pinfo.hProcess);
                CloseHandle(pinfo.hThread);
            }

        }
        else
        {
            // Nothing I guess..   let's just continue on with the cleanup.
        }

        // Clean up (remove BOSPrep.exe).
        TCHAR szSBS[MAX_PATH];
        LoadString( _Module.m_hInst, IDS_SBSSwitch, szSBS, sizeof(szSBS) / sizeof(TCHAR) );
        if( _tcsstr(lpCmdLine, szSBS) )
        {
            TCHAR szExe[MAX_PATH];
            LoadString( _Module.m_hInst, IDS_EXEName, szExe, sizeof(szExe) / sizeof(TCHAR) );

            SHGetSpecialFolderPath( NULL, szPath, CSIDL_SYSTEM, FALSE );
            AddBS( szPath );
            _tcscat( szPath, szExe );
        }
        else
        {
            TCHAR* szDrive = NULL;
            GetSystemDrive(&szDrive);
            lstrcpyn( szPath, szDrive, MAX_PATH );
            delete [] szDrive;

            AddBS( szPath );
            _tcscat( szPath, _T("bosprep.exe"));
        }

        MoveFileEx( szPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT );

        // Clean up (remove the shortcut from the StartUp folder).
        TCHAR szLinkPath[MAX_PATH + 64];
        if ( SHGetSpecialFolderPath(NULL, szLinkPath, CSIDL_COMMON_STARTUP, FALSE) )
        {
            TCHAR szTmp[64];
            LoadString( _Module.m_hInst, IDS_BOlnk, szTmp, sizeof(szTmp)/sizeof(TCHAR) );
            _tcscat( szLinkPath, szTmp );
            DeleteFile( szLinkPath );
        }
    }
    else
    {
        // Fix up the userinit regkey to make sure that DCPromo.exe is not in there.
        RemoveFromUserinit( _T("DCPromo") );

        // Suppress the Configure Your Server page.
        SuppressCfgSrvPage();

        // Add ourself to the StartUp with the /setup option so that we can
        //  begin BackOffice setup.
        TCHAR szLinkPath[MAX_PATH];

        // JeffZi: bosprep.exe will be copied to %PROGFILESDIR%\Microsoft BackOffice\Setup, except for
        //  SBS clean install cases, where it will be in %windir%\system32
        if( _tcsstr(lpCmdLine, _T("sbs")) || _tcsstr(lpCmdLine, _T("winsb")) )
        {
            TCHAR szExe[MAX_PATH];
            LoadString( _Module.m_hInst, IDS_EXEName, szExe, sizeof(szExe) / sizeof(TCHAR) );

            SHGetSpecialFolderPath( NULL, szPath, CSIDL_SYSTEM, FALSE );
            AddBS( szPath );
            _tcscat( szPath, szExe );
        }
        else
        {
            TCHAR* szDrive = NULL;
            GetSystemDrive(&szDrive);
            _tcsncpy( szPath, szDrive, sizeof(szPath) / sizeof(TCHAR) );
            delete [] szDrive;
            AddBS( szPath );
            _tcscat( szPath, _T("bosprep.exe"));
        }

        if ( SHGetSpecialFolderPath(NULL, szLinkPath, CSIDL_COMMON_STARTUP, FALSE) )
        {
            TCHAR szArgs[128];      // Used for IDS_IDS_SetupSwitch ("/setup")
            TCHAR szTmp[64];        // Used for IDS_BOlnk ("\\boinst.lnk")

            LoadString( _Module.m_hInst, IDS_BOlnk, szTmp, sizeof(szTmp)/sizeof(TCHAR) );
            _tcscat( szLinkPath, szTmp);
            LoadString( _Module.m_hInst, IDS_SetupSwitch, szArgs, sizeof(szArgs)/sizeof(TCHAR) );

            if ( _tcsstr(lpCmdLine, _T("winsb")) )
            {
                _tcscat( szArgs, _T(" /winsb") ); 
            }

            // Create the shortcut.
            MakeLink(szPath, szLinkPath, szArgs);
        }

        // Set the AppCompatibility\store.exe regkeys for SBS only.
        if ( g_bSBS )
        {
            HKEY        hk = NULL;
            CRegKey     cKey;
            DWORD       dwSize = 0;
            DWORD       dwDisp = 0;
            BYTE        byTmp;
            BYTE        byArray[1024];
            TCHAR       szKeyName[1024];
            TCHAR       szTmpKey[1024];
            TCHAR       szTmpVal[4096];
            TCHAR       *pszToken = NULL;

            memset(byArray, 0, 1024);
            _tcscpy(szKeyName, _T(""));
            _tcscpy(szTmpKey, _T(""));
            _tcscpy(szTmpVal, _T(""));

            LoadString( _Module.m_hInst, IDS_StoreExeKey, szKeyName, sizeof(szKeyName)/sizeof(TCHAR) );

            if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hk, &dwDisp) == ERROR_SUCCESS )
            {
                // "DllPatch-SBSUpgrade" = "_sbsw2ku.dll"
/*                LoadString( _Module.m_hInst, IDS_DllPatchSBSUpgrade, szTmpKey, sizeof(szTmpKey)/sizeof(TCHAR) );
                LoadString( _Module.m_hInst, IDS_DllPatchVal,        szTmpVal, sizeof(szTmpVal)/sizeof(TCHAR) );
                RegSetValueEx( hk, szTmpKey, NULL, REG_SZ, (LPBYTE)szTmpVal, (_tcslen(szTmpVal)+1)*sizeof(TCHAR) );
*/
                // "SBSUpgrade"=hex:0C,00,00,00, ... etc
                LoadString( _Module.m_hInst, IDS_SBSUpgrade,         szTmpKey, sizeof(szTmpKey)/sizeof(TCHAR) );
                LoadString( _Module.m_hInst, IDS_SBSUpgradeVal,      szTmpVal, sizeof(szTmpVal)/sizeof(TCHAR) );

                dwSize = 0;
                pszToken = _tcstok(szTmpVal, ",");
                while ( pszToken )
                {
                    byTmp = 0;
                    if(1==_stscanf( pszToken, _T("%x"), &byTmp ))
                    {
                        byArray[dwSize++] = byTmp;
                    }
                    else
                    {
                        byArray[dwSize++]= 0;
                    }
                    pszToken = _tcstok(NULL, ",");
                    
                }
                RegSetValueEx( hk, szTmpKey, NULL, REG_BINARY, byArray, dwSize );

                cKey.Close();
            }
        }
    }

CLEAN_UP:
    // Exit.
    if (pszLocation)
        delete [] pszLocation;
    CoUninitialize();
    _Module.Term();
    return iRetVal;
}


// ----------------------------------------------------------------------------
// parseCmdLine()
//
// Goes through the command line and checks if the "/setup" option is
//  present.  Since this program isn't really meant to be interactively
//  launched by the user, we will be a little sloppy with the way we look
//  at the commandline arguments.  That is, instead of making sure that there
//  is only one commandline argument, and that it "/setup"... we will instead
//  just try to find "/setup" somewhere in the commandline.
//
// Return:
//  0 if the setup switch string was NOT found in the cmd line.
//  1 if the setup switch string WAS found in the cmd line.
// ----------------------------------------------------------------------------
INT ParseCmdLine( LPTSTR lpCmdLine )
{
    TCHAR   szSetup[MAX_PATH];

    LoadString( _Module.m_hInst, IDS_SetupSwitch, szSetup, sizeof(szSetup)/sizeof(TCHAR) );

    // If we find the setup switch string (/setup) in the cmd line, then we are setting
    //  up to run BackOffice setup, so we'll return 1.
    if ( _tcsstr( lpCmdLine, szSetup ) )
        return(1);

    return(0);
}


// ----------------------------------------------------------------------------
// promptForPath()
//
// Displays UI to the user asking for the location of the BackOffice 5 CD1
//  so that we can launch setup.
//
// Return:
// 0 if the user pressed cancel when prompted for the path.
// 1 if we're ready to launch setup!
// ----------------------------------------------------------------------------
INT PromptForPath( BSTR* pbszPath )
{
    USES_CONVERSION;
    INT_PTR                 iRet = 0;
    CPromptForPathDlg*      pPromptDlg = NULL;
    TCHAR                   szTmpMsg[MAX_PATH];

    if( !pbszPath )
        return (0);

    CComBSTR bszDefault = *pbszPath;
    if (!bszDefault)
        return 0;
    SysFreeString( *pbszPath );
    HWND hWndParent = GetActiveWindow();

    pPromptDlg = new CPromptForPathDlg( bszDefault, _Module.m_hInst, g_bWinSB );
    if ( !pPromptDlg ) return(0);

    bool bNotDone = true;
    while (bNotDone == true)
    {
        iRet = pPromptDlg->DoModal( hWndParent );
        pPromptDlg->m_hWnd = NULL;
        if( iRet == IDOK )
        {
            // leave this as a SysAllocString
            *pbszPath = SysAllocString( pPromptDlg->m_bszDef );
            if (*pbszPath == NULL)
                goto CLEAN_UP;

            CComBSTR bszTmp = *pbszPath;
            bszTmp += _T("\\setup.exe");
            // Check if the path they chose was correct.
            if ( VerifyPath((TCHAR*)OLE2T(bszTmp)) )
            {
                bNotDone = false;           // If so, let's just move on.
            }
            else
            {
                bNotDone = true;            // If not, ask again.
                SysFreeString( *pbszPath );
                LoadString( _Module.m_hInst, IDS_CantFindMsg, szTmpMsg, sizeof(szTmpMsg)/sizeof(TCHAR) );
                TCHAR szTmpTitle[128];
                LoadString( _Module.m_hInst, g_bWinSB ? IDS_WinSBTitle : IDS_SBSTitle, szTmpTitle, sizeof(szTmpTitle)/sizeof(TCHAR) );
                ::MessageBox( hWndParent, szTmpMsg, szTmpTitle, MB_OK | MB_ICONEXCLAMATION );
            }
        }
        else if ( iRet == IDCANCEL )
        {
            INT iDoCancel = 0;  // note we do NOT use iRet here
    
            LoadString( _Module.m_hInst, g_bWinSB ? IDS_WinSBCancelCDPrompt : IDS_SBSCancelCDPrompt, szTmpMsg, sizeof(szTmpMsg)/sizeof(TCHAR) );
            TCHAR szTmpTitle[MAX_PATH];
            LoadString( _Module.m_hInst, g_bWinSB ? IDS_WinSBTitle : IDS_SBSTitle, szTmpTitle, sizeof(szTmpTitle)/sizeof(TCHAR) );
            iDoCancel = ::MessageBox( hWndParent, szTmpMsg, szTmpTitle, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2 );

            if ( iDoCancel == IDYES )
            {
                bNotDone = false;
            }
            // else we will reprompt them for the CD
        }
        else
        {
            // we don't know how to handle any other return values
            //::MessageBox(::GetForegroundWindow(), _T("AHhhhhhhhhhh"), _T("DEBUG"), MB_OK);
        }
    }


CLEAN_UP:
    if (pPromptDlg)
    {
        delete pPromptDlg;
        pPromptDlg = NULL;
    }

    return( iRet==IDOK ? 1 : 0 );
}



// ----------------------------------------------------------------------------
// removeFromUserinit()
//
// Opens the Userinit registry key and searches for the 'szToRemove' string.
//  If it finds the string, it removes that entry from the string.
//  (i.e. it removes the string and also the following comma and spaces).
//
// NOTE: This function only removes the first occurance of the szToRemove.
//       If you want to remove all occurances, simply loop around this
//       function until the returned value is 0.
//
// Return:
//  0 if an error of any kind occured.
//  1 if everything went as planned.
// ----------------------------------------------------------------------------
INT RemoveFromUserinit(const TCHAR * szToRemove)
{
    TCHAR       szToRemCpy[MAX_PATH];
    TCHAR       szKeyName[MAX_PATH];
    TCHAR *     szBuffer    = NULL;
    TCHAR *     szTmpBuf    = NULL;
    TCHAR *     ptc         = NULL;
    TCHAR *     p           = NULL;
    TCHAR *     q           = NULL;
    DWORD       dwOffset    = 0;
    DWORD       dwLen       = 0;
    BOOL        bAlreadyFixed = FALSE;
    CRegKey     cKey;

    // Check to make sure a valid string was passed in.
//    ASSERT(szToRemove);
    if (!szToRemove)
        return(0);                                  // If error, return 0.

    // Copy the passed in string to our "szToRemCpy"
    _tcsncpy(szToRemCpy, szToRemove, MAX_PATH);
    szToRemCpy[MAX_PATH-1] = 0;

    // Try to open the regkey.
    LoadString( _Module.m_hInst, IDS_UserInitKeyLoc, szKeyName, sizeof(szKeyName)/sizeof(TCHAR) );
    if ( cKey.Open(HKEY_LOCAL_MACHINE, szKeyName) != ERROR_SUCCESS )
        return(0);                                  // If error, return 0.

    if ( !(szBuffer = new TCHAR[MAX_PATH]) )        // Malloc and check...
    {
//        ASSERT(FALSE);
        cKey.Close();                               // Close the regkey.
        return(0);                                  // If error, return 0.
    }

    // Try to get the value of "userinit"
    dwLen = MAX_PATH;
    LoadString( _Module.m_hInst, IDS_UserInitKeyName, szKeyName, sizeof(szKeyName)/sizeof(TCHAR) );
    if ( cKey.QueryValue(szBuffer, szKeyName, &dwLen) != ERROR_SUCCESS )
    {
        delete[] szBuffer;                          // Free up that memory.
        cKey.Close();                               // Close the regkey.
        return(0);                                  // If error, return 0.
    }

    _tcslwr(szBuffer);                              // Convert to lowercase.
    _tcslwr(szToRemCpy);                            // Convert to lowercase.

    // See if the 'szToRemCpy' string is in the userinit string.
    if ( (ptc = _tcsstr(szBuffer, szToRemCpy)) == NULL )
    {
        delete[] szBuffer;
        cKey.Close();                               // Close the regkey.
        return(0);
    }

    dwOffset = _tcslen(szToRemCpy);
    for ( ; (ptc != szBuffer) && (*ptc != _T(',')); ptc--, dwOffset++ );    // Find the comma before this if it exists.
                                                                        // AHHHHHHHHHHHHHHHHH..  fix that char (',').
    if ( ptc != szBuffer )                                              // If we found a comma,
        bAlreadyFixed = true;                                           // then signal that we already removed a comma.

    // Now that we know that the string to remove is indeed in the userinit regkey (and 'ptc' points to
    //  the beginning of that sub string), we can copy all of the old buffer into the new buffer and
    //  just omit the szToRemove part.
    if ( !(szTmpBuf = new TCHAR[dwLen]) )
    {
//        ASSERT(FALSE);
        delete[] szBuffer;
        cKey.Close();
        return(0);
    }

    //  p = Source string
    //  q = Target string
    for ( p = szBuffer, q = szTmpBuf; (*p != 0) && (p != ptc); *q++ = *p++ );   // Copy until we hit the beginning of what we want to remove.
    if ( *p != 0 )
        p += dwOffset;                                      // Move our source pointer forward.
    for ( ; (*p != 0) && (*p != _T(',')); p++ );            // AHHHHHHHHHHHHHHHHH..  fix that char (',').
    if ( !bAlreadyFixed )
    {                                                       // If we haven't already removed a comma,
        if (*p != 0)
            p++;                                            // then let's remove this one.
    }
    for ( ; (*p != 0) && (_istspace(*p)); p++ );            // Find the beginning of the next program.
    for ( ; *p != 0; *q++ = *p++ );                         // Now copy until the end.
    *q = 0;

    // Now right the new and improved string to the registry.
    LoadString( _Module.m_hInst, IDS_UserInitKeyName, szKeyName, sizeof(szKeyName)/sizeof(TCHAR) );
    cKey.SetValue( szTmpBuf, szKeyName );

    delete[] szTmpBuf;                              // Free up that memory.
    delete[] szBuffer;                              // Free up that memory.
    cKey.Close();                                   // Close the regkey.

    return(1);                                      // Return success.
}


// ----------------------------------------------------------------------------
// suppressCfgSrvPage()
//
// Opens the "show" registry key and changes it's value to 0 to turn off the
// "Configure Your Server" screen.
//
// Return:
//  0 if an error of any kind occured.
//  1 if everything went as planned.
// ----------------------------------------------------------------------------
INT SuppressCfgSrvPage(void)
{
    TCHAR       szKeyName[MAX_PATH];
    DWORD       dwTmp=0;
    CRegKey     cKey;

    // Try to open the regkey.
    LoadString( _Module.m_hInst, IDS_CfgSrvKeyLoc, szKeyName, sizeof(szKeyName)/sizeof(TCHAR) );
    if ( cKey.Open(HKEY_CURRENT_USER, szKeyName) != ERROR_SUCCESS )
        return(0);                                  // If error, return 0.

    // Try to set the value.
    LoadString( _Module.m_hInst, IDS_CfgSrvKeyName, szKeyName, sizeof(szKeyName)/sizeof(TCHAR) );
    if ( cKey.SetValue(dwTmp, szKeyName) != ERROR_SUCCESS )
    {
        cKey.Close();                               // Close the regkey.
        return(0);                                  // If error, return 0.
    }

    cKey.Close();
    return(1);
}


INT GetSourcePath( TCHAR * szPath, DWORD dwCount )
{
    TCHAR       szKeyName[MAX_PATH];
    CRegKey     cKey;
    DWORD       dw = dwCount;

    // Try to open the regkey.
    LoadString( _Module.m_hInst, IDS_SourcePathLoc, szKeyName, sizeof(szKeyName)/sizeof(TCHAR) );
    if ( cKey.Open(HKEY_LOCAL_MACHINE, szKeyName) != ERROR_SUCCESS )
        return(0);

    // Try to get the value
    LoadString( _Module.m_hInst, IDS_SourcePathName, szKeyName, sizeof(szKeyName)/sizeof(TCHAR) );
    if ( cKey.QueryValue( szPath, szKeyName, &dw ) != ERROR_SUCCESS )
    {
        cKey.Close();
        return(0);
    }

    cKey.Close();
    return(1);
}


// ----------------------------------------------------------------------------
// verifyPath()
//
// Checks to make sure that the BOS/SBS setup.exe exists at the given location.
//
// Returns:
//  0 if BOS/SBS setup was not found at that location
//  1 if setup WAS found at the location.
// ----------------------------------------------------------------------------
INT VerifyPath( const TCHAR *szPath )
{
    if( !szPath )
        return (0);

    return (INVALID_FILE_ATTRIBUTES != GetFileAttributes(szPath));
    
}


// ----------------------------------------------------------------------------
// makeLink()
//
// This function creates a shortcut, "sourcePath," that points to "linkPath"
//  with the commandline arguments of "args."
//
// Return:
//  S_OK if the shortcut was successfully created.
//  Some sort of error (FAILED(hr)) if any error occured.
// ----------------------------------------------------------------------------
HRESULT MakeLink(const TCHAR* const sourcePath, const TCHAR* const linkPath, const TCHAR* const args)
{
    if ( !sourcePath || !linkPath || !args )
        return(E_FAIL);

    IShellLink* pShellLink = NULL;
    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
        IID_IShellLink, reinterpret_cast<void**>(&pShellLink));
    if (FAILED(hr))
        goto CLEAN_UP;

    hr = pShellLink->SetPath(sourcePath);
    if (FAILED(hr))
        goto CLEAN_UP;

    hr = pShellLink->SetArguments(args);
    if (FAILED(hr))
        goto CLEAN_UP;

    IPersistFile* pPersistFile = NULL;
    hr = pShellLink->QueryInterface(IID_IPersistFile, reinterpret_cast<void**>(&pPersistFile));
    if (FAILED(hr))
        goto CLEAN_UP;

    USES_CONVERSION;
    hr = pPersistFile->Save(T2OLE(linkPath), TRUE);
    if (FAILED(hr))
        return hr;

CLEAN_UP:
    if (pPersistFile)
        pPersistFile->Release();
    if (pShellLink)
        pShellLink->Release();

    return hr;
}

HRESULT CheckDCPromoSwitch( TCHAR* pszCmdLine )
{
    HRESULT hr = S_OK;
    CComBSTR bstrRun;
    CComBSTR bstrEXE;

    TCHAR* pszDCPromo = NULL;
    TCHAR* pszBOSUnattend = NULL;
    TCHAR* pszBOSSetup = NULL;
    TCHAR* pszNewCmd = NULL;

    if (!pszCmdLine)
        return E_INVALIDARG;

    pszDCPromo = new TCHAR[_tcslen(pszCmdLine) + 1];
    if (!pszDCPromo)
        return E_OUTOFMEMORY;

    GetParameter( pszCmdLine, _T("/dcpromo"), pszDCPromo );
    if( !_tcslen(pszDCPromo) )
    {
        hr = E_FAIL;
        goto CLEAN_UP;
    }

    // make sure that /bosunattend and /bossetup are on the cmd line as well
    pszBOSUnattend = new TCHAR[_tcslen(pszCmdLine) + 1];
    if (!pszBOSUnattend)
    {
        hr = E_OUTOFMEMORY;
        goto CLEAN_UP;
    }
    GetParameter( pszCmdLine, _T("/bosunattend"), pszBOSUnattend );

    pszBOSSetup = new TCHAR[_tcslen(pszCmdLine) + 1];
    if (!pszBOSSetup)
    {
        hr = E_OUTOFMEMORY;
        goto CLEAN_UP;
    }
    GetParameter( pszCmdLine, _T("/bossetup"), pszBOSSetup );

    if( !_tcslen(pszBOSSetup) || !_tcslen(pszBOSUnattend) )
    {
        hr = S_FALSE;
        goto CLEAN_UP;
    }

    // build the new command line (basically remove the dcpromo switch)
    pszNewCmd = new TCHAR[_tcslen(pszBOSSetup) + _tcslen(pszBOSUnattend) + MAX_PATH];
    if (!pszNewCmd)
    {
        hr = E_OUTOFMEMORY;
        goto CLEAN_UP;
    }
    
    _tcscpy( pszNewCmd, _T("/bosunattend ") );
    _tcscat( pszNewCmd, pszBOSUnattend );
    _tcscat( pszNewCmd, _T(" /bossetup ") );
    _tcscat( pszNewCmd, pszBOSSetup );

    // get the path to our exe
    TCHAR szOurPath[MAX_PATH * 2];
    if (!GetModuleFileName( NULL, szOurPath, MAX_PATH * 2 ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEAN_UP;
    }

    // make the path to the .lnk
    TCHAR szTmp[64];        // Used for IDS_BOlnk ("\\boinst.lnk")
    if (0 == LoadString( _Module.m_hInst, IDS_BOlnk, szTmp, sizeof(szTmp)/sizeof(TCHAR) ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEAN_UP;
    }

    TCHAR szLinkPath[MAX_PATH + 64];
    if (!SHGetSpecialFolderPath( NULL, szLinkPath, CSIDL_COMMON_STARTUP, FALSE ))
    {
        // MSDN doesn't indicate that SHGetSpecialFolderPath sets GetLastError
        hr = E_FAIL;
        goto CLEAN_UP;
    }

    _tcscat( szLinkPath, szTmp );

    // create the startup link
    if (FAILED(hr = MakeLink( szOurPath, szLinkPath, pszNewCmd )))
        goto CLEAN_UP;

    // run dcpromo.exe with the command line
    // Ensure path is enclosed in quotes
    bstrEXE = _T("\"");
    TCHAR szPath[MAX_PATH] = {0};
    if (0 == GetSystemDirectory(szPath, sizeof(szPath) / sizeof(TCHAR)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CLEAN_UP;
    }
    bstrEXE += szPath;
    bstrEXE += _T("dcpromo.exe\"");
    bstrRun = _T("dcpromo.exe /answer:");
    bstrRun += pszDCPromo;

    USES_CONVERSION;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwRet;
    memset( &si, 0, sizeof(STARTUPINFO) );
    si.cb = sizeof( STARTUPINFO );

    if( CreateProcess( (TCHAR*)OLE2T(bstrEXE), (TCHAR*)OLE2T(bstrRun), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi) )
    {
        do
        {
            dwRet = MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, 100, QS_ALLINPUT);
            if (dwRet == WAIT_OBJECT_0 + 1)
            {
                MSG msg;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
        while (dwRet != WAIT_OBJECT_0 && dwRet != WAIT_FAILED);
        
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }

CLEAN_UP:
    if (pszDCPromo)
        delete [] pszDCPromo;
    if (pszBOSUnattend)
        delete [] pszBOSUnattend;
    if (pszBOSSetup)
        delete [] pszBOSSetup;
    if (pszNewCmd)
        delete [] pszNewCmd;
    return hr;
}

HRESULT CheckBOSSwitch( TCHAR* pszCmdLine )
{
    HRESULT hr = S_OK;
    CComBSTR bstrEXE;
    CComBSTR bstrRun;

    TCHAR* pszBOSUnattend = NULL;
    TCHAR* pszBOSSetup = NULL;

    // remove the old .lnk file
    TCHAR szLinkPath[MAX_PATH + 64];
    if ( SHGetSpecialFolderPath(NULL, szLinkPath, CSIDL_COMMON_STARTUP, FALSE) )
    {
        TCHAR szTmp[64];
        LoadString( _Module.m_hInst, IDS_BOlnk, szTmp, sizeof(szTmp)/sizeof(TCHAR) );
        _tcscat( szLinkPath, szTmp );
        DeleteFile( szLinkPath );
    }

    // look for the switches
    pszBOSUnattend = new TCHAR[_tcslen(pszCmdLine) + 1];
    if (!pszCmdLine)
    {
        hr = E_OUTOFMEMORY;
        goto CLEAN_UP;
    }
    GetParameter( pszCmdLine, _T("/bosunattend"), pszBOSUnattend );

    pszBOSSetup = new TCHAR[_tcslen(pszCmdLine) + 1];
    if (!pszBOSSetup)
    {
        hr = E_OUTOFMEMORY;
        goto CLEAN_UP;
    }
    GetParameter( pszCmdLine, _T("/bossetup"), pszBOSSetup );

    if( !_tcslen(pszBOSSetup) || !_tcslen(pszBOSUnattend) )
    {
        hr = E_FAIL;
        goto CLEAN_UP;
    }

    USES_CONVERSION;
    // build the path via the bossetup, the unattend switch, then the unattend file
    bstrEXE = _T("\""); // Ensure path is in quotes
    bstrEXE += T2OLE(pszBOSSetup);
    bstrEXE += _T("\"");
    bstrRun = _T("/unattendfile ");
    bstrRun += T2OLE(pszBOSUnattend);

    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwRet;
    memset( &si, 0, sizeof(STARTUPINFO) );
    si.cb = sizeof( STARTUPINFO );

    if( CreateProcess( (TCHAR*)OLE2T(bstrEXE), (TCHAR*)OLE2T(bstrRun), NULL, NULL, FALSE, NULL, NULL, NULL, &si, &pi) )
    {
        do
        {
            dwRet = MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, 100, QS_ALLINPUT);
            if (dwRet == WAIT_OBJECT_0 + 1)
            {
                MSG msg;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
        while (dwRet != WAIT_OBJECT_0 && dwRet != WAIT_FAILED);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
CLEAN_UP:
    if (pszBOSUnattend)
        delete [] pszBOSUnattend;
    if (pszBOSSetup)
        delete [] pszBOSSetup;
    return hr;
}

VOID GetParameter( TCHAR* pszCmdLine, TCHAR* pszFindSwitch, TCHAR* pszOut )
{
    HRESULT hr = S_OK;
    
    if ( pszOut ) 
        _tcscpy( pszOut, _T("") );

    if (!pszCmdLine || !pszFindSwitch || !pszOut)
        return;

    TCHAR* psz = new TCHAR[_tcslen(pszCmdLine) + 1];
    if (!psz)
    {
        hr = E_OUTOFMEMORY;
        goto CLEAN_UP;
    }
    _tcscpy( psz, pszCmdLine );
    _tcslwr( psz );

    // look for the switch
    TCHAR* pszSwitch = NULL;
    if( !(pszSwitch = _tcsstr(psz, pszFindSwitch)) )
    {
        goto CLEAN_UP;
    }

    // find the space
    for( ; *pszSwitch && !_istspace(*pszSwitch); ++pszSwitch );
    if( !(*pszSwitch) || !(*(++pszSwitch)) )
    {
        goto CLEAN_UP;
    }

    // if we have a ", we'll look for the next ", else look for a space
    bool bQuote = false;
    TCHAR* pszStart = pszSwitch;
    if( *pszSwitch == _T('"') )
    {
        bQuote = true;
        ++pszSwitch;
    }

    // inc the pointer until we get either a " or a space
    for( ; *pszSwitch && (bQuote ? (*pszSwitch != _T('"')) : (!_istspace(*pszSwitch))); ++pszSwitch );

    // if we're at the end and were looking for a quote, fail.
    if( !(*pszSwitch) && bQuote )
    {
        goto CLEAN_UP;
    }
    // if we have a ", inc past it
    else if( bQuote )
    {
        ++pszSwitch;
    }
    *pszSwitch = 0;
    _tcscpy( pszOut, pszStart );

CLEAN_UP:
    if (psz)
        delete [] psz;
    return;

}

HRESULT CheckSuppressCYS( TCHAR* pszCmdLine )
{
    HRESULT hr = S_OK;

    if (!pszCmdLine)
        return E_INVALIDARG;

    TCHAR* psz = new TCHAR[_tcslen(pszCmdLine) + 1];
    if (!psz)
        return E_OUTOFMEMORY;

    _tcscpy( psz, pszCmdLine );
    _tcslwr( psz );

    if( _tcsstr(psz, "/suppresscys") )
    {
        SuppressCfgSrvPage();
    }
    else
    {
        hr = E_FAIL;
    }

    if (psz)
        delete [] psz;
    return hr;
}

// ----------------------------------------------------------------------------
// DisableBalloons()
//
// This function uses the following regkey to disable all balloon messages:
// HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced
//  EnableBalloonTips = 0x0 or 0x1
//
// If bDisable = TRUE, then we disable the balloons (0x0)
// if bDisable = FALSE, then we enable the balloons (0x1)
// ----------------------------------------------------------------------------
VOID DisableBalloons( BOOL bDisable )
{
    HKEY    hk = NULL;
    DWORD   dwVal = bDisable ? 0x0 : 0x1;

    RegCreateKeyEx( HKEY_CURRENT_USER, _T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"), NULL, NULL, NULL, KEY_ALL_ACCESS, NULL, &hk, NULL);
    if ( hk )
    {
        if ( RegSetValueEx(hk, _T("EnableBalloonTips"), NULL, REG_DWORD, (BYTE*)&dwVal, sizeof(dwVal)) != ERROR_SUCCESS )
        {
//            ASSERT(FALSE);
        }

        RegCloseKey(hk);
    }
}

VOID GetSystemDrive(TCHAR** ppszDrive)
{
    if (!ppszDrive)
        return;
    *ppszDrive = NULL;

    TCHAR szWindows[MAX_PATH + 1] = {0};
    if (0 != GetWindowsDirectory(szWindows, sizeof(szWindows) / sizeof(TCHAR)))
    {
        *ppszDrive = new TCHAR[MAX_PATH];
        _tsplitpath(szWindows, *ppszDrive, NULL, NULL, NULL);
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\bosprep\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H


#if _MSC_VER > 1000
#pragma once
#endif  // _MSC_VER > 1000


#define _ATL_APARTMENT_THREADED

#include "windows.h"
#include "resource.h"
#include <atlbase.h>

extern CComModule _Module;

#include <atlwin.h>

#endif  // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\common\pch.h ===
#include "baseinc.h"
#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\cab.h ===
#include "loader.h"

ERRORCODE
Unpack( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\common\sources.inc ===
!include ..\..\app.mk

MINORCOMP=appcommon

TARGETPATH=$(COBRA_ROOT)\lib\$(_OBJ_DIR)

SOURCES=\
    ..\common.c         \

PRECOMPILED_INCLUDE=..\pch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\inc\common.h ===
#define S_USER_SECTION              TEXT("User")
#define S_USER_INFKEY               TEXT("User")
#define S_DOMAIN_INFKEY             TEXT("Domain")

VOID
InitAppCommon (
    VOID
    );

VOID
TerminateAppCommon (
    VOID
    );

HINF
InitRequiredInfs (
    IN      PCTSTR AppPath,
    IN      PCSTR FailMessageId
    );

VOID
PrintMsgOnConsole (
    IN      UINT MsgId
    );

VOID
UploadEnvVars (
    IN      MIG_PLATFORMTYPEID Platform
    );

VOID
SetLogVerbosity (
    IN      INT VerboseLevel
    );

BOOL
GetFilePath (
    IN      PCTSTR UserSpecifiedFile,
    OUT     PTSTR Buffer,
    IN      UINT BufferTchars
    );

VOID
WriteAppStatus (
    IN      PCTSTR AppJournal,
    IN      DWORD Status
    );

DWORD
ReadAppStatus (
    IN      PCTSTR AppJournal
    );

VOID
SelectComponentsViaInf (
    IN      HINF Inf
    );


typedef struct {
    GROWBUFFER BadInfs;
    GROWBUFFER MultiInfs;
    GROWBUFFER InputInf;
    PCTSTR LogFile;
    INT VerboseLevel;
    BOOL SystemOn;
    BOOL UserOn;
    BOOL FilesOn;
    BOOL TestMode;
    BOOL OverwriteImage;
    BOOL DelayedOpsOn;
    BOOL NoScanStateInfs;

    union {
        BOOL ContinueOnError;
        BOOL CurrentUser;
    };

    PCTSTR StoragePath;
    BOOL FullTransport;
    PCTSTR TransportName;
    BOOL TransportNameSpecified;

    DWORD Capabilities;
    PCTSTR NewDomainName;
    PCTSTR NewUserName;

    BOOL HackHiveOn;
    PCTSTR HackProcessId;
    PCTSTR HackMappedHive;

#ifdef PRERELEASE
    BOOL Recovery;
    TCHAR Tag[64];
#endif

} TOOLARGS, *PTOOLARGS;

typedef enum {
    PARSE_SUCCESS,
    PARSE_MULTI_LOG,
    PARSE_BAD_LOG,
    PARSE_MULTI_VERBOSE,
    PARSE_MISSING_STORAGE_PATH,
    PARSE_OTHER_ERROR
} PARSERESULT;

PARSERESULT
ParseToolCmdLine (
    IN      BOOL ScanState,
    IN OUT  PTOOLARGS Args,
    IN      INT Argc,
    IN      PCTSTR Argv[]
    );

VOID
CallSetThreadUILanguage (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\common\common.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Implements code common to two or more apps.

Author:

    Jim Schmidt (jimschm) 17-Oct-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "common.h"

//
// Strings
//

// none

//
// Constants
//

#define LOG_VERBOSE_BIT  0x01
#define LOG_UNUSED_BIT   0x02   // for v1 compatibility, do not use
#define LOG_STATUS_BIT   0x04
#define LOG_DEBUGGER_BIT 0x08
#define LOG_UPDATE_BIT   0x10

//
// Macros
//

// none

//
// Types
//

// none

//
// Globals
//

// none

//
// Macro expansion list
//

#define REQUIRED_INFS       \
        DEFMAC(OSFILES,     TEXT("USMTDef.inf"))  \

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// this is the structure used for handling required infs

typedef struct {
    PCTSTR InfId;
    PCTSTR InfName;
} REQUIREDINF_STRUCT, *PREQUIREDINF_STRUCT;

// declare a global array of required infs

#define DEFMAC(infid,infname) {TEXT(#infid),infname},
static REQUIREDINF_STRUCT g_RequiredInfs[] = {
                              REQUIRED_INFS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//

VOID
InitAppCommon (
    VOID
    )
{
    InfGlobalInit (FALSE);
    RegInitialize();
}


VOID
TerminateAppCommon (
    VOID
    )
{
    RegTerminate();
    InfGlobalInit (FALSE);
}


HINF
InitRequiredInfs (
    IN      PCTSTR AppPath,
    IN      PCSTR FailMsgId
    )
{
    PCTSTR fullPath;
    HINF result = INVALID_HANDLE_VALUE;
    PREQUIREDINF_STRUCT p = g_RequiredInfs;

    while (p->InfId) {
        fullPath = JoinPaths (AppPath, p->InfName);
        if (DoesFileExist (fullPath)) {
            if (result == INVALID_HANDLE_VALUE) {
                result = SetupOpenInfFile (fullPath, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
                if (result == INVALID_HANDLE_VALUE) {
                    LOG ((LOG_ERROR, FailMsgId, p->InfId, fullPath));
                }
            } else {
                if (!SetupOpenAppendInfFile (fullPath, result, NULL)) {
                    LOG ((LOG_ERROR, FailMsgId, p->InfId, fullPath));
                }
            }
        } else {
            LOG ((LOG_ERROR, FailMsgId, p->InfId, fullPath));
        }
        FreePathString (fullPath);
        p++;
    }
    return result;
}


VOID
PrintMsgOnConsole (
    IN      UINT MsgId
    )
{
    PCTSTR msg;
#ifdef UNICODE
    PCSTR ansimsg;
#endif
    msg = GetStringResource (MsgId);

    if (msg) {

#ifdef UNICODE
        ansimsg = ConvertWtoA (msg);
        printf ("%s", ansimsg);
        FreeConvertedStr (ansimsg);
#else
        printf ("%s", msg);
#endif

        FreeStringResource (msg);
    }
}


VOID
UploadEnvVars (
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    PCTSTR envVars = NULL;
    MULTISZ_ENUM e;
    PTSTR envString;
    PTSTR p;

    //
    // we are going to write here all defined environment variables
    //

    envVars = (PCTSTR) GetEnvironmentStrings();

    if (envVars) {
        if (EnumFirstMultiSz (&e, envVars)) {
            do {
                envString = DuplicatePathString (e.CurrentString, 0);

                p = _tcschr (envString, TEXT('='));

                //
                // Get rid of empty environment strings or the dummy env string starting
                // with '='
                //
                if (!p || p == envString) {
                    FreePathString (envString);
                    continue;
                }

                *p = 0;
                p = _tcsinc (p);

                if (p) {
                    IsmSetEnvironmentString (Platform, S_SYSENVVAR_GROUP, envString, p);
                }

                FreePathString (envString);

            } while (EnumNextMultiSz (&e));
        }
    }
}

VOID
SetLogVerbosity (
    IN      INT VerboseLevel
    )
{
    LOG_LEVEL logBitmap = 0;

    if (VerboseLevel < 0) {
        VerboseLevel = 0;
    }

    // Always ON
    logBitmap = LL_FATAL_ERROR | LL_MODULE_ERROR | LL_ERROR;

    // ON for VERBOSE_BIT
    if (VerboseLevel & LOG_VERBOSE_BIT) {
        logBitmap |= LL_WARNING | LL_INFORMATION;
    }

    // ON for STATUS_BIT
    if (VerboseLevel & LOG_STATUS_BIT) {
        logBitmap |= LL_STATUS;
    }

    // ON for UPDATE_BIT
    if (VerboseLevel & LOG_UPDATE_BIT) {
        logBitmap |= LL_UPDATE;
    }

#ifdef PRERELEASE
    LogSetVerboseBitmap (
        logBitmap,
        LL_FATAL_ERROR|LL_MODULE_ERROR|LL_ERROR|LL_WARNING|LL_INFORMATION|LL_STATUS|LL_UPDATE,
        VerboseLevel & LOG_DEBUGGER_BIT
        );
#else
    LogSetVerboseBitmap (
        logBitmap,
        LL_FATAL_ERROR|LL_MODULE_ERROR|LL_ERROR|LL_WARNING|LL_INFORMATION,
        VerboseLevel & LOG_DEBUGGER_BIT
        );
#endif
}


BOOL
GetFilePath (
    IN      PCTSTR UserSpecifiedFile,
    OUT     PTSTR Buffer,
    IN      UINT BufferTchars
    )
{
    PTSTR tempBuffer = NULL;
    TCHAR infDir[MAX_MBCHAR_PATH];
    TCHAR modulePath[MAX_MBCHAR_PATH];
    TCHAR currentDir[MAX_MBCHAR_PATH];
    PTSTR p;
    PCTSTR userFile = NULL;
    PTSTR dontCare;

    __try {
        //
        // Locate the file using the full path specified by the user, or
        // if only a file spec was given, use the following priorities:
        //
        // 1. Current directory
        // 2. Directory where the tool is
        // 3. INF directory
        //
        // In all cases, return the full path to the file.
        //

        if (Buffer) {
            *Buffer = 0;
        } else {
            __leave;
        }

        tempBuffer = AllocText (BufferTchars);
        *tempBuffer = 0;

        if (!_tcsrchr (UserSpecifiedFile, TEXT('\\'))) {
            //
            // Compute INF directory, module directory and current directory
            //

            if (!GetWindowsDirectory (infDir, ARRAYSIZE(infDir) - 5)) {
                MYASSERT (FALSE);
                __leave;
            }

            StringCat (infDir, TEXT("\\inf"));

            if (!GetModuleFileName (NULL, modulePath, ARRAYSIZE(modulePath))) {
                MYASSERT (FALSE);
                __leave;
            }

            p = _tcsrchr (modulePath, TEXT('\\'));
            if (p) {
                *p = 0;
            } else {
                MYASSERT (FALSE);
                __leave;
            }

            if (!GetCurrentDirectory (ARRAYSIZE(currentDir), currentDir)) {
                MYASSERT (FALSE);
                __leave;
            }

            //
            // Let's see if it's in the current dir
            //

            userFile = JoinPaths (currentDir, UserSpecifiedFile);

            if (DoesFileExist (userFile)) {
                GetFullPathName (
                    userFile,
                    BufferTchars,
                    tempBuffer,
                    &dontCare
                    );
            } else {

                //
                // Let's try the module dir
                //

                FreePathString (userFile);
                userFile = JoinPaths (modulePath, UserSpecifiedFile);

                if (DoesFileExist (userFile)) {
                    GetFullPathName (
                        userFile,
                        BufferTchars,
                        tempBuffer,
                        &dontCare
                        );
                } else {
                    //
                    // Let's try the INF dir
                    //

                    FreePathString (userFile);
                    userFile = JoinPaths (infDir, UserSpecifiedFile);

                    if (DoesFileExist (userFile)) {
                        GetFullPathName (
                            userFile,
                            BufferTchars,
                            tempBuffer,
                            &dontCare
                            );
                    }
                }
            }

        } else {
            //
            // Use the full path that the user specified
            //

            GetFullPathName (
                UserSpecifiedFile,
                BufferTchars,
                tempBuffer,
                &dontCare
                );

            if (*tempBuffer && !DoesFileExist (tempBuffer)) {
                *tempBuffer = 0;
            }
        }

        //
        // Transfer output into caller's buffer.  Note the TCHAR conversion.
        //

        StringCopy (Buffer, tempBuffer);
    }
    __finally {
        if (userFile) {
            FreePathString (userFile);
        }

        if (tempBuffer) {
            FreeText (tempBuffer);
        }
    }

    return (Buffer && (*Buffer != 0));
}

VOID
WriteAppStatus (
    IN      PCTSTR AppJournal,
    IN      DWORD Status
    )
{
    HANDLE appJrnHandle;

    if (AppJournal && AppJournal [0]) {
        appJrnHandle = BfOpenFile (AppJournal);
        if (!appJrnHandle) {
            appJrnHandle = BfCreateFile (AppJournal);
        }
        if (appJrnHandle) {
            if (BfSetFilePointer (appJrnHandle, 0)) {
                BfWriteFile (appJrnHandle, (PBYTE)(&Status), sizeof (DWORD));
            }
            FlushFileBuffers (appJrnHandle);
            CloseHandle (appJrnHandle);
        }
    }
}

DWORD
ReadAppStatus (
    IN      PCTSTR AppJournal
    )
{
    HANDLE appJrnHandle;
    DWORD result = 0;

    if (AppJournal && AppJournal [0]) {
        appJrnHandle = BfOpenReadFile (AppJournal);
        if (appJrnHandle) {
            if (BfSetFilePointer (appJrnHandle, 0)) {
                if (!BfReadFile (appJrnHandle, (PBYTE)(&result), sizeof (DWORD))) {
                    result = 0;
                }
            }
            CloseHandle (appJrnHandle);
        }
    }
    return result;
}


VOID
SelectComponentsViaInf (
    IN      HINF Inf
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR data;

    //
    // Enable or disable components based on the unlocalized tag name,
    // or by the localized string
    //

    if (InfFindFirstLine (Inf, TEXT("Disabled Components"), NULL, &is)) {
        do {
            data = InfGetStringField (&is, 1);

            if (data) {
                if (!IsmSelectComponent (data, 0, FALSE)) {
                    IsmSelectComponent (data, COMPONENT_NAME, FALSE);
                }
            }

        } while (InfFindNextLine (&is));
    }

    if (InfFindFirstLine (Inf, TEXT("Enabled Components"), NULL, &is)) {
        do {
            data = InfGetStringField (&is, 1);

            if (data) {
                if (!IsmSelectComponent (data, 0, TRUE)) {
                    IsmSelectComponent (data, COMPONENT_NAME, TRUE);
                }
            }

        } while (InfFindNextLine (&is));
    }
}


PARSERESULT
ParseToolCmdLine (
    IN      BOOL ScanState,
    OUT     PTOOLARGS Args,
    IN      INT Argc,
    IN      PCTSTR Argv[]
    )
{
    INT i;
    PCTSTR infFileFromCmdLine;
    TCHAR fullInfPath[MAX_TCHAR_PATH];
    MULTISZ_ENUM e;
    HANDLE h;
    BOOL logCreated = FALSE;
    BOOL everythingOn = TRUE;
    BOOL xSwitch = FALSE;
#ifdef PRERELEASE
    DWORD tagSize;
#endif

    ZeroMemory (Args, sizeof (TOOLARGS));
    Args->VerboseLevel = -1;
    Args->TransportName = S_RELIABLE_STORAGE_TRANSPORT;

#ifdef PRERELEASE
    tagSize = ARRAYSIZE(Args->Tag);
    GetUserName (Args->Tag, &tagSize);
#endif

    for (i = 1 ; i < Argc ; i++) {
        if (Argv[i][0] == TEXT('-') || Argv[i][0] == '/') {
            switch ((CHARTYPE) _totlower ((CHARTYPE) _tcsnextc (&Argv[i][1]))) {

            case TEXT('i'):

                if (Argv[i][2] == TEXT('x') && !Argv[i][3]) {
                    if (ScanState) {
                        return PARSE_OTHER_ERROR;
                    }

                    if (Args->NoScanStateInfs) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->NoScanStateInfs = TRUE;
                    break;
                }

                if (Argv[i][2] == TEXT(':')) {
                    infFileFromCmdLine = &Argv[i][3];
                } else if (i + 1 < Argc) {
                    i++;
                    infFileFromCmdLine = Argv[i];
                } else {
                    return PARSE_OTHER_ERROR;
                }

                if (!GetFilePath (infFileFromCmdLine, fullInfPath, ARRAYSIZE(fullInfPath))) {
                    GbMultiSzAppend (&Args->BadInfs, infFileFromCmdLine);
                    break;
                }

                //
                // Make sure fullInfPath was not already specified
                //

                if (Args->InputInf.End) {
                    if (EnumFirstMultiSz (&e, (PCTSTR) Args->InputInf.Buf)) {
                        do {
                            if (StringIMatch (e.CurrentString, fullInfPath)) {
                                GbMultiSzAppend (&Args->MultiInfs, infFileFromCmdLine);
                                *fullInfPath = 0;
                                break;
                            }
                        } while (EnumNextMultiSz (&e));
                    }

                    if (*fullInfPath == 0) {
                        break;
                    }
                }

                //
                // INF file is valid
                //

                GbMultiSzAppend (&Args->InputInf, fullInfPath);
                break;

            case TEXT('l'):

                if (Args->LogFile) {
                    return PARSE_MULTI_LOG;
                }

                if (Argv[i][2] == TEXT(':')) {
                    Args->LogFile = &(Argv[i][3]);
                } else if (i + 1 < Argc) {
                    i++;
                    Args->LogFile = Argv[i];
                } else {
                    return PARSE_OTHER_ERROR;
                }

                h = BfCreateFile (Args->LogFile);
                if (!h) {
                    return PARSE_BAD_LOG;
                }

                CloseHandle (h);
                logCreated = TRUE;

                break;

            case TEXT('v'):

                if (Args->VerboseLevel >= 0) {
                    return PARSE_MULTI_VERBOSE;
                }

                if (Argv[i][2] == TEXT(':')) {
                    _stscanf (&(Argv[i][3]), TEXT("%d"), &Args->VerboseLevel);
                } else if (i + 1 < Argc) {
                    if (_tcsnextc (Argv[i + 1]) >= TEXT('0') &&
                        _tcsnextc (Argv[i + 1]) <= TEXT('9')
                        ) {
                        i++;
                        _stscanf (Argv[i], TEXT("%d"), &Args->VerboseLevel);
                    } else {
                        Args->VerboseLevel = 1;
                    }
                } else {
                    return PARSE_OTHER_ERROR;
                }

#ifndef PRERELEASE
                if (Args->VerboseLevel > 7) {
#else
                Args->VerboseLevel |= LOG_UPDATE_BIT;
                if (Args->VerboseLevel > 0x1F) {
#endif
                    return PARSE_OTHER_ERROR;
                }
                break;

            case TEXT('x'):
                if (xSwitch) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                everythingOn = FALSE;
                xSwitch = TRUE;
                break;

            case TEXT('s'):
                if (Args->SystemOn) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->SystemOn = TRUE;
                everythingOn = FALSE;
                break;

            case TEXT('u'):
                if (Args->UserOn) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->UserOn = TRUE;
                everythingOn = FALSE;
                break;

            case TEXT('f'):
                if (Args->FilesOn) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->FilesOn = TRUE;
                everythingOn = FALSE;
                break;

            case TEXT('q'):
                if (ScanState) {
                    Args->OverwriteImage = TRUE;
                    Args->TestMode = TRUE;
                } else {
                    Args->CurrentUser = TRUE;
                }

                break;

            case TEXT('o'):
                if (!ScanState) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->OverwriteImage) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->OverwriteImage = TRUE;
                break;

            case TEXT('c'):
                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->ContinueOnError) {
                    return PARSE_OTHER_ERROR;
                }

                Args->ContinueOnError = TRUE;

                break;

            case TEXT('d'):
                if (ScanState) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->DelayedOpsOn) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->DelayedOpsOn = TRUE;
                break;

            case TEXT('p'):
                if (!ScanState) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->FullTransport) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->Capabilities & CAPABILITY_SPACEESTIMATE) {
                    return PARSE_OTHER_ERROR;
                }

                Args->Capabilities |= CAPABILITY_SPACEESTIMATE;
                break;

            case TEXT('m'):

                switch ((CHARTYPE) _totlower (Argv[i][2])) {

                case TEXT('d'):

                    if (Argv[i][3] == TEXT(':')) {
                        Args->NewDomainName = &(Argv[i][4]);
                    } else if (i + 1 < Argc) {
                        i++;
                        Args->NewDomainName = Argv[i];
                    } else {
                        return PARSE_OTHER_ERROR;
                    }
                    break;

                case TEXT('u'):

                    if (Argv[i][3] == TEXT(':')) {
                        Args->NewUserName = &(Argv[i][4]);
                    } else if (i + 1 < Argc) {
                        i++;
                        Args->NewUserName = Argv[i];
                    } else {
                        return PARSE_OTHER_ERROR;
                    }
                    break;

                default:
                    return PARSE_OTHER_ERROR;
                }
                break;

            case TEXT('h'):

                Args->HackHiveOn = TRUE;

                switch ((CHARTYPE) _totlower (Argv[i][2])) {

                case TEXT('p'):

                    if (Argv[i][3] == TEXT(':')) {
                        Args->HackProcessId = &(Argv[i][4]);
                    } else if (i + 1 < Argc) {
                        i++;
                        Args->HackProcessId = Argv[i];
                    } else {
                        return PARSE_OTHER_ERROR;
                    }
                    break;

                case TEXT('m'):

                    if (Argv[i][3] == TEXT(':')) {
                        Args->HackMappedHive = &(Argv[i][4]);
                    } else if (i + 1 < Argc) {
                        i++;
                        Args->HackMappedHive = Argv[i];
                    } else {
                        return PARSE_OTHER_ERROR;
                    }
                    break;

                default:
                    return PARSE_OTHER_ERROR;
                }
                break;

#ifdef PRERELEASE
            case TEXT('t'):

                switch ((CHARTYPE) _totlower (Argv[i][2])) {

                case TEXT('f'):

                    if (Argv[i][3]) {
                        return PARSE_OTHER_ERROR;
                    }

                    if (Args->FullTransport) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->FullTransport = TRUE;
                    break;

                case TEXT('c'):
                    if (Argv[i][3]) {
                        return PARSE_OTHER_ERROR;
                    }

                    if (Args->Capabilities & CAPABILITY_COMPRESSED) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->Capabilities |= CAPABILITY_COMPRESSED;
                    break;

                case TEXT('a'):
                    if (Argv[i][3]) {
                        return PARSE_OTHER_ERROR;
                    }

                    if (Args->Capabilities & CAPABILITY_AUTOMATED) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->Capabilities |= CAPABILITY_AUTOMATED;
                    break;

                case TEXT('i'):
                    if (Argv[i][3] != TEXT(':')) {
                        return PARSE_OTHER_ERROR;
                    }

                    StackStringCopy (Args->Tag, &Argv[i][4]);
                    break;

                case 0:
                case TEXT(':'):
                    if (Args->TransportNameSpecified) {
                        return PARSE_OTHER_ERROR;
                    }

                    Args->TransportNameSpecified = TRUE;

                    if (Argv[i][2]) {
                        if (!Argv[i][3]) {
                            return PARSE_OTHER_ERROR;
                        }

                        Args->TransportName = &Argv[i][3];
                    } else {
                        if (i + 1 >= Argc) {
                            return PARSE_OTHER_ERROR;
                        } else {
                            i++;
                            Args->TransportName = Argv[i];
                        }
                    }

                    break;

                default:
                    return PARSE_OTHER_ERROR;
                }

                break;

            case TEXT('r'):
                if (ScanState) {
                    return PARSE_OTHER_ERROR;
                }

                if (Args->Recovery) {
                    return PARSE_OTHER_ERROR;
                }

                if (Argv[i][2]) {
                    return PARSE_OTHER_ERROR;
                }

                Args->Recovery = TRUE;
                break;

#endif

            default:
                return PARSE_OTHER_ERROR;

            }
        } else if (!Args->StoragePath) {
            Args->StoragePath = Argv[i];
        } else {
            return PARSE_OTHER_ERROR;
        }
    }

    if (!Args->StoragePath) {
        if ((!Args->DelayedOpsOn) &&
            (!Args->HackHiveOn)
            ) {
            return PARSE_MISSING_STORAGE_PATH;
        }
    }

    if (everythingOn) {
        Args->SystemOn = TRUE;
        Args->UserOn = TRUE;
        Args->FilesOn = TRUE;
    }

    if (Args->InputInf.Buf) {
        GbMultiSzAppend (&Args->InputInf, TEXT(""));
    }

    return PARSE_SUCCESS;
}


typedef LANGID(WINAPI SETTHREADUILANGUAGE)(WORD wReserved);
typedef SETTHREADUILANGUAGE *PSETTHREADUILANGUAGE;

VOID
CallSetThreadUILanguage (
    VOID
    )
{
    HMODULE kernel32Dll;
    PSETTHREADUILANGUAGE setThreadUiLanguage = NULL;

    kernel32Dll = LoadLibrary (TEXT("KERNEL32.DLL"));
    if (kernel32Dll) {
        setThreadUiLanguage = (PSETTHREADUILANGUAGE) GetProcAddress (kernel32Dll, "SetThreadUILanguage");
        if (setThreadUiLanguage) {
            setThreadUiLanguage (0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\dialog.c ===
#include "pch.h"
#include "loader.h"
#include "resource.h"
#include <winuser.h>
#include <commctrl.h>

#define ANIMATE_OPEN(x) SendDlgItemMessage(Dlg,IDC_ANIMATE1,ACM_OPEN,(WPARAM)NULL,(LPARAM)(LPTSTR)MAKEINTRESOURCE(x))
#define ANIMATE_PLAY()  SendDlgItemMessage(Dlg,IDC_ANIMATE1,ACM_PLAY,(WPARAM)-1,(LPARAM)MAKELONG(0,-1))
#define ANIMATE_STOP()  SendDlgItemMessage(Dlg,IDC_ANIMATE1,ACM_STOP,(WPARAM)0,(LPARAM)0);
#define ANIMATE_CLOSE() SendDlgItemMessage(Dlg,IDC_ANIMATE1,ACM_OPEN,(WPARAM)NULL,(LPARAM)NULL);

VOID
_CenterWindowOnDesktop (
    HWND WndToCenter
    )
{
    RECT  rcFrame, rcWindow;
    LONG  x, y, w, h;
    POINT point;
    HWND Desktop = GetDesktopWindow ();

    point.x = point.y = 0;
    ClientToScreen(Desktop, &point);
    GetWindowRect(WndToCenter, &rcWindow);
    GetClientRect(Desktop, &rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    //
    // Get the work area for the current desktop (i.e., the area that
    // the tray doesn't occupy).
    //
    if(!SystemParametersInfo (SPI_GETWORKAREA, 0, (PVOID)&rcFrame, 0)) {
        //
        // For some reason SPI failed, so use the full screen.
        //
        rcFrame.top = rcFrame.left = 0;
        rcFrame.right = GetSystemMetrics(SM_CXSCREEN);
        rcFrame.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    if(x + w > rcFrame.right) {
        x = rcFrame.right - w;
    } else if(x < rcFrame.left) {
        x = rcFrame.left;
    }
    if(y + h > rcFrame.bottom) {
        y = rcFrame.bottom - h;
    } else if(y < rcFrame.top) {
        y = rcFrame.top;
    }

    MoveWindow(WndToCenter, x, y, w, h, FALSE);
}

VOID
_DialogSetTextByResource( HWND hWnd, HINSTANCE hInst, DWORD dwResID, LPARAM Extra )
{
    PSTR lpszMsgFmtA;
    PWSTR lpszMsgFmtW;
    PSTR lpszNewTextA;
    PWSTR lpszNewTextW;

    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        lpszMsgFmtW = GetResourceStringW( hInst, dwResID );
        if (lpszMsgFmtW)
        {
            FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            lpszMsgFmtW,
                            0,
                            0,
                            (LPWSTR)(&lpszNewTextW),
                            0,
                            (va_list *)&Extra );
            FREE( lpszMsgFmtW );

            if (lpszNewTextW)
            {
                SetDlgItemTextW( hWnd, IDC_TEXT, (PWSTR)lpszNewTextW );
                LocalFree( lpszNewTextW );
            }
        }
    } else {
        // Win9x
        lpszMsgFmtA = GetResourceStringA( hInst, dwResID );
        if (lpszMsgFmtA)
        {
            FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            lpszMsgFmtA,
                            0,
                            0,
                            (LPSTR)(&lpszNewTextA),
                            0,
                            (va_list *)&Extra );
            FREE( lpszMsgFmtA );

            if (lpszNewTextA)
            {
                SetDlgItemTextA( hWnd, IDC_TEXT, (PSTR)lpszNewTextA );
                LocalFree( lpszNewTextA );
            }
        }
    }
}

VOID
_DisplayError( HWND hWnd, HINSTANCE hInst, DWORD ecValue, LPARAM Extra )
{
    ERRORMAPPINGSTRUCT ErrorMap[] = ERROR_MAPPING;
    DWORD dwArraySize;
    DWORD x;
    DWORD dwResId = IDS_MSG_SUCCESS;
    DWORD dwTitleId = IDS_WINDOWTITLE;
    PSTR lpszMsgFmtA;
    PWSTR lpszMsgFmtW;
    PSTR lpszBoxTitleA;
    PWSTR lpszBoxTitleW;
    PSTR lpszNewTextA;
    PWSTR lpszNewTextW;

    dwArraySize = sizeof(ErrorMap) / sizeof(ERRORMAPPINGSTRUCT);
    for (x=0; x<dwArraySize; x++)
    {
        if (ecValue == ErrorMap[x].ecValue)
        {
            dwTitleId = ErrorMap[x].uTitleResID;
            dwResId = ErrorMap[x].uResourceID;
            break;
        }
    }

    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        lpszMsgFmtW = GetResourceStringW( hInst, dwResId );
        if (lpszMsgFmtW)
        {
            FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            lpszMsgFmtW,
                            0,
                            0,
                            (LPWSTR)(&lpszNewTextW),
                            0,
                            (va_list *)&Extra );
            FREE( lpszMsgFmtW );

            if (lpszNewTextW)
            {
                lpszBoxTitleW = GetResourceStringW( hInst, dwTitleId );
                if (lpszBoxTitleW)
                {
                    MessageBoxW( hWnd, lpszNewTextW, lpszBoxTitleW, MB_OK | MB_ICONERROR | MB_TASKMODAL );
                    FREE( lpszBoxTitleW );
                }
                LocalFree( lpszNewTextW );
            }
        }
    } else {
        // Win9x
        lpszMsgFmtA = GetResourceStringA( hInst, dwResId );
        if (lpszMsgFmtA)
        {
            FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            lpszMsgFmtA,
                            0,
                            0,
                            (LPSTR)(&lpszNewTextA),
                            0,
                            (va_list *)&Extra );
            FREE( lpszMsgFmtA );

            if (lpszNewTextA)
            {
                lpszBoxTitleA = GetResourceStringA( hInst, dwTitleId );
                if (lpszBoxTitleA)
                {
                    MessageBoxA( hWnd, lpszNewTextA, lpszBoxTitleA, MB_OK | MB_ICONERROR | MB_TASKMODAL );
                    FREE( lpszBoxTitleA );
                }
                LocalFree( lpszNewTextA );
            }
        }
    }
}

BOOL
CALLBACK
_SetMigwizActive(
    HWND hWnd,
    LPARAM lParam
    )
{
    SetForegroundWindow( hWnd );
    return FALSE;
}

INT_PTR
CALLBACK
DlgProc (
    HWND Dlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    static HWND        hWndParent        = NULL;
    static HINSTANCE hInstParent    = NULL;
    static HCURSOR  Cursor            = NULL;
    static HWND        hWndAnim        = NULL;
    static DWORD    dwCurrentAnim    = 0;
    static DWORD    dwThreadId        = 0;

    switch (Msg)
    {
    case WM_ACTIVATE:
        if (dwThreadId != 0)
        {
            EnumThreadWindows( dwThreadId, _SetMigwizActive, (LPARAM)NULL );
        }
        break;
    case WM_INITDIALOG:
        hWndParent = ((LPTHREADSTARTUPINFO)lParam)->hWnd;
        hInstParent = ((LPTHREADSTARTUPINFO)lParam)->hInstance;

        ANIMATE_OPEN( IDA_STARTUP );
        ANIMATE_PLAY( );
        dwCurrentAnim = IDA_STARTUP;

        Cursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
        ShowCursor (TRUE);
        _CenterWindowOnDesktop( Dlg );

        return TRUE;


    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            SendMessage( hWndParent, WM_USER_DIALOG_COMPLETE, wParam, 0 );
            return TRUE;
            break;
        }
        break;

    case WM_USER_UNPACKING_FILE:
        if (dwCurrentAnim == IDA_STARTUP)
        {
            ANIMATE_STOP();
            ANIMATE_CLOSE();
            ANIMATE_OPEN( IDA_FILECOPY );
            ANIMATE_PLAY();
            dwCurrentAnim = IDA_FILECOPY;
        }
        if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            // WinNT
            _DialogSetTextByResource( Dlg, hInstParent, IDS_MSG_UNPACKING_FILEW, lParam );
        } else {
            // Win9x
            _DialogSetTextByResource( Dlg, hInstParent, IDS_MSG_UNPACKING_FILEA, lParam );
        }
        break;

    case WM_USER_THREAD_ERROR:
        ANIMATE_STOP();
        ANIMATE_CLOSE();

        ShowWindow( Dlg, SW_HIDE );
        _DisplayError( Dlg, hInstParent, (DWORD)wParam, lParam );
        SendMessage( hWndParent, WM_USER_DIALOG_COMPLETE, wParam, 0 );
        break;

    case WM_USER_SUBTHREAD_CREATED:
        ShowWindow( Dlg, SW_HIDE );
        dwThreadId = (DWORD)lParam;
        break;

    case WM_USER_THREAD_COMPLETE:
        ANIMATE_STOP();
        ANIMATE_CLOSE();

        if ((ERRORCODE)lParam == E_OK)
        {
            SendMessage( hWndParent, WM_USER_DIALOG_COMPLETE, 0, 0 );
        }
        dwThreadId = 0;
        break;

    case WM_DESTROY:
        ShowCursor (FALSE);
        if (Cursor) {
            SetCursor (Cursor);
            Cursor = NULL;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\cab.c ===
#include "pch.h"
#include <fdi.h>
#include <crtdbg.h>
#include <fcntl.h>
#include <stdio.h>
#include "loader.h"

// Types
typedef struct _UNPACKEDFILE
{
    PTSTR lpszFileName;
    PVOID nextFile;
} UNPACKEDFILESTRUCT, *LPUNPACKEDFILE;

// Globals
static ERF g_ERF;
static HFDI g_hFDI = NULL;
static LPUNPACKEDFILE g_lpFileList = NULL;

extern HINSTANCE g_hInstParent;
extern HWND g_hWndParent;

// Prototypes
VOID AddFileToList( PTSTR );


PVOID
DIAMONDAPI
CabAlloc (
    IN      ULONG Size
    )
{
    return ALLOC( Size );
}

VOID
DIAMONDAPI
CabFree (
    IN      PVOID Memory
    )
{
    FREE( Memory );
}

INT_PTR
DIAMONDAPI
CabOpen (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    )
{
    HANDLE fileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    _ASSERT (oFlag == _O_BINARY);

    fileHandle = CreateFile (FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_ARCHIVE,
                             NULL
                             );
    if (fileHandle == INVALID_HANDLE_VALUE)
    {
        return -1;
    }
    return (INT_PTR)fileHandle;
}

UINT
DIAMONDAPI
CabRead (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )
{
    BOOL result;
    ULONG bytesRead;

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return bytesRead;
}

UINT
DIAMONDAPI
CabWrite (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )
{
    BOOL result;
    DWORD bytesWritten;

    result = WriteFile ((HANDLE)FileHandle, Buffer, Size, &bytesWritten, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return Size;
}

INT
DIAMONDAPI
CabClose (
    IN      INT_PTR FileHandle
    )
{
    CloseHandle ((HANDLE)FileHandle);
    return 0;
}

LONG
DIAMONDAPI
CabSeek (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType
    )
{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        return -1;
    }
    return ((LONG)(result));
}

INT_PTR
DIAMONDAPI
CabUnpackStatus
(
    IN        FDINOTIFICATIONTYPE fdiType,
    IN        FDINOTIFICATION *pfdiNotification
    )
{
    HANDLE destHandle = NULL;
    PTSTR destFileName = NULL;
    FILETIME localFileTime;
    FILETIME fileTime;
    BOOL fSkip = FALSE;
    PTSTR lpszDestPath = NULL;
    TCHAR destName [MAX_PATH];
    PTSTR destPtr = NULL;

    switch (fdiType)
    {
    case fdintCOPY_FILE:        // File to be copied
        // pfdin->psz1    = file name in cabinet
        // pfdin->cb      = uncompressed size of file
        // pfdin->date    = file date
        // pfdin->time    = file time
        // pfdin->attribs = file attributes
        // pfdin->iFolder = file's folder index

        if (_tcsicmp (pfdiNotification->psz1, TEXT("migwiz.exe.manifest")) == 0)
        {
            // Only copy the manifest if this OS is later than Whistler beta 1

            fSkip = TRUE;
            if (g_VersionInfo.dwMajorVersion >= 5 &&
                (g_VersionInfo.dwMinorVersion > 1 ||
                 (g_VersionInfo.dwMinorVersion == 1 &&
                  g_VersionInfo.dwBuildNumber >= 2424)))
            {
                fSkip = FALSE;
            }
        }

        if (!fSkip)
        {
            // let's look at the system and decide the destination name for the file
            ZeroMemory (destName, sizeof (destName));
            _tcsncpy (destName, pfdiNotification->psz1, MAX_PATH - 1);
            destPtr = _tcsrchr (pfdiNotification->psz1, TEXT('_'));
            if (destPtr) {
                if (_tcsncmp (destPtr, TEXT("_a."), 3) == 0) {
                    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                        // this is an ANSI file, don't copy it on NT
                        fSkip = TRUE;
                    } else {
                        // this is an ANSI file, rename it on Win9x
                        ZeroMemory (destName, sizeof (destName));
                        CopyMemory (destName, pfdiNotification->psz1, (UINT) (destPtr - pfdiNotification->psz1) * sizeof (TCHAR));
                        destPtr += 2;
                        _tcscat (destName, destPtr);
                    }
                }
                if (_tcsncmp (destPtr, TEXT("_u."), 3) == 0) {
                    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
                        // this is an UNICODE file, don't copy it on NT
                        fSkip = TRUE;
                    } else {
                        // this is an UNICODE file, rename it on Win9x
                        ZeroMemory (destName, sizeof (destName));
                        CopyMemory (destName, pfdiNotification->psz1, (UINT) (destPtr - pfdiNotification->psz1) * sizeof (TCHAR));
                        destPtr += 2;
                        _tcscat (destName, destPtr);
                    }
                }
            }

            if (!fSkip) {

                SendMessage( g_hWndParent, WM_USER_UNPACKING_FILE, (WPARAM)NULL, (LPARAM)destName);

                lpszDestPath = GetDestPath();
                // Do not free lpszDestPath, because it is a pointer to a global
                if (lpszDestPath)
                {
                    destFileName = JoinPaths( lpszDestPath, destName);
                }
                if (destFileName)
                {
                    destHandle = CreateFile( destFileName,
                                             GENERIC_WRITE,
                                             0,
                                             NULL,
                                             CREATE_ALWAYS,
                                             FILE_ATTRIBUTE_TEMPORARY,
                                             NULL );
                    AddFileToList( destFileName );
                    FREE( destFileName );
                }
            }
        }
        return (INT_PTR)destHandle;

    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        //            Called after all of the data has been written to a target file.
        //            This function must close the file and set the file date, time,
        //            and attributes.
        //        Entry:
        //            pfdin->psz1    = file name in cabinet
        //            pfdin->hf      = file handle
        //            pfdin->date    = file date
        //            pfdin->time    = file time
        //            pfdin->attribs = file attributes
        //            pfdin->iFolder = file's folder index
        //            pfdin->cb      = Run After Extract (0 - don't run, 1 Run)
        //        Exit-Success:
        //            Returns TRUE
        //        Exit-Failure:
        //            Returns FALSE, or -1 to abort;
        //
        //                IMPORTANT NOTE IMPORTANT:
        //                    pfdin->cb is overloaded to no longer be the size of
        //                    the file but to be a binary indicated run or not
        //
        //                IMPORTANT NOTE:
        //                    FDI assumes that the target file was closed, even if this
        //                    callback returns failure.  FDI will NOT attempt to use
        //                    the PFNCLOSE function supplied on FDICreate() to close
        //                    the file!

        if (DosDateTimeToFileTime (pfdiNotification->date, pfdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)pfdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }
        CloseHandle ((HANDLE)pfdiNotification->hf);
//        attributes = (pfdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE)) | FILE_ATTRIBUTE_TEMPORARY;
//        SetFileAttributes (destFile, attributes);
//        FreePathString (destFile);
        return TRUE;

    case fdintCABINET_INFO:
        // return success
        return 0;

    case fdintENUMERATE:
        // return success
        return 0;

    case fdintPARTIAL_FILE:
        // return failure
        return -1;

    case fdintNEXT_CABINET:
        // return failure
        return -1;

    default:
        break;
    }

    return 0;
}

VOID
AddFileToList( PTSTR lpszFilename )
{
    LPUNPACKEDFILE lpNewFile;

    lpNewFile = (LPUNPACKEDFILE)ALLOC( sizeof(UNPACKEDFILESTRUCT) );
    if (lpNewFile)
    {
        lpNewFile->lpszFileName = (PTSTR)ALLOC( (lstrlen(lpszFilename) + 1) * sizeof(TCHAR) );
        if (lpNewFile->lpszFileName)
        {
            lstrcpy( lpNewFile->lpszFileName, lpszFilename );
            lpNewFile->nextFile = g_lpFileList;

            g_lpFileList = lpNewFile;
        }
    }
}

VOID
CleanupTempFiles( VOID )
{
    LPUNPACKEDFILE lpFile = g_lpFileList;
    PTSTR lpszDestPath;

    while (lpFile)
    {
        g_lpFileList = (LPUNPACKEDFILE)lpFile->nextFile;
        if (lpFile->lpszFileName)
        {
            DeleteFile( lpFile->lpszFileName );
            FREE( lpFile->lpszFileName );
        }
        lpFile = g_lpFileList;
    }

    lpszDestPath = GetDestPath();
    if (lpszDestPath)
    {
        RemoveDirectory( lpszDestPath );
        // Do not free lpszDestPath, because it is a pointer to a global value
    }
}

ERRORCODE
Unpack( VOID )
{
    ERRORCODE ecResult = E_OK;
    PTSTR lpszCabFilename;
    PTSTR lpszDestPath;
    TCHAR szModulePath[MAX_PATH];
    TCHAR szDestFile[MAX_PATH];

    // Create the File Decompression Interface context
    g_hFDI = FDICreate( CabAlloc,
                        CabFree,
                        CabOpen,
                        CabRead,
                        CabWrite,
                        CabClose,
                        CabSeek,
                        cpuUNKNOWN,    // WARNING: Don't use auto-detect from a 16-bit Windows
                                    //            application!  Use GetWinFlags()!
                        &g_ERF );
    if (g_hFDI == NULL)
    {
        ecResult = E_UNPACK_FAILED;
        goto END;
    }

    // Create Dest Directory

    lpszDestPath = GetDestPath();
    // Do not free lpszDestPath, because it is a pointer to a global value

    if (!lpszDestPath)
    {
        ecResult = E_INVALID_PATH;
        goto END;
    }

    lpszCabFilename = GetResourceString( g_hInstParent, IDS_CABFILENAME );
    if (lpszCabFilename == NULL)
    {
        ecResult = E_INVALID_FILENAME;
    }
    else
    {
        // Unpack the CAB
        if (!FDICopy( g_hFDI,
                      lpszCabFilename,    // Only filename
                      GetModulePath(),    // Only path
                      0,
                      CabUnpackStatus,
                      NULL,
                      NULL ))
        {
            switch (g_ERF.erfOper)
            {
            case FDIERROR_CABINET_NOT_FOUND:
                ecResult = E_CAB_NOT_FOUND;
                break;
            case FDIERROR_NOT_A_CABINET:
            case FDIERROR_UNKNOWN_CABINET_VERSION:
            case FDIERROR_CORRUPT_CABINET:
                ecResult = E_CAB_CORRUPT;
                break;
            default:
                ecResult = E_UNPACK_FAILED;
                break;
            }

            goto END;
        }
        FREE( lpszCabFilename );
    }

    // Now copy migload.exe to the dest.  This is needed for creating wizard disks.
    if (GetModuleFileName( NULL, szModulePath, MAX_PATH )) {
        szModulePath [MAX_PATH - 1] = 0;
        _tcscpy( szDestFile, lpszDestPath );
        _tcscat( szDestFile, TEXT("migload.exe"));
        CopyFile( szModulePath, szDestFile, FALSE );
    }

END:
    if (g_hFDI)
    {
        FDIDestroy( g_hFDI );
    }
    return ecResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\dialog.h ===
INT_PTR
CALLBACK
DlgProc (
    HWND Dlg,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\pch.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <windows.h>
#include <tchar.h>
//#include <malloc.h>
#include "resource.h"
#include "dialog.h"
#include "utils.h"
#include "cab.h"
#include "unpack.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\loader.h ===
#ifndef _LOADER_H_
#define _LOADER_H_

// NOTE: Currently REQUIRED_DLLS contains only new DLLs that are required at
//            startup of migwiz. It does not contain DLLs that are required already
//            to start this loader. It does not currently contain DLLs that are
//            automatically dynamically linked when a function is called in them.
// kernel32.dll
// msvcrt.dll
// user32.dll
// comctl32.dll
#define REQUIRED_DLLSA { \
    "advapi32.dll", \
    "comdlg32.dll", \
    "gdi32.dll",    \
    "msvcrt.dll",   \
    "ole32.dll",    \
    "setupapi.dll", \
    "shell32.dll",  \
    "shlwapi.dll",  \
}

#define REQUIRED_DLLSW { \
    L"advapi32.dll", \
    L"comdlg32.dll", \
    L"gdi32.dll",    \
    L"msvcrt.dll",   \
    L"ole32.dll",    \
    L"setupapi.dll", \
    L"shell32.dll",  \
    L"shlwapi.dll",  \
}

// Constants
#define WM_USER_THREAD_COMPLETE     (WM_APP + 1)
#define WM_USER_HIDE_WINDOW         (WM_APP + 2)
#define WM_USER_THREAD_ERROR        (WM_APP + 3)
#define WM_USER_DIALOG_COMPLETE     (WM_APP + 4)
#define WM_USER_UNPACKING_FILE      (WM_APP + 5)
#define WM_USER_SUBTHREAD_CREATED   (WM_APP + 6)

typedef enum _ERRORCODE
{
    E_OK,
    E_INVALID_PATH,
    E_INVALID_FILENAME,
    E_FILE_DOES_NOT_EXIST,
    E_PROCESS_CREATION_FAILED,
    E_THREAD_CREATION_FAILED,
    E_CAB_NOT_FOUND,
    E_CAB_CORRUPT,
    E_UNPACK_FAILED,
    E_DLL_NOT_FOUND,
    E_OLD_OS_VERSION,
    E_WRONG_LANGUAGE
} ERRORCODE;

#define ERROR_MAPPING {                                                                           \
    { E_OK,                         IDS_WINDOWTITLE,    IDS_MSG_SUCCESS                     },    \
    { E_INVALID_PATH,               IDS_WINDOWTITLE,    IDS_MSG_E_INVALID_PATH              },    \
    { E_INVALID_FILENAME,           IDS_WINDOWTITLE,    IDS_MSG_E_INVALID_FILENAME          },    \
    { E_FILE_DOES_NOT_EXIST,        IDS_WINDOWTITLE,    IDS_MSG_E_FILE_DOES_NOT_EXIST       },    \
    { E_PROCESS_CREATION_FAILED,    IDS_WINDOWTITLE,    IDS_MSG_E_PROCESS_CREATION_FAILED   },    \
    { E_THREAD_CREATION_FAILED,     IDS_WINDOWTITLE,    IDS_MSG_E_THREAD_CREATION_FAILED    },    \
    { E_CAB_NOT_FOUND,              IDS_WINDOWTITLE,    IDS_MSG_E_CAB_NOT_FOUND             },    \
    { E_CAB_CORRUPT,                IDS_WINDOWTITLE,    IDS_MSG_E_CAB_CORRUPT               },    \
    { E_UNPACK_FAILED,              IDS_WINDOWTITLE,    IDS_MSG_E_UNPACK_FAILED             },    \
    { E_DLL_NOT_FOUND,              IDS_WINDOWTITLE,    IDS_MSG_E_DLL_NOT_FOUND             },    \
    { E_OLD_OS_VERSION,             IDS_WINDOWTITLE,    IDS_MSG_E_OLD_OS_VERSION            },    \
    { E_WRONG_LANGUAGE,             IDS_WINDOWTITLE_ENG,IDS_MSG_E_WRONG_LANGUAGE            },    \
}

typedef struct _ERRORMAPPINGSTRUCT
{
    UINT ecValue;
    UINT uTitleResID;
    UINT uResourceID;
} ERRORMAPPINGSTRUCT, *LPERRORMAPPINGSTRUCT;

typedef struct _THREADSTARTUPINFO
{
    HWND hWnd;
    HINSTANCE hInstance;
    LPSTR lpCmdLine;
} THREADSTARTUPINFO, *LPTHREADSTARTUPINFO;

// Function prototypes

#define ALLOC(size) HeapAlloc( GetProcessHeap (), 0, size )
#define FREE(p)     HeapFree( GetProcessHeap (), 0, p )

BOOL InitLanguageDetection(VOID);


// Globals

extern OSVERSIONINFO g_VersionInfo;
extern BOOL g_IsLanguageMatched;


#endif /* _LOADER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\unpack.h ===
#include "loader.h"

DWORD
WINAPI
UnpackThread(
    IN      LPVOID lpParameter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDS_WINDOWCLASS                 1
#define IDS_WINDOWTITLE                 2
#define IDS_MSG_STARTING                3
#define IDS_MIGWIZFILENAME              4
#define IDS_CABFILENAME                 5
#define IDS_MSG_SUCCESS                 6
#define IDS_MSG_E_INVALID_PATH          7
#define IDS_MSG_E_INVALID_FILENAME      8
#define IDS_MSG_E_FILE_DOES_NOT_EXIST   9
#define IDS_MSG_E_PROCESS_CREATION_FAILED 10
#define IDS_MSG_E_THREAD_CREATION_FAILED 11
#define IDS_MSG_E_CAB_NOT_FOUND         12
#define IDS_MSG_E_CAB_CORRUPT           13
#define IDS_MSG_E_UNPACK_FAILED         14
#define IDS_MSG_E_DLL_NOT_FOUND         15
#define IDS_MSG_E_OLD_OS_VERSION        16
#define IDS_MSG_UNPACKING_FILEA         17
#define IDS_MSG_UNPACKING_FILEW         18
#define IDS_NEEDIE4                     19
#define IDS_MSG_E_WRONG_LANGUAGE        20
#define IDS_WINDOWTITLE_ENG             21
#define IDD_MIGWIZINIT                  101
#define IDA_FILECOPY                    104
#define IDA_STARTUP                     105
#define IDC_TEXT                        1002
#define IDC_WAIT_ANIM                   1003
#define IDC_WAIT_MARKER                 1004
#define IDC_ANIMATE1                    1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\utils.h ===
#define JoinPaths(x,y) JoinText(x, y, TEXT('\\'))

PTSTR
GetResourceString( HINSTANCE hInstance, DWORD dwResID );

VOID CleanupTempFiles( VOID );

VOID UtilFree( VOID );

PTSTR
GetDestPath( VOID );

PTSTR
GetModulePath( VOID );

PTSTR
JoinText( PTSTR lpStr1, PTSTR lpStr2, TCHAR chSeparator );

PTSTR
GetResourceString( HINSTANCE hInstance, DWORD dwResID );

PSTR
GetResourceStringA( HINSTANCE hInstance, DWORD dwResID );

PWSTR
GetResourceStringW( HINSTANCE hInstance, DWORD dwResID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loadstate\pch.h ===
#include "baseinc.h"
#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\lang.c ===
#include "pch.h"
#include "loader.h"
#include <stdlib.h>
#pragma hdrstop


#define ISNT()      (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISOSR2()    (LOWORD(g_VersionInfo.dwBuildNumber) > 1080)
#define BUILDNUM()  (g_VersionInfo.dwBuildNumber)

//
// Global variables defined here
//

//
// TargetNativeLangID : this is native language ID of running system
//
LANGID TargetNativeLangID;

//
// SourceNativeLangID : this is native language ID of new NT you want to install
//
LANGID SourceNativeLangID;

//
// g_IsLanguageMatched : if source and target language are matched (or compatible)
//
//                       1. if SourceNativeLangID == TargetNativeLangID
//
//                       2. if SourceNativeLangID's alternative ID == TargetNativeLangID
//
BOOL g_IsLanguageMatched;

typedef struct _tagAltSourceLocale {
    LANGID LangId;
    LANGID AltLangId;
    DWORD MajorOs;
    DWORD MinorOs;
    DWORD ExcludedOs;
} ALTSOURCELOCALE, *PALTSOURCELOCALE;

ALTSOURCELOCALE g_AltSourceLocale [] = {{0x00000C04, 0x00000409, 0x0200,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x0000040D, 0x00000409, 0x0200,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000401, 0x00000409, 0x0200,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x0000041E, 0x00000409, 0x0200,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000809, 0x00000409, 0x00FF,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x0000080A, 0x00000C0A, 0x00FF,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x0000040A, 0x00000C0A, 0x0300,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000425, 0x00000409, 0x00FF,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000801, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00000c01, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00001001, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00001401, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00001801, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00001c01, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00002001, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00002401, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00002801, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00002c01, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00003001, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00003401, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00003801, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00003c01, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0x00004001, 0x00000401, 0x0001,     0xFFFFFFFF, 0xFFFFFFFF},
                                        {0,          0,          0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}};

typedef struct _tagTrustedSourceLocale {
    LANGID LangId;
    DWORD MajorOs;
    DWORD MinorOs;
    DWORD ExcludedOs;
} TRUSTEDSOURCELOCALE, *PTRUSTEDSOURCELOCALE;

TRUSTEDSOURCELOCALE g_TrustedSourceLocale [] = {{0,          0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF}};

typedef struct _tagOSVERSIONMAJORID {
    PCTSTR Name;
    DWORD MajorId;
    DWORD Platform;
    DWORD Major;
    DWORD Minor;
} OSVERSIONMAJORID, *POSVERSIONMAJORID;

OSVERSIONMAJORID g_OsVersionMajorId [] = {{TEXT("Win95"),       0x0001, 1, 4, 0},
                                          {TEXT("Win98"),       0x0002, 1, 4, 10},
                                          {TEXT("WinME"),       0x0004, 1, 4, 90},
                                          {TEXT("WinNT351"),    0x0100, 2, 3, 51},
                                          {TEXT("WinNT40"),     0x0200, 2, 4, 0},
                                          {NULL,                0,      0, 0, 0}};

typedef struct _tagOSVERSIONMINORID {
    PCTSTR Name;
    DWORD MajorId;
    DWORD MinorId;
    DWORD Platform;
    DWORD Major;
    DWORD Minor;
    DWORD Build;
    PCTSTR CSDVer;
} OSVERSIONMINORID, *POSVERSIONMINORID;

OSVERSIONMINORID g_OsVersionMinorId [] = {{NULL, 0, 0, 0, 0, 0, 0, NULL}};

typedef struct _tagLANGINFO {
    LANGID LangID;
    INT    Count;
} LANGINFO,*PLANGINFO;

BOOL
TrustedDefaultUserLocale (
    LANGID LangID
    );

BOOL
CALLBACK
EnumLangProc(
    HANDLE hModule,     // resource-module handle
    LPCTSTR lpszType,   // pointer to resource type
    LPCTSTR lpszName,   // pointer to resource name
    WORD wIDLanguage,   // resource language identifier
    LONG_PTR lParam     // application-defined parameter
    )
/*++

Routine Description:

    Callback that counts versions stamps.

Arguments:

    Details of version enumerated version stamp. (Ignore.)

Return Value:

    Indirectly thru lParam: count, langID

--*/
{
    PLANGINFO LangInfo;

    LangInfo = (PLANGINFO) lParam;

    LangInfo->Count++;

    //
    // for localized build contains multiple resource,
    // it usually contains 0409 as backup lang.
    //
    // if LangInfo->LangID != 0 means we already assigned an ID to it
    //
    // so when wIDLanguage == 0x409, we keep the one we got from last time
    //
    if ((wIDLanguage == 0x409) && (LangInfo->LangID != 0)) {
        return TRUE;
    }

    LangInfo->LangID  = wIDLanguage;

    return TRUE;        // continue enumeration
}

LANGID
GetNTDLLNativeLangID (
    VOID
    )
/*++

Routine Description:

    This function is designed specifically for getting native lang of ntdll.dll

    This is not a generic function to get other module's language

    the assumption is:

    1. if only one language in resource then return this lang

    2. if two languages in resource then return non-US language

    3. if more than two languages, it's invalid in our case, but returns the last one.

Arguments:

    None

Return Value:

    Native lang ID in ntdll.dll

--*/
{
    LPCTSTR Type = (LPCTSTR) RT_VERSION;
    LPCTSTR Name = (LPCTSTR) 1;

    LANGINFO LangInfo;

    ZeroMemory(&LangInfo,sizeof(LangInfo));

    EnumResourceLanguages (
            GetModuleHandle(TEXT("ntdll.dll")),
            Type,
            Name,
            EnumLangProc,
            (LONG_PTR) &LangInfo
            );

    if ((LangInfo.Count > 2) || (LangInfo.Count < 1) ) {
        //
        // put error log here
        //
        // so far, for NT 3.51, only JPN has two language resources
    }

    return LangInfo.LangID;
}

BOOL
IsHongKongVersion (
    VOID
    )
/*++

Routine Description:

    Try to identify HongKong NT 4.0

    It based on:

    NTDLL's language is English and build is 1381 and
    pImmReleaseContext return TRUE

Arguments:


Return Value:

   Language ID of running system

--*/
{
    HMODULE hMod;
    BOOL bRet=FALSE;
    typedef BOOL (*IMMRELEASECONTEXT) (HWND,HANDLE);
    IMMRELEASECONTEXT pImmReleaseContext;

    LANGID TmpID = GetNTDLLNativeLangID();

    if ((g_VersionInfo.dwBuildNumber == 1381) &&
        (TmpID == 0x0409)){

        hMod = LoadLibrary(TEXT("imm32.dll"));

        if (hMod) {

            pImmReleaseContext = (IMMRELEASECONTEXT) GetProcAddress(hMod,"ImmReleaseContext");

            if (pImmReleaseContext) {
                bRet = pImmReleaseContext(NULL,NULL);
            }

            FreeLibrary(hMod);
        }
    }
    return (bRet);
}

LANGID
GetDefaultUserLangID (
    VOID
    )
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          langid = 0;

    dwErr = RegOpenKeyEx( HKEY_USERS,
                          TEXT(".DEFAULT\\Control Panel\\International"),
                          0,
                          KEY_READ,
                          &hkey );

    if( dwErr == ERROR_SUCCESS ) {

        dwSize = sizeof(buffer);
        dwErr = RegQueryValueExA(hkey,
                                 "Locale",
                                 NULL,  //reserved
                                 NULL,  //type
                                 buffer,
                                 &dwSize );

        if(dwErr == ERROR_SUCCESS) {
            langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));

        }
        RegCloseKey(hkey);
    }
    return langid;
}

LANGID
GetTargetNativeLangID (
    VOID
    )
/*++

Routine Description:

    Applies different rules to different platforms

    NT
        build number <= 1840           : check ntdll's language,
                                         we scaned all 3.51's ntdll on boneyard\intl,
                                         it looks like we can trust them.
        build number > 1840            : user MUI language

    Win9x
        use default user's resource language

Arguments:


Return Value:

   Language ID of running system

--*/
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          rcLang;
    LANGID          langid = 0;


    // Find out if we are running on NT or WIN9X

    if( ISNT() ) {

        //
        // We're on NT, but which version?  GetSystemDefaultUILanguage() was broke until 1840...
        //
        if( g_VersionInfo.dwBuildNumber > 1840 ) {
        FARPROC     NT5API;

            //
            // Use the API to find out our locale.
            //

            if( NT5API = GetProcAddress( GetModuleHandle(TEXT("kernel32.dll")), "GetSystemDefaultUILanguage") ) {

                rcLang = (LANGID)NT5API();
                //
                // need to convert decimal to hex, LANGID to chr.
                //
                langid = rcLang;
            }
        } else {

                //
                // by looking into \\boneyard\intl, almost every ntdll.dll marked correct lang ID
                // so get langID from ntdll.dll
                //

                langid = GetNTDLLNativeLangID();

                if (langid == 0x0409) {

                    if (IsHongKongVersion()) {

                        langid = 0x0C04;

                    } else {
                        //
                        // if default user's locale is in [TrustedDefaultUserLocale]
                        //
                        // then this is a backdoor for some localized build that its ntdll.dll marked
                        //
                        // as English but can't be upgrade by US version.
                        //
                        LANGID DefaultUserLangID = GetDefaultUserLangID();

                        if (DefaultUserLangID  &&
                            TrustedDefaultUserLocale (DefaultUserLangID)) {

                            langid = DefaultUserLangID;
                        }
                    }
                }

        }
    } else {

        //
        // We're on Win9x.
        //
        dwErr = RegOpenKeyEx( HKEY_USERS,
                              TEXT(".Default\\Control Panel\\desktop\\ResourceLocale"),
                              0,
                              KEY_READ,
                              &hkey );

        if (dwErr == ERROR_SUCCESS) {

            dwSize = sizeof(buffer);
            dwErr = RegQueryValueExA( hkey,
                                     "",
                                     NULL,  //reserved
                                     NULL,  //type
                                     buffer,
                                     &dwSize );

            if(dwErr == ERROR_SUCCESS) {
                langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));
            }
            RegCloseKey(hkey);
        }

        if ( dwErr != ERROR_SUCCESS ) {
           // Check HKLM\System\CurrentControlSet\Control\Nls\Locale

           dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                TEXT("System\\CurrentControlSet\\Control\\Nls\\Locale"),
                                0,
                                KEY_READ,
                                &hkey );

           if (dwErr == ERROR_SUCCESS) {

              dwSize = sizeof(buffer);
              dwErr = RegQueryValueExA( hkey,
                                        "",
                                        NULL,  //reserved
                                        NULL,  //type
                                        buffer,
                                        &dwSize );

              if (dwErr == ERROR_SUCCESS) {
                  langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));
              }
              RegCloseKey(hkey);
           }
        }
    }

    return (langid);
}


LANGID
GetSourceNativeLangID (
    VOID
    )

/*++

Routine Description:

    [DefaultValues]
    Locale = xxxx

    every localized build has it's own Locale in intl.inf,

    so we use this value to identify source languag

Arguments:

Return Value:

   Language ID of source

--*/
{

    // BUGBUG - implement this by reading our own version info.

    LPCTSTR Type = (LPCTSTR) RT_VERSION;
    LPCTSTR Name = (LPCTSTR) 1;

    LANGINFO LangInfo;

    ZeroMemory(&LangInfo,sizeof(LangInfo));

    EnumResourceLanguages (
            NULL,   // our own module
            Type,
            Name,
            EnumLangProc,
            (LONG_PTR) &LangInfo
            );

    if ((LangInfo.Count > 2) || (LangInfo.Count < 1) ) {
        //
        // put error log here
        //
        // so far, for NT 3.51, only JPN has two language resources
    }

    return LangInfo.LangID;
}

DWORD
GetOsMajorId (
    VOID
    )
{
    POSVERSIONMAJORID p = g_OsVersionMajorId;

    while (p->Name) {
        if ((p->Platform == g_VersionInfo.dwPlatformId) &&
            (p->Major == g_VersionInfo.dwMajorVersion) &&
            (p->Minor == g_VersionInfo.dwMinorVersion)
            ) {
            return p->MajorId;
        }
        p++;
    }
    return 0;
}

DWORD
GetOsMinorId (
    VOID
    )
{
    POSVERSIONMINORID p = g_OsVersionMinorId;

    while (p->Name) {
        if ((p->Platform == g_VersionInfo.dwPlatformId) &&
            (p->Major == g_VersionInfo.dwMajorVersion) &&
            (p->Minor == g_VersionInfo.dwMinorVersion) &&
            (p->Build == g_VersionInfo.dwBuildNumber) &&
            ((p->CSDVer == NULL) || _tcsicmp (p->CSDVer, g_VersionInfo.szCSDVersion))
            ) {
            return p->MinorId;
        }
        p++;
    }
    return 0;
}

BOOL
TrustedDefaultUserLocale (
    LANGID LangID
    )
{
    PTRUSTEDSOURCELOCALE p = g_TrustedSourceLocale;

    while (p->LangId) {
        if ((!(p->ExcludedOs & GetOsMinorId ())) &&
            ((p->MinorOs & GetOsMinorId ()) || (p->MajorOs & GetOsMajorId ()))
           ) {
           return TRUE;
        }
        p++;
    }
    return FALSE;
}

BOOL
CheckLanguageVersion (
    LANGID SourceLangID,
    LANGID TargetLangID
    )
/*++

Routine Description:

    Check if the language of source NT is same as target NT or ,at least,

    compatibile

Arguments:

    Inf    handle of intl.inf

Return Value:

   TRUE  They are same or compatibile
   FALSE They are different

--*/
{
    PALTSOURCELOCALE p = g_AltSourceLocale;
    TCHAR TargetLangIDStr[9];

    LANGID SrcLANGID;
    LANGID DstLANGID;
    LANGID AltSourceLangID;

    //
    // If either one is 0, allow the upgrade. This is Windows 2000 Beta3 behavior.
    //
    if (SourceLangID == 0 || TargetLangID == 0) {
        return TRUE;
    }

    if (SourceLangID == TargetLangID) {
        return TRUE;
    }

    //
    // if Src != Dst, then we need to look up inf file to see
    //
    // if we can open a backdoor for Target language
    //

    //
    // use TargetLangID as key to find alternative SourceLangID
    //

    while (p->LangId) {
        //
        // Check if we found alternative locale
        //
        AltSourceLangID = LANGIDFROMLCID(p->AltLangId);
        if ((TargetLangID == p->LangId) &&
            (SourceLangID == AltSourceLangID)
            ) {
            //
            // We are here if we found alternative source lang,
            //
            // now check the version criteria
            //
            if ((!(p->ExcludedOs & GetOsMinorId ())) &&
                ((p->MinorOs & GetOsMinorId ()) || (p->MajorOs & GetOsMajorId ()))
               ) {
               return TRUE;
            }
        }
        p++;
    }
    return FALSE;
}


BOOL
InitLanguageDetection (
    VOID
    )
/*++

Routine Description:

    Initialize language detection and put the result in 3 global variables

    SourceNativeLangID  - LANGID of Source (NT is going to be installed)

    TargetNativeLangID  - LANGID of Target (OS system which is running)

    g_IsLanguageMatched - If language is not matched, then blocks upgrade

Arguments:

    None

Return Value:

   TRUE  init correctly
   FALSE init failed

--*/
{
    //
    // Init Global Variables
    //

    SourceNativeLangID  = GetSourceNativeLangID();

    TargetNativeLangID  = GetTargetNativeLangID();

    g_IsLanguageMatched = CheckLanguageVersion(SourceNativeLangID,TargetNativeLangID);

    if (!g_IsLanguageMatched) {
        if (SourceNativeLangID == 0x00000409) {
            // This is a localized system running an English wizard.
            // We want to allow that.
            g_IsLanguageMatched = TRUE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\unpack.c ===
#include "pch.h"
#include <stdio.h>
#include <stdlib.h>
#include "loader.h"
#include "resource.h"
#include "cab.h"

// Constants
typedef enum _MIGWIZLOC
{
    MWL_EXISTING,
    MWL_UNPACKED
} MIGWIZLOC;

// Globals
HWND g_hWndParent = NULL;
HINSTANCE g_hInstParent = NULL;
static LPSTR g_lpCmdLine = NULL;


VOID
HandleError( ERRORCODE ecValue, LPARAM lpszExtra )
{
    if (ecValue != E_OK)
    {
        SendMessage( g_hWndParent, WM_USER_THREAD_ERROR, (WPARAM)ecValue, lpszExtra );
    }
}

BOOL
pIsIE4Installed (
    VOID
    )
{
    LONG hResult;
    HKEY ieKey = NULL;
    DWORD valueType = REG_SZ;
    DWORD valueSize = 0;
    PTSTR valueData = NULL;
    PTSTR numPtr = NULL;
    PTSTR dotPtr = NULL;
    INT major = 0;
    INT minor = 0;
    TCHAR saved;
    BOOL result = FALSE;

    hResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer"), 0, KEY_QUERY_VALUE, &ieKey);
    if ((hResult == ERROR_SUCCESS) &&
        ieKey
        ) {
        hResult = RegQueryValueEx (ieKey, TEXT("Version"), NULL, &valueType, NULL, &valueSize);
        if ((hResult == ERROR_SUCCESS) || (hResult == ERROR_MORE_DATA)) {
            valueData = (PTSTR)HeapAlloc (GetProcessHeap (), 0, valueSize * 2);
            if (valueData) {
                hResult = RegQueryValueEx (ieKey, TEXT("Version"), NULL, &valueType, (PBYTE)valueData, &valueSize);
                if ((hResult == ERROR_SUCCESS) && (valueType == REG_SZ)) {
                    // let's see if it the version is the correct one
                    numPtr = valueData;
                    dotPtr = _tcschr (numPtr, TEXT('.'));
                    if (dotPtr) {
                        saved = *dotPtr;
                        *dotPtr = 0;
                        major = atoi (numPtr);
                        *dotPtr = saved;
                    } else {
                        major = atoi (numPtr);
                    }
                    if (dotPtr) {
                        numPtr = _tcsinc (dotPtr);
                        dotPtr = _tcschr (numPtr, TEXT('.'));
                        if (dotPtr) {
                            saved = *dotPtr;
                            *dotPtr = 0;
                            minor = atoi (numPtr);
                            *dotPtr = saved;
                        } else {
                            minor = atoi (numPtr);
                        }
                    }
                    if ((major >= 5) ||
                        ((major == 4) && (minor >= 71))
                        ) {
                        result = TRUE;
                    }
                }
                HeapFree (GetProcessHeap (), 0, valueData);
                valueData = NULL;
            }
        }
    }
    if (ieKey) {
        RegCloseKey (ieKey);
        ieKey = NULL;
    }
    return result;
}

ERRORCODE
CheckSystemRequirements( VOID )
{
    ERRORCODE dwRetval = E_OK;
    DWORD dwArraySize;
    DWORD x;
    HMODULE hDll;
    PSTR lpszDllListA[] = REQUIRED_DLLSA;
    PWSTR lpszDllListW[] = REQUIRED_DLLSW;
    DWORD dwVersion;

    //
    // Check OS version. Disallow Win32s and NT < 4.00
    //
    dwVersion = GetVersion();
    if((dwVersion & 0xff) < 4)
    {
        HandleError( E_OLD_OS_VERSION, 0 );
        return E_OLD_OS_VERSION;
    }

    // let's check to see if IE4 is installed on this machine
    if (!pIsIE4Installed ())
    {
        HandleError( E_OLD_OS_VERSION, 0 );
        return E_OLD_OS_VERSION;
    }

    // check if required DLLS exist
    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        dwArraySize = sizeof(lpszDllListW) / sizeof(PWSTR);
        for (x=0; x<dwArraySize; x++)
        {
            hDll = LoadLibraryW( lpszDllListW[x] );
            if (!hDll)
            {
                dwRetval = E_DLL_NOT_FOUND;
                HandleError( E_DLL_NOT_FOUND, (LPARAM)lpszDllListW[x] );
                break;
            }
            FreeLibrary( hDll );
        }
    } else {
        // Win9x
        dwArraySize = sizeof(lpszDllListA) / sizeof(PSTR);
        for (x=0; x<dwArraySize; x++)
        {
            hDll = LoadLibraryA( lpszDllListA[x] );
            if (!hDll)
            {
                dwRetval = E_DLL_NOT_FOUND;
                HandleError( E_DLL_NOT_FOUND, (LPARAM)lpszDllListA[x] );
                break;
            }
            FreeLibrary( hDll );
        }
    }

    if (InitLanguageDetection ()) {
        if (!g_IsLanguageMatched) {
            HandleError( E_WRONG_LANGUAGE, 0 );
            return E_WRONG_LANGUAGE;
        }
    }

    return dwRetval;
}

ERRORCODE
StartMigwiz( MIGWIZLOC mwlLocation )
{
    PTSTR lpszPath = NULL;
    PTSTR lpszMigwiz = NULL;
    PTSTR lpszFullName = NULL;
    STARTUPINFO startInfo;
    PROCESS_INFORMATION procInfo;
    ERRORCODE ecResult = E_OK;

    if (mwlLocation == MWL_EXISTING)
    {
        lpszPath = GetModulePath();
    }
    else  // mwlLocation == MWL_UNPACKED
    {
        lpszPath = GetDestPath();
    }

    if (lpszPath == NULL)
    {
        return E_INVALID_PATH;
    }

    lpszMigwiz = GetResourceString( g_hInstParent, IDS_MIGWIZFILENAME );
    if (lpszMigwiz != NULL)
    {
        lpszFullName = JoinPaths( lpszPath, lpszMigwiz );
        FREE( lpszMigwiz );
    }

    if (lpszFullName)
    {
        if (GetFileAttributes( lpszFullName ) != -1)
        {
            PTSTR lpszCommand = NULL;

            ZeroMemory( &startInfo, sizeof(STARTUPINFO) );
            startInfo.cb = sizeof(STARTUPINFO);

            if (g_lpCmdLine)
            {
                PTSTR lpszQuotedName;
                lpszQuotedName = ALLOC( (lstrlen(lpszFullName) + 3) * sizeof(TCHAR) );
                if (lpszQuotedName)
                {
                    lpszQuotedName[0] = TEXT('"');
                    lstrcpy( (lpszQuotedName+1), lpszFullName );
                    lstrcat( lpszQuotedName, TEXT("\"") );

                    lpszCommand = JoinText( lpszQuotedName, g_lpCmdLine, TEXT(' ') );
                    FREE( lpszQuotedName );
                }
            }

            if (CreateProcess( NULL,
                               lpszCommand ? lpszCommand : lpszFullName,
                               NULL,
                               NULL,
                               FALSE,
                               DETACHED_PROCESS,
                               NULL,
                               NULL,
                               &startInfo,
                               &procInfo ))
            {
                SendMessage( g_hWndParent, WM_USER_SUBTHREAD_CREATED, (WPARAM)NULL, (LPARAM)procInfo.dwThreadId );

                WaitForSingleObject( procInfo.hProcess, INFINITE );
            }
            else
            {
                ecResult = E_PROCESS_CREATION_FAILED;
            }
            FREE( lpszCommand );
        }
        else
        {
            ecResult = E_FILE_DOES_NOT_EXIST;
        }
        FREE( lpszFullName );
    }
    else
    {
        ecResult = E_INVALID_FILENAME;
    }

    return ecResult;
}

DWORD
WINAPI
UnpackThread(
    IN      LPVOID lpParameter
    )
{
    ERRORCODE ecResult = E_OK;

    g_hWndParent = ((LPTHREADSTARTUPINFO)lpParameter)->hWnd;
    g_hInstParent = ((LPTHREADSTARTUPINFO)lpParameter)->hInstance;
    g_lpCmdLine = ((LPTHREADSTARTUPINFO)lpParameter)->lpCmdLine;

    ecResult = CheckSystemRequirements();
    if (ecResult == E_OK)
    {
        // Don't worry if this StartMigwiz fails.  It's not an error yet
        if (StartMigwiz( MWL_EXISTING ) != E_OK)
        {
            ecResult = Unpack();
            if (ecResult == E_OK)
            {
                ecResult = StartMigwiz( MWL_UNPACKED );
                CleanupTempFiles();
            }
            HandleError( ecResult, 0 );
        }
    }

    UtilFree();

    SendMessage( g_hWndParent, WM_USER_THREAD_COMPLETE, (WPARAM)NULL, (LPARAM)ecResult );
    ExitThread( ecResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\winmain.c ===
#include "pch.h"
#include "loader.h"
#include <commctrl.h>
#include "dialog.h"

static HWND g_hWndDialog = NULL;
static HANDLE g_hThread = NULL;

OSVERSIONINFO g_VersionInfo;

LRESULT CALLBACK WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch (message)
    {
    case WM_ACTIVATE:
        if (g_hWndDialog != NULL &&
            LOWORD(wParam) == WA_ACTIVE)
        {
            SetForegroundWindow( g_hWndDialog );
        }
        break;
    case WM_USER_DIALOG_COMPLETE:
        CloseHandle( g_hThread );
        DestroyWindow( g_hWndDialog );
        PostQuitMessage( 0 );
        break;
    default:
        return DefWindowProc( hWnd, message, wParam, lParam );
    }
    return 0;
}

int
APIENTRY
WinMain(HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR     lpCmdLine,
        int       nCmdShow)
{
    WNDCLASSEXA wcxA;
    WNDCLASSEXW wcxW;
    MSG msg;
    PSTR lpszClassNameA = NULL;
    PSTR lpszWindowNameA = NULL;
    PWSTR lpszClassNameW = NULL;
    PWSTR lpszWindowNameW = NULL;
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwThreadID;
    THREADSTARTUPINFO StartInfo;
    HINSTANCE hInst;
    HWND hWnd;

    InitCommonControls();

    hInst = hInstance;

    //
    // let's get the current version info, we are going to need it later
    //
    ZeroMemory (&g_VersionInfo, sizeof(OSVERSIONINFO));
    g_VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx (&g_VersionInfo)) {
        g_VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        g_VersionInfo.dwMajorVersion = 4;
        g_VersionInfo.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
    }

    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        lpszClassNameW = GetResourceStringW( hInstance, IDS_WINDOWCLASS );
        lpszWindowNameW = GetResourceStringW( hInstance, IDS_WINDOWTITLE );
        hWnd = FindWindowW( lpszClassNameW, NULL );
        if (hWnd)
        {
            SetForegroundWindow( hWnd );
            goto END;
        }
        wcxW.cbSize = sizeof (WNDCLASSEXW);
        wcxW.style = CS_HREDRAW | CS_VREDRAW;
        wcxW.lpfnWndProc = WndProc;
        wcxW.cbClsExtra = 0;
        wcxW.cbWndExtra = 0;
        wcxW.hInstance = hInstance;
        wcxW.hIcon = NULL;
        wcxW.hCursor = LoadCursorA(NULL, IDC_ARROW);
        wcxW.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcxW.lpszMenuName = NULL;
        wcxW.lpszClassName = lpszClassNameW;
        wcxW.hIconSm = NULL;
        if (!RegisterClassExW (&wcxW))
        {
            dwResult = GetLastError();
            goto END;
        }
        hWnd = CreateWindowW( lpszClassNameW,
                              lpszWindowNameW,
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              400,
                              300,
                              NULL,
                              NULL,
                              hInstance,
                              NULL );
        if (!hWnd)
        {
            dwResult = GetLastError();
            goto END;
        }
        StartInfo.hWnd = hWnd;
        StartInfo.hInstance = hInstance;
        g_hWndDialog = CreateDialogParamW( hInstance,
                                           MAKEINTRESOURCEW(IDD_MIGWIZINIT),
                                           hWnd,
                                           DlgProc,
                                           (LPARAM)&StartInfo );
        if (g_hWndDialog == NULL)
        {
            dwResult = GetLastError();
            goto END;
        }
    } else {
        // Win9x
        lpszClassNameA = GetResourceStringA( hInstance, IDS_WINDOWCLASS );
        lpszWindowNameA = GetResourceStringA( hInstance, IDS_WINDOWTITLE );
        hWnd = FindWindowA( lpszClassNameA, lpszWindowNameA );
        if (hWnd)
        {
            SetForegroundWindow( hWnd );
            goto END;
        }
        wcxA.cbSize = sizeof (WNDCLASSEXA);
        wcxA.style = CS_HREDRAW | CS_VREDRAW;
        wcxA.lpfnWndProc = WndProc;
        wcxA.cbClsExtra = 0;
        wcxA.cbWndExtra = 0;
        wcxA.hInstance = hInstance;
        wcxA.hIcon = NULL;
        wcxA.hCursor = LoadCursorA(NULL, IDC_ARROW);
        wcxA.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wcxA.lpszMenuName = NULL;
        wcxA.lpszClassName = lpszClassNameA;
        wcxA.hIconSm = NULL;
        if (!RegisterClassExA (&wcxA))
        {
            dwResult = GetLastError();
            goto END;
        }
        hWnd = CreateWindowA( lpszClassNameA,
                              lpszWindowNameA,
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              400,
                              300,
                              NULL,
                              NULL,
                              hInstance,
                              NULL );
        if (!hWnd)
        {
            dwResult = GetLastError();
            goto END;
        }
        StartInfo.hWnd = hWnd;
        StartInfo.hInstance = hInstance;
        g_hWndDialog = CreateDialogParamA( hInstance,
                                           MAKEINTRESOURCEA(IDD_MIGWIZINIT),
                                           hWnd,
                                           DlgProc,
                                           (LPARAM)&StartInfo );
        if (g_hWndDialog == NULL)
        {
            dwResult = GetLastError();
            goto END;
        }
    }

    // Create the Unpacking thread.
    // Note we pass along the Dialog's hwnd so the thread will report directly to it
    StartInfo.hWnd = g_hWndDialog;
    StartInfo.hInstance = hInstance;
    StartInfo.lpCmdLine = lpCmdLine;
    g_hThread = CreateThread( NULL,
                              0,
                              UnpackThread,
                              (PVOID)&StartInfo,
                              0,
                              &dwThreadID );
    if (g_hThread == NULL)
    {
        // TODO: Handle Error
        dwResult = GetLastError();
        goto END;
    }

    // Main message loop:
    while (GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    dwResult = LOWORD(msg.wParam);

END:
    if (g_VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        // WinNT
        if (lpszClassNameW)
        {
            UnregisterClassW(lpszClassNameW, hInstance);
            FREE( lpszClassNameW );
        }
        if (lpszWindowNameW)
        {
            FREE( lpszWindowNameW );
        }
    } else {
        // Win9x
        if (lpszClassNameA)
        {
            UnregisterClassA(lpszClassNameA, hInstance);
            FREE( lpszClassNameA );
        }
        if (lpszWindowNameA)
        {
            FREE( lpszWindowNameA );
        }
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loadstate\loadstate.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    loadstate.c

Abstract:

    <abstract>

Author:

    <full name> (<alias>) <date>

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include <tlhelp32.h>
#include <shlobjp.h>
#ifdef DEBUG
#include <shellapi.h>
#endif

#include "logmsg.h"
#include "common.h"

#define DBG_LOADSTATE       "LoadState"

//
// Strings
//

// None

//
// Constants
//

#define LOG_VERBOSE_BIT  0x01
#define LOG_UNUSED_BIT   0x02   // for v1 compatibility, do not use
#define LOG_STATUS_BIT   0x04
#define LOG_DEBUGGER_BIT 0x08
#define LOG_UPDATE_BIT   0x10

#define LOADSTATE_LOAD      0x00000001
#define LOADSTATE_EXECUTE   0x00000002
#define LOADSTATE_COMPLETED 0x00000003

#define RETURN_SUCCESS          0
#define RETURN_FATAL_ERROR      1
#define RETURN_ERROR            2
#define RETURN_IGNORED_ERROR    3

//
// Macros
//

// None

//
// Types
//

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE, *PREGSHELLSTATE;

//
// Globals
//

PTSTR g_Explorer = NULL;
BOOL g_ContinueOnError = FALSE;
DWORD g_ReturnCode = ERROR_SUCCESS;
TCHAR g_JournalPath[MAX_PATH_PLUS_NUL];
BOOL g_Break;

#ifdef PRERELEASE
HANDLE g_CallbackEvent;
#endif

//
// Macro expansion list
//

#define REQUIRED_INFS       \
        DEFMAC(OSFILES,     TEXT("USMTDef.inf"))  \

//
// Private function prototypes
//

MESSAGECALLBACK pSaveMsgCallback;

PTSTR
pGetShellFolderPath (
    IN      INT Folder
    );

//
// Macro expansion definition
//

//
// This is the structure used for handling required infs
//
typedef struct {
    PCTSTR InfId;
    PCTSTR InfName;
} REQUIREDINF_STRUCT, *PREQUIREDINF_STRUCT;

//
// Declare a global array of required infs
//
#define DEFMAC(infid,infname) {TEXT(#infid),infname},
static REQUIREDINF_STRUCT g_RequiredInfs[] = {
                              REQUIRED_INFS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//

VOID
pCleanUpApp (
    VOID
    )
{
    IsmTerminate();

    if (g_JournalPath[0]) {
        DeleteFile (g_JournalPath);
        g_JournalPath[0] = 0;
    }

#ifdef PRERELEASE
    CloseHandle (g_CallbackEvent);
#endif
}


BOOL
WINAPI
CtrlCRoutine (
    IN      DWORD ControlSignal
    )
{
    PrintMsgOnConsole (MSG_EXITING);

    LOG ((LOG_WARNING, (PCSTR) MSG_TOOL_STOPPED));

    g_Break = TRUE;

    IsmSetCancel();
    while (IsmCurrentlyExecuting()) {
        Sleep (1000);
    }

    pCleanUpApp();

    printf ("\n");
    exit (1);
}


VOID
pHelpAndExit (
    VOID
    )
{
    PrintMsgOnConsole (MSG_HELP);

#ifdef PRERELEASE
    printf ("\nAdditional PRERELEASE options:\n\n"
            "/tf            Uses full transport instead of v1 transport\n"
            "/tc            Enable compression\n"
            "/ta            Enable automatic capability (for homenet transport)\n"
            "/ti:<tag>      Specify an identity tag for the homenet transprot\n"
            "               Default is user name\n"
            "/t:<name>      Specifies transport to use\n"
            "/r             Start in recovery mode\n"
            );
#endif

    UtTerminate ();
    exit (1);
}

VOID
pSwitchToClassicDesktop (
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    TCHAR data[] = TEXT("0");

    //
    // The only thing that we need to do is to turn off:
    // HKCU\Software\Microsoft\Windows\CurrentVersion\ThemeManager [ThemeActive]
    //
    key = OpenRegKeyStr (TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"));

    if (key) {

        RegSetValueEx (
            key,
            TEXT("ThemeActive"),
            0,
            REG_SZ,
            (PBYTE)data,
            sizeof (data)
            );

        CloseRegKey (key);
    }
}

VOID
pSwitchToClassicTaskBar (
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    DWORD dataType;
    DWORD dataSize = 0;
    PBYTE data = NULL;
    PREGSHELLSTATE shellState = NULL;
    LONG result;

    //
    // The only thing that we need to do is to turn off the fStartPanelOn field in:
    // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer [ShellState]
    //
    key = OpenRegKeyStr (TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"));

    if (key) {

        result = RegQueryValueEx (
                    key,
                    TEXT ("ShellState"),
                    NULL,
                    &dataType,
                    NULL,
                    &dataSize
                    );

        if ((result == ERROR_SUCCESS) || (result == ERROR_MORE_DATA)) {
            data = MemAllocUninit (dataSize);
            if (data) {
                result = RegQueryValueEx (
                            key,
                            TEXT ("ShellState"),
                            NULL,
                            &dataType,
                            data,
                            &dataSize
                            );
                if ((result == ERROR_SUCCESS) &&
                    (dataType == REG_BINARY) &&
                    (dataSize == sizeof (REGSHELLSTATE))
                    ) {
                    if (dataType == REG_BINARY) {
                        shellState = (PREGSHELLSTATE) data;
                        shellState->ss.fStartPanelOn = FALSE;
                        RegSetValueEx (
                            key,
                            TEXT("ShellState"),
                            0,
                            REG_BINARY,
                            (PBYTE)data,
                            dataSize
                            );
                    }
                }
                FreeAlloc (data);
            }
        }

        CloseRegKey (key);
    }
}

VOID
pRegisterFonts (
    IN      PCTSTR Args
    )
{
    WIN32_FIND_DATA findData;
    HANDLE findHandle = INVALID_HANDLE_VALUE;
    PTSTR fontDir = NULL;
    TCHAR fontPattern [MAX_PATH];
    //
    // Let's (re)register all the fonts (in case the user migrated some new ones).
    //
    fontDir = pGetShellFolderPath (CSIDL_FONTS);
    if (fontDir) {
        StringCopyTcharCount (fontPattern, fontDir, ARRAYSIZE (fontPattern) - 4);
        StringCat (fontPattern, TEXT("\\*.*"));
        findHandle = FindFirstFile (fontPattern, &findData);
        if (findHandle != INVALID_HANDLE_VALUE) {
            do {
                AddFontResource (findData.cFileName);
            } while (FindNextFile (findHandle, &findData));
            FindClose (findHandle);
        }
    }
}

BOOL
pLoadstateExecute (
    IN      PCTSTR ExecuteArgs
    )
{
    PCTSTR funcName = NULL;
    PCTSTR funcArgs = NULL;

    funcName = ExecuteArgs;
    if (!funcName || !(*funcName)) {
        return FALSE;
    }
    funcArgs = _tcschr (funcName, 0);
    if (funcArgs) {
        funcArgs ++;
        if (!(*funcArgs)) {
            funcArgs = NULL;
        }
    }
    // BUGBUG - temporary, make a macro expansion list out of it
    if (StringIMatch (funcName, TEXT("SwitchToClassicDesktop"))) {
        pSwitchToClassicDesktop (funcArgs);
    }
    if (StringIMatch (funcName, TEXT("SwitchToClassicTaskBar"))) {
        pSwitchToClassicTaskBar (funcArgs);
    }
    if (StringIMatch (funcName, TEXT("RegisterFonts"))) {
        pRegisterFonts (funcArgs);
    }
    return TRUE;
}

ULONG_PTR
pSaveMsgCallback (
    UINT Message,
    ULONG_PTR Arg
    )
{
#ifdef PRERELEASE
    PRMEDIA_EXTRADATA extraData;
#endif

    switch (Message) {

#ifdef PRERELEASE
    case TRANSPORTMESSAGE_READY_TO_CONNECT:
        {
            TCHAR msg[512];

            wsprintf (msg, TEXT("Do you want to connect to %s?"), (PCTSTR) Arg);
            if (MessageBox (NULL, msg, TEXT("Question For You"), MB_YESNO|MB_SYSTEMMODAL) == IDYES) {
                SetEvent (g_CallbackEvent);
                return APPRESPONSE_SUCCESS;
            }

            return APPRESPONSE_FAIL;
        }

    case TRANSPORTMESSAGE_RMEDIA_LOAD:
        extraData = (PRMEDIA_EXTRADATA) Arg;
        if (!extraData) {
            return (MessageBox (
                        NULL,
                        TEXT("Please insert the next media in your drive."),
                        TEXT("LoadState"),
                        MB_OKCANCEL
                        ) == IDOK);
        }
        if (extraData->MediaNumber == 1) {
            switch (extraData->LastError) {
            case RMEDIA_ERR_NOERROR:
                return TRUE;
            case RMEDIA_ERR_WRONGMEDIA:
                return (MessageBox (
                            NULL,
                            TEXT("You have inserted the wrong media.\n\nPlease insert the first media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_DISKFULL:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted does not have enough free space.\n\nPlease insert the first media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_WRITEPROTECT:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted is write protected.\n\nPlease insert the first media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_NOTREADY:
                return (MessageBox (
                            NULL,
                            TEXT("The drive is not ready for use. Please check the drive and make sure that a disk is inserted and that the drive door is closed."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_CRITICAL:
                return FALSE;
            default:
                return (MessageBox (
                            NULL,
                            TEXT("Your media is toast.\n\nPlease insert the first media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            }
        } else {
            switch (extraData->LastError) {
            case RMEDIA_ERR_NOERROR:
                return TRUE;
            case RMEDIA_ERR_WRONGMEDIA:
                return (MessageBox (
                            NULL,
                            TEXT("You have inserted the wrong media.\n\nPlease insert the next media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_DISKFULL:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted does not have enough free space.\n\nPlease insert the next media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_WRITEPROTECT:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted is write protected.\n\nPlease insert the next media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_NOTREADY:
                return (MessageBox (
                            NULL,
                            TEXT("The drive is not ready for use. Please check the drive and make sure that a disk is inserted and that the drive door is closed."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_CRITICAL:
                return FALSE;
            default:
                return (MessageBox (
                            NULL,
                            TEXT("Your media is toast.\n\nPlease insert the next media in your drive."),
                            TEXT("LoadState"),
                            MB_OKCANCEL
                            ) == IDOK);
            }
        }
#endif

    case ISMMESSAGE_EXECUTE_REFRESH:
        pLoadstateExecute ((PCTSTR) Arg);
        return APPRESPONSE_SUCCESS;

    default:
        break;
    }
    return FALSE;
}

BOOL
pIsUserAdmin (
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a member of the
    Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS expected to be
    able to open their own process and process token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE token;
    DWORD bytesRequired;
    PTOKEN_GROUPS groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PSID administratorsGroup;

    if (ISWIN9X()) {
        return TRUE;
    }

    //
    // Open the process token.
    //
    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
        return FALSE;
    }

    b = FALSE;
    groups = NULL;

    //
    // Get group information.
    //
    if (!GetTokenInformation (token, TokenGroups, NULL, 0, &bytesRequired) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER
         ) {

        groups = (PTOKEN_GROUPS) MemAllocUninit (bytesRequired);
        b = GetTokenInformation (token, TokenGroups, groups, bytesRequired, &bytesRequired);
    }

    if (b) {

        b = AllocateAndInitializeSid (
                &ntAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &administratorsGroup
                );

        if (b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for (i = 0 ; i < groups->GroupCount ; i++) {
                if (EqualSid (groups->Groups[i].Sid, administratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid (administratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if (groups) {
        FreeAlloc (groups);
    }

    CloseHandle (token);

    return b;
}


VOID
pMyLogCallback (
    IN      PLOGARG LogArg
    )
{
    if (LogArg->Debug) {
        DEBUGDIRECT (LogArg->Type, LogArg->FormattedMessage);
    } else {
        if (StringIMatchA (LogArg->Type, LOG_ERROR)) {
            if (g_ReturnCode == RETURN_SUCCESS) {
                g_ReturnCode = g_ContinueOnError?RETURN_IGNORED_ERROR:RETURN_ERROR;
            }
            if (g_ReturnCode == RETURN_IGNORED_ERROR) {
                g_ReturnCode = g_ContinueOnError?RETURN_IGNORED_ERROR:RETURN_ERROR;
            }
        } else if (StringIMatchA (LogArg->Type, LOG_MODULE_ERROR) ||
                   StringIMatchA (LogArg->Type, LOG_FATAL_ERROR)) {
            g_ReturnCode = RETURN_FATAL_ERROR;
        }
        LOGDIRECT (LogArg->Type, LogArg->FormattedMessage);
    }
}

#ifdef DEBUG
VOID
pStopAndDisplayInfs (
    IN      PGROWBUFFER InputInfs,
    IN      BOOL Begin
    )
{
    MULTISZ_ENUM infEnum;

    if (MessageBox (
            NULL,
            TEXT("LoadState stopped. Do you want to display all loaded INFs?"),
            Begin?TEXT("LoadState-Begin"):TEXT("LoadState-End"),
            MB_YESNO
            ) == IDYES) {
        //
        // now let's open append all INF files and pass the HINF to
        // everybody.
        //
        if (EnumFirstMultiSz (&infEnum, (PCTSTR)InputInfs->Buf)) {
            do {
                ShellExecute (NULL, TEXT("open"), infEnum.CurrentString, NULL, NULL, SW_SHOWNORMAL);
            } while (EnumNextMultiSz (&infEnum));
        }
        MessageBox (NULL, TEXT("Press OK to continue..."), TEXT("LoadState-Begin"), MB_OK);
    }
}
#endif

BOOL
pOpenOrAppendInfFile (
    IN      HINF *InfHandle,
    IN      PCTSTR Filename
    )
{
    BOOL result = TRUE;

    if (*InfHandle == INVALID_HANDLE_VALUE) {
        *InfHandle = SetupOpenInfFile (Filename, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
        if (*InfHandle == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_FILE, Filename));
            result = FALSE;
        }
    } else {
        if (!SetupOpenAppendInfFile (Filename, *InfHandle, NULL)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_FILE, Filename));
            result = FALSE;
        }
    }
    return result;
}

PTSTR
pGetShellFolderPath (
    IN      INT Folder
    )
{
    PTSTR result = NULL;
    HRESULT hResult;
    BOOL b;
    LPITEMIDLIST localpidl = NULL;
    IMalloc *mallocFn;

    hResult = SHGetMalloc (&mallocFn);
    if (hResult != S_OK) {
        return NULL;
    }

    hResult = SHGetSpecialFolderLocation (NULL, Folder, &localpidl);

    if (hResult == S_OK) {

        result = (PTSTR) LocalAlloc (LPTR, MAX_PATH);
        if (result) {
             b = SHGetPathFromIDList (localpidl, result);

            if (b) {
                return result;
            }

            LocalFree (result);
        }
    }

    if (localpidl) {
        mallocFn->lpVtbl->Free (mallocFn, localpidl);
        localpidl = NULL;
    }

    return result;
}


VOID
__cdecl
_tmain (
    IN      INT Argc,
    IN      PCTSTR Argv[]
    )
{
    TCHAR appPath[MAX_PATH_PLUS_NUL];
    PCTSTR delayedCmd = NULL;
    TCHAR ismPath[MAX_PATH_PLUS_NUL];
    TCHAR infPath[MAX_PATH_PLUS_NUL];
    PTSTR iconLibRoot = NULL;
    TCHAR iconLibSrc[MAX_PATH] = TEXT("");
    TCHAR iconLibDest[MAX_PATH] = TEXT("");
    BOOL iconLibFound = FALSE;
    PCTSTR commandLine = NULL;
    DWORD err;
    PTSTR p;
    MIG_TRANSPORTID transportId;
    MIG_TRANSPORTSTORAGEID transportStorageId;
    MULTISZ_ENUM infEnum;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_STRUCT infHandleStruct;
    MIG_OBJECTSTRINGHANDLE objectPattern;
    MIG_OBJECT_ENUM objectEnum;
    MULTISZ_ENUM e;
    DWORD appStatus;
    BOOL loadResult;
    BOOL storagePathIsValid = FALSE;
    BOOL terminateIsm = FALSE;
    BOOL logEnabled = FALSE;
    PCTSTR msg;
#ifdef UNICODE
    PCSTR ansimsg;
#endif
    PCTSTR argArray[1];
    BOOL fail;
    TOOLARGS args;

#ifdef PRERELEASE
    g_CallbackEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
#endif

    SET_RESETLOG();
    UtInitialize (NULL);

    SuppressAllLogPopups (TRUE);

    // this part is for matching thread's locale to the console code page
    CallSetThreadUILanguage ();

    PrintMsgOnConsole (MSG_RUNNING);

    // initialize app journal path
    g_JournalPath [0] = 0;
    if (GetWindowsDirectory (g_JournalPath, ARRAYSIZE (g_JournalPath))) {
        StringCopy (AppendWack (g_JournalPath), TEXT("LOADSTATE.JRN"));
    }

    GetModuleFileName (NULL, appPath, ARRAYSIZE(appPath));
    delayedCmd = JoinText (appPath, TEXT(" /d"));
    p = _tcsrchr (appPath, TEXT('\\'));
    if (p) {
        *p = 0;
    }

    iconLibSrc [0] = 0;
    GetSystemDirectory (iconLibSrc, ARRAYSIZE(iconLibSrc));
    StringCopy (AppendWack (iconLibSrc), TEXT("usmt\\iconlib.dll"));

    //
    // Parse the command line
    //

    fail = TRUE;

    switch (ParseToolCmdLine (FALSE, &args, Argc, Argv)) {

    case PARSE_SUCCESS:
        fail = FALSE;
        break;

    case PARSE_MULTI_LOG:
        PrintMsgOnConsole (MSG_MULTI_LOG);
        g_ReturnCode = RETURN_FATAL_ERROR;
        goto END;

    case PARSE_BAD_LOG:
        argArray[0] = args.LogFile;
        msg = ParseMessageID (MSG_CANT_OPEN_LOG, argArray);
        if (msg) {
#ifdef UNICODE
            ansimsg = ConvertWtoA (msg);
            printf ("%s", ansimsg);
            FreeConvertedStr (ansimsg);
#else
            printf ("%s", msg);
#endif
            FreeStringResource (msg);
        }

        g_ReturnCode = RETURN_FATAL_ERROR;
        goto END;

    default:
        break;
    }

    if (fail) {
        pHelpAndExit();
    }

    g_ContinueOnError = args.ContinueOnError;

    if (args.HackHiveOn) {
        // This is the second copy of loadstate.exe that's running.
        // We are going to wait for the first copy to finish and then
        // we are going to attempt to unload the user's hive.
        DWORD processId = 0;
        HANDLE processHandle = NULL;
        DWORD waitResult = 0;

        _stscanf (args.HackProcessId, TEXT("%lx"), &(processId));

        processHandle = OpenProcess (SYNCHRONIZE, TRUE, processId);

        if (processHandle) {

            waitResult = WaitForSingleObject (processHandle, INFINITE);
            // we don't really care about the result. We are going to
            // attempt to unload the hive anyway
        }

        // now let's try to unload the hive
        g_ReturnCode = RegUnLoadKey (HKEY_USERS, args.HackMappedHive);

        if (g_ReturnCode == ERROR_SUCCESS) {
            PrintMsgOnConsole (MSG_SUCCESS);
        } else {
            PrintMsgOnConsole (MSG_FAILED_NO_LOG);
        }

        UtTerminate ();

        while (g_Break) {
            // infinite loop, because we'll get terminated in the ctrl+c handler
            Sleep (50);
        }

        exit (g_ReturnCode);
    }

#ifdef DEBUG
    {
        if (DoesFileExist (TEXT("C:\\LOADSTATE.BEGIN"))) {
            pStopAndDisplayInfs (&args.InputInf, TRUE);
        }
    }
#endif

    LogReInit (NULL, NULL, args.LogFile ? args.LogFile : TEXT("loadstate.log"), NULL);
    logEnabled = TRUE;

    // Let's log the command line that was used
    commandLine = GetCommandLine ();
    if (commandLine) {
        LOG ((LOG_INFORMATION, (PCSTR)MSG_COMMAND_LINE_USED, commandLine));
    }

    //
    // Check requirements
    //

    if (args.BadInfs.End || args.MultiInfs.End) {
        SetLastError (ERROR_BAD_COMMAND);

        if (EnumFirstMultiSz (&e, (PCTSTR) args.BadInfs.Buf)) {
            do {
                LOG ((LOG_ERROR, (PCSTR) MSG_INF_FILE_NOT_FOUND, e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) args.MultiInfs.Buf)) {
            do {
                LOG ((LOG_ERROR, (PCSTR) MSG_INF_SPECIFIED_MORE_THAN_ONE, e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }

        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CMD_LINE_ERROR));
        goto END;
    }

    if (!GetFilePath (TEXT("migism.inf"), ismPath, ARRAYSIZE(ismPath))) {
        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_ISM_INF_MISSING));
        goto END;
    }

    if (ISWIN9X()) {
        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_NT_REQUIRED));
        goto END;
    }

#ifndef UNICODE
    // ANSI version of loadstate.exe is not tested, let's not allow it to run
    g_ReturnCode = RETURN_ERROR;
    SetLastError (ERROR_APP_WRONG_OS);
    LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNICODE_REQUIRED));
    goto END;
#endif

    if (!pIsUserAdmin() && !args.DelayedOpsOn) {
        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_ADMIN_REQUIRED));
        goto END;
    }

    //
    // Initialize ISM
    //

    if (!IsmInitialize (ismPath, pSaveMsgCallback, pMyLogCallback)) {
        g_ReturnCode = RETURN_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_ISM));
        goto END;
    }

    terminateIsm = TRUE;
    SetLogVerbosity (args.VerboseLevel);

    SetConsoleCtrlHandler (CtrlCRoutine, TRUE);

    // upload environment variables
    UploadEnvVars (PLATFORM_DESTINATION);

    // we will try to copy iconlib.dll from our directory into "Common AppData" directory
    // If we don't succeed, we will not set the S_ENV_ICONLIB env variable

    iconLibFound = FALSE;

    iconLibRoot = pGetShellFolderPath (CSIDL_COMMON_APPDATA);
    if (iconLibRoot) {
        __try {
            StringCopy (iconLibDest, iconLibRoot);
            StringCopy (AppendWack (iconLibDest), TEXT("Microsoft"));
            if (!CreateDirectory (iconLibDest, NULL)) {
                err = GetLastError ();
                if (err != ERROR_ALREADY_EXISTS) {
                    __leave;
                }
            }
            StringCopy (AppendWack (iconLibDest), TEXT("USMT"));
            if (!CreateDirectory (iconLibDest, NULL)) {
                err = GetLastError ();
                if (err != ERROR_ALREADY_EXISTS) {
                    __leave;
                }
            }
            StringCopy (AppendWack (iconLibDest), TEXT("iconlib.dll"));
            if (!CopyFile (iconLibSrc, iconLibDest, TRUE)) {
                err = GetLastError ();
                if (err != ERROR_FILE_EXISTS) {
                    __leave;
                }
            }
            iconLibFound = TRUE;
        }
        __finally {
            LocalFree (iconLibRoot);
            iconLibRoot = NULL;
        }
    }

    // Set the icon lib data
    if (iconLibFound) {
        IsmSetEnvironmentString (PLATFORM_DESTINATION, NULL, S_ENV_ICONLIB, iconLibDest);
    }

    infHandle = InitRequiredInfs (appPath, (PCSTR) MSG_CANT_OPEN_REQUIRED_FILE);

    if (infHandle != INVALID_HANDLE_VALUE) {
        infHandleStruct.Type = ENVENTRY_BINARY;
        infHandleStruct.EnvBinaryData = (PVOID)(&infHandle);
        infHandleStruct.EnvBinaryDataSize = sizeof (HINF);
        IsmSetEnvironmentValue (PLATFORM_DESTINATION, NULL, S_GLOBAL_INF_HANDLE, &infHandleStruct);
    }

    if (args.UserOn) {
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_HKCU_V1);
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_HKCU_ON);
    }

    if (args.FilesOn) {
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_ALL_FILES);
    }

    IsmSetPlatform (PLATFORM_DESTINATION);

    if (!args.CurrentUser) {
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_REQUIRE_DOMAIN_USER);
        IsmSetEnvironmentFlag (PLATFORM_DESTINATION, NULL, S_ENV_CREATE_USER);
    }

    //
    // Start ETM modules
    //

    if (!IsmStartEtmModules ()) {
        if (!IsmCheckCancel()) {
            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_ETMS));
        }
        goto END;
    }

    if (args.DelayedOpsOn) {

        appStatus = ReadAppStatus (g_JournalPath);

        if ((appStatus != LOADSTATE_COMPLETED) &&
            (appStatus != LOADSTATE_EXECUTE) &&
            (appStatus != 0)
            ) {

            // unknown state, just cleanup the delayed ops journal
            IsmExecute (EXECUTETYPE_DELAYEDOPERATIONSCLEANUP);

        } else {

            IsmSetRollbackJournalType (FALSE);
            if (appStatus == LOADSTATE_EXECUTE) {
                IsmRollback ();
            }
            // write the app status
            WriteAppStatus (g_JournalPath, LOADSTATE_EXECUTE);
            IsmExecute (EXECUTETYPE_DELAYEDOPERATIONS);
            // write the app status
            WriteAppStatus (g_JournalPath, LOADSTATE_COMPLETED);
        }

    } else {

        //
        // Initialize transport
        //

        if (!IsmStartTransport ()) {
            if (!IsmCheckCancel()) {
                LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_TRANS));
            }
            goto END;
        }

        transportStorageId = IsmRegisterTransport (args.TransportName);

        if (args.FullTransport) {
            transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, args.Capabilities);
        } else {
            transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_LIGHT, args.Capabilities);
        }

        if (!transportId) {
            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_TRANSPORT_UNAVAILABLE));
            goto END;
        }

#ifdef PRERELEASE

        IsmSetEnvironmentString (PLATFORM_DESTINATION, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, args.Tag);

#endif

        if (!IsmSetTransportStorage (
                PLATFORM_DESTINATION,
                transportId,
                transportStorageId,
                args.Capabilities,
                args.StoragePath,
                &storagePathIsValid,
                NULL
                ) ||
                storagePathIsValid == FALSE) {
            if (!IsmCheckCancel()) {
                LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_TRANSPORT_STORAGE_INVALID, args.StoragePath));
            }
            goto END;
        }

#ifdef PRERELEASE
        if (args.Capabilities & CAPABILITY_AUTOMATED) {
            WaitForSingleObject (g_CallbackEvent, INFINITE);
        }
#endif

        appStatus = ReadAppStatus (g_JournalPath);

        if (appStatus != LOADSTATE_COMPLETED) {

            // if we need to, call IsmRollback
            if (appStatus == LOADSTATE_EXECUTE) {

                IsmRollback ();

                appStatus = LOADSTATE_LOAD;
            }

#ifdef PRERELEASE
            if (!args.Recovery) {
#endif
                // write the app status
                WriteAppStatus (g_JournalPath, LOADSTATE_LOAD);

                //
                // Recover the state
                //

                if (appStatus == LOADSTATE_LOAD) {
                    loadResult = IsmResumeLoad ();
                    if (!loadResult) {
                        loadResult = IsmLoad ();
                    }
                } else {
                    loadResult = IsmLoad ();
                }

                if (loadResult) {

                    // before we go further, let's see if we wanted to change the user name and/or domain
                    if (args.NewDomainName) {
                        IsmSetEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, TEXT("ALTUSERDOMAIN"), args.NewDomainName);
                    }
                    if (args.NewUserName) {
                        IsmSetEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, TEXT("ALTUSERNAME"), args.NewUserName);
                    }

                    // Load INFs that were specified in scanstate

                    if (!args.NoScanStateInfs) {
                        objectPattern = IsmCreateSimpleObjectPattern (TEXT("External"), FALSE, S_INF_OBJECT_NAME TEXT("*"), TRUE);

                        if (IsmEnumFirstSourceObject(&objectEnum, MIG_DATA_TYPE, objectPattern)) {
                            do {
                                if (IsmGetControlFile (objectEnum.ObjectTypeId, objectEnum.ObjectName, infPath)) {
                                    IsmAppendEnvironmentMultiSz (
                                        PLATFORM_DESTINATION,
                                        NULL,
                                        S_INF_FILE_MULTISZ,
                                        infPath
                                        );
                                    pOpenOrAppendInfFile (&infHandle, infPath);
                                }
                            } while (IsmEnumNextObject (&objectEnum));
                        }
                        IsmDestroyObjectHandle (objectPattern);
                    }

                    if (args.InputInf.Buf) {
                        //
                        // now let's open append all INF files and pass the HINF to
                        // everybody.
                        //
                        if (EnumFirstMultiSz (&infEnum, (PCTSTR)args.InputInf.Buf)) {
                            do {
                                IsmAppendEnvironmentMultiSz (
                                    PLATFORM_DESTINATION,
                                    NULL,
                                    S_INF_FILE_MULTISZ,
                                    infEnum.CurrentString
                                    );
                                pOpenOrAppendInfFile (&infHandle, infEnum.CurrentString);
                            } while (EnumNextMultiSz (&infEnum));
                        }
                    }

                    if (!args.FullTransport) {

                        //
                        // Execute the preparsing to populate components
                        //

                        if (IsmExecute (EXECUTETYPE_EXECUTESOURCE_PARSING)) {

                            IsmSelectMasterGroup (MASTERGROUP_ALL, TRUE);

                            if (!args.SystemOn) {
                                IsmSelectMasterGroup (MASTERGROUP_SYSTEM, FALSE);
                                IsmSelectMasterGroup (MASTERGROUP_USER, FALSE);
                                IsmSelectMasterGroup (MASTERGROUP_APP, FALSE);
                            }

                            SelectComponentsViaInf (infHandle);

                            //
                            // Execute data gather
                            //

                            if (!IsmExecute (EXECUTETYPE_EXECUTESOURCE)) {
                                if (!IsmCheckCancel()) {
                                    LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_SOURCE));
                                }
                            }

                        } else {
                            if (!IsmCheckCancel()) {
                                LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_SOURCE));
                            }
                        }
                    }

                    //
                    // Apply saved state
                    //

                    // write the app status
                    WriteAppStatus (g_JournalPath, LOADSTATE_EXECUTE);

                    IsmSetDelayedOperationsCommand (delayedCmd);

                    if (!IsmExecute (EXECUTETYPE_EXECUTEDESTINATION)) {
                        if (!IsmCheckCancel()) {
                            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_DEST));
                        }
                    }

                } else {
                    LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_FIND_SAVED_STATE));
                }

#ifdef PRERELEASE
            }
#endif
            // write the app status
            WriteAppStatus (g_JournalPath, LOADSTATE_COMPLETED);
        }
    }

    //
    // We're done!
    //

    SetupCloseInfFile (infHandle);

#ifdef DEBUG
    {
        if (DoesFileExist (TEXT("C:\\LOADSTATE.END"))) {
            pStopAndDisplayInfs (&args.InputInf, FALSE);
        }
    }
#endif

END:

    // If we were successfull, it is time to check for registry leaks
    // We call OE DLL entries and sometimes they leak registry keys.
    // When we create a new profile this is particularly bad because
    // we cannot unload the hive.
    if (!g_Break) {
        if (g_ReturnCode == RETURN_SUCCESS) {
            DWORD sizeNeeded;
            HKEY tempKey = NULL;
            PTSTR mappedKeyStr = NULL;
            DWORD processId = 0;
            TCHAR tempStr1 [sizeof (DWORD) * 2 + sizeof(TEXT(" /hp: 0x")) + 1];
            PCTSTR tempStr2 = NULL;
            PTSTR tempStr3 = NULL;
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            // Let's get the location of the mapped hive
            if (IsmGetEnvironmentString (
                    PLATFORM_DESTINATION,
                    NULL,
                    S_VER_HIVEMAPPEDLOCATION,
                    NULL,
                    0,
                    &sizeNeeded
                    )) {

                mappedKeyStr = AllocPathString (sizeNeeded);
                if (mappedKeyStr) {

                    if (IsmGetEnvironmentString (
                            PLATFORM_DESTINATION,
                            NULL,
                            S_VER_HIVEMAPPEDLOCATION,
                            mappedKeyStr,
                            sizeNeeded,
                            NULL
                            )) {
                        tempKey = OpenRegKey (HKEY_USERS, mappedKeyStr);
                        if (tempKey) {
                            // Yep, we had a leak and the hive was not unloaded
                            LOG ((LOG_INFORMATION, (PCSTR)MSG_UNLOAD_HIVE_HACK));

                            // What we are going to do is we are going to launch
                            // ourself passing the mappedKeyStr and our process ID
                            processId = GetCurrentProcessId ();
                            if (processId) {
                                wsprintf (tempStr1, TEXT(" /hp:0x%08X "), processId);
                                tempStr2 = JoinText (TEXT("/hm:"), mappedKeyStr);
                                if (tempStr2) {

                                    tempStr3 = JoinText (tempStr1, tempStr2);
                                    if (tempStr3) {

                                        if (GetModuleFileName (NULL, appPath, ARRAYSIZE(appPath))) {
                                            ZeroMemory (&si, sizeof (si));
                                            if (CreateProcess (
                                                    appPath,
                                                    tempStr3,
                                                    NULL,
                                                    NULL,
                                                    FALSE,
                                                    CREATE_NEW_CONSOLE,
                                                    NULL,
                                                    NULL,
                                                    &si,
                                                    &pi
                                                    )) {
                                                CloseHandle (pi.hThread);
                                                CloseHandle (pi.hProcess);
                                            }
                                        }
                                        FreeText (tempStr3);
                                    }
                                    FreeText (tempStr2);
                                }
                            }

                            CloseRegKey (tempKey);
                        }
                    }
                    FreePathString (mappedKeyStr);
                    mappedKeyStr = NULL;
                }
            }
        }
    }

    if (terminateIsm) {
        if (!g_Break) {
            pCleanUpApp();
        }
    }

    if (delayedCmd) {
        FreeText (delayedCmd);
        delayedCmd = NULL;
    }
    GbFree (&args.InputInf);
    GbFree (&args.BadInfs);
    GbFree (&args.MultiInfs);

    if (!g_Break) {
        if (g_ReturnCode == RETURN_SUCCESS) {
            PrintMsgOnConsole (MSG_SUCCESS);
        } else if (g_ReturnCode == RETURN_IGNORED_ERROR) {
            if (logEnabled) {
                PrintMsgOnConsole (MSG_IGNORE_FAILED_WITH_LOG);
            } else {
                PrintMsgOnConsole (MSG_IGNORE_FAILED_NO_LOG);
            }
            g_ReturnCode = RETURN_SUCCESS;
        } else {
            if (logEnabled) {
                PrintMsgOnConsole (MSG_FAILED_WITH_LOG);
            } else {
                PrintMsgOnConsole (MSG_FAILED_NO_LOG);
            }
        }
    }

    UtTerminate ();

    while (g_Break) {
        // infinite loop, because we'll get terminated in the ctrl+c handler
        Sleep (50);
    }

    exit (g_ReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loadstate\sources.inc ===
!include ..\..\app.mk

MINORCOMP=loadstate

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\loadstate.c      \
    ..\loadstate.rc     \
    ..\logmsg.mc        \

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\utils.lib        \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \

PRECOMPILED_INCLUDE=..\pch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\loader\utils.c ===
#include "pch.h"
#include "loader.h"

#define MAX_RESOURCE_LENGTH 2048
#define MIGWIZSUBDIR TEXT("usmt\\")

#define MINIMUM_DISK_SPACE 3000000

// Globals
static PTSTR g_lpszDestPath = NULL;
static PTSTR g_lpszModulePath = NULL;


PTSTR
GetModulePath( VOID )
{
    if (g_lpszModulePath == NULL)
    {
        TCHAR lpszPath[MAX_PATH + 1];
        DWORD dwResult;

        // Build the path where this exe resides
        dwResult = GetModuleFileName( NULL, lpszPath, MAX_PATH );
        if (dwResult > 0 &&
            dwResult < MAX_PATH)
        {
            LPTSTR ptr;
            TCHAR *lastWack = NULL;

            ptr = lpszPath;

            while (*ptr)
            {
                if (*ptr == TEXT('\\'))
                {
                    lastWack = ptr;
                }
                ptr = CharNext( ptr );
            }

            if (lastWack)
            {
                *(lastWack + 1) = 0;
                g_lpszModulePath = (PTSTR)ALLOC( (lstrlen(lpszPath) + 1) * sizeof(TCHAR) );
                if (g_lpszModulePath)
                {
                    lstrcpy( g_lpszModulePath, lpszPath );
                }
            }
        }
    }

    return g_lpszModulePath;
}

DWORD
pConvertDriveToBit (
    PCTSTR driveString
    )
{
    DWORD bit = 0;
    TCHAR driveLetter;

    if (driveString && *driveString) {
        driveLetter = (TCHAR)_totlower (*driveString);
        if (driveLetter >= TEXT('a') && driveLetter <= TEXT('z')) {
            bit = 0x1 << (driveLetter - TEXT('a'));
        }
    }
    return bit;
}

BOOL
pCreateMigwizDir( PCTSTR lpszPath )
{
    BOOL fResult = FALSE;

    if (g_lpszDestPath != NULL)
    {
        FREE( g_lpszDestPath );
    }

    g_lpszDestPath = (PTSTR)ALLOC( (lstrlen(lpszPath) + lstrlen(MIGWIZSUBDIR) + 1) * sizeof(TCHAR) );
    if (g_lpszDestPath)
    {
        lstrcpy( g_lpszDestPath, lpszPath );
        lstrcat( g_lpszDestPath, MIGWIZSUBDIR );

        if (!CreateDirectory( g_lpszDestPath, NULL ))
        {
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                FREE( g_lpszDestPath );
                g_lpszDestPath = NULL;
                return FALSE;
            }
        }
        fResult = TRUE;
    }

    return fResult;
}

PTSTR
GetDestPath( VOID )
{
    DWORD sectPerClust;
    DWORD bytesPerSect;
    DWORD freeClusters;
    DWORD totalClusters;
    ULONGLONG maxFreeDiskSpace = 0;
    ULONGLONG freeDiskSpace = 0;
    TCHAR szPath[MAX_PATH + 1];
    PTSTR lpDriveList = NULL;
    PCTSTR lpDrive;
    DWORD dwListLen;


    if (g_lpszDestPath == NULL)
    {
        // If %TEMP% has enough space, use it
        if (GetTempPath( MAX_PATH, szPath ))
        {
            TCHAR szTmpPath[4] = TEXT("?:\\");

            szTmpPath[0] = szPath[0];
            if (GetDiskFreeSpace( szTmpPath, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters ))
            {
                freeDiskSpace = Int32x32To64( (sectPerClust * bytesPerSect), freeClusters );
                if (freeDiskSpace > MINIMUM_DISK_SPACE)
                {
                    if (pCreateMigwizDir(szPath))
                    {
                        return g_lpszDestPath;
                    }
                }
            }
        }

        // Otherwise use the first drive with the enough space
        dwListLen = GetLogicalDriveStrings( 0, NULL ) + 1;
        lpDriveList = (PTSTR)ALLOC( dwListLen );
        GetLogicalDriveStrings( dwListLen, lpDriveList );
        lpDrive = lpDriveList;

        while (*lpDrive) {
            if (GetDriveType( lpDrive ) == DRIVE_FIXED)
            {
                if (GetDiskFreeSpace( lpDrive, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters ))
                {
                    freeDiskSpace = Int32x32To64( (sectPerClust * bytesPerSect), freeClusters );
                    if (freeDiskSpace > MINIMUM_DISK_SPACE)
                    {
                        if (pCreateMigwizDir( lpDrive ))
                        {
                            // We have a winner! Let's bail.
                            break;
                        }
                    }
                }
            }
            // Advance to the next drive in the drive list
            lpDrive = _tcschr( lpDrive, 0 ) + 1;
        }
        FREE(lpDriveList);
    }

    return g_lpszDestPath;
}

PTSTR
JoinText( PTSTR lpStr1, PTSTR lpStr2, TCHAR chSeparator )
{
    PTSTR lpResult;
    DWORD dwSize1;
    DWORD dwSize2;
    DWORD dwSize;
    BOOL fAddSep = TRUE;

    dwSize1 = lstrlen(lpStr1);
    if (lpStr1[dwSize1 - 1] == chSeparator)
    {
        fAddSep = FALSE;
    }

    dwSize2 = lstrlen(lpStr2);
    if (lpStr2[0] == chSeparator)
    {
        fAddSep = FALSE;
    }

    dwSize = dwSize1 + dwSize2 + (fAddSep ? 1 : 0);

    lpResult = (PTSTR)ALLOC((dwSize+1) * sizeof(TCHAR));
    if (lpResult)
    {
        lstrcpy( lpResult, lpStr1 );
        if (fAddSep)
        {
            lpResult[dwSize1] = chSeparator;
            dwSize1 += 1;
        }
        lstrcpy( lpResult+dwSize1, lpStr2 );
    }

    return lpResult;
}

PTSTR
GetResourceString( HINSTANCE hInstance, DWORD dwResID )
{
    TCHAR szTmpString[MAX_RESOURCE_LENGTH];
    DWORD dwStringLength;
    PTSTR lpszResultString = NULL;

    dwStringLength = LoadString( hInstance,
                                 dwResID,
                                 szTmpString,
                                 MAX_RESOURCE_LENGTH );
    if (dwStringLength > 0)
    {
        lpszResultString = (PTSTR)ALLOC( (dwStringLength+1) * sizeof(TCHAR) );
        if (lpszResultString)
        {
            lstrcpy( lpszResultString, szTmpString );
        }
    }

    return lpszResultString;
}

PSTR
GetResourceStringA( HINSTANCE hInstance, DWORD dwResID )
{
    CHAR szTmpString[MAX_RESOURCE_LENGTH];
    DWORD dwStringLength;
    PSTR lpszResultString = NULL;

    dwStringLength = LoadStringA( hInstance,
                                  dwResID,
                                  szTmpString,
                                  MAX_RESOURCE_LENGTH );
    if (dwStringLength > 0)
    {
        lpszResultString = (PSTR)ALLOC( (dwStringLength+1) * sizeof(CHAR) );
        if (lpszResultString)
        {
            lstrcpyA( lpszResultString, szTmpString );
        }
    }

    return lpszResultString;
}

PWSTR
GetResourceStringW( HINSTANCE hInstance, DWORD dwResID )
{
    WCHAR szTmpString[MAX_RESOURCE_LENGTH];
    DWORD dwStringLength;
    PWSTR lpszResultString = NULL;

    dwStringLength = LoadStringW( hInstance,
                                  dwResID,
                                  szTmpString,
                                  MAX_RESOURCE_LENGTH );
    if (dwStringLength > 0)
    {
        lpszResultString = (PWSTR)ALLOC( (dwStringLength+1) * sizeof(WCHAR) );
        if (lpszResultString)
        {
            lstrcpyW( lpszResultString, szTmpString );
        }
    }

    return lpszResultString;
}

VOID
UtilFree( VOID )
{
    if (g_lpszDestPath)
    {
        FREE( g_lpszDestPath );
        g_lpszDestPath = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

#include <ocidl.h>

#define ATOMICRELEASE(p)   \
   {                       \
      IUnknown *pFoo = (IUnknown *)p;  \
      p = NULL;            \
      if (pFoo)            \
         pFoo->Release();  \
   }

class CObjectWithSite : public IObjectWithSite
{
public:
    CObjectWithSite()  {_punkSite = NULL;};
    virtual ~CObjectWithSite() {ATOMICRELEASE(_punkSite);}

    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

protected:
    IUnknown*   _punkSite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\cowsite.cpp ===
#include <objbase.h>
#pragma hdrstop

#include "cowsite.h"

void IUnknown_Set(IUnknown ** ppunk, IUnknown * punk)
{
    if (*ppunk)
        (*ppunk)->Release();

    *ppunk = punk;
    if (punk)
        punk->AddRef();
}

HRESULT CObjectWithSite::SetSite(IUnknown *punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}

HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\container.h ===
//////////////////////////////////////////////////////////////////////////
//
//  container.h
//
//      This file contains the complete class specification of an ActiveX
//      control container. This purpose of this container is to test
//      a single control being hosted.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#ifndef _CONTAINER_H_
#define _CONTAINER_H_

#include <ocidl.h>

class Container : public IOleClientSite, 
                  public IOleInPlaceSite,
                  public IOleInPlaceFrame,
                  public IOleControlSite,
                  public IDispatch
{
    private:
        ULONG       m_cRefs;        // ref count
        HWND        m_hwnd;         // window handle of the container
        HWND        m_hwndStatus;   // status window handle
        IUnknown    *m_punk;        // IUnknown of contained object
        RECT        m_rect;         // size of control

    public:
        Container();
        ~Container();

    public:
        // *** IUnknown Methods ***
        STDMETHOD(QueryInterface)(REFIID riid, PVOID *ppvObject);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // *** IOleClientSite Methods ***
        STDMETHOD (SaveObject)();
        STDMETHOD (GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppMk);
        STDMETHOD (GetContainer)(LPOLECONTAINER *ppContainer);
        STDMETHOD (ShowObject)();
        STDMETHOD (OnShowWindow)(BOOL fShow);
        STDMETHOD (RequestNewObjectLayout)();

        // *** IOleWindow Methods ***
        STDMETHOD (GetWindow) (HWND * phwnd);
        STDMETHOD (ContextSensitiveHelp) (BOOL fEnterMode);

        // *** IOleInPlaceSite Methods ***
        STDMETHOD (CanInPlaceActivate) (void);
        STDMETHOD (OnInPlaceActivate) (void);
        STDMETHOD (OnUIActivate) (void);
        STDMETHOD (GetWindowContext) (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
        STDMETHOD (Scroll) (SIZE scrollExtent);
        STDMETHOD (OnUIDeactivate) (BOOL fUndoable);
        STDMETHOD (OnInPlaceDeactivate) (void);
        STDMETHOD (DiscardUndoState) (void);
        STDMETHOD (DeactivateAndUndo) (void);
        STDMETHOD (OnPosRectChange) (LPCRECT lprcPosRect);

        // *** IOleInPlaceUIWindow Methods ***
        STDMETHOD (GetBorder)(LPRECT lprectBorder);
        STDMETHOD (RequestBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
        STDMETHOD (SetBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
        STDMETHOD (SetActiveObject)(IOleInPlaceActiveObject * pActiveObject,
                                    LPCOLESTR lpszObjName);

        // *** IOleInPlaceFrame Methods ***
        STDMETHOD (InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
        STDMETHOD (SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
        STDMETHOD (RemoveMenus)(HMENU hmenuShared);
        STDMETHOD (SetStatusText)(LPCOLESTR pszStatusText);
        STDMETHOD (EnableModeless)(BOOL fEnable);
        STDMETHOD (TranslateAccelerator)(LPMSG lpmsg, WORD wID);

        // *** IOleControlSite Methods ***
        STDMETHOD (OnControlInfoChanged)(void);
        STDMETHOD (LockInPlaceActive)(BOOL fLock);
        STDMETHOD (GetExtendedControl)(IDispatch **ppDisp);
        STDMETHOD (TransformCoords)(POINTL *pptlHimetric, POINTF *pptfContainer, DWORD dwFlags);
        STDMETHOD (TranslateAccelerator)(LPMSG pMsg, DWORD grfModifiers);
        STDMETHOD (OnFocus)(BOOL fGotFocus);
        STDMETHOD (ShowPropertyFrame)(void);

        // *** IDispatch Methods ***
        STDMETHOD (GetIDsOfNames)(REFIID riid, OLECHAR FAR* FAR* rgszNames,	unsigned int cNames, LCID lcid,	DISPID FAR* rgdispid);
        STDMETHOD (GetTypeInfo)(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
        STDMETHOD (GetTypeInfoCount)(unsigned int FAR * pctinfo);
        STDMETHOD (Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR *pdispparams, VARIANT FAR *pvarResult, EXCEPINFO FAR * pexecinfo, unsigned int FAR *puArgErr);

    public:
        void add(BSTR clsid);
        void remove();
        void setParent(HWND hwndParent);
        void setLocation(int x, int y, int width, int height);
        void setVisible(BOOL fVisible);
        void setFocus(BOOL fFocus);
        void setStatusWindow(HWND hwndStatus);
        void translateKey(MSG msg);
        IDispatch *getDispatch();
        IUnknown * getUnknown();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\dll.cpp ===
//
// dll.cpp
//
#include <iostream.h>
#include <objbase.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobj.h>

#include "cowsite.h"

#include "Iface.h"      // Interface declarations
#include "Registry.h"   // Registry helper functions
#include "migutil.h"
#include "migeng.h"
#include "migfact.h"
#include "migtask.h"
#include "migoobe.h"

///////////////////////////////////////////////////////////
//
// Global variables
//
HMODULE g_hModule = NULL;   // DLL module handle
static long g_cComponents = 0;     // Count of active components

// Friendly name of component
const char g_szFriendlyName[] = "Migration Wizard Engine";

// Version-independent ProgID
const char g_szVerIndProgID[] = "MigWiz";

// ProgID
const char g_szProgID[] = "MigWiz.1";

///////////////////////////////////////////////////////////
//
// Exported functions
//

STDAPI DllAddRef()
{
    InterlockedIncrement(&g_cComponents);
    return S_OK;
}

STDAPI DllRelease()
{
    InterlockedDecrement(&g_cComponents);
    return S_OK;
}

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if (g_cComponents == 0)
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    HRESULT hres;

    DllAddRef();
    if (IsEqualIID(clsid, CLSID_MigWizEngine))
    {
        hres = CMigFactory_Create(clsid, iid, ppv);
    }
    else
    {
        *ppv = NULL;
        hres = CLASS_E_CLASSNOTAVAILABLE;
    }

    DllRelease();
    return hres;
}

//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_MigWizEngine,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_MigWizEngine,
                            g_szVerIndProgID,
                            g_szProgID);
}


///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule;
        DisableThreadLibraryCalls((HMODULE)hModule);       // PERF: makes faster because we don't get thread msgs
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\container.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  container.cpp
//
//      This file contains the complete implementation of an ActiveX
//      control container. This purpose of this container is to test
//      a single control being hosted.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>
#include "container.h"

/**
 *  This method is the constructor for the Container object. 
 */
Container::Container()
{
    m_cRefs     = 1;
    m_hwnd      = NULL;
    m_punk      = NULL;

    memset(&m_rect, 0, sizeof(m_rect));
}

/** 
 *  This method is the destructor for the Container object.
 */
Container::~Container()
{
    if (m_punk)
    {
        m_punk->Release();
        m_punk=NULL;
    }
}

/**
 *  This method is called when the caller wants an interface pointer.
 *
 *  @param      riid        The interface being requested.
 *  @param      ppvObject   The resultant object pointer.
 *
 *  @return     HRESULT     S_OK, E_POINTER, E_NOINTERFACE
 */
STDMETHODIMP Container::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    if (!ppvObject)
        return E_POINTER;

    if (IsEqualIID(riid, IID_IOleClientSite))
        *ppvObject = (IOleClientSite *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *ppvObject = (IOleInPlaceSite *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceFrame))
        *ppvObject = (IOleInPlaceFrame *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        *ppvObject = (IOleInPlaceUIWindow *)this;
    else if (IsEqualIID(riid, IID_IOleControlSite))
        *ppvObject = (IOleControlSite *)this;
    else if (IsEqualIID(riid, IID_IOleWindow))
        *ppvObject = this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *ppvObject = (IDispatch *)this;
    else if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = this;
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

/**
 *  This method increments the current object count.
 *
 *  @return     ULONG       The new reference count.
 */
ULONG Container::AddRef(void)
{
    return ++m_cRefs;
}

/**
 *  This method decrements the object count and deletes if necessary.
 *
 *  @return     ULONG       Remaining ref count.
 */
ULONG Container::Release(void)
{
    if (--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

// ***********************************************************************
//  IOleClientSite
// ***********************************************************************

HRESULT Container::SaveObject()
{
    return E_NOTIMPL;
}

HRESULT Container::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppMk)
{
    return E_NOTIMPL;
}

HRESULT Container::GetContainer(LPOLECONTAINER * ppContainer)
{
    return E_NOINTERFACE;
}

HRESULT Container::ShowObject()
{
    return S_OK;
}

HRESULT Container::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

HRESULT Container::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleWindow
// ***********************************************************************

HRESULT Container::GetWindow(HWND * lphwnd)
{
    if (!IsWindow(m_hwnd))
        return S_FALSE;

    *lphwnd = m_hwnd;
    return S_OK;
}

HRESULT Container::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleInPlaceSite
// ***********************************************************************

HRESULT Container::CanInPlaceActivate(void)
{
    return S_OK;
}

HRESULT Container::OnInPlaceActivate(void)
{
    return S_OK;
}

HRESULT Container::OnUIActivate(void)
{
    return S_OK;
}

HRESULT Container::GetWindowContext (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppIIPUIWin,
                                  LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    *ppFrame = (IOleInPlaceFrame *)this;
    *ppIIPUIWin = NULL;

    RECT rect;
    GetClientRect(m_hwnd, &rect);
    lprcPosRect->left       = 0;
    lprcPosRect->top        = 0;
    lprcPosRect->right      = rect.right;
    lprcPosRect->bottom     = rect.bottom;

    CopyRect(lprcClipRect, lprcPosRect);

    lpFrameInfo->cb             = sizeof(OLEINPLACEFRAMEINFO);
    lpFrameInfo->fMDIApp        = FALSE;
    lpFrameInfo->hwndFrame      = m_hwnd;
    lpFrameInfo->haccel         = 0;
    lpFrameInfo->cAccelEntries  = 0;

    (*ppFrame)->AddRef();
    return S_OK;
}

HRESULT Container::Scroll(SIZE scrollExtent)
{
    return E_NOTIMPL;
}

HRESULT Container::OnUIDeactivate(BOOL fUndoable)
{
    return E_NOTIMPL;
}

HRESULT Container::OnInPlaceDeactivate(void)
{
    return S_OK;
}

HRESULT Container::DiscardUndoState(void)
{
    return E_NOTIMPL;
}

HRESULT Container::DeactivateAndUndo(void)
{
    return E_NOTIMPL;
}

HRESULT Container::OnPosRectChange(LPCRECT lprcPosRect)
{
    return S_OK;
}

// ***********************************************************************
//  IOleInPlaceUIWindow
// ***********************************************************************

HRESULT Container::GetBorder(LPRECT lprectBorder)
{
    return E_NOTIMPL;
}

HRESULT Container::RequestBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT Container::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT Container::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleInPlaceFrame
// ***********************************************************************

HRESULT Container::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return E_NOTIMPL;
}

HRESULT Container::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return E_NOTIMPL;
}

HRESULT Container::RemoveMenus(HMENU hmenuShared)
{
    return E_NOTIMPL;
}

HRESULT Container::SetStatusText(LPCOLESTR pszStatusText)
{
    char status[MAX_PATH];              // ansi version of status text

    if (NULL == pszStatusText)
        return E_POINTER;

    WideCharToMultiByte(CP_ACP, 0, pszStatusText, -1, status, MAX_PATH, NULL, NULL);

    if (IsWindow(m_hwndStatus))
        SendMessage(m_hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)status);

    return (S_OK);
}

HRESULT Container::EnableModeless(BOOL fEnable)
{
    return E_NOTIMPL;
}

HRESULT Container::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    return S_OK;
}

// ***********************************************************************
//  IOleControlSite
// ***********************************************************************

HRESULT Container::OnControlInfoChanged()
{
    return E_NOTIMPL;
}

HRESULT Container::LockInPlaceActive(BOOL fLock)
{
    return E_NOTIMPL;
}

HRESULT Container::GetExtendedControl(IDispatch **ppDisp)
{
    if (ppDisp == NULL)
        return E_INVALIDARG;

    *ppDisp = (IDispatch *)this;
    (*ppDisp)->AddRef();

    return S_OK;
}

HRESULT Container::TransformCoords(POINTL *pptlHimetric, POINTF *pptfContainer, DWORD dwFlags)
{
    return E_NOTIMPL;
}

HRESULT Container::TranslateAccelerator(LPMSG pMsg, DWORD grfModifiers)
{
    return S_FALSE;
}

HRESULT Container::OnFocus(BOOL fGotFocus)
{
    return E_NOTIMPL;
}

HRESULT Container::ShowPropertyFrame(void)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IDispatch
// ***********************************************************************

HRESULT Container::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)
{
    *rgdispid = DISPID_UNKNOWN;
    return DISP_E_UNKNOWNNAME;
}

HRESULT Container::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    return E_NOTIMPL;
}

HRESULT Container::GetTypeInfoCount(unsigned int FAR * pctinfo)
{
    return E_NOTIMPL;
}

HRESULT Container::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR *pdispparams, VARIANT FAR *pvarResult, EXCEPINFO FAR * pexecinfo, unsigned int FAR *puArgErr)
{
    return DISP_E_MEMBERNOTFOUND;
}

// ***********************************************************************
//  Public (non-interface) Methods
// ***********************************************************************

/**
 *  This method will add an ActiveX control to the container. Note, for
 *  now, this container can only have one control.
 *
 *  @param  bstrClsid   The CLSID or PROGID of the control.
 *
 *  @return             No return value.
 */
void Container::add(BSTR bstrClsid)
{
    CLSID   clsid;          // CLSID of the control object
    HRESULT hr;             // return code

    CLSIDFromString(bstrClsid, &clsid);
    CoCreateInstance(clsid, 
                     NULL, 
                     CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                     IID_IUnknown,
                     (PVOID *)&m_punk);

    if (!m_punk)
        return;

    IOleObject *pioo;
    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (FAILED(hr))
        return;

    pioo->SetClientSite(this);
    pioo->Release();

    IPersistStreamInit  *ppsi;
    hr = m_punk->QueryInterface(IID_IPersistStreamInit, (PVOID *)&ppsi);
    if (SUCCEEDED(hr))
    {
        ppsi->InitNew();
        ppsi->Release();
    }
}

/**
 *  This method will remove the control from the container.
 *
 *  @return             No return value.
 */
void Container::remove()
{
    if (!m_punk)
        return;

    HRESULT             hr;
    IOleObject          *pioo;
    IOleInPlaceObject   *pipo;

    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (SUCCEEDED(hr))
    {
        pioo->Close(OLECLOSE_NOSAVE);
        pioo->SetClientSite(NULL);
        pioo->Release();
    }

    hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
    if (SUCCEEDED(hr))
    {
        pipo->UIDeactivate();
        pipo->InPlaceDeactivate();
        pipo->Release();
    }

    m_punk->Release();
    m_punk = NULL;
}

/**
 *  This method sets the parent window. This is used by the container
 *  so the control can parent itself.
 *
 *  @param  hwndParent  The parent window handle.
 *
 *  @return             No return value.
 */
void Container::setParent(HWND hwndParent)
{
    m_hwnd = hwndParent;
}

/**
 *  This method will set the location of the control.
 *  
 *  @param      x       The top left.
 *  @param      y       The top right.
 *  @param      width   The width of the control.
 *  @param      height  The height of the control.
 */
void Container::setLocation(int x, int y, int width, int height)
{
    m_rect.left     = x;
    m_rect.top      = y;
    m_rect.right    = width;
    m_rect.bottom   = height;

    if (!m_punk)
        return;

    HRESULT             hr;
    IOleInPlaceObject   *pipo;

    hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
    if (FAILED(hr))
        return;

    pipo->SetObjectRects(&m_rect, &m_rect);
    pipo->Release();
}

/**
 *  Sets the visible state of the control.
 *
 *  @param  fVisible    TRUE=visible, FALSE=hidden
 *  @return             No return value.
 */
void Container::setVisible(BOOL fVisible)
{
    if (!m_punk)
        return;

    HRESULT     hr;
    IOleObject  *pioo;

    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (FAILED(hr))
        return;
    
    if (fVisible)
    {
        pioo->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
        pioo->DoVerb(OLEIVERB_SHOW, NULL, this, 0, m_hwnd, &m_rect);
    }
    else
        pioo->DoVerb(OLEIVERB_HIDE, NULL, this, 0, m_hwnd, NULL);

    pioo->Release();
}

/**
 *  This sets the focus to the control (a.k.a. UIActivate)
 *
 *  @param  fFocus      TRUE=set, FALSE=remove
 *
 *  @return             No return value.
 */
void Container::setFocus(BOOL fFocus)
{
    if (!m_punk)
        return;

    HRESULT     hr;
    IOleObject  *pioo;

    if (fFocus)
    {
        hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
        if (FAILED(hr))
            return;

        pioo->DoVerb(OLEIVERB_UIACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
        pioo->Release();
    }
}

/**
 *  If the container has an HWND for the status window (must be
 *  common control), then this method is used to tell the container.
 *
 *  @param  hwndStatus  Window handle of the status bar.
 *
 *  @return             No return value.
 */
void Container::setStatusWindow(HWND hwndStatus)
{
    m_hwndStatus = hwndStatus;
}

/**
 *  This method gives the control the opportunity to translate and use
 *  key strokes.
 *
 *  @param      msg     Key message.
 *
 *  @return             No return value.
 */
void Container::translateKey(MSG msg)
{
    if (!m_punk)
        return;

    HRESULT                 hr;
    IOleInPlaceActiveObject *pao;

    hr = m_punk->QueryInterface(IID_IOleInPlaceActiveObject, (PVOID *)&pao);
    if (FAILED(hr))
        return;

    pao->TranslateAccelerator(&msg);
    pao->Release();
}

/**
 *  Returns the IDispatch pointer of the contained control. Note, the
 *  caller is responsible for calling IDispatch::Release().
 *
 *  @return             Controls dispatch interface.
 */
IDispatch * Container::getDispatch()
{
    if (!m_punk)
        return NULL;

    HRESULT     hr;
    IDispatch   *pdisp;

    hr = m_punk->QueryInterface(IID_IDispatch, (PVOID *)&pdisp);
    return pdisp;
}

/**
 *  Returns the IUnknown interface pointer for the containd control. Note,
 *  the caller is responsible for calling IUnknown::Release().
 *
 *  @return             Controls unknown interface.
 */
IUnknown * Container::getUnknown()
{
    if (!m_punk)
        return NULL;

    m_punk->AddRef();
    return m_punk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\iface.h ===
//
// Iface.h - 
//    Declarations of interfaces, IIDs, and CLSID
//    shared by the client and the component.
//
//
// Declaration of GUIDs for interfaces and component.
//   These constants are defined in GUIDs.cpp.
//
extern "C" const CLSID CLSID_MigWizEngine ;

const DISPID_GETREMOVECOUNT =       1001;
const DISPID_GETREMOVEDRIVE =       1002;
const DISPID_GETREMOVEDRIVEPRETTY = 1003;
const DISPID_CREATETOOLDISK =       1004;
const DISPID_CANCELTOOLDISK =       1005;
const DISPID_APPLYSETTINGS  =       1006;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migeng.h ===
#ifndef MIGENG_H
#define MIGENG_H

#include "migwiz.h"
#include "shlwapi.h"
#include "setupapi.h"

// Engine
#include "ism.h"

#include "modules.h"
#include "trans.h"

HRESULT Engine_Initialize (PCTSTR ptszInfPath, BOOL fSource, BOOL fNetworkSupport, LPTSTR pszUsername,
                           MESSAGECALLBACK pMessageCallback, PBOOL pfNetworkDetected);

HRESULT Engine_AppendScript(BOOL fSource, PCTSTR ptszInfPath);

HRESULT Engine_StartTransport (BOOL fSource, LPTSTR pszPath, PBOOL ImageIsValid, PBOOL ImageExists);

HRESULT Engine_Parse ();

HRESULT Engine_SelectComponentSet (UINT uSelectionGroup);

HRESULT Engine_RegisterProgressBarCallback(PROGRESSBARFN pProgressCallback, ULONG_PTR pArg);

HRESULT Engine_Execute(BOOL fSource);

HRESULT Engine_Cancel();

HRESULT Engine_Terminate ();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\guids.cpp ===
//
// GUIDs.cpp
//   - Defines all IIDs and CLSIDs for the client and the component.
//     The declaration of these GUIDs is in Iface.h
//
#include <objbase.h>

// {E7562536-2D53-4f63-A749-84F7D4FC93E8}
extern "C" const CLSID CLSID_MigWizEngine = 
{ 0xe7562536, 0x2d53, 0x4f63, { 0xa7, 0x49, 0x84, 0xf7, 0xd4, 0xfc, 0x93, 0xe8 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migeng.cpp ===
#include "migeng.h"
#include "migutil.h"
#include "miginf.h"

extern "C" {
    #include "log.h"
}


// Globals
HINF g_GlobalScriptHandle = INVALID_HANDLE_VALUE;
TCHAR g_HTMLLog[MAX_PATH] = TEXT("");
TCHAR g_HTMLAppList[MAX_PATH] = TEXT("");

extern MigrationWizard* g_migwiz;

HRESULT _Engine_UploadVars (MIG_PLATFORMTYPEID idPlatform)
{
    HRESULT hr = S_OK;

    PCTSTR envVars = NULL;
    PCTSTR envString;
    PTSTR envStringCopy;
    PTSTR p;

    envVars = (PCTSTR) GetEnvironmentStrings();

    if (envVars) {

        envString = envVars;

        while (*envString)
        {
            p = _tcschr (envString, 0);

            if (p)
            {
                envStringCopy = (PTSTR) IsmGetMemory (((UINT)(p - envString + 1)) * sizeof (TCHAR));

                _tcscpy (envStringCopy, envString);

                p = _tcschr (envStringCopy, TEXT('='));

                //
                // Get rid of empty environment strings or the dummy env string starting
                // with '='
                //
                if (p && p != envStringCopy)
                {
                    *p = 0;
                    p = _tcsinc (p);

                    if (p) {
                        IsmSetEnvironmentString (idPlatform, S_SYSENVVAR_GROUP, envStringCopy, p);
                    }
                }
                IsmReleaseMemory (envStringCopy);
            }
            envString = _tcschr (envString, 0);
            envString ++;
        }
    }

    return hr;
}

BOOL
pGetCurrentUser (
    OUT     PCTSTR *UserName,
    OUT     PCTSTR *UserDomain
    )
{
    HANDLE token;
    PTOKEN_USER tokenUser = NULL;
    SID_NAME_USE dontCare;
    DWORD bytesRequired;
    TCHAR userName[256];
    DWORD nameSize;
    TCHAR userDomain[256];
    DWORD domainSize;

    //
    // Open the process token.
    //
    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
        return FALSE;
    }

    bytesRequired = 0;
    if (GetTokenInformation (token, TokenUser, NULL, 0, &bytesRequired)) {
        return FALSE;
    }

    if (GetLastError () != ERROR_INSUFFICIENT_BUFFER) {
        return FALSE;
    }

    tokenUser = (PTOKEN_USER) IsmGetMemory (bytesRequired);

    if (!GetTokenInformation (token, TokenUser, tokenUser, bytesRequired, &bytesRequired)) {
        IsmReleaseMemory (tokenUser);
        return FALSE;
    }

    nameSize = ARRAYSIZE (userName);
    domainSize = ARRAYSIZE (userDomain);

    ZeroMemory (userName, nameSize);
    ZeroMemory (userDomain, domainSize);

    LookupAccountSid (
        NULL,
        tokenUser->User.Sid,
        userName,
        &nameSize,
        userDomain,
        &domainSize,
        &dontCare
        );

    if (UserName) {
        *UserName = IsmDuplicateString (userName);
    }

    if (UserDomain) {
        *UserDomain = IsmDuplicateString (userDomain);
    }

    if (tokenUser) {
        IsmReleaseMemory (tokenUser);
        tokenUser = NULL;
    }

    return TRUE;
}

BOOL
pIsUserAdmin (
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a member of the
    Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS expected to be
    able to open their own process and process token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE token;
    DWORD bytesRequired;
    PTOKEN_GROUPS groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PSID administratorsGroup;

    //
    // Open the process token.
    //
    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &token)) {
        return FALSE;
    }

    b = FALSE;
    groups = NULL;

    //
    // Get group information.
    //
    if (!GetTokenInformation (token, TokenGroups, NULL, 0, &bytesRequired) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER
         ) {

        groups = (PTOKEN_GROUPS) HeapAlloc (GetProcessHeap (), 0, bytesRequired);
        if (!groups) {
            return FALSE;
        }
        b = GetTokenInformation (token, TokenGroups, groups, bytesRequired, &bytesRequired);
    }

    if (b) {

        b = AllocateAndInitializeSid (
                &ntAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &administratorsGroup
                );

        if (b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for (i = 0 ; i < groups->GroupCount ; i++) {
                if (EqualSid (groups->Groups[i].Sid, administratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid (administratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if (groups) {
        HeapFree (GetProcessHeap (), 0, groups);
    }

    CloseHandle (token);

    return b;
}

typedef BOOL (WINAPI GETDISKFREESPACEEX)(
                        LPCTSTR lpDirectoryName,
                        PULARGE_INTEGER lpFreeBytesAvailable,
                        PULARGE_INTEGER lpTotalNumberOfBytes,
                        PULARGE_INTEGER lpTotalNumberOfFreeBytes
                        );
typedef GETDISKFREESPACEEX *PGETDISKFREESPACEEX;

BOOL
pMightHaveDiskSpaceProblem (
    VOID
    )
{
    TCHAR tempStorage[MAX_PATH];
    PTSTR tempPtr = NULL;
    ULARGE_INTEGER thisMediaMaxSize;
    ULARGE_INTEGER dummy1, dummy2;
    PGETDISKFREESPACEEX pGetDiskFreeSpaceEx;
    DWORD sectPerClust;
    DWORD bytesPerSect;
    DWORD freeClusters;
    DWORD totalClusters;

    if (IsmGetTempStorage (tempStorage, ARRAYSIZE(tempStorage))) {

        if (tempStorage [0] == TEXT('\\')) {
            // this is a UNC path
            _tcscat (tempStorage, TEXT("\\"));
            tempPtr = _tcschr (tempStorage, TEXT('\\'));
            if (tempPtr) {
                tempPtr = _tcschr (tempStorage, TEXT('\\'));
                if (tempPtr) {
                    tempPtr = _tcschr (tempStorage, TEXT('\\'));
                    if (tempPtr) {
                        tempPtr = _tcschr (tempStorage, TEXT('\\'));
                        if (tempPtr) {
                            tempPtr ++;
                            *tempPtr = 0;
                        }
                    }
                }
            }
        } else {
            // this is a normal path
            tempPtr = _tcschr (tempStorage, TEXT('\\'));
            if (tempPtr) {
                tempPtr ++;
                *tempPtr = 0;
            }
        }

        // Find out if GetDiskFreeSpaceEx is supported
#ifdef UNICODE
        pGetDiskFreeSpaceEx = (PGETDISKFREESPACEEX) GetProcAddress( GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExW");
#else
        pGetDiskFreeSpaceEx = (PGETDISKFREESPACEEX) GetProcAddress( GetModuleHandle (TEXT("kernel32.dll")), "GetDiskFreeSpaceExA");
#endif
        if (pGetDiskFreeSpaceEx) {
            if (!pGetDiskFreeSpaceEx (tempStorage, &dummy1, &dummy2, &thisMediaMaxSize)) {
                return FALSE;
            }
        } else {
            if (GetDiskFreeSpace (tempStorage, &sectPerClust, &bytesPerSect, &freeClusters, &totalClusters)) {
                thisMediaMaxSize.QuadPart = Int32x32To64 ((sectPerClust * bytesPerSect), freeClusters);
            } else {
                DWORD err = GetLastError ();
                return FALSE;
            }
        }

        if ((thisMediaMaxSize.HighPart == 0) &&
            (thisMediaMaxSize.LowPart < 1024 * 1024)
            ) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
pAddExtensions (
    VOID
    )
{
    HKEY rootKey = NULL;
    LONG result;

    // open the root key
    result = RegOpenKeyEx (HKEY_CLASSES_ROOT, TEXT(""), 0, KEY_READ, &rootKey);

    if (result == ERROR_SUCCESS) {

        UINT index = 0;
        TCHAR extName [MAX_PATH + 1];

        // enumerate all subkeys
        while (result == ERROR_SUCCESS) {

            result = RegEnumKey (rootKey, index, extName, MAX_PATH + 1);
            if (result == ERROR_SUCCESS) {

                // see if this is an extension
                if (_tcsnextc (extName) == TEXT('.')) {

                    HKEY subKey = NULL;
                    PCTSTR extNamePtr = NULL;

                    extNamePtr = _tcsinc (extName);

                    if (extNamePtr) {

                        BOOL foundExtension = FALSE;
                        INFCONTEXT context;

                        if (SetupFindFirstLine (g_hMigWizInf, TEXT("EXT.Include"), extNamePtr, &context)) {
                            foundExtension = TRUE;
                        } else if (SetupFindFirstLine (g_hMigWizInf, TEXT("EXT.Exclude"), extNamePtr, &context)) {
                            foundExtension = FALSE;
                        } else {

                            // open it
                            result = RegOpenKeyEx (rootKey, extName, 0, KEY_READ, &subKey);
                            if (result == ERROR_SUCCESS) {

                                TCHAR progIdName [MAX_PATH + 1];
                                DWORD regType;
                                DWORD size = (MAX_PATH + 1) * sizeof (TCHAR);

                                // let's find the ProgId (query the default value)
                                result = RegQueryValueEx (subKey, NULL, NULL, &regType, (PBYTE)progIdName, &size);
                                if ((result == ERROR_SUCCESS) && (regType == REG_SZ)) {

                                    HKEY progIdKey = NULL;

                                    // let's open the prog ID key
                                    result = RegOpenKeyEx (rootKey, progIdName, 0, KEY_READ, &progIdKey);
                                    if (result == ERROR_SUCCESS) {

                                        HKEY shellKey = NULL;

                                        // open the shell subkey
                                        result = RegOpenKeyEx (progIdKey, TEXT("shell"), 0, KEY_READ, &shellKey);
                                        if (result == ERROR_SUCCESS) {

                                            UINT shellIdx = 0;
                                            TCHAR cmdName [MAX_PATH + 1];

                                            // enumerate all subkeys
                                            while (result == ERROR_SUCCESS) {

                                                result = RegEnumKey (shellKey, shellIdx, cmdName, MAX_PATH + 1);
                                                if (result == ERROR_SUCCESS) {

                                                    if ((_tcsicmp (cmdName, TEXT("open")) == 0) ||
                                                        (_tcsicmp (cmdName, TEXT("play")) == 0)
                                                        ) {

                                                        HKEY cmdKey = NULL;

                                                        // open it
                                                        result = RegOpenKeyEx (shellKey, cmdName, 0, KEY_READ, &cmdKey);
                                                        if (result == ERROR_SUCCESS) {

                                                            HKEY actionKey = NULL;

                                                            // open the "command" subkey
                                                            result = RegOpenKeyEx (cmdKey, TEXT("command"), 0, KEY_READ, &actionKey);
                                                            if (result == ERROR_SUCCESS) {

                                                                TCHAR commandLine [MAX_PATH + 1];
                                                                DWORD size = (MAX_PATH + 1) * sizeof (TCHAR);

                                                                // let's find the actual command line (query the default value)
                                                                result = RegQueryValueEx (actionKey, NULL, NULL, &regType, (PBYTE)commandLine, &size);
                                                                if ((result == ERROR_SUCCESS) && ((regType == REG_SZ) || (regType == REG_EXPAND_SZ))) {

                                                                    TCHAR exePath [MAX_PATH + 1];
                                                                    PTSTR exeStart = NULL;
                                                                    PTSTR exeStop = NULL;
                                                                    PTSTR exePtr = NULL;
                                                                    INFCONTEXT context;
                                                                    BOOL doubleCheck = FALSE;

                                                                    // now we have the command line. Let's see if the module that handle this command
                                                                    // is in our IGNORE list
                                                                    if (_tcsnextc (commandLine) == TEXT('\"')) {
                                                                        exeStart = _tcsinc (commandLine);
                                                                        if (exeStart) {
                                                                            exeStop = _tcschr (exeStart, TEXT('\"'));
                                                                        }
                                                                    } else {
                                                                        doubleCheck = TRUE;
                                                                        exeStart = commandLine;
                                                                        exeStop = _tcschr (exeStart, TEXT(' '));
                                                                        if (!exeStop) {
                                                                            exeStop = _tcschr (exeStart, 0);
                                                                        }
                                                                    }

                                                                    if (exeStart && exeStop) {
                                                                        CopyMemory (exePath, exeStart, (exeStop - exeStart) * sizeof (TCHAR));
                                                                        exePath [exeStop - exeStart] = 0;

                                                                        exePtr = _tcsrchr (exePath, TEXT('\\'));
                                                                        if (exePtr) {
                                                                            exePtr = _tcsinc (exePtr);
                                                                        }

                                                                        if (exePtr && !SetupFindFirstLine (g_hMigWizInf, TEXT("EXT.IgnoreEXE"), exePtr, &context)) {
                                                                            foundExtension = TRUE;
                                                                        }
                                                                    }
                                                                    if (foundExtension && doubleCheck) {
                                                                        exeStop = NULL;
                                                                        exeStart = _tcsrchr (commandLine, TEXT('\\'));
                                                                        if (exeStart) {
                                                                            exeStart = _tcsinc (exeStart);
                                                                            if (exeStart) {
                                                                                exeStop = _tcschr (exeStart, TEXT(' '));
                                                                                if (!exeStop) {
                                                                                    exeStop = _tcschr (exeStart, 0);
                                                                                }
                                                                            }
                                                                        }
                                                                        if (exeStart && exeStop) {
                                                                            CopyMemory (exePath, exeStart, (exeStop - exeStart) * sizeof (TCHAR));
                                                                            exePath [exeStop - exeStart] = 0;

                                                                            exePtr = _tcsrchr (exePath, TEXT('\\'));
                                                                            if (exePtr) {
                                                                                exePtr = _tcsinc (exePtr);
                                                                            } else {
                                                                                exePtr = exePath;
                                                                            }

                                                                            if (exePtr && SetupFindFirstLine (g_hMigWizInf, TEXT("EXT.IgnoreEXE"), exePtr, &context)) {
                                                                                foundExtension = FALSE;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                RegCloseKey (actionKey);
                                                            }
                                                            RegCloseKey (cmdKey);
                                                        }
                                                    }
                                                    result = ERROR_SUCCESS;
                                                }
                                                shellIdx ++;
                                            }
                                            RegCloseKey (shellKey);
                                        }
                                        RegCloseKey (progIdKey);
                                    }
                                }
                                RegCloseKey (subKey);
                            }
                        }
                        if (foundExtension) {

                            //
                            // Add the component to the engine, unless it already exists
                            //
                            // Check if it is already in the tree
                            if (!IsmIsComponentSelected (extName + 1, COMPONENT_EXTENSION)) {

                                // Not in the tree; select it if it exists as a component
                                if (!IsmSelectComponent (extName + 1, COMPONENT_EXTENSION, TRUE)) {

                                    // Not a component; add the component
                                    IsmAddComponentAlias (
                                        NULL,
                                        MASTERGROUP_FILES_AND_FOLDERS,
                                        extName + 1,
                                        COMPONENT_EXTENSION,
                                        FALSE
                                        );
                                }
                            }
                        }
                    }
                }
                result = ERROR_SUCCESS;
            }
            index ++;
        }
        RegCloseKey (rootKey);
    }
    return TRUE;
}

HRESULT Engine_Initialize (PCTSTR ptszInfPath,
                           BOOL   fSource,
                           BOOL   fNetworkSupport,
                           LPTSTR pszUsername,
                           PMESSAGECALLBACK pMessageCallback,
                           PBOOL  pfNetworkDetected)
{
    static HRESULT hr = E_FAIL;
    static BOOL fDidThis = FALSE;
    ERRUSER_EXTRADATA errExtraData;
    PTSTR iconLibRoot = NULL;
    TCHAR iconLibSrc[MAX_PATH] = TEXT("");
    TCHAR iconLibDest[MAX_PATH] = TEXT("");
    HANDLE iconLibHandle = INVALID_HANDLE_VALUE;
    BOOL iconLibFound = FALSE;
    DWORD err;
    PCTSTR userName = NULL;
    PCTSTR userDomain = NULL;
    PCTSTR currUserName = NULL;
    PCTSTR currUserDomain = NULL;
    ROLLBACK_USER_ERROR rollbackError;

    if (fDidThis) {
        return hr;
    }

    __try
    {
        TCHAR szLogPath[MAX_PATH];
        TCHAR szFullLogFile[MAX_PATH];
        DWORD dwLength;
        HRESULT hResult;
        PTSTR pszAppData;

        fDidThis = TRUE;

        LogDeleteOnNextInit();

        pszAppData = GetShellFolderPath (CSIDL_LOCAL_APPDATA, TEXT("LocalAppData"), FALSE, NULL);
        if (pszAppData) {
            wsprintf (szFullLogFile, TEXT("%s\\FASTWiz.log"), pszAppData);
            LogReInit (NULL, NULL, szFullLogFile, NULL );
            wsprintf (g_HTMLLog, TEXT("%s\\FASTWiz.html"), pszAppData);
            wsprintf (g_HTMLAppList, TEXT("%s\\FASTApp.html"), pszAppData);
            LocalFree (pszAppData);
        } else {
            dwLength = GetEnvironmentVariable (TEXT("USERPROFILE"), szLogPath, ARRAYSIZE(szLogPath));
            if (dwLength > 0 && dwLength < (MAX_PATH - 13) )
            {
                wsprintf (szFullLogFile, TEXT("%s\\FASTWiz.log"), szLogPath);
                LogReInit (NULL, NULL, szFullLogFile, NULL );
                wsprintf (g_HTMLLog, TEXT("%s\\FASTWiz.html"), szLogPath);
                wsprintf (g_HTMLAppList, TEXT("%s\\FASTApp.html"), szLogPath);
            }
            else if (g_migwiz->GetWin9X() && GetWindowsDirectory(szLogPath, ARRAYSIZE(szLogPath)))
            {
                wsprintf (szFullLogFile, TEXT("%s\\FASTWiz.log"), szLogPath);
                LogReInit (NULL, NULL, szFullLogFile, NULL);
                wsprintf (g_HTMLLog, TEXT("%s\\FASTWiz.html"), szLogPath);
                wsprintf (g_HTMLAppList, TEXT("%s\\FASTApp.html"), szLogPath);
            }
            else
            {
                LogReInit (NULL, NULL, TEXT("FASTWiz.log"), NULL);
                if (GetCurrentDirectory(ARRAYSIZE(g_HTMLLog), g_HTMLLog))
                {
                    PathAppend(g_HTMLLog, TEXT("FASTWiz.html"));
                    PathAppend(g_HTMLAppList, TEXT("FASTApp.html"));
                }
                else
                {
                    _tcscpy (g_HTMLLog, TEXT("FASTWiz.html"));
                    _tcscpy (g_HTMLAppList, TEXT("FASTApp.html"));
                }
            }
        }

#ifndef DEBUG
        SuppressAllLogPopups (TRUE);
#endif

        if (!IsmInitialize (ptszInfPath, pMessageCallback, NULL))
        {
            __leave;
        }

        hr = _Engine_UploadVars (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION);

        if (!SUCCEEDED(hr))
        {
            __leave;
        }

        hr = E_FAIL;

        if (!IsmSetPlatform (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION))
        {
            __leave;
        }

        if (!fSource)
        {
            // we will try to copy iconlib.dll from our directory into "Common AppData" directory
            // If we don't succeed, we will try to copy it to "Local AppData". If this one does
            // not succeed we will not set the S_ENV_ICONLIB env variable

            iconLibSrc [0] = 0;
            GetSystemDirectory (iconLibSrc, ARRAYSIZE(iconLibSrc));
            _tcscat (iconLibSrc, TEXT("\\usmt\\iconlib.dll"));

            iconLibFound = FALSE;

            iconLibRoot = GetShellFolderPath (CSIDL_COMMON_APPDATA, TEXT("AppData"), FALSE, NULL);
            if (iconLibRoot) {
                __try {
                    _tcscpy (iconLibDest, iconLibRoot);
                    _tcscat (iconLibDest, TEXT("\\Microsoft"));
                    if (!CreateDirectory (iconLibDest, NULL)) {
                        err = GetLastError ();
                        if (err != ERROR_ALREADY_EXISTS) {
                            __leave;
                        }
                    }
                    _tcscat (iconLibDest, TEXT("\\USMT"));
                    if (!CreateDirectory (iconLibDest, NULL)) {
                        err = GetLastError ();
                        if (err != ERROR_ALREADY_EXISTS) {
                            __leave;
                        }
                    }
                    _tcscat (iconLibDest, TEXT("\\iconlib.dll"));
                    if (!CopyFile (iconLibSrc, iconLibDest, TRUE)) {
                        err = GetLastError ();
                        if (err != ERROR_FILE_EXISTS) {
                            __leave;
                        }
                        // we found an iconlib.dll there. The only question now is: can we access it?
                        // Let's try to open the file with write mode.
                        iconLibHandle = CreateFile (
                                            iconLibDest,
                                            GENERIC_READ|GENERIC_WRITE,
                                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                                            NULL,
                                            OPEN_EXISTING,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL
                                            );
                        if (iconLibHandle == INVALID_HANDLE_VALUE) {
                            // something is wrong, we can't access this file
                            err = GetLastError ();
                            __leave;
                        }
                        CloseHandle (iconLibHandle);
                    }
                    iconLibFound = TRUE;
                }
                __finally {
                    LocalFree (iconLibRoot);
                    iconLibRoot = NULL;
                }
            }

            if (!iconLibFound) {
                iconLibRoot = GetShellFolderPath (CSIDL_LOCAL_APPDATA, TEXT("Local AppData"), TRUE, NULL);
                if (iconLibRoot) {
                    __try {
                        _tcscpy (iconLibDest, iconLibRoot);
                        _tcscat (iconLibDest, TEXT("\\Microsoft"));
                        if (!CreateDirectory (iconLibDest, NULL)) {
                            err = GetLastError ();
                            if (err != ERROR_ALREADY_EXISTS) {
                                __leave;
                            }
                        }
                        _tcscat (iconLibDest, TEXT("\\USMT"));
                        if (!CreateDirectory (iconLibDest, NULL)) {
                            err = GetLastError ();
                            if (err != ERROR_ALREADY_EXISTS) {
                                __leave;
                            }
                        }
                        _tcscat (iconLibDest, TEXT("\\iconlib.dll"));
                        if (!CopyFile (iconLibSrc, iconLibDest, TRUE)) {
                            err = GetLastError ();
                            if (err != ERROR_FILE_EXISTS) {
                                __leave;
                            }
                        }
                        iconLibFound = TRUE;
                    }
                    __finally {
                        LocalFree (iconLibRoot);
                        iconLibRoot = NULL;
                    }
                }
            }

            // Set the icon lib data
            if (iconLibFound) {
                IsmSetEnvironmentString (PLATFORM_DESTINATION, NULL, S_ENV_ICONLIB, iconLibDest);
            }
        }

        //
        // Enable HKR migration
        //
        IsmSetEnvironmentFlag (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, S_ENV_HKCU_ON);

        //
        // Enable files migration
        //
        IsmSetEnvironmentFlag (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, S_ENV_ALL_FILES);

        //
        // Start ETM modules
        //
        if (!IsmStartEtmModules ()) {
            __leave;
        }

        // Set up the username
        if (pszUsername)
        {
            IsmSetEnvironmentString (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, pszUsername);
        }

        //
        // Start the transport modules
        //
        if (!IsmStartTransport ()) {
            __leave;
        }

        // If we're network-enabled, start appropriate network stuff
        if (fNetworkSupport)
        {
            // try to detect another machine on network
            MIG_TRANSPORTSTORAGEID transportStorageId = IsmRegisterTransport (S_HOME_NETWORK_TRANSPORT);
            MIG_TRANSPORTID transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, 0);
            if (!transportId)
            {
                // Network is not supported
                fNetworkSupport = FALSE;
            }
            else
            {
                BOOL fNetworkDetected = FALSE;
                if (!IsmSetTransportStorage (
                        fSource ? PLATFORM_SOURCE : PLATFORM_DESTINATION,
                        transportId,
                        transportStorageId,
                        CAPABILITY_AUTOMATED,
                        NULL,
                        NULL,
                        pfNetworkDetected
                        ))
                {
                    // Network is not supported
                    fNetworkSupport = FALSE;
                }
            }
        }

        hr = S_OK;

        if (!fSource) {
            // now let's take care of the rollback if necessary
            __try {
                // get the current user name and domain
                if ((!pGetCurrentUser (&currUserName, &currUserDomain)) ||
                    (!currUserName) ||
                    (!currUserDomain)
                    ) {
                    __leave;
                }

                if (IsmSetRollbackJournalType (TRUE)) {
                    if (IsmDoesRollbackDataExist (&userName, &userDomain, NULL, NULL, NULL)) {
                        if ((StrCmpI (userName, currUserName) == 0) &&
                            (StrCmpI (userDomain, currUserDomain) == 0)
                            ) {
                            // disable cancel, write the UNDO message in the UI
                            DisableCancel ();
                            PostMessageForWizard (WM_USER_ROLLBACK, 0, 0);
                            IsmRollback ();
                            __leave;
                        }
                        if (pIsUserAdmin ()) {
                            // disable cancel, write the UNDO message in the UI
                            DisableCancel ();
                            PostMessageForWizard (WM_USER_ROLLBACK, 0, 0);
                            IsmRollback ();
                            __leave;
                        }
                        // display the message, we can't run
                        rollbackError.UserName = userName;
                        rollbackError.UserDomain = userDomain;
                        IsmSendMessageToApp (ISMMESSAGE_EXECUTE_ROLLBACK, (ULONG_PTR)&rollbackError);
                        IsmPreserveJournal (TRUE);
                        hr = E_FAIL;
                        __leave;
                    }
                }

                if (IsmSetRollbackJournalType (FALSE)) {
                    if (IsmDoesRollbackDataExist (NULL, NULL, NULL, NULL, NULL)) {
                        // disable cancel, write the UNDO message in the UI
                        DisableCancel ();
                        PostMessageForWizard (WM_USER_ROLLBACK, 0, 0);
                        IsmRollback ();
                        __leave;
                    }
                }
            }
            __finally {
                if (currUserName) {
                    IsmReleaseMemory (currUserName);
                    currUserName = NULL;
                }

                if (currUserDomain) {
                    IsmReleaseMemory (currUserDomain);
                    currUserDomain = NULL;
                }

                if (userName) {
                    IsmReleaseMemory (userName);
                    userName = NULL;
                }
                if (userDomain) {
                    IsmReleaseMemory (userDomain);
                    userDomain = NULL;
                }
            }

            // finally let's find a place for the rollback journal
            if (SUCCEEDED(hr)) {
                if ((!IsmSetRollbackJournalType (TRUE)) ||
                    (!IsmCanWriteRollbackJournal ())
                    ) {
                    if ((!IsmSetRollbackJournalType (FALSE)) ||
                        (!IsmCanWriteRollbackJournal ())
                        ) {
                        // log a warning - we can't create a rollback journal
                        // BUGBUG - log the warning
                    }
                }
            }
        }
        if (SUCCEEDED(hr)) {
            if (fSource) {
                pAddExtensions ();
            }
        }
    }
    __finally
    {
        // Empty
    }

    if (FAILED(hr)) {
        if (pMightHaveDiskSpaceProblem ()) {
            errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
        } else {
            errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
        }
        errExtraData.ErrorArea = ERRUSER_AREA_INIT;
        errExtraData.ObjectTypeId = 0;
        errExtraData.ObjectName = NULL;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
        Engine_Terminate();
    }

    return hr;
}

HRESULT Engine_RegisterProgressBarCallback(PROGRESSBARFN pProgressCallback, ULONG_PTR pArg)
{
    static HRESULT hr = E_FAIL;
    if (FAILED(hr)) // only register once
    {
        hr = IsmRegisterProgressBarCallback(pProgressCallback, pArg) ? S_OK : E_FAIL;
    }

    return hr;
}

HRESULT Engine_AppendScript(BOOL fSource, PCTSTR ptszInfPath)
{
    HRESULT hr = E_FAIL;
    ENVENTRY_STRUCT infHandleStruct;

    if (g_GlobalScriptHandle == INVALID_HANDLE_VALUE)
    {
        g_GlobalScriptHandle = SetupOpenInfFile (ptszInfPath, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
        if (g_GlobalScriptHandle != INVALID_HANDLE_VALUE)
        {
            hr = S_OK;
        }
    }
    else
    {
        if (SetupOpenAppendInfFile (ptszInfPath, g_GlobalScriptHandle, NULL))
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        IsmAppendEnvironmentMultiSz (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, S_INF_FILE_MULTISZ, ptszInfPath);
        infHandleStruct.Type = ENVENTRY_BINARY;
        infHandleStruct.EnvBinaryData = (PBYTE)(&g_GlobalScriptHandle);
        infHandleStruct.EnvBinaryDataSize = sizeof (HINF);
        IsmSetEnvironmentValue (fSource?PLATFORM_SOURCE:PLATFORM_DESTINATION, NULL, S_GLOBAL_INF_HANDLE, &infHandleStruct);
    }

    return hr;
}

BOOL _LocalPathIsRoot(LPTSTR pszPath)
{
    return (PathIsRoot(pszPath) ||
            ((2 == lstrlen(pszPath)) &&
             ((pszPath[0] >= TEXT('A') && pszPath[0] <= TEXT('Z')) || (pszPath[0] >= TEXT('a') && pszPath[0] <= TEXT('z'))) &&
             (pszPath[1] == TEXT(':'))));
}

HRESULT Engine_StartTransport (BOOL fSource, LPTSTR pszPath, PBOOL ImageIsValid, PBOOL ImageExists)
{
    ERRUSER_EXTRADATA errExtraData;
    HRESULT hr = E_FAIL;
    MIG_TRANSPORTID         transportId;
    MIG_TRANSPORTSTORAGEID  transportStorageId;
    LPTSTR                  pszStoragePath;
    TCHAR                   szRootPath[4] = TEXT("A:\\");
    PTSTR                   lpExpStore = NULL;
    BOOL                    retryTrans = TRUE;
    BOOL                    tryUncFirst = (!fSource);
    TCHAR                   szSerialStr[] = TEXT("COM");
    TCHAR                   szParallelStr[] = TEXT("LPT");

    if (ImageIsValid) {
        *ImageIsValid = FALSE;
    }
    if (ImageExists) {
        *ImageExists = FALSE;
    }

    __try
    {
        if (pszPath) {

            //
            // Normal transport
            //

            //
            // Pick the specified transport
            //

            lpExpStore = (PTSTR)IsmExpandEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, pszPath, NULL);

            if (!lpExpStore) {
                // BUGBUG - fatal error
                __leave;
            }

            while (retryTrans) {
                if (_IsRemovableOrCDDrive(lpExpStore[0]) && _LocalPathIsRoot(lpExpStore) && (!tryUncFirst))
                {
                    transportStorageId = IsmRegisterTransport (S_REMOVABLE_MEDIA_TRANSPORT);
                    szRootPath[0] = lpExpStore[0];
                    pszStoragePath = szRootPath;
                }
                else if ((_tcsnicmp (pszPath, szSerialStr, (sizeof (szSerialStr) / sizeof (TCHAR)) - 1) == 0) ||
                         (_tcsnicmp (pszPath, szParallelStr, (sizeof (szParallelStr) / sizeof (TCHAR)) - 1) == 0)
                         )
                {
                    transportStorageId = IsmRegisterTransport (S_DIRECT_CABLE_TRANSPORT);
                    pszStoragePath = lpExpStore;
                }
                else
                {
                    transportStorageId = IsmRegisterTransport (S_RELIABLE_STORAGE_TRANSPORT);
                    pszStoragePath = lpExpStore;
                }

                transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, 0);
                if (!transportId)
                {
                    // BUGBUG - fatal error
                    __leave;
                }

                if (!IsmSetTransportStorage (
                        fSource ? PLATFORM_SOURCE : PLATFORM_DESTINATION,
                        transportId,
                        transportStorageId,
                        CAPABILITY_COMPRESSED,
                        pszStoragePath,
                        ImageIsValid,
                        ImageExists
                        ))
                {
                    if (tryUncFirst) {
                        tryUncFirst = FALSE;
                        continue;
                    }
                    // BUGBUG - fatal error
                    __leave;
                }
                if ((!fSource && ImageIsValid && !(*ImageIsValid)) ||
                    (!fSource && ImageExists && !(*ImageExists))
                    ) {
                    if (tryUncFirst) {
                        tryUncFirst = FALSE;
                        continue;
                    }
                }
                retryTrans = FALSE;
            }

            IsmReleaseMemory (lpExpStore);
            lpExpStore = NULL;

        } else {
            // network transport
            transportStorageId = IsmRegisterTransport (S_HOME_NETWORK_TRANSPORT);
            transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, 0);
            if (!transportId)
            {
                // BUGBUG - fatal error
                __leave;
            }
            if (!IsmSetTransportStorage (
                    fSource ? PLATFORM_SOURCE : PLATFORM_DESTINATION,
                    transportId,
                    transportStorageId,
                    CAPABILITY_AUTOMATED,
                    NULL,
                    ImageIsValid,
                    ImageExists
                    ))
            {
                // BUGBUG - fatal error
                __leave;
            }

        }
        hr = S_OK;
    }
    __finally
    {
        if (lpExpStore) {
            IsmReleaseMemory (lpExpStore);
            lpExpStore = NULL;
        }
    }

    if (!SUCCEEDED(hr))
    {
        if (pMightHaveDiskSpaceProblem ()) {
            errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
        } else {
            errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
        }
        errExtraData.ErrorArea = ERRUSER_AREA_SAVE;
        errExtraData.ObjectTypeId = 0;
        errExtraData.ObjectName = NULL;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
    }

    return hr;
}

HRESULT Engine_Parse ()
{
    ERRUSER_EXTRADATA errExtraData;

    //
    // Execute the preparsing
    //
    if (!IsmExecute (EXECUTETYPE_EXECUTESOURCE_PARSING))
    {
        if (pMightHaveDiskSpaceProblem ()) {
            errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
        } else {
            errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
        }
        errExtraData.ErrorArea = ERRUSER_AREA_GATHER;
        errExtraData.ObjectTypeId = 0;
        errExtraData.ObjectName = NULL;
        IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
        return E_FAIL;
    }

    return S_OK;
}

HRESULT Engine_SelectComponentSet (UINT uSelectionGroup)
{
    MIG_COMPONENT_ENUM mce;
    BOOL bSelected;
    BOOL bDefaultSetting;
    BOOL bDefaultFile;
    BOOL bCallIsm;
    TCHAR szComponentToSelect[256];
    UINT uGroupInUi;

    // uSelectionGroup is either
    //   MIGINF_SELECT_OOBE
    //   MIGINF_SELECT_SETTINGS
    //   MIGINF_SELECT_FILES
    //   MIGINF_SELECT_BOTH

    //
    // Enable all components for the type. Use the migwiz.inf to identify components
    // that are part of the single floppy or multi floppy configuration. Remove all
    // customized components.
    //
    // This loop pings the component name (such as RAS) or the alias name (such as DOC)
    // to determine if the component should be selected. It is optimized to stop pinging
    // after the component becomes selected (because a component might have many aliases).
    // We rely on the mce.Instance member, which will always be sequential, and will
    // always be 1 for the first alias of a component.
    //

    IsmRemoveAllUserSuppliedComponents();

    IsmSelectMasterGroup (MASTERGROUP_ALL, FALSE);

    if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALL_ALIASES, 0))
    {

        bSelected = FALSE;

        do {

            bCallIsm = FALSE;

            if (mce.GroupId == COMPONENT_EXTENSION) {
                bSelected = IsComponentEnabled (uSelectionGroup, TEXT("EXTENSIONS"));
                bCallIsm = bSelected;
            } else {
                if (mce.Instance == 1)
                {
                    bSelected = IsComponentEnabled (uSelectionGroup, mce.ComponentString);
                    bCallIsm = bSelected;
                }
                if (!bSelected)
                {
                    bSelected = IsComponentEnabled (uSelectionGroup, mce.LocalizedAlias);
                    bCallIsm = bSelected;
                }
            }
            if (bCallIsm)
            {
                IsmSelectComponent (mce.LocalizedAlias, mce.GroupId, bSelected);
                mce.SkipToNextComponent = TRUE;
            }

        } while (IsmEnumNextComponent (&mce));
    }
    return S_OK;
}

HRESULT Engine_Execute(BOOL fSource)
{
    ERRUSER_EXTRADATA errExtraData;

    HRESULT hr = E_FAIL;

    __try {
        if (fSource)
        {
            //
            // Enumerate the system, gather data and analyze
            //
            if (!IsmExecute (EXECUTETYPE_EXECUTESOURCE))
            {
                if (pMightHaveDiskSpaceProblem ()) {
                    errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
                } else {
                    errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
                }
                errExtraData.ErrorArea = ERRUSER_AREA_GATHER;
                errExtraData.ObjectTypeId = 0;
                errExtraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
                __leave;
            }

            //
            // Finally, save the data
            //
            if (!IsmSave ()) {
                if (pMightHaveDiskSpaceProblem ()) {
                    errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
                } else {
                    errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
                }
                errExtraData.ErrorArea = ERRUSER_AREA_SAVE;
                errExtraData.ObjectTypeId = 0;
                errExtraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
                __leave;
            }

            hr = S_OK;
        }
        else
        {
            //
            // Try and retrieve the data
            //
            if (!IsmLoad ()) {
                if (pMightHaveDiskSpaceProblem ()) {
                    errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
                } else {
                    errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
                }
                errExtraData.ErrorArea = ERRUSER_AREA_LOAD;
                errExtraData.ObjectTypeId = 0;
                errExtraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
                __leave;
            }

            //
            // Apply saved state
            //
            if (!IsmExecute (EXECUTETYPE_EXECUTEDESTINATION)) {
                if (pMightHaveDiskSpaceProblem ()) {
                    errExtraData.Error = ERRUSER_ERROR_DISKSPACE;
                } else {
                    errExtraData.Error = ERRUSER_ERROR_UNKNOWN;
                }
                errExtraData.ErrorArea = ERRUSER_AREA_RESTORE;
                errExtraData.ObjectTypeId = 0;
                errExtraData.ObjectName = NULL;
                IsmSendMessageToApp (MODULEMESSAGE_DISPLAYERROR, (ULONG_PTR)(&errExtraData));
                IsmRollback();
                __leave;
            }

            DisableCancel();

            hr = S_OK;
        }
    }
    __finally {
    }

    return hr;
}

HRESULT Engine_Cancel ()
{
    IsmSetCancel();

    return S_OK;
}

HRESULT Engine_Terminate ()
{
    static BOOL fDidThis = FALSE;

    if (fDidThis) {
        return E_FAIL;
    }

    fDidThis = TRUE;

    IsmTerminate();

    if (g_GlobalScriptHandle != INVALID_HANDLE_VALUE)
    {
        SetupCloseInfFile (g_GlobalScriptHandle);
        g_GlobalScriptHandle = INVALID_HANDLE_VALUE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\main.cpp ===
#include "migwiz.h"
#include "migutil.h"
#include "resource.h"
#include "container.h"
#include <string.h>
#include <tchar.h>

typedef struct _THREADSTARTUPINFO
{
    HWND hWnd;
    HINSTANCE hInstance;
    LPTSTR lpCmdLine;
} THREADSTARTUPINFO, *LPTHREADSTARTUPINFO;

#define WINDOWCLASS TEXT("USMTCobraApp")
#define WINDOWNAME  TEXT("Migwiz")

#define ANOTHERUSER_RESLEN 100

BOOL g_ConfirmedLogOff = FALSE;
BOOL g_ConfirmedReboot = FALSE;
static HANDLE g_hThread = NULL;
static DWORD g_dwThreadId = 0;

Container *g_WebContainer = NULL;

DWORD
WINAPI
MigwizThread(
    IN      LPVOID lpParameter
    )
{
    HRESULT hr;
    TCHAR szAppPath[MAX_PATH] = TEXT("");
    TCHAR* pszAppPathOffset;

    CoInitialize(NULL);
    OleInitialize(NULL);

    GetModuleFileName (NULL, szAppPath, ARRAYSIZE(szAppPath));
    szAppPath [ARRAYSIZE(szAppPath) - 1] = 0;
    pszAppPathOffset = _tcsrchr (szAppPath, TEXT('\\'));
    if (pszAppPathOffset) {
        *pszAppPathOffset = 0;
        SetCurrentDirectory (szAppPath);
    }

    MigrationWizard* pMigWiz = new MigrationWizard();

    if (pMigWiz)
    {
        LPTSTR lpszUsername = NULL;
        LPTSTR lpszCmdLine = ((LPTHREADSTARTUPINFO)lpParameter)->lpCmdLine;

        if (lpszCmdLine && 0 == _tcsncmp (lpszCmdLine, TEXT("/t:"), 3))
        {
            // BUGBUG: need to make this more stable
            lpszUsername = lpszCmdLine + 3;
        }

        hr = pMigWiz->Init(((LPTHREADSTARTUPINFO)lpParameter)->hInstance, lpszUsername);

        if (SUCCEEDED(hr))
        {
            pMigWiz->Execute();
        }

        // ISSUE: leak
        //delete pMigWiz;
    }

    SendMessage (((LPTHREADSTARTUPINFO)lpParameter)->hWnd, WM_USER_THREAD_COMPLETE, NULL, NULL);

    OleUninitialize();
    CoUninitialize();

    return 0;
}

BOOL
CALLBACK
_SetMigwizActive(
    IN      HWND hWnd,
    IN      LPARAM lParam
    )
{
    SetForegroundWindow( hWnd );
    return FALSE;
}

LRESULT CALLBACK WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch (message)
    {
    case WM_ACTIVATE:
        if (g_hThread != NULL && g_dwThreadId != 0)
        {
            EnumThreadWindows( g_dwThreadId, _SetMigwizActive, (LPARAM)NULL );
        }
        break;
    case WM_USER_THREAD_COMPLETE:
        CloseHandle( g_hThread );
        PostQuitMessage( 0 );
        break;
    default:
        return DefWindowProc( hWnd, message, wParam, lParam );
    }
    return 0;
}

LRESULT CALLBACK WebHostProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch (message)
    {
        case WM_SETFOCUS:
            if (g_WebContainer) {
                g_WebContainer->setFocus(TRUE);
                return 0;
            }
            break;
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

INT
WINAPI
WinMain(
    IN      HINSTANCE    hInstance,
    IN      HINSTANCE    hPrevInstance,
    IN      LPSTR        lpszCmdLine,
    IN      INT          nCmdShow)
{
    WNDCLASSEX wcx;
    MSG msg;
    HANDLE hMutex = NULL;
    OSVERSIONINFO vi;

    HWND hwnd;
    DWORD dwResult = 0;
    THREADSTARTUPINFO StartInfo;

    PSID pSid = NULL;

    PTSTR commandLine = NULL;

#ifdef UNICODE
    commandLine = _ConvertToUnicode (CP_ACP, lpszCmdLine);
#else
    commandLine = lpszCmdLine;
#endif

    hwnd = FindWindow (WINDOWCLASS, WINDOWNAME);
    if (hwnd)
    {
        SetForegroundWindow (hwnd);
        goto END;
    }

    CoInitialize(NULL);
    OleInitialize(NULL);

    vi.dwOSVersionInfoSize = sizeof (vi);

    if (GetVersionEx (&vi) &&
        vi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        vi.dwMajorVersion > 4)
    {
        hMutex = CreateMutex (NULL, TRUE, TEXT("Global\\migwiz.mutex"));
    }
    else
    {
        hMutex = CreateMutex (NULL, TRUE, TEXT("migwiz.mutex"));
    }

    if ((hMutex && GetLastError() == ERROR_ALREADY_EXISTS) ||
        (!hMutex && GetLastError() == ERROR_ACCESS_DENIED))
    {
        TCHAR szTmpBuf[512];
        PVOID lpBuf = NULL;
        LPTSTR lpUsername = NULL;

        lpUsername = (LPTSTR)LocalAlloc(LPTR, ANOTHERUSER_RESLEN * sizeof (TCHAR));
        LoadString (hInstance, IDS_ANOTHER_USER, lpUsername, ANOTHERUSER_RESLEN);

        LoadString (hInstance, IDS_ALREADY_RUN_USER, szTmpBuf, ARRAYSIZE(szTmpBuf));
        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       szTmpBuf,
                       0,
                       0,
                       (LPTSTR)&lpBuf,
                       0,
                       (va_list *)(&lpUsername));
        MessageBox (NULL, (LPCTSTR)lpBuf, NULL, MB_OK);
        LocalFree (lpBuf);
        LocalFree (lpUsername);

        goto END;
    }

    ZeroMemory (&wcx, sizeof (WNDCLASSEX));
    wcx.cbSize = sizeof (WNDCLASSEX);
    wcx.hInstance = hInstance;
    wcx.lpszClassName = WINDOWCLASS;
    wcx.lpfnWndProc = WndProc;
    if (!RegisterClassEx (&wcx))
    {
        dwResult = GetLastError();
        goto END;
    }

    ZeroMemory (&wcx, sizeof (WNDCLASSEX));
    wcx.cbSize = sizeof (WNDCLASSEX);
    wcx.hInstance = hInstance;
    wcx.lpszClassName = TEXT("WebHost");
    wcx.lpfnWndProc = WebHostProc;
    if (!RegisterClassEx (&wcx))
    {
        dwResult = GetLastError();
        goto END;
    }

    hwnd = CreateWindow (WINDOWCLASS,
                         WINDOWNAME,
                         WS_OVERLAPPEDWINDOW,
                         CW_USEDEFAULT,
                         CW_USEDEFAULT,
                         400, 300,
                         NULL, NULL,
                         hInstance,
                         NULL);
    if (!hwnd)
    {
        dwResult = GetLastError();
        goto END;
    }

    StartInfo.hWnd = hwnd;
    StartInfo.hInstance = hInstance;
    StartInfo.lpCmdLine = commandLine;

    g_hThread = CreateThread( NULL,
                              0,
                              MigwizThread,
                              (PVOID)&StartInfo,
                              0,
                              &g_dwThreadId );
    if (g_hThread == NULL)
    {
        dwResult = GetLastError();
        goto END;
    }

    // Main message loop:
    while (GetMessage( &msg, NULL, 0, 0 ))
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }

END:
    OleUninitialize();
    CoUninitialize();

    if (hMutex)
    {
        CloseHandle (hMutex);
    }

    if (pSid)
    {
        LocalFree (pSid);
    }

#ifdef UNICODE
    if (commandLine)
    {
        LocalFree (commandLine);
    }
#endif

    if (g_ConfirmedReboot) {
        HANDLE token;
        TOKEN_PRIVILEGES newPrivileges;
        LUID luid;

        if (OpenProcessToken (GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token)) {
            if (LookupPrivilegeValue (NULL, SE_SHUTDOWN_NAME, &luid)) {

                newPrivileges.PrivilegeCount = 1;
                newPrivileges.Privileges[0].Luid = luid;
                newPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                if (AdjustTokenPrivileges(
                        token,
                        FALSE,
                        &newPrivileges,
                        0,
                        NULL,
                        NULL
                        )) {
                    ExitWindowsEx (EWX_REBOOT, 0);
                }
            }
            CloseHandle (token);
        }
    } else if (g_ConfirmedLogOff) {
        ExitWindowsEx (EWX_LOGOFF, 0);
    }

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\miginf.h ===
#ifndef _MIGINF_H_
#define _MIGINF_H_

#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <setupapi.h>
#include <shlobj.h>
#include <prsht.h>
#include <tchar.h>
#include <windef.h>
#include "resource.h"
#include "commdlg.h"
#include "shlwapi.h"
#include "shellapi.h"

#include "migwiz.h"

#define MIGINF_SELECT_OOBE      0
#define MIGINF_SELECT_SETTINGS  1
#define MIGINF_SELECT_FILES     2
#define MIGINF_SELECT_BOTH      3


extern HINF g_hMigWizInf;
extern BOOL g_fStoreToFloppy;

BOOL OpenAppInf (LPTSTR pszFileName);
VOID CloseAppInf (VOID);
BOOL IsComponentEnabled (UINT uType, PCTSTR szComponent);
BOOL GetAppsToInstall (VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\miginf.cpp ===
#include "miginf.h"
#include "migutil.h"

#include "basetypes.h"
#include "utiltypes.h"
#include "objstr.h"

extern "C" {
#include "ism.h"
}

#include "modules.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) ((sizeof(x)) / (sizeof(x[0])))
#endif

HINF g_hMigWizInf = INVALID_HANDLE_VALUE;
POBJLIST g_HTMLApps;


BOOL OpenAppInf (LPTSTR pszFileName)
{
    if (g_hMigWizInf != INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    if (!pszFileName)
    {
        TCHAR szFileName[MAX_PATH];
        PTSTR psz;
        if (!GetModuleFileName (NULL, szFileName, ARRAYSIZE(szFileName))) {
            return FALSE;
        }
        szFileName [ARRAYSIZE(szFileName) - 1] = 0;

        psz = _tcsrchr (szFileName, TEXT('\\'));
        if (!psz) {
            return FALSE;
        }

        lstrcpy (psz + 1, TEXT("migwiz.inf"));
        pszFileName = szFileName;
    }

    g_hMigWizInf = SetupOpenInfFile (pszFileName, NULL, INF_STYLE_WIN4|INF_STYLE_OLDNT, NULL);

    return g_hMigWizInf != INVALID_HANDLE_VALUE;
}


VOID CloseAppInf (VOID)
{
    if (g_hMigWizInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile (g_hMigWizInf);
        g_hMigWizInf = INVALID_HANDLE_VALUE;
    }
}


BOOL IsComponentEnabled (UINT uType, PCTSTR szComponent)
{
    BOOL bResult = FALSE;
    INFCONTEXT ic;

    //
    // script-based entries start with $, while module-based entries don't.
    // This ensures script components do not collide with anything else.
    // Remove the $ to simplify [Single Floppy] or [Multiple Floppy].
    //

    if (_tcsnextc (szComponent) == TEXT('$')) {
        szComponent = _tcsinc (szComponent);
    }

    if (g_hMigWizInf != INVALID_HANDLE_VALUE) {

        switch (uType) {

        case MIGINF_SELECT_OOBE:
            bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("OOBE"), szComponent, &ic);
            break;

        case MIGINF_SELECT_SETTINGS:
            bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Settings Only"), szComponent, &ic);
            if (!g_fStoreToFloppy && !bResult)
            {
                bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Settings Only.Ext"), szComponent, &ic);
            }
            break;

        case MIGINF_SELECT_FILES:
            bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Files Only"), szComponent, &ic);
            if (!g_fStoreToFloppy && !bResult)
            {
                bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Files Only.Ext"), szComponent, &ic);
            }
            break;

        case MIGINF_SELECT_BOTH:
            bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Files and Settings"), szComponent, &ic);

            if (!g_fStoreToFloppy && !bResult)
            {
                bResult = SetupFindFirstLine (g_hMigWizInf, TEXT("Files and Settings.Ext"), szComponent, &ic);
            }
            break;

        default:
            bResult = TRUE;
            break;

        }
    }

    return bResult;
}

BOOL
GetAppsToInstall (
    VOID
    )
{
    INFCONTEXT ic;
    POBJLIST objList = NULL;
    BOOL fResult;
    LPTSTR p;

    MIG_COMPONENT_ENUM mce;

    _FreeObjectList(g_HTMLApps);
    g_HTMLApps = NULL;

    if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES | COMPONENTENUM_ENABLED |
                               COMPONENTENUM_PREFERRED_ONLY, COMPONENT_NAME)) {
        do {
            if (IsmIsComponentSelected (mce.ComponentString, 0)) {
                p = _tcsinc(mce.ComponentString);
                if (SetupFindFirstLine (g_hMigWizInf, TEXT("AppsToInstallOnDest"), p, &ic)) {
                    objList = _AllocateObjectList (mce.LocalizedAlias);
                    objList->Next = g_HTMLApps;
                    g_HTMLApps = objList;
                }
            }
        } while (IsmEnumNextComponent (&mce));
    }
    return (objList != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migfact.cpp ===
/*****************************************************************************
 *
 *    migfact.cpp - IClassFactory interface
 *
 *****************************************************************************/
// includes

#include <iostream.h>
#include <objbase.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobj.h>

#include "cowsite.h"

#include "Iface.h"      // Interface declarations
#include "Registry.h"   // Registry helper functions
#include "migutil.h"
#include "migeng.h"
#include "migtask.h"
#include "migoobe.h"

/*****************************************************************************/
// macros

#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))

/*****************************************************************************/
// extern methods

STDAPI DllAddRef();
STDAPI DllRelease();

/*****************************************************************************/
// function prototypesb

HRESULT CMigWizEngine_Create(IID riid, LPVOID* ppvObj);

/*****************************************************************************
 *
 *    CMigFactory
 *
 *
 *****************************************************************************/

class CMigFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CMigFactory(REFCLSID rclsid);
    ~CMigFactory(void);

    // Friend Functions
    friend HRESULT CMigFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int                     m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *    IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CMigFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = ResultFromScode(REGDB_E_CLASSNOTREG);

    if (!punkOuter)
    {
        if (IsEqualIID(m_rclsid, CLSID_MigWizEngine))
            hres = CMigWizEngine_Create(riid, ppvObj);
        else
            hres = E_FAIL;  //ASSERT(0);
    }
    else
    {        // Does anybody support aggregation any more?
        hres = ResultFromScode(CLASS_E_NOAGGREGATION);
    }

    if (FAILED(hres) && ppvObj)
    {
        *ppvObj = NULL; // Be Robust. NT #355186
    }
    
    return hres;
}

/*****************************************************************************
 *
 *    IClassFactory::LockServer
 *
 *    Locking the server is identical to
 *    creating an object and not releasing it until you want to unlock
 *    the server.
 *
 *****************************************************************************/

HRESULT CMigFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *    CFtpFactory_Create
 *
 *****************************************************************************/

HRESULT CMigFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CMigFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}





/****************************************************\
    Constructor
\****************************************************/
CMigFactory::CMigFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
}


/****************************************************\
    Destructor
\****************************************************/
CMigFactory::~CMigFactory()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CMigFactory::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CMigFactory::Release()
{
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CMigFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CMigWizEngine_Create(IID riid, LPVOID* ppvObj)
{
    HRESULT hres = E_OUTOFMEMORY;
    CMigWizEngine* pengine = new CMigWizEngine();

    *ppvObj = NULL;
    if (pengine)
    {
        hres = pengine->QueryInterface(riid, ppvObj);
        pengine->Release();
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migoobe.cpp ===
//
// dll.cpp
//
#include <iostream.h>
#include <objbase.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobj.h>

#include "cowsite.h"

#include "Iface.h"      // Interface declarations
#include "Registry.h"   // Registry helper functions
#include "migutil.h"
#include "migeng.h"
#include "migtask.h"
#include "migoobe.h"


// DLL functions, declared in dll.cpp
STDAPI DllAddRef();
STDAPI DllRelease();

extern HMODULE g_hModule;

///////////////////////////////////////////////////////////
//
// Global variables
//
///////////////////////////////////////////////////////////
//
// Component
//


//
// Constructor
//
CMigWizEngine::CMigWizEngine() : m_cRef(1), m_fCancelled(TRUE), m_fUserApplying(FALSE), m_fInBackgroundThread(FALSE)
{
    DllAddRef();
}

//
// Destructor
//
CMigWizEngine::~CMigWizEngine()
{
    DllRelease();
}

//
// IUnknown implementation
//
STDMETHODIMP CMigWizEngine::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMigWizEngine, IObjectWithSite),
        QITABENT(CMigWizEngine, IMigrationWizardAuto),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMigWizEngine::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CMigWizEngine::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

///////////////////////////////////////////////////////////

STDMETHODIMP CMigWizEngine::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMigWizEngine::GetIDsOfNames(REFIID /*riid */, LPOLESTR* rgszNames,
    UINT cNames, LCID lcid, DISPID* rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMigWizEngine::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams,
                              VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMigWizEngine::GetTypeInfoCount(UINT* pctinfo)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////

HRESULT CMigWizEngine::_FireEvent (LPVOID lpParam, int iDISPID, DISPPARAMS* pdisp)
{
    HRESULT hr = E_FAIL;

    IDispatch* pDispatch = (IDispatch*)lpParam;

    if (pDispatch)
    {
        VARIANT varResult;
        DISPPARAMS disp = { NULL, NULL, 0, 0};
        if (pdisp == NULL)
        {
            pdisp = &disp;
        }

        hr = pDispatch->Invoke(iDISPID, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, pdisp, &varResult, NULL, NULL);

    }

    return hr;
}

HRESULT CMigWizEngine::_GetIDispatchStream(IStream** ppStream)
{
    HRESULT hr = E_FAIL;

    BOOL fDone = FALSE;

    if (_punkSite)
    {
        IConnectionPointContainer* pCPC;
        hr = _punkSite->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pCPC)); // get the connect point container

        if (SUCCEEDED(hr))
        {
            IEnumConnectionPoints* pEnum;

            hr = pCPC->EnumConnectionPoints(&pEnum); // get all the connection points

            if (SUCCEEDED(hr))
            {
                IConnectionPoint* pcp;
                while (!fDone)
                {
                    ULONG cpcp = 1;
                    if (FAILED(pEnum->Next(1, &pcp, &cpcp)) || 0 == cpcp)
                    {
                        break;
                    }
                    else
                    {
                        IID iidInterface;
                        if (SUCCEEDED ( pcp->GetConnectionInterface(&iidInterface) && // get only the connection point for DMigrationWizardAutoEvents
                            (DIID_DMigrationWizardAutoEvents == iidInterface)))
                        {
                            // now fire the event for all listeners on this connection point
                            IEnumConnections* pEnumConnections;
                            if (SUCCEEDED(pcp->EnumConnections(&pEnumConnections)))
                            {
                                CONNECTDATA rgcd[1];
                                ULONG ccd;
                                while (!fDone)
                                {
                                    if (FAILED(pEnumConnections->Next(ARRAYSIZE(rgcd), rgcd, &ccd)) || ccd == 0)
                                    {
                                        break;
                                    }
                                    else if (rgcd[0].pUnk)
                                    {
                                        IDispatch* pDispatch;
                                        if (SUCCEEDED(rgcd[0].pUnk->QueryInterface(IID_PPV_ARG(IDispatch, &pDispatch))))
                                        {
                                            if (SUCCEEDED(CoMarshalInterThreadInterfaceInStream(IID_IDispatch, pDispatch, ppStream)))
                                            {
                                                fDone = TRUE;
                                                hr = S_OK;
                                            }
                                            pDispatch->Release();
                                        }
                                        rgcd[0].pUnk->Release();
                                    }
                                }
                                pEnumConnections->Release();
                            }
                        }
                        pcp->Release();
                    }
                }
                pEnum->Release();
            }
            pCPC->Release();
        }
    }

    return hr;
}

HRESULT CMigWizEngine::_FireProgress(LPVOID lpParam, BSTR pszMsg, int iDone, int iTotal)
{
    VARIANTARG rgvarg[3];
    VARIANT varResult;
    VariantClear(&varResult);
    HRESULT hr = E_OUTOFMEMORY;

    DISPPARAMS disp = { rgvarg, NULL, ARRAYSIZE(rgvarg), 0};

    rgvarg[0].vt = VT_BSTR;
    rgvarg[0].bstrVal = SysAllocString(pszMsg);
    if (rgvarg[0].bstrVal)
    {
        rgvarg[1].vt = VT_I4;
        rgvarg[1].lVal = iDone;

        rgvarg[2].vt = VT_I4;
        rgvarg[2].lVal = iTotal;

        hr = _FireEvent(lpParam, 1, &disp);
        SysFreeString(rgvarg[0].bstrVal);
    }

    return hr;
}

HRESULT CMigWizEngine::_FireComplete(LPVOID lpParam, BSTR pszMsg)
{
    VARIANTARG rgvarg[1];
    DISPPARAMS disp = { rgvarg, NULL, ARRAYSIZE(rgvarg), 0};

    rgvarg[0].vt = VT_BSTR;
    rgvarg[0].bstrVal = SysAllocString(pszMsg);
    if (rgvarg[0].bstrVal)
    {

        _FireEvent(lpParam, 2, &disp);

        SysFreeString(rgvarg[0].bstrVal);
    }

    return S_OK;
}


typedef struct {
    IDispatch* pDispatch;
    CMigWizEngine* pengine;
} PROGRESSCALLBACKSTRUCT;

UINT ProgressCallback (LPVOID lpParam, UINT ui1, UINT ui2)
{

    PROGRESSCALLBACKSTRUCT* ppcs = (PROGRESSCALLBACKSTRUCT*)lpParam;

    ppcs->pengine->_FireProgress((LPVOID)(ppcs->pDispatch), SZ_MIGWIZPROGRESS_OK, ui1, ui2);

    return 0;
}

#define SZ_OOBEMODE     TEXT("OOBEMODE")
HRESULT CMigWizEngine::_CreateToolDiskThreadWorker ()
{
    HRESULT hr = E_FAIL;
    BOOL fNoDisk = FALSE;

    IDispatch* pDispatch;

    hr = CoGetInterfaceAndReleaseStream(m_pDispatchStream, IID_PPV_ARG(IDispatch, &pDispatch));
    if (SUCCEEDED(hr))
    {
        // copy the INF
        CHAR szDrivePathA[MAX_PATH];

        if (SUCCEEDED(_SHUnicodeToAnsi(m_pszDrivePath, szDrivePathA, ARRAYSIZE(szDrivePathA))))
        {
            CHAR szFilesPathA[MAX_PATH];
            if (SUCCEEDED(_SHUnicodeToAnsi(m_pszFilesPath, szFilesPathA, ARRAYSIZE(szFilesPathA))))
            {
                CHAR szManifestPathA[MAX_PATH];
                if (SUCCEEDED(_SHUnicodeToAnsi(m_pszManifestPath, szManifestPathA, ARRAYSIZE(szManifestPathA))))
                {
                    PROGRESSCALLBACKSTRUCT pcs;
                    pcs.pDispatch = pDispatch;
                    pDispatch->AddRef();
                    pcs.pengine = this;
                    this->AddRef();

                    if (SUCCEEDED(_CopyInfToDisk(szDrivePathA, szFilesPathA, szManifestPathA,
                                  ProgressCallback, (LPVOID)&pcs, NULL, NULL, g_hModule, &m_fCancelled, &fNoDisk)))
                    {
                        if (!m_fCancelled)
                        {
                            hr = S_OK;
                            IStream* pStream = NULL;
                            TCHAR szPath[MAX_PATH];
                            lstrcpy(szPath, szDrivePathA);
                            PathAppend(szPath, TEXT("oobemode.dat"));
                            if (SUCCEEDED(SHCreateStreamOnFile(szPath, STGM_WRITE | STGM_CREATE, &pStream)))
                            {
                                pStream->Write(SZ_OOBEMODE, sizeof(TCHAR) * (ARRAYSIZE(SZ_OOBEMODE) - 1), NULL);
                                pStream->Release();
                            }
                        }
                    }

                    pDispatch->Release();
                    this->Release();
                }
            }
        }


        m_fInBackgroundThread = FALSE;

        if (m_fCancelled)
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_CANCEL);
        }
        else if (fNoDisk)
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_NODISK);
        }
        else if (SUCCEEDED(hr))
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_OK);
        }
        else
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_FAIL);
        }
    }

    m_fCancelled = TRUE;

    SysFreeString(m_pszDrivePath);
    SysFreeString(m_pszFilesPath);
    SysFreeString(m_pszManifestPath);
    if (pDispatch)
    {
        pDispatch->Release();
    }
    Release();

    return 0;
}

DWORD WINAPI CMigWizEngine::_CreateToolDiskThread (LPVOID lpParam)
{
    if (lpParam)
    {
        ((CMigWizEngine*)lpParam)->_CreateToolDiskThreadWorker();
    }


    return 0;
}

STDMETHODIMP CMigWizEngine::CreateToolDisk(BSTR pszDrivePath, BSTR pszFilesPath, BSTR pszManifestPath)
{
    HRESULT hr = S_OK; // we always want to return S_OK

    if (!m_fInBackgroundThread)
    {
        m_fInBackgroundThread = TRUE;
        hr = S_OK;

        IStream* pDispatchStream;
        hr = _GetIDispatchStream(&pDispatchStream);

        if (SUCCEEDED(hr))
        {
            m_pszDrivePath = SysAllocString(pszDrivePath);
            m_pszFilesPath = SysAllocString(pszFilesPath);
            m_pszManifestPath = SysAllocString(pszManifestPath);

            if (m_pszDrivePath && m_pszFilesPath && m_pszManifestPath)
            {
                m_fCancelled = FALSE;
                m_pDispatchStream = pDispatchStream;
                m_pDispatchStream->AddRef();

                AddRef();
                if (!SHCreateThread(_CreateToolDiskThread, this, (CTF_COINIT | CTF_PROCESS_REF | CTF_FREELIBANDEXIT), NULL))
                {
                    Release();
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                SysFreeString(pszDrivePath); // SysFreeString doesn't mind being passed NULL
                SysFreeString(pszFilesPath);
                SysFreeString(pszManifestPath);
            }

            pDispatchStream->Release();
        }
    }

    return hr;
}

BOOL g_fApplyDiskNotFound;

ULONG_PTR MessageCallback (UINT uiMsg, ULONG_PTR pArg)
{
    PRMEDIA_EXTRADATA extraData;

    switch (uiMsg) {

    case TRANSPORTMESSAGE_SIZE_SAVED:
        return TRUE;

    case TRANSPORTMESSAGE_RMEDIA_LOAD:
        extraData = (PRMEDIA_EXTRADATA) pArg;
        if (!extraData) {
            return TRUE;
        } else {
            if (extraData->MediaNumber == 1) {
                switch (extraData->LastError) {
                case RMEDIA_ERR_NOERROR:
                    return TRUE;
                    break;
                case RMEDIA_ERR_WRONGMEDIA:
                    g_fApplyDiskNotFound = TRUE;
                    return FALSE;
                    break;
                case RMEDIA_ERR_DISKFULL:
                    return FALSE;
                    break;
                case RMEDIA_ERR_WRITEPROTECT:
                    return FALSE;
                    break;
                case RMEDIA_ERR_NOTREADY:
                    return FALSE;
                    break;
                case RMEDIA_ERR_CRITICAL:
                    return FALSE;
                    break;
                default:
                    return TRUE;
                }
            } else {
                switch (extraData->LastError) {
                case RMEDIA_ERR_NOERROR:
                    return TRUE;
                    break;
                case RMEDIA_ERR_WRONGMEDIA:
                    g_fApplyDiskNotFound = TRUE;
                    return FALSE;
                    break;
                case RMEDIA_ERR_DISKFULL:
                    return FALSE;
                    break;
                case RMEDIA_ERR_WRITEPROTECT:
                    return FALSE;
                    break;
                case RMEDIA_ERR_NOTREADY:
                    return FALSE;
                    break;
                case RMEDIA_ERR_CRITICAL:
                    return FALSE;
                    break;
                default:
                    return TRUE;
                }
            }
        }
    }

    return APPRESPONSE_SUCCESS;
}

#define PHASEWIDTH_APPLY_TRANSPORT     1000
#define PHASEWIDTH_APPLY_ANALYSIS      1000
#define PHASEWIDTH_APPLY_APPLY         1000
#define PHASEWIDTH_APPLY_TOTAL        (PHASEWIDTH_APPLY_TRANSPORT + PHASEWIDTH_APPLY_ANALYSIS + PHASEWIDTH_APPLY_APPLY)

typedef struct {
    CMigWizEngine* pEngine;
    IDispatch* pDispatch;
} APPLYPROGRESSCALLBACKSTRUCT;

VOID WINAPI ApplyProgressCallback (MIG_PROGRESSPHASE Phase, MIG_PROGRESSSTATE State, UINT uiWorkDone, UINT uiTotalWork, ULONG_PTR pArg)
{
    INT iWork = 0;
    INT iPhaseWidth = 0;
    INT iTotal = PHASEWIDTH_APPLY_TOTAL;

    APPLYPROGRESSCALLBACKSTRUCT* papcs = (APPLYPROGRESSCALLBACKSTRUCT*)pArg;

    switch (Phase)
    {
    case MIG_TRANSPORT_PHASE:
        iWork = 0;
        iPhaseWidth = PHASEWIDTH_APPLY_TRANSPORT;
        break;
    case MIG_ANALYSIS_PHASE:
        iWork = PHASEWIDTH_APPLY_TRANSPORT;
        iPhaseWidth = PHASEWIDTH_APPLY_ANALYSIS;
        break;
    case MIG_APPLY_PHASE:
        iWork = PHASEWIDTH_APPLY_TRANSPORT + PHASEWIDTH_APPLY_ANALYSIS;
        iPhaseWidth = PHASEWIDTH_APPLY_APPLY;
        break;
    }

    if (State == MIG_END_PHASE)
    {
        iWork += iPhaseWidth;
    }
    else if (uiTotalWork && uiWorkDone)
    {
        iWork += (iPhaseWidth * uiWorkDone) / uiTotalWork;
    }

    if (papcs && papcs->pEngine && papcs->pDispatch)
    {
        papcs->pEngine->_FireProgress(papcs->pDispatch, L"", iWork, iTotal);
    }
}

HRESULT CMigWizEngine::_ApplySettingsThreadWorker ()
{
    HRESULT hr = E_OUTOFMEMORY;

    g_fApplyDiskNotFound = FALSE; // set up

    IDispatch* pDispatch;

    hr = CoGetInterfaceAndReleaseStream(m_pDispatchStream, IID_PPV_ARG(IDispatch, &pDispatch));
    if (SUCCEEDED(hr))
    {
        APPLYPROGRESSCALLBACKSTRUCT apcs;
        apcs.pEngine = this;
        apcs.pEngine->AddRef();
        apcs.pDispatch = pDispatch;
        apcs.pDispatch->AddRef();

        if (SUCCEEDED(hr))
        {
            TCHAR szFloppyPath[4] = TEXT("A:\\");
            szFloppyPath[0] += (TCHAR)_GetFloppyNumber(TRUE);

            hr = _DoApply(szFloppyPath, NULL, NULL, &m_fCancelled, ApplyProgressCallback, (ULONG_PTR)&apcs);
        }

        apcs.pEngine->Release();
        apcs.pDispatch->Release();

        m_fInBackgroundThread = FALSE;

        if (m_fCancelled)
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_CANCEL);
        }
        else if (g_fApplyDiskNotFound)
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_NODISK);
        }
        else if (SUCCEEDED(hr))
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_OK);
        }
        else
        {
            _FireComplete((LPVOID)pDispatch, SZ_MIGWIZCOMPLETE_FAIL);
        }
    }

    m_fCancelled = TRUE;
    m_fUserApplying = FALSE;

    Release();

    return hr;
}

DWORD WINAPI CMigWizEngine::_ApplySettingsThread (LPVOID lpParam)
{
    if (lpParam)
    {
        ((CMigWizEngine*)lpParam)->_ApplySettingsThreadWorker();
    }

    return 0;
}

STDMETHODIMP CMigWizEngine::ApplySettings(BSTR pszMigwizFiles)
{
    HRESULT hr = E_FAIL;

    if (!m_fInBackgroundThread)
    {
        m_fInBackgroundThread = TRUE;
        hr = S_OK;

        m_fUserApplying = TRUE;

        IStream* pDispatchStream;
        hr = _GetIDispatchStream(&pDispatchStream);

        if (SUCCEEDED(hr))
        {
            m_fCancelled = FALSE;

            CHAR szMigwizPathA[MAX_PATH];
            if (SUCCEEDED(_SHUnicodeToAnsi(pszMigwizFiles, szMigwizPathA, ARRAYSIZE(szMigwizPathA))))
            {
                hr = Engine_Initialize(szMigwizPathA, FALSE, FALSE, TEXT("OOBE"), MessageCallback, NULL);

                m_pDispatchStream = pDispatchStream;
                m_pDispatchStream->AddRef();
                AddRef();
                if (!SHCreateThread(_ApplySettingsThread, this, (CTF_COINIT | CTF_PROCESS_REF | CTF_FREELIBANDEXIT), NULL))
                {
                    Release();
                }
            }
            else
            {
                hr = E_FAIL;
            }


            pDispatchStream->Release();
        }
    }

    return hr;
}

STDMETHODIMP CMigWizEngine::Cancel()
{
    HRESULT hr = S_OK;

    m_fCancelled = TRUE;
    if (m_fUserApplying)
    {
        Engine_Cancel();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migtask.cpp ===
#include <windowsx.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <stdio.h>
#include <winioctl.h>
#include "resource.h"

#include "migtask.h"
#include "migwiz.h"
#include "migwnprc.h"
#include "migutil.h"
#include "miginf.h"
#include "migeng.h"

extern "C" {
#include "cablib.h"
}

#define MAX_LOADSTRING 1024

extern BOOL g_fUberCancel;

CCABHANDLE g_hCabHandle = NULL;
#define S_MIGWIZCAB TEXT("migwiz.cab")
#define S_TOOLDISK TEXT("DSK%05X")
#define S_DONOTCOMPRESS TEXT("NO_COMPRESS")
#define S_DONOTFAIL TEXT("NO_FAIL")

typedef struct {
    HWND hwndProgress;
    HWND hwndPropSheet;
    BOOL fSource;
    BOOL* pfHasUserCancelled;
} PROGRESSCALLBACKSTRUCT;

#define PHASEWIDTH_S_BEGINGAP                 200
#define PHASEWIDTH_S_ENDGAP                   200
#define PHASEWIDTH_S_QUEUE_HIGHPRIORITY       200
#define PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY    200
#define PHASEWIDTH_S_GATHER_HIGHPRIORITY      400
#define PHASEWIDTH_S_QUEUE_GATHER             800
#define PHASEWIDTH_S_ESTIMATE_GATHER          800
#define PHASEWIDTH_S_GATHER_GATHER           2400
#define PHASEWIDTH_S_ANALYSIS                 200
#define PHASEWIDTH_S_TRANSPORT               5000
#define PHASEWIDTH_S_TOTAL                   (PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                                            + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                                            + PHASEWIDTH_S_QUEUE_GATHER + PHASEWIDTH_S_ESTIMATE_GATHER \
                                            + PHASEWIDTH_S_GATHER_GATHER + PHASEWIDTH_S_ANALYSIS \
                                            + PHASEWIDTH_S_TRANSPORT + PHASEWIDTH_S_ENDGAP)

#define PHASEWIDTH_D_BEGINGAP                 150
#define PHASEWIDTH_D_ENDGAP                   150
#define PHASEWIDTH_D_TRANSPORT               2000
#define PHASEWIDTH_D_QUEUE_HIGHPRIORITY        50
#define PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY     50
#define PHASEWIDTH_D_GATHER_HIGHPRIORITY      100
#define PHASEWIDTH_D_QUEUE_GATHER              50
#define PHASEWIDTH_D_ESTIMATE_GATHER           50
#define PHASEWIDTH_D_GATHER_GATHER            100
#define PHASEWIDTH_D_ANALYSIS                 500
#define PHASEWIDTH_D_APPLY                   5000
#define PHASEWIDTH_D_TOTAL                   (PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                                            + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                                            + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER \
                                            + PHASEWIDTH_D_ESTIMATE_GATHER + PHASEWIDTH_D_GATHER_GATHER \
                                            + PHASEWIDTH_D_ANALYSIS + PHASEWIDTH_D_APPLY \
                                            + PHASEWIDTH_D_ENDGAP)

VOID WINAPI ProgressCallback (MIG_PROGRESSPHASE Phase, MIG_PROGRESSSTATE State, UINT uiWorkDone, UINT uiTotalWork, ULONG_PTR pArg)
{
    PROGRESSCALLBACKSTRUCT* ppcs = (PROGRESSCALLBACKSTRUCT*)pArg;

    if (!g_fUberCancel) {
        INT iWork = 0;
        INT iPhaseWidth = 0;
        INT iTotal = ppcs->fSource ? PHASEWIDTH_S_TOTAL : PHASEWIDTH_D_TOTAL;

        if (ppcs->fSource)
        {
            switch (Phase)
            {
            case MIG_HIGHPRIORITYQUEUE_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP;
                iPhaseWidth = PHASEWIDTH_S_QUEUE_HIGHPRIORITY;
                break;
            case MIG_HIGHPRIORITYESTIMATE_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY;
                break;
            case MIG_HIGHPRIORITYGATHER_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_S_GATHER_HIGHPRIORITY;
                break;
            case MIG_GATHERQUEUE_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_S_QUEUE_GATHER;
                break;
            case MIG_GATHERESTIMATE_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                      + PHASEWIDTH_S_QUEUE_GATHER;
                iPhaseWidth = PHASEWIDTH_S_ESTIMATE_GATHER;
                break;
            case MIG_GATHER_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                      + PHASEWIDTH_S_QUEUE_GATHER + PHASEWIDTH_S_ESTIMATE_GATHER;
                iPhaseWidth = PHASEWIDTH_S_GATHER_GATHER;
                break;
            case MIG_ANALYSIS_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                      + PHASEWIDTH_S_QUEUE_GATHER + PHASEWIDTH_S_ESTIMATE_GATHER \
                      + PHASEWIDTH_S_GATHER_GATHER;
                iPhaseWidth = PHASEWIDTH_S_ANALYSIS;
                break;
            case MIG_TRANSPORT_PHASE:
                iWork = PHASEWIDTH_S_BEGINGAP + PHASEWIDTH_S_QUEUE_HIGHPRIORITY \
                      + PHASEWIDTH_S_ESTIMATE_HIGHPRIORITY + PHASEWIDTH_S_GATHER_HIGHPRIORITY \
                      + PHASEWIDTH_S_QUEUE_GATHER + PHASEWIDTH_S_ESTIMATE_GATHER \
                      + PHASEWIDTH_S_GATHER_GATHER + PHASEWIDTH_S_ANALYSIS;
                iPhaseWidth = PHASEWIDTH_S_TRANSPORT;
                break;
            }
        }
        else
        {
            switch (Phase)
            {
            case MIG_TRANSPORT_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP;
                iPhaseWidth = PHASEWIDTH_D_TRANSPORT;
                break;
            case MIG_HIGHPRIORITYQUEUE_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT;
                iPhaseWidth = PHASEWIDTH_D_QUEUE_HIGHPRIORITY;
                break;
            case MIG_HIGHPRIORITYESTIMATE_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                       +PHASEWIDTH_D_QUEUE_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY;
                break;
            case MIG_HIGHPRIORITYGATHER_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_D_GATHER_HIGHPRIORITY;
                break;
            case MIG_GATHERQUEUE_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY;
                iPhaseWidth = PHASEWIDTH_D_QUEUE_GATHER;
                break;
            case MIG_GATHERESTIMATE_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER;
                iPhaseWidth = PHASEWIDTH_D_ESTIMATE_GATHER;
                break;
            case MIG_GATHER_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER \
                      + PHASEWIDTH_D_ESTIMATE_GATHER;
                iPhaseWidth = PHASEWIDTH_D_GATHER_GATHER;
                break;
            case MIG_ANALYSIS_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER \
                      + PHASEWIDTH_D_ESTIMATE_GATHER + PHASEWIDTH_D_GATHER_GATHER;
                iPhaseWidth = PHASEWIDTH_D_ANALYSIS;
                break;
            case MIG_APPLY_PHASE:
                iWork = PHASEWIDTH_D_BEGINGAP + PHASEWIDTH_D_TRANSPORT \
                      + PHASEWIDTH_D_QUEUE_HIGHPRIORITY + PHASEWIDTH_D_ESTIMATE_HIGHPRIORITY \
                      + PHASEWIDTH_D_GATHER_HIGHPRIORITY + PHASEWIDTH_D_QUEUE_GATHER \
                      + PHASEWIDTH_D_ESTIMATE_GATHER + PHASEWIDTH_D_GATHER_GATHER \
                      + PHASEWIDTH_D_ANALYSIS;
                iPhaseWidth = PHASEWIDTH_D_APPLY;
                break;
            }
        }

        if (State == MIG_END_PHASE)
        {
            iWork += iPhaseWidth;
        }
        else if (uiTotalWork && uiWorkDone)
        {
            iWork += (iPhaseWidth * uiWorkDone) / uiTotalWork;
        }

        SendMessage(ppcs->hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, iTotal));
        SendMessage(ppcs->hwndProgress, PBM_SETPOS, iWork, 0);

    }
}


VOID WINAPI pFillProgressBar (ULONG_PTR pArg)
{
    PROGRESSCALLBACKSTRUCT* ppcs = (PROGRESSCALLBACKSTRUCT*)pArg;

    if (!g_fUberCancel) {
        INT iWork = ppcs->fSource ? PHASEWIDTH_S_TOTAL : PHASEWIDTH_D_TOTAL;
        INT iTotal = ppcs->fSource ? PHASEWIDTH_S_TOTAL : PHASEWIDTH_D_TOTAL;

        SendMessage(ppcs->hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, iTotal));
        SendMessage(ppcs->hwndProgress, PBM_SETPOS, iWork, 0);
    }
}


//////////////////////////////////////////////////////////
// prepare data

HRESULT _DoCopy(LPTSTR tszTransportPath, HWND hwndProgress, HWND hwndPropSheet, BOOL* pfHasUserCancelled)
{
    HRESULT hr = E_OUTOFMEMORY;

    PROGRESSCALLBACKSTRUCT* ppcs = (PROGRESSCALLBACKSTRUCT*)CoTaskMemAlloc(sizeof(PROGRESSCALLBACKSTRUCT));
    if (ppcs)
    {
        ppcs->hwndProgress = hwndProgress;
        ppcs->hwndPropSheet = hwndPropSheet;
        ppcs->fSource = TRUE;
        ppcs->pfHasUserCancelled = pfHasUserCancelled;
        hr = Engine_RegisterProgressBarCallback (ProgressCallback, (ULONG_PTR)ppcs);
    }


    if (SUCCEEDED(hr))
    {
        // start the transport
        hr = Engine_StartTransport (TRUE, tszTransportPath, NULL, NULL); // start non-network transport

        if (SUCCEEDED(hr))
        {
            hr = Engine_Execute(TRUE);
        }

        if (SUCCEEDED(hr))
        {
            Engine_Terminate();
        }
    }

    if (ppcs) {
        pFillProgressBar ((ULONG_PTR)ppcs);
    }

    return hr;
}

//////////////////////////////////////////////////////////
// apply data

HRESULT _DoApply(LPTSTR tszTransportPath, HWND hwndProgress, HWND hwndPropSheet, BOOL* pfHasUserCancelled,
                 PROGRESSBARFN pAltProgressFunction, ULONG_PTR puAltProgressParam)
{
    HRESULT hr;
    PROGRESSCALLBACKSTRUCT* ppcs = NULL;
    BOOL imageIsValid = FALSE, imageExists = FALSE;

    if (NULL != pAltProgressFunction)
    {
        hr = Engine_RegisterProgressBarCallback(pAltProgressFunction, puAltProgressParam);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        ppcs = (PROGRESSCALLBACKSTRUCT*)CoTaskMemAlloc(sizeof(PROGRESSCALLBACKSTRUCT));
        if (ppcs)
        {
            ppcs->hwndProgress = hwndProgress;
            ppcs->hwndPropSheet = hwndPropSheet;
            ppcs->fSource = FALSE;
            ppcs->pfHasUserCancelled = pfHasUserCancelled;
            hr = Engine_RegisterProgressBarCallback(ProgressCallback, (ULONG_PTR)ppcs);
        }
    }

    if (SUCCEEDED(hr))
    {
        if (tszTransportPath) // if not network
        {
            hr = Engine_StartTransport(FALSE, tszTransportPath, &imageIsValid, &imageExists); // start non-network transport
        }
        else
        {
            // it's network
            imageIsValid = TRUE;
            imageExists = TRUE;
        }

        if (SUCCEEDED(hr) && imageIsValid && imageExists)
        {
            hr = Engine_Execute(FALSE);

            if (SUCCEEDED(hr))
            {
                Engine_Terminate();
            }
        }
    }

    if (ppcs)
    {
        pFillProgressBar ((ULONG_PTR)ppcs);
    }

    return hr;
}

//////////////////////////////////////////////////////////
// create tool disk data

BOOL _CopyFileToDisk(LPCTSTR pctszSrcFname, LPCTSTR pctszSrcPath, LPCTSTR pctszDestPath, LPCTSTR pctszDestFname,
                     HINSTANCE hInstance, HWND hwndParent,
                     BOOL fCompress, BOOL fFailOnError)
{
    TCHAR tszSysDir[MAX_PATH];
    TCHAR tszFnameSrc[MAX_PATH];
    TCHAR tszFnameDest[MAX_PATH];
    UINT uFnameTchars;
    BOOL fCopySuccess = FALSE;

    if (pctszDestFname == NULL ||
        *pctszDestFname == NULL)
    {
        pctszDestFname = pctszSrcFname;
    }

    uFnameTchars = lstrlen (pctszSrcFname) + 1;

    // Build Source path+filename
    StrCpyN(tszFnameSrc, pctszSrcPath, ARRAYSIZE(tszFnameSrc) - uFnameTchars);
    PathAppend(tszFnameSrc, pctszSrcFname);

    if (!fCompress)
    {
        // Build Dest path+filename
        StrCpyN(tszFnameDest, pctszDestPath, ARRAYSIZE(tszFnameDest) - uFnameTchars);
        PathAppend(tszFnameDest, pctszDestFname);
    }

    // if source file does not exist, try using the system directory (case is shfolder.dll)
    if (0xFFFFFFFF == GetFileAttributes (tszFnameSrc))
    {
        GetSystemDirectory (tszSysDir, ARRAYSIZE(tszSysDir));
        StrCpyN(tszFnameSrc, tszSysDir, ARRAYSIZE(tszFnameSrc) - uFnameTchars);
        PathAppend(tszFnameSrc, pctszSrcFname);
    }

    if (fCompress)
    {
        // Add to migwiz.cab
        fCopySuccess = CabAddFileToCabinet( g_hCabHandle, tszFnameSrc, pctszDestFname );
    }
    else
    {
        // do the actual copy
        fCopySuccess = CopyFile(tszFnameSrc, tszFnameDest, FALSE);
    }

    if (fFailOnError) {
        return fCopySuccess;
    }
    return TRUE;
}

VOID
pDisplayCopyError (
    HWND hwndParent,
    HINSTANCE hInstance,
    DWORD Error
    )
{
    UINT resId;
    TCHAR szMigrationWizardTitle[MAX_LOADSTRING];

    LoadString(hInstance, IDS_MIGWIZTITLE, szMigrationWizardTitle, ARRAYSIZE(szMigrationWizardTitle));

    if (hwndParent) // Stand-alone wizard mode
    {
        TCHAR szErrDiskLoad[MAX_LOADSTRING];
        resId = IDS_ERRORDISK;
        if (Error == ERROR_WRITE_PROTECT) {
            resId = IDS_ENGERR_WRITEPROTECT;
        }
        if (Error == ERROR_NOT_READY) {
            resId = IDS_ENGERR_NOTREADY;
        }
        if (Error == ERROR_DISK_FULL) {
            resId = IDS_ENGERR_FULL;
        }
        LoadString(hInstance, resId, szErrDiskLoad, ARRAYSIZE(szErrDiskLoad));
        _ExclusiveMessageBox(hwndParent, szErrDiskLoad, szMigrationWizardTitle, MB_OK);
    }
}

BOOL
CanCreateWizardDisk (
    IN      PCTSTR SourcePath,
    IN      PCTSTR InfPath
    )
{
    INFCONTEXT context;
    TCHAR sourcePath [MAX_PATH];
    TCHAR systemDir [MAX_PATH];
    TCHAR fullFileName [MAX_PATH];
    PTSTR filePtr = NULL;
    PTSTR sysFilePtr = NULL;
    TCHAR destName [MAX_PATH];
    DWORD attribs;
    BOOL result = FALSE;

    if (!SourcePath) {
        if (GetModuleFileName (NULL, sourcePath, ARRAYSIZE(sourcePath))) {
            filePtr = _tcsrchr (sourcePath, TEXT('\\'));
            if (filePtr) {
                *filePtr = 0;
                SourcePath = sourcePath;
            } else {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    }

    OpenAppInf ((LPTSTR)InfPath);

    if (g_hMigWizInf != INVALID_HANDLE_VALUE) {

        GetSystemDirectory (systemDir, ARRAYSIZE(systemDir));
        sysFilePtr = _tcschr (systemDir, 0);
        if (sysFilePtr) {
            _tcscpy (sysFilePtr, TEXT("\\"));
            sysFilePtr = _tcschr (sysFilePtr, 0);
        }

        _tcsncpy (fullFileName, SourcePath, MAX_PATH - 2);
        filePtr = _tcschr (fullFileName, 0);
        if (filePtr) {
            _tcscpy (filePtr, TEXT("\\"));
            filePtr = _tcschr (filePtr, 0);
        }
        if (filePtr && sysFilePtr) {
            if (SetupFindFirstLine(g_hMigWizInf, TEXT("CopyFiles"), NULL, &context)) {
                result = TRUE;
                do {
                    if (!SetupGetStringField (&context, 1, filePtr, ARRAYSIZE(fullFileName) - (filePtr - fullFileName), NULL)) {
                        result = FALSE;
                        break;
                    }
                    if (SetupGetStringField (&context, 2, destName, ARRAYSIZE(destName), NULL)) {
                        if (!StrCmpI (destName, S_DONOTFAIL)) {
                            // we don't care about this file
                            continue;
                        }
                    }
                    // let's see if this file exists on the source path
                    attribs = GetFileAttributes (fullFileName);
                    if (attribs == INVALID_FILE_ATTRIBUTES) {
                        _tcsncpy (sysFilePtr, filePtr, ARRAYSIZE(systemDir) - (sysFilePtr - systemDir));
                        attribs = GetFileAttributes (systemDir);
                        if (attribs == INVALID_FILE_ATTRIBUTES) {
                            result = FALSE;
                            break;
                        }
                    }
                } while (SetupFindNextLine (&context, &context));
            }
        }
        CloseAppInf ();
    }

    return result;
}

HRESULT _CopyInfToDisk(LPCTSTR pctszDestPath, LPCTSTR pctszSourcePath, LPCTSTR pctszInfPath,
                       PMESSAGECALLBACK2 progressCallback, LPVOID lpparam,
                       HWND hwndProgressBar, HWND hwndParent, HINSTANCE hInstance,
                       BOOL* pfHasUserCancelled, DWORD* pfError)
{
    HRESULT hr = S_OK;
    TCHAR szCabPath [MAX_PATH];

    if (pfError) {
        *pfError = ERROR_SUCCESS;
    }

    __try {

        // copy the actual files over
        OpenAppInf((LPTSTR)pctszInfPath);

        if (INVALID_HANDLE_VALUE != g_hMigWizInf)
        {
            INFCONTEXT context;
            LONG cLinesProcessed = 0;
            LONG cLines = SetupGetLineCount(g_hMigWizInf, TEXT("CopyFiles")) + 1;  // Last one is for closing the CAB

            if (SetupFindFirstLine(g_hMigWizInf, TEXT("CopyFiles"), NULL, &context))
            {
                if (!pctszDestPath) {
                    hr = E_FAIL;
                    __leave;
                }

                if (_tcslen(pctszDestPath) + _tcslen(S_MIGWIZCAB) + 1 >= MAX_PATH) {
                    hr = E_FAIL;
                    __leave;
                }

                // Delete the existing CAB that might be on the disk
                StrCpy (szCabPath, pctszDestPath);
                StrCat (szCabPath, S_MIGWIZCAB);
                SetFileAttributes (szCabPath, FILE_ATTRIBUTE_NORMAL);
                if (!DeleteFile (szCabPath)) {
                    if (GetLastError () != ERROR_FILE_NOT_FOUND) {
                        if (pfError) {
                            *pfError = GetLastError ();
                        }
                        hr = E_FAIL;
                        __leave;
                    }
                }

                g_hCabHandle = CabCreateCabinet( pctszDestPath, S_MIGWIZCAB, S_TOOLDISK, IsmGetTempFile, 0 );
                if (g_hCabHandle)
                {
                    do
                    {
                        TCHAR szFname[MAX_PATH];

                        if (*pfHasUserCancelled) {
                            hr = E_ABORT;
                            __leave;
                        }

                        if (SetupGetStringField(&context, 1, szFname, ARRAYSIZE(szFname), NULL))
                        {
                            TCHAR szDestFname[MAX_PATH] = TEXT("");
                            BOOL fCompress = TRUE;
                            BOOL fFailOnError = TRUE;
                            if (SetupGetStringField(&context, 2, szDestFname, ARRAYSIZE(szDestFname), NULL))
                            {
                                if (!StrCmpI(szDestFname, S_DONOTCOMPRESS))
                                {
                                    fCompress = FALSE;
                                    *szDestFname = 0;
                                }
                                else if (!StrCmpI(szDestFname, S_DONOTFAIL))
                                {
                                    fFailOnError = FALSE;
                                    *szDestFname = 0;
                                }
                                else
                                {
                                    TCHAR szCompress[MAX_PATH];
                                    if (SetupGetStringField(&context, 3, szCompress, ARRAYSIZE(szCompress), NULL))
                                    {
                                        if (!StrCmpI(szCompress, S_DONOTCOMPRESS))
                                        {
                                            fCompress = FALSE;
                                            *szCompress = 0;
                                        }
                                        else if (!StrCmpI(szDestFname, S_DONOTFAIL))
                                        {
                                            fFailOnError = FALSE;
                                            *szCompress = 0;
                                        }
                                    }
                                }
                            }
                            if (!_CopyFileToDisk(szFname, pctszSourcePath, pctszDestPath, szDestFname,
                                            hInstance, hwndParent, fCompress, fFailOnError))
                            {
                                if (pfError) {
                                    *pfError = GetLastError ();
                                }
                                hr = E_FAIL;
                            }

                            cLinesProcessed++;

                            if (hwndProgressBar) // Stand-alone wizard mode
                            {
                                SendMessage(hwndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, cLines));
                                SendMessage(hwndProgressBar, PBM_SETPOS, cLinesProcessed, 0);
                            }

                            if (progressCallback) // OOBE mode
                            {
                                progressCallback(lpparam, cLinesProcessed, cLines);
                            }
                        }
                    } while (SetupFindNextLine(&context, &context));

                    if (*pfHasUserCancelled) {
                        hr = E_ABORT;
                        __leave;
                    }

                    if (!CabFlushAndCloseCabinet(g_hCabHandle)) {
                        if (pfError) {
                            *pfError = GetLastError ();
                        }
                        hr = E_FAIL;
                        __leave;
                    };

                    if (*pfHasUserCancelled) {
                        hr = E_ABORT;
                        __leave;
                    }

                    // Now that the CAB is complete, show the progress bar as finished
                    if (hwndProgressBar) // Stand-alone wizard mode
                    {
                        SendMessage(hwndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, cLines));
                        SendMessage(hwndProgressBar, PBM_SETPOS, cLines, 0);
                    }

                    if (progressCallback) // OOBE mode
                    {
                        progressCallback(lpparam, cLines, cLines);
                    }
                } else {
                    if (pfError) {
                        *pfError = GetLastError ();
                    }
                    hr = E_FAIL;
                    __leave;
                }
            }
        } else {
            if (pfError) {
                *pfError = ERROR_INTERNAL_ERROR;
            }
            hr = E_FAIL;
            __leave;
        }
    }
    __finally {
    }

    if (hwndParent)
    {
        if (!SUCCEEDED(hr) && (hr != E_ABORT)) {
            pDisplayCopyError (hwndParent, hInstance, *pfError);
            SendMessage(hwndParent, WM_USER_CANCELLED, 0, 0);
        } else {
            SendMessage(hwndParent, WM_USER_FINISHED, 0, 0);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migoobe.h ===
#ifndef _MIGOOBE_H
#define _MIGOOBE_H

#include "cowsite.h"

class CMigWizEngine : public CObjectWithSite
                      ,public IMigrationWizardAuto
{
public:
    // Constructor
    CMigWizEngine();

    // Destructor
    virtual ~CMigWizEngine();

    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();


protected:
    // IMigrationWizardAuto
    virtual STDMETHODIMP CreateToolDisk(BSTR pszDrivePath, BSTR pszFilesPath, BSTR pszManifestPath);
    virtual STDMETHODIMP ApplySettings(BSTR pszStore);
    virtual STDMETHODIMP Cancel();

    // IDispatch
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR*  pctinfo);

protected:
    // helpers
    HRESULT _FireEvent(LPVOID lpParam, int iDISPID, DISPPARAMS* pdisp);
    HRESULT _FireProgress(LPVOID lpParam, BSTR pszMsg, int iDone, int iTotal);
    HRESULT _FireComplete(LPVOID lpParam, BSTR pszMsg);

    HRESULT _GetIDispatchStream (IStream** ppStream);

    HRESULT _CreateToolDiskThreadWorker();
    static DWORD WINAPI _CreateToolDiskThread (LPVOID lpParam);

    HRESULT _ApplySettingsThreadWorker();
    static DWORD WINAPI _ApplySettingsThread (LPVOID lpParam);


private:

    // Reference count
    long     m_cRef;
    BOOL     m_fUserApplying;
    BOOL     m_fInBackgroundThread; // only one background thread at a time, precludes more calls to CreateToolDisk, ApplySettings

    // _CreateToolDiskThread, _ApplySettingsThread
    BSTR     m_pszDrivePath;
    BSTR     m_pszFilesPath; 
    BSTR     m_pszManifestPath;
    BOOL     m_fCancelled;
    IStream* m_pDispatchStream;


    friend UINT ProgressCallback (LPVOID lpparam, UINT ui1, UINT ui2);
    friend VOID WINAPI ApplyProgressCallback (MIG_PROGRESSPHASE Phase, MIG_PROGRESSSTATE State, UINT uiWorkDone, UINT uiTotalWork, ULONG_PTR pArg);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migtask.h ===
#ifndef _MIGTASK_H_
#define _MIGTASK_H_

#include "ism.h"

typedef UINT(CALLBACK MESSAGECALLBACK2)(LPVOID lpParam, UINT ui1, UINT ui2);
typedef MESSAGECALLBACK2 *PMESSAGECALLBACK2;


HRESULT _CopyInfToDisk(LPCTSTR pctszDestPath, LPCTSTR pctszSourcePath, LPCTSTR pctszInfPath,
                       PMESSAGECALLBACK2 progressCallback, LPVOID lpParam,
                       HWND hwndProgessBar, HWND hwndParent, HINSTANCE hInstance,
                       BOOL* pfHasUserCancelled, DWORD* pfError);

BOOL CanCreateWizardDisk (PCTSTR SourcePath, PCTSTR InfPath);

HRESULT _DoCopy(LPTSTR tszTransportPath, HWND hwndProgress, HWND hwndPropSheet, BOOL* pfHasUserCancelled);

HRESULT _DoApply(LPTSTR tszTransportPath, HWND hwndProgress, HWND hwndPropSheet, BOOL* pfHasUserCancelled, PROGRESSBARFN pAltProgressFunction, ULONG_PTR puAltProgressParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migutil.cpp ===
#include <windowsx.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <stdio.h>
#include <winioctl.h>
#include "resource.h"
#include "migutil.h"
#include "migwiz.h"
#include <tlhelp32.h>
#include <tchar.h>
#include <shlobjp.h>

extern "C" {
#include "ism.h"
#include "modules.h"
}

PTSTR g_Explorer = NULL;

/////////////////
// definitions

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) ((sizeof(x)) / (sizeof(x[0])))
#endif

CRITICAL_SECTION g_csDialogCritSection;
BOOL g_fUberCancel;
BOOL g_LogOffSystem = FALSE;
BOOL g_RebootSystem = FALSE;
BOOL g_OFStatus = FALSE;

//////////////////////////////////////////////////////////////////////////////////////

LPSTR _ConvertToAnsi(UINT cp, LPCWSTR pcwszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPSTR       pszDup=NULL;

    // No Source
    if (pcwszSource == NULL)
        goto exit;

    // Length
    cchWide = lstrlenW(pcwszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, NULL, 0, NULL, NULL);

    // Error
    if (cchNarrow == 0)
        goto exit;

    // Alloc temp buffer
    pszDup = (LPSTR)LocalAlloc(LPTR, cchNarrow + 1);
    if (NULL == pszDup)
    {
        goto exit;
    }

    // Do the actual translation
    cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, pszDup, cchNarrow + 1, NULL, NULL);

    // Error
    if (cchNarrow == 0)
    {
        if (NULL != pszDup)
        {
            free(pszDup);
        }
        goto exit;
    }

exit:
    // Done
    return(pszDup);
}

//////////////////////////////////////////////////////////////////////////////////////

LPWSTR _ConvertToUnicode(UINT cp, LPCSTR pcszSource)
{
    // Locals
    HRESULT     hr=S_OK;
    INT         cchNarrow;
    INT         cchWide;
    LPWSTR      pwszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Length
    cchNarrow = lstrlenA(pcszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, NULL, 0);

    // Error
    if (cchWide == 0)
        goto exit;

    // Alloc temp buffer
    pwszDup = (LPWSTR)LocalAlloc(LPTR, cchWide * sizeof (WCHAR));
    if (NULL == pwszDup)
    {
        goto exit;
    }

    // Do the actual translation
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, pwszDup, cchWide+1);

    // Error
    if (cchWide == 0)
    {
        if (NULL != pwszDup)
        {
            free(pwszDup);
        }
        goto exit;
    }

exit:
    // Done
    return pwszDup;
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _SHUnicodeToAnsi(LPWSTR pwszIn, LPSTR pszOut, UINT cchOut)
{
    // Locals
    HRESULT     hr = E_INVALIDARG;
    INT         cchNarrow;
    INT         cchWide;

    // No Source
    if (pwszIn && pszOut)
    {
        // Length
        cchWide = lstrlenW(pwszIn) + 1;

        // Determine how much space is needed for translated widechar
        cchNarrow = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchWide, NULL, 0, NULL, NULL);

        // Error
        if (cchNarrow > 0)
        {

            // Do the actual translation
            cchNarrow = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchWide, pszOut, cchNarrow + 1, NULL, NULL);

            if (cchNarrow)
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _SHAnsiToUnicode(LPSTR pszIn, LPWSTR pwszOut, UINT cchOut)
{
    // Locals
    HRESULT     hr = E_INVALIDARG;
    INT         cchNarrow;
    INT         cchWide;

    // No Source
    if (pszIn && pwszOut)
    {

        // Length
        cchNarrow = lstrlenA(pszIn) + 1;

        // Determine how much space is needed for translated widechar
        cchWide = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszIn, cchNarrow, NULL, 0);

        // Error
        if (cchWide > 0)
        {

            // Do the actual translation
            cchWide = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszIn, cchNarrow, pwszOut, cchWide+1);

            if (cchWide > 0)
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE
#define _StrRetToBuf _StrRetToBufW
#else
#define _StrRetToBuf _StrRetToBufA
#endif

#ifdef NONAMELESSUNION
#define NAMELESS_MEMBER(member) DUMMYUNIONNAME.##member
#else
#define NAMELESS_MEMBER(member) member
#endif

#define STRRET_OLESTR  STRRET_WSTR          // same as STRRET_WSTR
#define STRRET_OFFPTR(pidl,lpstrret) ((LPSTR)((LPBYTE)(pidl)+(lpstrret)->NAMELESS_MEMBER(uOffset)))

STDAPI _StrRetToBufA(STRRET *psr, LPCITEMIDLIST pidl, LPSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pszStr = psr->pOleStr;   // temp copy because SHUnicodeToAnsi may overwrite buffer
            if (pszStr)
            {
                _SHUnicodeToAnsi(pszStr, pszBuf, cchBuf);
                CoTaskMemFree(pszStr);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;
                psr->cStr[0] = 0;

                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        StrCpyNA (pszBuf, psr->cStr, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            StrCpyNA (pszBuf, STRRET_OFFPTR(pidl, psr), cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

STDAPI _StrRetToBufW(STRRET *psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf)
{
    HRESULT hres = E_FAIL;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pwszTmp = psr->pOleStr;
            if (pwszTmp)
            {
                StrCpyNW(pszBuf, pwszTmp, cchBuf);
                CoTaskMemFree(pwszTmp);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;
                psr->cStr[0] = 0;

                hres = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        _SHAnsiToUnicode(psr->cStr, pszBuf, cchBuf);
        hres = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            _SHAnsiToUnicode(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hres = S_OK;
        }
        break;
    }

    if (FAILED(hres) && cchBuf)
        *pszBuf = 0;

    return hres;
}

//////////////////////////////////////////////////////////////////////////////////////


INT_PTR _ExclusiveDialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc)
{
    INT_PTR iRetVal = -1;
    EnterCriticalSection(&g_csDialogCritSection);
    if (!g_fUberCancel)
    {
        iRetVal = DialogBoxParam(hInstance, lpTemplate, hWndParent, lpDialogFunc, (LPARAM)hWndParent);
    }
    LeaveCriticalSection(&g_csDialogCritSection);
    return iRetVal;
}

int _ExclusiveMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)
{
    int iRetVal = -1;
    EnterCriticalSection(&g_csDialogCritSection);
    if (!g_fUberCancel)
    {
        iRetVal = MessageBox(hWnd, lpText, lpCaption, uType);
    }
    LeaveCriticalSection(&g_csDialogCritSection);
    return iRetVal;
}

//////////////////////////////////////////////////////////////////////////////////////

int _ComboBoxEx_AddString(HWND hwndBox, LPTSTR ptsz)
{
    COMBOBOXEXITEM item = {0};

    item.mask = CBEIF_TEXT;
    item.iItem = ComboBox_GetCount(hwndBox);
    item.pszText = ptsz;

    return (INT) SendMessage(hwndBox, CBEM_INSERTITEM, 0, (LONG_PTR)&item);
}

//////////////////////////////////////////////////////////////////////////////////////

int _ComboBoxEx_SetItemData(HWND hwndBox, UINT iDex, LPARAM lParam)
{
    COMBOBOXEXITEM item = {0};

    item.mask = CBEIF_LPARAM;
    item.iItem = iDex;
    item.lParam = lParam;

    return (INT) SendMessage(hwndBox, CBEM_SETITEM, 0, (LONG_PTR)&item);
}

//////////////////////////////////////////////////////////////////////////////////////

int _ComboBoxEx_SetIcon(HWND hwndBox, LPTSTR sz, UINT iDex)
{
    SHFILEINFO sfi = {0};
    COMBOBOXEXITEM item = {0};

    DWORD dwFlags = SHGFI_SMALLICON | SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES;

    if (SHGetFileInfo(sz, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), dwFlags)) {

        item.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
        item.iItem = iDex;
        item.iImage = sfi.iIcon;
        item.iSelectedImage = sfi.iIcon;

        return (INT) SendMessage(hwndBox, CBEM_SETITEM, 0, (LONG_PTR)&item);
    }
    return -1;
}

//////////////////////////////////////////////////////////////////////////////////////

int _GetRemovableDriveCount()
{
    int iCount = 0;
    TCHAR szDrive[4] = TEXT("A:\\");
    for (UINT uiCount = 0; uiCount < 26; uiCount++)
    {
        szDrive[0] = TEXT('A') + uiCount;

        if (DRIVE_REMOVABLE == GetDriveType(szDrive))
        {
            iCount++;
        }
    }

    return iCount;
}

//////////////////////////////////////////////////////////////////////////////////////

TCHAR _GetRemovableDrive(int iDex)
{
    int iCount = iDex;

    TCHAR szDrive[4] = TEXT("?:\\");
    for (UINT uiCount = 0; uiCount < 26; uiCount++)
    {
        szDrive[0] = TEXT('A') + uiCount;

        if (DRIVE_REMOVABLE == GetDriveType(szDrive))
        {
            if (!(iCount--))
            {
                return szDrive[0];
            }
        }
    }

    // ASSERT(FALSE);
    return '0'; // ERROR
}

//////////////////////////////////////////////////////////////////////////////////////

LPTSTR _GetRemovableDrivePretty(int iDex)
{
    HRESULT hr;
    LPTSTR pszRetVal = NULL;

    WCHAR wszDrive[4] = L"A:\\";
    wszDrive[0] = L'A' + _GetRemovableDrive(iDex) - TEXT('A');

    IShellFolder* psfDesktop;
    hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlDrive;
        hr = psfDesktop->ParseDisplayName(NULL, NULL, wszDrive, NULL, &pidlDrive, NULL);
        if (SUCCEEDED(hr))
        {
            STRRET strret;
            hr = psfDesktop->GetDisplayNameOf(pidlDrive, SHGDN_INFOLDER, &strret);
            if (SUCCEEDED(hr))
            {
                TCHAR szDisplayName[MAX_PATH];
                if (SUCCEEDED(_StrRetToBuf(&strret, pidlDrive, szDisplayName, ARRAYSIZE(szDisplayName))))
                {
                    pszRetVal = StrDup(szDisplayName);
                }
            }
        }
    }

    return pszRetVal;
}

//////////////////////////////////////////////////////////////////////////////////////

BOOL _IsRemovableOrCDDrive(TCHAR chDrive)
{
    UINT result = 0;
    if ( (chDrive >= TEXT('A') && chDrive <= TEXT('Z')) || (chDrive >= TEXT('a') && chDrive <= TEXT('z')))
    {
        TCHAR szDrive[4] = TEXT("A:\\");
        szDrive[0] = chDrive;
        result = GetDriveType (szDrive);
        return ((result == DRIVE_REMOVABLE) || (result == DRIVE_CDROM));
    }
    return FALSE;
}

BOOL _IsValidDrive(TCHAR chDrive)
{
    UINT result;

    if ( (chDrive >= TEXT('A') && chDrive <= TEXT('Z')) || (chDrive >= TEXT('a') && chDrive <= TEXT('z')))
    {
        TCHAR szDrive[4] = TEXT("A:\\");
        szDrive[0] = chDrive;
        result = GetDriveType(szDrive);
        if ((result == DRIVE_UNKNOWN) ||
            (result == DRIVE_NO_ROOT_DIR)
            ) {
            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

BOOL _IsValidStorePath(PCTSTR pszStore)
{
    return (((pszStore[1] == TEXT(':')) && (pszStore[2] == TEXT('\\')) && (_IsValidDrive (pszStore [0]))) ||
            ((pszStore[0] == TEXT('\\')) && (pszStore[1] == TEXT('\\')) && (_tcschr (pszStore + 2, TEXT('\\')) != NULL)));
}

BOOL _CreateFullDirectory(PCTSTR pszPath)
{
    TCHAR pathCopy [MAX_PATH];
    PTSTR p;
    BOOL b = TRUE;

    StrCpyN (pathCopy, pszPath, ARRAYSIZE(pathCopy));

    //
    // Advance past first directory
    //

    if (pathCopy[1] == TEXT(':') && pathCopy[2] == TEXT('\\')) {
        //
        // <drive>:\ case
        //

        p = _tcschr (&pathCopy[3], TEXT('\\'));

    } else if (pathCopy[0] == TEXT('\\') && pathCopy[1] == TEXT('\\')) {

        //
        // UNC case
        //

        p = _tcschr (pathCopy + 2, TEXT('\\'));
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
            if (p) {
                p = _tcsinc (p);
                if (p) {
                    p = _tcschr (p, TEXT('\\'));
                }
            }
        }

    } else {

        //
        // Relative dir case
        //

        p = _tcschr (pathCopy, TEXT('\\'));
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;
        b = CreateDirectory (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }

        if (!b) {
            break;
        }

        *p = TEXT('\\');
        p = _tcsinc (p);
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
        }
    }

    //
    // At last, make the FullPath directory
    //

    if (b) {
        b = CreateDirectory (pathCopy, NULL);

        if (!b && GetLastError() == ERROR_ALREADY_EXISTS) {
            b = TRUE;
        }
    }

    return b;
}

PTSTR
pGoBack (
    IN      PTSTR LastChar,
    IN      PTSTR FirstChar,
    IN      UINT NumWacks
    )
{
    LastChar = _tcsdec (FirstChar, LastChar);
    while (NumWacks && LastChar && (LastChar >= FirstChar)) {
        if (_tcsnextc (LastChar) == TEXT('\\')) {
            NumWacks --;
        }
        LastChar = _tcsdec (FirstChar, LastChar);
    }
    if (NumWacks) {
        return NULL;
    }
    return LastChar + 2;
}

UINT
pCountDots (
    IN      PCTSTR PathSeg
    )
{
    UINT numDots = 0;

    while (PathSeg && *PathSeg) {
        if (_tcsnextc (PathSeg) != TEXT('.')) {
            return 0;
        }
        numDots ++;
        PathSeg = _tcsinc (PathSeg);
    }
    return numDots;
}

VOID
_CutEndSpaces (
    IN      PTSTR String
    )
{
    PTSTR curr;
    PTSTR lastSpace = NULL;
    UINT ch;

    if (!String) {
        return;
    }

    curr = String;

    while (curr) {
        ch = _tcsnextc (curr);
        if (ch == 0) {
            break;
        }
#ifdef UNICODE
        if (_istspace ((wint_t)ch)) {
#else
        if (_istspace (ch)) {
#endif
            lastSpace = curr;
        } else {
            lastSpace = NULL;
        }
        curr = _tcsinc (curr);
    }
    if (lastSpace) {
        *lastSpace = 0;
    }
}

PCTSTR
_SanitizePath (
    IN      PCTSTR FileSpec
    )
{
    TCHAR pathSeg [MAX_PATH];
    PCTSTR wackPtr;
    UINT dotNr;
    PTSTR newPath = (PTSTR)IsmDuplicateString (FileSpec);
    PTSTR newPathPtr = newPath;
    BOOL firstPass = TRUE;
    UINT max;
    BOOL removeLastWack = FALSE;

    do {
        removeLastWack = FALSE;

        ZeroMemory (pathSeg, sizeof (pathSeg));

        wackPtr = _tcschr (FileSpec, TEXT('\\'));

        if (wackPtr) {
            if (firstPass && (wackPtr == FileSpec)) {
                // this one starts with a wack, let's see if we have double wacks
                wackPtr = _tcsinc (wackPtr);
                if (!wackPtr) {
                    IsmReleaseMemory (newPath);
                    return NULL;
                }
                if (_tcsnextc (wackPtr) == TEXT('\\')) {
                    // this one starts with a double wack
                    wackPtr = _tcsinc (wackPtr);
                    if (!wackPtr) {
                        IsmReleaseMemory (newPath);
                        return NULL;
                    }
                    wackPtr = _tcschr (wackPtr, TEXT('\\'));
                } else {
                    wackPtr = _tcschr (wackPtr, TEXT('\\'));
                }
            }
            firstPass = FALSE;
            if (wackPtr) {
                max = (wackPtr - FileSpec) * sizeof (TCHAR);
                CopyMemory (pathSeg, FileSpec, min (MAX_PATH * sizeof (TCHAR), max));
                FileSpec = _tcsinc (wackPtr);
            } else {
                max = _tcslen (FileSpec) * sizeof (TCHAR);
                CopyMemory (pathSeg, FileSpec, min (MAX_PATH * sizeof (TCHAR), max));
            }
            _CutEndSpaces (pathSeg);
        } else {
            max = _tcslen (FileSpec) * sizeof (TCHAR);
            if (max == 0) {
                removeLastWack = TRUE;
            }
            CopyMemory (pathSeg, FileSpec, min (MAX_PATH * sizeof (TCHAR), max));
        }

        if (*pathSeg) {
            dotNr = pCountDots (pathSeg);
            if (dotNr>1) {

                newPathPtr = pGoBack (newPathPtr, newPath, dotNr);

                if (newPathPtr == NULL) {
                    IsmReleaseMemory (newPath);
                    return NULL;
                }
            } else if (dotNr != 1) {
                _tcscpy (newPathPtr, pathSeg);
                newPathPtr = _tcschr (newPathPtr, 0);
                if (wackPtr) {
                    *newPathPtr = TEXT('\\');
                    //we increment this because we know that \ is a single byte character.
                    newPathPtr ++;
                }
            } else {
                removeLastWack = TRUE;
            }
        }
    } while (wackPtr);

    if (removeLastWack && (newPathPtr > newPath)) {
        newPathPtr --;
    }
    *newPathPtr = 0;

    return newPath;
}

BOOL _IsValidStore(LPTSTR pszStore, BOOL bCreate, HINSTANCE hinst, HWND hwnd)
{
    TCHAR szSerialStr[] = TEXT("COM");
    TCHAR szParallelStr[] = TEXT("LPT");
    PTSTR lpExpStore;
    PCTSTR sanitizedStore;
    BOOL fValid = FALSE;
    //
    //  Skip past leading space, since PathIsDirectory() on Win9x
    //  incorrectly assumes spaces are a valid dir.
    //

    while (_istspace (*pszStore))
        pszStore++;

    //
    //  No relative paths allowed.
    //

    if (*pszStore == TEXT('.'))
        return FALSE;

    if ((_tcsnicmp (pszStore, szSerialStr, (sizeof (szSerialStr) / sizeof (TCHAR)) - 1) == 0) ||
        (_tcsnicmp (pszStore, szParallelStr, (sizeof (szParallelStr) / sizeof (TCHAR)) - 1) == 0)
        ) {
        return TRUE;
    }

    lpExpStore = (PTSTR)IsmExpandEnvironmentString (IsmGetRealPlatform (), S_SYSENVVAR_GROUP, pszStore, NULL);

    sanitizedStore = _SanitizePath (lpExpStore);

    if (sanitizedStore) {

        if (PathIsDirectory(sanitizedStore)) // if a normal directory
        {
            fValid = TRUE;
        }
        else if (lstrlen(sanitizedStore) == 3 && sanitizedStore[1] == TEXT(':') && sanitizedStore[2] == TEXT('\\') && _IsRemovableOrCDDrive(sanitizedStore[0]))
        {
            fValid = TRUE;
        }
        else if (lstrlen(sanitizedStore) == 2 && sanitizedStore[1] == TEXT(':') && _IsRemovableOrCDDrive(sanitizedStore[0]))
        {
            fValid = TRUE;
        }
        else
        {
            if ((bCreate) && (_IsValidStorePath (sanitizedStore))) {
                TCHAR szTitle[MAX_LOADSTRING];
                TCHAR szLoadString[MAX_LOADSTRING];
                LoadString(hinst, IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                LoadString(hinst, IDS_ASKCREATEDIR, szLoadString, ARRAYSIZE(szLoadString));
                if (_ExclusiveMessageBox(hwnd, szLoadString, szTitle, MB_YESNO) == IDYES) {
                    if (_CreateFullDirectory (sanitizedStore)) {
                        fValid = TRUE;
                    }
                }
            }
        }

        if (fValid) {
            _tcsncpy (pszStore, sanitizedStore, MAX_PATH);
        }

        IsmReleaseMemory (sanitizedStore);
        sanitizedStore = NULL;
    }

    IsmReleaseMemory (lpExpStore);

    return fValid;
}

//////////////////////////////////////////////////////////////////////////////////////

INT _ComboBoxEx_AddDrives(HWND hwndBox)
{
    INT result = -1;

    ComboBox_ResetContent(hwndBox);

    WCHAR wszDrive[4] = L"A:\\";
    TCHAR szDrive[4] = TEXT("A:\\");

    for (UINT uiCount = 0; uiCount < (UINT)_GetRemovableDriveCount(); uiCount++)
    {
        szDrive[0] = _GetRemovableDrive(uiCount);

        int iDex = _ComboBoxEx_AddString(hwndBox, _GetRemovableDrivePretty(uiCount));
        _ComboBoxEx_SetIcon(hwndBox, szDrive, iDex);
        _ComboBoxEx_SetItemData(hwndBox, iDex, (LPARAM)StrDup(szDrive));
        result = 0;
    }
    ComboBox_SetCurSel(hwndBox, result);
    return result;
}

//////////////////////////////////////////////////////////////////////////////////////

BOOL
pIsComPortAccessible (
    PCTSTR ComPort
    )
{
    HANDLE comPortHandle = NULL;

    comPortHandle = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (comPortHandle != INVALID_HANDLE_VALUE) {
        CloseHandle (comPortHandle);
        return TRUE;
    }
    return FALSE;
}

INT _ComboBoxEx_AddCOMPorts(HWND hwndBox, INT SelectedPort)
{
    INT iDex;
    INT index = 1;
    INT added = -1;
    TCHAR comPort [] = TEXT("COM0");

    if (hwndBox) {
        // clear the combo box content
        SendMessage (hwndBox, CB_RESETCONTENT, 0, 0);
    }

    while (index < 10) {
        comPort [ARRAYSIZE(comPort) - 2] ++;
        if (pIsComPortAccessible (comPort)) {
            if (hwndBox) {
                iDex = SendMessage (hwndBox, CB_ADDSTRING, 0, (LPARAM)comPort);
                SendMessage (hwndBox, CB_SETITEMDATA, (WPARAM)iDex, (LPARAM)StrDup(comPort));
            }
            added ++;
        }
        index ++;
    }
    if (added == -1) {
        return -1;
    }
    if ((added >= SelectedPort) && (SelectedPort != -1)) {
        if (hwndBox) {
            ComboBox_SetCurSel(hwndBox, SelectedPort);
        }
        return SelectedPort;
    }
    if (hwndBox) {
        // We want nothing to be selected in this combo box, this
        // is intentional.
        ComboBox_SetCurSel(hwndBox, -1);
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////

int _GetIcon(LPTSTR psz)
{
    SHFILEINFO sfi = {0};

    SHGetFileInfo(psz, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), SHGFI_SMALLICON | SHGFI_SYSICONINDEX);

    return sfi.iIcon;
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _ListView_AddDrives(HWND hwndList, LPTSTR pszNetworkName)
{
    HRESULT hr = E_FAIL;

    if (ListView_DeleteAllItems(hwndList))
    {
        LVITEM item = {0};
        item.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_TEXT;

        if (pszNetworkName)
        {
            item.iItem = 0; // first item
            item.pszText = pszNetworkName;
            item.iImage = 0; // ISSUE: 0 is icon for sharing, is there a better way to do this?
            item.lParam = NULL;
            ListView_InsertItem(hwndList, &item);
        }

        IShellFolder* psfDesktop;
        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            WCHAR wszDrive[4] = L"?:\\";
            TCHAR tszDrive[4] = TEXT("?:\\");
            for (int iDrive = 0; iDrive < _GetRemovableDriveCount(); iDrive++)
            {
                tszDrive[0] = _GetRemovableDrive(iDrive);
                wszDrive[0] = L'A' + tszDrive[0] - TEXT('A');

                LPITEMIDLIST pidlDrive;
                hr = psfDesktop->ParseDisplayName(NULL, NULL, wszDrive, NULL, &pidlDrive, NULL);
                if (SUCCEEDED(hr))
                {
                    STRRET strret;
                    hr = psfDesktop->GetDisplayNameOf(pidlDrive, SHGDN_INFOLDER, &strret);
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szDisplayName[MAX_PATH];
                        hr = _StrRetToBuf(&strret, pidlDrive, szDisplayName, ARRAYSIZE(szDisplayName));
                        if (SUCCEEDED(hr))
                        {
                            item.iItem = 27; // this will force adding at the end
                            item.pszText = szDisplayName;
                            item.iImage = _GetIcon(tszDrive);
                            item.lParam = (LPARAM)StrDup(tszDrive);

                            ListView_InsertItem(hwndList, &item);
                        }
                    }
                }
            }
        }
    }
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _CreateAnimationCtrl(HWND hwndDlg, HINSTANCE hinst, UINT idMarker, UINT idAnim, UINT idAvi, HWND* pHwndAnim)
{
    HWND hwndAnim = NULL;
    RECT rc, rc1, rc2, rc3;
    POINT pt31, pt32;
    LONG tempXY = 0;
    PWORD tempX, tempY;
    POINT pt;

    // Create the animation control.
    hwndAnim = Animate_Create(hwndDlg, (ULONG_PTR) idAnim, WS_CHILD | ACS_TRANSPARENT, hinst);

    // Get the screen coordinates of the specified control button.
    GetWindowRect(GetDlgItem(hwndDlg, idMarker), &rc);

    // Get the screen coordinates of the specified control button.
    GetWindowRect(hwndAnim, &rc1);

    // Convert the coordinates of the lower-left corner to
    // client coordinates.
    pt.x = rc.left;
    pt.y = rc.bottom;
    ScreenToClient(hwndDlg, &pt);

    // Position the animation control below the Stop button.
    SetWindowPos(hwndAnim, 0, pt.x, pt.y + 20, 0, 0, SWP_NOZORDER | SWP_NOSIZE);

    // Get the screen coordinates of the specified control button.
    GetWindowRect(hwndAnim, &rc2);

    // Open the AVI clip, and show the animation control.
    Animate_Open(hwndAnim, MAKEINTRESOURCE(idAvi));
    ShowWindow(hwndAnim, SW_SHOW);
    Animate_Play(hwndAnim, 0, -1, -1);

    // Get the screen coordinates of the specified control button.
    GetWindowRect(hwndAnim, &rc3);

    pt31.x = rc3.left;
    pt31.y = rc3.top;
    pt32.x = rc3.right;
    pt32.y = rc3.bottom;
    ScreenToClient(hwndDlg, &pt31);
    ScreenToClient(hwndDlg, &pt32);
    rc3.left = pt31.x;
    rc3.top = pt31.y;
    rc3.right = pt32.x;
    rc3.bottom = pt32.y;

    tempXY = GetDialogBaseUnits ();
    tempX = (PWORD)(&tempXY);
    tempY = tempX + 1;

    rc3.left = MulDiv (rc3.left, 4, *tempX);
    rc3.right = MulDiv (rc3.right, 4, *tempX);
    rc3.top = MulDiv (rc3.top, 8, *tempY);
    rc3.bottom = MulDiv (rc3.bottom, 8, *tempY);

    *pHwndAnim = hwndAnim;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////

#define USER_SHELL_FOLDERS                                                                                               \
    DEFMAC(CSIDL_ADMINTOOLS, TEXT("Administrative Tools"), -1, IDS_CSIDL_ADMINTOOLS)                                     \
    DEFMAC(CSIDL_ALTSTARTUP, TEXT("AltStartup"), -1, IDS_CSIDL_ALTSTARTUP)                                               \
    DEFMAC(CSIDL_APPDATA, TEXT("AppData"), -1, IDS_CSIDL_APPDATA)                                                        \
    DEFMAC(CSIDL_BITBUCKET, TEXT("RecycleBinFolder"), -1, IDS_CSIDL_BITBUCKET)                                           \
    DEFMAC(CSIDL_CONNECTIONS, TEXT("ConnectionsFolder"), -1, IDS_CSIDL_CONNECTIONS)                                      \
    DEFMAC(CSIDL_CONTROLS, TEXT("ControlPanelFolder"), -1, IDS_CSIDL_CONTROLS)                                           \
    DEFMAC(CSIDL_COOKIES, TEXT("Cookies"), -1, IDS_CSIDL_COOKIES)                                                        \
    DEFMAC(CSIDL_DESKTOP, TEXT("Desktop"), -1, IDS_CSIDL_DESKTOP)                                                        \
    DEFMAC(CSIDL_DESKTOPDIRECTORY, TEXT("Desktop"), -1, IDS_CSIDL_DESKTOPDIRECTORY)                                      \
    DEFMAC(CSIDL_DRIVES, TEXT("DriveFolder"), -1, IDS_CSIDL_DRIVES)                                                      \
    DEFMAC(CSIDL_FAVORITES, TEXT("Favorites"), -1, IDS_CSIDL_FAVORITES)                                                  \
    DEFMAC(CSIDL_FONTS, TEXT("Fonts"), -1, IDS_CSIDL_FONTS)                                                              \
    DEFMAC(CSIDL_HISTORY, TEXT("History"), -1, IDS_CSIDL_HISTORY)                                                        \
    DEFMAC(CSIDL_INTERNET, TEXT("InternetFolder"), -1, IDS_CSIDL_INTERNET)                                               \
    DEFMAC(CSIDL_INTERNET_CACHE, TEXT("Cache"), -1, IDS_CSIDL_INTERNET_CACHE)                                            \
    DEFMAC(CSIDL_LOCAL_APPDATA, TEXT("Local AppData"), -1, IDS_CSIDL_LOCAL_APPDATA)                                      \
    DEFMAC(CSIDL_MYDOCUMENTS, TEXT("My Documents"), -1, IDS_CSIDL_MYDOCUMENTS)                                           \
    DEFMAC(CSIDL_MYMUSIC, TEXT("My Music"), -1, IDS_CSIDL_MYMUSIC)                                                       \
    DEFMAC(CSIDL_MYPICTURES, TEXT("My Pictures"), -1, IDS_CSIDL_MYPICTURES)                                              \
    DEFMAC(CSIDL_MYVIDEO, TEXT("My Video"), -1, IDS_CSIDL_MYVIDEO)                                                       \
    DEFMAC(CSIDL_NETHOOD, TEXT("NetHood"), -1, IDS_CSIDL_NETHOOD)                                                        \
    DEFMAC(CSIDL_NETWORK, TEXT("NetworkFolder"), -1, IDS_CSIDL_NETWORK)                                                  \
    DEFMAC(CSIDL_PERSONAL, TEXT("Personal"), -1, IDS_CSIDL_PERSONAL)                                                     \
    DEFMAC(CSIDL_PROFILE, TEXT("Profile"), -1, IDS_CSIDL_PROFILE)                                                        \
    DEFMAC(CSIDL_PROGRAM_FILES, TEXT("ProgramFiles"), -1, IDS_CSIDL_PROGRAM_FILES)                                       \
    DEFMAC(CSIDL_PROGRAM_FILESX86, TEXT("ProgramFilesX86"), -1, IDS_CSIDL_PROGRAM_FILESX86)                              \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMON, TEXT("CommonProgramFiles"), -1, IDS_CSIDL_PROGRAM_FILES_COMMON)                   \
    DEFMAC(CSIDL_PROGRAM_FILES_COMMONX86, TEXT("CommonProgramFilesX86"), -1, IDS_CSIDL_PROGRAM_FILES_COMMONX86)          \
    DEFMAC(CSIDL_PROGRAMS, TEXT("Programs"), -1, IDS_CSIDL_PROGRAMS)                                                     \
    DEFMAC(CSIDL_RECENT, TEXT("Recent"), -1, IDS_CSIDL_RECENT)                                                           \
    DEFMAC(CSIDL_SENDTO, TEXT("SendTo"), -1, IDS_CSIDL_SENDTO)                                                           \
    DEFMAC(CSIDL_STARTMENU, TEXT("Start Menu"), -1, IDS_CSIDL_STARTMENU)                                                 \
    DEFMAC(CSIDL_STARTUP, TEXT("Startup"), -1, IDS_CSIDL_STARTUP)                                                        \
    DEFMAC(CSIDL_SYSTEM, TEXT("System"), -1, IDS_CSIDL_SYSTEM)                                                           \
    DEFMAC(CSIDL_SYSTEMX86, TEXT("SystemX86"), -1, IDS_CSIDL_SYSTEMX86)                                                  \
    DEFMAC(CSIDL_TEMPLATES, TEXT("Templates"), -1, IDS_CSIDL_TEMPLATES)                                                  \
    DEFMAC(CSIDL_WINDOWS, TEXT("Windows"), -1, IDS_CSIDL_WINDOWS)                                                        \

#define COMMON_SHELL_FOLDERS                                                                                                \
    DEFMAC(CSIDL_COMMON_ADMINTOOLS, TEXT("Common Administrative Tools"), CSIDL_ADMINTOOLS, IDS_CSIDL_COMMON_ADMINTOOLS)     \
    DEFMAC(CSIDL_COMMON_ALTSTARTUP, TEXT("Common AltStartup"), CSIDL_ALTSTARTUP, IDS_CSIDL_COMMON_ALTSTARTUP)               \
    DEFMAC(CSIDL_COMMON_APPDATA, TEXT("Common AppData"), CSIDL_APPDATA, IDS_CSIDL_COMMON_APPDATA)                           \
    DEFMAC(CSIDL_COMMON_DESKTOPDIRECTORY, TEXT("Common Desktop"), CSIDL_DESKTOP, IDS_CSIDL_COMMON_DESKTOPDIRECTORY)         \
    DEFMAC(CSIDL_COMMON_DOCUMENTS, TEXT("Common Documents"), CSIDL_PERSONAL, IDS_CSIDL_COMMON_DOCUMENTS)                    \
    DEFMAC(CSIDL_COMMON_FAVORITES, TEXT("Common Favorites"), CSIDL_FAVORITES, IDS_CSIDL_COMMON_FAVORITES)                   \
    DEFMAC(CSIDL_COMMON_PROGRAMS, TEXT("Common Programs"), CSIDL_PROGRAMS, IDS_CSIDL_COMMON_PROGRAMS)                       \
    DEFMAC(CSIDL_COMMON_STARTMENU, TEXT("Common Start Menu"), CSIDL_STARTMENU, IDS_CSIDL_COMMON_STARTMENU)                  \
    DEFMAC(CSIDL_COMMON_STARTUP, TEXT("Common Startup"), CSIDL_STARTUP, IDS_CSIDL_COMMON_STARTUP)                           \
    DEFMAC(CSIDL_COMMON_TEMPLATES, TEXT("Common Templates"), CSIDL_TEMPLATES, IDS_CSIDL_COMMON_TEMPLATES)                   \

//
// This is the structure used for handling CSIDLs
//
typedef struct {
    INT DirId;
    PCTSTR DirStr;
    INT AltDirId;
    UINT DirResId;
    BOOL DirUser;
} CSIDL_STRUCT, *PCSIDL_STRUCT;

#define DEFMAC(did,dstr,adid,rid) {did,dstr,adid,rid,TRUE},
static CSIDL_STRUCT g_UserShellFolders[] = {
                              USER_SHELL_FOLDERS
                              {-1, NULL, -1, 0, FALSE}
                              };
#undef DEFMAC
#define DEFMAC(did,dstr,adid,rid) {did,dstr,adid,rid,FALSE},
static CSIDL_STRUCT g_CommonShellFolders[] = {
                              COMMON_SHELL_FOLDERS
                              {-1, NULL, -1, 0, FALSE}
                              };
#undef DEFMAC


PTSTR
pFindSfPath (
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder
    )
{
    HKEY key = NULL;
    PTSTR data;
    PTSTR expData;
    DWORD expDataSize;
    PTSTR result = NULL;
    LONG lResult;
    DWORD dataType;
    DWORD dataSize;

    if (!result) {
        if (UserFolder) {
            lResult = RegOpenKey (HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"), &key);
        } else {
            lResult = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"), &key);
        }

        if ((lResult == ERROR_SUCCESS) && key) {

            dataSize = 0;
            lResult = RegQueryValueEx (key, FolderStr, NULL, &dataType, NULL, &dataSize);
            if ((lResult == ERROR_SUCCESS) &&
                ((dataType == REG_SZ) || (dataType == REG_EXPAND_SZ))
                ) {
                data = (PTSTR)LocalAlloc (LPTR, dataSize);
                if (data) {
                    lResult = RegQueryValueEx (key, FolderStr, NULL, &dataType, (LPBYTE)data, &dataSize);
                    if (lResult == ERROR_SUCCESS) {
                        expDataSize = ExpandEnvironmentStrings (data, NULL, 0);
                        if (expDataSize) {
                            expData = (PTSTR)LocalAlloc (LPTR, (expDataSize + 1) * sizeof (TCHAR));
                            expDataSize = ExpandEnvironmentStrings (data, expData, expDataSize);
                            if (!expDataSize) {
                                LocalFree (expData);
                                expData = NULL;
                            }
                        }
                        if (expDataSize) {
                            result = expData;
                            LocalFree (data);
                        } else {
                            result = data;
                        }
                    } else {
                        LocalFree (data);
                    }
                }
            }

            CloseHandle (key);
        }
    }

    if (result && !(*result)) {
        LocalFree (result);
        result = NULL;
    }

    if (!result) {
        if (UserFolder) {
            lResult = RegOpenKey (HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), &key);
        } else {
            lResult = RegOpenKey (HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), &key);
        }

        if ((lResult == ERROR_SUCCESS) && key) {

            dataSize = 0;
            lResult = RegQueryValueEx (key, FolderStr, NULL, &dataType, NULL, &dataSize);
            if ((lResult == ERROR_SUCCESS) &&
                ((dataType == REG_SZ) || (dataType == REG_EXPAND_SZ))
                ) {
                data = (PTSTR)LocalAlloc (LPTR, dataSize);
                if (data) {
                    lResult = RegQueryValueEx (key, FolderStr, NULL, &dataType, (LPBYTE)data, &dataSize);
                    if (lResult == ERROR_SUCCESS) {
                        expDataSize = ExpandEnvironmentStrings (data, NULL, 0);
                        if (expDataSize) {
                            expData = (PTSTR)LocalAlloc (LPTR, (expDataSize + 1) * sizeof (TCHAR));
                            expDataSize = ExpandEnvironmentStrings (data, expData, expDataSize);
                            if (!expDataSize) {
                                LocalFree (expData);
                                expData = NULL;
                            }
                        }
                        if (expDataSize) {
                            result = expData;
                            LocalFree (data);
                        } else {
                            result = data;
                        }
                    } else {
                        LocalFree (data);
                    }
                }
            }

            CloseHandle (key);
        }
    }

    if (result && !(*result)) {
        LocalFree (result);
        result = NULL;
    }

    return (PTSTR) result;
}

PTSTR
GetShellFolderPath (
    IN      INT Folder,
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder,
    OUT     LPITEMIDLIST *pidl  //OPTIONAL
    )
{
    PTSTR result = NULL;
    HRESULT hResult;
    BOOL b;
    LPITEMIDLIST localpidl = NULL;
    IMalloc *mallocFn;

    if (pidl) {
        *pidl = NULL;
    }

    hResult = SHGetMalloc (&mallocFn);
    if (hResult != S_OK) {
        return NULL;
    }

    hResult = SHGetSpecialFolderLocation (NULL, Folder, &localpidl);

    if (hResult == S_OK) {

        result = (PTSTR) LocalAlloc (LPTR, MAX_PATH);

        if (result) {

            b = SHGetPathFromIDList (localpidl, result);

            if (b) {
                if (pidl) {
                    *pidl = localpidl;
                }
                return result;
            }

            LocalFree (result);
            result = NULL;
        }
    }

    if (FolderStr) {
        result = pFindSfPath (FolderStr, UserFolder);
    }

    mallocFn->Free (localpidl);
    localpidl = NULL;

    return result;
}

typedef HRESULT (WINAPI SHBINDTOPARENT)(LPCITEMIDLIST pidl, REFIID riid, VOID **ppv, LPCITEMIDLIST *ppidlLast);
typedef SHBINDTOPARENT *PSHBINDTOPARENT;

HRESULT
OurSHBindToParent (
    IN      LPCITEMIDLIST pidl,
    IN      REFIID riid,
    OUT     VOID **ppv,
    OUT     LPCITEMIDLIST *ppidlLast
    )
{
    HRESULT hr = E_FAIL;
    HMODULE lib;
    PSHBINDTOPARENT shBindToParent = NULL;

    lib = LoadLibrary (TEXT("shell32.dll"));
    if (lib) {
        shBindToParent = (PSHBINDTOPARENT)GetProcAddress (lib, "SHBindToParent");
        if (shBindToParent) {
            hr = shBindToParent (pidl, riid, ppv, ppidlLast);
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// if pctszPath corresponds to the path of one of the CSIDL_XXXX entries, then return
//   its "pretty name", else return the standard path name

HRESULT _GetPrettyFolderName (HINSTANCE Instance, BOOL fNT4, LPCTSTR pctszPath, LPTSTR ptszName, UINT cchName)
{
    UINT itemsIndex = 0;
    PCSIDL_STRUCT items[2] = {g_UserShellFolders, g_CommonShellFolders};
    PCSIDL_STRUCT p;
    IMalloc *mallocFn;
    LPITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlLast = NULL;
    IShellFolder* psf = NULL;
    HRESULT hr = S_OK;
    PTSTR szPath = NULL;
    PTSTR szAltPath = NULL;
    STRRET strret;
    TCHAR szDisplay1[2048];
    TCHAR szDisplay2[2048];
    BOOL checkAlternate = FALSE;
    BOOL found = FALSE;

    // First, we look to find the corresponding CSIDL if we can
    // If we can't we will just copy the IN path to the OUT path.

    for (itemsIndex = 0; itemsIndex < 2; itemsIndex ++) {

        p = items [itemsIndex];

        while (!found && (p->DirId >= 0)) {

            szDisplay1 [0] = 0;
            szDisplay2 [0] = 0;
            pidl = NULL;
            pidlLast = NULL;
            szPath = NULL;
            psf = NULL;

            szPath = GetShellFolderPath (p->DirId, p->DirStr, p->DirUser, &pidl);

            if (szPath && (0 == StrCmpI(pctszPath, szPath))) {

                found = TRUE;

                if (pidl) {

                    hr = OurSHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);

                    if (SUCCEEDED(hr) && psf && pidlLast) {

                        hr = psf->GetDisplayNameOf (pidlLast, SHGDN_NORMAL, &strret);

                        if (SUCCEEDED (hr)) {

                            hr = _StrRetToBuf (&strret, pidlLast, szDisplay1, ARRAYSIZE(szDisplay1));

                            if (!SUCCEEDED (hr) || (0 == StrCmpI (szDisplay1, pctszPath))) {
                                // Failed or we just got back the complete folder spec. We don't need that!
                                szDisplay1 [0] = 0;
                            }
                        }
                    }

                    if (psf) {
                        psf->Release ();
                        psf = NULL;
                    }
                }
            }

            if (pidl) {
                hr = SHGetMalloc (&mallocFn);
                if (SUCCEEDED (hr)) {
                    mallocFn->Free (pidl);
                    pidl = NULL;
                }
            }

            if (szPath) {
                LocalFree (szPath);
                szPath = NULL;
            }

            if (szDisplay1 [0] && (p->AltDirId >= 0)) {

                szPath = GetShellFolderPath (p->AltDirId, NULL, TRUE, &pidl);

                if (pidl && szPath) {

                    hr = OurSHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);

                    if (SUCCEEDED(hr) && psf && pidlLast) {

                        hr = psf->GetDisplayNameOf (pidlLast, SHGDN_INFOLDER, &strret);

                        if (SUCCEEDED (hr)) {

                            hr = _StrRetToBuf (&strret, pidlLast, szDisplay2, ARRAYSIZE(szDisplay2));

                            if (!SUCCEEDED (hr)) {
                                szDisplay2 [0] = 0;
                            }
                        }
                    }

                    if (psf) {
                        psf->Release ();
                        psf = NULL;
                    }

                }

                if (pidl) {
                    hr = SHGetMalloc (&mallocFn);
                    if (SUCCEEDED (hr)) {
                        mallocFn->Free (pidl);
                        pidl = NULL;
                    }
                }

                if (szPath) {
                    LocalFree (szPath);
                    szPath = NULL;
                }

            }

            if (found) {

                if ((!szDisplay1 [0]) || (0 == StrCmpI (szDisplay1, szDisplay2))) {
                    // we need to use the resource ID
                    if (!LoadString (Instance, p->DirResId, ptszName, cchName)) {
                        StrCpyN (ptszName, pctszPath, cchName);
                    }
                } else {
                    StrCpyN (ptszName, szDisplay1, cchName);
                }

                break;
            }

            p ++;
        }

        if (found) {
            break;
        }
    }

    if (!found) {
        StrCpyN (ptszName, pctszPath, cchName);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////

VOID _PopulateTree (HWND hwndTree, HTREEITEM hti, LPTSTR ptsz, UINT cch,
                    HRESULT (*fct)(HINSTANCE, BOOL, LPCTSTR, LPTSTR, UINT cchName),
                    DWORD dwFlags, HINSTANCE Instance, BOOL fNT4)
{
    if (hwndTree && hti && ptsz)
    {
        // ISSUE: resolve flickering, this doesn't fix it
        EnableWindow (hwndTree, FALSE);

        TCHAR szDisplay[2048];
        TCHAR szClean[2048];
        TCHAR* ptszPtr = ptsz;
        TCHAR* ptszParam = NULL;

        while (*ptsz && (ptszPtr < (ptsz + cch)))
        {
            szDisplay[0] = 0;
            BOOL fOK = TRUE;

            LV_DATASTRUCT* plvds = (LV_DATASTRUCT*)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
            if (plvds)
            {
                plvds->fOverwrite = FALSE;

                StrCpyN(szClean, ptszPtr, ARRAYSIZE(szClean));

                LPITEMIDLIST pidl = NULL;
                // if this is a filetype, restore the "*." before it, add pretty name
                if (dwFlags == POPULATETREE_FLAGS_FILETYPES)
                {
                    TCHAR szPretty[2048];
                    if (FAILED(_GetPrettyTypeName(szClean, szPretty, ARRAYSIZE(szPretty))))
                    {
                        szPretty[0] = 0;
                    }
                    memmove(szClean + 2, szClean, sizeof(szClean) - (2 * sizeof(TCHAR)));
                    *szClean = TEXT('*');
                    *(szClean + 1) = TEXT('.');
                    if (szPretty[0])
                    {
                        lstrcpy(szClean + lstrlen(szClean), TEXT(" - "));
                        lstrcpy(szClean + lstrlen(szClean), szPretty);
                    }
                }

                if (fOK)
                {
                    if (szDisplay[0]) // if we already have a display name, use that and store the clean name
                    {
                        plvds->pszPureName = StrDup(szClean);
                    }
                    else
                    {
                        if (fct) // if there's a pretty-fying function, use it
                        {
                            fct(Instance, fNT4, szClean, szDisplay, ARRAYSIZE(szDisplay));
                            plvds->pszPureName = StrDup(szClean);
                        }
                        else if (POPULATETREE_FLAGS_FILETYPES) // ISSUE: this is hacky, clean this up
                        {
                            StrCpyN(szDisplay, szClean, ARRAYSIZE(szDisplay));
                            plvds->pszPureName = StrDup(ptsz);
                        }
                        else
                        {
                            StrCpyN(szDisplay, szClean, ARRAYSIZE(szDisplay));
                        }
                    }

                    TV_INSERTSTRUCT tis = {0};
                    tis.hParent = hti;
                    tis.hInsertAfter = TVI_SORT;
                    tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
                    tis.item.lParam = (LPARAM)plvds;

                    tis.item.pszText = szDisplay;

                    TreeView_InsertItem(hwndTree, &tis);
                }

                ptszPtr += (1 + lstrlen(ptszPtr));
            }
        }
        EnableWindow (hwndTree, TRUE);
    }
}

//////////////////////////////////////////////////////////////////////////////////////

UINT _ListView_InsertItem(HWND hwndList, LPTSTR ptsz)
{
    LVITEM lvitem = {0};

    lvitem.mask = LVIF_TEXT;
    lvitem.iItem = ListView_GetItemCount(hwndList);
    lvitem.pszText = ptsz;

    return ListView_InsertItem(hwndList, &lvitem);
}

//////////////////////////////////////////////////////////////////////////////////////

HRESULT _GetPrettyTypeName(LPCTSTR pctszType, LPTSTR ptszPrettyType, UINT cchPrettyType)
{
    HRESULT hr = E_FAIL;
    BOOL found = FALSE;

    TCHAR tszTypeName[MAX_PATH];
    LPTSTR ptszType;

    TCHAR szTypeName[MAX_PATH];
    DWORD cchTypeName = MAX_PATH;
    TCHAR szCmdLine[MAX_PATH];
    DWORD cchCmdLine = MAX_PATH;
    DWORD dwType = REG_SZ;

    if (TEXT('*') == pctszType[0] && TEXT('.') == pctszType[1])
    {
        ptszType = (LPTSTR)pctszType + 1;
    }
    else
    {
        tszTypeName[0] = TEXT('.');
        lstrcpy(tszTypeName + 1, pctszType);
        ptszType = tszTypeName;
    }

    // let's find the progId
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, ptszType, NULL, &dwType, szTypeName, &cchTypeName))
    {
        LONG result;
        DWORD cchPrettyName = cchPrettyType;
        PTSTR cmdPtr, resIdPtr;
        INT resId;
        HMODULE dllModule;

        // let's see if this progId has the FriendlyTypeName value name
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szTypeName, TEXT("FriendlyTypeName"), &dwType, szCmdLine, &cchCmdLine)) {

            cmdPtr = szCmdLine;
            if (_tcsnextc (cmdPtr) == TEXT('@')) {
                cmdPtr = _tcsinc (cmdPtr);
            }
            if (cmdPtr) {
                resIdPtr = _tcsrchr (cmdPtr, TEXT(','));
                if (resIdPtr) {
                    *resIdPtr = 0;
                    resIdPtr ++;
                }
            }
            if (cmdPtr && resIdPtr) {
                resId = _ttoi (resIdPtr);
                if (resId < 0) {
                    // let's load the resource string from that PE file
                    // use resIdPtr to access the string resource
                    dllModule = LoadLibraryEx (cmdPtr, NULL, LOAD_LIBRARY_AS_DATAFILE);
                    if (dllModule) {
                        found = (LoadString (dllModule, (UINT)(-resId), ptszPrettyType, cchPrettyName) > 0);
                        hr = S_OK;
                        FreeLibrary (dllModule);
                    }
                }
            }
        }

        if ((!found) && (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szTypeName, NULL, &dwType, ptszPrettyType, &cchPrettyName)))
        {
            hr = S_OK;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////

BOOL _DriveIdIsFloppyNT(int iDrive)
{
    BOOL fRetVal = FALSE;

    HANDLE hDevice;
    UINT i;
    TCHAR szTemp[] = TEXT("\\\\.\\a:");

    if (iDrive >= 0 && iDrive < 26)
    {
        szTemp[4] += (TCHAR)iDrive;

        hDevice = CreateFile(szTemp, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL, OPEN_EXISTING, 0, NULL);
        if (INVALID_HANDLE_VALUE != hDevice)
        {
            DISK_GEOMETRY rgGeometry[15];
            DWORD cbIn = sizeof(rgGeometry);
            DWORD cbReturned;

            if (DeviceIoControl(hDevice, IOCTL_DISK_GET_MEDIA_TYPES,
                                NULL, 0, rgGeometry, cbIn, &cbReturned, NULL))
            {
                UINT cStructReturned = cbReturned / sizeof(DISK_GEOMETRY);
                for (i = 0; i < cStructReturned; i++)
                {
                    switch (rgGeometry[i].MediaType)
                    {
                    case F5_1Pt2_512:
                    case F3_1Pt44_512:
                    case F3_2Pt88_512:
                    case F3_20Pt8_512:
                    case F3_720_512:
                    case F5_360_512:
                    case F5_320_512:
                    case F5_320_1024:
                    case F5_180_512:
                    case F5_160_512:
                        fRetVal = TRUE;
                        break;
                    case Unknown:
                    case RemovableMedia:
                    case FixedMedia:
                    default:
                        break;
                    }
                }
            }
            CloseHandle (hDevice);
        }
    }

    return fRetVal;
}

///////////////////////////////////////////

#define DEVPB_DEVTYP_525_0360   0
#define DEVPB_DEVTYP_525_1200   1
#define DEVPB_DEVTYP_350_0720   2
#define DEVPB_DEVTYP_350_1440   7
#define DEVPB_DEVTYP_350_2880   9
#define DEVPB_DEVTYP_FIXED      5
#define DEVPB_DEVTYP_NECHACK    4       // for 3rd FE floppy
#define DEVPB_DEVTYP_350_120M   6

#define CARRY_FLAG      0x01
#define VWIN32_DIOC_DOS_IOCTL       1


// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs {
    DWORD   reg_EBX;
    DWORD   reg_EDX;
    DWORD   reg_ECX;
    DWORD   reg_EAX;
    DWORD   reg_EDI;
    DWORD   reg_ESI;
    DWORD   reg_Flags;
} DIOC_REGISTERS;

#pragma pack(1)
typedef struct _DOSDPB {
   BYTE    specialFunc;    //
   BYTE    devType;        //
   WORD    devAttr;        //
   WORD    cCyl;           // number of cylinders
   BYTE    mediaType;      //
   WORD    cbSec;          // Bytes per sector
   BYTE    secPerClus;     // Sectors per cluster
   WORD    cSecRes;        // Reserved sectors
   BYTE    cFAT;           // FATs
   WORD    cDir;           // Root Directory Entries
   WORD    cSec;           // Total number of sectors in image
   BYTE    bMedia;         // Media descriptor
   WORD    secPerFAT;      // Sectors per FAT
   WORD    secPerTrack;    // Sectors per track
   WORD    cHead;          // Heads
   DWORD   cSecHidden;     // Hidden sectors
   DWORD   cTotalSectors;  // Total sectors, if cbSec is zero
   BYTE    reserved[6];    //
} DOSDPB, *PDOSDPB;
#pragma pack()



BOOL _DriveIOCTL(int iDrive, int cmd, void *pvIn, DWORD dwIn, void *pvOut, DWORD dwOut, BOOL fFileSystem = FALSE,
                          HANDLE handle = INVALID_HANDLE_VALUE)
{
    BOOL fHandlePassedIn = TRUE;
    BOOL fSuccess = FALSE;
    DWORD dwRead;

    if (INVALID_HANDLE_VALUE == handle)
    {
        handle = CreateFileA("\\\\.\\VWIN32", 0, 0, 0, 0,
                           FILE_FLAG_DELETE_ON_CLOSE, 0);
        fHandlePassedIn = FALSE;
    }

    if (INVALID_HANDLE_VALUE != handle)
    {
        DIOC_REGISTERS reg;

        //
        // On non-NT, we talk to VWIN32, issuing reads (which are converted
        // internally to DEVIOCTLs)
        //
        //  this is a real hack (talking to VWIN32) on NT we can just
        //  open the device, we dont have to go through VWIN32
        //
        reg.reg_EBX = (DWORD)iDrive + 1;  // make 1 based drive number
        reg.reg_EDX = (DWORD)(ULONG_PTR)pvOut; // out buffer
        reg.reg_ECX = cmd;              // device specific command code
        reg.reg_EAX = 0x440D;           // generic read ioctl
        reg.reg_Flags = 0x0001;     // flags, assume error (carry)

        DeviceIoControl(handle, VWIN32_DIOC_DOS_IOCTL, &reg, sizeof(reg), &reg, sizeof(reg), &dwRead, NULL);

        fSuccess = !(reg.reg_Flags & 0x0001);
        if (!fHandlePassedIn)
            CloseHandle(handle);
    }

    return fSuccess;
}

BOOL _DriveIdIsFloppy9X(int iDrive)
{
    DOSDPB SupportedGeometry;      // s/b big enough for all
    BOOL fRet = FALSE;

    SupportedGeometry.specialFunc = 0;

    if (_DriveIOCTL(iDrive, 0x860, NULL, 0, &SupportedGeometry, sizeof(SupportedGeometry)))
    {
        switch( SupportedGeometry.devType )
        {
            case DEVPB_DEVTYP_525_0360:
            case DEVPB_DEVTYP_525_1200:
            case DEVPB_DEVTYP_350_0720:
            case DEVPB_DEVTYP_350_1440:
            case DEVPB_DEVTYP_350_2880:
                fRet = TRUE;
                break;

            case DEVPB_DEVTYP_FIXED:
            case DEVPB_DEVTYP_NECHACK:        // for 3rd FE floppy
            case DEVPB_DEVTYP_350_120M:
                fRet = FALSE;
                break;
        }
    }

    return fRet;
}



///////////////////////////////////////////

BOOL _DriveIdIsFloppy(BOOL fIsNT, int iDrive)
{
    if (fIsNT)
    {
        return _DriveIdIsFloppyNT(iDrive);
    }
    else
    {
        return _DriveIdIsFloppy9X(iDrive);
    }
}

///////////////////////////////////////////
BOOL _DriveStrIsFloppy(BOOL fIsNT, PCTSTR pszPath)
{
    int iDrive;

    iDrive = towlower(pszPath[0]) - TEXT('a');

    return _DriveIdIsFloppy(fIsNT, iDrive);
}

///////////////////////////////////////////

INT _GetFloppyNumber(BOOL fIsNT)
{
    static int iFloppy = -1;
    static bool fInit = FALSE;

    if (!fInit)
    {
        DWORD dwLog = GetLogicalDrives();

        for (int i = 0; i < 26; i++)
        {
            if( !((dwLog >> i) & 0x01) || !_DriveIdIsFloppy(fIsNT, i) )
            {
                break;
            }
            else
            {
                iFloppy = i;
            }
        }
        fInit = TRUE;
    }

    return iFloppy;
}

////////////////////////////////////////////////////////
/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}

BOOL _SetTextLoadString(HINSTANCE hInst, HWND hwnd, UINT idText)
{
    TCHAR sz[MAX_LOADSTRING];
    if (LoadString(hInst, idText, sz, ARRAYSIZE(sz)))
    {
        SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)sz);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

typedef HANDLE (WINAPI CREATETOOLHELP32SNAPSHOT)(DWORD dwFlags, DWORD th32ProcessID);
typedef CREATETOOLHELP32SNAPSHOT *PCREATETOOLHELP32SNAPSHOT;

#ifdef UNICODE

typedef BOOL (WINAPI PROCESS32FIRST)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
typedef BOOL (WINAPI PROCESS32NEXT)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);

#else

typedef BOOL (WINAPI PROCESS32FIRST)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
typedef BOOL (WINAPI PROCESS32NEXT)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

#endif

typedef PROCESS32FIRST *PPROCESS32FIRST;
typedef PROCESS32NEXT *PPROCESS32NEXT;


VOID
KillExplorer (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    HANDLE h, h1;
    PROCESSENTRY32 pe;
    TCHAR szExplorerPath[MAX_PATH];
    PCREATETOOLHELP32SNAPSHOT dynCreateToolhelp32Snapshot;
    PPROCESS32FIRST dynProcess32First;
    PPROCESS32NEXT dynProcess32Next;
    HMODULE lib;

    lib = LoadLibrary (TEXT("kernel32.dll"));

    if (!lib) {
        return;
    }

    dynCreateToolhelp32Snapshot = (PCREATETOOLHELP32SNAPSHOT) GetProcAddress (lib, "CreateToolhelp32Snapshot");

#ifdef UNICODE
    dynProcess32First = (PPROCESS32FIRST) GetProcAddress (lib, "Process32FirstW");
    dynProcess32Next = (PPROCESS32NEXT) GetProcAddress (lib, "Process32NextW");
#else
    dynProcess32First = (PPROCESS32FIRST) GetProcAddress (lib, "Process32First");
    dynProcess32Next = (PPROCESS32NEXT) GetProcAddress (lib, "Process32Next");
#endif

    __try {
        if (!dynCreateToolhelp32Snapshot || !dynProcess32Next || !dynProcess32First) {
            __leave;
        }

        h = dynCreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);

        if (h == INVALID_HANDLE_VALUE) {
            __leave;
        }

        GetWindowsDirectory (szExplorerPath, MAX_PATH);
        PathAppend (szExplorerPath, TEXT("explorer.exe"));

        pe.dwSize = sizeof (PROCESSENTRY32);

        if (dynProcess32First (h, &pe)) {
            do {
                if (!StrCmpI (pe.szExeFile, TEXT("explorer.exe")) ||
                    !StrCmpI (pe.szExeFile, szExplorerPath)
                    ) {

                    h1 = OpenProcess (PROCESS_TERMINATE, FALSE, pe.th32ProcessID);

                    if (h1) {
                        g_Explorer = StrDup (szExplorerPath);
                        TerminateProcess (h1, 1);
                        CloseHandle (h1);
                        break;
                    }
                }
            } while (dynProcess32Next (h, &pe));
        }

        CloseHandle (h);
    }
    __finally {
        FreeLibrary (lib);
    }
}


typedef enum {
    MS_MAX_PATH,
    MS_NO_ARG,
    MS_BOOL,
    MS_INT,
    MS_RECT,
    MS_BLOB
} METRICSTYLE;


VOID
__RefreshMetric (
    IN      METRICSTYLE msStyle,
    IN      UINT uGetMetricId,
    IN      UINT uSetMetricId,
    IN      UINT uBlobSize
    )
{
    BYTE byBuffer[MAX_PATH * 4];
    PVOID blob;

    switch (msStyle) {

    case MS_NO_ARG:
        SystemParametersInfo (uSetMetricId, 0, NULL, SPIF_SENDCHANGE);
        break;

    case MS_BLOB:
        blob = LocalAlloc (LPTR, uBlobSize);
        if (blob) {
            if (SystemParametersInfo (uGetMetricId, uBlobSize, blob, SPIF_UPDATEINIFILE)) {
                SystemParametersInfo (uSetMetricId, 0, blob, SPIF_SENDCHANGE);
            }

            LocalFree (blob);
        }
        break;

    case MS_RECT:
        if (SystemParametersInfo (uGetMetricId, 0, byBuffer, SPIF_UPDATEINIFILE)) {
            SystemParametersInfo (uSetMetricId, 0, byBuffer, SPIF_SENDCHANGE);
        }
        break;

    case MS_BOOL:
        if (SystemParametersInfo (uGetMetricId, 0, byBuffer, SPIF_UPDATEINIFILE)) {
            SystemParametersInfo (uSetMetricId, *((BOOL *) byBuffer), NULL, SPIF_SENDCHANGE);
        }
        break;

    case MS_INT:
        if (SystemParametersInfo (uGetMetricId, 0, byBuffer, SPIF_UPDATEINIFILE)) {
            SystemParametersInfo (uSetMetricId, *((UINT *) byBuffer), NULL, SPIF_SENDCHANGE);
        }
        break;

    case MS_MAX_PATH:
        if (SystemParametersInfo (uGetMetricId, MAX_PATH, byBuffer, SPIF_UPDATEINIFILE)) {
            SystemParametersInfo (uSetMetricId, 0, byBuffer, SPIF_SENDCHANGE);
        }
        break;

    }

    return;
}

VOID
SwitchToClassicDesktop (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    LONG result;
    HKEY key = NULL;
    TCHAR data[] = TEXT("0");

    //
    // The only thing that we need to do is to turn off:
    // HKCU\Software\Microsoft\Windows\CurrentVersion\ThemeManager [ThemeActive]
    //
    result = RegOpenKeyEx (
                HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"),
                0,
                KEY_WRITE,
                &key
                );
    if ((result == ERROR_SUCCESS) &&
        (key)
        ) {

        result = RegSetValueEx (
                    key,
                    TEXT("ThemeActive"),
                    0,
                    REG_SZ,
                    (PBYTE)data,
                    sizeof (data)
                    );

        RegCloseKey (key);
    }
}

typedef struct
{
    UINT cbSize;
    SHELLSTATE ss;
} REGSHELLSTATE, *PREGSHELLSTATE;

VOID
SwitchToClassicTaskBar (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    DWORD dataType;
    DWORD dataSize = 0;
    PBYTE data = NULL;
    PREGSHELLSTATE shellState = NULL;
    LONG result;

    //
    // The only thing that we need to do is to turn off the fStartPanelOn field in:
    // HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer [ShellState]
    //
    result = RegOpenKeyEx (
                HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                0,
                KEY_READ | KEY_WRITE,
                &key
                );
    if ((result == ERROR_SUCCESS) &&
        (key)
        ) {

        result = RegQueryValueEx (
                    key,
                    TEXT ("ShellState"),
                    NULL,
                    &dataType,
                    NULL,
                    &dataSize
                    );

        if ((result == ERROR_SUCCESS) || (result == ERROR_MORE_DATA)) {
            data = (PBYTE) LocalAlloc (LPTR, dataSize);
            if (data) {
                result = RegQueryValueEx (
                            key,
                            TEXT ("ShellState"),
                            NULL,
                            &dataType,
                            data,
                            &dataSize
                            );
                if ((result == ERROR_SUCCESS) &&
                    (dataType == REG_BINARY) &&
                    (dataSize == sizeof (REGSHELLSTATE))
                    ) {
                    if (dataType == REG_BINARY) {
                        shellState = (PREGSHELLSTATE) data;
                        shellState->ss.fStartPanelOn = FALSE;
                        RegSetValueEx (
                            key,
                            TEXT("ShellState"),
                            0,
                            REG_BINARY,
                            (PBYTE)data,
                            dataSize
                            );
                    }
                }
                LocalFree (data);
            }
        }

        RegCloseKey (key);
    }
}

VOID
RegisterFonts (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    WIN32_FIND_DATA findData;
    HANDLE findHandle = INVALID_HANDLE_VALUE;
    PTSTR fontDir = NULL;
    TCHAR fontPattern [MAX_PATH];
    //
    // Let's (re)register all the fonts (in case the user migrated some new ones).
    //
    fontDir = GetShellFolderPath (CSIDL_FONTS, NULL, TRUE, NULL);
    if (fontDir) {
        StrCpyN (fontPattern, fontDir, ARRAYSIZE (fontPattern) - 4);
        StrCat (fontPattern, TEXT("\\*.*"));
        findHandle = FindFirstFile (fontPattern, &findData);
        if (findHandle != INVALID_HANDLE_VALUE) {
            do {
                AddFontResource (findData.cFileName);
            } while (FindNextFile (findHandle, &findData));
            FindClose (findHandle);
        }
    }
}

VOID
RefreshMetrics (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    //
    // Refresh all system metrics
    //
    __RefreshMetric (MS_NO_ARG, 0, SPI_SETCURSORS, 0);
    __RefreshMetric (MS_NO_ARG, 0, SPI_SETDESKPATTERN, 0);
    __RefreshMetric (MS_MAX_PATH, SPI_GETDESKWALLPAPER, SPI_SETDESKWALLPAPER, 0);
    __RefreshMetric (MS_BOOL, SPI_GETFONTSMOOTHING, SPI_SETFONTSMOOTHING, 0);
    __RefreshMetric (MS_RECT, SPI_GETWORKAREA, SPI_SETWORKAREA, 0);
    __RefreshMetric (MS_BLOB, SPI_GETICONMETRICS, SPI_SETICONMETRICS, sizeof (ICONMETRICS));
    __RefreshMetric (MS_NO_ARG, 0, SPI_SETICONS, 0);
    __RefreshMetric (MS_BLOB, SPI_GETICONTITLELOGFONT, SPI_SETICONTITLELOGFONT, sizeof (LOGFONT));
    __RefreshMetric (MS_BOOL, SPI_GETICONTITLEWRAP, SPI_SETICONTITLEWRAP, 0);
    __RefreshMetric (MS_BOOL, SPI_GETBEEP, SPI_SETBEEP, 0);
    __RefreshMetric (MS_BOOL, SPI_GETKEYBOARDCUES, SPI_SETKEYBOARDCUES, 0);
    __RefreshMetric (MS_INT, SPI_GETKEYBOARDDELAY, SPI_SETKEYBOARDDELAY, 0);
    __RefreshMetric (MS_BOOL, SPI_GETKEYBOARDPREF, SPI_SETKEYBOARDPREF, 0);
    __RefreshMetric (MS_INT, SPI_GETKEYBOARDSPEED, SPI_SETKEYBOARDSPEED, 0);
    //__RefreshMetric (MS_BOOL, SPI_GETMOUSEBUTTONSWAP, SPI_SETMOUSEBUTTONSWAP, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSEHOVERHEIGHT, SPI_SETMOUSEHOVERHEIGHT, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSEHOVERTIME, SPI_SETMOUSEHOVERTIME, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSEHOVERWIDTH, SPI_SETMOUSEHOVERWIDTH, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSESPEED, SPI_SETMOUSESPEED, 0);
    __RefreshMetric (MS_INT, SPI_GETMOUSETRAILS, SPI_SETMOUSETRAILS, 0);
    //__RefreshMetric (MS_INT, SPI_GETDOUBLECLICKTIME, SPI_SETDOUBLECLICKTIME, 0);
    //__RefreshMetric (MS_INT, SPI_GETDOUBLECLKHEIGHT, SPI_SETDOUBLECLKHEIGHT, 0);
    //__RefreshMetric (MS_INT, SPI_GETDOUBLECLKWIDTH, SPI_SETDOUBLECLKWIDTH, 0);
    __RefreshMetric (MS_BOOL, SPI_GETSNAPTODEFBUTTON, SPI_SETSNAPTODEFBUTTON, 0);
    __RefreshMetric (MS_INT, SPI_GETWHEELSCROLLLINES, SPI_SETWHEELSCROLLLINES, 0);
    __RefreshMetric (MS_BOOL, SPI_GETMENUDROPALIGNMENT, SPI_SETMENUDROPALIGNMENT, 0);
    __RefreshMetric (MS_BOOL, SPI_GETMENUFADE, SPI_SETMENUFADE, 0);
    __RefreshMetric (MS_BOOL, SPI_GETMENUSHOWDELAY, SPI_SETMENUSHOWDELAY, 0);
    __RefreshMetric (MS_BOOL, SPI_GETLOWPOWERACTIVE, SPI_SETLOWPOWERACTIVE, 0);
    __RefreshMetric (MS_INT, SPI_GETLOWPOWERTIMEOUT, SPI_SETLOWPOWERTIMEOUT, 0);
    __RefreshMetric (MS_BOOL, SPI_GETPOWEROFFACTIVE, SPI_SETPOWEROFFACTIVE, 0);
    __RefreshMetric (MS_INT, SPI_GETPOWEROFFTIMEOUT, SPI_SETPOWEROFFTIMEOUT, 0);
    __RefreshMetric (MS_BOOL, SPI_GETSCREENSAVEACTIVE, SPI_SETSCREENSAVEACTIVE, 0);
    __RefreshMetric (MS_INT, SPI_GETSCREENSAVETIMEOUT, SPI_SETSCREENSAVETIMEOUT, 0);
    __RefreshMetric (MS_BOOL, SPI_GETCOMBOBOXANIMATION, SPI_SETCOMBOBOXANIMATION, 0);
    __RefreshMetric (MS_BOOL, SPI_GETCURSORSHADOW, SPI_SETCURSORSHADOW, 0);
    __RefreshMetric (MS_BOOL, SPI_GETGRADIENTCAPTIONS, SPI_SETGRADIENTCAPTIONS, 0);
    __RefreshMetric (MS_BOOL, SPI_GETHOTTRACKING, SPI_SETHOTTRACKING, 0);
    __RefreshMetric (MS_BOOL, SPI_GETLISTBOXSMOOTHSCROLLING, SPI_SETLISTBOXSMOOTHSCROLLING, 0);
    __RefreshMetric (MS_BOOL, SPI_GETSELECTIONFADE, SPI_SETSELECTIONFADE, 0);
    __RefreshMetric (MS_BOOL, SPI_GETTOOLTIPANIMATION, SPI_SETTOOLTIPANIMATION, 0);
    __RefreshMetric (MS_BOOL, SPI_GETTOOLTIPFADE, SPI_SETTOOLTIPFADE, 0);
    __RefreshMetric (MS_BOOL, SPI_GETUIEFFECTS, SPI_SETUIEFFECTS, 0);
    __RefreshMetric (MS_BOOL, SPI_GETACTIVEWINDOWTRACKING, SPI_SETACTIVEWINDOWTRACKING, 0);
    __RefreshMetric (MS_BOOL, SPI_GETACTIVEWNDTRKZORDER, SPI_SETACTIVEWNDTRKZORDER, 0);
    __RefreshMetric (MS_INT, SPI_GETACTIVEWNDTRKTIMEOUT, SPI_SETACTIVEWNDTRKTIMEOUT, 0);
    __RefreshMetric (MS_BLOB, SPI_GETANIMATION, SPI_SETANIMATION, sizeof (ANIMATIONINFO));
    __RefreshMetric (MS_INT, SPI_GETBORDER, SPI_SETBORDER, 0);
    __RefreshMetric (MS_INT, SPI_GETCARETWIDTH, SPI_SETCARETWIDTH, 0);
    __RefreshMetric (MS_BOOL, SPI_GETDRAGFULLWINDOWS, SPI_SETDRAGFULLWINDOWS, 0);
    __RefreshMetric (MS_INT, SPI_GETFOREGROUNDFLASHCOUNT, SPI_SETFOREGROUNDFLASHCOUNT, 0);
    __RefreshMetric (MS_INT, SPI_GETFOREGROUNDLOCKTIMEOUT, SPI_SETFOREGROUNDLOCKTIMEOUT, 0);
    __RefreshMetric (MS_BLOB, SPI_GETMINIMIZEDMETRICS, SPI_SETMINIMIZEDMETRICS, sizeof (MINIMIZEDMETRICS));
    __RefreshMetric (MS_BLOB, SPI_GETNONCLIENTMETRICS, SPI_SETNONCLIENTMETRICS, sizeof (NONCLIENTMETRICS));
    __RefreshMetric (MS_BOOL, SPI_GETSHOWIMEUI, SPI_SETSHOWIMEUI, 0);

    // SPI_SETMOUSE
    // SPI_SETDRAGHEIGHT
    // SPI_SETDRAGWIDTH

    __RefreshMetric (MS_BLOB, SPI_GETACCESSTIMEOUT, SPI_SETACCESSTIMEOUT, sizeof (ACCESSTIMEOUT));
    __RefreshMetric (MS_BLOB, SPI_GETFILTERKEYS, SPI_SETFILTERKEYS, sizeof (FILTERKEYS));
    __RefreshMetric (MS_BLOB, SPI_GETHIGHCONTRAST, SPI_SETHIGHCONTRAST, sizeof (HIGHCONTRAST));
    __RefreshMetric (MS_BLOB, SPI_GETMOUSEKEYS, SPI_SETMOUSEKEYS, sizeof (MOUSEKEYS));
    __RefreshMetric (MS_BLOB, SPI_GETSERIALKEYS, SPI_SETSERIALKEYS, sizeof (SERIALKEYS));
    __RefreshMetric (MS_BOOL, SPI_GETSHOWSOUNDS, SPI_SETSHOWSOUNDS, 0);
    __RefreshMetric (MS_BLOB, SPI_GETSOUNDSENTRY, SPI_SETSOUNDSENTRY, sizeof (SOUNDSENTRY));
    __RefreshMetric (MS_BLOB, SPI_GETSTICKYKEYS, SPI_SETSTICKYKEYS, sizeof (STICKYKEYS));
    __RefreshMetric (MS_BLOB, SPI_GETTOGGLEKEYS, SPI_SETTOGGLEKEYS, sizeof (TOGGLEKEYS));
}

VOID
AskForLogOff (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    g_LogOffSystem = TRUE;
}

VOID
AskForReboot (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    g_RebootSystem = TRUE;
}

VOID
SaveOFStatus (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    LONG lResult;
    DWORD dataType;
    DWORD dataSize;
    DWORD data;

    lResult = RegOpenKey (HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray"), &key);
    if ((lResult == ERROR_SUCCESS) && key) {
        dataSize = 0;
        lResult = RegQueryValueEx (key, TEXT("Services"), NULL, &dataType, NULL, &dataSize);
        if ((lResult == ERROR_SUCCESS) && (dataType == REG_DWORD)) {
            lResult = RegQueryValueEx (key, TEXT("Services"), NULL, &dataType, (LPBYTE)(&data), &dataSize);
            if (lResult == ERROR_SUCCESS) {
                g_OFStatus = ((data & 0x00000008) != 0);
            }
        }
        CloseHandle (key);
    }
}

VOID
RebootOnOFStatusChange (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    HKEY key = NULL;
    LONG lResult;
    DWORD dataType;
    DWORD dataSize;
    DWORD data;

    lResult = RegOpenKey (HKEY_CURRENT_USER, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray"), &key);
    if ((lResult == ERROR_SUCCESS) && key) {
        dataSize = 0;
        lResult = RegQueryValueEx (key, TEXT("Services"), NULL, &dataType, NULL, &dataSize);
        if ((lResult == ERROR_SUCCESS) && (dataType == REG_DWORD)) {
            lResult = RegQueryValueEx (key, TEXT("Services"), NULL, &dataType, (LPBYTE)(&data), &dataSize);
            if (lResult == ERROR_SUCCESS) {
                if (g_OFStatus && ((data & 0x00000008) == 0)) {
                    AskForReboot (Instance, hwndDlg, NULL);
                }
                if ((!g_OFStatus) && ((data & 0x00000008) != 0)) {
                    AskForReboot (Instance, hwndDlg, NULL);
                }
            }
        }
        CloseHandle (key);
    }
}

typedef BOOL (WINAPI LOCKSETFOREGROUNDWINDOW)(UINT uLockCode);
typedef LOCKSETFOREGROUNDWINDOW *PLOCKSETFOREGROUNDWINDOW;

VOID
RestartExplorer (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    )
{
    BOOL bResult;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    HMODULE lib;
    PLOCKSETFOREGROUNDWINDOW dynLockSetForegroundWindow;

    if (g_Explorer) {

        //
        // Start explorer.exe
        //

        ZeroMemory( &si, sizeof(STARTUPINFO) );
        si.cb = sizeof(STARTUPINFO);

        lib = LoadLibrary (TEXT("user32.dll"));
        if (lib) {

            dynLockSetForegroundWindow = (PLOCKSETFOREGROUNDWINDOW) GetProcAddress (lib, "LockSetForegroundWindow");

            if (dynLockSetForegroundWindow) {
                // let's lock this so Explorer does not steal our focus
                dynLockSetForegroundWindow (LSFW_LOCK);
            }

            FreeLibrary (lib);
        }

        bResult = CreateProcess(
                        NULL,
                        g_Explorer,
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_NEW_PROCESS_GROUP,
                        NULL,
                        NULL,
                        &si,
                        &pi
                        );

        if (bResult) {
            CloseHandle (pi.hProcess);
            CloseHandle (pi.hThread);
        }
    }
}

BOOL
AppExecute (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR ExecuteArgs
    )
{
    PCTSTR funcName = NULL;
    PCTSTR funcArgs = NULL;

    funcName = ExecuteArgs;
    if (!funcName || !(*funcName)) {
        return FALSE;
    }
    funcArgs = StrChrI (funcName, 0);
    if (funcArgs) {
        funcArgs ++;
        if (!(*funcArgs)) {
            funcArgs = NULL;
        }
    }
    // BUGBUG - temporary, make a macro expansion list out of it
    if (0 == StrCmpI (funcName, TEXT("KillExplorer"))) {
        KillExplorer (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("RefreshMetrics"))) {
        RefreshMetrics (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("AskForLogOff"))) {
        AskForLogOff (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("AskForReboot"))) {
        AskForReboot (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("RestartExplorer"))) {
        RestartExplorer (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("SwitchToClassicDesktop"))) {
        SwitchToClassicDesktop (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("SwitchToClassicTaskBar"))) {
        SwitchToClassicTaskBar (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("RegisterFonts"))) {
        RegisterFonts (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("SaveOFStatus"))) {
        SaveOFStatus (Instance, hwndDlg, funcArgs);
    }
    if (0 == StrCmpI (funcName, TEXT("RebootOnOFStatusChange"))) {
        RebootOnOFStatusChange (Instance, hwndDlg, funcArgs);
    }
    return TRUE;
}

////////////////////////////////////////////////////


//
//  Obtaining a connection point sink is supposed to be easy.  You just
//  QI for the interface.  Unfortunately, too many components are buggy.
//
//  mmc.exe faults if you QI for IDispatch
//  and punkCB is non-NULL.  And if you do pass in NULL,
//  it returns S_OK but fills punkCB with NULL anyway.
//  Somebody must've had a rough day.
//
//  Java responds only to its dispatch ID and not IID_IDispatch, even
//  though the dispatch ID is derived from IID_IDispatch.
//
//  The Explorer Band responds only to IID_IDispatch and not to
//  the dispatch ID.
//

HRESULT GetConnectionPointSink(IUnknown *pUnk, const IID *piidCB, IUnknown **ppunkCB)
{
    HRESULT hr = E_NOINTERFACE;
    *ppunkCB = NULL;                // Pre-zero it to work around MMC
    if (piidCB)                     // Optional interface (Java/ExplBand)
    {
        hr = pUnk->QueryInterface(*piidCB, (void **) ppunkCB);
        if (*ppunkCB == NULL)       // Clean up behind MMC
            hr = E_NOINTERFACE;
    }
    return hr;
}

//
//  Enumerate the connection point sinks, calling the callback for each one
//  found.
//
//  The callback function is called once for each sink.  The IUnknown is
//  whatever interface we could get from the sink (either piidCB or piidCB2).
//

typedef HRESULT (CALLBACK *ENUMCONNECTIONPOINTSPROC)(
    /* [in, iid_is(*piidCB)] */ IUnknown *psink, LPARAM lParam);

HRESULT EnumConnectionPointSinks(
    IConnectionPoint *pcp,              // IConnectionPoint victim
    const IID *piidCB,                  // Interface for callback
    const IID *piidCB2,                 // Alternate interface for callback
    ENUMCONNECTIONPOINTSPROC EnumProc,  // Callback procedure
    LPARAM lParam)                      // Refdata for callback
{
    HRESULT hr;
    IEnumConnections * pec;

    if (pcp)
        hr = pcp->EnumConnections(&pec);
    else
        hr = E_NOINTERFACE;

    if (SUCCEEDED(hr))
    {
        CONNECTDATA cd;
        ULONG cFetched;

        while (S_OK == (hr = pec->Next(1, &cd, &cFetched)))
        {
            IUnknown *punkCB;

            //ASSERT(1 == cFetched);

            hr = GetConnectionPointSink(cd.pUnk, piidCB, &punkCB);
            if (FAILED(hr))
                hr = GetConnectionPointSink(cd.pUnk, piidCB2, &punkCB);

            if (SUCCEEDED(hr))
            {
                hr = EnumProc(punkCB, lParam);
                punkCB->Release();
            }
            else
            {
                hr = S_OK;      // Pretend callback succeeded
            }
            cd.pUnk->Release();
            if (FAILED(hr)) break; // Callback asked to stop
        }
        pec->Release();
        hr = S_OK;
    }

    return hr;
}

//
//  Send out the callback (if applicable) and then do the invoke if the
//  callback said that was a good idea.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      pinv         -  Structure containing parameters to INVOKE.

HRESULT CALLBACK EnumInvokeCallback(IUnknown *psink, LPARAM lParam)
{
    IDispatch *pdisp = (IDispatch *)psink;
    LPSHINVOKEPARAMS pinv = (LPSHINVOKEPARAMS)lParam;
    HRESULT hr;

    if (pinv->Callback)
    {
        // Now see if the callback wants to do pre-vet the pdisp.
        // It can return S_FALSE to skip this callback or E_FAIL to
        // stop the invoke altogether
        hr = pinv->Callback(pdisp, pinv);
        if (hr != S_OK) return hr;
    }

    pdisp->Invoke(pinv->dispidMember, *pinv->piid, pinv->lcid,
                  pinv->wFlags, pinv->pdispparams, pinv->pvarResult,
                  pinv->pexcepinfo, pinv->puArgErr);

    return S_OK;
}


//
//  QI's for IConnectionPointContainer and then does the FindConnectionPoint.
//
//  Parameters:
//
//      punk         -  The object who might be an IConnectionPointContainer.
//                      This parameter may be NULL, in which case the
//                      operation fails.
//      riidCP       -  The connection point interface to locate.
//      pcpOut       -  Receives the IConnectionPoint, if any.

HRESULT IUnknown_FindConnectionPoint(IUnknown *punk, REFIID riidCP,
                                      IConnectionPoint **pcpOut)
{
    HRESULT hr;

    *pcpOut = NULL;

    if (punk)
    {
        IConnectionPointContainer *pcpc;
        hr = punk->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpc);
        if (SUCCEEDED(hr))
        {
            hr = pcpc->FindConnectionPoint(riidCP, pcpOut);
            pcpc->Release();
        }
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

//
//  IConnectionPoint_InvokeIndirect
//
//  Given a connection point, call the IDispatch::Invoke for each
//  connected sink.
//
//  The return value merely indicates whether the command was dispatched.
//  If any particular sink fails the IDispatch::Invoke, we will still
//  return S_OK, since the command was indeed dispatched.
//
//  Parameters:
//
//      pcp          -  IConnectionPoint whose sinks are to be Invoke()d.
//                      If this parameter is NULL, the function does nothing.
//      pinv         -  Structure containing parameters to INVOKE.
//                      The pdispparams field can be NULL; we will turn it
//                      into a real DISPPARAMS for you.
//
//  The SHINVOKEPARAMS.flags field can contain the following flags.
//
//      IPFL_USECALLBACK    - The callback field contains a callback function
//                            Otherwise, it will be set to NULL.
//      IPFL_USEDEFAULT     - Many fields in the SHINVOKEPARAMS will be set to
//                            default values to save the caller effort:
//
//                  riid            =   IID_NULL
//                  lcid            =   0
//                  wFlags          =   DISPATCH_METHOD
//                  pvarResult      =   NULL
//                  pexcepinfo      =   NULL
//                  puArgErr        =   NULL
//

HRESULT IConnectionPoint_InvokeIndirect(
    IConnectionPoint *pcp,
    SHINVOKEPARAMS *pinv)
{
    HRESULT hr;
    DISPPARAMS dp = { 0 };
    IID iidCP;

    if (pinv->pdispparams == NULL)
        pinv->pdispparams = &dp;

    if (!(pinv->flags & IPFL_USECALLBACK))
    {
        pinv->Callback = NULL;
    }

    if (pinv->flags & IPFL_USEDEFAULTS)
    {
        pinv->piid            =  &IID_NULL;
        pinv->lcid            =   0;
        pinv->wFlags          =   DISPATCH_METHOD;
        pinv->pvarResult      =   NULL;
        pinv->pexcepinfo      =   NULL;
        pinv->puArgErr        =   NULL;
    }

    // Try both the interface they actually connected on,
    // as well as IDispatch.  Apparently Java responds only to
    // the connecting interface, and ExplBand responds only to
    // IDispatch, so we have to try both.  (Sigh.  Too many buggy
    // components in the system.)

    hr = EnumConnectionPointSinks(pcp,
                                  (pcp->GetConnectionInterface(&iidCP) == S_OK) ? &iidCP : NULL,
                                  &IID_IDispatch,
                                  EnumInvokeCallback,
                                  (LPARAM)pinv);

    // Put the original NULL back so the caller can re-use the SHINVOKEPARAMS.
    if (pinv->pdispparams == &dp)
        pinv->pdispparams = NULL;

    return hr;
}

//
//  Given an IUnknown, query for its connection point container,
//  find the corresponding connection point, package up the
//  invoke parameters, and call the IDispatch::Invoke for each
//  connected sink.
//
//  See IConnectionPoint_InvokeParam for additional semantics.
//
//  Parameters:
//
//      punk         -  Object that might be an IConnectionPointContainer
//      riidCP       -  ConnectionPoint interface to request
//      pinv         -  Arguments for the Invoke.
//

HRESULT IUnknown_CPContainerInvokeIndirect(IUnknown *punk, REFIID riidCP,
                SHINVOKEPARAMS *pinv)
{
    IConnectionPoint *pcp;
    HRESULT hr = IUnknown_FindConnectionPoint(punk, riidCP, &pcp);
    if (SUCCEEDED(hr))
    {
        hr = IConnectionPoint_InvokeIndirect(pcp, pinv);
        pcp->Release();
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////////////

VOID
_UpdateText(
    IN      HWND hWnd,
    IN      LPCTSTR pcszString
)
{
    TCHAR szCurString[MAX_LOADSTRING];

    if (pcszString)
    {
        SendMessage (hWnd, WM_GETTEXT, (WPARAM)MAX_LOADSTRING, (LPARAM)szCurString);
        if (StrCmp (pcszString, szCurString))
        {
            SendMessage (hWnd, WM_SETTEXT, 0, (LPARAM)pcszString);
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////

VOID
_RemoveSpaces (
    IN      PTSTR szData,
    IN      UINT uDataCount
    )
{
    UINT curr;
    PTSTR currPtr;
    PTSTR lastSpace;
    BOOL isSpace;

    // First trim the spaces at the beginning
    if (!szData) {
        return;
    }
    curr = _tcsnextc (szData);
    while (curr == TEXT(' ')) {
        currPtr = _tcsinc (szData);
        memmove (szData, currPtr, uDataCount * sizeof(TCHAR) - (UINT)((currPtr - szData) * sizeof (TCHAR)));
        curr = _tcsnextc (szData);
    }

    // Now trim the trailing spaces
    lastSpace = NULL;
    currPtr = szData;
    curr = _tcsnextc (szData);
    while (curr) {
        if (curr == TEXT(' ')) {
            if (!lastSpace) {
                lastSpace = currPtr;
            }
        } else {
            if (lastSpace) {
                lastSpace = NULL;
            }
        }
        currPtr = _tcsinc (currPtr);
        curr = _tcsnextc (currPtr);
    }
    if (lastSpace) {
        *lastSpace = 0;
    }
}

POBJLIST
_AllocateObjectList (
    IN      PCTSTR ObjectName
    )
{
    POBJLIST objList;

    objList = (POBJLIST)LocalAlloc (LPTR, sizeof (OBJLIST));
    if (objList) {
        ZeroMemory (objList, sizeof (OBJLIST));
        objList->ObjectName = (PTSTR)LocalAlloc (LPTR, (_tcslen (ObjectName) + 1) * sizeof (TCHAR));
        if (objList->ObjectName) {
            _tcscpy (objList->ObjectName, ObjectName);
        }
    }
    return objList;
}

VOID
pFreeObjects (
    IN        POBJLIST ObjectList
    )
{
    if (ObjectList->Next) {
        pFreeObjects(ObjectList->Next);
        LocalFree(ObjectList->Next);
        ObjectList->Next = NULL;
    }
    if (ObjectList->ObjectName) {
        LocalFree(ObjectList->ObjectName);
        ObjectList->ObjectName = NULL;
    }
}


VOID
_FreeObjectList (
    IN      POBJLIST ObjectList
    )
{
    if (ObjectList) {
        pFreeObjects(ObjectList);
        LocalFree(ObjectList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migwiz.h ===
#ifndef _MIGWIZ_HXX_
#define _MIGWIZ_HXX_

#include <shlobj.h>

#define NUMPAGES 22

#define ENGINE_RULE_MAXLEN 4000

#define ENGINE_NOTINIT              0
#define ENGINE_INITGATHER           1
#define ENGINE_INITAPPLY            2

// custom window messages

#define WM_USER_FINISHED        (WM_APP + 1)
#define WM_USER_CANCELLED       (WM_APP + 2)
#define WM_USER_THREAD_COMPLETE (WM_APP + 3)
#define WM_USER_CANCEL_PENDING  (WM_APP + 4)
#define WM_USER_STATUS          (WM_APP + 5)
#define WM_USER_ROLLBACK        (WM_APP + 6)

// device bit entries

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

class MigrationWizard
{
public:
    MigrationWizard();
    ~MigrationWizard();

    HRESULT Init(HINSTANCE hinstance, LPTSTR pszUsername);
    HRESULT Execute();

    HINSTANCE  GetInstance()     { return _hInstance; }
    HFONT      GetTitleFont()    { return _hTitleFont; }
    HFONT      Get95HeaderFont() { return _h95HeaderFont; }
    HIMAGELIST GetImageList()    { return _hil; }

    BOOL GetLegacy()   { return _fLegacyMode; }
    BOOL GetWin9X()    { return _fWin9X; }
    BOOL GetWinNT4()   { return _fWinNT4; }
    BOOL GetOOBEMode() { return _fOOBEMode; }
    BOOL GetOldStyle() { return _fOldStyle; }

    void ResetLastResponse();
    BOOL GetLastResponse();

    HRESULT SelectComponentSet(UINT uSelectionGroup);

private:  // helper functions
    HRESULT _CreateWizardPages();
    HRESULT _InitEngine(BOOL fSource, BOOL* pfNetworkDetected);

protected: // friend WinProcs
    friend INT_PTR CALLBACK _CollectProgressDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend DWORD WINAPI     _CollectProgressDlgProcThread (LPVOID lpParam);
    friend INT_PTR CALLBACK _ApplyProgressDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend DWORD WINAPI     _ApplyProgressDlgProcThread (LPVOID lpParam);
    friend INT_PTR CALLBACK _DiskProgressDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK _PickMethodDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend DWORD WINAPI     _StartEngineDlgProcThread (LPVOID lpParam);

    // other friend functions
    friend BOOL             _HandleCancel (HWND hwndDlg, BOOL PressNext);

private:
    LPTSTR          _pszUsername;       // username specified
    HFONT           _hTitleFont;        // The title font for the Welcome and Completion pages
    HFONT           _h95HeaderFont;     // The title font for the Wizard 95 interior page header titles
    HINSTANCE       _hInstance;         // HInstance the wizard is run in
    HPROPSHEETPAGE  _rghpsp[NUMPAGES];  // an array to hold the page's HPROPSHEETPAGE handles
    PROPSHEETHEADER _psh;               // defines the property sheet
    HIMAGELIST      _hil;               // shell's small image list
    BOOL            _fInit;             // has the engine been initialized yet
    BOOL            _fOOBEMode;         // are we running on from an OOBE floppy?
    BOOL            _fLegacyMode;       // are we running on a downlevel (non-whistler) machine?
    BOOL            _fWin9X;            // are we running on a Win9X machine?
    BOOL            _fWinNT4;           // are we running on a WinNT4 machine?
    BOOL            _fOldStyle;         // are we running the old-style wizard?
    BOOL            _fDelCs;            // delete critical section on terminate?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migutil.h ===
#ifndef _MIGUTIL_H_
#define _MIGUTIL_H_


#define MAX_LOADSTRING 1024

#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

LPWSTR _ConvertToUnicode(UINT cp, LPCSTR pcszSource);
LPSTR _ConvertToAnsi(UINT cp, LPCWSTR pcwszSource);

HRESULT _SHAnsiToUnicode(LPSTR pszIn, LPWSTR pwszOut, UINT cchOut);
HRESULT _SHUnicodeToAnsi(LPWSTR pwszIn, LPSTR pszOut, UINT cchOut);

INT_PTR _ExclusiveDialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc);
int     _ExclusiveMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);

int     _ComboBoxEx_AddString(HWND hwndBox, LPTSTR ptsz);
int     _ComboBoxEx_SetIconW(HWND hwndBox, LPWSTR wsz, UINT iDex);
HRESULT _ListView_AddDrives(HWND hwndList, LPTSTR pszNetworkName);

int     _GetRemovableDriveCount();
TCHAR   _GetRemovableDrive(int iDex);
LPTSTR  _GetRemovableDrivePretty(int iDex);
BOOL    _IsRemovableOrCDDrive(TCHAR chDrive);

BOOL    _IsValidStore(LPTSTR pszStore, BOOL bCreate, HINSTANCE hinst, HWND hwnd);

INT     _ComboBoxEx_AddDrives(HWND hwndBox);
INT     _ComboBoxEx_AddCOMPorts(HWND hwndBox, INT SelectedPort);

HRESULT _CreateAnimationCtrl(HWND hwndDlg, HINSTANCE hinst, UINT idMarker, UINT idAnim, UINT idAvi, HWND* pHwndAnim);


#define POPULATETREE_FLAGS_FOLDERS 0x1
#define POPULATETREE_FLAGS_FILES 0x2
#define POPULATETREE_FLAGS_FILETYPES 0x3
#define POPULATETREE_FLAGS_SETTINGS 0x4

VOID    _PopulateTree (HWND hwndTree, HTREEITEM hti, LPTSTR ptsz, UINT cch,
                       HRESULT (*fct)(HINSTANCE, BOOL, LPCTSTR, LPTSTR, UINT cchName),
                       DWORD dwFlags, HINSTANCE Instance, BOOL fNT4);

UINT    _ListView_InsertItem(HWND hwndList, LPTSTR ptsz);


HRESULT _GetPrettyFolderName(HINSTANCE Instance, BOOL fNT4, LPCTSTR pctszPath, LPTSTR ptszName, UINT cchName);
HRESULT _GetPrettyTypeName(LPCTSTR pctszType, LPTSTR ptszPrettyType, UINT cchPrettyType);

HANDLE _GetDeviceHandle(LPCTSTR psz, DWORD dwDesiredAccess, DWORD dwFileAttributes);

INT _GetFloppyNumber(BOOL fIsNT);
INT _DriveStrIsFloppy(BOOL fIsNT, PCTSTR psz);

typedef struct {
    LPTSTR pszPureName;
    BOOL fOverwrite;
} LV_DATASTRUCT;

BOOL _SetTextLoadString(HINSTANCE hInst, HWND hwnd, UINT idText);

VOID DisableCancel (VOID);

VOID EnableCancel (VOID);

VOID PostMessageForWizard (UINT Msg, WPARAM wParam, LPARAM lParam);

VOID _UpdateText (HWND hWnd, LPCTSTR  pszString);

BOOL
AppExecute (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR ExecuteArgs
    );

VOID
RestartExplorer (
    IN      HINSTANCE Instance,
    IN      HWND hwndDlg,
    IN      PCTSTR Args
    );

typedef struct {
    PCTSTR UserName;
    PCTSTR UserDomain;
} ROLLBACK_USER_ERROR, *PROLLBACK_USER_ERROR;

PTSTR
GetShellFolderPath (
    IN      INT Folder,
    IN      PCTSTR FolderStr,
    IN      BOOL UserFolder,
    OUT     LPITEMIDLIST *pidl  //OPTIONAL
    );

#define IPFL_USECALLBACK        0x0001
#define IPFL_USEDEFAULTS        0x0002

typedef HRESULT (CALLBACK *SHINVOKECALLBACK)(IDispatch *pdisp, struct SHINVOKEPARAMS *pinv);

#include <pshpack1.h>
    typedef struct SHINVOKEPARAMS {
        UINT flags;                     // mandatory
        DISPID dispidMember;            // mandatory
        const IID*piid;                 // IPFL_USEDEFAULTS will fill this in
        LCID lcid;                      // IPFL_USEDEFAULTS will fill this in
        WORD wFlags;                    // IPFL_USEDEFAULTS will fill this in
        DISPPARAMS * pdispparams;       // mandatory, may be NULL
        VARIANT * pvarResult;           // IPFL_USEDEFAULTS will fill this in
        EXCEPINFO * pexcepinfo;         // IPFL_USEDEFAULTS will fill this in
        UINT * puArgErr;                // IPFL_USEDEFAULTS will fill this in
        SHINVOKECALLBACK Callback;      // required if IPFL_USECALLBACK
    } SHINVOKEPARAMS, *LPSHINVOKEPARAMS;
#include <poppack.h>        /* Return to byte packing */

HRESULT IUnknown_CPContainerInvokeIndirect(IUnknown *punk, REFIID riidCP,
            SHINVOKEPARAMS *pinv);

VOID
_RemoveSpaces (
    IN      PTSTR szData,
    IN      UINT uDataCount
    );

HRESULT
OurSHBindToParent (
    IN      LPCITEMIDLIST pidl,
    IN      REFIID riid,
    OUT     VOID **ppv,
    OUT     LPCITEMIDLIST *ppidlLast
    );

typedef struct _TAG_OBJLIST {
    PTSTR ObjectName;
    PTSTR AlternateName;
    struct _TAG_OBJLIST *Next;
} OBJLIST, *POBJLIST;

POBJLIST
_AllocateObjectList (
    IN      PCTSTR ObjectName
    );

VOID
_FreeObjectList (
    IN      POBJLIST ObjectList
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\pch.h ===
#include "ism.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\scanstate\pch.h ===
#include "baseinc.h"
#include "allutils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migwnprc.cpp ===
#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <prsht.h>
#include <tchar.h>
#include <windef.h>
#include "resource.h"
#include "commdlg.h"
#include "shlwapi.h"
#include "shellapi.h"

#include "migwiz.h"
#include "miginf.h"
#include "migutil.h"
#include "migtask.h"
#include "migeng.h"

#include "basetypes.h"
#include "utiltypes.h"
#include "objstr.h"
#include "container.h"

extern "C" {
#include "ism.h"
#include "main.h"
}

#include "modules.h"

#define ENGINE_RULE_MAXLEN  4000
#define ENGINE_TIMEOUT      180000

#define DOWNSHIFT_PIXEL_OFFSET  60
#define UPSHIFT_PIXEL_OFFSET    -11
#define PATH_SAFETY_CHARS       26

#define ANIMATE_OPEN(w,c,x) SendDlgItemMessage(w,c,ACM_OPEN,(WPARAM)NULL,(LPARAM)(LPTSTR)MAKEINTRESOURCE(x))
#define ANIMATE_PLAY(w,c)   SendDlgItemMessage(w,c,ACM_PLAY,(WPARAM)-1,(LPARAM)MAKELONG(0,-1))
#define ANIMATE_STOP(w,c)   SendDlgItemMessage(w,c,ACM_STOP,(WPARAM)0,(LPARAM)0);
#define ANIMATE_CLOSE(w,c)  SendDlgItemMessage(w,c,ACM_OPEN,(WPARAM)NULL,(LPARAM)NULL);

///////////////////////////////////////////////////////////////
// globals

extern BOOL g_LogOffSystem;
extern BOOL g_RebootSystem;
extern BOOL g_ConfirmedLogOff;
extern BOOL g_ConfirmedReboot;

MigrationWizard* g_migwiz;

HTREEITEM g_htiFolders;
HTREEITEM g_htiFiles;
HTREEITEM g_htiSettings;
HTREEITEM g_htiTypes;

// ISSUE: embed selections within the migration wizard

BOOL g_fStoreToNetwork;  // OLD COMPUTER ONLY: this means we've selected to store to the network
BOOL g_fStoreToFloppy;   // OLD COMPUTER ONLY: this means we've selected to store to floppies
BOOL g_fStoreToCable;    // this means we've selected direct cable transport

BOOL g_fReadFromNetwork; // NEW COMPUTER ONLY: this means go ahead and read from the network immediately
TCHAR g_szStore[MAX_PATH];
BOOL g_NextPressed;

BOOL g_fHaveWhistlerCD = FALSE;
BOOL g_fAlreadyCollected = FALSE;

TCHAR g_szToolDiskDrive[MAX_PATH];

INT g_iEngineInit = ENGINE_NOTINIT;

BOOL g_fCustomize; // used to store whether we've customized or not to help with navigation
BOOL g_fOldComputer; // used to store whether we're on the old computer or not to help with navigation
BOOL g_fHaveJaz = FALSE;
BOOL g_fHaveZip = FALSE;
BOOL g_fHaveNet = FALSE;
BOOL g_hInitResult = E_FAIL;
BOOL g_fCancelPressed = FALSE;
BOOL g_fPickMethodReset = TRUE; // used to trigger a re-default of the PickMethod page
BOOL g_fCustomizeComp = FALSE; // if the user has some customization
BOOL g_CompleteLogOff = FALSE;
BOOL g_CompleteReboot = FALSE;

HWND g_hwndCurrent;

extern BOOL g_fUberCancel; // has the user has confirmed cancel?

HWND g_hwndDlg;
HWND g_hwndWizard;
UINT g_uChosenComponent = (UINT) -1;

HANDLE g_TerminateEvent = NULL;
CRITICAL_SECTION g_AppInfoCritSection;

MIG_PROGRESSPHASE g_AppInfoPhase;
UINT g_AppInfoSubPhase;
MIG_OBJECTTYPEID g_AppInfoObjectTypeId;
TCHAR g_AppInfoObjectName [4096];
TCHAR g_AppInfoText [4096];

extern Container *g_WebContainer;
extern TCHAR g_HTMLAppList[MAX_PATH];
extern TCHAR g_HTMLLog[MAX_PATH];
extern DWORD g_HTMLErrArea;
extern DWORD g_HTMLErrInstr;
extern PCTSTR g_HTMLErrObjectType;
extern PCTSTR g_HTMLErrObjectName;
extern POBJLIST g_HTMLApps;
extern POBJLIST g_HTMLWrnFile;
extern POBJLIST g_HTMLWrnAltFile;
extern POBJLIST g_HTMLWrnRas;
extern POBJLIST g_HTMLWrnNet;
extern POBJLIST g_HTMLWrnPrn;
extern POBJLIST g_HTMLWrnGeneral;

DWORD g_BaudRate [] = {CBR_110,
                       CBR_300,
                       CBR_600,
                       CBR_1200,
                       CBR_2400,
                       CBR_4800,
                       CBR_9600,
                       CBR_14400,
                       CBR_19200,
                       CBR_38400,
                       CBR_56000,
                       CBR_57600,
                       CBR_115200,
                       CBR_128000,
                       CBR_256000,
                       0};

// environment variables

BOOL _ShiftControl (HWND hwndControl, HWND hwndDlg, DWORD dwOffset)
{

    RECT rc;
    POINT pt;
    LONG lExStyles;

    GetWindowRect(hwndControl, &rc);
    // This should really be done once per dialog, not once per control
    lExStyles = GetWindowLong (hwndDlg, GWL_EXSTYLE);

    if (lExStyles & WS_EX_LAYOUTRTL)
    {
        pt.x = rc.right;
    }
    else
    {
        pt.x = rc.left;
    }

    pt.y = rc.top;
    ScreenToClient(hwndDlg, &pt);

    SetWindowPos(hwndControl, 0, pt.x, pt.y + dwOffset, 0, 0, SWP_NOZORDER | SWP_NOSIZE);

    return TRUE;
}

BOOL CALLBACK _DownshiftControl (HWND hwndControl, LPARAM lParam)
{
    return _ShiftControl(hwndControl, (HWND)lParam, DOWNSHIFT_PIXEL_OFFSET);
}

BOOL CALLBACK _UpshiftControl (HWND hwndControl, LPARAM lParam)
{
    return _ShiftControl(hwndControl, (HWND)lParam, UPSHIFT_PIXEL_OFFSET);
}

VOID _OldStylify (HWND hwndDlg, UINT uTitleStrID)
{
    HWND hwnd;

    // First, shift everything down
    EnumChildWindows(hwndDlg, _DownshiftControl, (LPARAM)hwndDlg);

    // Add a divider bar
    CreateWindow(TEXT("STATIC"),
                 NULL,
                 WS_CHILD | WS_VISIBLE | SS_SUNKEN,
                 0, 45,
                 515, 2,
                 hwndDlg,
                 (HMENU)IDC_WIZ95DIVIDER,
                 g_migwiz->GetInstance(),
                 NULL);

    // Add the Title
    hwnd = CreateWindow(TEXT("STATIC"),
                        NULL,
                        WS_CHILD | WS_VISIBLE,
                        11, 0,
                        475, 15,
                        hwndDlg,
                        (HMENU)IDC_WIZ95TITLE,
                        g_migwiz->GetInstance(),
                        NULL);
    // Set the Title font
    SetWindowFont(hwnd, g_migwiz->Get95HeaderFont(), TRUE);
    // Set the title string
    if (uTitleStrID != 0)
    {
        _SetTextLoadString(g_migwiz->GetInstance(), hwnd, uTitleStrID);
    }
}

// For Welcome and Completing pages
VOID _OldStylifyTitle (HWND hwndDlg)
{
    HWND hwnd;
    HANDLE hBitmap;

    // First, shift everything up
    EnumChildWindows(hwndDlg, _UpshiftControl, (LPARAM)hwndDlg);

    // Create the bitmap window
    hwnd = CreateWindow(TEXT("STATIC"),
                        NULL,
                        WS_CHILD | WS_VISIBLE | SS_BITMAP,
                        0, 0,
                        152, 290,
                        hwndDlg,
                        (HMENU)IDC_WIZ95WATERMARK,
                        g_migwiz->GetInstance(),
                        NULL);
    hBitmap = LoadImage(g_migwiz->GetInstance(),
                        MAKEINTRESOURCE(IDB_WATERMARK),
                        IMAGE_BITMAP,
                        0, 0,
                        LR_SHARED);
    SendMessage(hwnd, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBitmap);
    hBitmap = (HANDLE)SendMessage(hwnd, STM_GETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)NULL);
}

HTREEITEM __GetRootType (HWND hwndTree)
{
    TV_INSERTSTRUCT tisTypes;
    TCHAR szPickTypes[MAX_LOADSTRING];

    if (!g_htiTypes) {

        tisTypes.hParent = NULL;
        tisTypes.hInsertAfter = TVI_ROOT;
        tisTypes.item.mask  = TVIF_TEXT | TVIF_STATE;
        tisTypes.item.state = TVIS_EXPANDED;
        tisTypes.item.stateMask = TVIS_EXPANDED;

        LoadString(g_migwiz->GetInstance(), IDS_PICK_TYPES, szPickTypes, ARRAYSIZE(szPickTypes));
        tisTypes.item.pszText = szPickTypes;

        g_htiTypes = TreeView_InsertItem(hwndTree, &tisTypes);
    }

    return g_htiTypes;
}

HTREEITEM __GetRootFolder (HWND hwndTree)
{
    TV_INSERTSTRUCT tisFolders;
    TCHAR szPickFolders[MAX_LOADSTRING];

    if (!g_htiFolders) {

        tisFolders.hParent = NULL;
        tisFolders.hInsertAfter = TVI_ROOT;
        tisFolders.item.mask  = TVIF_TEXT | TVIF_STATE;
        tisFolders.item.state = TVIS_EXPANDED;
        tisFolders.item.stateMask = TVIS_EXPANDED;

        LoadString(g_migwiz->GetInstance(), IDS_PICK_FOLDERS, szPickFolders, ARRAYSIZE(szPickFolders));
        tisFolders.item.pszText = szPickFolders;

        g_htiFolders = TreeView_InsertItem(hwndTree, &tisFolders);
    }

    return g_htiFolders;
}

HTREEITEM __GetRootFile (HWND hwndTree)
{
    TV_INSERTSTRUCT tisFiles;
    TCHAR szPickFiles[MAX_LOADSTRING];

    if (!g_htiFiles) {

        tisFiles.hParent = NULL;
        tisFiles.hInsertAfter = TVI_ROOT;
        tisFiles.item.mask  = TVIF_TEXT | TVIF_STATE;
        tisFiles.item.state = TVIS_EXPANDED;
        tisFiles.item.stateMask = TVIS_EXPANDED;

        LoadString(g_migwiz->GetInstance(), IDS_PICK_FILES, szPickFiles, ARRAYSIZE(szPickFiles));
        tisFiles.item.pszText = szPickFiles;

        g_htiFiles = TreeView_InsertItem(hwndTree, &tisFiles);
    }

    return g_htiFiles;
}

HTREEITEM __GetRootSetting (HWND hwndTree)
{
    TV_INSERTSTRUCT tisSettings;
    TCHAR szPickSettings[MAX_LOADSTRING];

    if (!g_htiSettings) {

        tisSettings.hParent = NULL;
        tisSettings.hInsertAfter = TVI_ROOT;
        tisSettings.item.mask  = TVIF_TEXT | TVIF_STATE;
        tisSettings.item.state = TVIS_EXPANDED;
        tisSettings.item.stateMask = TVIS_EXPANDED;

        LoadString(g_migwiz->GetInstance(), IDS_PICKSETTINGS, szPickSettings, ARRAYSIZE(szPickSettings));
        tisSettings.item.pszText = szPickSettings;

        g_htiSettings = TreeView_InsertItem(hwndTree, &tisSettings);
    }

    return g_htiSettings;
}

HRESULT _AddType (HWND hwndTree, LPCTSTR lpszFileType, LPCTSTR lpszFileTypePretty)
{
    HRESULT hr = E_OUTOFMEMORY;
    TCHAR tszCombine[2000];

    if (_tcslen(lpszFileType) + _tcslen(lpszFileTypePretty) + 6 >= 2000) {
        return E_FAIL;
    }

    // ISSUE: potential for overflow, but wnsprintf doesn't work on downlevel.  Ideas?
    lstrcpy(tszCombine, TEXT("*."));
    lstrcat(tszCombine, lpszFileType);
    if (lpszFileTypePretty && *lpszFileTypePretty)
    {
        lstrcat(tszCombine, TEXT(" - "));
        lstrcat(tszCombine, lpszFileTypePretty);
    }

    TV_INSERTSTRUCT tis = {0};
    tis.hParent = __GetRootType(hwndTree);
    tis.hInsertAfter = TVI_SORT;
    tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
    tis.item.pszText = tszCombine;
    tis.item.lParam = (LPARAM)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
    if (tis.item.lParam)
    {
        ((LV_DATASTRUCT*)tis.item.lParam)->fOverwrite = FALSE;
        ((LV_DATASTRUCT*)tis.item.lParam)->pszPureName = StrDup(lpszFileType);
        if (!((LV_DATASTRUCT*)tis.item.lParam)->pszPureName)
        {
            LocalFree((HLOCAL)tis.item.lParam);
        }
        else
        {
            //
            // Add the component to the engine and tree control, unless it already exists
            //

            // Check if it is already in the tree
            if (!IsmIsComponentSelected (lpszFileType, COMPONENT_EXTENSION)) {
                // Not in the tree; select it if it exists as a component
                if (!IsmSelectComponent (lpszFileType, COMPONENT_EXTENSION, TRUE)) {

                    // Not a component; add the component
                    IsmAddComponentAlias (
                        NULL,
                        MASTERGROUP_FILES_AND_FOLDERS,
                        lpszFileType,
                        COMPONENT_EXTENSION,
                        TRUE
                        );
                }

                TreeView_InsertItem(hwndTree, &tis);

                // if the user hits BACK we will remember that the user customized stuff
                g_fCustomizeComp = TRUE;
            }

            hr = S_OK;
        }
    }

    return hr;
}

VOID
CopyStorePath(LPTSTR pszIn, LPTSTR pszOut)
{
    TCHAR *ptsLastSpace = NULL;

    *pszOut = '\0';
    if( ! pszIn )
        return;

    //
    //  Step 1: Skip over leading white space
    //

    while( *pszIn && _istspace(*pszIn) )
        pszIn = _tcsinc(pszIn);


    //
    //  Step 2: Copy the string, stripping out quotes and keeping
    //          track of the last space after valid text in order
    //          to strip out trailing space.
    //

    while( *pszIn )
    {
        if( _tcsnextc(pszIn) == '\"' )
        {
            pszIn = _tcsinc(pszIn);
            continue;
        }

        if( _istspace(*pszIn) )
        {
            if( ! ptsLastSpace )
            {
                ptsLastSpace = pszOut;
            }
        }
        else
        {
            ptsLastSpace = NULL;
        }

#ifdef UNICODE
        *pszOut++ = *pszIn++;
#else
        if( isleadbyte(*pszIn) )
        {
            *pszOut++ = *pszIn++;
        }
        *pszOut++ = *pszIn++;
#endif

    }

    //
    //  Step 3: Terminate the output string correctly
    //

    if( ptsLastSpace )
    {
        *ptsLastSpace = '\0';
    }
    else
    {
        *pszOut = '\0';
    }

    return;
}




BOOL _IsNetworkPath(LPTSTR pszPath)
{
    TCHAR tszDriveName[4] = TEXT("?:\\");
    tszDriveName[0] = pszPath[0];
    return ((pszPath[0] == '\\' && pszPath[1] == '\\') || DRIVE_REMOTE == GetDriveType(tszDriveName));
}

int CALLBACK
AddFolderCallback (
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    HRESULT hr = S_OK;
    TCHAR tszFolderName[MAX_PATH];
    IMalloc *mallocFn = NULL;
    IShellFolder *psfParent = NULL;
    IShellLink *pslLink = NULL;
    LPCITEMIDLIST pidl;
    LPCITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlReal = NULL;

    if (uMsg == BFFM_SELCHANGED) {

        hr = SHGetMalloc (&mallocFn);
        if (!SUCCEEDED (hr)) {
            mallocFn = NULL;
        }

        pidl = (LPCITEMIDLIST) lParam;
        pidlReal = NULL;

        if (pidl) {

            hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

            if (SUCCEEDED(hr)) {
                hr = psfParent->GetUIObjectOf (hwnd, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                if (SUCCEEDED(hr)) {
                    hr = pslLink->GetIDList (&pidlReal);
                    if (!SUCCEEDED(hr)) {
                        pidlReal = NULL;
                    }
                    pslLink->Release ();
                }
                pidlRelative = NULL;
                psfParent->Release ();
            }

            if (SHGetPathFromIDList(pidlReal?pidlReal:pidl, tszFolderName) == TRUE)
            {
                if ((tszFolderName[0] == 0) ||
                    (_IsNetworkPath(tszFolderName))
                    ) {
                    SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
                }
            } else {
                SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
            }

            if (pidlReal) {
                if (mallocFn) {
                    mallocFn->Free ((void *)pidlReal);
                }
                pidlReal = NULL;
            }
        }

        if (mallocFn) {
            mallocFn->Release ();
            mallocFn = NULL;
        }
    }
    return 0;
}

HRESULT _AddFolder (HWND hwndDlg, HWND hwndTree)
{
    HRESULT hr = S_OK;
    TCHAR tszFolderName[MAX_PATH];

    IMalloc *mallocFn = NULL;
    IShellFolder *psfParent = NULL;
    IShellLink *pslLink = NULL;
    LPCITEMIDLIST pidl;
    LPCITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlReal = NULL;

    TCHAR szPick[MAX_LOADSTRING];

    hr = SHGetMalloc (&mallocFn);
    if (!SUCCEEDED (hr)) {
        mallocFn = NULL;
    }

    LoadString(g_migwiz->GetInstance(), IDS_ADDAFOLDER, szPick, ARRAYSIZE(szPick));
    BROWSEINFO brwsinf = { hwndDlg, NULL, NULL, szPick, BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE, AddFolderCallback, 0, 0 };
    // loop until we get pidl or cancel cancels
    BOOL fDone = FALSE;
    while (!fDone)
    {
        pidl = SHBrowseForFolder(&brwsinf);
        if (pidl)
        {
            hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

            if (SUCCEEDED(hr)) {
                hr = psfParent->GetUIObjectOf (hwndDlg, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                if (SUCCEEDED(hr)) {
                    hr = pslLink->GetIDList (&pidlReal);
                    if (SUCCEEDED(hr)) {
                        if (mallocFn) {
                            mallocFn->Free ((void *)pidl);
                        }
                        pidl = pidlReal;
                        pidlReal = NULL;
                    }
                    pslLink->Release ();
                }
                pidlRelative = NULL;
                psfParent->Release ();
            }

            if (SHGetPathFromIDList(pidl, tszFolderName))
            {
                fDone = TRUE; // user chose a valid folder
            }
        }
        else
        {
            fDone = TRUE; // user cancelled
        }
    }

    if (pidl)
    {
        TCHAR tszPrettyFolderName[MAX_PATH];
        hr = _GetPrettyFolderName (
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4(),
                    tszFolderName,
                    tszPrettyFolderName,
                    ARRAYSIZE(tszPrettyFolderName)
                    );
        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;

            SHFILEINFO sfi = {0};
            SHGetFileInfo((PCTSTR) (pidlReal?pidlReal:pidl), FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), SHGFI_SMALLICON | SHGFI_SYSICONINDEX | SHGFI_PIDL);

            TV_INSERTSTRUCT tis = {0};
            tis.hParent = __GetRootFolder (hwndTree);
            tis.hInsertAfter = TVI_SORT;
            tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
            tis.item.pszText = tszPrettyFolderName;
            tis.item.lParam = (LPARAM)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
            if (tis.item.lParam)
            {
                ((LV_DATASTRUCT*)tis.item.lParam)->fOverwrite = FALSE;
                ((LV_DATASTRUCT*)tis.item.lParam)->pszPureName = StrDup(tszFolderName);
                if (!((LV_DATASTRUCT*)tis.item.lParam)->pszPureName)
                {
                    LocalFree((HLOCAL)tis.item.lParam);
                }
                else
                {
                    //
                    // Add the component to the engine and tree control, unless it already exists
                    //

                    // Check if it is already in the tree
                    if (!IsmIsComponentSelected (tszFolderName, COMPONENT_FOLDER)) {

                        // Not in the tree; select it if it exists as a component
                        if (!IsmSelectComponent (tszFolderName, COMPONENT_FOLDER, TRUE)) {

                            // Not a component; add the component
                            IsmAddComponentAlias (
                                NULL,
                                MASTERGROUP_FILES_AND_FOLDERS,
                                tszFolderName,
                                COMPONENT_FOLDER,
                                TRUE
                                );
                        }

                        TreeView_InsertItem(hwndTree, &tis);

                        // if the user hits BACK we will remember that the user customized stuff
                        g_fCustomizeComp = TRUE;
                    }

                    hr = S_OK;
                }
            }
        }
        if (mallocFn) {
            mallocFn->Free ((void *)pidl);
        }
        pidl = NULL;
    }

    if (mallocFn) {
        mallocFn->Release ();
        mallocFn = NULL;
    }

    return hr;
}

HRESULT _AddSetting (HWND hwndTree, LPTSTR lpszSetting)
{
    HRESULT hr = E_OUTOFMEMORY;

    TV_INSERTSTRUCT tis = {0};
    tis.hParent = __GetRootSetting(hwndTree);
    tis.hInsertAfter = TVI_SORT;
    tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
    tis.item.pszText = lpszSetting;
    tis.item.lParam = (LPARAM)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
    if (tis.item.lParam)
    {
        ((LV_DATASTRUCT*)tis.item.lParam)->pszPureName = NULL;
        ((LV_DATASTRUCT*)tis.item.lParam)->fOverwrite = FALSE;

        //
        // Add the component to the engine and tree control, unless it already exists
        //

        // Check if it is already in the tree
        if (!IsmIsComponentSelected (lpszSetting, COMPONENT_NAME)) {

            // Not in the tree; select it if it exists as a component
            if (!IsmSelectComponent (lpszSetting, COMPONENT_NAME, TRUE)) {

                // Not a component; add the component
                IsmAddComponentAlias (
                    NULL,
                    MASTERGROUP_FILES_AND_FOLDERS,
                    lpszSetting,
                    COMPONENT_NAME,
                    TRUE
                    );
            }
            TreeView_InsertItem(hwndTree, &tis);

            // if the user hits BACK we will remember that the user customized stuff
            g_fCustomizeComp = TRUE;
        }
        hr = S_OK;
    }
    return hr;
}

HRESULT _AddFile (HWND hwndDlg, HWND hwndTree)
{
    TCHAR szCurrDir[MAX_PATH] = TEXT("");
    TCHAR szPath[MAX_PATH];
    szPath[0] = TEXT('\0');
    TCHAR szPick[MAX_LOADSTRING];
    TCHAR szAll[MAX_LOADSTRING + 6];
    HRESULT hr = S_OK;
    BOOL fDone = FALSE;
    BOOL fGotFile = FALSE;
    PTSTR mydocsDir = NULL;
    PTSTR lpstrFilter;
    DWORD dwLength;

    LoadString(g_migwiz->GetInstance(), IDS_PICKAFILE, szPick, ARRAYSIZE(szPick));
    dwLength = LoadString(g_migwiz->GetInstance(), IDS_OPENFILEFILTER_ALL, szAll, MAX_LOADSTRING);
    memcpy (szAll + dwLength, TEXT("\0*.*\0\0"), 6 * sizeof (TCHAR));
    OPENFILENAME of = {
        g_migwiz->GetLegacy() ? OPENFILENAME_SIZE_VERSION_400 : sizeof(OPENFILENAME), // DWORD        lStructSize;
        hwndDlg,                               // HWND         hwndOwner;
        NULL,                                  // HINSTANCE    hInstance;
        szAll,                                 // LPCTSTR      lpstrFilter;
        NULL,                                  // LPTSTR       lpstrCustomFilter;
        NULL,                                  // DWORD        nMaxCustFilter;
        1,                                     // DWORD        nFilterIndex;
        szPath,                                // LPTSTR       lpstrFile;
        MAX_PATH,                              // DWORD        nMaxFile;
        NULL,                                  // LPTSTR       lpstrFileTitle;
        NULL,                                  // DWORD        nMaxFileTitle;
        NULL,                                  // LPCTSTR      lpstrInitialDir;
        szPick,                                // LPCTSTR      lpstrTitle;
        OFN_NODEREFERENCELINKS | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NONETWORKBUTTON | OFN_HIDEREADONLY, // DWORD        Flags;
        0,                                     // WORD         nFileOffset;
        0,                                     // WORD         nFileExtension;
        NULL,                                  // LPCTSTR      lpstrDefExt;
        NULL,                                  // LPARAM       lCustData;
        NULL,                                  // LPOFNHOOKPROC lpfnHook;
        NULL,                                  // LPCTSTR      lpTemplateName;
    };

    while (!fDone)
    {
        // we need to set the current directory to be in "My Documents" for this dialog
        // to work properly. If we don't the dialog will open in the current directory
        // which is the temp dir where we copied the wizard.

        if (GetCurrentDirectory(ARRAYSIZE(szCurrDir), szCurrDir)) {
            mydocsDir = GetShellFolderPath (CSIDL_MYDOCUMENTS, TEXT("My Documents"), TRUE, NULL);
            if (!mydocsDir) {
                mydocsDir = GetShellFolderPath (CSIDL_PERSONAL, TEXT("Personal"), TRUE, NULL);
            }
            if (mydocsDir) {
                SetCurrentDirectory (mydocsDir);
                LocalFree (mydocsDir);
            }
        }
        fGotFile = GetOpenFileName(&of);
        if (szCurrDir [0]) {
            SetCurrentDirectory (szCurrDir);
        }
        if (!fGotFile)
        {
            fDone = TRUE;
        }
        else
        {
            if (_IsNetworkPath(szPath))
            {
                // if LoadStrings fail, we default to english
                TCHAR szNoNetworkMsg[MAX_LOADSTRING];
                TCHAR szNoNetworkCaption[MAX_LOADSTRING] = TEXT("Files and Settings Transfer Wizard");
                if (!LoadString(g_migwiz->GetInstance(), IDS_NONETWORK, szNoNetworkMsg, ARRAYSIZE(szPick)))
                {
                    StrCpyN(szNoNetworkMsg, TEXT("Network files and folders cannot be transferred.  Please choose again."), ARRAYSIZE(szNoNetworkMsg));
                }
                if (!LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szNoNetworkCaption, ARRAYSIZE(szPick)))
                {
                    StrCpyN(szNoNetworkCaption, TEXT("Files and Settings Transfer Wizard"), ARRAYSIZE(szNoNetworkMsg));
                }
                _ExclusiveMessageBox(hwndDlg, szNoNetworkMsg, szNoNetworkCaption, MB_OK);
            }
            else
            {
                fDone = TRUE; // user chose a non-network folder
            }
        }
    }

    if (fGotFile)
    {
        hr = E_OUTOFMEMORY;

        TV_INSERTSTRUCT tis = {0};
        tis.hParent = __GetRootFile (hwndTree);
        tis.hInsertAfter = TVI_SORT;
        tis.item.mask  = TVIF_TEXT | TVIF_PARAM;
        tis.item.pszText = szPath;
        tis.item.lParam = (LPARAM)LocalAlloc(LPTR, sizeof(LV_DATASTRUCT));
        if (tis.item.lParam)
        {
            ((LV_DATASTRUCT*)tis.item.lParam)->pszPureName = NULL;
            ((LV_DATASTRUCT*)tis.item.lParam)->fOverwrite = FALSE;

            //
            // Add the component to the engine and tree control, unless it already exists
            //

            // Check if it is already in the tree
            if (!IsmIsComponentSelected (szPath, COMPONENT_FILE)) {

                // Not in the tree; select it if it exists as a component
                if (!IsmSelectComponent (szPath, COMPONENT_FILE, TRUE)) {

                    // Not a component; add the component
                    IsmAddComponentAlias (
                        NULL,
                        MASTERGROUP_FILES_AND_FOLDERS,
                        szPath,
                        COMPONENT_FILE,
                        TRUE
                        );
                }

                TreeView_InsertItem(hwndTree, &tis);

                // if the user hits BACK we will remember that the user customized stuff
                g_fCustomizeComp = TRUE;
            }

            hr = S_OK;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _FileTypeDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static bool fDoneInit;
    static HWND hwndParent;
    switch (uMsg)
    {
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_DBLCLK:
            // On this dialog, this message can only come from the listview.
            // If there is something selected, that means the user doubleclicked on an item
            // On a doubleclick we will trigger the OK button
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_FILETYPE_LIST)) > 0)
            {
                SendMessage (GetDlgItem(hwndDlg, IDOK), BM_CLICK, 0, 0);
            }
            break;
        case LVN_ITEMCHANGED:
            {
                if (fDoneInit) // ignore messages during WM_INITDIALOG
                {
                    if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_FILETYPE_LIST)) > 0)
                    {
                        Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
                    }
                    else
                    {
                        Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);
                    }
                }
            }
            break;
        }
        break;

    case WM_INITDIALOG :
        {
            fDoneInit = FALSE;
            hwndParent = (HWND)lParam;
            HWND hwndList = GetDlgItem(hwndDlg, IDC_FILETYPE_LIST);
            ListView_DeleteAllItems(hwndList);
            Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);

            LVCOLUMN lvcolumn;
            lvcolumn.mask = LVCF_TEXT | LVCF_WIDTH;
            lvcolumn.cx = 75;
            TCHAR szColumn[MAX_LOADSTRING];
            LoadString(g_migwiz->GetInstance(), IDS_COLS_EXTENSIONS, szColumn, ARRAYSIZE(szColumn));
            lvcolumn.pszText = szColumn;
            ListView_InsertColumn(hwndList, 0, &lvcolumn);
            lvcolumn.cx = 235;
            LoadString(g_migwiz->GetInstance(), IDS_COLS_FILETYPES, szColumn, ARRAYSIZE(szColumn));
            lvcolumn.pszText = szColumn;
            ListView_InsertColumn(hwndList, 1, &lvcolumn);

            DWORD dwRetVal = ERROR_SUCCESS;
            UINT i = 0;
            BOOL fImageListSet = FALSE;

            // 1.  insert all the extensions
            while (ERROR_SUCCESS == dwRetVal)
            {
                TCHAR szKeyName[MAX_PATH];
                DWORD cchKeyName = ARRAYSIZE(szKeyName);
                dwRetVal = RegEnumKeyEx(HKEY_CLASSES_ROOT, i++, szKeyName, &cchKeyName,
                                        NULL, NULL, NULL, NULL);
                if (dwRetVal == ERROR_SUCCESS && cchKeyName > 0)
                {
                    if (szKeyName[0] == TEXT('.'))// &&
                        //!IsmIsComponentSelected(szKeyName + 1, COMPONENT_EXTENSION))
                    {
                        INFCONTEXT context;

                        // read the screened extensions from MIGWIZ.INF and
                        // don't add it if it's there
                        if (!SetupFindFirstLine (g_hMigWizInf, TEXT("Screened Extensions"), szKeyName+1, &context)) {
                            _ListView_InsertItem(hwndList, szKeyName+1);
                        }
                    }
                }
            }


            // 2.  remove all the extensions already in the engine
            MIG_COMPONENT_ENUM mce;
            int iFoundItem;
            LVFINDINFO findinfo;
            findinfo.flags = LVFI_STRING;
            findinfo.vkDirection = VK_DOWN;

            if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES|COMPONENTENUM_ENABLED, COMPONENT_EXTENSION))
            {
                do
                {
                    findinfo.psz = mce.LocalizedAlias;

                    iFoundItem = ListView_FindItem(hwndList, -1, &findinfo);
                    if (-1 != iFoundItem)
                    {
                        ListView_DeleteItem(hwndList, iFoundItem);
                    }

                    mce.SkipToNextComponent = TRUE;

                } while (IsmEnumNextComponent (&mce));
            }

            // 3.  add the extensions in the engine, but removed, yet not in the registry
            if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES|COMPONENTENUM_DISABLED, COMPONENT_EXTENSION))
            {
                do
                {
                    findinfo.psz = mce.LocalizedAlias;

                    iFoundItem = ListView_FindItem(hwndList, -1, &findinfo);
                    if (-1 == iFoundItem)
                    {
                        _ListView_InsertItem(hwndList, (LPTSTR)mce.LocalizedAlias);
                    }

                    mce.SkipToNextComponent = TRUE;

                } while (IsmEnumNextComponent (&mce));
            }

            // 3.  add in the *. and the pretty names
            TCHAR szName[MAX_PATH];
            TCHAR szPrettyName[MAX_PATH];
            LVITEM lvitem = {0};
            lvitem.mask = LVIF_TEXT;
            lvitem.pszText = szName;
            lvitem.cchTextMax = ARRAYSIZE(szName);


            int cListView = ListView_GetItemCount(hwndList);

            for (int j = 0; j < cListView; j++)
            {
                lvitem.iItem = j;
                ListView_GetItem(hwndList, &lvitem);
                memmove(szName + 2, szName, sizeof(szName) - (2 * sizeof(TCHAR)));
                szName[0] = '*';
                szName[1] = '.';

                ListView_SetItemText(hwndList, j, 0, szName);

                if (SUCCEEDED(_GetPrettyTypeName(szName, szPrettyName, ARRAYSIZE(szPrettyName))))
                {
                    ListView_SetItemText(hwndList, j, 1, szPrettyName);
                }
            }

            if (cListView) {
                // let's select the first one
                ListView_SetItemState (hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
                // the OK button should be enabled
                Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
            }

            ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

            Edit_LimitText(GetDlgItem(hwndDlg, IDC_FILETYPEEDIT), MAX_PATH - 4);

            fDoneInit = TRUE;
        }
        return TRUE;
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE)
        {

            Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
            break;
        }

        switch (LOWORD(wParam))
        {
        case IDOK:
            {
                HWND hwndTree = GetDlgItem(hwndParent, IDC_CUSTOMIZE_TREE);
                HWND hwndList = GetDlgItem(hwndDlg, IDC_FILETYPE_LIST);
                UINT cSelCount = ListView_GetSelectedCount(hwndList);
                INT iIndex = -1;
                TCHAR szFileType[MAX_PATH];
                TCHAR szFileTypePretty[MAX_PATH];

                for (UINT x=0; x < cSelCount; x++)
                {
                    iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED);
                    if (iIndex == -1)
                    {
                        break;
                    }

                    // add "doc", not "*.doc"
                    ListView_GetItemText(hwndList, iIndex, 0, szFileType, ARRAYSIZE(szFileType));
                    memmove(szFileType, szFileType + 2, sizeof(szFileType) - (2 * sizeof(TCHAR)));

                    ListView_GetItemText(hwndList, iIndex, 1, szFileTypePretty, ARRAYSIZE(szFileTypePretty));

                    _AddType(hwndTree, szFileType, szFileTypePretty);
                }

                // Now check the edit box
                SendMessage(GetDlgItem(hwndDlg, IDC_FILETYPEEDIT), WM_GETTEXT,
                            (WPARAM)ARRAYSIZE(szFileType), (LPARAM)szFileType);
                if (*szFileType)
                {
                    szFileTypePretty [0] = 0;
                    _RemoveSpaces (szFileType, ARRAYSIZE (szFileType));
                    _GetPrettyTypeName(szFileType, szFileTypePretty, ARRAYSIZE(szFileTypePretty));
                    if (szFileType[0] == TEXT('*') && szFileType[1] == TEXT('.'))
                    {
                        _AddType(hwndTree, szFileType + 2, szFileTypePretty);
                    }
                    else
                    {
                        _AddType(hwndTree, szFileType, szFileTypePretty);
                    }
                }

                EndDialog(hwndDlg, 1);
                return TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            return TRUE;
            break;
        }
        break;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _SettingDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndParent;
    switch (uMsg)
    {
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_DBLCLK:
            // On this dialog, this message can only come from the listview.
            // If there is something selected, that means the user doubleclicked on an item
            // On a doubleclick we will trigger the OK button
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_SETTINGPICKER_LIST)) > 0)
            {
                SendMessage (GetDlgItem(hwndDlg, IDOK), BM_CLICK, 0, 0);
            }
            break;
        case LVN_ITEMCHANGED:
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_SETTINGPICKER_LIST)) > 0)
            {
                Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
            }
            else
            {
                Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);
            }
            break;
        }
        break;

    case WM_INITDIALOG :
        {
            BOOL fListEmpty = TRUE;
            hwndParent = (HWND)lParam;
            HWND hwndList = GetDlgItem(hwndDlg, IDC_SETTINGPICKER_LIST);
            ListView_DeleteAllItems(hwndList);

            LVCOLUMN lvcolumn;
            lvcolumn.mask = LVCF_WIDTH;
            lvcolumn.cx = 250; // BUGBUG: should read width from box
            ListView_InsertColumn(hwndList, 0, &lvcolumn);

            Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);

            MIG_COMPONENT_ENUM mce;
            if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES | COMPONENTENUM_DISABLED |
                                       COMPONENTENUM_PREFERRED_ONLY, COMPONENT_NAME))
            {
                do
                {
                    if (MASTERGROUP_SYSTEM == mce.MasterGroup || MASTERGROUP_APP == mce.MasterGroup)
                    {
                        _ListView_InsertItem(hwndList, (PTSTR) mce.LocalizedAlias);
                        if (fListEmpty) {
                            ListView_SetItemState (hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
                            fListEmpty = FALSE;
                        }
                    }
                }
                while (IsmEnumNextComponent (&mce));
            }
            if (fListEmpty) {
                TCHAR szNothingToAdd[MAX_LOADSTRING];

                LoadString(g_migwiz->GetInstance(), IDS_NOMORE_SETTINGS, szNothingToAdd, ARRAYSIZE(szNothingToAdd));
                _ListView_InsertItem(hwndList, szNothingToAdd);
                EnableWindow (hwndList, FALSE);
            }
        }

        return TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            {
                HWND hwndTree = GetDlgItem(hwndParent, IDC_CUSTOMIZE_TREE);
                HWND hwndList = GetDlgItem(hwndDlg, IDC_SETTINGPICKER_LIST);
                TCHAR szSetting[MAX_PATH];
                INT iIndex = -1;
                UINT cSelCount = ListView_GetSelectedCount(hwndList);

                for (UINT x=0; x < cSelCount; x++)
                {
                    iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED);
                    if (iIndex == -1)
                    {
                        break;
                    }
                    ListView_GetItemText(hwndList, iIndex, 0, szSetting, ARRAYSIZE(szSetting));
                    _AddSetting(hwndTree, szSetting);
                }

                EndDialog(hwndDlg, TRUE);
                return TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, FALSE);
            return TRUE;
            break;
        }
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

VOID _SetIcons (HWND hwnd)
{
    HICON hIcon;
    HINSTANCE hInstance = g_migwiz->GetInstance();

    if (!hwnd || !hInstance)
    {
        return;
    }

    hIcon = LoadIcon (hInstance, MAKEINTRESOURCE (2000));
    if (hIcon) {
        SendMessage (hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        SendMessage (hwnd, WM_SETICON, ICON_SMALL, NULL);
    }

    SetWindowLong (hwnd, GWL_STYLE, WS_BORDER | WS_CAPTION);
    RedrawWindow (hwnd, NULL, NULL, RDW_INVALIDATE | RDW_INTERNALPAINT | RDW_ERASE);
}

VOID _SetPageHandles (HWND hwndPage)
{
    g_hwndDlg = hwndPage;
    g_hwndWizard = g_hwndDlg ? GetParent (hwndPage) : NULL;
}


VOID _NextWizardPage (HWND hwndCurrentPage)
{
    //
    // We only want to advance the page in the UI thread context
    //

    if (!g_NextPressed && g_hwndWizard) {
        if (PropSheet_GetCurrentPageHwnd (g_hwndWizard) == hwndCurrentPage) {
            PropSheet_PressButton(g_hwndWizard, PSBTN_NEXT);
            g_NextPressed = TRUE;
        }
    }
}

VOID _PrevWizardPage (VOID)
{
    //
    // We only want to advance the page in the UI thread context
    //

    if (g_hwndWizard) {
        PropSheet_PressButton(g_hwndWizard, PSBTN_BACK);
    }
}

INT_PTR CALLBACK _RootDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, DWORD dwEnabled, BOOL fTitle, UINT uiTitleID)
{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        {
            g_migwiz = (MigrationWizard*) ((LPPROPSHEETPAGE) lParam) -> lParam;

            if (fTitle)
            {
                HWND hwndControl = GetDlgItem(hwndDlg, uiTitleID);
                SetWindowFont(hwndControl, g_migwiz->GetTitleFont(), TRUE);
            }
            break;
        }

    case WM_NOTIFY :
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE : //Enable the Back and/or Next button
                g_hwndCurrent = hwndDlg;
                g_NextPressed = FALSE;
                PropSheet_SetWizButtons(GetParent(hwndDlg), dwEnabled);
                _SetPageHandles (hwndDlg);
                break;
            default :
                break;
            }
        }
        break;

    default:
        break;
    }
    return 0;
}

///////////////////////////////////////////////////////////////

VOID
pSetEvent (
    IN      HANDLE *Event
    )
{
    if (!*Event) {
        *Event = CreateEvent (NULL, TRUE, TRUE, NULL);
    } else {
        SetEvent (*Event);
    }
}

VOID
pResetEvent (
    IN      HANDLE *Event
    )
{
    if (!*Event) {
        *Event = CreateEvent (NULL, TRUE, FALSE, NULL);
    } else {
        ResetEvent (*Event);
    }
}

BOOL
pIsEventSet (
    IN      HANDLE *Event
    )
{
    DWORD result;

    if (!*Event) {
        *Event = CreateEvent (NULL, TRUE, TRUE, NULL);
        return TRUE;
    }
    result = WaitForSingleObject (*Event, 0);
    return (result == WAIT_OBJECT_0);
}

BOOL _HandleCancel (HWND hwndDlg, BOOL fStopNow, BOOL fConfirm)
{
    if (fConfirm)
    {
        TCHAR szConfirm[MAX_LOADSTRING];
        TCHAR szTitle[MAX_LOADSTRING];

        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
        LoadString(g_migwiz->GetInstance(), IDS_CONFIRMCANCEL, szConfirm, ARRAYSIZE(szConfirm));
        if (IDNO == _ExclusiveMessageBox(hwndDlg, szConfirm, szTitle, MB_YESNO | MB_DEFBUTTON2))
        {
            // Do not exit
            SetWindowLong(hwndDlg, DWLP_MSGRESULT, TRUE);
            return TRUE;
        }
    }

    g_fUberCancel = TRUE;
    g_fCancelPressed = TRUE;
    Engine_Cancel();

    if (fStopNow)
    {
        // Exit now
        SetWindowLong(hwndDlg, DWLP_MSGRESULT, FALSE);
        return FALSE;
    }

    SendMessage (g_hwndCurrent, WM_USER_CANCEL_PENDING, 0, (LPARAM) E_ABORT);

    // Do not exit
    SetWindowLong(hwndDlg, DWLP_MSGRESULT, TRUE);
    return TRUE;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _IntroDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, TRUE, IDC_INTRO_TITLE);

    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            {
            static BOOL fInit = FALSE;
            if (!fInit)
            {
                _SetIcons (g_hwndWizard);
                fInit = TRUE;
            }
            break;
            }
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, TRUE, FALSE);
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDCOLLECTFAIL);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_GETSTARTED);
            }
            return TRUE;
            break;
        }
        case NM_CLICK:
            if (wParam == IDC_INTRO_TEXT3) {
                TCHAR szAppPath[MAX_PATH] = TEXT("");
                LONG appPathSize;
                TCHAR szHtmlPath[MAX_PATH] = TEXT("");
                TCHAR szCmdLine[MAX_PATH * 3] = TEXT("");
                BOOL bResult;
                LONG lResult;
                STARTUPINFO si;
                PROCESS_INFORMATION pi;

                PNMLINK nmLink = (PNMLINK) lParam;
                if (_wcsicmp (nmLink->item.szID, L"StartHelp") == 0) {
                    if (GetWindowsDirectory (szHtmlPath, ARRAYSIZE(szHtmlPath))) {
                        // let's get the path to iexplore.exe
                        appPathSize = MAX_PATH;
                        lResult = RegQueryValue (
                                    HKEY_LOCAL_MACHINE,
                                    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"),
                                    szAppPath,
                                    &appPathSize
                                    );
                        if (lResult == ERROR_SUCCESS) {
                            _tcscat (szHtmlPath, TEXT("\\Help\\migwiz.htm"));

                            if (_tcsnextc (szAppPath) != TEXT('\"')) {
                                _tcscpy (szCmdLine, TEXT("\""));
                                _tcscat (szCmdLine, szAppPath);
                                _tcscat (szCmdLine, TEXT("\" "));
                            } else {
                                _tcscpy (szCmdLine, szAppPath);
                                _tcscat (szCmdLine, TEXT(" "));
                            }
                            _tcscat (szCmdLine, szHtmlPath);

                            ZeroMemory( &si, sizeof(STARTUPINFO) );
                            si.cb = sizeof(STARTUPINFO);
                            bResult = CreateProcess(
                                        NULL,
                                        szCmdLine,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        0,
                                        NULL,
                                        NULL,
                                        &si,
                                        &pi
                                        );
                            if (bResult) {
                                CloseHandle (pi.hProcess);
                                CloseHandle (pi.hThread);
                            }
                        }
                    }
                }
            }
            break;
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _IntroLegacyDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, TRUE, IDC_INTROLEGACY_TITLE);

    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            {
            static BOOL fInit = FALSE;

            g_fOldComputer = TRUE; // we are on the old machine

            if (!fInit)
            {
                _SetIcons (g_hwndWizard);
                fInit = TRUE;
            }
            break;
            }
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, TRUE, FALSE);
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDCOLLECTFAIL);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_WAIT);
            }
            return TRUE;
            break;
        }
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _IntroOOBEDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, TRUE, IDC_INTROOOBE_TITLE);

    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            break;
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, TRUE, FALSE);
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDCOLLECTFAIL);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD); // go on with prepare
            }
            return TRUE;
            break;
        }
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

VOID DisableCancel (VOID)
{
    if (g_hwndWizard) {
        SetFocus (GetDlgItem (g_hwndWizard, IDOK));
        EnableWindow (GetDlgItem (g_hwndWizard, IDCANCEL), FALSE);
    }
}

VOID EnableCancel (VOID)
{
    if (g_hwndWizard) {
        EnableWindow (GetDlgItem (g_hwndWizard, IDCANCEL), TRUE);
    }
}

VOID PostMessageForWizard (
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (g_hwndCurrent) {
        PostMessage (g_hwndCurrent, Msg, wParam, lParam);
    }
}

BOOL
pWriteStrResToFile (
    IN      HANDLE FileHandle,
    IN      DWORD StrId
    )
{
    TCHAR strFromRes[MAX_LOADSTRING] = TEXT("");
    INT strLen = 0;
    DWORD written;

    strLen = LoadString (g_migwiz->GetInstance(), StrId, strFromRes, ARRAYSIZE(strFromRes));
    if (strLen) {
        WriteFile (FileHandle, strFromRes, (_tcslen (strFromRes) + 1) * sizeof (TCHAR), &written, NULL);
        return TRUE;
    }
    return FALSE;
}

BOOL
pGenerateHTMLWarnings (
    IN      HANDLE FileHandle,
    IN      DWORD BeginId,
    IN      DWORD EndId,
    IN      DWORD AreaId,
    IN      DWORD InstrId,
    IN      DWORD WrnId,
    IN      DWORD WrnFileId1,
    IN      DWORD WrnFileId2,
    IN      DWORD WrnAltFileId1,
    IN      DWORD WrnAltFileId2,
    IN      DWORD WrnRasId1,
    IN      DWORD WrnRasId2,
    IN      DWORD WrnNetId1,
    IN      DWORD WrnNetId2,
    IN      DWORD WrnPrnId1,
    IN      DWORD WrnPrnId2,
    IN      DWORD WrnGeneralId1,
    IN      DWORD WrnGeneralId2
    )
{
    TCHAR szLoadStr[MAX_LOADSTRING];
    DWORD objTypes = 0;
    POBJLIST objList = NULL;
    DWORD written;

#ifdef UNICODE
    ((PBYTE)szLoadStr) [0] = 0xFF;
    ((PBYTE)szLoadStr) [1] = 0xFE;
    WriteFile (FileHandle, szLoadStr, 2, &written, NULL);
#endif

    pWriteStrResToFile (FileHandle, BeginId);

    if (AreaId) {
        pWriteStrResToFile (FileHandle, AreaId);
        if (InstrId) {
            pWriteStrResToFile (FileHandle, InstrId);
        }
    }

    // let's see if we have some object that could not be restored
    objTypes = 0;
    if (g_HTMLWrnFile) {
        objTypes ++;
    }
    if (g_HTMLWrnAltFile) {
        objTypes ++;
    }
    if (g_HTMLWrnRas) {
        objTypes ++;
    }
    if (g_HTMLWrnNet) {
        objTypes ++;
    }
    if (g_HTMLWrnPrn) {
        objTypes ++;
    }
    if (g_HTMLWrnGeneral) {
        objTypes ++;
    }
    if (objTypes) {
        if (objTypes > 1) {
            if (WrnId) {
                pWriteStrResToFile (FileHandle, WrnId);
            }
        }
        if (g_HTMLWrnFile) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnFileId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnFileId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnFile;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnAltFile) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnAltFileId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnAltFileId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnAltFile;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnRas) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnRasId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnRasId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnRas;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnNet) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnNetId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnNetId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnNet;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnPrn) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnPrnId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnPrnId2);
            }

            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnPrn;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }

            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
        if (g_HTMLWrnGeneral) {
            if (objTypes > 1) {
                pWriteStrResToFile (FileHandle, WrnGeneralId1);
            } else {
                pWriteStrResToFile (FileHandle, WrnGeneralId2);
            }
            _tcscpy (szLoadStr, TEXT("<UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

            objList = g_HTMLWrnGeneral;
            while (objList) {
                if (objList->ObjectName) {
                    _tcscpy (szLoadStr, TEXT("<LI>"));
                    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
                    WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
                }
                objList = objList->Next;
            }
            _tcscpy (szLoadStr, TEXT("</UL>\n"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
        }
    }

    pWriteStrResToFile (FileHandle, EndId);

    return TRUE;
}

INT_PTR CALLBACK _EndCollectDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLLog = INVALID_HANDLE_VALUE;
    PWSTR szTarget;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylifyTitle(hwndDlg);
        }
        if (!g_fCancelPressed) {
            webHostWnd = GetDlgItem (hwndDlg, IDC_WEBHOST);
            if (webHostWnd) {
                // Now let's generate the failure HTML file.
                if (*g_HTMLLog) {
                    hHTMLLog = CreateFile (g_HTMLLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
                    if (hHTMLLog != INVALID_HANDLE_VALUE) {
                        pGenerateHTMLWarnings (
                            hHTMLLog,
                            IDS_COLLECT_BEGIN,
                            IDS_COLLECT_END,
                            0,
                            0,
                            IDS_WARNING_SAVE,
                            IDS_WARNING_SAVEFILE1,
                            IDS_WARNING_SAVEFILE2,
                            IDS_WARNING_SAVEFILE1,
                            IDS_WARNING_SAVEFILE2,
                            IDS_WARNING_SAVERAS1,
                            IDS_WARNING_SAVERAS2,
                            IDS_WARNING_SAVENET1,
                            IDS_WARNING_SAVENET2,
                            IDS_WARNING_SAVEPRN1,
                            IDS_WARNING_SAVEPRN2,
                            0,
                            0
                            );
                        g_WebContainer = new Container();
                        if (g_WebContainer)
                        {
                            g_WebContainer->setParent(webHostWnd);
                            g_WebContainer->add(L"Shell.Explorer");
                            g_WebContainer->setVisible(TRUE);
                            g_WebContainer->setFocus(TRUE);

                            //
                            //  get the IWebBrowser2 interface and cache it.
                            //
                            punk = g_WebContainer->getUnknown();
                            if (punk)
                            {
                                punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                if (m_pweb) {
#ifdef UNICODE
                                    m_pweb->Navigate(g_HTMLLog, NULL, NULL, NULL, NULL);
#else
                                    szTarget = _ConvertToUnicode (CP_ACP, g_HTMLLog);
                                    if (szTarget) {
                                        m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                        LocalFree ((HLOCAL)szTarget);
                                        szTarget = NULL;
                                    }
#endif
                                }
                                punk->Release();
                                punk = NULL;
                            }
                        }
                        // We intentionally want to keep this file open for the life of the wizard.
                        // With this we eliminate the possibility for someone to overwrite the
                        // content of the HTML file therefore forcing us to show something else
                        // maybe even run some malicious script.
                        // CloseHandle (hHTMLLog);
                    }
                } else {
                    ShowWindow(webHostWnd, SW_HIDE);
                }
            }
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            break;
        }
        break;
    }

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDCOLLECT_TITLE);

    return 0;
}

INT_PTR CALLBACK _EndCollectNetDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLLog = INVALID_HANDLE_VALUE;
    PWSTR szTarget;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylifyTitle(hwndDlg);
        }
        if (!g_fCancelPressed) {
            webHostWnd = GetDlgItem (hwndDlg, IDC_WEBHOST);
            if (webHostWnd) {
                // Now let's generate the failure HTML file.
                if (*g_HTMLLog) {
                    hHTMLLog = CreateFile (g_HTMLLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
                    if (hHTMLLog != INVALID_HANDLE_VALUE) {
                        pGenerateHTMLWarnings (
                            hHTMLLog,
                            IDS_COLLECTNET_BEGIN,
                            IDS_COLLECTNET_END,
                            0,
                            0,
                            IDS_WARNING_SAVE,
                            IDS_WARNING_SAVEFILE1,
                            IDS_WARNING_SAVEFILE2,
                            IDS_WARNING_SAVEFILE1,
                            IDS_WARNING_SAVEFILE2,
                            IDS_WARNING_SAVERAS1,
                            IDS_WARNING_SAVERAS2,
                            IDS_WARNING_SAVENET1,
                            IDS_WARNING_SAVENET2,
                            IDS_WARNING_SAVEPRN1,
                            IDS_WARNING_SAVEPRN2,
                            0,
                            0
                            );
                        g_WebContainer = new Container();
                        if (g_WebContainer)
                        {
                            g_WebContainer->setParent(webHostWnd);
                            g_WebContainer->add(L"Shell.Explorer");
                            g_WebContainer->setVisible(TRUE);
                            g_WebContainer->setFocus(TRUE);

                            //
                            //  get the IWebBrowser2 interface and cache it.
                            //
                            punk = g_WebContainer->getUnknown();
                            if (punk)
                            {
                                punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                if (m_pweb) {
#ifdef UNICODE
                                    m_pweb->Navigate(g_HTMLLog, NULL, NULL, NULL, NULL);
#else
                                    szTarget = _ConvertToUnicode (CP_ACP, g_HTMLLog);
                                    if (szTarget) {
                                        m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                        LocalFree ((HLOCAL)szTarget);
                                        szTarget = NULL;
                                    }
#endif
                                }
                                punk->Release();
                                punk = NULL;
                            }
                        }
                        // We intentionally want to keep this file open for the life of the wizard.
                        // With this we eliminate the possibility for someone to overwrite the
                        // content of the HTML file therefore forcing us to show something else
                        // maybe even run some malicious script.
                        // CloseHandle (hHTMLLog);
                    }
                } else {
                    ShowWindow(webHostWnd, SW_HIDE);
                }
            }
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            break;
        }
        break;
    }

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDCOLLECT_TITLE);

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _EndOOBEDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDOOBE_TITLE);
    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _EndApplyDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLLog = INVALID_HANDLE_VALUE;
    PWSTR szTarget;
    TCHAR szAskForLogOff[MAX_LOADSTRING] = TEXT("");
    TCHAR szAskForReboot[MAX_LOADSTRING] = TEXT("");
    TCHAR szTitle[MAX_LOADSTRING] = TEXT("");

    switch (uMsg)
    {
    case WM_INITDIALOG:
        if (!g_fCancelPressed) {
            webHostWnd = GetDlgItem (hwndDlg, IDC_WEBHOST);
            if (webHostWnd) {
                // Now let's generate the failure HTML file.
                if (*g_HTMLLog) {
                    hHTMLLog = CreateFile (g_HTMLLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
                    if (hHTMLLog != INVALID_HANDLE_VALUE) {
                        pGenerateHTMLWarnings (
                            hHTMLLog,
                            IDS_APPLY_BEGIN,
                            IDS_APPLY_END,
                            0,
                            0,
                            IDS_WARNING_RESTORE,
                            IDS_WARNING_RESTOREFILE1,
                            IDS_WARNING_RESTOREFILE2,
                            IDS_WARNING_RESTOREALTFILE1,
                            IDS_WARNING_RESTOREALTFILE2,
                            IDS_WARNING_RESTORERAS1,
                            IDS_WARNING_RESTORERAS2,
                            IDS_WARNING_RESTORENET1,
                            IDS_WARNING_RESTORENET2,
                            IDS_WARNING_RESTOREPRN1,
                            IDS_WARNING_RESTOREPRN2,
                            IDS_WARNING_RESTOREGENERAL1,
                            IDS_WARNING_RESTOREGENERAL2
                            );
                        g_WebContainer = new Container();
                        if (g_WebContainer)
                        {
                            g_WebContainer->setParent(webHostWnd);
                            g_WebContainer->add(L"Shell.Explorer");
                            g_WebContainer->setVisible(TRUE);
                            g_WebContainer->setFocus(TRUE);

                            //
                            //  get the IWebBrowser2 interface and cache it.
                            //
                            punk = g_WebContainer->getUnknown();
                            if (punk)
                            {
                                punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                if (m_pweb) {
#ifdef UNICODE
                                    m_pweb->Navigate(g_HTMLLog, NULL, NULL, NULL, NULL);
#else
                                    szTarget = _ConvertToUnicode (CP_ACP, g_HTMLLog);
                                    if (szTarget) {
                                        m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                        LocalFree ((HLOCAL)szTarget);
                                        szTarget = NULL;
                                    }
#endif
                                }
                                punk->Release();
                                punk = NULL;
                            }
                        }
                        // We intentionally want to keep this file open for the life of the wizard.
                        // With this we eliminate the possibility for someone to overwrite the
                        // content of the HTML file therefore forcing us to show something else
                        // maybe even run some malicious script.
                        // CloseHandle (hHTMLLog);
                    }
                } else {
                    ShowWindow(webHostWnd, SW_HIDE);
                }
            }
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            break;

        case PSN_WIZFINISH:
            ShowWindow(g_hwndWizard, SW_HIDE);
            if (g_CompleteReboot) {
                g_CompleteReboot = FALSE;
                g_CompleteLogOff = FALSE;
                if (LoadString(g_migwiz->GetInstance(),
                               IDS_MIGWIZTITLE,
                               szTitle,
                               ARRAYSIZE(szTitle))) {
                    if (LoadString(g_migwiz->GetInstance(),
                                   IDS_ASKFORREBOOT,
                                   szAskForReboot,
                                   ARRAYSIZE(szAskForReboot))) {
                        if (_ExclusiveMessageBox(g_hwndWizard, szAskForReboot, szTitle, MB_YESNO) == IDYES) {
                            g_ConfirmedReboot = TRUE;
                        }
                    }
                }
            } else if (g_CompleteLogOff) {
                g_CompleteLogOff = FALSE;
                if (LoadString(g_migwiz->GetInstance(),
                               IDS_MIGWIZTITLE,
                               szTitle,
                               ARRAYSIZE(szTitle))) {
                    if (LoadString(g_migwiz->GetInstance(),
                                   IDS_ASKFORLOGOFF,
                                   szAskForLogOff,
                                   ARRAYSIZE(szAskForLogOff))) {
                        if (_ExclusiveMessageBox(g_hwndWizard, szAskForLogOff, szTitle, MB_YESNO) == IDYES) {
                            g_ConfirmedLogOff = TRUE;
                        }
                    }
                }
            }
        }
        break;
    }

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDAPPLY_TITLE);
    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    BOOL fSource;
    HWND hwndDlg;
} CLEANUPSTRUCT;

DWORD WINAPI _FailureCleanUpThread (LPVOID lpParam)
{
    CLEANUPSTRUCT* pcsStruct = (CLEANUPSTRUCT*)lpParam;
    DWORD result = WAIT_OBJECT_0;
    HRESULT hResult = ERROR_SUCCESS;

    //
    // Wait for the current thread to finish
    //
    if (g_TerminateEvent)
    {
        result = WaitForSingleObject (g_TerminateEvent, ENGINE_TIMEOUT);
    }

    //
    // Terminate the engine
    //

    if (result == WAIT_OBJECT_0) {
        hResult = Engine_Terminate ();
    }

    SendMessage (pcsStruct->hwndDlg, WM_USER_THREAD_COMPLETE, 0, (LPARAM) hResult);

    LocalFree(pcsStruct);

    return 0;
}

INT_PTR CALLBACK _CleanUpDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hResult;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_FAILCLEANUPTITLE);
        }
        break;

    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            {
                ANIMATE_OPEN(hwndDlg,IDC_WAIT_ANIMATE2,IDA_STARTUP);
                ANIMATE_PLAY(hwndDlg,IDC_WAIT_ANIMATE2);

                CLEANUPSTRUCT* pcsStruct = (CLEANUPSTRUCT*)LocalAlloc(LPTR, sizeof(CLEANUPSTRUCT));
                if (pcsStruct)
                {
                    pcsStruct->fSource = g_fOldComputer;
                    pcsStruct->hwndDlg = hwndDlg;

                    SHCreateThread(_FailureCleanUpThread, pcsStruct, 0, NULL);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, g_fOldComputer?IDD_ENDCOLLECTFAIL:IDD_ENDAPPLYFAIL);
                }
            }
            return TRUE;
            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            ANIMATE_STOP(hwndDlg,IDC_WAIT_ANIMATE2);
            ANIMATE_CLOSE(hwndDlg,IDC_WAIT_ANIMATE2);
            if (g_fCancelPressed)
            {
                // User aborted
                PostQuitMessage( 0 );
            }
            else
            {
                // Error condition
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, g_fOldComputer?IDD_ENDCOLLECTFAIL:IDD_ENDAPPLYFAIL);
            }
            return TRUE;
            break;
        }
        break;

    case WM_USER_THREAD_COMPLETE:
        hResult = (HRESULT) lParam;
        if (FAILED(hResult))
        {
            g_fUberCancel = TRUE;
        }
        _NextWizardPage (hwndDlg);
        break;

    default:
        break;
    }

    return 0;
}

INT_PTR CALLBACK _EndFailDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLLog = INVALID_HANDLE_VALUE;
    TCHAR szLoadStr[MAX_LOADSTRING];
    DWORD written;
    PWSTR szTarget;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylifyTitle(hwndDlg);
        }
        if (!g_fCancelPressed) {
            webHostWnd = GetDlgItem (hwndDlg, IDC_WEBHOST);
            if (webHostWnd) {
                // Now let's generate the failure HTML file.
                if (*g_HTMLLog) {
                    hHTMLLog = CreateFile (g_HTMLLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
                    if (hHTMLLog != INVALID_HANDLE_VALUE) {
                        pGenerateHTMLWarnings (
                            hHTMLLog,
                            IDS_ERRORHTML_BEGIN,
                            IDS_ERRORHTML_END,
                            g_HTMLErrArea?g_HTMLErrArea:IDS_ERRORAREA_UNKNOWN,
                            g_HTMLErrInstr,
                            0,
                            IDS_ERRORHTML_SAVEFILE1,
                            IDS_ERRORHTML_SAVEFILE2,
                            IDS_ERRORHTML_SAVEFILE1,
                            IDS_ERRORHTML_SAVEFILE2,
                            IDS_ERRORHTML_SAVERAS1,
                            IDS_ERRORHTML_SAVERAS2,
                            IDS_ERRORHTML_SAVENET1,
                            IDS_ERRORHTML_SAVENET2,
                            IDS_ERRORHTML_SAVEPRN1,
                            IDS_ERRORHTML_SAVEPRN2,
                            0,
                            0
                            );
                        g_WebContainer = new Container();
                        if (g_WebContainer)
                        {
                            g_WebContainer->setParent(webHostWnd);
                            g_WebContainer->add(L"Shell.Explorer");
                            g_WebContainer->setVisible(TRUE);
                            g_WebContainer->setFocus(TRUE);

                            //
                            //  get the IWebBrowser2 interface and cache it.
                            //
                            punk = g_WebContainer->getUnknown();
                            if (punk)
                            {
                                punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                if (m_pweb) {
#ifdef UNICODE
                                    m_pweb->Navigate(g_HTMLLog, NULL, NULL, NULL, NULL);
#else
                                    szTarget = _ConvertToUnicode (CP_ACP, g_HTMLLog);
                                    if (szTarget) {
                                        m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                        LocalFree ((HLOCAL)szTarget);
                                        szTarget = NULL;
                                    }
#endif
                                }
                                punk->Release();
                                punk = NULL;
                            }
                        }
                        // We intentionally want to keep this file open for the life of the wizard.
                        // With this we eliminate the possibility for someone to overwrite the
                        // content of the HTML file therefore forcing us to show something else
                        // maybe even run some malicious script.
                        // CloseHandle (hHTMLLog);
                    }
                } else {
                    ShowWindow(webHostWnd, SW_HIDE);
                }
            }
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            DisableCancel();
            break;
        }
        break;
    }

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_FINISH, TRUE, IDC_ENDFAIL_TITLE);
    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    PBOOL pfHaveNet;
    BOOL fSource;
    HWND hwndDlg;
} STARTENGINESTRUCT;

DWORD WINAPI _StartEngineDlgProcThread (LPVOID lpParam)
{
    STARTENGINESTRUCT* pseStruct = (STARTENGINESTRUCT*)lpParam;
    HRESULT hResult;

    hResult = g_migwiz->_InitEngine(pseStruct->fSource, pseStruct->pfHaveNet);

    SendMessage (pseStruct->hwndDlg, WM_USER_THREAD_COMPLETE, 0, (LPARAM) hResult);

    pSetEvent (&g_TerminateEvent);

    LocalFree(pseStruct);

    return 0;
}

INT_PTR CALLBACK _StartEngineDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hResult;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_WAITTITLE);
        }
        break;
    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, TRUE);
            break;
        case PSN_SETACTIVE:
            if ((ENGINE_INITGATHER == g_iEngineInit && g_fOldComputer) ||
                (ENGINE_INITAPPLY == g_iEngineInit && !g_fOldComputer))
            {
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
            }
            else
            {
                ANIMATE_OPEN(hwndDlg,IDC_WAIT_ANIMATE1,IDA_STARTUP);
                ANIMATE_PLAY(hwndDlg,IDC_WAIT_ANIMATE1);

                STARTENGINESTRUCT* pseStruct = (STARTENGINESTRUCT*)LocalAlloc(LPTR, sizeof(STARTENGINESTRUCT));
                if (pseStruct)
                {
                    pseStruct->fSource = g_fOldComputer;
                    pseStruct->pfHaveNet = &g_fHaveNet;
                    pseStruct->hwndDlg = hwndDlg;

                    SHCreateThread(_StartEngineDlgProcThread, pseStruct, 0, NULL);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, g_fOldComputer?IDD_ENDCOLLECTFAIL:IDD_ENDAPPLYFAIL);
                }
            }
            return TRUE;
            break;
        case PSN_WIZNEXT:
            ANIMATE_STOP(hwndDlg,IDC_WAIT_ANIMATE1);
            ANIMATE_CLOSE(hwndDlg,IDC_WAIT_ANIMATE1);
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else if (g_fOldComputer)
            {
                g_iEngineInit = ENGINE_INITGATHER;
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKCOLLECTSTORE); // go on with prepare
            }
            else
            {
                g_iEngineInit = ENGINE_INITAPPLY;
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD); // go on with apply
            }

            return TRUE;
            break;
        case PSN_WIZBACK:
            // ISSUE: we should assert here or something, this should never happen
            ANIMATE_STOP(hwndDlg,IDC_WAIT_ANIMATE1);
            ANIMATE_CLOSE(hwndDlg,IDC_WAIT_ANIMATE1);
            if (g_fOldComputer)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, g_migwiz->GetLegacy() ? IDD_INTROLEGACY : IDD_GETSTARTED);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_GETSTARTED);
            }
            return TRUE;
            break;
        }
        break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pResetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    case WM_USER_THREAD_COMPLETE:

        hResult = (HRESULT) lParam;

        if (FAILED(hResult))
        {
            g_fUberCancel = TRUE;
        }

        EnableCancel ();

        _NextWizardPage (hwndDlg);

        break;

    case WM_USER_ROLLBACK:

        // Hide IDC_WAIT_TEXT1 and show IDC_WAIT_TEXT2
        ShowWindow(GetDlgItem(hwndDlg, IDC_WAIT_TEXT1), SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_WAIT_TEXT2), SW_SHOW);
        break;

    default:
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _GetStartedDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static UINT uiSelectedStart = 2; // 1=old, 2=new

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_GETSTARTED_RADIONEW), BST_CHECKED);
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_GETSTARTED_RADIOOLD), BST_UNCHECKED);
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_GETSTARTED_RADIOOLD:
            uiSelectedStart = 1;
            break;
        case IDC_GETSTARTED_RADIONEW:
            uiSelectedStart = 2;
            break;
        }
        break;
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, TRUE, FALSE);
            break;

        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDAPPLYFAIL);
            }
            else
            {
                g_fOldComputer = (uiSelectedStart == 1);

                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_WAIT); // go on with prepare
            }

            return TRUE;
            break;

        case PSN_WIZBACK:
            SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_INTRO);
            return TRUE;
            break;
        }
        break;

    default:
        break;
    }

    return 0;
}

///////////////////////////////////////////////////////////////

VOID _CleanTreeView(HWND hwndTree)
{
    if (hwndTree)
    {
        HTREEITEM rghti[4] = { g_htiFolders, g_htiFiles, g_htiSettings, g_htiTypes };

        HTREEITEM hti;
        TVITEM item = {0};
        item.mask = TVIF_PARAM | TVIF_HANDLE;

        for (int i = 0; i < ARRAYSIZE(rghti); i++)
        {
            hti = rghti[i];

            if (hti)
            {
                hti = TreeView_GetChild(hwndTree, hti);

                while (hti)
                {
                    item.hItem = hti;
                    if (TreeView_GetItem(hwndTree, &item))
                    {
                        if (item.lParam)
                        {
                            if (((LV_DATASTRUCT*)item.lParam)->pszPureName)
                            {
                                LocalFree(((LV_DATASTRUCT*)item.lParam)->pszPureName);
                            }
                            LocalFree((HLOCAL)item.lParam);
                        }
                    }
                    hti = TreeView_GetNextItem(hwndTree, hti, TVGN_NEXT);
                }
            }
        }
        TreeView_DeleteAllItems(hwndTree);
    }
}

VOID __PopulateFilesDocumentsCollected (HWND hwndTree, UINT uiRadio)
{
    MIG_COMPONENT_ENUM mce;

    _CleanTreeView(hwndTree); // ISSUE: we should free the memory of all elements in this tree

    g_htiFolders = NULL;
    g_htiFiles = NULL;
    g_htiTypes = NULL;
    g_htiSettings = NULL;

    if (IsmEnumFirstComponent (&mce, COMPONENTENUM_ALIASES|COMPONENTENUM_ENABLED|
                               COMPONENTENUM_PREFERRED_ONLY, 0))
    {
        do {
            switch (mce.GroupId)
            {

            case COMPONENT_FOLDER:
                _PopulateTree (
                    hwndTree,
                    __GetRootFolder (hwndTree),
                    (PTSTR) mce.LocalizedAlias,
                    lstrlen (mce.LocalizedAlias) + 1,
                    _GetPrettyFolderName,
                    POPULATETREE_FLAGS_FOLDERS,
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4()
                    );
                mce.SkipToNextComponent = TRUE;
                break;

            case COMPONENT_FILE:
                _PopulateTree (
                    hwndTree,
                    __GetRootFile (hwndTree),
                    (PTSTR) mce.LocalizedAlias,
                    lstrlen (mce.LocalizedAlias) + 1,
                    NULL,
                    POPULATETREE_FLAGS_FILES,
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4()
                    );
                mce.SkipToNextComponent = TRUE;
                break;

            case COMPONENT_EXTENSION:
                _PopulateTree (
                    hwndTree,
                    __GetRootType (hwndTree),
                    (PTSTR) mce.LocalizedAlias,
                    lstrlen (mce.LocalizedAlias) + 1,
                    NULL,
                    POPULATETREE_FLAGS_FILETYPES,
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4()
                    );
                mce.SkipToNextComponent = TRUE;
                break;

            case COMPONENT_NAME:
                _PopulateTree (
                    hwndTree,
                    __GetRootSetting (hwndTree),
                    (PTSTR) mce.LocalizedAlias,
                    lstrlen (mce.LocalizedAlias) + 1,
                    NULL,
                    POPULATETREE_FLAGS_SETTINGS,
                    g_migwiz->GetInstance(),
                    g_migwiz->GetWinNT4()
                    );
                mce.SkipToNextComponent = TRUE;
                break;
            }

        } while (IsmEnumNextComponent (&mce));
    }
}

///////////////////////////////////////////////////////////////

typedef struct {
    BOOL Valid;
    PCTSTR PortName;
    DWORD PortSpeed;
    HANDLE Event;
    HANDLE Thread;
} DIRECTCABLE_DATA, *PDIRECTCABLE_DATA;

typedef struct {
    DWORD Signature;
    DWORD MaxSpeed;
} DIRECTSEND_DATA, *PDIRECTSEND_DATA;

typedef struct {
    HWND hwndCombo;
    PDIRECTCABLE_DATA DirectCableData;
} AUTODETECT_DATA, *PAUTODETECT_DATA;

HANDLE
UIOpenAndSetPort (
    IN      PCTSTR ComPort,
    OUT     PDWORD MaxSpeed
    )
{
    HANDLE result = INVALID_HANDLE_VALUE;
    COMMTIMEOUTS commTimeouts;
    DCB dcb;
    UINT index;

    // let's open the port. If we can't we just exit with error;
    result = CreateFile (ComPort, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (result == INVALID_HANDLE_VALUE) {
        return result;
    }

    // we want 10 sec timeout for both read and write
    commTimeouts.ReadIntervalTimeout = 0;
    commTimeouts.ReadTotalTimeoutMultiplier = 0;
    commTimeouts.ReadTotalTimeoutConstant = 3000;
    commTimeouts.WriteTotalTimeoutMultiplier = 0;
    commTimeouts.WriteTotalTimeoutConstant = 3000;
    SetCommTimeouts (result, &commTimeouts);

    // let's set some comm state data
    if (GetCommState (result, &dcb)) {
        dcb.fBinary = 1;
        dcb.fParity = 1;
        dcb.ByteSize = 8;
        dcb.fOutxCtsFlow = 1;
        dcb.fTXContinueOnXoff = 1;
        dcb.fRtsControl = 2;
        dcb.fAbortOnError = 1;
        dcb.Parity = 0;
        // let's first see the max speed
        if (MaxSpeed) {
            *MaxSpeed = 0;
            index = 0;
            while (TRUE) {
                dcb.BaudRate = g_BaudRate [index];
                if (dcb.BaudRate == 0) {
                    break;
                }
                if (!SetCommState (result, &dcb)) {
                    break;
                }
                *MaxSpeed = g_BaudRate [index];
                index ++;
            }
        }
        dcb.BaudRate = CBR_110;
        if (!SetCommState (result, &dcb)) {
            CloseHandle (result);
            result = INVALID_HANDLE_VALUE;
            return result;
        }
    } else {
        CloseHandle (result);
        result = INVALID_HANDLE_VALUE;
        return result;
    }

    return result;
}

#define ACK             0x16
#define NAK             0x15
#define SOH             0x01
#define EOT             0x04
#define BLOCKSIZE       (sizeof (DIRECTSEND_DATA))
#define DIRECTTR_SIG    0x55534D33  //USM2

BOOL
UISendBlockToHandle (
    IN      HANDLE DeviceHandle,
    IN      PCBYTE Buffer,
    IN      HANDLE Event
    )
{
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 0;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = FALSE;
    UINT index;

    // let's start the protocol

    // We are going to listen for the NAK(15h) signal.
    // As soon as we get it we are going to send a 4 + BLOCKSIZE bytes block having:
    // 1 byte - SOH (01H)
    // 1 byte - block number
    // 1 byte - FF - block number
    // BLOCKSIZE bytes of data
    // 1 byte - checksum - sum of all BLOCKSIZE bytes of data
    // After the block is sent, we are going to wait for ACK(16h). If we don't get
    // it after timeout or if we get something else we are going to send the block again.

    // wait for NAK
    while ((!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
            (numRead != 1) ||
            (signal != NAK)
            ) &&
           (!pIsEventSet (&Event))
           );

    repeat = FALSE;
    while (TRUE) {
        if (pIsEventSet (&Event)) {
            result = FALSE;
            break;
        }
        if (!repeat) {
            // prepare the next block
            currBlock ++;
            if (currBlock == 0) {
                result = TRUE;
            }
            buffer [0] = SOH;
            buffer [1] = currBlock;
            buffer [2] = 0xFF - currBlock;
            CopyMemory (buffer + 3, Buffer, BLOCKSIZE);

            // compute the checksum
            buffer [sizeof (buffer) - 1] = 0;
            signal = 0;
            for (index = 0; index < sizeof (buffer) - 1; index ++) {
                signal += buffer [index];
            }
            buffer [sizeof (buffer) - 1] = signal;
        }

        // now send the block to the other side
        if (!WriteFile (DeviceHandle, buffer, sizeof (buffer), &numWritten, NULL) ||
            (numWritten != sizeof (buffer))
            ) {
            repeat = TRUE;
        } else {
            repeat = FALSE;
        }

        if (pIsEventSet (&Event)) {
            result = FALSE;
            break;
        }

        if (repeat) {
            // we could not send the data last time
            // let's just wait for a NAK for 10 sec and then send it again
            ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL);
        } else {
            // we sent it OK. We need to wait for an ACK to come. If we timeout
            // or we get something else, we will repeat the block.
            if (!ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) ||
                (numRead != sizeof (signal)) ||
                (signal != ACK)
                ) {
                repeat = TRUE;
            } else {
                // we are done with data, send the EOT signal
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
                break;
            }
        }
    }

    if (result) {
        // we are done here. However, let's listen one more timeout for a
        // potential NAK. If we get it, we'll repeat the EOT signal
        while (ReadFile (DeviceHandle, &signal, sizeof (signal), &numRead, NULL) &&
            (numRead == 1)
            ) {
            if (signal == NAK) {
                signal = EOT;
                WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
            }
        }
    }

    return result;
}

BOOL
UIReceiveBlockFromHandle (
    IN      HANDLE DeviceHandle,
    OUT     PBYTE Buffer,
    IN      HANDLE Event
    )
{
    BOOL result = TRUE;
    BYTE buffer [4 + BLOCKSIZE];
    BYTE signal;
    BYTE currBlock = 1;
    DWORD numRead;
    DWORD numWritten;
    BOOL repeat = TRUE;
    UINT index;

    // finally let's start the protocol

    // We are going to send an NAK(15h) signal.
    // After that we are going to listen for a block.
    // If we don't get the block in time, or the block is wrong size
    // or it has a wrong checksum we are going to send a NAK signal,
    // otherwise we are going to send an ACK signal
    // One exception. If the block size is 1 and the block is actually the
    // EOT signal it means we are done.

    ZeroMemory (Buffer, BLOCKSIZE);

    while (TRUE) {
        if (pIsEventSet (&Event)) {
            result = FALSE;
            break;
        }
        if (repeat) {
            // send the NAK
            signal = NAK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        } else {
            // send the ACK
            signal = ACK;
            WriteFile (DeviceHandle, &signal, sizeof (signal), &numWritten, NULL);
        }
        if (pIsEventSet (&Event)) {
            result = FALSE;
            break;
        }
        repeat = TRUE;
        // let's read the data block
        if (ReadFile (DeviceHandle, buffer, sizeof (buffer), &numRead, NULL)) {
            if ((numRead == 1) &&
                (buffer [0] == EOT)
                ) {
                // we are done
                break;
            }
            if (numRead == sizeof (buffer)) {
                // compute the checksum
                signal = 0;
                for (index = 0; index < sizeof (buffer) - 1; index ++) {
                    signal += buffer [index];
                }
                if (buffer [sizeof (buffer) - 1] == signal) {
                    repeat = FALSE;
                    // checksum is correct, let's see if this is the right block
                    if (currBlock < buffer [1]) {
                        // this is a major error, the sender is ahead of us,
                        // we have to fail
                        result = FALSE;
                        break;
                    }
                    if (currBlock == buffer [1]) {
                        CopyMemory (Buffer, buffer + 3, BLOCKSIZE);
                        currBlock ++;
                    }
                }
            }
        }
    }

    return result;
}

DWORD WINAPI _DirectCableConnectThread (LPVOID lpParam)
{
    PDIRECTCABLE_DATA directCableData;
    HANDLE comHandle = INVALID_HANDLE_VALUE;
    DIRECTSEND_DATA sendData;
    DIRECTSEND_DATA receiveData;

    directCableData = (PDIRECTCABLE_DATA) lpParam;
    if (directCableData) {
        sendData.Signature = DIRECTTR_SIG;
        // open the COM port and set the timeout and speed
        comHandle = UIOpenAndSetPort (directCableData->PortName, &(sendData.MaxSpeed));
        if (comHandle) {
            // send the message to the COM port
            if (g_fOldComputer) {
                if (UISendBlockToHandle (comHandle, (PCBYTE)(&sendData), directCableData->Event)) {
                    if (UIReceiveBlockFromHandle (comHandle, (PBYTE)(&receiveData), directCableData->Event)) {
                        if (sendData.Signature == receiveData.Signature) {
                            directCableData->Valid = TRUE;
                            directCableData->PortSpeed = min (sendData.MaxSpeed, receiveData.MaxSpeed);
                        }
                    }
                }
            } else {
                if (UIReceiveBlockFromHandle (comHandle, (PBYTE)(&receiveData), directCableData->Event)) {
                    if (UISendBlockToHandle (comHandle, (PCBYTE)(&sendData), directCableData->Event)) {
                        if (sendData.Signature == receiveData.Signature) {
                            directCableData->Valid = TRUE;
                            directCableData->PortSpeed = min (sendData.MaxSpeed, receiveData.MaxSpeed);
                        }
                    }
                }
            }
            CloseHandle (comHandle);
            comHandle = INVALID_HANDLE_VALUE;
        }
    }
    pSetEvent (&(directCableData->Event));
    ExitThread (0);
}

INT_PTR CALLBACK _DirectCableWaitDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PDIRECTCABLE_DATA directCableData = NULL;
    DWORD waitResult;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        directCableData = (PDIRECTCABLE_DATA) lParam;
        SetTimer (hwndDlg, NULL, 100, NULL);
        ANIMATE_OPEN(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE,IDA_STARTUP);
        ANIMATE_PLAY(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            if (directCableData) {
                pSetEvent (&(directCableData->Event));
                waitResult = WaitForSingleObject (directCableData->Thread, 0);
                if (waitResult == WAIT_OBJECT_0) {
                    // the thread is done
                    ANIMATE_STOP(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                    ANIMATE_CLOSE(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                    EndDialog(hwndDlg, FALSE);
                } else {
                    // Let's change the static text
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_WAIT_TEXT1), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_WAIT_TEXT2), SW_SHOW);
                }
            } else {
                ANIMATE_STOP(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                ANIMATE_CLOSE(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                EndDialog(hwndDlg, FALSE);
            }
            return TRUE;
        }
        break;

    case WM_TIMER:
        if (directCableData) {
            if (pIsEventSet (&(directCableData->Event))) {
                waitResult = WaitForSingleObject (directCableData->Thread, 0);
                if (waitResult == WAIT_OBJECT_0) {
                    // the thread is done
                    ANIMATE_STOP(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                    ANIMATE_CLOSE(hwndDlg,IDC_DIRECTCABLE_WAIT_ANIMATE);
                    EndDialog(hwndDlg, FALSE);
                }
                break;
            }
        }
    }

    return 0;
}

DWORD WINAPI _DetectPortThread (LPVOID lpParam)
{
    PDIRECTCABLE_DATA directCableData;
    HANDLE comHandle = INVALID_HANDLE_VALUE;
    DIRECTSEND_DATA sendData;
    DIRECTSEND_DATA receiveData;
    HANDLE event = NULL;
    BOOL result = FALSE;

    directCableData = (PDIRECTCABLE_DATA) lpParam;
    if (directCableData) {

        // let's set the termination event
        event = directCableData->Event;

        sendData.Signature = DIRECTTR_SIG;
        // open the COM port and set the timeout and speed
        comHandle = UIOpenAndSetPort (directCableData->PortName, &(sendData.MaxSpeed));
        if (comHandle) {
            // send the message to the COM port
            if (g_fOldComputer) {
                if (UISendBlockToHandle (comHandle, (PCBYTE)(&sendData), directCableData->Event)) {
                    if (UIReceiveBlockFromHandle (comHandle, (PBYTE)(&receiveData), directCableData->Event)) {
                        if (sendData.Signature == receiveData.Signature) {
                            result = TRUE;
                            directCableData->Valid = TRUE;
                            directCableData->PortSpeed = min (sendData.MaxSpeed, receiveData.MaxSpeed);
                        }
                    }
                }
            } else {
                if (UIReceiveBlockFromHandle (comHandle, (PBYTE)(&receiveData), directCableData->Event)) {
                    if (UISendBlockToHandle (comHandle, (PCBYTE)(&sendData), directCableData->Event)) {
                        if (sendData.Signature == receiveData.Signature) {
                            result = TRUE;
                            directCableData->Valid = TRUE;
                            directCableData->PortSpeed = min (sendData.MaxSpeed, receiveData.MaxSpeed);
                        }
                    }
                }
            }
            CloseHandle (comHandle);
            comHandle = INVALID_HANDLE_VALUE;
        }
    }

    if ((!result) && event) {
        // we failed, let's wait until the master tells us to quit
        WaitForSingleObject (event, INFINITE);
    }
    ExitThread (0);
}

DWORD WINAPI _AutoDetectThread (LPVOID lpParam)
{
    PAUTODETECT_DATA autoDetectData = NULL;
    PCTSTR comPort = NULL;
    UINT numPorts = 0;
    PHANDLE threadArray;
    PDIRECTCABLE_DATA directCableArray;
    UINT index = 0;
    DWORD threadId;
    DWORD waitResult;

    autoDetectData = (PAUTODETECT_DATA) lpParam;
    if (!autoDetectData) {
        return FALSE;
    }

    if (!autoDetectData->DirectCableData) {
        return FALSE;
    }
    autoDetectData->DirectCableData->Valid = FALSE;

    if (!autoDetectData->hwndCombo) {
        return FALSE;
    }

    numPorts = SendMessage (autoDetectData->hwndCombo, CB_GETCOUNT, 0, 0);
    if (numPorts) {
        threadArray = (PHANDLE)LocalAlloc(LPTR, numPorts * sizeof(HANDLE));
        if (threadArray) {
            directCableArray = (PDIRECTCABLE_DATA)LocalAlloc(LPTR, numPorts * sizeof(DIRECTCABLE_DATA));
            if (directCableArray) {
                // let's start the threads, one for every port.
                index = 0;
                while (index < numPorts) {
                    comPort = NULL;
                    comPort = (PCTSTR)SendMessage (autoDetectData->hwndCombo, CB_GETITEMDATA, (WPARAM)index, 0);
                    directCableArray [index].Valid = FALSE;
                    directCableArray [index].PortName = comPort;
                    directCableArray [index].PortSpeed = 0;
                    directCableArray [index].Event = autoDetectData->DirectCableData->Event;
                    threadArray [index] = CreateThread (
                                                NULL,
                                                0,
                                                _DetectPortThread,
                                                &(directCableArray [index]),
                                                0,
                                                &threadId
                                                );
                    index ++;
                }

                // let's wait for at least one thread to finish
                waitResult = WaitForMultipleObjects (numPorts, threadArray, FALSE, INFINITE);
                index = waitResult - WAIT_OBJECT_0;
                if ((index < numPorts) && (!pIsEventSet (&(autoDetectData->DirectCableData->Event)))) {
                    // probably a good com port
                    autoDetectData->DirectCableData->Valid = directCableArray [index].Valid;
                    autoDetectData->DirectCableData->PortName = directCableArray [index].PortName;
                    autoDetectData->DirectCableData->PortSpeed = directCableArray [index].PortSpeed;
                }

                // we found the thread, now let's signal the event and wait for all threads to finish
                pSetEvent (&(autoDetectData->DirectCableData->Event));
                WaitForMultipleObjects (numPorts, threadArray, TRUE, INFINITE);

                // let's close all thread handles
                index = 0;
                while (index < numPorts) {
                    CloseHandle (threadArray [index]);
                    index ++;
                }
                LocalFree (directCableArray);
            } else {
                LocalFree (threadArray);
                return FALSE;
            }
            LocalFree (threadArray);
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

INT_PTR CALLBACK _DirectCableDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static INT  iSelectedPort = -1;        // Which COM port is selected
    INT lastPort;
    HWND hwndCombo;
    DIRECTCABLE_DATA directCableData;
    AUTODETECT_DATA autoDetectData;
    HANDLE threadHandle;
    DWORD threadId;
    DWORD waitResult;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:

        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_DIRECTCABLETITLE);
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_DIRECTC_COMSELECT:
            if (HIWORD(wParam) == CBN_SELCHANGE) {
                // clear the error or success area
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);
                // see if the combo box has a real COM port selected. If yes, enable the Next Button
                hwndCombo = GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT);
                lastPort = iSelectedPort;
                iSelectedPort = ComboBox_GetCurSel (hwndCombo);
                if (iSelectedPort >= 0) {
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
                if (lastPort != iSelectedPort) {
                    // clear the store, we need to revalidate the COM port
                    g_szStore [0] = 0;
                }
            }
            break;
        case IDC_DIRECTC_AUTO:
            // clear the error or success area
            ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);

            hwndCombo = GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT);
            ZeroMemory (&directCableData, sizeof (DIRECTCABLE_DATA));
            directCableData.Event = CreateEvent (NULL, TRUE, FALSE, NULL);
            autoDetectData.hwndCombo = hwndCombo;
            autoDetectData.DirectCableData = &directCableData;

            // Start the connection thread
            threadHandle = CreateThread (NULL, 0, _AutoDetectThread, &autoDetectData, 0, &threadId);

            directCableData.Thread = threadHandle;

            // Start the Please wait dialog
            DialogBoxParam (
                g_migwiz->GetInstance(),
                MAKEINTRESOURCE(IDD_DIRECTCABLE_WAIT),
                g_hwndCurrent,
                _DirectCableWaitDlgProc,
                (LPARAM)(&directCableData)
                );

            pSetEvent (&(directCableData.Event));

            // wait for the thread to finish
            waitResult = WaitForSingleObject (threadHandle, INFINITE);

            // Close thread handle
            CloseHandle (threadHandle);

            // Verify that the connection worked
            if (directCableData.Valid && directCableData.PortName) {
                // select the appropriate com port in the drop-down list
                UINT numPorts;
                UINT index = 0;
                PCTSTR comPort = NULL;

                numPorts = SendMessage (hwndCombo, CB_GETCOUNT, 0, 0);
                if (numPorts) {
                    while (index < numPorts) {
                        comPort = (LPTSTR)ComboBox_GetItemData (hwndCombo, index);
                        if (_tcsicmp (comPort, directCableData.PortName) == 0) {
                            break;
                        }
                        index ++;
                    }
                }
                ComboBox_SetCurSel (hwndCombo, index);
                iSelectedPort = index;

                // build the transport string
                if (directCableData.PortSpeed) {
                    wsprintf (g_szStore, TEXT("%s:%u"), directCableData.PortName, directCableData.PortSpeed);
                } else {
                    wsprintf (g_szStore, TEXT("%s"), directCableData.PortName);
                }

                // write the success in the error/success area
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_SHOW);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);

                // enable the Next button
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
            } else {
                // clear the transport string
                g_szStore [0] = 0;

                // write the failure in the error/success area
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_SHOW);

                // preserve the state of the Next button
            }
            break;
        }
        break;

    case WM_NOTIFY :
    {
    switch (((LPNMHDR)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, FALSE);
            break;
        case PSN_WIZBACK:
            if (g_fOldComputer) {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKCOLLECTSTORE);
            } else {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
            }
            return TRUE;
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else {
                // run the COM port test, if we haven't done it already
                if (!g_szStore [0]) {

                    // clear the error or success area
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
                    ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);

                    // Get the COM port from the IDC_DIRECTC_COMSELECT
                    hwndCombo = GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT);
                    iSelectedPort = ComboBox_GetCurSel (hwndCombo);
                    directCableData.Valid = FALSE;
                    directCableData.PortName = (LPTSTR)ComboBox_GetItemData (hwndCombo, iSelectedPort);
                    directCableData.PortSpeed = 0;
                    directCableData.Event = CreateEvent (NULL, TRUE, FALSE, NULL);

                    // Start the connection thread
                    threadHandle = CreateThread (NULL, 0, _DirectCableConnectThread, &directCableData, 0, &threadId);

                    directCableData.Thread = threadHandle;

                    // Start the Please wait dialog
                    DialogBoxParam (
                        g_migwiz->GetInstance(),
                        MAKEINTRESOURCE(IDD_DIRECTCABLE_WAIT),
                        g_hwndCurrent,
                        _DirectCableWaitDlgProc,
                        (LPARAM)(&directCableData)
                        );

                    pSetEvent (&(directCableData.Event));

                    // wait for the thread to finish
                    waitResult = WaitForSingleObject (threadHandle, INFINITE);

                    // Close thread handle
                    CloseHandle (threadHandle);

                    // Verify that the connection worked
                    if (directCableData.Valid) {
                        // build the transport string
                        if (directCableData.PortSpeed) {
                            wsprintf (g_szStore, TEXT("%s:%u"), directCableData.PortName, directCableData.PortSpeed);
                        } else {
                            wsprintf (g_szStore, TEXT("%s"), directCableData.PortName);
                        }

                        // write the success in the error/success area
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_SHOW);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_SHOW);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_HIDE);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_HIDE);

                        // enable the Next button
                        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    } else {
                        // clear the transport string
                        g_szStore [0] = 0;

                        // write the failure in the error/success area
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_SUCCESSTEXT), SW_HIDE);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONYES), SW_HIDE);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_FAILURETEXT), SW_SHOW);
                        ShowWindow(GetDlgItem(hwndDlg, IDC_DIRECTCABLE_ICONNO), SW_SHOW);

                        // preserve the state of the Next button

                        // refuse the Next advance
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }
                }

                if (g_fOldComputer) {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                } else {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
            }
            return TRUE;
            break;
        case PSN_SETACTIVE:
            g_fCustomize = FALSE;

            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);

            // let's build the list of COM ports
            iSelectedPort = _ComboBoxEx_AddCOMPorts (GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT), iSelectedPort);

            Button_Enable (GetDlgItem (hwndDlg, IDC_DIRECTC_COMSELECT), (-1 != iSelectedPort));
            Button_Enable (GetDlgItem (hwndDlg, IDC_DIRECTC_AUTO), (-1 != iSelectedPort));

            // see if the combo box has a real COM port selected. If yes, enable the Next Button
            if (ComboBox_GetCurSel (GetDlgItem(hwndDlg, IDC_DIRECTC_COMSELECT)) >= 0) {
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
            } else {
                iSelectedPort = -1;
            }

            break;
        }
    }
    break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

void _PickMethodDlgProc_Prepare(HWND hwndTree, UINT uiRadio, UINT uiSel, PUINT puiLast, PUINT pselLast)
{
    if ((uiSel != -1) && (*pselLast == uiSel) && (*puiLast == uiRadio)) {
        return;
    }

    switch (uiSel)
    {
    case 0:
        g_migwiz->SelectComponentSet(MIGINF_SELECT_SETTINGS);
        break;
    case 1:
        g_migwiz->SelectComponentSet(MIGINF_SELECT_FILES);
        break;
    case 2:
        g_migwiz->SelectComponentSet(MIGINF_SELECT_BOTH);
        break;
    }
    __PopulateFilesDocumentsCollected(hwndTree, uiRadio);

    *puiLast = uiRadio;
    *pselLast = uiSel;
    g_uChosenComponent = uiRadio;
}

INT_PTR CALLBACK _PickMethodDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    static UINT uiLast = (UINT) -1;
    static UINT selLast = (UINT) -1;
    UINT uiSet;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        HANDLE hBitmap;

        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_PICKMETHODTITLE);
        }

        // Display the mini exclamation mark
        hBitmap = LoadImage(g_migwiz->GetInstance(),
                            MAKEINTRESOURCE(IDB_SMEXCLAMATION),
                            IMAGE_BITMAP,
                            0, 0,
                            LR_LOADTRANSPARENT | LR_SHARED | LR_LOADMAP3DCOLORS);
        SendDlgItemMessage(hwndDlg, IDC_PICKMETHOD_WARNINGICON, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBitmap);
        TreeView_SetBkColor(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), GetSysColor(COLOR_3DFACE));
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_PICKMETHOD_RADIO1:
            _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), 0, 0, &uiLast, &selLast);
            break;
        case IDC_PICKMETHOD_RADIO2:
            _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), 1, 1, &uiLast, &selLast);
            break;
        case IDC_PICKMETHOD_RADIO3:
            _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), 2, 2, &uiLast, &selLast);
            break;
        case IDC_PICKMETHOD_CUSTOMIZE:
            if (!Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_CUSTOMIZE))) {
                _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), uiLast, uiLast, &uiLast, &selLast);
            }
            break;
        }
        break;

    case WM_NOTIFY :
    {
    switch (((LPNMHDR)lParam)->code)
        {
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, FALSE);
            break;
        case PSN_WIZBACK:
            if (g_fStoreToCable) {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DIRECTCABLE);
            } else {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKCOLLECTSTORE);
            }
            return TRUE;
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_CUSTOMIZE)))
            {
                g_fCustomize = TRUE;
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_CUSTOMIZE);
            }
            else if (GetAppsToInstall() == TRUE)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPINSTALL);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_COLLECTPROGRESS);
            }
            return TRUE;
            break;
        case PSN_SETACTIVE:
            g_fCustomize = FALSE;

            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);

            Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO1), BST_UNCHECKED);
            Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO2), BST_UNCHECKED);
            Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO3), BST_UNCHECKED);

            ShowWindow(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TEXT2), (g_fStoreToFloppy ? SW_SHOW : SW_HIDE));
            ShowWindow(GetDlgItem(hwndDlg, IDC_PICKMETHOD_WARNINGICON), (g_fStoreToFloppy ? SW_SHOW : SW_HIDE));

            if (g_fPickMethodReset == TRUE || uiLast == (UINT) -1)
            {
                // Always refresh the tree
                uiLast = -1;
                uiSet = g_fStoreToFloppy ? 0 : 2;
                g_fPickMethodReset = FALSE;
            }
            else
            {
                uiSet = uiLast;
            }

            switch (uiSet)
            {
            case 0:
                Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO1), BST_CHECKED);
                break;
            case 1:
                Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO2), BST_CHECKED);
                break;
            case 2:
                Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKMETHOD_RADIO3), BST_CHECKED);
                break;
            }
            _PickMethodDlgProc_Prepare(GetDlgItem(hwndDlg, IDC_PICKMETHOD_TREE), uiSet, g_fCustomizeComp?-1:uiSet, &uiLast, &selLast);

            break;
        case TVN_ITEMEXPANDINGA:
        case TVN_ITEMEXPANDINGW:
            // Disable selecting and expand/compress
            SetWindowLong(hwndDlg, DWLP_MSGRESULT, TRUE);
            return TRUE;
            break;
        case NM_CUSTOMDRAW:
            {
            LPNMTVCUSTOMDRAW lpNMCustomDraw = (LPNMTVCUSTOMDRAW) lParam;

            // Do not allow highlighting of anything in this treeview

            switch (lpNMCustomDraw->nmcd.dwDrawStage)
            {
                case CDDS_PREPAINT:
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW);
                    return CDRF_NOTIFYITEMDRAW;
                    break;
                case CDDS_ITEMPREPAINT:
                    lpNMCustomDraw->clrText = GetSysColor(COLOR_WINDOWTEXT);
                    lpNMCustomDraw->clrTextBk = GetSysColor(COLOR_3DFACE);
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                    return CDRF_NEWFONT;
                    break;
            }
            }
            break;
        }
    }
    break;

    case WM_USER_CANCEL_PENDING:
        g_fUberCancel = TRUE;
        pSetEvent (&g_TerminateEvent);
        _NextWizardPage (hwndDlg);
        break;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK _CustomizeDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HTREEITEM htiSelected = NULL;
    UINT treeCount = 0;
    UINT rootCount = 0;
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    HWND hwndTree = GetDlgItem(hwndDlg, IDC_CUSTOMIZE_TREE);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_CUSTOMIZETITLE);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CUSTOMIZE_ADDFOLDERS:
            _AddFolder(hwndDlg, hwndTree);

            // Hack to hide shell bug#309872
            RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            break;
        case IDC_CUSTOMIZE_ADDTYPES:
            _ExclusiveDialogBox(g_migwiz->GetInstance(),
                                MAKEINTRESOURCE(IDD_FILETYPEPICKER),
                                hwndDlg,
                                _FileTypeDlgProc);

            // Hack to hide shell bug#309872
            RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            break;
        case IDC_CUSTOMIZE_ADDSETTING:
            _ExclusiveDialogBox(g_migwiz->GetInstance(),
                                MAKEINTRESOURCE(IDD_SETTINGPICKER),
                                hwndDlg,
                                _SettingDlgProc);

            // Hack to hide shell bug#309872
            RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            break;
        case IDC_CUSTOMIZE_ADDFILE:
            _AddFile(hwndDlg, hwndTree);

            // Hack to hide shell bug#309872
            RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_ERASENOW);

            break;
        case IDC_CUSTOMIZE_REMOVE:
            if (htiSelected != g_htiFiles &&
                htiSelected != g_htiFolders &&
                htiSelected != g_htiTypes &&
                htiSelected != g_htiSettings)
            {
                TVITEM item = {0};
                HTREEITEM htiParent;

                item.mask = TVIF_HANDLE | TVIF_TEXT | TVIF_PARAM;
                item.hItem = htiSelected;
                TCHAR szText[MAX_PATH];
                item.pszText = szText;
                item.cchTextMax = ARRAYSIZE(szText);
                if (TreeView_GetItem(hwndTree, &item))
                {
                    if (item.lParam)
                    {
                        LV_DATASTRUCT* plvds = (LV_DATASTRUCT*)item.lParam;

                        // first disable the ISM component
                        htiParent = TreeView_GetParent(hwndTree, htiSelected);

                        if (htiParent == g_htiFiles) {

                            IsmSelectComponent (item.pszText, COMPONENT_FILE, FALSE);

                        } else if (htiParent == g_htiFolders) {

                            IsmSelectComponent (
                                plvds->pszPureName ? plvds->pszPureName : item.pszText,
                                COMPONENT_FOLDER,
                                FALSE
                                );

                        } else if (htiParent == g_htiTypes) {

                            IsmSelectComponent (
                                plvds->pszPureName ? plvds->pszPureName : item.pszText,
                                COMPONENT_EXTENSION,
                                FALSE
                                );

                        } else if (htiParent == g_htiSettings) {

                            IsmSelectComponent (item.pszText, COMPONENT_NAME, FALSE);

                        }


                        // second delete the memory associated with the item
                        if (plvds->pszPureName)
                        {
                            LocalFree(plvds->pszPureName);
                        }
                        LocalFree(plvds);

                        // if the user hits BACK we will remember that the user customized stuff
                        g_fCustomizeComp = TRUE;
                    }
                }
                // third, delete the item itself
                TreeView_DeleteItem(hwndTree, htiSelected);
            }
            break;
        }

        rootCount = 0;
        if (g_htiFolders)
        {
            rootCount ++;
        }
        if (g_htiFiles)
        {
            rootCount ++;
        }
        if (g_htiSettings)
        {
            rootCount ++;
        }
        if (g_htiTypes)
        {
            rootCount ++;
        }

        treeCount = TreeView_GetCount (hwndTree);
        if (treeCount <= rootCount)
        {
            // Disable the NEXT button
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
        }
        else
        {
            // Enable the NEXT button
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
        }
        break;
    case WM_NOTIFY :
        {
            switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                {
                __PopulateFilesDocumentsCollected(hwndTree, g_uChosenComponent);

                rootCount = 0;
                if (g_htiFolders)
                {
                    rootCount ++;
                }
                if (g_htiFiles)
                {
                    rootCount ++;
                }
                if (g_htiSettings)
                {
                    rootCount ++;
                }
                if (g_htiTypes)
                {
                    rootCount ++;
                }
                if (TreeView_GetCount (hwndTree) <= rootCount)
                {
                    // Disable the NEXT button
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
                }
                else
                {
                    // Enable the NEXT button
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
                break;
                }
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (GetAppsToInstall() == TRUE)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPINSTALL);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_COLLECTPROGRESS);
                }
                return TRUE;
                break;
            case TVN_ITEMEXPANDINGA:
            case TVN_ITEMEXPANDINGW:
                return TRUE;
                break;
            case TVN_SELCHANGED:
                {
                    htiSelected = ((NM_TREEVIEW*)lParam)->itemNew.hItem;

                    if (htiSelected == NULL ||
                        htiSelected == g_htiFiles ||
                        htiSelected == g_htiFolders ||
                        htiSelected == g_htiTypes ||
                        htiSelected == g_htiSettings)
                    {
                        // Disable the REMOVE key
                        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOMIZE_REMOVE), FALSE);
                    }
                    else
                    {
                        // Enable the REMOVE key
                        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOMIZE_REMOVE), TRUE);
                    }
                }
                break;
            }
            break;
        }

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

int CALLBACK
PickCollectCallback (
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    HRESULT hr = S_OK;
    TCHAR tszFolderName[MAX_PATH];
    IMalloc *mallocFn = NULL;
    IShellFolder *psfParent = NULL;
    IShellLink *pslLink = NULL;
    LPCITEMIDLIST pidl;
    LPCITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlReal = NULL;

    if (uMsg == BFFM_SELCHANGED) {

        hr = SHGetMalloc (&mallocFn);
        if (!SUCCEEDED (hr)) {
            mallocFn = NULL;
        }

        pidl = (LPCITEMIDLIST) lParam;
        pidlReal = NULL;

        if (pidl) {

            hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

            if (SUCCEEDED(hr)) {
                hr = psfParent->GetUIObjectOf (hwnd, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                if (SUCCEEDED(hr)) {
                    hr = pslLink->GetIDList (&pidlReal);
                    if (!SUCCEEDED(hr)) {
                        pidlReal = NULL;
                    }
                    pslLink->Release ();
                }
                pidlRelative = NULL;
                psfParent->Release ();
            }

            if (SHGetPathFromIDList(pidlReal?pidlReal:pidl, tszFolderName))
            {
                if (tszFolderName[0] == 0) {
                    SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
                }
            } else {
                SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
            }

            if (pidlReal) {
                if (mallocFn) {
                    mallocFn->Free ((void *)pidlReal);
                }
                pidlReal = NULL;
            }
        }

        if (mallocFn) {
            mallocFn->Release ();
            mallocFn = NULL;
        }
    }
    return 0;
}

INT_PTR CALLBACK _PickCollectStoreDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static UINT uiSelected = 0;
    static INT  iSelectedDrive = -1;        // Which removeable media drive is selected
    BOOL imageIsValid;
    BOOL imageExists;
    TCHAR szTitle[MAX_LOADSTRING];
    TCHAR szLoadString[MAX_LOADSTRING];
    HRESULT hr = E_FAIL;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_PICKCOLLECTSTORETITLE);
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {

        case IDC_PICKCOLLECTSTORE_RADIO1:
            // Direct cable

        case IDC_PICKCOLLECTSTORE_RADIO2:
            // Network

            // Disable Browse button
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
            Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);

            // Disable the edit box
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);

            // Disable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);
            break;

        case IDC_PICKCOLLECTSTORE_RADIO3:
            // Floppy

            // Disable Browse button
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
            Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);

            // Disable the edit box
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);

            // Enable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), TRUE);

            break;

        case IDC_PICKCOLLECTSTORE_RADIO4:
            {
            // Other

            // Enable the Browse button
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), TRUE);
            Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), TRUE);

            // Enable the edit box
            HWND hwndEdit = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT);
            Edit_Enable(hwndEdit, TRUE);
            Edit_SetReadOnly(hwndEdit, FALSE);
            Edit_LimitText(hwndEdit, MAX_PATH - PATH_SAFETY_CHARS);

            // Disable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);
            break;
            }

        case IDC_PICKCOLLECTSTORE_BROWSE:
            {
                HRESULT hr = S_OK;
                IMalloc *mallocFn = NULL;
                IShellFolder *psfParent = NULL;
                IShellLink *pslLink = NULL;
                LPCITEMIDLIST pidl;
                LPCITEMIDLIST pidlRelative = NULL;
                LPITEMIDLIST pidlReal = NULL;
                TCHAR szFolder[MAX_PATH];
                TCHAR szPick[MAX_LOADSTRING];

                hr = SHGetMalloc (&mallocFn);
                if (!SUCCEEDED (hr)) {
                    mallocFn = NULL;
                }

                LoadString(g_migwiz->GetInstance(), IDS_PICKAFOLDER, szPick, ARRAYSIZE(szPick));
                BROWSEINFO brwsinf = { hwndDlg, NULL, NULL, szPick, BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE, PickCollectCallback, 0, 0 };

                pidl = SHBrowseForFolder(&brwsinf);
                if (pidl)
                {
                    hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

                    if (SUCCEEDED(hr)) {
                        hr = psfParent->GetUIObjectOf (hwndDlg, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                        if (SUCCEEDED(hr)) {
                            hr = pslLink->GetIDList (&pidlReal);
                            if (SUCCEEDED(hr)) {
                                if (mallocFn) {
                                    mallocFn->Free ((void *)pidl);
                                }
                                pidl = pidlReal;
                                pidlReal = NULL;
                            }
                            pslLink->Release ();
                        }
                        pidlRelative = NULL;
                        psfParent->Release ();
                    }

                    if (SHGetPathFromIDList(pidl, szFolder))
                    {
                        if (_tcslen(szFolder) > MAX_PATH - PATH_SAFETY_CHARS) {
                            TCHAR szTitle[MAX_LOADSTRING];
                            LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                            TCHAR szMsg[MAX_LOADSTRING];
                            LoadString(g_migwiz->GetInstance(), IDS_ERROR_PATHTOOLONG, szMsg, ARRAYSIZE(szMsg));
                            _ExclusiveMessageBox(hwndDlg, szMsg, szTitle, MB_OK);
                        } else {
                            SendMessage(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), WM_SETTEXT, 0, (LPARAM)szFolder);
                        }
                    }

                    if (mallocFn) {
                        mallocFn->Free ((void *)pidl);
                    }
                    pidl = NULL;
                }

                if (mallocFn) {
                    mallocFn->Release ();
                    mallocFn = NULL;
                }
            }
            break;
        }
        break;
    case WM_NOTIFY :
        {
            switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                INT currDrive;
                INT comPort;

                // enable direct cable transport if available
                comPort = _ComboBoxEx_AddCOMPorts (NULL, 0);
                Button_Enable (GetDlgItem (hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), (-1 != comPort));

                // enable network if present
                Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), g_fHaveNet);
                Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT3), g_fHaveNet);

                // get removable drives list and enable radio if any
                SendMessage(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), CBEM_SETIMAGELIST, 0, (LPARAM)g_migwiz->GetImageList());
                currDrive = _ComboBoxEx_AddDrives (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO));

                Button_Enable (GetDlgItem (hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), (-1 != currDrive));
                Static_Enable (GetDlgItem (hwndDlg, IDC_PICKCOLLECTSTORE_TEXT2), (-1 != currDrive));

                // set the selected drive if any
                if ((currDrive != -1) && (iSelectedDrive != -1)) {
                    ComboBox_SetCurSel(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), iSelectedDrive);
                    currDrive = iSelectedDrive;
                }

                if ((uiSelected == 0 || uiSelected == 2) && g_fHaveNet)
                {
                    // Home Network
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), BST_CHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO4), BST_UNCHECKED);

                    // disable folder box, browse button
                    Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);
                    Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
                    Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);
                    // Disable the drive selector
                    EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);
                } else if ((uiSelected == 0 || uiSelected == 1) && (-1 != comPort)) {
                    // Direct cable
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), BST_CHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO4), BST_UNCHECKED);

                    // disable folder box, browse button
                    Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);
                    Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
                    Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);
                    // Disable the drive selector
                    EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);
                }
                else if ((uiSelected == 0 || uiSelected == 3) && (-1 != currDrive))
                {
                    // Floppy
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), BST_CHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO4), BST_UNCHECKED);

                    // disable folder box, browse button
                    Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), FALSE);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), FALSE);
                    Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), FALSE);
                    Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), TRUE);

                    // Enable the drive selector
                    EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), TRUE);
                }
                else
                {
                    // Other
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3), BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO4), BST_CHECKED);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), TRUE);

                    // Disable the drive selector
                    EnableWindow (GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO), FALSE);

                    // Enable folder box, browse button
                    Button_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_BROWSE), TRUE);
                    Static_Enable(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_TEXT5), TRUE);

                    HWND hwndEdit = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT);
                    Edit_Enable(hwndEdit, TRUE);
                    Edit_SetReadOnly(hwndEdit, FALSE);
                    Edit_LimitText(hwndEdit, MAX_PATH - PATH_SAFETY_CHARS);
                }

                // Reset my globals
                g_szStore[0] = 0;

                break;

            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;

            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else
                {
                    if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO1))) // direct cable
                    {
                        g_fStoreToNetwork = FALSE;
                        g_fStoreToCable = TRUE;
                        if (uiSelected != 1)
                        {
                            g_fCustomizeComp = FALSE;
                            uiSelected = 1;
                        }
                    }
                    else if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO2))) // network
                    {
                        g_fStoreToNetwork = TRUE;
                        g_fStoreToCable = FALSE;
                        if (uiSelected != 2)
                        {
                            g_fCustomizeComp = FALSE;
                            uiSelected = 2;
                        }
                    }
                    else if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_RADIO3))) // floppy
                    {
                        LPTSTR pszDrive;
                        TCHAR szFloppyPath[4] = TEXT("A:\\");

                        g_fStoreToNetwork = FALSE;
                        g_fStoreToCable = FALSE;

                        HWND hwndCombo = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_COMBO);
                        iSelectedDrive = ComboBox_GetCurSel(hwndCombo);
                        pszDrive = (LPTSTR)ComboBox_GetItemData(hwndCombo, iSelectedDrive);

                        szFloppyPath[0] = pszDrive[0];
                        lstrcpy(g_szStore, szFloppyPath);
                        if (uiSelected != 3)
                        {
                            g_fCustomizeComp = FALSE;
                            uiSelected = 3;
                        }
                    }
                    else // other
                    {
                        TCHAR   tsTemp[MAX_PATH + 1];

                        g_fStoreToNetwork = FALSE;
                        g_fStoreToCable = FALSE;

                        SendMessage(GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT), WM_GETTEXT,
                            (WPARAM)ARRAYSIZE(tsTemp), (LPARAM)tsTemp);
                        if (uiSelected != 4)
                        {
                            g_fCustomizeComp = FALSE;
                            uiSelected = 4;
                        }

                        CopyStorePath(tsTemp, g_szStore);
                    }

                    if (g_fStoreToNetwork)
                    {
                        if (g_fStoreToFloppy) {
                            g_fStoreToFloppy = FALSE;
                            g_fPickMethodReset = TRUE;
                        }
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                        return TRUE;
                    }

                    if (g_fStoreToCable) {
                        if (g_fStoreToFloppy) {
                            g_fStoreToFloppy = FALSE;
                            g_fPickMethodReset = TRUE;
                        }
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DIRECTCABLE);
                        return TRUE;
                    }

                    if (!_IsValidStore(g_szStore, TRUE, g_migwiz->GetInstance(), hwndDlg)) // not a valid directory!  stay right here.
                    {
                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        LoadString(g_migwiz->GetInstance(), IDS_ENTERSOURCE, szLoadString, ARRAYSIZE(szLoadString));
                        _ExclusiveMessageBox(hwndDlg, szLoadString, szTitle, MB_OK);

                        HWND hwndEdit = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT);
                        SetFocus(hwndEdit);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);

                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }

                    hr = Engine_StartTransport (TRUE, g_szStore, &imageIsValid, &imageExists);
                    if ((!SUCCEEDED (hr)) || (!imageIsValid)) {

                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        LoadString(g_migwiz->GetInstance(), IDS_ENTERSOURCE, szLoadString, ARRAYSIZE(szLoadString));
                        _ExclusiveMessageBox (hwndDlg, szLoadString, szTitle, MB_OK);

                        HWND hwndEdit = GetDlgItem(hwndDlg, IDC_PICKCOLLECTSTORE_EDIT);
                        SetFocus(hwndEdit);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);

                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }

                    BOOL oldFloppy = g_fStoreToFloppy;
                    g_fStoreToFloppy = _DriveStrIsFloppy(!g_migwiz->GetWin9X(), g_szStore);

                    if (oldFloppy != g_fStoreToFloppy) {
                        g_fPickMethodReset = TRUE;
                    }

                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                }
                return TRUE;
                break;
            }
            break;
        }

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    default:
        break;
    }
    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    HWND  hwndProgressBar;
    HWND  hwndPropPage;
} COLLECTPROGRESSSTRUCT;

DWORD WINAPI _CollectProgressDlgProcThread (LPVOID lpParam)
{
    COLLECTPROGRESSSTRUCT* pcps = (COLLECTPROGRESSSTRUCT*)lpParam;
    HRESULT hResult;
    BOOL fHasUserCancelled = FALSE;

    hResult = _DoCopy(g_fStoreToNetwork ? NULL : g_szStore, pcps->hwndProgressBar, pcps->hwndPropPage, &fHasUserCancelled);

    if (fHasUserCancelled) {
        hResult = E_FAIL;
    }

    SendMessage (pcps->hwndPropPage, WM_USER_THREAD_COMPLETE, 0, (LPARAM) hResult);

    pSetEvent (&g_TerminateEvent);

    CoTaskMemFree(pcps);

    return 0;
}


INT_PTR CALLBACK _CollectProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hResult;
    LONG lExStyles;
    HWND hwnd;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_COLLECTPROGRESSTITLE);
        }

        // RTL progress bar for RTL dialogs
        lExStyles = GetWindowLong (hwndDlg, GWL_EXSTYLE);
        if (lExStyles & WS_EX_LAYOUTRTL)
        {
            hwnd = GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS);
            lExStyles = GetWindowLongA(hwnd, GWL_EXSTYLE);
            lExStyles |= WS_EX_LAYOUTRTL;       // toggle layout
            SetWindowLongA(hwnd, GWL_EXSTYLE, lExStyles);
            InvalidateRect(hwnd, NULL, TRUE);   // redraw
        }

        // Let's set an update timer to 3 sec.
        SetTimer (hwndDlg, 0, 3000, NULL);
        break;

    case WM_USER_FINISHED:
        if (g_migwiz->GetLastResponse() == TRUE) // we didn't cancel to get here
        {
            _NextWizardPage (hwndDlg);
        }
        return TRUE;
        break;

    case WM_USER_CANCELLED:
        g_fUberCancel = TRUE;
        _NextWizardPage (hwndDlg);
        return TRUE;
        break;

    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            {
                // blank progress bar
                SendMessage(GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS), PBM_SETRANGE, 0, 100);
                SendMessage(GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS), PBM_SETPOS, 0, 0);

                ANIMATE_OPEN(hwndDlg,IDC_PROGRESS_ANIMATE2,IDA_FILECOPY);
                ANIMATE_PLAY(hwndDlg,IDC_PROGRESS_ANIMATE2);

                g_migwiz->ResetLastResponse();
                COLLECTPROGRESSSTRUCT* pcps = (COLLECTPROGRESSSTRUCT*)CoTaskMemAlloc(sizeof(COLLECTPROGRESSSTRUCT));
                if (pcps)
                {
                    pcps->hwndProgressBar = GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS);
                    pcps->hwndPropPage = hwndDlg;
                    SHCreateThread(_CollectProgressDlgProcThread, pcps, 0, NULL);
                }
            }
            break;

        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, TRUE);
            break;

        case PSN_WIZBACK:
            // ISSUE: we should NEVER get here
            ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE2);
            ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE2);
            SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            return TRUE;
            break;

        case PSN_WIZNEXT:
            ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE2);
            ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE2);
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else if (g_migwiz->GetOOBEMode())
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDOOBE);
            }
            else
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, (g_fStoreToNetwork || g_fStoreToCable) ? IDD_ENDCOLLECTNET : IDD_ENDCOLLECT);
            }
            return TRUE;
            break;
        }
        break;

    case WM_USER_CANCEL_PENDING:
        g_fUberCancel = TRUE;
        pResetEvent (&g_TerminateEvent);
        _NextWizardPage (hwndDlg);
        break;

    case WM_USER_THREAD_COMPLETE:
        hResult = (HRESULT) lParam;
        if (FAILED(hResult))
        {
            g_fUberCancel = TRUE;
        }
        _NextWizardPage (hwndDlg);
        break;

    case WM_USER_STATUS:
    case WM_TIMER:
        INT nResult = 0;
        PTSTR szStatusString = NULL;
        TCHAR szTmpStatus[MAX_LOADSTRING];
        PCTSTR nativeObjectName;
        HWND hwndText = GetDlgItem(hwndDlg, IDC_PROGRESS_STATUS);

        // Let's update the status
        EnterCriticalSection(&g_AppInfoCritSection);
        switch (g_AppInfoPhase) {
            case MIG_HIGHPRIORITYQUEUE_PHASE:
            case MIG_HIGHPRIORITYESTIMATE_PHASE:
            case MIG_GATHERQUEUE_PHASE:
            case MIG_GATHERESTIMATE_PHASE:
            case MIG_ANALYSIS_PHASE:
                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_QUEUE, szTmpStatus, MAX_LOADSTRING);
                _UpdateText (hwndText, szTmpStatus);
                break;
            case MIG_HIGHPRIORITYGATHER_PHASE:
            case MIG_GATHER_PHASE:
                if (g_AppInfoObjectTypeId != MIG_FILE_TYPE) {
                    nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_GATHER1, szTmpStatus, MAX_LOADSTRING);
                    _UpdateText (hwndText, szTmpStatus);
                } else {
                    nativeObjectName = IsmGetNativeObjectName (g_AppInfoObjectTypeId, g_AppInfoObjectName);
                    if (nativeObjectName) {
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_GATHER2, szTmpStatus, MAX_LOADSTRING);
                        if (nResult) {
                            FormatMessage (
                                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szTmpStatus,
                                0,
                                0,
                                (LPTSTR)&szStatusString,
                                0,
                                (va_list *)&nativeObjectName);
                        }
                        if (szStatusString) {
                            _UpdateText (hwndText, szStatusString);
                            LocalFree (szStatusString);
                        }
                        IsmReleaseMemory (nativeObjectName);
                    }
                }
                break;
            case MIG_TRANSPORT_PHASE:
                switch (g_AppInfoSubPhase) {
                    case SUBPHASE_CONNECTING1:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_CONNECTING1, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_CONNECTING2:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_CONNECTING2, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_NETPREPARING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_NETPREPARING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_PREPARING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_PREPARING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_COMPRESSING:
                        if (g_AppInfoObjectTypeId != MIG_FILE_TYPE) {
                            nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_PREPARING, szTmpStatus, MAX_LOADSTRING);
                            _UpdateText (hwndText, szTmpStatus);
                        } else {
                            nativeObjectName = IsmGetNativeObjectName (g_AppInfoObjectTypeId, g_AppInfoObjectName);
                            if (nativeObjectName) {
                                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_COMPRESSING, szTmpStatus, MAX_LOADSTRING);
                                if (nResult) {
                                    FormatMessage (
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        szTmpStatus,
                                        0,
                                        0,
                                        (LPTSTR)&szStatusString,
                                        0,
                                        (va_list *)&nativeObjectName);
                                }
                                if (szStatusString) {
                                    _UpdateText (hwndText, szStatusString);
                                    LocalFree (szStatusString);
                                }
                                IsmReleaseMemory (nativeObjectName);
                            }
                        }
                        break;
                    case SUBPHASE_TRANSPORTING:
                        if (g_AppInfoObjectTypeId != MIG_FILE_TYPE) {
                            nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_PREPARING, szTmpStatus, MAX_LOADSTRING);
                            _UpdateText (hwndText, szTmpStatus);
                        } else {
                            nativeObjectName = IsmGetNativeObjectName (g_AppInfoObjectTypeId, g_AppInfoObjectName);
                            if (nativeObjectName) {
                                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_TRANSPORTING, szTmpStatus, MAX_LOADSTRING);
                                if (nResult) {
                                    FormatMessage (
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        szTmpStatus,
                                        0,
                                        0,
                                        (LPTSTR)&szStatusString,
                                        0,
                                        (va_list *)&nativeObjectName);
                                }
                                if (szStatusString) {
                                    _UpdateText (hwndText, szStatusString);
                                    LocalFree (szStatusString);
                                }
                                IsmReleaseMemory (nativeObjectName);
                            }
                        }
                        break;
                    case SUBPHASE_MEDIAWRITING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_MEDIAWRITING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_FINISHING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_FINISHING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                    case SUBPHASE_CABLETRANS:
                        if (g_AppInfoText) {
                            _UpdateText (hwndText, g_AppInfoText);
                        }
                        break;
                    default:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_PREPARING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                }
                break;
            default:
                break;
        }
        LeaveCriticalSection(&g_AppInfoCritSection);
        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    HWND hwndProgressBar;
    HWND hwndPropPage;
    HINSTANCE hInstance;
    LPTSTR pszDrive;
    LPTSTR pszCurrDir;
    LPTSTR pszInf;
    BOOL *pfHasUserCancelled;
    DWORD pfError;
} DISKPROGRESSSTRUCT;

DWORD WINAPI _DiskProgressDlgProcThread (LPVOID lpParam)
{
    DISKPROGRESSSTRUCT* pdps = (DISKPROGRESSSTRUCT*)lpParam;

    UtInitialize( NULL );

    _CopyInfToDisk (
        pdps->pszDrive,
        pdps->pszCurrDir,
        pdps->pszInf,
        NULL,
        NULL,
        pdps->hwndProgressBar,
        pdps->hwndPropPage,
        pdps->hInstance,
        pdps->pfHasUserCancelled,
        &pdps->pfError
        );

    UtTerminate();

    return 0;
}


BOOL
pReallyCancel (
    HWND hwndParent,
    HINSTANCE hInstance
    )
{
    TCHAR szMigrationWizardTitle[MAX_LOADSTRING];
    BOOL result = FALSE;

    LoadString(hInstance, IDS_MIGWIZTITLE, szMigrationWizardTitle, ARRAYSIZE(szMigrationWizardTitle));

    if (hwndParent) // Stand-alone wizard mode
    {
        TCHAR szStopDisk[MAX_LOADSTRING];
        LoadString(hInstance, IDS_STOPDISK, szStopDisk, ARRAYSIZE(szStopDisk));
        if (IDYES == _ExclusiveMessageBox(hwndParent, szStopDisk, szMigrationWizardTitle, MB_YESNO | MB_DEFBUTTON2))
        {
            result = TRUE;
        }
    }
    return result;
}

INT_PTR CALLBACK _DiskProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fHasUserCancelled = FALSE;
    static DWORD fError = ERROR_SUCCESS;
    HWND hwnd;
    LONG lExStyles;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // RTL progress bar for RTL dialogs
            lExStyles = GetWindowLong (hwndDlg, GWL_EXSTYLE);
            if (lExStyles & WS_EX_LAYOUTRTL)
            {
                hwnd = GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS);
                lExStyles = GetWindowLongA(hwnd, GWL_EXSTYLE);
                lExStyles |= WS_EX_LAYOUTRTL;       // toggle layout
                SetWindowLongA(hwnd, GWL_EXSTYLE, lExStyles);
                InvalidateRect(hwnd, NULL, TRUE);   // redraw
            }
            break;
        case WM_USER_FINISHED:
            if (fHasUserCancelled) {
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_BACK);
            } else {
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
            }
            return TRUE;
            break;
        case WM_USER_CANCELLED:
            PropSheet_PressButton(GetParent(hwndDlg), PSBTN_BACK);
            return TRUE;
            break;
        case WM_NOTIFY :
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                {
                    // blank progress bar
                    SendMessage(GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS), PBM_SETRANGE, 0, 100);
                    SendMessage(GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS), PBM_SETPOS, 0, 0);

                    ANIMATE_OPEN(hwndDlg,IDC_PROGRESS_ANIMATE1,IDA_FILECOPY);
                    ANIMATE_PLAY(hwndDlg,IDC_PROGRESS_ANIMATE1);

                    TCHAR szCurrDir[MAX_PATH];
                    if (GetCurrentDirectory(ARRAYSIZE(szCurrDir), szCurrDir))
                    {

                        DISKPROGRESSSTRUCT* pdps = (DISKPROGRESSSTRUCT*)CoTaskMemAlloc(sizeof(DISKPROGRESSSTRUCT));
                        fHasUserCancelled = FALSE;
                        pdps->hwndProgressBar = GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS);
                        pdps->hwndPropPage = hwndDlg;
                        pdps->hInstance = g_migwiz->GetInstance();
                        pdps->pszDrive = (LPTSTR)CoTaskMemAlloc(sizeof(TCHAR) * (1 + lstrlen(g_szToolDiskDrive)));
                        StrCpy(pdps->pszDrive, g_szToolDiskDrive);
                        pdps->pszCurrDir = (LPTSTR)CoTaskMemAlloc(sizeof(TCHAR) * (1 + lstrlen(szCurrDir)));
                        StrCpy(pdps->pszCurrDir, szCurrDir);
                        pdps->pszInf = NULL; // means choose default
                        pdps->pfHasUserCancelled = &fHasUserCancelled;

                        SHCreateThread(_DiskProgressDlgProcThread, pdps, 0, NULL);

                        fError = pdps->pfError;
                    }
                }
                break;
            case PSN_QUERYCANCEL:
                fHasUserCancelled = pReallyCancel (hwndDlg, g_migwiz->GetInstance());
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, TRUE);
                return TRUE;
                break;
            case PSN_WIZBACK:
                ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE1);
                ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE1);
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE1);
                ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE1);
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (g_fReadFromNetwork)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS); // just got a net connect, skip ahead
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DISKINSTRUCTIONS);
                }
                return TRUE;
                break;
            default :
                break;
            }
        }
        break;
    }

    return 0;
}
///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _InstructionsDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // just highlight the title
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_NOTIFY:
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (g_fReadFromNetwork)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
                }
                return TRUE;
                break;
            }
        }
        break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

int CALLBACK
PickApplyCallback (
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    HRESULT hr = S_OK;
    TCHAR tszFolderName[MAX_PATH];
    IMalloc *mallocFn = NULL;
    IShellFolder *psfParent = NULL;
    IShellLink *pslLink = NULL;
    LPCITEMIDLIST pidl;
    LPCITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlReal = NULL;

    if (uMsg == BFFM_SELCHANGED) {

        hr = SHGetMalloc (&mallocFn);
        if (!SUCCEEDED (hr)) {
            mallocFn = NULL;
        }

        pidl = (LPCITEMIDLIST) lParam;
        pidlReal = NULL;

        if (pidl) {

            hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

            if (SUCCEEDED(hr)) {
                hr = psfParent->GetUIObjectOf (hwnd, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                if (SUCCEEDED(hr)) {
                    hr = pslLink->GetIDList (&pidlReal);
                    if (!SUCCEEDED(hr)) {
                        pidlReal = NULL;
                    }
                    pslLink->Release ();
                }
                pidlRelative = NULL;
                psfParent->Release ();
            }

            if (SHGetPathFromIDList(pidlReal?pidlReal:pidl, tszFolderName))
            {
                if (tszFolderName[0] == 0) {
                    SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
                }
            } else {
                SendMessage (hwnd, BFFM_ENABLEOK, 0, 0);
            }

            if (pidlReal) {
                if (mallocFn) {
                    mallocFn->Free ((void *)pidlReal);
                }
                pidlReal = NULL;
            }
        }

        if (mallocFn) {
            mallocFn->Release ();
            mallocFn = NULL;
        }
    }
    return 0;
}

INT_PTR CALLBACK _PickApplyStoreDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL imageIsValid;
    BOOL imageExists;
    TCHAR szTitle[MAX_LOADSTRING];
    TCHAR szLoadString[MAX_LOADSTRING];
    HWND hwndEdit;
    HRESULT hr = E_FAIL;
    static INT  iSelectedDrive = -1;        // Which removeable media drive is selected

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);
    static UINT uiSelected = 0;

    switch (uMsg)
    {
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_PICKAPPLYSTORE_RADIO1:  // Direct cable
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), FALSE);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);

            uiSelected = 1;

            // Disable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), FALSE);
            break;

        case IDC_PICKAPPLYSTORE_RADIO2:  // Floppy
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), FALSE);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);

            uiSelected = 2;

            // Enable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), TRUE);
            break;

        case IDC_PICKAPPLYSTORE_RADIO3:  // Other
            Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), TRUE);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);
            Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
            Edit_LimitText(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), MAX_PATH - PATH_SAFETY_CHARS);

            uiSelected = 3;

            // Disable the drive selector
            EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), FALSE);
            break;

        case IDC_PICKAPPLYSTORE_BROWSE:
            {
                HRESULT hr = S_OK;
                IMalloc *mallocFn = NULL;
                IShellFolder *psfParent = NULL;
                IShellLink *pslLink = NULL;
                LPCITEMIDLIST pidl;
                LPCITEMIDLIST pidlRelative = NULL;
                LPITEMIDLIST pidlReal = NULL;
                TCHAR szFolder[MAX_PATH];
                TCHAR szPick[MAX_LOADSTRING];

                hr = SHGetMalloc (&mallocFn);
                if (!SUCCEEDED (hr)) {
                    mallocFn = NULL;
                }

                LoadString(g_migwiz->GetInstance(), IDS_PICKAFOLDER, szPick, ARRAYSIZE(szPick));
                BROWSEINFO brwsinf = { hwndDlg, NULL, NULL, szPick, BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE, PickApplyCallback, 0, 0 };

                pidl = SHBrowseForFolder(&brwsinf);
                if (pidl)
                {
                    hr = OurSHBindToParent (pidl, IID_IShellFolder, (void **)&psfParent, &pidlRelative);

                    if (SUCCEEDED(hr)) {
                        hr = psfParent->GetUIObjectOf (hwndDlg, 1, &pidlRelative, IID_IShellLink, NULL, (void **)&pslLink);
                        if (SUCCEEDED(hr)) {
                            hr = pslLink->GetIDList (&pidlReal);
                            if (SUCCEEDED(hr)) {
                                if (mallocFn) {
                                    mallocFn->Free ((void *)pidl);
                                }
                                pidl = pidlReal;
                                pidlReal = NULL;
                            }
                            pslLink->Release ();
                        }
                        pidlRelative = NULL;
                        psfParent->Release ();
                    }

                    if (SHGetPathFromIDList(pidl, szFolder))
                    {
                        SendMessage(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), WM_SETTEXT, 0, (LPARAM)szFolder);
                    }

                    if (mallocFn) {
                        mallocFn->Free ((void *)pidl);
                    }
                    pidl = NULL;
                }

                if (mallocFn) {
                    mallocFn->Release ();
                    mallocFn = NULL;
                }
            }
            break;
        }
        break;
    case WM_NOTIFY :
        {
            switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                if (g_fReadFromNetwork)
                {
                    PropSheet_PressButton(GetParent(hwndDlg), PSWIZB_NEXT);
                }
                else
                {
                    BOOL fFloppyDetected;
                    INT currDrive;
                    INT comPort;

                    // enable direct cable transport if available
                    comPort = _ComboBoxEx_AddCOMPorts (NULL, 0);
                    Button_Enable (GetDlgItem (hwndDlg, IDC_PICKAPPLYSTORE_RADIO1), (-1 != comPort));

                    SendMessage(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), CBEM_SETIMAGELIST, 0, (LPARAM)g_migwiz->GetImageList());
                    currDrive = _ComboBoxEx_AddDrives (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO));

                    Button_Enable (GetDlgItem (hwndDlg, IDC_PICKAPPLYSTORE_RADIO2), (-1 != currDrive));
                    fFloppyDetected = (-1 != currDrive);

                    // set the selected drive if any
                    if ((currDrive != -1) && (iSelectedDrive != -1)) {
                        ComboBox_SetCurSel(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), iSelectedDrive);
                        currDrive = iSelectedDrive;
                    }

                    if ((uiSelected == 0 || uiSelected == 1) && (-1 != comPort))
                    {
                        // check Direct cable button
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO1), BST_CHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO2), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO3), BST_UNCHECKED);

                        // disable folder box, browse button
                        Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), FALSE);
                        Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
                        Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);

                        // disable the drive selector
                        EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), FALSE);
                    }
                    else if ((uiSelected == 0 || uiSelected == 2) && fFloppyDetected)
                    {
                        // check Floppy button
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO1), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO2), BST_CHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO3), BST_UNCHECKED);

                        // disable folder box, browse button
                        Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), FALSE);
                        Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
                        Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);

                        // Enable the drive selector
                        EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), TRUE);
                    }
                    else  // Other
                    {
                        // check Other button
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO1), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO2), BST_UNCHECKED);
                        Button_SetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO3), BST_CHECKED);

                        // enable folder box, browse button
                        Button_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_BROWSE), TRUE);
                        Edit_Enable(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), TRUE);
                        Edit_SetReadOnly(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), FALSE);
                        Edit_LimitText(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), MAX_PATH - PATH_SAFETY_CHARS);

                        // disable the drive selector
                        EnableWindow (GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO), FALSE);
                    }

                }
                break;
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else
                {
                    if (g_fHaveWhistlerCD)
                    {
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_CDINSTRUCTIONS);
                    }
                    else if (g_fAlreadyCollected)
                    {
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD);
                    }
                    else
                    {
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DISKINSTRUCTIONS);
                    }
                }
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (g_fReadFromNetwork)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
                else
                {
                    if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO1))) // direct cable
                    {
                        g_fStoreToCable = TRUE;

                        if (uiSelected != 1)
                        {
                            uiSelected = 1;
                        }
                    }
                    else if (Button_GetCheck(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_RADIO2))) // floppy
                    {
                        LPTSTR pszDrive;

                        g_fStoreToCable = FALSE;

                        HWND hwndCombo = GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_COMBO);
                        iSelectedDrive = ComboBox_GetCurSel(hwndCombo);
                        pszDrive = (LPTSTR)ComboBox_GetItemData(hwndCombo, iSelectedDrive);

                        lstrcpy(g_szStore, pszDrive);

                        if (uiSelected != 2)
                        {
                            uiSelected = 2;
                        }
                    }
                    else // other
                    {
                        TCHAR tsTemp[MAX_PATH + 1];

                        g_fStoreToCable = FALSE;

                        SendMessage(GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT), WM_GETTEXT,
                            (WPARAM)ARRAYSIZE(tsTemp), (LPARAM)tsTemp);
                        CopyStorePath(tsTemp, g_szStore);

                        if (uiSelected != 3)
                        {
                            uiSelected = 3;
                        }
                    }

                    if (g_fStoreToCable) {
                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DIRECTCABLE);
                        return TRUE;
                    }

                    if (!_IsValidStore(g_szStore, FALSE, g_migwiz->GetInstance(), NULL))  // need a valid directory!  stay right here.
                    {
                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        LoadString(g_migwiz->GetInstance(), IDS_ENTERDEST, szLoadString, ARRAYSIZE(szLoadString));
                        _ExclusiveMessageBox(hwndDlg, szLoadString, szTitle, MB_OK);

                        hwndEdit = GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT);
                        SetFocus(hwndEdit);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);

                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }

                    hr = Engine_StartTransport (FALSE, g_szStore, &imageIsValid, &imageExists);
                    if ((!SUCCEEDED (hr)) || (!imageIsValid) || (!imageExists)) {

                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        if (!imageExists) {
                            LoadString(g_migwiz->GetInstance(), IDS_STORAGEEMPTY, szLoadString, ARRAYSIZE(szLoadString));
                        } else {
                            LoadString(g_migwiz->GetInstance(), IDS_STORAGEINVALID, szLoadString, ARRAYSIZE(szLoadString));
                        }
                        _ExclusiveMessageBox (hwndDlg, szLoadString, szTitle, MB_OK);

                        hwndEdit = GetDlgItem(hwndDlg, IDC_PICKAPPLYSTORE_EDIT);
                        SetFocus(hwndEdit);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);

                        SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1);
                        return -1;
                    }

                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
                return TRUE;
                break;
            }
            break;
        }

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    default:
        break;
    }
    return 0;
}

///////////////////////////////////////////////////////////////

typedef struct {
    HWND hwndProgressBar;
    HWND hwndPropPage;
} APPLYPROGRESSSTRUCT;

BOOL CALLBACK
pSendQueryEndSession (
    HWND hwnd,
    LPARAM lParam
    )
{
    DWORD_PTR result;

    if (hwnd == (HWND)lParam) {
        return TRUE;
    }

    SetForegroundWindow (hwnd);

    if (SendMessageTimeout (
            hwnd,
            WM_QUERYENDSESSION,
            0,
            ENDSESSION_LOGOFF,
            SMTO_ABORTIFHUNG|SMTO_NORMAL|SMTO_NOTIMEOUTIFNOTHUNG,
            1000,
            &result
            )) {
        if (result) {

            SendMessageTimeout (
                hwnd,
                WM_ENDSESSION,
                TRUE,
                ENDSESSION_LOGOFF,
                SMTO_ABORTIFHUNG|SMTO_NORMAL|SMTO_NOTIMEOUTIFNOTHUNG,
                1000,
                &result
                );

            return TRUE;
        }
    }
    return FALSE;
}

BOOL
pLogOffSystem (
    VOID
    )
{
    HWND topLevelWnd = NULL;
    HWND tempWnd = NULL;

    if (g_hwndCurrent) {
        tempWnd = g_hwndCurrent;
        while (tempWnd) {
            topLevelWnd = tempWnd;
            tempWnd = GetParent (tempWnd);
        }
    }

    // first we enumerate all top level windows and send them WM_QUERYENDSESSION
    if (!EnumWindows (pSendQueryEndSession, (LPARAM)topLevelWnd)) {
        return FALSE;
    }

    // finally we call ExitWindowsEx forcing the Log off
    return ExitWindowsEx (EWX_LOGOFF, EWX_FORCE);
}

DWORD WINAPI _ApplyProgressDlgProcThread (LPVOID lpParam)
{
    APPLYPROGRESSSTRUCT* paps = (APPLYPROGRESSSTRUCT*)lpParam;
    BOOL fHasUserCancelled = FALSE;
    HRESULT hResult;

    hResult = _DoApply(g_fReadFromNetwork ? NULL : g_szStore, paps->hwndProgressBar, paps->hwndPropPage, &fHasUserCancelled, NULL, 0);

    if (fHasUserCancelled) {
        hResult = E_FAIL;
    } else {
        if (SUCCEEDED(hResult)) {
            if (g_RebootSystem) {
                g_CompleteReboot = TRUE;
            }
            if (g_LogOffSystem) {
                g_CompleteLogOff = TRUE;
            }
        }
    }

    SendMessage (paps->hwndPropPage, WM_USER_THREAD_COMPLETE, 0, (LPARAM) hResult);

    pSetEvent (&g_TerminateEvent);

    return hResult;
}

INT_PTR CALLBACK _ApplyProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hResult;
    HWND hwnd;
    LONG lExStyles;

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, 0, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // RTL progress bar for RTL dialogs
        lExStyles = GetWindowLong (hwndDlg, GWL_EXSTYLE);
        if (lExStyles & WS_EX_LAYOUTRTL)
        {
            hwnd = GetDlgItem(hwndDlg, IDC_COLLECTPROGRESS_PROGRESS);
            lExStyles = GetWindowLongA(hwnd, GWL_EXSTYLE);
            lExStyles |= WS_EX_LAYOUTRTL;       // toggle layout
            SetWindowLongA(hwnd, GWL_EXSTYLE, lExStyles);
            InvalidateRect(hwnd, NULL, TRUE);   // redraw
        }

        // Let's set an update timer to 3 sec.
        SetTimer (hwndDlg, 0, 3000, NULL);

        break;
    case WM_USER_FINISHED:
        PropSheet_PressButton(GetParent(hwndDlg), PSBTN_NEXT);
        return TRUE;
        break;

    case WM_USER_CANCELLED:
        g_fUberCancel = TRUE;
        _NextWizardPage (hwndDlg);
        return TRUE;
        break;

    case WM_NOTIFY :
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                {
                    // blank progress bar
                    SendMessage(GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS), PBM_SETRANGE, 0, 100);
                    SendMessage(GetDlgItem(hwndDlg, IDC_DISKPROGRESS_PROGRESS), PBM_SETPOS, 0, 0);

                    ANIMATE_OPEN(hwndDlg,IDC_PROGRESS_ANIMATE3,IDA_FILECOPY);
                    ANIMATE_PLAY(hwndDlg,IDC_PROGRESS_ANIMATE3);

                    APPLYPROGRESSSTRUCT* paps = (APPLYPROGRESSSTRUCT*)CoTaskMemAlloc(sizeof(APPLYPROGRESSSTRUCT));
                    paps->hwndProgressBar = GetDlgItem(hwndDlg, IDC_APPLYPROGRESS_PROGRESS);
                    paps->hwndPropPage = hwndDlg;

                    // Lanuch apply thread
                    SHCreateThread(_ApplyProgressDlgProcThread, paps, 0, NULL);
                }
                break;
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, TRUE);
                break;
            case PSN_WIZBACK:
                ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE3);
                ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE3);
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                ANIMATE_STOP(hwndDlg,IDC_PROGRESS_ANIMATE3);
                ANIMATE_CLOSE(hwndDlg,IDC_PROGRESS_ANIMATE3);
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ENDAPPLY);
                }
                return TRUE;
                break;
            default :
                break;
            }
        }
        break;

    case WM_USER_CANCEL_PENDING:
        g_fUberCancel = TRUE;
        pResetEvent (&g_TerminateEvent);
        _NextWizardPage (hwndDlg);
        break;

    case WM_USER_THREAD_COMPLETE:
        hResult = (HRESULT) lParam;
        if (FAILED(hResult))
        {
            g_fUberCancel = TRUE;
        }
        _NextWizardPage (hwndDlg);
        break;

    case WM_USER_STATUS:
    case WM_TIMER:
        INT nResult = 0;
        PTSTR szStatusString = NULL;
        TCHAR szTmpStatus[MAX_LOADSTRING];
        PCTSTR nativeObjectName;
        HWND hwndText = GetDlgItem(hwndDlg, IDC_APPLYPROGRESS_STATUS);

        // Let's update the status
        EnterCriticalSection(&g_AppInfoCritSection);
        switch (g_AppInfoPhase) {
            case MIG_TRANSPORT_PHASE:
                switch (g_AppInfoSubPhase) {
                    case SUBPHASE_CONNECTING2:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_CONNECTING2, szTmpStatus, MAX_LOADSTRING);
                        if (nResult) {
                            _UpdateText (hwndText, szTmpStatus);
                        }
                        break;
                    case SUBPHASE_NETPREPARING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_NETPREPARING, szTmpStatus, MAX_LOADSTRING);
                        if (nResult) {
                            _UpdateText (hwndText, szTmpStatus);
                        }
                        break;
                    case SUBPHASE_CABLETRANS:
                        if (g_AppInfoText) {
                            _UpdateText (hwndText, g_AppInfoText);
                        }
                        break;
                    case SUBPHASE_UNCOMPRESSING:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_TR_UNCOMPRESSING, szTmpStatus, MAX_LOADSTRING);
                        if (nResult) {
                            _UpdateText (hwndText, szTmpStatus);
                        }
                    default:
                        nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_ORGANIZING, szTmpStatus, MAX_LOADSTRING);
                        _UpdateText (hwndText, szTmpStatus);
                        break;
                }
                break;
            case MIG_HIGHPRIORITYQUEUE_PHASE:
            case MIG_HIGHPRIORITYESTIMATE_PHASE:
            case MIG_HIGHPRIORITYGATHER_PHASE:
            case MIG_GATHERQUEUE_PHASE:
            case MIG_GATHERESTIMATE_PHASE:
            case MIG_GATHER_PHASE:
            case MIG_ANALYSIS_PHASE:
                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_ORGANIZING, szTmpStatus, MAX_LOADSTRING);
                _UpdateText (hwndText, szTmpStatus);
                break;
            case MIG_APPLY_PHASE:
                nResult = LoadString (g_migwiz->GetInstance(), IDS_APPINFO_APPLY, szTmpStatus, MAX_LOADSTRING);
                _UpdateText (hwndText, szTmpStatus);
                break;
            default:
                break;
        }
        LeaveCriticalSection(&g_AppInfoCritSection);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _AskCDDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static UINT uiSelected = 1;  // 1=MakeDisk, 2=HaveDisk, 3:UseCD, 4:Collected
    static INT  iSelectedDrive = -1;        // Which removeable media drive is selected

    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        uiSelected = 1;
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO1), BST_CHECKED);
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO2), BST_UNCHECKED);
        Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO3), BST_UNCHECKED);
        break;
    case WM_COMMAND:
        if (BN_CLICKED == HIWORD(wParam))
        {
            switch (LOWORD(wParam))
            {
            case IDC_ASKCD_RADIO1:
                uiSelected = 1;
                break;
            case IDC_ASKCD_RADIO2:
                uiSelected = 2;
                break;
            case IDC_ASKCD_RADIO3:
                uiSelected = 3;
                break;
            case IDC_ASKCD_RADIO4:
                uiSelected = 4;
                break;
            }

            BOOL fActivate = (1 == uiSelected);
            EnableWindow (GetDlgItem (hwndDlg, IDC_ASKCD_COMBO), fActivate);
        }
        break;
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            // Reinit my globals
            g_fAlreadyCollected = FALSE;
            g_fHaveWhistlerCD = FALSE;

            // Check for HomeLan
            if (g_fReadFromNetwork)
            {
                PropSheet_PressButton(GetParent(hwndDlg), PSWIZB_NEXT);
            }
            else
            {
                HWND hwndCombo = GetDlgItem(hwndDlg, IDC_ASKCD_COMBO);

                SendMessage(hwndCombo, CBEM_SETIMAGELIST, 0, (LPARAM)g_migwiz->GetImageList());
                _ComboBoxEx_AddDrives (hwndCombo);

                if ((ComboBox_GetCount(hwndCombo) > 0) && (CanCreateWizardDisk (NULL, NULL))) {
                    EnableWindow (hwndCombo, (1 == uiSelected));
                    Button_Enable (GetDlgItem(hwndDlg, IDC_ASKCD_RADIO1), TRUE);

                    if( iSelectedDrive != -1 )
                    {
                        ComboBox_SetCurSel(hwndCombo, iSelectedDrive);
                    }
                } else {
                    // No floppy drives exist, or we can't create the floppy wizard from some
                    // other reason (like we are running from the CD). Disable the creation option.
                    if (uiSelected == 1) {
                        uiSelected = 3;
                    }
                    EnableWindow (hwndCombo, FALSE);
                    Button_Enable (GetDlgItem(hwndDlg, IDC_ASKCD_RADIO1), FALSE);
                }

                Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO1), BST_UNCHECKED);
                Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO2), BST_UNCHECKED);
                Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO3), BST_UNCHECKED);
                Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO4), BST_UNCHECKED);
                switch (uiSelected)
                {
                case 1: // Create wizard disk
                    Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO1), BST_CHECKED);
                    break;
                case 2: // I already have wizard disk
                    Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO2), BST_CHECKED);
                    break;
                case 3: // I will use the CD
                    Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO3), BST_CHECKED);
                    break;
                case 4: // I already have the stuff collected
                    Button_SetCheck(GetDlgItem(hwndDlg,IDC_ASKCD_RADIO4), BST_CHECKED);
                    break;
                }
            }
            break;
        case PSN_QUERYCANCEL:
            return _HandleCancel(hwndDlg, FALSE, FALSE);
            break;
        case PSN_WIZNEXT:
            if (g_fUberCancel)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
            }
            else if (g_fReadFromNetwork)
            {
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
            }
            else
            {
                switch (uiSelected)
                {
                case 1: // Create wizard disk
                    {
                        LPTSTR pszDrive;
                        HWND hwndRemoveCombo = GetDlgItem(hwndDlg, IDC_ASKCD_COMBO);
                        iSelectedDrive = ComboBox_GetCurSel(hwndRemoveCombo);
                        pszDrive = (LPTSTR)ComboBox_GetItemData(hwndRemoveCombo, iSelectedDrive);
                        StrCpyN(g_szToolDiskDrive, pszDrive, ARRAYSIZE(g_szToolDiskDrive));

                        TCHAR szTitle[MAX_LOADSTRING];
                        LoadString(g_migwiz->GetInstance(), IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
                        TCHAR szMsg[MAX_LOADSTRING];
                        LoadString(g_migwiz->GetInstance(), IDS_MAKETOOLDISK_INSERT, szMsg, ARRAYSIZE(szMsg));
                        if (IDOK == _ExclusiveMessageBox(hwndDlg, szMsg, szTitle, MB_OKCANCEL))
                        {
                            SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DISKPROGRESS);
                        }
                        else
                        {
                            SetWindowLong(hwndDlg, DWLP_MSGRESULT, -1); // stay right here
                        }
                        return TRUE;
                    }
                    break;
                case 2: // I already have wizard disk
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_DISKINSTRUCTIONS);
                    return TRUE;
                case 3: // I will use the CD
                    g_fHaveWhistlerCD = TRUE;
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_CDINSTRUCTIONS);
                    return TRUE;
                case 4: // I already have the stuff collected
                    g_fAlreadyCollected = TRUE;
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
                    return TRUE;
                }
            }
            return TRUE;
            break;
        }
        break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

///////////////////////////////////////////////////////////////

INT_PTR CALLBACK _CDInstructionsDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // just highlight the title
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_NOTIFY:
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                if (g_fReadFromNetwork)
                {
                    PropSheet_PressButton(GetParent(hwndDlg), PSWIZB_NEXT);
                }
                else
                {
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
                break;
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_ASKCD);
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else if (g_fReadFromNetwork)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_APPLYPROGRESS);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKAPPLYSTORE);
                }
                return TRUE;
                break;
            }
        }
        break;

    case WM_USER_CANCEL_PENDING:

        g_fUberCancel = TRUE;

        pSetEvent (&g_TerminateEvent);

        _NextWizardPage (hwndDlg);

        break;

    }

    return 0;
}

VOID
pGenerateHTMLAppList (HANDLE FileHandle)
{
    TCHAR szLoadStr[MAX_LOADSTRING];
    POBJLIST objList = NULL;
    DWORD written;

#ifdef UNICODE
    ((PBYTE)szLoadStr) [0] = 0xFF;
    ((PBYTE)szLoadStr) [1] = 0xFE;
    WriteFile (FileHandle, szLoadStr, 2, &written, NULL);
#endif

    pWriteStrResToFile (FileHandle, IDS_APPINSTALL_BEGIN);

    _tcscpy (szLoadStr, TEXT("<UL>\n"));
    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

    objList = g_HTMLApps;

    while (objList) {
        if (objList->ObjectName) {
            _tcscpy (szLoadStr, TEXT("<LI>"));
            WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);
            WriteFile (FileHandle, objList->ObjectName, (_tcslen (objList->ObjectName) + 1) * sizeof (TCHAR), &written, NULL);
        }
        objList = objList->Next;
    }

    _tcscpy (szLoadStr, TEXT("</UL>\n"));
    WriteFile (FileHandle, szLoadStr, (_tcslen (szLoadStr) + 1) * sizeof (TCHAR), &written, NULL);

    pWriteStrResToFile (FileHandle, IDS_APPINSTALL_END);
}


INT_PTR CALLBACK _AppInstallDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    IWebBrowser2    *m_pweb = NULL;            // IE4 IWebBrowser interface pointer
    IUnknown        *punk = NULL;
    HWND webHostWnd = NULL;
    HANDLE hHTMLAppList = INVALID_HANDLE_VALUE;
    PWSTR szTarget;

    // just highlight the title
    _RootDlgProc(hwndDlg, uMsg, wParam, lParam, PSWIZB_BACK | PSWIZB_NEXT, FALSE, 0);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // If Wiz95 layout...
        if (g_migwiz->GetOldStyle())
        {
            _OldStylify(hwndDlg, IDS_APPINSTALLTITLE);
        }
        break;

    case WM_DESTROY:
        if (m_pweb)
            m_pweb->Release();
            m_pweb = NULL;

        //
        //  tell the container to remove IE4 and then
        //  release our reference to the container.
        //
        if (g_WebContainer)
        {
            g_WebContainer->remove();
            g_WebContainer->Release();
            g_WebContainer = NULL;
        }
        break;
    case WM_NOTIFY:
        {
        switch (((LPNMHDR)lParam)->code)
            {
            case PSN_SETACTIVE:
                if (!g_fCancelPressed) {
                    webHostWnd = GetDlgItem (hwndDlg, IDC_APPWEBHOST);
                    if (webHostWnd) {
                        // Now let's generate the failure HTML file.
                        if (*g_HTMLAppList) {
                            hHTMLAppList = CreateFile (g_HTMLAppList,
                                                       GENERIC_READ|GENERIC_WRITE,
                                                       FILE_SHARE_READ,
                                                       NULL,
                                                       CREATE_ALWAYS,
                                                       0,
                                                       NULL);
                            if (hHTMLAppList != INVALID_HANDLE_VALUE) {
                                pGenerateHTMLAppList (hHTMLAppList);
                                if (g_WebContainer)
                                {
                                    g_WebContainer->remove();
                                    g_WebContainer->Release();
                                    g_WebContainer = NULL;
                                }
                                g_WebContainer = new Container();
                                if (g_WebContainer)
                                {
                                    g_WebContainer->setParent(webHostWnd);
                                    g_WebContainer->add(L"Shell.Explorer");
                                    g_WebContainer->setVisible(TRUE);
                                    g_WebContainer->setFocus(TRUE);

                                    //
                                    //  get the IWebBrowser2 interface and cache it.
                                    //
                                    punk = g_WebContainer->getUnknown();
                                    if (punk)
                                    {
                                        punk->QueryInterface(IID_IWebBrowser2, (PVOID *)&m_pweb);
                                        if (m_pweb) {
#ifdef UNICODE
                                            m_pweb->Navigate(g_HTMLAppList, NULL, NULL, NULL, NULL);
#else
                                            szTarget = _ConvertToUnicode (CP_ACP, g_HTMLAppList);
                                            if (szTarget) {
                                                m_pweb->Navigate(szTarget, NULL, NULL, NULL, NULL);
                                                LocalFree ((HLOCAL)szTarget);
                                                szTarget = NULL;
                                            }
#endif
                                        }
                                        punk->Release();
                                        punk = NULL;
                                    }
                                }
                                // We intentionally want to keep this file open for the life of the wizard.
                                // With this we eliminate the possibility for someone to overwrite the
                                // content of the HTML file therefore forcing us to show something else
                                // maybe even run some malicious script.
                                // CloseHandle (hHTMLAppList);
                            }

                        } else {
                            ShowWindow(webHostWnd, SW_HIDE);
                        }
                    }
                }
                break;
            case PSN_QUERYCANCEL:
                return _HandleCancel(hwndDlg, FALSE, FALSE);
                break;
            case PSN_WIZBACK:
                if (g_fCustomize == TRUE) {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_CUSTOMIZE);
                } else {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_PICKMETHOD);
                }
                return TRUE;
                break;
            case PSN_WIZNEXT:
                if (g_fUberCancel)
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_FAILCLEANUP);
                }
                else
                {
                    SetWindowLong(hwndDlg, DWLP_MSGRESULT, IDD_COLLECTPROGRESS);
                }
                return TRUE;
            }
        }
        break;
    case WM_USER_CANCEL_PENDING:
        g_fUberCancel = TRUE;
        pSetEvent (&g_TerminateEvent);
        _NextWizardPage (hwndDlg);
        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migwnprc.h ===
#ifndef _MIGWNPRC_H_
#define _MIGWNPRC_H_

#include <shlobj.h>

// core dialog
INT_PTR CALLBACK _RootDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam, DWORD dwEnabled, BOOL fTitle, UINT uiTitleID);

// util dialogs
INT_PTR CALLBACK _FileTypeDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// intro, end dialogs
INT_PTR CALLBACK _IntroDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _IntroLegacyDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _IntroOOBEDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _StartEngineDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _GetStartedDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndApplyDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndCollectDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndCollectNetDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndFailDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _EndOOBEDlgProc (HWND hwndDlg,UINT uMsg, WPARAM wParam, LPARAM lParam);

// collection dialogs
INT_PTR CALLBACK _CustomizeDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _PickMethodDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _PickCollectStoreDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _FinalNotesDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _CollectProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _CleanUpDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _AppInstallDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// application dialogs
INT_PTR CALLBACK _AskCDDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _DiskProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _CDInstructionsDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _InstructionsDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _AskCompleteDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _PickApplyStoreDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _ApplyProgressDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK _DirectCableDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\migwiz.cpp ===
#include "migwiz.h"
#include "migwnprc.h"
#include "migeng.h"
#include "migutil.h"
#include "miginf.h"
#include "shellapi.h"
#include "resource.h"


HINSTANCE g_hInstance = NULL;
BOOL g_fLastResponse; // did the user hit ok to the last callback message?
extern MigrationWizard* g_migwiz;
extern BOOL g_fHaveNet; // OLD COMPUTER ONLY: this means we can use the network
extern BOOL g_fReadFromNetwork; // NEW COMPUTER ONLY: this means go ahead and read from the network immediately
extern BOOL g_fStoreToNetwork; // OLD COMPUTER ONLY: this means we've selected to store to the network
extern HWND g_hwndCurrent;
extern CRITICAL_SECTION g_csDialogCritSection;
extern CRITICAL_SECTION g_AppInfoCritSection;
extern BOOL g_fUberCancel;
DWORD g_HTMLErrArea = 0;
DWORD g_HTMLErrInstr = 0;
PCTSTR g_HTMLErrObjectType = NULL;
PCTSTR g_HTMLErrObjectName = NULL;

POBJLIST g_HTMLWrnFile = NULL;
POBJLIST g_HTMLWrnAltFile = NULL;
POBJLIST g_HTMLWrnRas = NULL;
POBJLIST g_HTMLWrnNet = NULL;
POBJLIST g_HTMLWrnPrn = NULL;
POBJLIST g_HTMLWrnGeneral = NULL;

TCHAR g_szMultiDests[20 * MAX_PATH];
BOOL g_fReceivedMultiDest = FALSE; // we only respond to the first multi-dest message we receive

extern MIG_PROGRESSPHASE g_AppInfoPhase;
extern UINT g_AppInfoSubPhase;
extern MIG_OBJECTTYPEID g_AppInfoObjectTypeId;
extern TCHAR g_AppInfoObjectName [4096];
extern TCHAR g_AppInfoText [4096];

MigrationWizard::MigrationWizard() : _fInit(FALSE), _pszUsername(NULL)
{
}

MigrationWizard::~MigrationWizard()
{
    CloseAppInf();

    // Destroy the fonts
    if (_hTitleFont)
    {
        DeleteObject(_hTitleFont);
        DeleteObject(_h95HeaderFont);
    }

    if (_pszUsername)
    {
        LocalFree(_pszUsername);
    }

    if (_fDelCs) {
        DeleteCriticalSection (&g_csDialogCritSection);
        _fDelCs = FALSE;
    }
}

HRESULT MigrationWizard::Init(HINSTANCE hInstance, LPTSTR pszUsername)
{
    HRESULT hr;
    BOOL fWinXP = FALSE;

    _hInstance = hInstance;
    if (pszUsername)
    {
        _pszUsername = (LPTSTR)LocalAlloc(LPTR, (lstrlen(pszUsername) + 1) * sizeof (TCHAR));
        if (_pszUsername)
        {
            lstrcpy(_pszUsername, pszUsername);
        }
    }

    __try {
        InitializeCriticalSection (&g_csDialogCritSection);
    } __except (EXCEPTION_CONTINUE_EXECUTION) {
        // Might raise an out of memory exception
        // -1 ignores
    }
    _fDelCs = TRUE;

    __try {
        InitializeCriticalSection (&g_AppInfoCritSection);
    } __except (EXCEPTION_CONTINUE_EXECUTION) {
        // Might raise an out of memory exception
        // -1 ignores
    }

    // do we run in OOBE mode?  check for oobemode.dat in the curr dir
    _fOOBEMode = FALSE; // default
    TCHAR szPath[MAX_PATH];
    if (GetCurrentDirectory(ARRAYSIZE(szPath), szPath))
    {
        PathAppend(szPath, TEXT("oobemode.dat"));
        HANDLE hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            _fOOBEMode = TRUE;
            CloseHandle(hFile);
        }
    }

    OpenAppInf(NULL);

    // do we run in legacy mode? (collect-only)
    UINT uiVer = GetVersion();
    _fLegacyMode = (uiVer >= 0x80000000 || LOBYTE(LOWORD(uiVer)) < 5);
    _fWin9X      = (uiVer >= 0x80000000);
    _fWinNT4     = (uiVer <  0x80000000 && LOBYTE(LOWORD(uiVer)) == 4);
    fWinXP       = ((uiVer <  0x80000000) && (LOBYTE(LOWORD(uiVer)) == 5) && (HIBYTE(LOWORD(uiVer)) >= 1));

#ifndef PRERELEASE
    // in release mode, run legacy on for Win2k
    if (HIBYTE(LOWORD(uiVer)) < 1)
    {
        _fLegacyMode = TRUE;
    }
#endif

    // do we run with old-style wizard?
    _fOldStyle = (uiVer >= 0x80000000 || LOBYTE(LOWORD(uiVer)) < 5); // hack, for now win9x is old-style


    // Init common controls
    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    if (fWinXP) {
        icex.dwICC = ICC_USEREX_CLASSES | ICC_LINK_CLASS;
    } else {
        icex.dwICC = ICC_USEREX_CLASSES;
    }
    InitCommonControlsEx(&icex);

    // Init the imagelist
    SHFILEINFO sfi = {0};
    _hil = (HIMAGELIST)SHGetFileInfo(TEXT(".txt"), FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi),
                                     SHGFI_SMALLICON | SHGFI_SYSICONINDEX | SHGFI_USEFILEATTRIBUTES);

    //
    //Create the Wizard pages
    //
    hr = _CreateWizardPages();

    if (SUCCEEDED(hr))
    {
        //Create the property sheet

        _psh.hInstance =         _hInstance;
        _psh.hwndParent =        NULL;
        _psh.phpage =            _rghpsp;
        if (!_fOldStyle)
        {
            _psh.dwSize =            sizeof(_psh);
            _psh.dwFlags =           PSH_WIZARD97|PSH_WATERMARK|PSH_HEADER;
            _psh.pszbmWatermark =    MAKEINTRESOURCE(IDB_WATERMARK);
            _psh.pszbmHeader =       MAKEINTRESOURCE(IDB_BANNER);
        }
        else
        {
            _psh.dwSize =  PROPSHEETHEADER_V1_SIZE;
            _psh.dwFlags = PSH_WIZARD;
        }
        _psh.nStartPage =        0;
        _psh.nPages =            NUMPAGES;


        //Set up the font for the titles on the intro and ending pages
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        //Create the intro/end title font
        LOGFONT TitleLogFont = ncm.lfMessageFont;
        // ISSUE: we don't want to do this, this can break us on non-English builds.
        TitleLogFont.lfWeight = FW_BOLD;
        lstrcpy(TitleLogFont.lfFaceName, TEXT("MS Shell Dlg"));

        HDC hdc = GetDC(NULL); //gets the screen DC
        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * 12 / 72;
        _hTitleFont = CreateFontIndirect(&TitleLogFont);


        CHAR szFontSize[MAX_LOADSTRING];
        DWORD dwFontSize = 8;
        if (LoadStringA(g_hInstance, IDS_WIN9X_HEADER_FONTSIZE, szFontSize, ARRAYSIZE(szFontSize))) {
            dwFontSize = strtoul(szFontSize, NULL, 10);
        }

        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * dwFontSize / 72;
        lstrcpy(TitleLogFont.lfFaceName, TEXT("MS Shell Dlg"));
        _h95HeaderFont = CreateFontIndirect(&TitleLogFont);

        ReleaseDC(NULL, hdc);

        g_hInstance = _hInstance; // HACK: allows message callback to get an hinstance to load strings
    }

    return hr;
}

HRESULT MigrationWizard::Execute()
{
    //Display the wizard
    PropertySheet(&_psh);

    return S_OK;
}


#define WIZDLG(name, dlgproc)   \
            psp.dwFlags = _fOldStyle ? PSP_DEFAULT : PSP_DEFAULT|PSP_USEHEADERTITLE;\
            psp.pszHeaderTitle = _fOldStyle ? NULL : MAKEINTRESOURCE(IDS_##name##TITLE);\
            psp.pszHeaderSubTitle = NULL;\
            psp.pszTemplate = MAKEINTRESOURCE(IDD_##name##);\
            psp.pfnDlgProc = ##dlgproc##;\
            _rghpsp[uiCounter++] =  CreatePropertySheetPage(&psp)

#define WIZDLG_TITLE(name, dlgproc)   \
            psp.dwFlags = _fOldStyle ? PSP_DEFAULT : PSP_DEFAULT|PSP_HIDEHEADER;\
            psp.pszHeaderTitle = NULL;\
            psp.pszHeaderSubTitle = NULL;\
            psp.pszTemplate = MAKEINTRESOURCE(IDD_##name##);\
            psp.pfnDlgProc = ##dlgproc##;\
            _rghpsp[uiCounter++] =  CreatePropertySheetPage(&psp)

HRESULT MigrationWizard::_CreateWizardPages()
{
    UINT uiCounter = 0;

    PROPSHEETPAGE psp = {0}; //defines the property sheet page
    psp.dwSize =        sizeof(psp);
    psp.hInstance =     _hInstance;
    psp.lParam =        (LPARAM)this;

    //Opening page

    if (_fOOBEMode)
    {
        WIZDLG_TITLE(INTROOOBE, _IntroOOBEDlgProc);
    }
    else if (!_fLegacyMode)
    {
        WIZDLG_TITLE(INTRO, _IntroDlgProc);
    }
    else
    {
        WIZDLG_TITLE(INTROLEGACY, _IntroLegacyDlgProc);
    }

    // Interior pages
    WIZDLG(GETSTARTED, _GetStartedDlgProc);
    WIZDLG(ASKCD, _AskCDDlgProc);
    WIZDLG(DISKPROGRESS, _DiskProgressDlgProc);
    WIZDLG(DISKINSTRUCTIONS, _InstructionsDlgProc);
    WIZDLG(CDINSTRUCTIONS, _CDInstructionsDlgProc);
    WIZDLG(PICKAPPLYSTORE, _PickApplyStoreDlgProc);
    WIZDLG(APPLYPROGRESS, _ApplyProgressDlgProc);
    WIZDLG(WAIT, _StartEngineDlgProc);
    WIZDLG(PICKMETHOD, _PickMethodDlgProc);
    WIZDLG(CUSTOMIZE, _CustomizeDlgProc);
    WIZDLG(PICKCOLLECTSTORE, _PickCollectStoreDlgProc);
    WIZDLG(COLLECTPROGRESS, _CollectProgressDlgProc);
    WIZDLG(DIRECTCABLE, _DirectCableDlgProc);
    WIZDLG(FAILCLEANUP, _CleanUpDlgProc);
    WIZDLG(APPINSTALL, _AppInstallDlgProc);

    //Final pages
    WIZDLG_TITLE(ENDAPPLY, _EndApplyDlgProc);
    WIZDLG_TITLE(ENDAPPLYFAIL, _EndFailDlgProc);
    WIZDLG_TITLE(ENDCOLLECT, _EndCollectDlgProc);
    WIZDLG_TITLE(ENDCOLLECTNET, _EndCollectNetDlgProc);
    WIZDLG_TITLE(ENDCOLLECTFAIL, _EndFailDlgProc);
    WIZDLG_TITLE(ENDOOBE, _EndOOBEDlgProc);

    return S_OK;
}

// this lets us know if the user cancelled
void MigrationWizard::ResetLastResponse()
{
    g_fLastResponse = TRUE;
}

BOOL MigrationWizard::GetLastResponse()
{
    return g_fLastResponse;
}

INT_PTR CALLBACK _WaitDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

INT_PTR CALLBACK _DisplayPasswordDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PPASSWORD_DATA passwordData = NULL;
    DWORD waitResult;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        {
            passwordData = (PPASSWORD_DATA) lParam;
            if (passwordData) {
                if (passwordData->Key) {
                    SendMessageA (GetDlgItem(hwndDlg, IDC_DISPLAY_PASSWORD), WM_SETTEXT, 0, (LPARAM)passwordData->Key);
                }
            }
            SetTimer (hwndDlg, NULL, 100, NULL);
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hwndDlg, FALSE);
            return TRUE;
        }
        break;

    case WM_TIMER:
        if (passwordData) {
            waitResult = WaitForSingleObject (passwordData->Event, 0);
            if (waitResult != WAIT_TIMEOUT) {
                EndDialog(hwndDlg, FALSE);
                return TRUE;
            }
        }
    }

    return 0;
}

INT_PTR CALLBACK _GatherPasswordDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static PPASSWORD_DATA passwordData = NULL;
    DWORD waitResult;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        {
            passwordData = (PPASSWORD_DATA) lParam;
            if (passwordData) {
                if (passwordData->Key) {
                    SendMessageA (GetDlgItem(hwndDlg, IDC_GATHER_PASSWORD), WM_SETTEXT, 0, (LPARAM)passwordData->Key);
                }
                Edit_LimitText(GetDlgItem(hwndDlg, IDC_GATHER_PASSWORD), passwordData->KeySize - 1);
            }
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if (passwordData && passwordData->Key) {
                SendMessageA (GetDlgItem(hwndDlg, IDC_GATHER_PASSWORD), WM_GETTEXT, passwordData->KeySize, (LPARAM)passwordData->Key);
                EndDialog(hwndDlg, TRUE);
            } else {
                EndDialog(hwndDlg, FALSE);
            }
            return TRUE;
        case IDCANCEL:
            EndDialog(hwndDlg, FALSE);
            return TRUE;
        }
        break;
    }

    return 0;
}

INT_PTR CALLBACK _ChooseDestDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_NOTIFY :
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_DBLCLK:
            // On this dialog, this message can only come from the listview.
            // If there is something selected, that means the user doubleclicked on an item
            // On a doubleclick we will trigger the OK button
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST)) > 0)
            {
                SendMessage (GetDlgItem(hwndDlg, IDOK), BM_CLICK, 0, 0);
            }
            break;
        case LVN_ITEMCHANGED:
            if (ListView_GetSelectedCount(GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST)) > 0)
            {
                Button_Enable(GetDlgItem(hwndDlg, IDOK), TRUE);
            }
            else
            {
                Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);
            }
            break;
        }
        break;

    case WM_INITDIALOG :
        {
            HWND hwndList = GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST);
            ListView_DeleteAllItems(hwndList);

            LVCOLUMN lvcolumn;
            lvcolumn.mask = LVCF_WIDTH;
            lvcolumn.cx = 250; // BUGBUG: should read width from box
            ListView_InsertColumn(hwndList, 0, &lvcolumn);

            LVITEM lvitem = {0};
            lvitem.mask = LVIF_TEXT;

            Button_Enable(GetDlgItem(hwndDlg, IDOK), FALSE);

            LPTSTR pszPtr = g_szMultiDests;

            BOOL fDone = FALSE;
            while (*pszPtr != NULL)
            {
                lvitem.iItem = lvitem.iItem = ListView_GetItemCount(hwndList);
                lvitem.pszText = pszPtr;
                ListView_InsertItem(hwndList, &lvitem);
                pszPtr += (lstrlen(pszPtr) + 1);
            }
        }

        return TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            {
                UINT uiSelected = ListView_GetSelectionMark(GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST));
                ListView_GetItemText(GetDlgItem(hwndDlg, IDC_DESTPICKER_LIST), uiSelected, 0, g_szMultiDests, ARRAYSIZE(g_szMultiDests));
                g_szMultiDests[lstrlen(g_szMultiDests) + 1] = 0; // double-null terminate the multi-sz
                EndDialog(hwndDlg, TRUE);
                return TRUE;
            }
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, FALSE);
            return TRUE;
            break;
        }
        break;
    }

    return 0;
}

BOOL
_ExclusiveMessageBoxVaArgs (
    IN      PTSTR pszTitle,
    IN      BOOL RetryCancel,
    IN      DWORD dwResourceId,
    ...
)
{
    TCHAR szErrMsg[MAX_LOADSTRING];
    TCHAR szErrStr[MAX_LOADSTRING];
    va_list args;

    LoadString(g_hInstance, dwResourceId, szErrMsg, ARRAYSIZE(szErrMsg));

    va_start (args, dwResourceId);
    FormatMessage (FORMAT_MESSAGE_FROM_STRING, szErrMsg, 0, 0, (LPTSTR)szErrStr, ARRAYSIZE (szErrStr), &args);
    va_end (args);

    if (RetryCancel) {
        return (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrStr,pszTitle,MB_RETRYCANCEL));
    } else {
        return (IDOK == _ExclusiveMessageBox (g_hwndCurrent,szErrStr,pszTitle,MB_OKCANCEL));
    }
}

PCTSTR
pGenerateNewNode (
    IN      PCTSTR OldNode
    )
{
    PTSTR newNode;
    PTSTR newNodePtr;
    PCTSTR result = NULL;

    newNode = (PTSTR)LocalAlloc (LPTR, (_tcslen (TEXT ("%CSIDL_PERSONAL%\\")) + _tcslen (OldNode) + 1) * sizeof (TCHAR));
    if (newNode) {
        _tcscpy (newNode, TEXT("%CSIDL_PERSONAL%\\"));
        _tcscat (newNode, OldNode);
        newNodePtr = _tcschr (newNode, TEXT(':'));
        while (newNodePtr) {
            *newNodePtr = TEXT('_');
            newNodePtr = _tcschr (newNode, TEXT(':'));
        }
        result = IsmExpandEnvironmentString (PLATFORM_DESTINATION, S_SYSENVVAR_GROUP, newNode, NULL);
        LocalFree ((PVOID)newNode);
    }
    return result;
}

BOOL
pForceRestoreObject (
    IN      MIG_OBJECTSTRINGHANDLE EncodedFileName,
    IN OUT  POBJLIST ObjList
    )
{
    MIG_CONTENT objectContent;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PCTSTR newNode = NULL;
    MIG_OBJECTSTRINGHANDLE newFileName;
    BOOL result = FALSE;

    if (IsmAcquireObject (MIG_FILE_TYPE | PLATFORM_SOURCE, EncodedFileName, &objectContent)) {
        // let's build the new name for this file
        if (IsmCreateObjectStringsFromHandle (EncodedFileName, &node, &leaf)) {
            if (node && leaf) {
                newNode = pGenerateNewNode (node);
                if (newNode) {
                    newFileName = IsmCreateObjectHandle (newNode, leaf);
                    if (newFileName) {
                        result = IsmReplacePhysicalObject (
                                    MIG_FILE_TYPE | PLATFORM_DESTINATION,
                                    newFileName,
                                    &objectContent
                                    );
                        if (result && ObjList) {
                            ObjList->AlternateName = (PTSTR)LocalAlloc (LPTR, (_tcslen (newFileName) + 1) * sizeof (TCHAR));
                            if (ObjList->AlternateName) {
                                _tcscpy (ObjList->AlternateName, newFileName);
                            }
                        }
                        IsmDestroyObjectHandle (newFileName);
                    }
                    IsmReleaseMemory (newNode);
                }
            }
            if (node) {
                IsmDestroyObjectString (node);
                node = NULL;
            }
            if (leaf) {
                IsmDestroyObjectString (leaf);
                leaf = NULL;
            }
        }
        IsmReleaseObject (&objectContent);
    }
    return result;
}

ULONG_PTR MessageCallback (UINT uiMsg, ULONG_PTR pArg)
{
    PRMEDIA_EXTRADATA extraData;
    PTRANSCOPY_ERROR transCopyError;
    PERRUSER_EXTRADATA errExtraData;
    PROLLBACK_USER_ERROR rollbackError;
    PPASSWORD_DATA passwordData;
    PMIG_APPINFO appInfo;
    PQUESTION_DATA questionData;
    int msgBoxReturn;
    TCHAR szTitle[MAX_LOADSTRING];
    LoadString(g_hInstance, IDS_MIGWIZTITLE, szTitle, ARRAYSIZE(szTitle));
    TCHAR szErrMsg[MAX_LOADSTRING];
    TCHAR szErrStr[MAX_LOADSTRING];
    POBJLIST wrnObj = NULL;
    PCTSTR objectType = NULL;
    PCTSTR objectName = NULL;
    static DWORD dwTypeID = 0;

    switch (uiMsg)
    {
    case MODULEMESSAGE_ASKQUESTION:
        questionData = (PQUESTION_DATA) pArg;
        if (questionData) {
            if (MessageBox (g_hwndCurrent, questionData->Question, szTitle, questionData->MessageStyle) == questionData->WantedResult) {
                return APPRESPONSE_SUCCESS;
            } else {
                return APPRESPONSE_FAIL;
            }
        }
        return APPRESPONSE_SUCCESS;

    case ISMMESSAGE_APP_INFO:
    case ISMMESSAGE_APP_INFO_NOW:
        appInfo = (PMIG_APPINFO) pArg;
        if (appInfo) {
            EnterCriticalSection(&g_AppInfoCritSection);
            g_AppInfoPhase = appInfo->Phase;
            g_AppInfoSubPhase = appInfo->SubPhase;
            g_AppInfoObjectTypeId = appInfo->ObjectTypeId;
            if (appInfo->ObjectName) {
                _tcsncpy (g_AppInfoObjectName, appInfo->ObjectName, 4096);
            } else {
                g_AppInfoObjectName [0] = 0;
            }
            if (appInfo->Text) {
                _tcsncpy (g_AppInfoText, appInfo->Text, 4096);
            } else {
                g_AppInfoText [0] = 0;
            }
            LeaveCriticalSection(&g_AppInfoCritSection);
            if (uiMsg == ISMMESSAGE_APP_INFO_NOW) {
                SendMessage (g_hwndCurrent, WM_USER_STATUS, 0, 0);
            }
        }
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_OLD_STORAGE:
        LoadString(g_hInstance, IDS_ENGERR_IMAGE_OLDFORMAT, szErrMsg, ARRAYSIZE(szErrMsg));
        _ExclusiveMessageBox (g_hwndCurrent, szErrMsg, szTitle, MB_OK);
        return 0;

    case TRANSPORTMESSAGE_IMAGE_EXISTS:
        LoadString(g_hInstance, IDS_ENGERR_IMAGE_EXISTS, szErrMsg, ARRAYSIZE(szErrMsg));
        g_fLastResponse = (IDYES == _ExclusiveMessageBox (g_hwndCurrent, szErrMsg, szTitle, MB_YESNO));
        return g_fLastResponse;

    case TRANSPORTMESSAGE_SIZE_SAVED:
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_RMEDIA_LOAD:
    case TRANSPORTMESSAGE_RMEDIA_SAVE:
        extraData = (PRMEDIA_EXTRADATA) pArg;
        if (!extraData) {
            LoadString(g_hInstance, IDS_ENGERR_NEXT_MEDIA, szErrMsg, ARRAYSIZE(szErrMsg));
            g_fLastResponse = (IDOK == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_OKCANCEL));
        } else {
            switch (extraData->LastError)
            {
            case RMEDIA_ERR_NOERROR:
                if (uiMsg == TRANSPORTMESSAGE_RMEDIA_LOAD) {
                    g_fLastResponse = _ExclusiveMessageBoxVaArgs (
                                            szTitle,
                                            FALSE,
                                            IDS_ENGERR_INSERT_DEST_MEDIA_NUMBER,
                                            extraData->MediaNumber
                                            );
                } else {
                    if (extraData->MediaNumber == 1) {
                        DOUBLE sizeMB = (DOUBLE) extraData->TotalImageSize / (1024 * 1024);
                        UINT intMB = (UINT) sizeMB;
                        UINT decMB = (UINT) ((sizeMB - intMB) * 100);
                        UINT sizeF = (UINT) (sizeMB / 1.44);
                        UINT sizeZ = (UINT) (sizeMB / 100);
                        if (sizeF < 1) {
                            LoadString(g_hInstance, IDS_ENGERR_INSERT_FIRST_MEDIA1, szErrMsg, ARRAYSIZE(szErrMsg));
                            wsprintf (szErrStr, szErrMsg, intMB, decMB);
                        } else if (sizeZ < 1) {
                            LoadString(g_hInstance, IDS_ENGERR_INSERT_FIRST_MEDIA2, szErrMsg, ARRAYSIZE(szErrMsg));
                            wsprintf (szErrStr, szErrMsg, intMB, decMB, 1 + sizeF);
                        } else {
                            LoadString(g_hInstance, IDS_ENGERR_INSERT_FIRST_MEDIA3, szErrMsg, ARRAYSIZE(szErrMsg));
                            wsprintf (szErrStr, szErrMsg, intMB, decMB, 1 + sizeF, 1 + sizeZ);
                        }
                        g_fLastResponse = (IDOK == _ExclusiveMessageBox (g_hwndCurrent,szErrStr,szTitle,MB_OKCANCEL));
                    } else {
                        UINT iDisks;
                        ULONGLONG ullBytesPerDisk;
                        ullBytesPerDisk = extraData->TotalImageWritten / (extraData->MediaNumber - 1);
                        if (ullBytesPerDisk) {
                            iDisks = (UINT)(extraData->TotalImageSize / ullBytesPerDisk) + 1;
                            g_fLastResponse = _ExclusiveMessageBoxVaArgs (
                                                    szTitle,
                                                    FALSE,
                                                    IDS_ENGERR_INSERT_MEDIA_NUMBER,
                                                    extraData->MediaNumber,
                                                    iDisks
                                                    );
                        } else {
                            LoadString(g_hInstance, IDS_ENGERR_NEXT_MEDIA, szErrMsg, ARRAYSIZE(szErrMsg));
                            g_fLastResponse = (IDOK == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_OKCANCEL));
                        }
                    }
                }
                break;
            case RMEDIA_ERR_WRONGMEDIA:
                g_fLastResponse = _ExclusiveMessageBoxVaArgs (szTitle,
                                                              TRUE,
                                                              IDS_ENGERR_WRONG_MEDIA,
                                                              extraData->MediaNumber);
                break;
            case RMEDIA_ERR_USEDMEDIA:
                g_fLastResponse = _ExclusiveMessageBoxVaArgs (szTitle,
                                                              FALSE,
                                                              IDS_ENGERR_USED_MEDIA,
                                                              extraData->MediaNumber);
                break;
            case RMEDIA_ERR_DISKFULL:
                LoadString(g_hInstance, IDS_ENGERR_FULL, szErrMsg, ARRAYSIZE(szErrMsg));
                g_fLastResponse = (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_RETRYCANCEL));
                break;
            case RMEDIA_ERR_NOTREADY:
                LoadString(g_hInstance, IDS_ENGERR_NOTREADY, szErrMsg, ARRAYSIZE(szErrMsg));
                g_fLastResponse = (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_RETRYCANCEL));
                break;
            case RMEDIA_ERR_WRITEPROTECT:
                LoadString(g_hInstance, IDS_ENGERR_WRITEPROTECT, szErrMsg, ARRAYSIZE(szErrMsg));
                g_fLastResponse = (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_RETRYCANCEL));
                break;
            case RMEDIA_ERR_CRITICAL:
                g_fLastResponse = FALSE;
                break;
            default:
                LoadString(g_hInstance, IDS_ENGERR_TOAST, szErrMsg, ARRAYSIZE(szErrMsg));
                g_fLastResponse = (IDRETRY == _ExclusiveMessageBox (g_hwndCurrent,szErrMsg,szTitle,MB_RETRYCANCEL));
            }
            return g_fLastResponse;
        }

    case TRANSPORTMESSAGE_READY_TO_CONNECT:
        // this message is received only on the new machine
        g_fReadFromNetwork = TRUE; // this means go ahead and read from the network immediately
        PropSheet_PressButton(GetParent(g_hwndCurrent), PSBTN_NEXT);
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_MULTIPLE_DESTS:
        // this is received only on the old machine
        {
            if (g_fReceivedMultiDest)
            {
                return APPRESPONSE_SUCCESS;
            }
            else
            {
                g_fReceivedMultiDest = TRUE;
                ULONG_PTR uiRetVal = APPRESPONSE_FAIL;
                g_fHaveNet = FALSE; // disable network unless user chooses a destination
                TCHAR szDestinations[20 * MAX_PATH];
                if (IsmGetEnvironmentMultiSz (
                        PLATFORM_DESTINATION,
                        NULL,
                        TRANSPORT_ENVVAR_HOMENET_DESTINATIONS,
                        szDestinations,
                        ARRAYSIZE(szDestinations),
                        NULL
                        ))
                {
                    memcpy(g_szMultiDests, szDestinations, sizeof(TCHAR) * ARRAYSIZE(szDestinations));
                    if (_ExclusiveDialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DESTPICKER), g_hwndCurrent, _ChooseDestDlgProc))
                    {
                        IsmSetEnvironmentMultiSz (
                            PLATFORM_DESTINATION,
                            NULL,
                            TRANSPORT_ENVVAR_HOMENET_DESTINATIONS,
                            g_szMultiDests
                            );
                        uiRetVal = APPRESPONSE_SUCCESS;
                        g_fHaveNet = TRUE; // re-enable network
                    }
                    else
                    {
                        g_fUberCancel = TRUE;
                        Engine_Cancel();
                    }
                }

                return uiRetVal;
            }
        }

    case ISMMESSAGE_EXECUTE_PREPROCESS:
        if (!g_migwiz->GetOOBEMode()) {
            AppExecute (g_migwiz->GetInstance(), g_hwndCurrent, (PCTSTR) pArg);
        }
        return APPRESPONSE_SUCCESS;

    case ISMMESSAGE_EXECUTE_REFRESH:
        if (!g_migwiz->GetOOBEMode() && !g_fUberCancel) {
            AppExecute (g_migwiz->GetInstance(), g_hwndCurrent, (PCTSTR) pArg);
        }
        return APPRESPONSE_SUCCESS;

    case ISMMESSAGE_EXECUTE_POSTPROCESS:
        if (!g_migwiz->GetOOBEMode()) {
            AppExecute (g_migwiz->GetInstance(), g_hwndCurrent, (PCTSTR) pArg);
        }
        return APPRESPONSE_SUCCESS;

    case ISMMESSAGE_EXECUTE_ROLLBACK:
        rollbackError = (PROLLBACK_USER_ERROR) pArg;
        if (rollbackError) {
            LoadString(g_hInstance, IDS_CANTROLLBACK, szErrMsg, ARRAYSIZE(szErrMsg));
            wsprintf (szErrStr, szErrMsg, rollbackError->UserDomain, rollbackError->UserName);
            _ExclusiveMessageBox (g_hwndCurrent,szErrStr,szTitle,MB_OK);
        }
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_SRC_COPY_ERROR:
        transCopyError = (PTRANSCOPY_ERROR) pArg;
        if (transCopyError) {
            if (StrCmpI (transCopyError->ObjectType, TEXT("File")) == 0) {
                if ((transCopyError->Error == ERROR_SHARING_VIOLATION) ||
                    (transCopyError->Error == ERROR_LOCK_VIOLATION) ||
                    (transCopyError->Error == 0x80090020)   // found this on a WinME machine, when a file was locked
                    ) {
                    LoadString(g_hInstance, IDS_ENGERR_COPYSOURCE, szErrMsg, ARRAYSIZE(szErrMsg));
                    wsprintf (szErrStr, szErrMsg, transCopyError->ObjectName);
                    msgBoxReturn = _ExclusiveMessageBox (g_hwndCurrent,szErrStr,szTitle,MB_ABORTRETRYIGNORE | MB_DEFBUTTON2);
                    if (msgBoxReturn == IDRETRY) {
                        return APPRESPONSE_SUCCESS;
                    }
                    if (msgBoxReturn == IDIGNORE) {
                        return APPRESPONSE_IGNORE;
                    }
                    return APPRESPONSE_FAIL;
                }
                // we don't really know what was the problem here.
                // Let's just continue, at the end we will tell the
                // user about this file and he will copy it manually.
                return APPRESPONSE_IGNORE;
            }
        }
        return APPRESPONSE_FAIL;

    case MODULEMESSAGE_DISPLAYERROR:
        errExtraData = (PERRUSER_EXTRADATA) pArg;
        if (errExtraData && !g_HTMLErrArea) {
            switch (errExtraData->ErrorArea) {
                case ERRUSER_AREA_INIT:
                    g_HTMLErrArea = IDS_ERRORAREA_INIT;
                    break;
                case ERRUSER_AREA_GATHER:
                    g_HTMLErrArea = IDS_ERRORAREA_GATHER;
                    break;
                case ERRUSER_AREA_SAVE:
                    g_HTMLErrArea = IDS_ERRORAREA_SAVE;
                    break;
                case ERRUSER_AREA_LOAD:
                    g_HTMLErrArea = IDS_ERRORAREA_LOAD;
                    break;
                case ERRUSER_AREA_RESTORE:
                    g_HTMLErrArea = IDS_ERRORAREA_RESTORE;
                    break;
                default:
                    g_HTMLErrArea = IDS_ERRORAREA_UNKNOWN;
            }
            switch (errExtraData->Error) {
                case ERRUSER_ERROR_NOTRANSPORTPATH:
                    g_HTMLErrInstr = IDS_ERROR_NOTRANSPORTPATH;
                    break;
                case ERRUSER_ERROR_TRANSPORTPATHBUSY:
                case ERRUSER_ERROR_CANTEMPTYDIR:
                case ERRUSER_ERROR_ALREADYEXISTS:
                case ERRUSER_ERROR_CANTCREATEDIR:
                case ERRUSER_ERROR_CANTCREATESTATUS:
                case ERRUSER_ERROR_CANTWRITETODESTPATH:
                    g_HTMLErrInstr = IDS_ERROR_TRANSPORTNOACCESS;
                    break;
                case ERRUSER_ERROR_CANTCREATETEMPDIR:
                case ERRUSER_ERROR_CANTCREATECABFILE:
                case ERRUSER_ERROR_CANTSAVEINTERNALDATA:
                    g_HTMLErrInstr = IDS_ERROR_TRANSPORTINTERNALERROR;
                    break;
                case ERRUSER_ERROR_TRANSPORTINVALIDIMAGE:
                case ERRUSER_ERROR_CANTOPENSTATUS:
                case ERRUSER_ERROR_CANTREADIMAGE:
                    g_HTMLErrInstr = IDS_ERROR_TRANSPORTNOVALIDSOURCE;
                    break;
                case ERRUSER_ERROR_CANTFINDDESTINATION:
                case ERRUSER_ERROR_CANTSENDTODEST:
                    g_HTMLErrInstr = IDS_ERROR_HOMENETINVALIDDEST;
                    break;
                case ERRUSER_ERROR_CANTFINDSOURCE:
                case ERRUSER_ERROR_CANTRECEIVEFROMSOURCE:
                case ERRUSER_ERROR_INVALIDDATARECEIVED:
                    g_HTMLErrInstr = IDS_ERROR_HOMENETINVALIDSRC;
                    break;
                case ERRUSER_ERROR_NOENCRYPTION:
                    g_HTMLErrInstr = IDS_ERROR_HOMENETINVALIDENC;
                    break;
                case ERRUSER_ERROR_CANTUNPACKIMAGE:
                    g_HTMLErrInstr = IDS_ERROR_TRANSPORTINTERNALERROR;
                    break;
                case ERRUSER_ERROR_CANTSAVEOBJECT:
                case ERRUSER_ERROR_CANTRESTOREOBJECT:
                    if (errExtraData->ErrorArea == ERRUSER_AREA_SAVE) {
                        g_HTMLErrInstr = IDS_ERROR_CANTSAVEOBJECT;
                    } else {
                        g_HTMLErrInstr = IDS_ERROR_CANTRESTOREOBJECT;
                    }
                    if (errExtraData->ObjectTypeId && errExtraData->ObjectName) {
                        objectType = IsmGetObjectTypeName (errExtraData->ObjectTypeId);
                        if (objectType) {
                            objectName = IsmGetNativeObjectName (errExtraData->ObjectTypeId, errExtraData->ObjectName);
                            if (objectName) {
                                if (StrCmpI (objectType, TEXT("File")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnFile;
                                    g_HTMLWrnFile = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("RasConnection")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnRas;
                                    g_HTMLWrnRas = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("MappedDrives")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnNet;
                                    g_HTMLWrnNet = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("Printers")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnPrn;
                                    g_HTMLWrnPrn = wrnObj;
                                }
                                IsmReleaseMemory (objectName);
                                objectName = NULL;
                            }
                            objectType = NULL;
                        }
                    }
                    break;
                case ERRUSER_WARNING_OUTLOOKRULES:
                    g_HTMLErrInstr = IDS_ERROR_CANTRESTOREOBJECT;
                    LoadString(g_hInstance, IDS_WARNING_OUTLOOKRULES, szErrMsg, ARRAYSIZE(szErrMsg));
                    wrnObj = _AllocateObjectList (szErrMsg);
                    wrnObj->Next = g_HTMLWrnGeneral;
                    g_HTMLWrnGeneral = wrnObj;
                    break;
                case ERRUSER_WARNING_OERULES:
                    g_HTMLErrInstr = IDS_ERROR_CANTRESTOREOBJECT;
                    LoadString(g_hInstance, IDS_WARNING_OERULES, szErrMsg, ARRAYSIZE(szErrMsg));
                    wrnObj = _AllocateObjectList (szErrMsg);
                    wrnObj->Next = g_HTMLWrnGeneral;
                    g_HTMLWrnGeneral = wrnObj;
                    break;
                case ERRUSER_ERROR_DISKSPACE:
                    g_HTMLErrInstr = IDS_ERROR_DISKSPACE;
                    break;
            }
        }
        return APPRESPONSE_SUCCESS;

    case MODULEMESSAGE_DISPLAYWARNING:
        errExtraData = (PERRUSER_EXTRADATA) pArg;
        if (errExtraData) {
            switch (errExtraData->Error) {
                case ERRUSER_ERROR_CANTSAVEOBJECT:
                case ERRUSER_ERROR_CANTRESTOREOBJECT:
                    if (errExtraData->ObjectTypeId && errExtraData->ObjectName) {
                        objectType = IsmGetObjectTypeName (errExtraData->ObjectTypeId);
                        if (objectType) {
                            objectName = IsmGetNativeObjectName (errExtraData->ObjectTypeId, errExtraData->ObjectName);
                            if (objectName) {
                                if (StrCmpI (objectType, TEXT("File")) == 0) {
                                    // If we are restoring this file, we are going to try
                                    // to write it to a default location where the user
                                    // can find it later
                                    if (errExtraData->Error == ERRUSER_ERROR_CANTRESTOREOBJECT) {
                                        wrnObj = _AllocateObjectList (objectName);
                                        if (pForceRestoreObject (errExtraData->ObjectName, wrnObj)) {
                                            wrnObj->Next = g_HTMLWrnAltFile;
                                            g_HTMLWrnAltFile = wrnObj;
                                        } else {
                                            wrnObj->Next = g_HTMLWrnFile;
                                            g_HTMLWrnFile = wrnObj;
                                        }
                                    } else {
                                        wrnObj = _AllocateObjectList (objectName);
                                        wrnObj->Next = g_HTMLWrnFile;
                                        g_HTMLWrnFile = wrnObj;
                                    }
                                } else if (StrCmpI (objectType, TEXT("RasConnection")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnRas;
                                    g_HTMLWrnRas = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("MappedDrives")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnNet;
                                    g_HTMLWrnNet = wrnObj;
                                } else if (StrCmpI (objectType, TEXT("Printers")) == 0) {
                                    wrnObj = _AllocateObjectList (objectName);
                                    wrnObj->Next = g_HTMLWrnPrn;
                                    g_HTMLWrnPrn = wrnObj;
                                }
                                IsmReleaseMemory (objectName);
                                objectName = NULL;
                            }
                            objectType = NULL;
                        }
                    }
                    break;
            }
        }
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_NET_DISPLAY_PASSWORD:
        passwordData = (PPASSWORD_DATA) pArg;
        if (passwordData) {
            DialogBoxParam (
                g_hInstance,
                MAKEINTRESOURCE(IDD_DISPLAY_PASSWORD),
                g_hwndCurrent,
                _DisplayPasswordDlgProc,
                (LPARAM)passwordData
                );
        }
        return APPRESPONSE_SUCCESS;

    case TRANSPORTMESSAGE_NET_GATHER_PASSWORD:
        passwordData = (PPASSWORD_DATA) pArg;
        if (passwordData) {
            if (DialogBoxParam (
                    g_hInstance,
                    MAKEINTRESOURCE(IDD_GATHER_PASSWORD),
                    g_hwndCurrent,
                    _GatherPasswordDlgProc,
                    (LPARAM)passwordData
                    )) {
                return APPRESPONSE_SUCCESS;
            }
        }
        return APPRESPONSE_FAIL;
    }
    return FALSE;
}

HRESULT MigrationWizard::_InitEngine(BOOL fSource, BOOL* pfNetworkDetected)
{
    HRESULT hr;

    TCHAR szAppPath[MAX_PATH] = TEXT("");
    TCHAR* pszAppPathOffset;

    GetModuleFileName (NULL, szAppPath, ARRAYSIZE(szAppPath));
    pszAppPathOffset = _tcsrchr (szAppPath, TEXT('\\'));
    if (pszAppPathOffset) {
        pszAppPathOffset ++;
    } else {
        pszAppPathOffset = szAppPath;
    }
    _tcsncpy (pszAppPathOffset, TEXT("migism.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));


    hr = Engine_Initialize(szAppPath, fSource, TRUE, _pszUsername, MessageCallback, pfNetworkDetected);

    if (SUCCEEDED(hr))
    {
        _fInit = TRUE;

        _tcsncpy (pszAppPathOffset, TEXT("migwiz.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
        hr = Engine_AppendScript(fSource, szAppPath);

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("usmtdef.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("migapp.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("migsys.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("miguser.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (SUCCEEDED(hr))
        {
            _tcsncpy (pszAppPathOffset, TEXT("sysfiles.inf"), ARRAYSIZE(szAppPath) - (pszAppPathOffset - szAppPath));
            hr = Engine_AppendScript(fSource, szAppPath);
        }

        if (fSource)
        {
            if (SUCCEEDED(hr))
            {
                hr = Engine_Parse();
            }
        }
    }

    return hr;
}

HRESULT MigrationWizard::SelectComponentSet(UINT uSelectionGroup)
{
    if (_fOOBEMode)
    {
        Engine_SelectComponentSet(MIGINF_SELECT_OOBE);
    }
    else
    {
        Engine_SelectComponentSet(uSelectionGroup);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\registry.cpp ===
//
// Registry.cpp
//

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 char* szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const char* szFriendlyName, // Friendly Name
                       const char* szVerIndProgID, // Programmatic
                       const char* szProgID)       //   IDs
{
	// Get server location.
	char szModule[512] ;
	DWORD dwResult =
		::GetModuleFileName(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(char)) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, "InprocServer32", szModule) ;

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, "ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, "VersionIndependentProgID",
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, "CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, "CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, "CLSID", szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      const char* szVerIndProgID, // Programmatic
                      const char* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 char* szCLSID,
                 int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length) ;

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const char* lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	char szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const char* szKey,
                    const char* szSubkey,
                    const char* szValue)
{
	HKEY hKey;
	char szKeyBuf[1024] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, NULL, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              strlen(szValue)+1) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\sources.inc ===
!include ..\..\app.mk

MINORCOMP=migwiz

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\main.cpp         \
    ..\migwiz.cpp       \
    ..\migeng.cpp       \
    ..\miginf.cpp       \
    ..\migtask.cpp      \
    ..\migutil.cpp      \
    ..\migwnprc.cpp     \
    ..\container.cpp    \
    ..\migwiz.rc

# app settings
UMENTRY=winmain
UMTYPE=windows

# extra libs
TARGETLIBS= $(SDK_LIB_PATH)\ShFolder.Lib                \
            $(TARGETLIBS)                               \
            $(COBRA_ROOT)\bin\$(O)\migism.lib           \
            $(COBRA_ROOT)\bin\$(O)\log.lib              \
            $(SHELL_LIB_PATH)\shlwapip.lib              \
            $(COBRA_ROOT)\lib\$(O)\cablib.lib           \
            $(SDK_LIB_PATH)\cabinet.lib                 \

PRECOMPILED_INCLUDE=..\pch.h

# target
TARGETNAME=migwiz
TARGETTYPE=PROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by visualc.rc
//
#define IDS_GETSTARTEDTITLE             1
#define IDS_DISKPROGRESSTITLE           5
#define IDS_DISKINSTRUCTIONSTITLE       7
#define IDS_PICKAPPLYSTORETITLE         9
#define IDS_APPLYPROGRESSTITLE          11
#define IDS_PICKMETHODTITLE             13
#define IDS_CUSTOMIZETITLE              15
#define IDS_PICKCOLLECTSTORETITLE       17
#define IDS_DIRECTCABLETITLE            18
#define IDS_COLLECTPROGRESSTITLE        21
#define IDS_DISKPLEASE                  23
#define IDS_NODISK                      24
#define IDS_MIGWIZTITLE                 25
#define IDS_STOPDISK                    26
#define IDS_ERRORDISK                   27
#define IDS_ENGERR_IMAGE_EXISTS         28
#define IDS_ENGERR_NEXT_MEDIA           30
#define IDS_ENGERR_TOAST                31
#define IDS_COLS_EXTENSIONS             32
#define IDS_COLS_FILETYPES              33
#define IDS_PICK_FOLDERS                35
#define IDS_PICK_FILES                  36
#define IDS_PICK_TYPES                  37
#define IDS_ADDAFOLDER                  38
#define IDS_PICKAFILE                   39
#define IDS_OPENFILEFILTER_ALL          40
#define IDS_ENGERR_INSERT_MEDIA_NUMBER  41
#define IDS_ENGERR_INSERT_MEDIA_ONLY    42
#define IDS_ENGERR_FULL                 49
#define IDS_NONETWORK                   70
#define IDS_WAITTITLE                   73
#define IDS_ENGERR_WRONG_MEDIA          75
#define IDS_PICKSETTINGS                82
#define IDD_INTRO                       101
#define IDD_ENDCOLLECT                  102
#define IDD_GETSTARTED                  103
#define IDD_CUSTOMIZE                   104
#define IDB_BANNER                      105
#define IDD_PICKMETHOD                  105
#define IDB_WATERMARK                   106
#define IDD_ENDAPPLY                    107
#define IDD_PICKCOLLECTSTORE            109
#define IDD_COLLECTPROGRESS             111
#define IDD_DISKINSTRUCTIONS            113
#define IDD_APPLYPROGRESS               115
#define IDD_FILETYPEPICKER              116
#define IDD_DISKPROGRESS                117
#define IDD_PICKAPPLYSTORE              118
#define IDD_INTROLEGACY                 119
#define IDD_ENDCOLLECTFAIL              124
#define IDD_INTROOOBE                   125
#define IDD_ENDOOBE                     126
#define IDD_WAIT                        127
#define IDD_SETTINGPICKER               128
#define IDA_STARTUP                     129
#define IDD_FAILCLEANUP                 130
#define IDS_FAILCLEANUPTITLE            131
#define IDD_DESTPICKER                  131
#define IDD_ASKCD                       133
#define IDS_MAKETOOLDISK_INSERT         134
#define IDD_CDINSTRUCTIONS              134
#define IDS_ENTERDEST                   135
#define IDS_ENGERR_COPYSOURCE           136
#define IDD_ENDAPPLYFAIL                136
#define IDS_ENGERR_COPYFAILED           137
#define IDS_ASKCDTITLE                  138
#define IDB_SMEXCLAMATION               140
#define IDS_CDINSTRUCTIONSTITLE         142
#define IDS_ENGERR_NOTREADY             144
#define IDS_ENGERR_WRITEPROTECT         145
#define IDS_CSIDL_APPDATA               146
#define IDS_CSIDL_ADMINTOOLS            147
#define IDS_CSIDL_ALTSTARTUP            148
#define IDD_ENDCOLLECTNET               148
#define IDS_CSIDL_BITBUCKET             149
#define IDS_CSIDL_CONTROLS              150
#define IDS_CSIDL_COOKIES               151
#define IDS_CSIDL_DESKTOP               152
#define IDS_CSIDL_DESKTOPDIRECTORY      153
#define IDS_CSIDL_DRIVES                154
#define IDS_CSIDL_FAVORITES             155
#define IDS_CSIDL_FONTS                 156
#define IDS_CSIDL_HISTORY               157
#define IDS_CSIDL_INTERNET              158
#define IDS_CSIDL_INTERNET_CACHE        159
#define IDS_CSIDL_LOCAL_APPDATA         160
#define IDS_CSIDL_MYPICTURES            161
#define IDS_CSIDL_NETHOOD               162
#define IDS_CSIDL_NETWORK               163
#define IDS_CSIDL_PERSONAL              164
#define IDS_CSIDL_PROFILE               165
#define IDS_CSIDL_PROGRAM_FILES         166
#define IDS_CSIDL_PROGRAM_FILES_COMMON  167
#define IDS_CSIDL_PROGRAMS              168
#define IDS_CSIDL_RECENT                169
#define IDS_CSIDL_SENDTO                170
#define IDS_CSIDL_STARTMENU             171
#define IDS_CSIDL_STARTUP               172
#define IDS_CSIDL_SYSTEM                173
#define IDS_CSIDL_TEMPLATES             174
#define IDS_CSIDL_WINDOWS               175
#define IDS_CSIDL_MYDOCUMENTS           176
#define IDS_CSIDL_MYMUSIC               177
#define IDS_CSIDL_MYVIDEO               178
#define IDS_CSIDL_SYSTEMX86             179
#define IDS_CSIDL_PROGRAM_FILESX86      180
#define IDS_CSIDL_PROGRAM_FILES_COMMONX86 181
#define IDS_CSIDL_CONNECTIONS           182
#define IDS_CSIDL_COMMON_ADMINTOOLS     183
#define IDS_CSIDL_COMMON_ALTSTARTUP     184
#define IDS_CSIDL_COMMON_APPDATA        185
#define IDS_CSIDL_COMMON_DESKTOPDIRECTORY 186
#define IDS_CSIDL_COMMON_DOCUMENTS      187
#define IDS_CSIDL_COMMON_FAVORITES      188
#define IDS_CSIDL_COMMON_PROGRAMS       189
#define IDS_CSIDL_COMMON_STARTMENU      190
#define IDS_CSIDL_COMMON_STARTUP        191
#define IDS_CSIDL_COMMON_TEMPLATES      192
#define IDS_ASKFORLOGOFF                193
#define IDS_COLLECT_REGISTRY            194
#define IDS_COLLECT_FILE_FMT            195
#define IDS_APPLY_REGISTRY              196
#define IDS_APPLY_FILE_FMT              197
#define IDS_ALREADY_RUN_USER            198
#define IDS_ANOTHER_USER                199
#define IDS_CANTROLLBACK                200
#define IDS_PICKAFOLDER                 201
#define IDS_MIGWIZLNK_TITLE             202
#define IDS_MIGWIZLNK_INFO              203
#define IDS_ENGERR_INSERT_DEST_MEDIA_NUMBER 204
#define IDS_ENGERR_INSERT_FIRST_MEDIA   205
#define IDS_ERROR_PATHTOOLONG           206
#define IDS_ASKCREATEDIR                207
#define IDS_ERRORHTML_BEGIN             208
#define IDS_ERRORHTML_END               209
#define IDS_ERRORAREA_INIT              210
#define IDS_ERRORAREA_GATHER            211
#define IDS_ERRORAREA_SAVE              212
#define IDS_ERRORAREA_LOAD              213
#define IDS_ERRORAREA_RESTORE           214
#define IDS_ERRORAREA_UNKNOWN           215
#define IDS_ERROR_NOTRANSPORTPATH       216
#define IDS_ERROR_TRANSPORTNOACCESS     217
#define IDS_ERROR_TRANSPORTINTERNALERROR 218
#define IDS_ERROR_TRANSPORTNOVALIDSOURCE 219
#define IDS_ERROR_HOMENETINVALIDDEST    220
#define IDS_ERROR_HOMENETINVALIDSRC     221
#define IDS_ERROR_CANTSAVEOBJECT        222
#define IDS_ERROR_CANTRESTOREOBJECT     223
#define IDS_ERROR_DISKSPACE             224
#define IDS_COLLECT_BEGIN               225
#define IDS_COLLECT_END                 226
#define IDS_COLLECTNET_BEGIN            227
#define IDS_COLLECTNET_END              228
#define IDS_APPLY_BEGIN                 229
#define IDS_APPLY_END                   230
#define IDS_WARNING_RESTORE             231
#define IDS_WARNING_RESTOREFILE1        232
#define IDS_WARNING_RESTOREFILE2        233
#define IDS_WARNING_RESTORERAS1         234
#define IDS_WARNING_RESTORERAS2         235
#define IDS_WARNING_RESTORENET1         236
#define IDS_WARNING_RESTORENET2         237
#define IDS_WARNING_RESTOREPRN1         238
#define IDS_WARNING_RESTOREPRN2         239
#define IDS_WARNING_SAVE                240
#define IDS_WARNING_SAVEFILE1           241
#define IDS_WARNING_SAVEFILE2           242
#define IDS_WARNING_SAVERAS1            243
#define IDS_WARNING_SAVERAS2            244
#define IDS_WARNING_SAVENET1            245
#define IDS_WARNING_SAVENET2            246
#define IDS_WARNING_SAVEPRN1            247
#define IDS_WARNING_SAVEPRN2            248
#define IDS_ENGERR_IMAGE_OLDFORMAT      249
#define IDS_STORAGEEMPTY                250
#define IDS_STORAGEINVALID              251
#define IDS_ASKFORREBOOT                252
#define IDS_DISKSPACEWARNING            253
#define IDS_ENGERR_USED_MEDIA           254
#define IDS_ERRORHTML_SAVEFILE1         255
#define IDS_ERRORHTML_SAVEFILE2         256
#define IDS_ERRORHTML_SAVERAS1          257
#define IDS_ERRORHTML_SAVERAS2          258
#define IDS_ERRORHTML_SAVENET1          259
#define IDS_ERRORHTML_SAVENET2          260
#define IDS_ERRORHTML_SAVEPRN1          261
#define IDS_ERRORHTML_SAVEPRN2          262
#define IDS_CONFIRMCANCEL               263
#define IDS_NOMORE_SETTINGS             264
#define IDS_ENGERR_INSERT_FIRST_MEDIA1  265
#define IDD_DISPLAY_PASSWORD            265
#define IDS_ENGERR_INSERT_FIRST_MEDIA2  266
#define IDD_GATHER_PASSWORD             266
#define IDS_ENGERR_INSERT_FIRST_MEDIA3  267
#define IDD_DIRECTCABLE                 267
#define IDS_WARNING_RESTOREALTFILE1     268
#define IDS_WARNING_RESTOREALTFILE2     269
#define IDD_DIRECTCABLE_WAIT            269
#define IDS_ERROR_HOMENETINVALIDENC     270
#define IDS_WARNING_RESTOREGENERAL1     271
#define IDS_WARNING_RESTOREGENERAL2     272
#define IDD_APPINSTALL                  272
#define IDS_WARNING_OUTLOOKRULES        273
#define IDS_APPINFO_QUEUE               274
#define IDS_APPINFO_GATHER1             275
#define IDS_APPINFO_GATHER2             276
#define IDS_APPINFO_APPLY               277
#define IDS_APPINFO_ORGANIZING          278
#define IDS_APPINFO_TRANSPORT           279
#define IDS_APPINFO_TR_CONNECTING1      279
#define IDS_APPINFO_TR_CONNECTING2      280
#define IDS_APPINFO_TR_NETPREPARING     281
#define IDS_APPINFO_TR_PREPARING        282
#define IDS_APPINFO_TR_COMPRESSING      283
#define IDS_APPINFO_TR_TRANSPORTING     284
#define IDS_APPINFO_TR_MEDIAWRITING     285
#define IDS_APPINFO_TR_FINISHING        286
#define IDS_WARNING_OERULES             287
#define IDS_WIN9X_HEADER_FONTSIZE       288
#define IDS_APPINFO_TR_UNCOMPRESSING    289
#define IDS_APPINSTALLTITLE             290
#define IDS_APPINSTALL_BEGIN            291
#define IDS_APPINSTALL_END              292
#define IDS_ENTERSOURCE                 293
#define IDC_INTRO_TITLE                 1000
#define IDC_ENDCOLLECT_TITLE            1000
#define IDC_GETSTARTED_TEXT1            1000
#define IDC_INTRO_TEXT1                 1001
#define IDC_GETSTARTED_RADIOOLD         1001
#define IDC_INTRO_TEXT2                 1002
#define IDC_GETSTARTED_RADIONEW         1002
#define IDC_GETSTARTED_GROUP            1003
#define IDC_CUSTOMIZE_ADDFOLDERS        1003
#define IDC_INTRO_TEXT3                 1003
#define IDC_CUSTOMIZE_ADDTYPES          1004
#define IDC_CUSTOMIZE_ADDFILE           1005
#define IDC_CUSTOMIZE_ADDSETTING        1006
#define IDC_INTRO_TEXT4                 1006
#define IDC_CUSTOMIZE_REMOVE            1007
#define IDC_WIZ95DIVIDER                1009
#define IDC_WIZ95TITLE                  1010
#define IDC_WIZ95SUBTITLE               1011
#define IDC_WIZ95WATERMARK              1012
#define IDC_INSTRUCTIONS_TEXT1          1038
#define IDC_INSTRUCTIONS_TEXT2          1040
#define IDC_INSTRUCTIONS_TEXT3          1041
#define IDC_APPLYPROGRESS_TEXT1         1048
#define IDC_APPLYPROGRESS_PROGRESS      1049
#define IDC_COLLECTPROGRESS_PROGRESS    1050
#define IDC_ENDCOLLECT_TEXT1            1051
#define IDC_ENDCOLLECT_TEXT2            1052
#define IDC_ENDCOLLECT_TEXT3            1053
#define IDC_ENDCOLLECT_TEXT4            1054
#define IDC_FILETYPE_TEXT1              1055
#define IDC_FILETYPE_LIST               1056
#define IDC_COLLECTPROGRESS_MARKER      1057
#define IDC_APPLYPROGRESS_MARKER        1058
#define IDC_DISKPROGRESS_TEXT1          1075
#define IDC_DISKPROGRESS_MARKER         1076
#define IDC_DISKPROGRESS_PROGRESS       1078
#define IDC_PICKAPPLYSTORE_RADIO1       1092
#define IDC_PICKAPPLYSTORE_RADIO2       1093
#define IDC_PICKAPPLYSTORE_RADIO3       1094
#define IDC_PICKAPPLYSTORE_GROUP        1095
#define IDC_ENDAPPLY_TITLE              1097
#define IDC_ENDAPPLY_TEXT1              1098
#define IDC_CUSTOMIZE_TREE              1099
#define IDC_ENDAPPLY_TEXT2              1099
#define IDC_INTROLEGACY_TITLE           1100
#define IDC_INTROLEGACY_TEXT2           1101
#define IDC_INTROLEGACY_TEXT1           1102
#define IDC_CUSTOMIZE_TEXT              1103
#define IDC_INTROLEGACY_TEXT3           1104
#define IDC_COLLECTPROGRESS_TEXT2       1107
#define IDC_INSTRUCTIONS_TEXT4          1108
#define IDC_INSTRUCTIONS_TEXT5          1109
#define IDC_ENDFAIL_TITLE               1135
#define IDC_ENDFAIL_TEXT1               1136
#define IDC_ENDFAIL_TEXT2               1137
#define IDC_INTROOOBE_TITLE             1138
#define IDC_ENDOOBE_TITLE               1139
#define IDC_ENDOOBE_TEXT1               1140
#define IDC_WAIT_TEXT1                  1144
#define IDC_WAIT_MARKER                 1145
#define IDC_PICKCOLLECTSTORE_RADIO1     1146
#define IDC_WAIT_TEXT2                  1146
#define IDC_PICKCOLLECTSTORE_RADIO3     1147
#define IDC_PICKCOLLECTSTORE_RADIO2     1148
#define IDC_PICKCOLLECTSTORE_GROUP      1149
#define IDC_PICKCOLLECTSTORE_EDIT       1150
#define IDC_PICKCOLLECTSTORE_BROWSE     1151
#define IDC_PICKCOLLECTSTORE_RADIO4     1152
#define IDC_PICKCOLLECTSTORE_TEXT1      1155
#define IDC_PICKAPPLYSTORE_TEXT         1156
#define IDC_PICKAPPLYSTORE_EDIT         1158
#define IDC_PICKAPPLYSTORE_BROWSE       1159
#define IDC_PICKMETHOD_TEXT1            1162
#define IDC_PICKMETHOD_RADIO1           1163
#define IDC_PICKMETHOD_RADIO2           1164
#define IDC_PICKMETHOD_RADIO3           1165
#define IDC_PICKMETHOD_GROUP            1166
#define IDC_PICKMETHOD_CUSTOMIZE        1167
#define IDC_PICKMETHOD_TEXT2            1170
#define IDC_PICKMETHOD_TREE             1172
#define IDC_PICKCOLLECTSTORE_TEXT2      1173
#define IDC_SETTINGPICKER_TEXT1         1174
#define IDC_SETTINGPICKER_LIST          1175
#define IDC_DESTPICKER_TEXT1            1176
#define IDC_DESTPICKER_LIST             1177
#define IDC_GETSTARTED_DESCOLD          1178
#define IDC_ASKCD_TEXT2                 1179
#define IDC_ASKCD_RADIO1                1180
#define IDC_ASKCD_RADIO2                1181
#define IDC_ASKCD_RADIO3                1182
#define IDC_ASKCD_RADIO                 1183
#define IDC_ASKCD_RADIO4                1183
#define IDC_CDINSTRUCTIONS_TEXT2        1185
#define IDC_CDINSTRUCTIONS_TEXT3        1186
#define IDC_CDINSTRUCTIONS_TEXT4        1187
#define IDC_CDINSTRUCTIONS_TEXT5        1188
#define IDC_CDINSTRUCTIONS_TEXT6        1190
#define IDC_CDINSTRUCTIONS_TEXT7        1191
#define IDC_CDINSTRUCTIONS_TEXT8        1192
#define IDC_FILETYPEEDIT                1198
#define IDC_FILETYPEEDITLABEL           1199
#define IDC_COLLECTPROGRESS_ANIM        1200
#define IDC_PICKFILETYPETEXT1           1200
#define IDC_DISKPROGRESS_ANIM           1201
#define IDC_PICKFILETYPETEXT2           1201
#define IDC_APPLYPROGRESS_ANIM          1202
#define IDC_WAIT_ANIM                   1203
#define IDC_GETSTARTED_DESCNEW          1204
#define IDC_ASKCD_TEXT1                 1205
#define IDC_CDINSTRUCTIONS_TEXT1        1206
#define IDC_PICKCOLLECTSTORE_TEXT3      1207
#define IDC_ENDCOLLECTNET_TEXT1         1207
#define IDC_PICKCOLLECTSTORE_TEXT4      1208
#define IDC_ENDCOLLECTNET_TEXT2         1208
#define IDC_PICKCOLLECTSTORE_TEXT5      1209
#define IDC_ENDCOLLECTNET_TEXT4         1209
#define IDC_CDINSTRUCTIONS_TEXT_5       1210
#define IDC_PROGRESS_STATUS             1211
#define IDC_WEBHOST                     1211
#define IDC_PICKMETHOD_TEXT3            1211
#define IDC_WAIT_ANIMATE1               1212
#define IDC_APPLYPROGRESS_STATUS        1213
#define IDC_WAIT_ANIMATE2               1213
#define IDC_CDINSTRUCTIONS_ICON         1214
#define IDC_PROGRESS_ANIMATE3           1214
#define IDC_INSTRUCTIONS_ICON           1215
#define IDC_PROGRESS_ANIMATE2           1215
#define IDC_PICKMETHOD_WARNINGICON      1216
#define IDC_PROGRESS_ANIMATE1           1216
#define IDC_PICKCOLLECTSTORE_COMBO      1217
#define IDC_INTRO_TEXT5                 1218
#define IDC_PICKAPPLYSTORE_COMBO        1219
#define IDC_DISPLAY_PASSWORD            1220
#define IDC_GATHER_PASSWORD             1221
#define IDC_DIRECTC_COMSELECT           1222
#define IDC_DIRECTC_AUTO                1223
#define IDC_DIRECTCABLE_SUCCESSTEXT     1225
#define IDC_DIRECTCABLE_FAILURETEXT     1226
#define IDC_DIRECTCABLE_WAIT_ANIMATE    1226
#define IDC_DIRECTCABLE_WAIT_TEXT1      1227
#define IDC_DIRECTCABLE_WAIT_TEXT2      1228
#define IDC_DIRECTCABLE_ICONYES         1229
#define IDC_DIRECTCABLE_ICONNO          1230
#define IDC_DIRECTC_LABELPORT           1231
#define IDC_ASKCD_COMBO                 1232
#define IDC_APPWEBHOST                  1233
#define IDA_FILECOPY                    2000
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        273
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1234
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\migwiz\registry.h ===
#ifndef __Registry_H__
#define __Registry_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const char* szFriendlyName,
                       const char* szVerIndProgID,
                       const char* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         const char* szVerIndProgID,
                         const char* szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\scanstate\scanstate.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    scanstate.c

Abstract:

    Implements the app layer of the v1 compatibility app.

Author:

    Jim Schmidt (jimschm) 14-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "modules.h"
#include "trans.h"
#include "v2app.h"
#include <lm.h>
#ifdef DEBUG
#include <shellapi.h>
#endif
#include "logmsg.h"
#include "common.h"

#define DBG_SCANSTATE       "ScanState"

//
// Strings
//

// None

//
// Constants
//

#define LOG_VERBOSE_BIT  0x01
#define LOG_UNUSED_BIT   0x02   // for v1 compatibility, do not use
#define LOG_STATUS_BIT   0x04
#define LOG_DEBUGGER_BIT 0x08
#define LOG_UPDATE_BIT   0x10

#define SCANSTATE_SAVE      0x00000001
#define SCANSTATE_COMPLETED 0x00000002

#define RETURN_SUCCESS          0
#define RETURN_FATAL_ERROR      1
#define RETURN_ERROR            2
#define RETURN_IGNORED_ERROR    3

//
// Macros
//

// None

//
// Types
//

typedef NET_API_STATUS(WINAPI NETWKSTAGETINFO)(PWSTR, DWORD, PBYTE *);
typedef NETWKSTAGETINFO *PNETWKSTAGETINFO;

typedef NET_API_STATUS(WINAPI NETAPIBUFFERFREE)(PVOID);
typedef NETAPIBUFFERFREE *PNETAPIBUFFERFREE;

//
// Globals
//

BOOL g_OverwriteImage = FALSE;
BOOL g_ContinueOnError = FALSE;
DWORD g_ReturnCode = RETURN_SUCCESS;
TCHAR g_JournalPath[MAX_PATH_PLUS_NUL];
BOOL g_Break;
BOOL g_TestMode;

//
// Macro expansion list
//

#define REQUIRED_INFS       \
        DEFMAC(OSFILES,     TEXT("USMTDef.inf"))  \

//
// Private function prototypes
//

#ifdef PRERELEASE
MESSAGECALLBACK pSaveMsgCallback;
#endif

//
// Macro expansion definition
//

//
// This is the structure used for required infs
//
typedef struct {
    PCTSTR InfId;
    PCTSTR InfName;
} REQUIREDINF_STRUCT, *PREQUIREDINF_STRUCT;

//
// Declare a global array of required infs
//
#define DEFMAC(infid,infname) {TEXT(#infid),infname},
static REQUIREDINF_STRUCT g_RequiredInfs[] = {
                              REQUIRED_INFS
                              {NULL, NULL}
                              };
#undef DEFMAC

//
// Code
//

VOID
pHelpAndExit (
    VOID
    )
{
    PrintMsgOnConsole (MSG_HELP);

#ifdef PRERELEASE
    printf ("\nAdditional PRERELEASE options:\n\n"
            "/tf            Uses full transport instead of v1 transport\n"
            "/tc            Enable compression\n"
            "/ta            Enable automatic capability (for homenet transport)\n"
            "/ti:<tag>      Specify an identity tag for the homenet transport\n"
            "               Default is user name\n"
            "/t:<name>      Specifies transport to use\n"
            );
#endif

    TerminateAppCommon();
    UtTerminate ();
    exit (1);
}


VOID
pCleanUpApp (
    VOID
    )
{
    IsmTerminate();

    if (g_JournalPath[0]) {
        DeleteFile (g_JournalPath);
        g_JournalPath[0] = 0;
    }
}


BOOL
WINAPI
CtrlCRoutine (
    IN      DWORD ControlSignal
    )
{
    PrintMsgOnConsole (MSG_EXITING);

    LOG ((LOG_WARNING, (PCSTR) MSG_TOOL_STOPPED));

    g_Break = TRUE;

    IsmSetCancel();
    while (IsmCurrentlyExecuting()) {
        Sleep (1000);
    }

    pCleanUpApp();

    printf ("\n");
    exit (1);
}


ULONG_PTR
pSaveMsgCallback (
    UINT Message,
    ULONG_PTR Arg
    )
{
    PTRANSCOPY_ERROR transCopyError;
#ifdef PRERELEASE
    PRMEDIA_EXTRADATA extraData;
#endif

    switch (Message) {

    case TRANSPORTMESSAGE_IMAGE_EXISTS:
        return g_OverwriteImage;

    case TRANSPORTMESSAGE_SRC_COPY_ERROR:
        transCopyError = (PTRANSCOPY_ERROR) Arg;
        if (transCopyError) {
            if (StringIMatch (transCopyError->ObjectType, TEXT("File"))) {
                if ((transCopyError->Error == ERROR_FILE_NOT_FOUND) ||
                    (transCopyError->Error == ERROR_PATH_NOT_FOUND) ||
                    (transCopyError->Error == ERROR_ACCESS_DENIED)  ||
                    (transCopyError->Error == ERROR_INVALID_NAME)
                    ) {
                    return APPRESPONSE_IGNORE;
                }
                if ((transCopyError->Error == ERROR_FILENAME_EXCED_RANGE) && g_ContinueOnError) {
                    return APPRESPONSE_IGNORE;
                }
            }
        }
        return APPRESPONSE_FAIL;

#ifdef PRERELEASE
    case TRANSPORTMESSAGE_RMEDIA_SAVE:
        extraData = (PRMEDIA_EXTRADATA) Arg;
        if (!extraData) {
            return (MessageBox (
                        NULL,
                        TEXT("Please insert the next media in your drive."),
                        TEXT("ScanState"),
                        MB_OKCANCEL
                        ) == IDOK);
        }
        if (extraData->MediaNumber == 1) {
            switch (extraData->LastError) {
            case RMEDIA_ERR_NOERROR:
                return TRUE;
            case RMEDIA_ERR_WRONGMEDIA:
                return (MessageBox (
                            NULL,
                            TEXT("You have inserted the wrong media.\n\nPlease insert the first media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_DISKFULL:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted does not have enough free space.\n\nPlease insert the first media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_WRITEPROTECT:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted is write protected.\n\nPlease insert the first media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_NOTREADY:
                return (MessageBox (
                            NULL,
                            TEXT("The drive is not ready for use. Please check the drive and make sure that a disk is inserted and that the drive door is closed."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_CRITICAL:
                return FALSE;
            default:
                return (MessageBox (
                            NULL,
                            TEXT("Your media is toast.\n\nPlease insert the first media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            }
        } else {
            switch (extraData->LastError) {
            case RMEDIA_ERR_NOERROR:
                return TRUE;
            case RMEDIA_ERR_WRONGMEDIA:
                return (MessageBox (
                            NULL,
                            TEXT("You have inserted the wrong media.\n\nPlease insert the next media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_DISKFULL:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted does not have enough free space.\n\nPlease insert the next media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_WRITEPROTECT:
                return (MessageBox (
                            NULL,
                            TEXT("The media you inserted is write protected.\n\nPlease insert the next media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_NOTREADY:
                return (MessageBox (
                            NULL,
                            TEXT("The drive is not ready for use. Please check the drive and make sure that a disk is inserted and that the drive door is closed."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            case RMEDIA_ERR_CRITICAL:
                return FALSE;
            default:
                return (MessageBox (
                            NULL,
                            TEXT("Your media is toast.\n\nPlease insert the next media in your drive."),
                            TEXT("ScanState"),
                            MB_OKCANCEL
                            ) == IDOK);
            }
        }
#endif
    }
    return FALSE;
}

VOID
pMyLogCallback (
    IN      PLOGARG LogArg
    )
{
    if (LogArg->Debug) {
        DEBUGDIRECT (LogArg->Type, LogArg->FormattedMessage);
    } else {
        if (StringIMatchA (LogArg->Type, LOG_ERROR)) {
            if (g_ReturnCode == RETURN_SUCCESS) {
                g_ReturnCode = g_ContinueOnError?RETURN_IGNORED_ERROR:RETURN_ERROR;
            }
            if (g_ReturnCode == RETURN_IGNORED_ERROR) {
                g_ReturnCode = g_ContinueOnError?RETURN_IGNORED_ERROR:RETURN_ERROR;
            }
            if (!g_ContinueOnError) {
                IsmSetCancel();
            }
        } else if (StringIMatchA (LogArg->Type, LOG_FATAL_ERROR) ||
                   StringIMatchA (LogArg->Type, LOG_MODULE_ERROR)) {
            g_ReturnCode = RETURN_FATAL_ERROR;
        }
        LOGDIRECT (LogArg->Type, LogArg->FormattedMessage);
    }
}

#ifdef DEBUG
VOID
pStopAndDisplayInfs (
    IN      PGROWBUFFER InputInfs,
    IN      BOOL Begin
    )
{
    MULTISZ_ENUM infEnum;

    if (MessageBox (
            NULL,
            TEXT("ScanState stopped. Do you want to display all loaded INFs?"),
            Begin?TEXT("ScanState-Begin"):TEXT("ScanState-End"),
            MB_YESNO
            ) == IDYES) {
        //
        // now let's open append all INF files and pass the HINF to
        // everybody.
        //
        if (EnumFirstMultiSz (&infEnum, (PCTSTR)InputInfs->Buf)) {
            do {
                ShellExecute (NULL, TEXT("open"), infEnum.CurrentString, NULL, NULL, SW_SHOWNORMAL);
            } while (EnumNextMultiSz (&infEnum));
        }
        MessageBox (NULL, TEXT("Press OK to continue..."), TEXT("ScanState-Begin"), MB_OK);
    }
}
#endif


BOOL
pIsIE4Installed (
    VOID
    )
{
    LONG hResult;
    REGSAM prevMode;
    HKEY ieKey = NULL;
    DWORD valueType = REG_SZ;
    DWORD valueSize = 0;
    PTSTR valueData = NULL;
    PTSTR numPtr = NULL;
    PTSTR dotPtr = NULL;
    INT major = 0;
    INT minor = 0;
    TCHAR saved;
    BOOL result = FALSE;

    prevMode = SetRegOpenAccessMode (KEY_READ);

    ieKey = OpenRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\Internet Explorer"));

    SetRegOpenAccessMode (prevMode);

    if (ieKey) {
        hResult = RegQueryValueEx (ieKey, TEXT("Version"), NULL, &valueType, NULL, &valueSize);
        if ((hResult == ERROR_SUCCESS) || (hResult == ERROR_MORE_DATA)) {
            valueData = (PTSTR)HeapAlloc (GetProcessHeap (), 0, valueSize * 2);
            if (valueData) {
                hResult = RegQueryValueEx (ieKey, TEXT("Version"), NULL, &valueType, (PBYTE)valueData, &valueSize);
                if ((hResult == ERROR_SUCCESS) && (valueType == REG_SZ)) {
                    // let's see if it the version is the correct one
                    numPtr = valueData;
                    dotPtr = _tcschr (numPtr, TEXT('.'));
                    if (dotPtr) {
                        saved = *dotPtr;
                        *dotPtr = 0;
                        major = _ttoi (numPtr);
                        *dotPtr = saved;
                    } else {
                        major = _ttoi (numPtr);
                    }
                    if (dotPtr) {
                        numPtr = _tcsinc (dotPtr);
                        dotPtr = _tcschr (numPtr, TEXT('.'));
                        if (dotPtr) {
                            saved = *dotPtr;
                            *dotPtr = 0;
                            minor = _ttoi (numPtr);
                            *dotPtr = saved;
                        } else {
                            minor = _ttoi (numPtr);
                        }
                    }
                    if ((major >= 5) ||
                        ((major == 4) && (minor >= 71))
                        ) {
                        result = TRUE;
                    }
                }
                HeapFree (GetProcessHeap (), 0, valueData);
                valueData = NULL;
            }
        }
        CloseRegKey (ieKey);
    }
    return result;
}

BOOL
pCheckSystemRequirements (
    VOID
    )
{
    HKEY domainLogonKey;
    PDWORD data;
    BOOL result = TRUE;
    TCHAR userName[MAX_USER_NAME];
    DWORD size;
    NET_API_STATUS rc;
    PWKSTA_INFO_102 buffer;
    HANDLE netApi32Lib;
    PNETWKSTAGETINFO netWkstaGetInfo;
    PNETAPIBUFFERFREE netApiBufferFree;
    BYTE sid[256];
    DWORD sidSize = 256;
    WCHAR domain[256];
    DWORD domainSize = 256;
    SID_NAME_USE use;

    if (!ISNT()) {
        //
        // Require the Log On To Domain setting to be checked
        //

        SetLastError (ERROR_SUCCESS);

        domainLogonKey = OpenRegKeyStr (TEXT("HKLM\\Network\\Logon"));
        if (!domainLogonKey) {
            LOG ((LOG_ERROR, (PCSTR) MSG_NETWORK_LOGON_KEY));
            return FALSE;
        }

        data = (PDWORD) GetRegValueBinary (domainLogonKey, TEXT("LMLogon"));
        if (!data) {
            data = (PDWORD) GetRegValueDword (domainLogonKey, TEXT("LMLogon"));
            if (!data) {
                LOG ((LOG_ERROR, (PCSTR) MSG_NETWORK_LMLOGON_KEY));
                result = FALSE;
            } else {
                if (!(*data)) {
                    LOG ((LOG_ERROR, (PCSTR) MSG_NO_DOMAIN_LOGON));
                    result = FALSE;
                }
                FreeAlloc (data);
            }
        } else {
            if (!(*data)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_NO_DOMAIN_LOGON));
                result = FALSE;
            }
            FreeAlloc (data);
        }

        CloseRegKey (domainLogonKey);

    } else {
        //
        // Require domain membership
        //

        netApi32Lib = LoadLibrary (TEXT("netapi32.dll"));
        if (netApi32Lib) {
            netWkstaGetInfo = (PNETWKSTAGETINFO) GetProcAddress (netApi32Lib, "NetWkstaGetInfo");
            netApiBufferFree = (PNETAPIBUFFERFREE) GetProcAddress (netApi32Lib, "NetApiBufferFree");
        } else {
            netWkstaGetInfo = NULL;
            netApiBufferFree = NULL;
        }

        if (!netWkstaGetInfo || !netApiBufferFree) {
            LOG ((LOG_ERROR, (PCSTR) MSG_CANT_LOAD_NETAPI32));
            result = FALSE;
        } else {

            rc = netWkstaGetInfo (NULL, 102, (PBYTE *) &buffer);

            if (rc == NO_ERROR) {
                result = buffer->wki102_langroup && (buffer->wki102_langroup[0] != 0);
                if (result) {
                    DEBUGMSGW ((DBG_SCANSTATE, "Getting account type of %s", buffer->wki102_langroup));

                    sidSize = ARRAYSIZE(sid);
                    domainSize = ARRAYSIZE(domain);

                    result = LookupAccountNameW (
                                    NULL,
                                    buffer->wki102_langroup,
                                    sid,
                                    &sidSize,
                                    domain,
                                    &domainSize,
                                    &use
                                    );
                    DEBUGMSG ((DBG_SCANSTATE, "Account type result is %u (use=%u)", result, use));

                    LOG_IF ((!result, LOG_ERROR, (PCSTR) MSG_NOT_JOINED_TO_DOMAIN));

                }
                ELSE_DEBUGMSG ((DBG_SCANSTATE, "No langroup specified"));

                netApiBufferFree (buffer);
            } else {
                LOG ((LOG_ERROR, (PCSTR) MSG_CANT_GET_WORKSTATION_PROPS));
                result = FALSE;
            }
        }

        if (netApi32Lib) {
            FreeLibrary (netApi32Lib);
        }
    }

    // let's check to see if IE4 is installed on this machine
    if (result && !pIsIE4Installed ()) {
        LOG ((LOG_ERROR, (PCSTR) MSG_NEED_IE4));
        return FALSE;
    }

    //
    // Make sure a user name is specified
    //

    if (result) {
        size = ARRAYSIZE(userName);
        if (!GetUserName (userName, &size)) {
            result = FALSE;
        } else if (*userName == 0) {
            result = FALSE;
        }

        LOG_IF ((!result, LOG_ERROR, (PCSTR) MSG_LOGGED_ON_USER_REQUIRED));
    }

    return result;
}


VOID
__cdecl
_tmain (
    IN      INT Argc,
    IN      PCTSTR Argv[]
    )
{
    TCHAR appPath[MAX_PATH_PLUS_NUL];
    TCHAR ismPath[MAX_PATH_PLUS_NUL];
    PCTSTR commandLine = NULL;
    PTSTR p;
    MIG_TRANSPORTID transportId;
    MIG_TRANSPORTSTORAGEID transportStorageId;
    MULTISZ_ENUM infEnum;
    HINF infHandle = INVALID_HANDLE_VALUE;
    ENVENTRY_STRUCT infHandleStruct;
    INT numInfs = 0;
    PTSTR buffer;
    MULTISZ_ENUM e;
    DWORD appStatus;
    BOOL skipExecute = FALSE;
    BOOL storagePathIsValid = FALSE;
    BOOL imageExists = FALSE;
    BOOL terminateIsm = FALSE;
    BOOL logEnabled = FALSE;
    PCTSTR msg;
#ifdef UNICODE
    PCSTR ansimsg;
#endif
    PCTSTR argArray[1];
    TOOLARGS args;
    BOOL fail;

    ZeroMemory (&args, sizeof (args));

    SET_RESETLOG();
    UtInitialize (NULL);
    InitAppCommon();

    SuppressAllLogPopups (TRUE);

    // this part is for matching thread's locale to the console code page
    CallSetThreadUILanguage ();

    PrintMsgOnConsole (MSG_RUNNING);

    // initialize app journal path
    g_JournalPath[0] = 0;
    if (GetWindowsDirectory (g_JournalPath, ARRAYSIZE (g_JournalPath))) {
        StringCopy (AppendWack (g_JournalPath), TEXT("SCANSTATE.JRN"));
    }

    GetModuleFileName (NULL, appPath, ARRAYSIZE(appPath));
    p = _tcsrchr (appPath, TEXT('\\'));
    if (p) {
        *p = 0;
    }

    //
    // Parse the command line
    //

    fail = TRUE;

    switch (ParseToolCmdLine (TRUE, &args, Argc, Argv)) {

    case PARSE_SUCCESS:
        fail = FALSE;
        break;

    case PARSE_MULTI_LOG:
        PrintMsgOnConsole (MSG_MULTI_LOG);
        g_ReturnCode = RETURN_FATAL_ERROR;
        goto END;

    case PARSE_BAD_LOG:
        argArray[0] = args.LogFile;
        msg = ParseMessageID (MSG_CANT_OPEN_LOG, argArray);
        if (msg) {
#ifdef UNICODE
            ansimsg = ConvertWtoA (msg);
            printf ("%s", ansimsg);
            FreeConvertedStr (ansimsg);
#else
            printf ("%s", msg);
#endif
            FreeStringResource (msg);
        }

        g_ReturnCode = RETURN_FATAL_ERROR;
        goto END;

    default:
        break;
    }

    if (fail) {
        pHelpAndExit();
    }

    g_TestMode = args.TestMode;
    g_OverwriteImage = args.OverwriteImage;
    g_ContinueOnError = args.ContinueOnError;

#ifdef DEBUG
    {
        if (DoesFileExist (TEXT("C:\\SCANSTATE.BEGIN"))) {
            pStopAndDisplayInfs (&args.InputInf, TRUE);
        }
    }
#endif

    LogReInit (NULL, NULL, (args.LogFile ? args.LogFile : TEXT("scanstate.log")), NULL);
    logEnabled = TRUE;

    // Let's log the command line that was used
    commandLine = GetCommandLine ();
    if (commandLine) {
        LOG ((LOG_INFORMATION, (PCSTR)MSG_COMMAND_LINE_USED, commandLine));
    }

    //
    // Check requirements
    //

    if (args.BadInfs.End || args.MultiInfs.End) {
        SetLastError (ERROR_BAD_COMMAND);

        if (EnumFirstMultiSz (&e, (PCTSTR) args.BadInfs.Buf)) {
            do {
                LOG ((LOG_ERROR, (PCSTR) MSG_INF_FILE_NOT_FOUND, e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }

        if (EnumFirstMultiSz (&e, (PCTSTR) args.MultiInfs.Buf)) {
            do {
                LOG ((LOG_ERROR, (PCSTR) MSG_INF_SPECIFIED_MORE_THAN_ONE, e.CurrentString));
            } while (EnumNextMultiSz (&e));
        }

        g_ReturnCode = RETURN_FATAL_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CMD_LINE_ERROR));
        goto END;
    }

    if (!GetFilePath (TEXT("migism.inf"), ismPath, ARRAYSIZE(ismPath))) {
        g_ReturnCode = RETURN_FATAL_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_ISM_INF_MISSING));
        goto END;
    }

    if (!g_TestMode) {
        if (!pCheckSystemRequirements()) {
            g_ReturnCode = RETURN_FATAL_ERROR;
            goto END;
        }
    }

    //
    // Initialize ISM
    //

    if (!IsmInitialize (ismPath, pSaveMsgCallback, pMyLogCallback)) {
        g_ReturnCode = RETURN_FATAL_ERROR;
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_ISM));
        goto END;
    }

    terminateIsm = TRUE;
    SetLogVerbosity (args.VerboseLevel);

    SetConsoleCtrlHandler (CtrlCRoutine, TRUE);

    IsmSetPlatform (PLATFORM_SOURCE);

    // upload environment variables
    UploadEnvVars (PLATFORM_SOURCE);

    infHandle = InitRequiredInfs (appPath, (PCSTR) MSG_CANT_OPEN_REQUIRED_FILE);

    if (args.InputInf.Buf) {
        IsmSetEnvironmentData (
            PLATFORM_SOURCE,
            NULL,
            S_INF_FILE_MULTISZ,
            args.InputInf.Buf,
            (WORD) args.InputInf.End
            );

        //
        // now let's open append all INF files and pass the HINF to
        // everybody.
        //
        if (EnumFirstMultiSz (&infEnum, (PCTSTR)args.InputInf.Buf)) {
            buffer = DuplicateTextEx (NULL, S_INF_OBJECT_NAME, 2, &p);  // Up to 2 digits of numbers
            do {
                if (infHandle == INVALID_HANDLE_VALUE) {
                    infHandle = SetupOpenInfFile (infEnum.CurrentString, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
                    if (infHandle == INVALID_HANDLE_VALUE) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_FILE, infEnum.CurrentString));
                    }
                } else {
                    if (!SetupOpenAppendInfFile (infEnum.CurrentString, infHandle, NULL)) {
                        LOG ((LOG_ERROR, (PCSTR) MSG_CANT_OPEN_FILE, infEnum.CurrentString));
                    }
                }

                // Save Inf for right side use
                if (numInfs < 100) {
                   numInfs++;
                   _stprintf(p, TEXT("%d"), numInfs);
                   IsmAddControlFile (buffer, infEnum.CurrentString);
                }
            } while (EnumNextMultiSz (&infEnum));
            FreeText (buffer);
        }
    }

    if (infHandle != INVALID_HANDLE_VALUE) {
        infHandleStruct.Type = ENVENTRY_BINARY;
        infHandleStruct.EnvBinaryData = (PVOID)(&infHandle);
        infHandleStruct.EnvBinaryDataSize = sizeof (HINF);
        IsmSetEnvironmentValue (PLATFORM_SOURCE, NULL, S_GLOBAL_INF_HANDLE, &infHandleStruct);
    }

    if (args.UserOn) {
        IsmSetEnvironmentFlag (PLATFORM_SOURCE, NULL, S_ENV_HKCU_V1);
        IsmSetEnvironmentFlag (PLATFORM_SOURCE, NULL, S_ENV_HKCU_ON);
    }

    if (args.FilesOn) {
        IsmSetEnvironmentFlag (PLATFORM_SOURCE, NULL, S_ENV_ALL_FILES);
    }

    //
    // Start ETM modules
    //

    if (!IsmStartEtmModules ()) {
        if (!IsmCheckCancel()) {
            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_START_ETMS));
        }
        goto END;
    }

    //
    // Initialize transport
    //

    if (!IsmStartTransport ()) {
        if (!IsmCheckCancel()) {
            LOG ((LOG_FATAL_ERROR, "Can't start the transport."));
        }
        goto END;
    }

    transportStorageId = IsmRegisterTransport (args.TransportName);

    if (args.FullTransport) {
        transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_FULL, args.Capabilities);
    } else {
        transportId = IsmSelectTransport (transportStorageId, TRANSPORTTYPE_LIGHT, args.Capabilities);
    }

    if (!args.TransportNameSpecified) {
        BfCreateDirectory (args.StoragePath);
    }

    if (!transportId) {
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_TRANSPORT_UNAVAILABLE));
        goto END;
    }

#ifdef PRERELEASE

    IsmSetEnvironmentString (PLATFORM_SOURCE, NULL, TRANSPORT_ENVVAR_HOMENET_TAG, args.Tag);

#endif

    if (!IsmSetTransportStorage (
            PLATFORM_SOURCE,
            transportId,
            transportStorageId,
            args.Capabilities,
            args.StoragePath,
            &storagePathIsValid,
            &imageExists
            ) || storagePathIsValid == FALSE
            ) {

        if (!IsmCheckCancel()) {
            LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_TRANSPORT_STORAGE_INVALID, args.StoragePath));
        }

        goto END;
    }

#ifdef PRERELEASE
    if (args.Capabilities & CAPABILITY_AUTOMATED) {
        if (!imageExists) {
            LOG ((
                LOG_FATAL_ERROR,
                "Can't select %s as the transport; need to run loadstate first.",
                args.TransportName
                ));
            goto END;
        }
    }
#endif

    appStatus = ReadAppStatus (g_JournalPath);

    if (appStatus == SCANSTATE_SAVE) {
        skipExecute = IsmResumeSave ();
    }

    if (!skipExecute) {

        //
        // Execute the preparsing to populate the components
        //

        if (IsmExecute (args.FullTransport?EXECUTETYPE_EXECUTESOURCE_PARSING:EXECUTETYPE_VIRTUALCOMPUTER_PARSING)) {

            IsmSelectMasterGroup (MASTERGROUP_ALL, TRUE);

            if (!args.SystemOn) {
                IsmSelectMasterGroup (MASTERGROUP_SYSTEM, FALSE);
                IsmSelectMasterGroup (MASTERGROUP_USER, FALSE);
                IsmSelectMasterGroup (MASTERGROUP_APP, FALSE);
            }

            SelectComponentsViaInf (infHandle);

            //
            // Enumerate the system, gather data and analyze
            //

            if (IsmExecute (args.FullTransport?EXECUTETYPE_EXECUTESOURCE:EXECUTETYPE_VIRTUALCOMPUTER)) {
                //
                // Display report
                //

                //
                // Save the state
                //

                // write the app status
                WriteAppStatus (g_JournalPath, SCANSTATE_SAVE);

                // before we save, let's see if we wanted to change the user name and/or domain
                if (args.NewDomainName) {
                    IsmSetEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, TEXT("ALTUSERDOMAIN"), args.NewDomainName);
                }
                if (args.NewUserName) {
                    IsmSetEnvironmentString (PLATFORM_SOURCE, S_SYSENVVAR_GROUP, TEXT("ALTUSERNAME"), args.NewUserName);
                }

                if (!IsmSave ()) {
                    if (!IsmCheckCancel()) {
                        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_SAVE));
                    }
                }

                // write the app status
                WriteAppStatus (g_JournalPath, SCANSTATE_COMPLETED);

            } else {
                if (!IsmCheckCancel()) {
                    LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_SOURCE));
                }
            }

        } else {
            if (!IsmCheckCancel()) {
                LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_CANT_EXECUTE_SOURCE));
            }
        }
    }

    //
    // We're done!
    //

    SetupCloseInfFile (infHandle);

#ifdef DEBUG
    {
        if (DoesFileExist (TEXT("C:\\SCANSTATE.END"))) {
            pStopAndDisplayInfs (&args.InputInf, FALSE);
        }
    }
#endif


END:
    if (terminateIsm) {
        if (!g_Break) {
            pCleanUpApp();
        }
    }

    GbFree (&args.BadInfs);
    GbFree (&args.MultiInfs);
    GbFree (&args.InputInf);

    if (!g_Break) {
        if (g_ReturnCode == RETURN_SUCCESS) {
            PrintMsgOnConsole (MSG_SUCCESS);
        } else if (g_ReturnCode == RETURN_IGNORED_ERROR) {
            if (logEnabled) {
                PrintMsgOnConsole (MSG_IGNORE_FAILED_WITH_LOG);
            } else {
                PrintMsgOnConsole (MSG_IGNORE_FAILED_NO_LOG);
            }
            g_ReturnCode = RETURN_SUCCESS;
        } else {
            if (logEnabled) {
                PrintMsgOnConsole (MSG_FAILED_WITH_LOG);
            } else {
                PrintMsgOnConsole (MSG_FAILED_NO_LOG);
            }
        }
    }

    TerminateAppCommon();
    UtTerminate ();

    while (g_Break) {
        // infinite loop, because we'll get terminated in the ctrl+c handler
        Sleep (50);
    }

    exit (g_ReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\app\scanstate\sources.inc ===
!include ..\..\app.mk

MINORCOMP=scanstate

# compiler options
USE_MSVCRT=1

SOURCES=\
    ..\scanstate.c      \
    ..\scanstate.rc     \
    ..\logmsg.mc        \

# extra libs
TARGETLIBS= $(TARGETLIBS)                           \
            $(COBRA_ROOT)\lib\$(O)\utils.lib        \
            $(COBRA_ROOT)\bin\$(O)\migism.lib       \

PRECOMPILED_INCLUDE=..\pch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\attrib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    attrib.c

Abstract:

    Implements the attribute interface for the ISM.  Attributes are caller-defined
    flags that are associated with objects, for purposes of understanding and
    organizing state.

Author:

    Jim Schmidt (jimschm) 01-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_ATTRIB      "Attrib"

//
// Strings
//

#define S_PERSISTENT_ATTRIBUTE          TEXT("$PERSISTENT")
#define S_APPLY_ATTRIBUTE               TEXT("$APPLY")
#define S_ABANDONED_ATTRIBUTE           TEXT("$ABANDONED")
#define S_NONCRITICAL_ATTRIBUTE         TEXT("$NONCRITICAL")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PUINT LinkageList;
    UINT Count;
    UINT Index;
} OBJECTATTRIBUTE_HANDLE, *POBJECTATTRIBUTE_HANDLE;

typedef struct {
    PUINT LinkageList;
    UINT Count;
    UINT Index;
    PCTSTR ObjectFromMemdb;
} OBJECTWITHATTRIBUTE_HANDLE, *POBJECTWITHATTRIBUTE_HANDLE;

//
// Globals
//

MIG_ATTRIBUTEID g_PersistentAttributeId = 0;
MIG_ATTRIBUTEID g_ApplyAttributeId = 0;
MIG_ATTRIBUTEID g_AbandonedAttributeId = 0;
MIG_ATTRIBUTEID g_NonCriticalAttributeId = 0;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

PCTSTR
pGetAttributeNameForDebugMsg (
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    static TCHAR name[256];

    if (!IsmGetAttributeName (AttributeId, name, ARRAYSIZE(name), NULL, NULL, NULL)) {
        StringCopy (name, TEXT("<invalid attribute>"));
    }

    return name;
}


PCTSTR
pAttributePathFromId (
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    return MemDbGetKeyFromHandle ((UINT) AttributeId, 0);
}


PCTSTR
pAttributePathFromName (
    IN      PCTSTR AttributeName
    )
{
    return JoinPaths (TEXT("Attrib"), AttributeName);
}


MIG_ATTRIBUTEID
IsmRegisterAttribute (
    IN      PCTSTR AttributeName,
    IN      BOOL Private
    )

/*++

Routine Description:

  IsmRegisterAttribute creates a public or private attribute and returns the
  ID to the caller. If the attribute already exists, then the existing ID is
  returned to the caller.

Arguments:

  AttribName    - Specifies the attribute name to register.
  Private       - Specifies TRUE if the attribute is owned by the calling module
                  only, or FALSE if it is shared by all modules. If TRUE is
                  specified, the caller must be in an ISM callback function.

Return Value:

  The ID of the attribute, or 0 if the registration failed.

--*/

{
    PCTSTR attribPath;
    PCTSTR decoratedName;
    UINT offset;

    if (!g_CurrentGroup && Private) {
        DEBUGMSG ((DBG_ERROR, "IsmRegisterAttribute called for private attribute outside of ISM-managed context"));
        return 0;
    }

    if (!IsValidCNameWithDots (AttributeName)) {
        DEBUGMSG ((DBG_ERROR, "attribute name \"%s\" is illegal", AttributeName));
        return 0;
    }

#ifdef DEBUG
    if (Private && !IsValidCName (g_CurrentGroup)) {
        DEBUGMSG ((DBG_ERROR, "group name \"%s\" is illegal", g_CurrentGroup));
        return 0;
    }
#endif

    if (Private) {
        decoratedName = JoinTextEx (NULL, g_CurrentGroup, AttributeName, TEXT(":"), 0, NULL);
    } else {
        decoratedName = JoinTextEx (NULL, S_COMMON, AttributeName, TEXT(":"), 0, NULL);
    }
    attribPath = pAttributePathFromName (decoratedName);
    FreeText (decoratedName);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        FreePathString (attribPath);
        return 0;
    }

    offset = MemDbSetKey (attribPath);

    FreePathString (attribPath);

    if (!offset) {
        EngineError ();
        return 0;
    }

    return (MIG_ATTRIBUTEID) offset;
}


BOOL
RegisterInternalAttributes (
    VOID
    )
{
    PCTSTR attribPath;
    PCTSTR decoratedName;
    UINT offset;

    decoratedName = JoinTextEx (NULL, S_COMMON, S_PERSISTENT_ATTRIBUTE, TEXT(":"), 0, NULL);
    attribPath = pAttributePathFromName (decoratedName);
    FreeText (decoratedName);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        FreePathString (attribPath);
        return 0;
    }

    offset = MemDbSetKey (attribPath);

    FreePathString (attribPath);

    if (!offset) {
        EngineError ();
        return FALSE;
    }

    g_PersistentAttributeId = (MIG_ATTRIBUTEID) offset;

    decoratedName = JoinTextEx (NULL, S_COMMON, S_APPLY_ATTRIBUTE, TEXT(":"), 0, NULL);
    attribPath = pAttributePathFromName (decoratedName);
    FreeText (decoratedName);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        FreePathString (attribPath);
        return 0;
    }

    offset = MemDbSetKey (attribPath);

    FreePathString (attribPath);

    if (!offset) {
        EngineError ();
        return FALSE;
    }

    g_ApplyAttributeId = (MIG_ATTRIBUTEID) offset;

    decoratedName = JoinTextEx (NULL, S_COMMON, S_ABANDONED_ATTRIBUTE, TEXT(":"), 0, NULL);
    attribPath = pAttributePathFromName (decoratedName);
    FreeText (decoratedName);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        FreePathString (attribPath);
        return 0;
    }

    offset = MemDbSetKey (attribPath);

    FreePathString (attribPath);

    if (!offset) {
        EngineError ();
        return FALSE;
    }

    g_AbandonedAttributeId = (MIG_ATTRIBUTEID) offset;

    decoratedName = JoinTextEx (NULL, S_COMMON, S_NONCRITICAL_ATTRIBUTE, TEXT(":"), 0, NULL);
    attribPath = pAttributePathFromName (decoratedName);
    FreeText (decoratedName);

    if (!MarkGroupIds (attribPath)) {
        DEBUGMSG ((
            DBG_ERROR,
            "%s conflicts with previously registered attribute",
            attribPath
            ));
        FreePathString (attribPath);
        return 0;
    }

    offset = MemDbSetKey (attribPath);

    FreePathString (attribPath);

    if (!offset) {
        EngineError ();
        return FALSE;
    }

    g_NonCriticalAttributeId = (MIG_ATTRIBUTEID) offset;

    return TRUE;
}


BOOL
IsmGetAttributeName (
    IN      MIG_ATTRIBUTEID AttributeId,
    OUT     PTSTR AttributeName,            OPTIONAL
    IN      UINT AttributeNameBufChars,
    OUT     PBOOL Private,                  OPTIONAL
    OUT     PBOOL BelongsToMe,              OPTIONAL
    OUT     PUINT ObjectReferences          OPTIONAL
    )

/*++

Routine Description:

  IsmGetAttributeName obtains the attribute text name from a numeric ID. It
  also identifies private and owned attributes.

Arguments:

  AttributeId           - Specifies the attribute ID to look up.
  AttributeName         - Receives the attribute name. The name is filled for
                          all valid AttributeId values, even when the return
                          value is FALSE.
  AttributeNameBufChars - Specifies the number of TCHARs that AttributeName
                          can hold, including the nul terminator.
  Private               - Receives TRUE if the attribute is private, or FALSE
                          if it is public.
  BelongsToMe           - Receives TRUE if the attribute is private and
                          belongs to the caller, FALSE otherwise.
  ObjectReferences      - Receives the number of objects that reference the
                          attribute


Return Value:

  TRUE if the attribute is public, or if the attribute is private and belongs to
  the caller.

  FALSE if the attribute is private and belongs to someone else. AttributeName,
  Private and BelongsToMe are valid in this case.

  FALSE if AttributeId is not valid. Attributename, Private and BelongsToMe are
  not modified in this case.  Do not use this function to test if AttributeId
  is valid or not.

--*/


  {
    PCTSTR attribPath = NULL;
    PCTSTR start;
    PTSTR p, q;
    BOOL privateAttribute = FALSE;
    BOOL groupMatch = FALSE;
    BOOL result = FALSE;
    UINT references;
    PUINT linkageList;

    __try {
        //
        // Get the attribute path from memdb, then parse it for group and name
        //

        attribPath = pAttributePathFromId (AttributeId);
        if (!attribPath) {
            __leave;
        }

        p = _tcschr (attribPath, TEXT('\\'));
        if (!p) {
            __leave;
        }

        start = _tcsinc (p);
        p = _tcschr (start, TEXT(':'));

        if (!p) {
            __leave;
        }

        q = _tcsinc (p);
        *p = 0;

        if (StringIMatch (start, S_COMMON)) {

            //
            // This attribute is a global attribute.
            //

            privateAttribute = FALSE;
            groupMatch = TRUE;

        } else if (g_CurrentGroup) {

            //
            // This attribute is private. Check if it is ours.
            //

            privateAttribute = TRUE;

            if (StringIMatch (start, g_CurrentGroup)) {
                groupMatch = TRUE;
            } else {
                groupMatch = FALSE;
            }
        } else {

            //
            // This is a private attribute, but the caller is not
            // a module that can own attributes.
            //

            DEBUGMSG ((DBG_WARNING, "IsmGetAttributeName: Caller cannot own private attributes"));
        }

        //
        // Copy the name to the buffer, update outbound BOOLs, set result
        //

        if (AttributeName && AttributeNameBufChars >= sizeof (TCHAR)) {
            StringCopyByteCount (AttributeName, q, AttributeNameBufChars * sizeof (TCHAR));
        }

        if (Private) {
            *Private = privateAttribute;
        }

        if (BelongsToMe) {
            *BelongsToMe = privateAttribute && groupMatch;
        }

        if (ObjectReferences) {
            linkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                AttributeId,
                                ATTRIBUTE_INDEX,
                                &references
                                );

            references /= SIZEOF(KEYHANDLE);

            if (linkageList) {
                MemDbReleaseMemory (linkageList);
                INVALID_POINTER (linkageList);
            } else {
                references = 0;
            }

            *ObjectReferences = references;
        }

        if (groupMatch) {
            result = TRUE;
        }
    }
    __finally {
        if (attribPath) {       //lint !e774
            MemDbReleaseMemory (attribPath);
            attribPath = NULL;
        }
    }
    return result;
}


MIG_ATTRIBUTEID
IsmGetAttributeGroup (
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    return (MIG_ATTRIBUTEID) GetGroupOfId ((KEYHANDLE) AttributeId);
}


BOOL
pSetAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId,
    IN      BOOL QueryOnly
    )
{
    BOOL result = FALSE;

    __try {
        //
        // Test if object is locked, then if not locked, add linkage
        //

        if (TestLock (ObjectId, (KEYHANDLE) AttributeId)) {

            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_WARNING,
                "Can't set attribute %s on %s because of lock",
                pGetAttributeNameForDebugMsg (AttributeId),
                GetObjectNameForDebugMsg (ObjectId)
                ));

            __leave;

        }

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        result = MemDbAddDoubleLinkageByKeyHandle (
                    ObjectId,
                    AttributeId,
                    ATTRIBUTE_INDEX
                    );
        if (!result) {
            EngineError ();
        }
    }
    __finally {
    }

    return result;
}


BOOL
pSetAttributeGroup (
    IN      KEYHANDLE AttributeId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    MYASSERT (IsItemId (AttributeId));

    return pSetAttributeOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_ATTRIBUTEID) AttributeId,
                FirstPass
                );
}


BOOL
IsmSetAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    RECURSERETURN rc;

    //
    // If AttributeId is a group, set all attribs in the group
    //

    rc = RecurseForGroupItems (
                AttributeId,
                pSetAttributeGroup,
                (ULONG_PTR) ObjectId,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pSetAttributeOnObjectId (ObjectId, AttributeId, FALSE);
}


BOOL
IsmSetAttributeOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = GetObjectIdForModification (ObjectTypeId, EncodedObjectName);

    if (objectId) {
        result = IsmSetAttributeOnObjectId (objectId, AttributeId);
    }

    return result;
}


BOOL
IsmMakePersistentObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    BOOL result;

    if (IsmIsPersistentObjectId (ObjectId)) {
        return TRUE;
    }

    result = pSetAttributeOnObjectId (ObjectId, g_PersistentAttributeId, FALSE);

    if (result) {

        g_TotalObjects.PersistentObjects ++;

        result = MemDbGetValueByHandle (ObjectId, &objectTypeId);

        if (result) {

            if ((objectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                g_SourceObjects.PersistentObjects ++;
            } else {
                g_DestinationObjects.PersistentObjects ++;
            }
            IncrementPersistentObjectCount (objectTypeId);
        }

        result = TRUE;
    }

    return result;
}


BOOL
IsmMakePersistentObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);

    if (objectId) {
        result = IsmMakePersistentObjectId (objectId);
    }

    return result;
}


BOOL
IsmMakeApplyObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    BOOL result;

    if (IsmIsApplyObjectId (ObjectId)) {
        return TRUE;
    }

    if (!IsmMakePersistentObjectId (ObjectId)) {
        return FALSE;
    }

    result = pSetAttributeOnObjectId (ObjectId, g_ApplyAttributeId, FALSE);

    if (result) {

        g_TotalObjects.ApplyObjects ++;

        result = MemDbGetValueByHandle (ObjectId, &objectTypeId);

        if (result) {

            if ((objectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                g_SourceObjects.ApplyObjects ++;
            } else {
                g_DestinationObjects.ApplyObjects ++;
            }
            IncrementApplyObjectCount (objectTypeId);
        }

        result = TRUE;
    }

    return result;
}

BOOL
IsmMakeApplyObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);

    if (objectId) {
        result = IsmMakeApplyObjectId (objectId);
    }

    return result;
}


BOOL
IsmAbandonObjectIdOnCollision (
    IN      MIG_OBJECTID ObjectId
    )
{
    BOOL result;

    if (IsmIsObjectIdAbandonedOnCollision (ObjectId)) {
        return TRUE;
    }

    result = pSetAttributeOnObjectId (ObjectId, g_AbandonedAttributeId, FALSE);

    return result;
}

BOOL
IsmAbandonObjectOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);

    if (objectId) {
        result = IsmAbandonObjectIdOnCollision (objectId);
    }

    return result;
}


BOOL
IsmMakeNonCriticalObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    if (IsmIsNonCriticalObjectId (ObjectId)) {
        return TRUE;
    }

    return pSetAttributeOnObjectId (ObjectId, g_NonCriticalAttributeId, FALSE);
}


BOOL
IsmMakeNonCriticalObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, FALSE);

    if (objectId) {
        result = IsmMakeNonCriticalObjectId (objectId);
    }

    return result;
}


VOID
IsmLockAttribute (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    LockHandle (ObjectId, (KEYHANDLE) AttributeId);
}


BOOL
pClearAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId,
    IN      BOOL QueryOnly
    )
{
    PCTSTR groupKey = NULL;
    PCTSTR enumKey = NULL;
    BOOL result = FALSE;

    __try {

        if (TestLock (ObjectId, (KEYHANDLE) AttributeId)) {

            SetLastError (ERROR_LOCKED);
            DEBUGMSG ((
                DBG_ERROR,
                "Can't clear attribute %s on %s because of lock",
                pGetAttributeNameForDebugMsg (AttributeId),
                GetObjectNameForDebugMsg (ObjectId)
                ));

            __leave;

        }

        if (QueryOnly) {
            result = TRUE;
            __leave;
        }

        result = MemDbDeleteDoubleLinkageByKeyHandle (
                    ObjectId,
                    AttributeId,
                    ATTRIBUTE_INDEX
                    );
    }
    __finally {
        if (groupKey) {
            MemDbReleaseMemory (groupKey);
            INVALID_POINTER (groupKey);
        }

        if (enumKey) {
            FreeText (enumKey);
            INVALID_POINTER (enumKey);
        }
    }

    return result;
}


BOOL
pClearAttributeGroup (
    IN      KEYHANDLE AttributeId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pClearAttributeOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_ATTRIBUTEID) AttributeId,
                FirstPass
                );
}


BOOL
IsmClearAttributeOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    RECURSERETURN rc;

    //
    // If AttributeId is a group, set all attribs in the group
    //

    rc = RecurseForGroupItems (
                AttributeId,
                pClearAttributeGroup,
                (ULONG_PTR) ObjectId,
                FALSE,
                FALSE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pClearAttributeOnObjectId (ObjectId, AttributeId, FALSE);
}


BOOL
IsmClearAttributeOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearAttributeOnObjectId (objectId, AttributeId);
    }

    return result;
}


BOOL
IsmClearPersistenceOnObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    BOOL result;

    if (!IsmIsPersistentObjectId (ObjectId)) {
        return TRUE;
    }

    if (!IsmClearApplyOnObjectId (ObjectId)) {
        return FALSE;
    }

    result = pClearAttributeOnObjectId (ObjectId, g_PersistentAttributeId, FALSE);

    if (result) {

        g_TotalObjects.PersistentObjects --;

        result = MemDbGetValueByHandle (ObjectId, &objectTypeId);

        if (result) {

            if ((objectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                g_SourceObjects.PersistentObjects --;
            } else {
                g_DestinationObjects.PersistentObjects --;
            }
            DecrementPersistentObjectCount (objectTypeId);
        }

        result = TRUE;
    }

    return result;
}


BOOL
IsmClearPersistenceOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearPersistenceOnObjectId (objectId);
    }

    return result;
}


BOOL
IsmClearApplyOnObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    MIG_OBJECTTYPEID objectTypeId;
    BOOL result;

    if (!IsmIsApplyObjectId (ObjectId)) {
        return TRUE;
    }

    result = pClearAttributeOnObjectId (ObjectId, g_ApplyAttributeId, FALSE);

    if (result) {

        g_TotalObjects.ApplyObjects --;

        result = MemDbGetValueByHandle (ObjectId, &objectTypeId);

        if (result) {

            if ((objectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE) {
                g_SourceObjects.ApplyObjects --;
            } else {
                g_DestinationObjects.ApplyObjects --;
            }
            DecrementApplyObjectCount (objectTypeId);
        }

        result = TRUE;
    }

    return result;
}


BOOL
IsmClearApplyOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearApplyOnObjectId (objectId);
    }

    return result;
}


BOOL
IsmClearAbandonObjectIdOnCollision (
    IN      MIG_OBJECTID ObjectId
    )
{
    BOOL result;

    if (!IsmIsObjectIdAbandonedOnCollision (ObjectId)) {
        return TRUE;
    }

    result = pClearAttributeOnObjectId (ObjectId, g_AbandonedAttributeId, FALSE);

    return result;
}


BOOL
IsmClearAbandonObjectOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearAbandonObjectIdOnCollision (objectId);
    }

    return result;
}


BOOL
IsmClearNonCriticalFlagOnObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    if (!IsmIsNonCriticalObjectId (ObjectId)) {
        return TRUE;
    }

    return pClearAttributeOnObjectId (ObjectId, g_NonCriticalAttributeId, FALSE);
}


BOOL
IsmClearNonCriticalFlagOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;
    BOOL result = FALSE;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        result = IsmClearNonCriticalFlagOnObjectId (objectId);
    }

    return result;
}


BOOL
pIsAttributeSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    return MemDbTestDoubleLinkageByKeyHandle (
                ObjectId,
                AttributeId,
                ATTRIBUTE_INDEX
                );
}


BOOL
pQueryAttributeGroup (
    IN      KEYHANDLE AttributeId,
    IN      BOOL FirstPass,
    IN      ULONG_PTR Arg
    )
{
    return pIsAttributeSetOnObjectId (
                (MIG_OBJECTID) Arg,
                (MIG_ATTRIBUTEID) AttributeId
                );
}


BOOL
IsmIsAttributeSetOnObjectId (
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    RECURSERETURN rc;

    //
    // If AttributeId is a group, query all properties in the group
    //

    rc = RecurseForGroupItems (
                AttributeId,
                pQueryAttributeGroup,
                (ULONG_PTR) ObjectId,
                TRUE,
                TRUE
                );

    if (rc == RECURSE_FAIL) {
        return FALSE;
    } else if (rc == RECURSE_SUCCESS) {
        return TRUE;
    }

    MYASSERT (rc == RECURSE_NOT_NEEDED);

    return pIsAttributeSetOnObjectId (ObjectId, AttributeId);
}


BOOL
IsmIsAttributeSetOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsAttributeSetOnObjectId (objectId, AttributeId);
    }

    return FALSE;
}


BOOL
IsmIsPersistentObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    return pIsAttributeSetOnObjectId (ObjectId, g_PersistentAttributeId);
}


BOOL
IsmIsPersistentObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsPersistentObjectId (objectId);
    }

    return FALSE;
}


BOOL
IsmIsApplyObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    return pIsAttributeSetOnObjectId (ObjectId, g_ApplyAttributeId);
}


BOOL
IsmIsApplyObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsApplyObjectId (objectId);
    }

    return FALSE;
}


BOOL
IsmIsObjectIdAbandonedOnCollision (
    IN      MIG_OBJECTID ObjectId
    )
{
    return pIsAttributeSetOnObjectId (ObjectId, g_AbandonedAttributeId);
}


BOOL
IsmIsObjectAbandonedOnCollision (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsObjectIdAbandonedOnCollision (objectId);
    }

    return FALSE;
}


BOOL
IsmIsNonCriticalObjectId (
    IN      MIG_OBJECTID ObjectId
    )
{
    return pIsAttributeSetOnObjectId (ObjectId, g_NonCriticalAttributeId);
}


BOOL
IsmIsNonCriticalObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmIsNonCriticalObjectId (objectId);
    }

    return FALSE;
}


BOOL
IsmEnumFirstObjectAttributeById (
    OUT     PMIG_OBJECTATTRIBUTE_ENUM EnumPtr,
    IN      MIG_OBJECTID ObjectId
    )
{
    POBJECTATTRIBUTE_HANDLE handle;
    BOOL result = TRUE;

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTATTRIBUTE_ENUM));

    EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTATTRIBUTE_HANDLE));
    handle = (POBJECTATTRIBUTE_HANDLE) EnumPtr->Handle;

    handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                ObjectId,
                                ATTRIBUTE_INDEX,
                                &handle->Count
                                );

    handle->Count = handle->Count / SIZEOF(KEYHANDLE);

    if (!handle->LinkageList || !handle->Count) {
        IsmAbortObjectAttributeEnum (EnumPtr);
        result = FALSE;
    } else {

        result = IsmEnumNextObjectAttribute (EnumPtr);
    }

    return result;
}


BOOL
IsmEnumFirstObjectAttribute (
    OUT     PMIG_OBJECTATTRIBUTE_ENUM EnumPtr,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    )
{
    MIG_OBJECTID objectId;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    objectId = IsmGetObjectIdFromName (ObjectTypeId, EncodedObjectName, TRUE);

    if (objectId) {
        return IsmEnumFirstObjectAttributeById (EnumPtr, objectId);
    }

    return FALSE;
}


BOOL
IsmEnumNextObjectAttribute (
    IN OUT  PMIG_OBJECTATTRIBUTE_ENUM EnumPtr
    )
{
    POBJECTATTRIBUTE_HANDLE handle;
    BOOL result = FALSE;
    BOOL mine;

    handle = (POBJECTATTRIBUTE_HANDLE) EnumPtr->Handle;
    if (!handle) {
        return FALSE;
    }

    do {

        MYASSERT (!result);

        //
        // Check if we hit the end
        //

        if (handle->Index >= handle->Count) {
            break;
        }

        //
        // Return the next attribute
        //

        EnumPtr->AttributeId = (MIG_ATTRIBUTEID) handle->LinkageList[handle->Index];
        handle->Index++;

        result = IsmGetAttributeName (
                        EnumPtr->AttributeId,
                        NULL,
                        0,
                        &EnumPtr->Private,
                        &mine,
                        NULL
                        );

        //
        // Continue when the attribute is not owned by the caller
        //

        if (result && EnumPtr->Private && !mine) {
            result = FALSE;
        }

        //
        // Continue when we are talking about reserved persistent/apply attribute
        //
        if (result) {
            if (EnumPtr->AttributeId == g_PersistentAttributeId ||
                EnumPtr->AttributeId == g_ApplyAttributeId ||
                EnumPtr->AttributeId == g_AbandonedAttributeId ||
                EnumPtr->AttributeId == g_NonCriticalAttributeId
                ) {
                result = FALSE;
            }
        }

    } while (!result);

    if (!result) {
        IsmAbortObjectAttributeEnum (EnumPtr);
    }

    return result;
}


VOID
IsmAbortObjectAttributeEnum (
    IN OUT  PMIG_OBJECTATTRIBUTE_ENUM EnumPtr
    )
{
    POBJECTATTRIBUTE_HANDLE handle;

    if (EnumPtr->Handle) {

        handle = (POBJECTATTRIBUTE_HANDLE) EnumPtr->Handle;

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        MemFree (g_hHeap, 0, EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTATTRIBUTE_ENUM));
}


BOOL
IsmEnumFirstObjectWithAttribute (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr,
    IN      MIG_ATTRIBUTEID AttributeId
    )
{
    POBJECTWITHATTRIBUTE_HANDLE handle;
    BOOL result = FALSE;

    __try {
        if (!IsItemId ((KEYHANDLE) AttributeId)) {
            DEBUGMSG ((DBG_ERROR, "IsmEnumFirstObjectWithAttribute: invalid attribute id"));
            __leave;
        }

        ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHATTRIBUTE_ENUM));

        EnumPtr->Handle = MemAllocZeroed (sizeof (OBJECTWITHATTRIBUTE_HANDLE));
        handle = (POBJECTWITHATTRIBUTE_HANDLE) EnumPtr->Handle;

        handle->LinkageList = MemDbGetDoubleLinkageArrayByKeyHandle (
                                    AttributeId,
                                    ATTRIBUTE_INDEX,
                                    &handle->Count
                                    );

        handle->Count = handle->Count / SIZEOF(KEYHANDLE);

        if (!handle->LinkageList || !handle->Count) {
            IsmAbortObjectWithAttributeEnum (EnumPtr);
            __leave;
        } else {
            result = IsmEnumNextObjectWithAttribute (EnumPtr);
        }
    }
    __finally {
    }

    return result;
}


BOOL
IsmEnumNextObjectWithAttribute (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    POBJECTWITHATTRIBUTE_HANDLE handle;
    PCTSTR objectPath = NULL;
    BOOL result = FALSE;
    PTSTR p;

    __try {
        handle = (POBJECTWITHATTRIBUTE_HANDLE) EnumPtr->Handle;
        if (!handle) {
            __leave;
        }

        do {

            //
            // Check if enum is done
            //

            if (handle->Index >= handle->Count) {
                break;
            }

            //
            // Get the next object id from the linkage list
            //

            EnumPtr->ObjectId = handle->LinkageList[handle->Index];
            handle->Index++;

            if (handle->ObjectFromMemdb) {
                MemDbReleaseMemory (handle->ObjectFromMemdb);
                INVALID_POINTER (handle->ObjectFromMemdb);
            }

            handle->ObjectFromMemdb = MemDbGetKeyFromHandle ((KEYHANDLE) EnumPtr->ObjectId, 0);

            if (!handle->ObjectFromMemdb) {
                MYASSERT (FALSE);   // this error shouldn't happen -- but don't give up
                continue;
            }

            //
            // Turn the object id into a name
            //

            p = _tcschr (handle->ObjectFromMemdb, TEXT('\\'));

            if (p) {
                result = TRUE;
                EnumPtr->ObjectName = _tcsinc (p);
                *p = 0;
                EnumPtr->ObjectTypeId = GetObjectTypeId (handle->ObjectFromMemdb);
            }
        } while (!result);
    }
    __finally {
    }

    if (!result) {
        IsmAbortObjectWithAttributeEnum (EnumPtr);
    }

    return result;
}


VOID
IsmAbortObjectWithAttributeEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    POBJECTWITHATTRIBUTE_HANDLE handle;

    if (EnumPtr->Handle) {
        handle = (POBJECTWITHATTRIBUTE_HANDLE) EnumPtr->Handle;

        if (handle->ObjectFromMemdb) {
            MemDbReleaseMemory (handle->ObjectFromMemdb);
            INVALID_POINTER (handle->ObjectFromMemdb);
        }

        if (handle->LinkageList) {
            MemDbReleaseMemory (handle->LinkageList);
            INVALID_POINTER (handle->LinkageList);
        }

        FreeAlloc (EnumPtr->Handle);
        INVALID_POINTER (EnumPtr->Handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_OBJECTWITHATTRIBUTE_ENUM));
}


BOOL
IsmEnumFirstPersistentObject (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    return IsmEnumFirstObjectWithAttribute (EnumPtr, g_PersistentAttributeId);
}


BOOL
IsmEnumNextPersistentObject (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    return IsmEnumNextObjectWithAttribute (EnumPtr);
}


VOID
IsmAbortPersistentObjectEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    IsmAbortObjectWithAttributeEnum (EnumPtr);
}


BOOL
IsmEnumFirstApplyObject (
    OUT     PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    return IsmEnumFirstObjectWithAttribute (EnumPtr, g_ApplyAttributeId);
}


BOOL
IsmEnumNextApplyObject (
    IN OUT  PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    return IsmEnumNextObjectWithAttribute (EnumPtr);
}


VOID
IsmAbortApplyObjectEnum (
    IN      PMIG_OBJECTWITHATTRIBUTE_ENUM EnumPtr
    )
{
    IsmAbortObjectWithAttributeEnum (EnumPtr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\components.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    components.c

Abstract:

    Implements a set of APIs for the purposes of allowing the application layer to select
    module functionality.

Author:

    Jim Schmidt (jimschm) 07-Aug-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_COMP     "Comp"

//
// Strings
//

#define S_COMPONENT_ROOT            TEXT("Components")
#define S_USER_SUPPLIED             TEXT("User")
#define S_MODULE_SUPPLIED           TEXT("Module")

//
// Constants
//

#define MAX_COMPONENT_SPEC          127
#define MAX_COMPONENT_SPEC_PLUS_NUL (MAX_COMPONENT_SPEC+1)

#define MAX_CONTROLLED_NODE_SIZE    (MAX_COMPONENT_SPEC_PLUS_NUL +  \
                                     ARRAYSIZE(S_COMPONENT_ROOT) +  \
                                     ARRAYSIZE(S_MODULE_SUPPLIED) + 16)

#define MEMDB_FLAG_PREFERRED        1
#define MEMDB_FLAG_SELECTED         1

//
// Macros
//

// none

//
// Types
//

typedef enum {
    CES_DONE = 0,
    CES_FIRST_COMPONENT,
    CES_NEXT_COMPONENT,
    CES_FIRST_ALIAS,
    CES_NEXT_ALIAS,
    CES_CHECK_ALIAS_FLAGS
} COMPONENTENUMSTATE;

typedef struct {
    MEMDB_ENUM ComponentEnumStruct;
    MEMDB_ENUM AliasEnumStruct;
    BOOL EnumAliases;
    UINT GroupIdFilter;
    BOOL EnumEnabled;
    BOOL EnumDisabled;
    BOOL EnumPreferredOnly;
    BOOL EnumNonPreferredOnly;
    COMPONENTENUMSTATE State;
} COMPONENTENUM_HANDLE, *PCOMPONENTENUM_HANDLE;

//
// Globals
//

// none

//
// Macro expansion list
//

// none

//
// Private function prototypes
//

// none

//
// Macro expansion definition
//

// none

//
// Code
//


BOOL
pCheckCompChar (
    IN      CHARTYPE Char,
    IN      BOOL CheckDecoration
    )
{
    //
    // Process decoration chars
    //

    if (Char == TEXT('$') || Char == TEXT('@') || Char == TEXT('~') || Char == TEXT('#')) {
        return CheckDecoration;
    }

    if (CheckDecoration) {
        return FALSE;
    }

    //
    // Block illegal chars
    //

    if (Char == TEXT('\"') || Char == TEXT('*') || Char == TEXT('?') || Char== TEXT('\\') ||
        Char == TEXT('%') || Char == TEXT(';')
        ) {
        return FALSE;
    }

    //
    // Make sure char is printable
    //

    if (Char < 33 || Char > 126) {
        return FALSE;
    }

    return TRUE;
}


BOOL
pCheckComponentName (
    IN      PCTSTR ComponentString
    )
{
    BOOL result = FALSE;
    PCTSTR end;
    PCTSTR begin;

    //
    // Check for a non-empty spec
    //

    if (ComponentString && ComponentString[0]) {

        //
        // Allow for decoration
        //

        end = ComponentString;

        while (pCheckCompChar ((CHARTYPE) _tcsnextc (end), TRUE)) {
            end = _tcsinc (end);
        }

        //
        // Now enforce the name character set: non-decorated characters and no
        // more than MAX_COMPONENT_SPEC characters. Allow spaces in the middle.
        //

        begin = end;

        while (*end) {
            if (!pCheckCompChar ((CHARTYPE) _tcsnextc (end), FALSE)) {
                if (_tcsnextc (end) == TEXT(' ')) {
                    if (!end[1] || end == begin) {
                        break;
                    }
                } else {
                    break;
                }
            }

            end = _tcsinc (end);
        }

        if (!(*end) && *begin) {
            if (end - ComponentString <= MAX_COMPONENT_SPEC) {
                result = TRUE;
            }
        }
    }

    if (!result) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "%s is not a valid component name", ComponentString));
    }

    return result;
}

BOOL
pFindComponent (
    IN      PCTSTR LocalizedAlias,
    IN      UINT ComponentGroupId,
    OUT     PCTSTR *ComponentKey,           OPTIONAL
    OUT     PCTSTR *AliasKey                OPTIONAL
    )
{
    MEMDB_ENUM component;
    PCTSTR memdbNode = NULL;
    PCTSTR encodedUserAlias;
    PCTSTR encodedModuleAlias;
    TCHAR number[32];
    BOOL result = FALSE;

    //
    // Find the component based on the localized alias
    //

    wsprintf (number, TEXT("\\%s\\%04u"), S_USER_SUPPLIED, ComponentGroupId);
    encodedUserAlias = JoinPaths (number, LocalizedAlias);

    wsprintf (number, TEXT("\\%s\\%04u"), S_MODULE_SUPPLIED, ComponentGroupId);
    encodedModuleAlias = JoinPaths (number, LocalizedAlias);

    if (MemDbEnumFirst (
            &component,
            S_COMPONENT_ROOT TEXT("\\*"),
            ENUMFLAG_ALL,
            1,
            1
            )) {

        do {
            memdbNode = JoinText (component.FullKeyName, encodedModuleAlias);

            if (MemDbTestKey (memdbNode)) {
                break;
            }

            FreeText (memdbNode);
            memdbNode = NULL;

            memdbNode = JoinText (component.FullKeyName, encodedUserAlias);

            if (MemDbTestKey (memdbNode)) {
                break;
            }

            FreeText (memdbNode);
            memdbNode = NULL;

        } while (MemDbEnumNext (&component));
    }

    if (memdbNode) {

        if (ComponentKey) {
            *ComponentKey = DuplicateText (component.FullKeyName);
        }

        if (AliasKey) {
            *AliasKey = memdbNode;
            memdbNode = NULL;
        }

        MemDbAbortEnum (&component);
        result = TRUE;
    }

    FreeText (memdbNode);
    INVALID_POINTER (memdbNode);

    FreePathString (encodedUserAlias);
    INVALID_POINTER (encodedUserAlias);

    FreePathString (encodedModuleAlias);
    INVALID_POINTER (encodedModuleAlias);

    return result;
}


BOOL
WINAPI
IsmSelectPreferredAlias (
    IN      PCTSTR ComponentString,
    IN      PCTSTR LocalizedAlias,          OPTIONAL
    IN      UINT ComponentGroupId           OPTIONAL
    )

/*++

Routine Description:

  IsmSelectPreferredAlias marks a specific alias as the "preferred" one, so
  that the UI knows what to display. If LocalizedAlias is not specified, none
  of the aliases are preferred.

  A component can have only one preferred localized alias. If another alias is
  selected as preferred, it will be deselected automatically.

Arguments:

  ComponentString  - Specifies the non-displayed component identifier
  LocalizedAlias   - Specifies the displayable string to mark as "preferred,"
                     or NULL to remove the preferred flag from the component.
  ComponentGroupId - Specifies the group ID for LocalizedAlias. Required if
                     LocalizedAlias is not NULL.

Return Value:

  TRUE if selection (or deselection) succeeded, FALSE if LocalizedAlias does
  not exist.

--*/

{
    MEMDB_ENUM e;
    TCHAR number[32];
    PCTSTR memdbNode = NULL;
    PCTSTR baseOfPattern;
    PCTSTR enumPattern;
    PCTSTR groupedAlias;
    BOOL result;

    if (!ComponentString || (LocalizedAlias && !ComponentGroupId)) {
        MYASSERT (FALSE);
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    result = (LocalizedAlias == NULL);

    //
    // Build enumeration string Components\<component>\*
    //

    baseOfPattern = JoinPaths (S_COMPONENT_ROOT, ComponentString);
    enumPattern = JoinPaths (baseOfPattern, TEXT("*"));
    FreePathString (baseOfPattern);
    INVALID_POINTER (baseOfPattern);

    if (LocalizedAlias) {
        wsprintf (number, TEXT("%04u"), ComponentGroupId);
        groupedAlias = JoinPaths (number, LocalizedAlias);
    } else {
        groupedAlias = NULL;
    }

    if (MemDbEnumFirst (
            &e,
            enumPattern,
            ENUMFLAG_NORMAL,
            3,
            ENUMLEVEL_ALLLEVELS
            )) {
        do {
            if (groupedAlias && StringIMatch (e.KeyName, groupedAlias)) {
                MemDbSetFlags (e.FullKeyName, MEMDB_FLAG_PREFERRED, MEMDB_FLAG_PREFERRED);
                result = TRUE;
            } else {
                MemDbSetFlags (e.FullKeyName, 0, MEMDB_FLAG_PREFERRED);
            }
        } while (MemDbEnumNext (&e));
    }

    FreePathString (enumPattern);
    INVALID_POINTER (enumPattern);

    FreePathString (groupedAlias);
    INVALID_POINTER (groupedAlias);

    return result;
}


BOOL
WINAPI
IsmAddComponentAlias (
    IN      PCTSTR ComponentString,         OPTIONAL
    IN      UINT MasterGroup,
    IN      PCTSTR LocalizedAlias,
    IN      UINT ComponentGroupId,
    IN      BOOL UserSupplied
    )

/*++

Routine Description:

  IsmAddComponentAlias associates a display string (LocalizedAlias) with a
  logical component tag (ComponentString).

Arguments:

  ComponentString  - Specifies the identifier of the component. This
                     identifier is not used for display purposes.
  MasterGroup      - Specifies a MASTERGROUP_xxx constant, which organizes
                     the components into major groups such as system settings
                     and app settings (to simplify selection).
  LocalizedAliais  - The displayable text. It is a localized component name,
                     a path, a file, etc.
  ComponentGroupId - An arbitrary numeric ID defined outside of the ISM. This
                     ID is used to implement requirements specific to the app
                     layer. It allows for arbitrary idenfication and grouping.
  UserSupplied     - Specifies TRUE if the end-user supplied this info, FALSE
                     if it is built into the migration package.

Return Value:

  A flag indicating success or failure.

--*/

 {
    PCTSTR memdbNode;
    TCHAR workNode[MAX_CONTROLLED_NODE_SIZE];
    static UINT sequencer = 0;
    TCHAR madeUpComponent[MAX_COMPONENT_SPEC_PLUS_NUL];
    BOOL b;
    BOOL newComponent = FALSE;

    //
    // Components are kept in memdb in the form of
    //
    //  Component\<Module|User>\<GroupId>\<LocalizedAlias> = <preferred flag>
    //
    // <GroupId> is stored as a 4 digit number (such as 0001)
    //
    // Component\<Module|User> = <enable/disable>,<master group>
    //

    //
    // Validate arguments
    //

    if (ComponentGroupId > 9999) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ComponentString || !ComponentString[0]) {

        wsprintf (madeUpComponent, TEXT("Component %u"), ++sequencer);
        ComponentString = madeUpComponent;

    } else if (!pCheckComponentName (ComponentString)) {
        return FALSE;
    }

    if (!MasterGroup || MasterGroup >= MASTERGROUP_ALL) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "MasterGroup is invalid"));
        return FALSE;
    }

    //
    // See if the component already exists
    //

    // This is safe since ComponentString was already checked for length by pCheckComponentName
    wsprintf (workNode, TEXT("%s\\%s"), S_COMPONENT_ROOT, ComponentString);

    if (pFindComponent (LocalizedAlias, ComponentGroupId, &memdbNode, NULL)) {

        if (StringIMatch (workNode, memdbNode)) {
            DEBUGMSG ((DBG_VERBOSE, "Alias %s already exists; not adding it again", LocalizedAlias));
        } else {
            DEBUGMSG ((
                DBG_WARNING,
                "Alias %s is in use by component %s; not adding it again",
                LocalizedAlias,
                _tcschr (memdbNode, TEXT('\\')) + 1
                ));
        }

        FreeText (memdbNode);
        return FALSE;
    }

    //
    // Create the component if it doesn't exist, and then add the alias
    //

    if (!MemDbTestKey (workNode)) {
        if (!MemDbSetValueAndFlags (workNode, MasterGroup, MEMDB_FLAG_SELECTED, MEMDB_FLAG_SELECTED)) {
            EngineError ();
            return FALSE;
        }

        newComponent = TRUE;
    }

    // This is safe since ComponentString was already checked for length by pCheckComponentName
    wsprintf (
        workNode,
        TEXT("%s\\%s\\%s\\%04u"),
        S_COMPONENT_ROOT,
        ComponentString,
        UserSupplied ? S_USER_SUPPLIED : S_MODULE_SUPPLIED,
        ComponentGroupId
        );

    memdbNode = JoinPaths (workNode, LocalizedAlias);

    if (newComponent) {
        b = MemDbSetFlags (memdbNode, MEMDB_FLAG_PREFERRED, MEMDB_FLAG_PREFERRED);
    } else {
        b = MemDbSetKey (memdbNode);
    }

    FreePathString (memdbNode);

    if (!b) {
        EngineError ();
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
IsmSelectComponent (
    IN      PCTSTR ComponentOrAlias,
    IN      UINT ComponentGroupId,      OPTIONAL
    IN      BOOL Enable
    )
{
    PCTSTR memdbNode = NULL;
    UINT flags;
    BOOL b;

    if (ComponentGroupId > 9999) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "Invalid component group"));
        return FALSE;
    }

    if (!ComponentOrAlias || !ComponentOrAlias[0]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "Invalid localized alias"));
        return FALSE;
    }

    if (!ComponentGroupId) {
        if (!pCheckComponentName (ComponentOrAlias)) {
            return FALSE;
        }

        memdbNode = JoinText (S_COMPONENT_ROOT TEXT("\\"), ComponentOrAlias);
        if (!MemDbTestKey (memdbNode)) {
            FreeText (memdbNode);
            return FALSE;
        }

    } else {

        if (!pFindComponent (ComponentOrAlias, ComponentGroupId, &memdbNode, NULL)) {
            SetLastError (ERROR_NO_SUCH_ALIAS);
            return FALSE;
        }
    }

    flags = Enable ? MEMDB_FLAG_SELECTED : 0;
    b = MemDbSetFlags (memdbNode, flags, MEMDB_FLAG_SELECTED);
    FreeText (memdbNode);

    if (!b) {
        EngineError ();
        return FALSE;
    }

    return TRUE;
}


BOOL
pEnumWorker (
    IN OUT  PMIG_COMPONENT_ENUM EnumPtr,
    IN OUT  PCOMPONENTENUM_HANDLE Handle
    )
{
    BOOL result = FALSE;
    PCTSTR pattern;
    PCTSTR p;
    BOOL enabled;

    while (Handle->State != CES_DONE) {

        switch (Handle->State) {

        case CES_FIRST_COMPONENT:

            if (!MemDbEnumFirst (
                    &Handle->ComponentEnumStruct,
                    S_COMPONENT_ROOT TEXT("\\*"),
                    ENUMFLAG_ALL,
                    1,
                    1
                    )) {
                Handle->State = CES_DONE;
            } else {
                if (Handle->EnumAliases) {
                    Handle->State = CES_FIRST_ALIAS;
                } else {
                    Handle->State = CES_NEXT_COMPONENT;
                    result = TRUE;
                }
            }
            break;

        case CES_FIRST_ALIAS:

            enabled = ((Handle->ComponentEnumStruct.Flags  & MEMDB_FLAG_SELECTED) != 0);

            if ((!Handle->EnumEnabled && enabled) ||
                (!Handle->EnumDisabled && !enabled)
                ) {
                Handle->State = CES_NEXT_COMPONENT;
                continue;
            }

            EnumPtr->Instance = 0;

            pattern = JoinPaths (Handle->ComponentEnumStruct.FullKeyName, TEXT("*"));

            if (!MemDbEnumFirst (
                    &Handle->AliasEnumStruct,
                    pattern,
                    ENUMFLAG_NORMAL,
                    4,
                    ENUMLEVEL_ALLLEVELS
                    )) {
                Handle->State = CES_NEXT_COMPONENT;
            } else {
                Handle->State = CES_CHECK_ALIAS_FLAGS;
            }

            FreePathString (pattern);
            break;

        case CES_NEXT_ALIAS:
            if (EnumPtr->SkipToNextComponent) {
                MemDbAbortEnum (&Handle->AliasEnumStruct);
                Handle->State = CES_NEXT_COMPONENT;
                EnumPtr->SkipToNextComponent = FALSE;
                break;
            }

            if (!MemDbEnumNext (&Handle->AliasEnumStruct)) {
                Handle->State = CES_NEXT_COMPONENT;
            } else {
                Handle->State = CES_CHECK_ALIAS_FLAGS;
            }
            break;

        case CES_CHECK_ALIAS_FLAGS:
            EnumPtr->Preferred = ((Handle->AliasEnumStruct.Flags & MEMDB_FLAG_PREFERRED) != 0);
            Handle->State = CES_NEXT_ALIAS;

            if (Handle->EnumPreferredOnly) {
                result = EnumPtr->Preferred;
            } else if (Handle->EnumNonPreferredOnly) {
                result = !EnumPtr->Preferred;
            } else {
                result = TRUE;
            }

            break;

        case CES_NEXT_COMPONENT:
            if (!MemDbEnumNext (&Handle->ComponentEnumStruct)) {
                Handle->State = CES_DONE;
            } else {
                if (Handle->EnumAliases) {
                    Handle->State = CES_FIRST_ALIAS;
                } else {
                    Handle->State = CES_NEXT_COMPONENT;
                    result = TRUE;
                }
            }
            break;

        default:
            Handle->State = CES_DONE;
            break;
        }

        if (result) {

            //
            // Fill in all of the caller enum struct fields
            //

            EnumPtr->SkipToNextComponent = FALSE;
            EnumPtr->ComponentString = Handle->ComponentEnumStruct.KeyName;
            EnumPtr->Enabled = ((Handle->ComponentEnumStruct.Flags  & MEMDB_FLAG_SELECTED) != 0);
            EnumPtr->MasterGroup =  Handle->ComponentEnumStruct.Value;

            if (Handle->EnumAliases) {
                p = _tcschr (Handle->AliasEnumStruct.FullKeyName, TEXT('\\'));
                MYASSERT (p);

                if (p) {
                    p = _tcschr (p + 1, TEXT('\\'));
                    MYASSERT (p);
                }

                if (p) {
                    p++;
                    if (_totlower (p[0]) == TEXT('u')) {
                        EnumPtr->UserSupplied = TRUE;
                    } else {
                        EnumPtr->UserSupplied = FALSE;
                    }

                    p = _tcschr (p, TEXT('\\'));
                    MYASSERT (p);
                }

                if (p) {
                    p++;
                    EnumPtr->GroupId = _tcstoul (p, (PTSTR *) (&p), 10);
                    MYASSERT (p && p[0] == TEXT('\\'));
                }

                if (p) {
                    EnumPtr->LocalizedAlias = p + 1;
                }

                //
                // If group ID filter was specified, loop until a match is found
                //

                if (Handle->GroupIdFilter && Handle->GroupIdFilter != EnumPtr->GroupId) {
                    result = FALSE;
                    continue;
                }

            } else {
                EnumPtr->Preferred = FALSE;
                EnumPtr->UserSupplied = FALSE;
                EnumPtr->GroupId = 0;
                EnumPtr->LocalizedAlias = NULL;
            }

            EnumPtr->Instance++;
            break;
        }
    }

    if (!result) {
        IsmAbortComponentEnum (EnumPtr);
    }

    return result;
}


BOOL
WINAPI
IsmEnumFirstComponent (
    OUT     PMIG_COMPONENT_ENUM EnumPtr,
    IN      DWORD Flags,
    IN      UINT GroupIdFilter                  OPTIONAL
    )
{
    PCOMPONENTENUM_HANDLE handle;

    ZeroMemory (EnumPtr, sizeof (MIG_COMPONENT_ENUM));

    if (Flags & (COMPONENTENUM_PREFERRED_ONLY|COMPONENTENUM_NON_PREFERRED_ONLY)) {
        if (!(Flags & COMPONENTENUM_ALIASES)) {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if ((Flags & (COMPONENTENUM_PREFERRED_ONLY|COMPONENTENUM_NON_PREFERRED_ONLY)) ==
            (COMPONENTENUM_PREFERRED_ONLY|COMPONENTENUM_NON_PREFERRED_ONLY)
            ) {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    EnumPtr->Handle = MemAllocUninit (sizeof (COMPONENTENUM_HANDLE));
    handle = (PCOMPONENTENUM_HANDLE) EnumPtr->Handle;
    handle->EnumAliases = Flags & COMPONENTENUM_ALIASES ? TRUE : FALSE;
    handle->EnumEnabled = Flags & COMPONENTENUM_ENABLED ? TRUE : FALSE;
    handle->EnumDisabled = Flags & COMPONENTENUM_DISABLED ? TRUE : FALSE;
    handle->GroupIdFilter = GroupIdFilter;
    handle->EnumPreferredOnly = Flags & COMPONENTENUM_PREFERRED_ONLY;
    handle->EnumNonPreferredOnly = Flags & COMPONENTENUM_NON_PREFERRED_ONLY;

    handle->State = CES_FIRST_COMPONENT;

    return pEnumWorker (EnumPtr, handle);
}


BOOL
WINAPI
IsmEnumNextComponent (
    IN OUT  PMIG_COMPONENT_ENUM EnumPtr
    )
{
    PCOMPONENTENUM_HANDLE handle;

    handle = (PCOMPONENTENUM_HANDLE) EnumPtr->Handle;
    return pEnumWorker (EnumPtr, handle);
}


VOID
WINAPI
IsmAbortComponentEnum (
    IN      PMIG_COMPONENT_ENUM EnumPtr         ZEROED
    )
{
    PCOMPONENTENUM_HANDLE handle;

    handle = (PCOMPONENTENUM_HANDLE) EnumPtr->Handle;
    if (handle) {
        if (handle->State == CES_NEXT_COMPONENT) {
            MemDbAbortEnum (&handle->ComponentEnumStruct);
        }

        if (handle->EnumAliases) {
            if (handle->State == CES_NEXT_ALIAS) {
                MemDbAbortEnum (&handle->AliasEnumStruct);
            }
        }

        FreeAlloc (handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_COMPONENT_ENUM));
}


VOID
WINAPI
IsmRemoveAllUserSuppliedComponents (
    VOID
    )
{
    MEMDB_ENUM e;
    MULTISZ_ENUM listEnum;
    GROWBUFFER list = INIT_GROWBUFFER;

    //
    // Collect all the components that have user-supplied aliases. Then after
    // enum completes, delete them. We don't delete during the enum because it
    // is never a good idea to delete the item just enumerated, and then try
    // to continue enumerating.
    //

    if (MemDbEnumFirst (
            &e,
            S_COMPONENT_ROOT TEXT("\\*\\") S_USER_SUPPLIED TEXT("\\*"),
            ENUMFLAG_ALL,
            2,
            2
            )) {

        do {
            GbMultiSzAppend (&list, e.FullKeyName);
        } while (MemDbEnumNext (&e));
    }

    if (EnumFirstMultiSz (&listEnum, (PCTSTR) list.Buf)) {
        do {
            MemDbDeleteTree (listEnum.CurrentString);
        } while (EnumNextMultiSz (&listEnum));
    }

    GbFree (&list);
}


BOOL
WINAPI
IsmSelectMasterGroup (
    IN      UINT MasterGroup,
    IN      BOOL Enable
    )
{
    MEMDB_ENUM e;
    UINT flags;

    if (MasterGroup > MASTERGROUP_ALL) {
        SetLastError (ERROR_INVALID_PARAMETER);
        DEBUGMSG ((DBG_ERROR, "Can't select invalid MasterGroup"));
        return FALSE;
    }

    //
    // Enumerate all components and mark them enabled or disabled
    // depending on the master group
    //

    if (MemDbEnumFirst (
            &e,
            S_COMPONENT_ROOT TEXT("\\*"),
            ENUMFLAG_NORMAL,
            1,
            1
            )) {

        do {
            if (MasterGroup == MASTERGROUP_ALL ||
                MasterGroup == e.Value
                ) {
                flags = Enable ? MEMDB_FLAG_SELECTED : 0;
            } else {
                flags = 0;
            }

            if (!MemDbSetFlags (e.FullKeyName, flags, MEMDB_FLAG_SELECTED)) {
                EngineError ();
                MemDbAbortEnum (&e);
                return FALSE;
            }

        } while (MemDbEnumNext (&e));
    }

    return TRUE;
}


BOOL
WINAPI
IsmIsComponentSelected (
    IN      PCTSTR ComponentOrAlias,
    IN      UINT ComponentGroupId           OPTIONAL
    )
{
    UINT flags = 0;
    TCHAR memdbNode[MAX_CONTROLLED_NODE_SIZE];
    PCTSTR componentNode;

    if (!ComponentGroupId) {
        if (!pCheckComponentName (ComponentOrAlias)) {
            return FALSE;
        }
        // This is safe since ComponentOrAlias was already checked for length by pCheckComponentName
        wsprintf (memdbNode, TEXT("%s\\%s"), S_COMPONENT_ROOT, ComponentOrAlias);
        MemDbGetFlags (memdbNode, &flags);
    } else {
        if (pFindComponent (ComponentOrAlias, ComponentGroupId, &componentNode, NULL)) {
            MemDbGetFlags (componentNode, &flags);
            FreeText (componentNode);
        }
    }

    return (flags & MEMDB_FLAG_SELECTED) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\env.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    env.c

Abstract:

    Implements ISM environment variable support

Author:

    Jim Schmidt (jimschm) 01-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_ISMENV          "IsmEnv"

//
// Strings
//

#define S_MEMDB_ENV_ROOT_SRC        TEXT("EnvSrc")
#define S_MEMDB_ENV_ROOT_DEST       TEXT("EnvDest")

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    ENVENTRY_TYPE Type;
    UINT DataSize;
    BYTE Data[];
} ENVIRONMENT_ENTRY, *PENVIRONMENT_ENTRY;

//
// Globals
//

GROWBUFFER g_AppendBuffer = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

BOOL
pGetEnvironmentValue (
    IN      UINT Platform,
    IN OUT  KEYHANDLE *KeyHandle,       OPTIONAL
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE Data,                 OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded,       OPTIONAL
    OUT     PENVENTRY_TYPE DataType     OPTIONAL
    );

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
InitializeEnv (
    VOID
    )
{
    return TRUE;
}

VOID
TerminateEnv (
    VOID
    )
{
    GbFree (&g_AppendBuffer);
}

BOOL
EnvEnumerateFirstEntry (
    OUT     PENV_ENTRY_ENUM EnvEntryEnum,
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Pattern
    )
{
    PCTSTR pattern = NULL;
    PENVIRONMENT_ENTRY envEntry;
    UINT dataSize;
    BOOL result = FALSE;

    if (Platform == PLATFORM_CURRENT) {
        Platform = g_IsmCurrentPlatform;
    }
    if (Platform == PLATFORM_SOURCE) {
        pattern = JoinPaths (S_MEMDB_ENV_ROOT_SRC, Pattern);
    } else {
        pattern = JoinPaths (S_MEMDB_ENV_ROOT_DEST, Pattern);
    }

    ZeroMemory (EnvEntryEnum, sizeof (PENV_ENTRY_ENUM));

    EnvEntryEnum->Platform = Platform;

    if (MemDbEnumFirst (&EnvEntryEnum->Handle, pattern, ENUMFLAG_NORMAL, 1, ENUMLEVEL_ALLLEVELS)) {

        envEntry = (PENVIRONMENT_ENTRY) MemDbGetUnorderedBlob (EnvEntryEnum->Handle.FullKeyName, 0, NULL);
        EnvEntryEnum->EnvEntryType = envEntry->Type;
        EnvEntryEnum->EnvEntryGroup = DuplicatePathString (EnvEntryEnum->Handle.KeyName, 0);
        EnvEntryEnum->EnvEntryName = _tcschr (EnvEntryEnum->EnvEntryGroup, TEXT('\\'));

        if (EnvEntryEnum->EnvEntryName) {
            *((PTSTR)(EnvEntryEnum->EnvEntryName)) = 0;
            EnvEntryEnum->EnvEntryName ++;
        } else {
            EnvEntryEnum->EnvEntryName = EnvEntryEnum->EnvEntryGroup;
            EnvEntryEnum->EnvEntryGroup = NULL;
        }

#ifdef UNICODE
        EnvEntryEnum->EnvEntryDataSize = envEntry->DataSize;
        if (envEntry->DataSize) {
            EnvEntryEnum->EnvEntryData = IsmGetMemory (envEntry->DataSize);
            CopyMemory (EnvEntryEnum->EnvEntryData, envEntry->Data, envEntry->DataSize);
        } else {
            EnvEntryEnum->EnvEntryData = NULL;
        }
#else
        if (envEntry->Type == ENVENTRY_STRING) {
            dataSize = SizeOfStringA ((PCSTR)envEntry->Data) * 2;
            EnvEntryEnum->EnvEntryData = IsmGetMemory (dataSize);
            ZeroMemory (EnvEntryEnum->EnvEntryData, dataSize);
            DirectDbcsToUnicodeN (
                (PWSTR)EnvEntryEnum->EnvEntryData,
                (PSTR)envEntry->Data,
                SizeOfStringA ((PCSTR)envEntry->Data)
                );
            EnvEntryEnum->EnvEntryDataSize = SizeOfStringW ((PWSTR)EnvEntryEnum->EnvEntryData);
        } else if (envEntry->Type == ENVENTRY_MULTISZ) {
            dataSize = SizeOfMultiSzA ((PCSTR)envEntry->Data) * 2;
            EnvEntryEnum->EnvEntryData = IsmGetMemory (dataSize);
            ZeroMemory (EnvEntryEnum->EnvEntryData, dataSize);
            DirectDbcsToUnicodeN (
                (PWSTR)EnvEntryEnum->EnvEntryData,
                (PSTR)envEntry->Data,
                SizeOfMultiSzA ((PCSTR)envEntry->Data)
                );
            EnvEntryEnum->EnvEntryDataSize = SizeOfMultiSzW ((PWSTR)EnvEntryEnum->EnvEntryData);
        } else {
            EnvEntryEnum->EnvEntryDataSize = envEntry->DataSize;
            if (envEntry->DataSize) {
                EnvEntryEnum->EnvEntryData = IsmGetMemory (envEntry->DataSize);
                CopyMemory (EnvEntryEnum->EnvEntryData, envEntry->Data, envEntry->DataSize);
            } else {
                EnvEntryEnum->EnvEntryData = NULL;
            }
        }
#endif

        MemDbReleaseMemory (envEntry);
        result = TRUE;
    }

    FreePathString (pattern);
    return result;
}

BOOL
EnvEnumerateNextEntry (
    IN OUT  PENV_ENTRY_ENUM EnvEntryEnum
    )
{
    PENVIRONMENT_ENTRY envEntry;
    UINT dataSize;
    BOOL result = FALSE;

    if (EnvEntryEnum->EnvEntryData) {
        IsmReleaseMemory (EnvEntryEnum->EnvEntryData);
        EnvEntryEnum->EnvEntryData = NULL;
    }
    if (EnvEntryEnum->EnvEntryGroup) {
        FreePathString (EnvEntryEnum->EnvEntryGroup);
        EnvEntryEnum->EnvEntryGroup = NULL;
        EnvEntryEnum->EnvEntryName = NULL;
    }
    if (EnvEntryEnum->EnvEntryName) {
        FreePathString (EnvEntryEnum->EnvEntryName);
        EnvEntryEnum->EnvEntryName = NULL;
    }
    if (MemDbEnumNext (&EnvEntryEnum->Handle)) {

        envEntry = (PENVIRONMENT_ENTRY) MemDbGetUnorderedBlob (EnvEntryEnum->Handle.FullKeyName, 0, NULL);
        EnvEntryEnum->EnvEntryType = envEntry->Type;
        EnvEntryEnum->EnvEntryGroup = DuplicatePathString (EnvEntryEnum->Handle.KeyName, 0);
        EnvEntryEnum->EnvEntryName = _tcschr (EnvEntryEnum->EnvEntryGroup, TEXT('\\'));

        if (EnvEntryEnum->EnvEntryName) {
            *((PTSTR)(EnvEntryEnum->EnvEntryName)) = 0;
            EnvEntryEnum->EnvEntryName ++;
        } else {
            EnvEntryEnum->EnvEntryName = EnvEntryEnum->EnvEntryGroup;
            EnvEntryEnum->EnvEntryGroup = NULL;
        }

#ifdef UNICODE
        EnvEntryEnum->EnvEntryDataSize = envEntry->DataSize;
        if (envEntry->DataSize) {
            EnvEntryEnum->EnvEntryData = IsmGetMemory (envEntry->DataSize);
            CopyMemory (EnvEntryEnum->EnvEntryData, envEntry->Data, envEntry->DataSize);
        } else {
            EnvEntryEnum->EnvEntryData = NULL;
        }
#else
        if (envEntry->Type == ENVENTRY_STRING) {
            dataSize = SizeOfStringW ((PCWSTR)envEntry->Data) * 2;
            EnvEntryEnum->EnvEntryData = IsmGetMemory (dataSize);
            ZeroMemory (EnvEntryEnum->EnvEntryData, dataSize);
            DirectUnicodeToDbcsN (
                (PSTR)EnvEntryEnum->EnvEntryData,
                (PWSTR)envEntry->Data,
                SizeOfStringW ((PCWSTR)envEntry->Data)
                );
            EnvEntryEnum->EnvEntryDataSize = SizeOfStringW ((PWSTR)EnvEntryEnum->EnvEntryData);
        } else if (envEntry->Type == ENVENTRY_MULTISZ) {
            dataSize = SizeOfMultiSzW ((PCWSTR)envEntry->Data) * 2;
            EnvEntryEnum->EnvEntryData = IsmGetMemory (dataSize);
            ZeroMemory (EnvEntryEnum->EnvEntryData, dataSize);
            DirectUnicodeToDbcsN (
                (PSTR)EnvEntryEnum->EnvEntryData,
                (PWSTR)envEntry->Data,
                SizeOfMultiSzW ((PCWSTR)envEntry->Data)
                );
            EnvEntryEnum->EnvEntryDataSize = SizeOfMultiSzW ((PWSTR)EnvEntryEnum->EnvEntryData);
        } else {
            EnvEntryEnum->EnvEntryDataSize = envEntry->DataSize;
            if (envEntry->DataSize) {
                EnvEntryEnum->EnvEntryData = IsmGetMemory (envEntry->DataSize);
                CopyMemory (EnvEntryEnum->EnvEntryData, envEntry->Data, envEntry->DataSize);
            } else {
                EnvEntryEnum->EnvEntryData = NULL;
            }
        }
#endif

        MemDbReleaseMemory (envEntry);
        result = TRUE;
    } else {
        MemDbAbortEnum (&EnvEntryEnum->Handle);
    }

    return result;
}

VOID
AbortEnvEnumerateEntry (
    IN OUT  PENV_ENTRY_ENUM EnvEntryEnum
    )
{
    if (EnvEntryEnum->EnvEntryData) {
        IsmReleaseMemory (EnvEntryEnum->EnvEntryData);
        EnvEntryEnum->EnvEntryData = NULL;
    }
    if (EnvEntryEnum->EnvEntryGroup) {
        FreePathString (EnvEntryEnum->EnvEntryGroup);
        EnvEntryEnum->EnvEntryGroup = NULL;
        EnvEntryEnum->EnvEntryName = NULL;
    }
    if (EnvEntryEnum->EnvEntryName) {
        FreePathString (EnvEntryEnum->EnvEntryName);
        EnvEntryEnum->EnvEntryName = NULL;
    }
    MemDbAbortEnum (&EnvEntryEnum->Handle);

    ZeroMemory (EnvEntryEnum, sizeof (PENV_ENTRY_ENUM));
}

VOID
EnvInvalidateCallbacks (
    VOID
    )
{
    GROWBUFFER envBuff = INIT_GROWBUFFER;
    PCTSTR pattern = NULL;
    MEMDB_ENUM e;
    MULTISZ_ENUM se;
    BOOL toDelete = FALSE;
    PENVIRONMENT_ENTRY envEntry;

    pattern = JoinPaths (S_MEMDB_ENV_ROOT_SRC, TEXT("*"));

    if (MemDbEnumFirst (&e, pattern, ENUMFLAG_NORMAL, 0, ENUMLEVEL_ALLLEVELS)) {
        do {
            envEntry = (PENVIRONMENT_ENTRY) MemDbGetUnorderedBlob (e.FullKeyName, 0, NULL);
            if (envEntry->Type == ENVENTRY_CALLBACK) {
                GbMultiSzAppend (&envBuff, e.FullKeyName);
                toDelete = TRUE;
            }
            MemDbReleaseMemory (envEntry);
        } while (MemDbEnumNext (&e));
        MemDbAbortEnum (&e);
    }
    if (toDelete && EnumFirstMultiSz (&se, (PCTSTR) envBuff.Buf)) {
        do {
            MemDbDeleteKey (se.CurrentString);
        } while (EnumNextMultiSz (&se));
    }
    FreePathString (pattern);
}


VOID
pEnvSave (
    IN      PCTSTR Pattern,
    IN OUT  PGROWLIST GrowList
    )
{
    MEMDB_ENUM e;
    PENVIRONMENT_ENTRY envEntry;
    UINT strSize;
    PBYTE listStruct;

    if (MemDbEnumFirst (&e, Pattern, ENUMFLAG_NORMAL, 0, ENUMLEVEL_ALLLEVELS)) {
        do {
            envEntry = (PENVIRONMENT_ENTRY) MemDbGetUnorderedBlob (e.FullKeyName, 0, NULL);

            strSize = SizeOfString (e.FullKeyName);
            listStruct = PmGetMemory (g_IsmPool, strSize + sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize);

            CopyMemory (listStruct, e.FullKeyName, strSize);
            CopyMemory (listStruct + strSize, envEntry, sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize);

            GlAppend (GrowList, listStruct, strSize + sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize);
            PmReleaseMemory (g_IsmPool, listStruct);
            MemDbReleaseMemory (envEntry);

        } while (MemDbEnumNext (&e));
    }
}


BOOL
EnvSaveEnvironment (
    IN OUT  PGROWLIST GrowList
    )
{
    pEnvSave (S_MEMDB_ENV_ROOT_SRC TEXT("\\*"), GrowList);
    pEnvSave (S_MEMDB_ENV_ROOT_DEST TEXT("\\*"), GrowList);

    return TRUE;
}


BOOL
EnvRestoreEnvironment (
    IN      PGROWLIST GrowList
    )
{
    UINT listSize, i;
    PBYTE listStruct;
    PCTSTR memdbName;
    PENVIRONMENT_ENTRY envEntry;

    listSize = GlGetSize (GrowList);

    for (i = 0; i < listSize; i ++) {

        listStruct = GlGetItem (GrowList, i);
        memdbName = (PCTSTR) listStruct;

        if (!MemDbTestKey (memdbName)) {
            envEntry = (PENVIRONMENT_ENTRY) (GetEndOfString ((PCTSTR) listStruct) + 1);
            if (!MemDbSetUnorderedBlob (
                    memdbName,
                    0,
                    (PBYTE) envEntry,
                    sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize
                    )) {
                EngineError ();
            }
        }
    }

    return TRUE;
}

BOOL
IsmSetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PENVENTRY_STRUCT VariableData   OPTIONAL
    )
{
    PCTSTR memdbName = NULL;
    BOOL result = FALSE;
    KEYHANDLE kh;
    PENVIRONMENT_ENTRY envEntry = NULL;
    UINT dataSize;
    PCVOID dataPtr;
    DATAHANDLE dh;
    BOOL destPlatform = FALSE;
#ifndef UNICODE
    PWSTR unicodeData = NULL;
#endif

    if ((Platform != PLATFORM_SOURCE) &&
        (Platform != PLATFORM_DESTINATION)
        ) {
        DEBUGMSG ((DBG_ERROR, "Environment variable specified with no platform."));
        return FALSE;
    }

    destPlatform = (Platform == PLATFORM_DESTINATION);

    __try {
        //
        // Validate arguments
        //

        if (!VariableName || !(*VariableName)) {
            DEBUGMSG ((DBG_ERROR, "Invalid variable name"));
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        //
        // Build decorated name by joining current group with variable name,
        // then build memdb key
        //

        memdbName = JoinPathsInPoolEx ((
                        NULL,
                        destPlatform?S_MEMDB_ENV_ROOT_DEST:S_MEMDB_ENV_ROOT_SRC,
                        Group?Group:VariableName,
                        Group?VariableName:NULL,
                        NULL
                        ));

        kh = MemDbSetKey (memdbName);
        if (!kh) {
            DEBUGMSG ((DBG_ERROR, "Error while adding environment variable into database"));
            EngineError ();
            __leave;
        }
        MemDbDeleteUnorderedBlobByKeyHandle (kh, 0);

        if (VariableData->Type == ENVENTRY_STRING) {
            if (VariableData->EnvString == NULL) {
                dataSize = sizeof (TCHAR);
                dataPtr = TEXT("");
            } else {
#ifdef UNICODE
                dataSize = SizeOfStringW (VariableData->EnvString);
                dataPtr = VariableData->EnvString;
#else
                dataSize = SizeOfStringA (VariableData->EnvString) * 2;
                unicodeData = IsmGetMemory (dataSize);
                if (unicodeData) {
                    ZeroMemory (unicodeData, dataSize);
                    DirectDbcsToUnicodeN (
                        unicodeData,
                        VariableData->EnvString,
                        SizeOfStringA (VariableData->EnvString)
                        );
                    dataSize = SizeOfStringW (unicodeData);
                    dataPtr = unicodeData;
                } else {
                    dataSize = sizeof (WCHAR);
                    dataPtr = L"";
                }
#endif
            }
        } else if (VariableData->Type == ENVENTRY_MULTISZ) {
            if (VariableData->MultiSz == NULL) {
                dataSize = sizeof (TCHAR);
                dataPtr = TEXT("");
            } else {
#ifdef UNICODE
                dataSize = SizeOfMultiSzW (VariableData->MultiSz);
                dataPtr = VariableData->MultiSz;
#else
                dataSize = SizeOfMultiSzA (VariableData->MultiSz) * 2;
                unicodeData = IsmGetMemory (dataSize);
                if (unicodeData) {
                    ZeroMemory (unicodeData, dataSize);
                    DirectDbcsToUnicodeN (
                        unicodeData,
                        VariableData->MultiSz,
                        SizeOfMultiSzA (VariableData->MultiSz)
                        );
                    dataSize = SizeOfMultiSzW (unicodeData);
                    dataPtr = unicodeData;
                } else {
                    dataSize = sizeof (WCHAR);
                    dataPtr = L"";
                }
#endif
            }
        } else if (VariableData->Type == ENVENTRY_CALLBACK) {
            dataSize = sizeof (PENVENTRYCALLBACK);
            dataPtr = (&VariableData->EnvCallback);
        } else if (VariableData->Type == ENVENTRY_BINARY) {
            dataSize = VariableData->EnvBinaryDataSize;
            dataPtr = VariableData->EnvBinaryData;
        } else {
            DEBUGMSG ((DBG_ERROR, "Invalid variable data type"));
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        envEntry = (PENVIRONMENT_ENTRY) MemAllocUninit (sizeof (ENVIRONMENT_ENTRY) + dataSize);
        envEntry->Type = VariableData->Type;
        envEntry->DataSize = dataSize;
        if (envEntry->DataSize) {
            CopyMemory (envEntry->Data, dataPtr, envEntry->DataSize);
        }

        dh = MemDbSetUnorderedBlob (memdbName, 0, (PBYTE) envEntry, sizeof (ENVIRONMENT_ENTRY) + envEntry->DataSize);

        result = (dh != 0);

        if (!result) {
            EngineError ();
        }
    }
    __finally {
        if (memdbName) {
            FreePathString (memdbName);
            memdbName = NULL;
        }

        if (envEntry) {
            FreeAlloc (envEntry);
            envEntry = NULL;
        }

#ifndef UNICODE
        if (unicodeData) {
            IsmReleaseMemory (unicodeData);
            unicodeData = NULL;
        }
#endif
    }

    return result;
}

BOOL
IsmSetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_STRING;
    envEntry.EnvString = VariableValue;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
IsmSetEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_MULTISZ;
    envEntry.MultiSz = VariableValue;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
IsmAppendEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    )
{
    ENVENTRY_STRUCT envEntry;
    ENVENTRY_TYPE type;
    KEYHANDLE kh = 0;
    UINT multiSzNeeded;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            &multiSzNeeded,
            &type
            )) {
        if (type != ENVENTRY_MULTISZ) {
            return FALSE;
        }
        g_AppendBuffer.End = 0;
        GbGrow (&g_AppendBuffer, multiSzNeeded);
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                g_AppendBuffer.Buf,
                multiSzNeeded,
                NULL,
                NULL
                )) {
            if (g_AppendBuffer.End) {
                g_AppendBuffer.End -= sizeof (TCHAR);
            }
            GbMultiSzAppend (&g_AppendBuffer, VariableValue);
            envEntry.Type = ENVENTRY_MULTISZ;
            envEntry.MultiSz = (PCTSTR) g_AppendBuffer.Buf;
            return IsmSetEnvironmentValue (
                        Platform,
                        Group,
                        VariableName,
                        &envEntry
                        );
        }
    } else {
        g_AppendBuffer.End = 0;
        GbMultiSzAppend (&g_AppendBuffer, VariableValue);
        envEntry.Type = ENVENTRY_MULTISZ;
        envEntry.MultiSz = (PCTSTR) g_AppendBuffer.Buf;
        return IsmSetEnvironmentValue (
                    Platform,
                    Group,
                    VariableName,
                    &envEntry
                    );
    }
    return FALSE;
}

BOOL
IsmAppendEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCTSTR VariableValue
    )
{
    ENVENTRY_STRUCT envEntry;
    ENVENTRY_TYPE type;
    KEYHANDLE kh = 0;
    UINT multiSzNeeded;
    MULTISZ_ENUM multiSzEnum;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            &multiSzNeeded,
            &type
            )) {
        if (type != ENVENTRY_MULTISZ) {
            return FALSE;
        }
        g_AppendBuffer.End = 0;
        GbGrow (&g_AppendBuffer, multiSzNeeded);
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                g_AppendBuffer.Buf,
                multiSzNeeded,
                NULL,
                NULL
                )) {
            if (g_AppendBuffer.End) {
                g_AppendBuffer.End -= sizeof (TCHAR);
            }
            if (EnumFirstMultiSz (&multiSzEnum, VariableValue)) {
                do {
                    GbMultiSzAppend (&g_AppendBuffer, multiSzEnum.CurrentString);
                } while (EnumNextMultiSz (&multiSzEnum));
            }
            envEntry.Type = ENVENTRY_MULTISZ;
            envEntry.MultiSz = (PCTSTR) g_AppendBuffer.Buf;
            return IsmSetEnvironmentValue (
                        Platform,
                        Group,
                        VariableName,
                        &envEntry
                        );
        }
    } else {
        envEntry.Type = ENVENTRY_MULTISZ;
        envEntry.MultiSz = VariableValue;
        return IsmSetEnvironmentValue (
                    Platform,
                    Group,
                    VariableName,
                    &envEntry
                    );
    }
    return FALSE;
}

BOOL
IsmSetEnvironmentCallback (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PENVENTRYCALLBACK VariableCallback
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_CALLBACK;
    envEntry.EnvCallback = VariableCallback;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
IsmSetEnvironmentData (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName,
    IN      PCBYTE VariableData,
    IN      UINT VariableDataSize
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_BINARY;
    envEntry.EnvBinaryData = VariableData;
    envEntry.EnvBinaryDataSize = VariableDataSize;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
IsmSetEnvironmentFlag (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                   OPTIONAL
    IN      PCTSTR VariableName
    )
{
    ENVENTRY_STRUCT envEntry;

    envEntry.Type = ENVENTRY_BINARY;
    envEntry.EnvBinaryData = NULL;
    envEntry.EnvBinaryDataSize = 0;
    return IsmSetEnvironmentValue (
                Platform,
                Group,
                VariableName,
                &envEntry
                );
}

BOOL
pGetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN OUT  KEYHANDLE *KeyHandle,       OPTIONAL
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE Data,                 OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded,       OPTIONAL
    OUT     PENVENTRY_TYPE DataType     OPTIONAL
    )
{
    PCTSTR memdbName = NULL;
    BOOL result = FALSE;
    KEYHANDLE kh = 0;
    PENVIRONMENT_ENTRY envEntry;
    UINT sizeNeeded;
    GROWBUFFER tempBuffer = INIT_GROWBUFFER;
    BOOL destPlatform = FALSE;
    UINT dataSize;
#ifndef UNICODE
    PSTR ansiData = NULL;
#endif

    if ((Platform != PLATFORM_SOURCE) &&
        (Platform != PLATFORM_DESTINATION)
        ) {
        DEBUGMSG ((DBG_ERROR, "Environment variable specified with no platform."));
        return FALSE;
    }

    destPlatform = (Platform == PLATFORM_DESTINATION);

    __try {
        //
        // IsmGetEnvironmentValue will call this worker with KeyHandle set to NULL, but
        // IsmGetEnvironmentString will call this worker with a valid KeyHandle. This
        // is done to eliminate double-validation and double-lookup of the memdb key.
        //

        if (!KeyHandle || !(*KeyHandle)) {
            //
            // Validate arguments
            //

            if (!VariableName || !(*VariableName)) {
                DEBUGMSG ((DBG_ERROR, "Can't get value of invalid variable name"));
                SetLastError (ERROR_INVALID_PARAMETER);
                __leave;
            }

            memdbName = JoinPathsInPoolEx ((
                            NULL,
                            destPlatform?S_MEMDB_ENV_ROOT_DEST:S_MEMDB_ENV_ROOT_SRC,
                            Group?Group:VariableName,
                            Group?VariableName:NULL,
                            NULL
                            ));

            kh = MemDbGetHandleFromKey (memdbName);

            if (KeyHandle) {
                *KeyHandle = kh;
            }

        } else {
            kh = *KeyHandle;
        }

        //
        // If no variable exists, return FALSE
        //

        if (!kh) {
            SetLastError (ERROR_SUCCESS);
            __leave;
        }

        //
        // Otherwise get the binary data
        //

        envEntry = NULL;

        if (!MemDbGetUnorderedBlobByKeyHandleEx (kh, 0, &tempBuffer, &sizeNeeded)) {
            //
            // No variable exists, return FALSE
            //
            if (DataSizeNeeded) {
                *DataSizeNeeded = 0;
            }
            if (DataType) {
                *DataType = ENVENTRY_NONE;
            }
            SetLastError (ERROR_SUCCESS);
            __leave;
        }

        envEntry = (PENVIRONMENT_ENTRY) tempBuffer.Buf;

        if (DataType) {
            *DataType = envEntry->Type;
        }

#ifdef UNICODE
        if (DataSizeNeeded) {
            *DataSizeNeeded = envEntry->DataSize;
        }

        if (DataSize) {
            if (DataSize < envEntry->DataSize) {
                SetLastError (ERROR_INSUFFICIENT_BUFFER);
            } else {
                CopyMemory (Data, envEntry->Data, envEntry->DataSize);
            }
        }
#else
        if (envEntry->Type == ENVENTRY_STRING) {

            dataSize = SizeOfStringW ((PCWSTR)envEntry->Data);
            ansiData = IsmGetMemory (dataSize);
            if (ansiData) {
                ZeroMemory (ansiData, dataSize);
                DirectUnicodeToDbcsN (
                    ansiData,
                    (PWSTR)envEntry->Data,
                    SizeOfStringW ((PCWSTR)envEntry->Data)
                    );

                dataSize = SizeOfStringA (ansiData);

                if (DataSizeNeeded) {
                    *DataSizeNeeded = dataSize;
                }

                if (DataSize) {
                    if (DataSize < dataSize) {
                        SetLastError (ERROR_INSUFFICIENT_BUFFER);
                    } else {
                        CopyMemory (Data, ansiData, dataSize);
                    }
                }
                IsmReleaseMemory (ansiData);
                ansiData = NULL;
            }

        } else if (envEntry->Type == ENVENTRY_MULTISZ) {

            dataSize = SizeOfMultiSzW ((PCWSTR)envEntry->Data);
            ansiData = IsmGetMemory (dataSize);
            if (ansiData) {
                ZeroMemory (ansiData, dataSize);
                DirectUnicodeToDbcsN (
                    ansiData,
                    (PWSTR)envEntry->Data,
                    SizeOfMultiSzW ((PCWSTR)envEntry->Data)
                    );

                dataSize = SizeOfMultiSzA (ansiData);

                if (DataSizeNeeded) {
                    *DataSizeNeeded = dataSize;
                }

                if (DataSize) {
                    if (DataSize < dataSize) {
                        SetLastError (ERROR_INSUFFICIENT_BUFFER);
                    } else {
                        CopyMemory (Data, ansiData, dataSize);
                    }
                }
                IsmReleaseMemory (ansiData);
                ansiData = NULL;
            }

        } else {

            if (DataSizeNeeded) {
                *DataSizeNeeded = envEntry->DataSize;
            }

            if (DataSize) {
                if (DataSize < envEntry->DataSize) {
                    SetLastError (ERROR_INSUFFICIENT_BUFFER);
                } else {
                    CopyMemory (Data, envEntry->Data, envEntry->DataSize);
                }
            }
        }
#endif
        result = TRUE;
    }
    __finally {

        if (memdbName) {
            FreePathString (memdbName);
            memdbName = NULL;
        }

        GbFree (&tempBuffer);
    }

    return result;
}

BOOL
IsmGetEnvironmentValue (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE Data,                 OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded,       OPTIONAL
    OUT     PENVENTRY_TYPE DataType     OPTIONAL
    )
{
    return pGetEnvironmentValue (
                Platform,
                NULL,
                Group,
                VariableName,
                Data,
                DataSize,
                DataSizeNeeded,
                DataType
                );
}

BOOL
IsmGetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PTSTR VariableValue,        OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            &type
            )) {
        if (type != ENVENTRY_STRING) {
            return FALSE;
        }
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                (PBYTE) VariableValue,
                DataSize,
                DataSizeNeeded,
                NULL
                )) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsmGetEnvironmentMultiSz (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PTSTR VariableValue,        OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            &type
            )) {
        if (type != ENVENTRY_MULTISZ) {
            return FALSE;
        }
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                (PBYTE) VariableValue,
                DataSize,
                DataSizeNeeded,
                NULL
                )) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsmGetEnvironmentCallback (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,                           OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PENVENTRYCALLBACK *VariableCallback     OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            &type
            )) {
        if (type != ENVENTRY_CALLBACK) {
            return FALSE;
        }
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                (PBYTE)VariableCallback,
                sizeof (PENVENTRYCALLBACK),
                NULL,
                NULL
                )) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsmGetEnvironmentData (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName,
    OUT     PBYTE VariableData,         OPTIONAL
    IN      UINT DataSize,
    OUT     PUINT DataSizeNeeded        OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            &type
            )) {
        if (type != ENVENTRY_BINARY) {
            return FALSE;
        }
        if (pGetEnvironmentValue (
                Platform,
                &kh,
                Group,
                VariableName,
                VariableData,
                DataSize,
                DataSizeNeeded,
                NULL
                )) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
IsmIsEnvironmentFlagSet (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName
    )
{
    KEYHANDLE kh = 0;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            VariableName,
            NULL,
            0,
            NULL,
            NULL
            )) {
        return TRUE;
    }
    return FALSE;
}

BOOL
IsmDeleteEnvironmentVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR VariableName
    )
{
    BOOL result = FALSE;
    PCTSTR memdbName = NULL;
    BOOL destPlatform = FALSE;

    if ((Platform != PLATFORM_SOURCE) &&
        (Platform != PLATFORM_DESTINATION)
        ) {
        DEBUGMSG ((DBG_ERROR, "Environment variable specified with no platform."));
        return FALSE;
    }

    destPlatform = (Platform == PLATFORM_DESTINATION);

    __try {
        //
        // Validate arguments
        //

        if (!(*VariableName)) {
            DEBUGMSG ((DBG_ERROR, "Invalid variable name"));
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        //
        // Build decorated name by joining current group with variable name,
        // then build memdb key
        //

        memdbName = JoinPathsInPoolEx ((
                        NULL,
                        destPlatform?S_MEMDB_ENV_ROOT_DEST:S_MEMDB_ENV_ROOT_SRC,
                        Group?Group:VariableName,
                        Group?VariableName:NULL,
                        NULL
                        ));

        //
        // Now delete the memdb key
        //

        result = MemDbDeleteKey (memdbName);
    }
    __finally {

        if (memdbName) {
            FreePathString (memdbName);
            memdbName = NULL;
        }
    }

    return result;
}

BOOL
pGetEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR EnvString,
    OUT     PTSTR EnvValue,             OPTIONAL
    IN      UINT EnvValueSize,
    OUT     PUINT EnvValueSizeNeeded,   OPTIONAL
    IN      PCTSTR EnvStringContext     OPTIONAL
    )
{
    KEYHANDLE kh = 0;
    ENVENTRY_TYPE type;
    PENVENTRYCALLBACK callback = NULL;
    TCHAR buffer[1024];
    UINT sizeNeeded;

    if (pGetEnvironmentValue (
            Platform,
            &kh,
            Group,
            EnvString,
            (PBYTE) buffer,
            sizeof (buffer),
            &sizeNeeded,
            &type
            )) {
        if (type == ENVENTRY_STRING) {
            if (!EnvValue) {
                if (EnvValueSizeNeeded) {
                    *EnvValueSizeNeeded = sizeNeeded;
                }
                return TRUE;
            }
            if ((sizeNeeded <= sizeof (buffer)) && (sizeNeeded <= EnvValueSize)) {
                StringCopy (EnvValue, buffer);
                if (EnvValueSizeNeeded) {
                    *EnvValueSizeNeeded = sizeNeeded;
                }
                return TRUE;
            }
            return pGetEnvironmentValue (
                        Platform,
                        &kh,
                        Group,
                        EnvString,
                        (PBYTE)EnvValue,
                        EnvValueSize,
                        EnvValueSizeNeeded,
                        NULL
                        );
        } else if (type == ENVENTRY_CALLBACK) {
            if (sizeNeeded == sizeof (PENVENTRYCALLBACK)) {
                callback = (PENVENTRYCALLBACK) buffer;
                return callback (
                            EnvString,
                            EnvValue,
                            EnvValueSize,
                            EnvValueSizeNeeded,
                            EnvStringContext
                            );
            }
        }
        return FALSE;
    }
    return FALSE;
}

PCTSTR
TrackedIsmExpandEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR SrcString,
    IN      PCTSTR Context
            TRACKING_DEF
    )
{
    UINT ch;
    PTSTR strCopy;
    PTSTR srcString;
    PTSTR envBegin = NULL;
    PTSTR envStrBegin;
    PTSTR envEnd;
    CHARTYPE savedCh;
    BOOL envMode = FALSE;
    UINT strSize;
    UINT maxSize;
    GROWBUFFER envBuff = INIT_GROWBUFFER;
    PCTSTR result = NULL;

    TRACK_ENTER();

    strCopy = PmDuplicateString (g_IsmPool, SrcString);
    srcString = strCopy;

    while (*srcString) {
        ch = _tcsnextc (srcString);
        if (ch == TEXT('%')) {
            if (envMode) {
                envEnd = srcString;
                envStrBegin = _tcsinc (envBegin);
                savedCh = *envEnd;
                *envEnd = 0;
                maxSize = (UINT) ((envBuff.Size - envBuff.End) * sizeof (TCHAR));
                if (pGetEnvironmentString (Platform, Group, envStrBegin, (PTSTR) (envBuff.Buf + envBuff.End), maxSize, &strSize, Context)) {
                    if (maxSize < strSize) {
                        pGetEnvironmentString (Platform, Group, envStrBegin, (PTSTR) GbGrow (&envBuff, strSize), strSize, &strSize, Context);
                    } else {
                        envBuff.End += strSize;
                    }
                    if (strSize) {
                        //we know that the routine above also adds the terminating null character
                        //so we need to pull it out.
                        envBuff.End -= sizeof (TCHAR);
                    }
                    *envEnd = (TCHAR) savedCh;
                } else {
                    *envEnd = (TCHAR) savedCh;
                    envEnd = _tcsinc (envEnd);
                    strSize = (UINT) ((envEnd - envBegin) * sizeof (TCHAR));
                    CopyMemory (GbGrow (&envBuff, strSize), envBegin, strSize);
                }
                envMode = FALSE;
            } else {
                envBegin = srcString;
                envMode = TRUE;
            }
            srcString = _tcsinc (srcString);
        } else {
            envEnd = _tcsinc (srcString);
            if (!envMode) {
                strSize = (UINT) ((envEnd - srcString) * sizeof (TCHAR));
                CopyMemory (GbGrow (&envBuff, strSize), srcString, strSize);
            }
            srcString = envEnd;
        }
    }
    if (envMode && envBegin) {
        strSize = (UINT) ((srcString - envBegin) * sizeof (TCHAR));
        CopyMemory (GbGrow (&envBuff, strSize), envBegin, strSize);
    }

    CopyMemory (GbGrow (&envBuff, sizeof (TCHAR)), srcString, sizeof (TCHAR));

    PmReleaseMemory (g_IsmPool, strCopy);

    result = PmDuplicateString (g_IsmPool, (PCTSTR) envBuff.Buf);
    GbFree (&envBuff);

    TRACK_LEAVE();

    return result;
}


BOOL
pDoesEnvExistOnOtherPlatform (
    IN      PCTSTR Group,
    IN      PCTSTR VariableName,
    IN      MIG_PLATFORMTYPEID Platform
    )
{
    BOOL result = FALSE;

    if (Platform == PLATFORM_SOURCE) {
        Platform = PLATFORM_DESTINATION;
    } else {
        Platform = PLATFORM_SOURCE;
    }
    result = pGetEnvironmentValue (
                Platform,
                NULL,
                Group,
                VariableName,
                NULL,
                0,
                NULL,
                NULL
                );
    return result;
}

PCTSTR
TrackedIsmCompressEnvironmentString (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Group,               OPTIONAL
    IN      PCTSTR SrcString,
    IN      PCTSTR Context,
    IN      BOOL MustExistOnOtherPlatform
            TRACKING_DEF
    )
{
    ENV_ENTRY_ENUM envEntryEnum;
    PCTSTR pattern = NULL;
    BOOL match = FALSE;
    DWORD matchLen = 0;
    DWORD matchLenTmp;
    PCTSTR envWack = NULL;
    PCTSTR varName = NULL;
    PCTSTR varValue = NULL;
    DWORD resultSize;
    PTSTR result = NULL;

    TRACK_ENTER();

    // let's enumerate all environment variables
    pattern = JoinPathsInPoolEx ((
                    NULL,
                    Group?Group:TEXT("*"),
                    Group?TEXT("*"):NULL,
                    NULL
                    ));
    if (EnvEnumerateFirstEntry (
            &envEntryEnum,
            Platform,
            pattern
            )) {
        do {
            switch (envEntryEnum.EnvEntryType) {
            case ENVENTRY_STRING:
                match = FALSE;
                if (StringIMatch (SrcString, (PCTSTR)envEntryEnum.EnvEntryData)) {
                    match = TRUE;
                }
                if (!match) {
                    envWack = JoinPaths (SrcString, TEXT("\\"));
                    if (envWack) {
                        if (StringIMatch (envWack, (PCTSTR)envEntryEnum.EnvEntryData)) {
                            match = TRUE;
                        }
                        FreePathString (envWack);
                    }
                }
                if (!match) {
                    envWack = JoinPaths ((PCTSTR)envEntryEnum.EnvEntryData, TEXT("\\"));
                    if (envWack) {
                        if (StringIPrefix (SrcString, envWack)) {
                            match = TRUE;
                        }
                    }
                    FreePathString (envWack);
                }
                if (match) {
                    // we have a match, let's see how big is the match and,
                    // if we need to, write down the env variable and its value
                    matchLenTmp = ByteCount ((PCTSTR)envEntryEnum.EnvEntryData);
                    if (matchLenTmp > matchLen) {
                        // Let's check if this env variable must exist on the other platform
                        if (!MustExistOnOtherPlatform ||
                            (pDoesEnvExistOnOtherPlatform (Group, envEntryEnum.EnvEntryName, Platform))
                            ) {
                            matchLen = matchLenTmp;
                            if (varName) {
                                IsmReleaseMemory (varName);
                            }
                            if (varValue) {
                                IsmReleaseMemory (varValue);
                            }
                            varName = IsmDuplicateString (envEntryEnum.EnvEntryName);
                            varValue = IsmDuplicateString ((PCTSTR)envEntryEnum.EnvEntryData);
                        }
                    }
                }
                break;
            default:
                break;
            }
        } while (EnvEnumerateNextEntry (&envEntryEnum));
    }
    if (matchLen && varName && varValue) {
        resultSize = ByteCount (TEXT("%")) +
                     ByteCount (varName) +
                     ByteCount (TEXT("%")) +
                     ByteCount (SrcString) -
                     matchLen +
                     2 * sizeof (TCHAR);
        result = (PTSTR)IsmGetMemory (resultSize);
        if (result) {
            StringCopy (result, TEXT("%"));
            StringCat (result, varName);
            StringCat (result, TEXT("%"));
            StringCat (result, (PCTSTR)((PBYTE)SrcString + matchLen));
        }
    }

    TRACK_LEAVE();

    return result;
}


BOOL
IsmSetTransportVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    IN      PCTSTR KeyData
    )
{
    PCTSTR variable;
    BOOL result = FALSE;

    if (!Section || !Key || !KeyData) {
        DEBUGMSG ((DBG_ERROR, "Section, key and key data are required for IsmSetTransportVariable"));
        return FALSE;
    }

    variable = JoinPaths (Section, Key);

    result = IsmSetEnvironmentString (Platform, S_TRANSPORT_PREFIX, variable, KeyData);

    FreePathString (variable);

    return result;
}


BOOL
IsmGetTransportVariable (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Section,
    IN      PCTSTR Key,
    OUT     PTSTR KeyData,                      OPTIONAL
    IN      UINT KeyDataBufferSizeInBytes
    )
{
    PCTSTR variable;
    BOOL result = FALSE;

    if (!Section || !Key) {
        DEBUGMSG ((DBG_ERROR, "Section, key and key data are required for IsmSetTransportVariable"));
        return FALSE;
    }

    variable = JoinPaths (Section, Key);

    result = IsmGetEnvironmentString (
                Platform,
                S_TRANSPORT_PREFIX,
                variable,
                KeyData,
                KeyDataBufferSizeInBytes,
                NULL
                );

    FreePathString (variable);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\filetype.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    filetype.c

Abstract:

    Implements all callbacks for file type

Author:

    Calin Negreanu (calinn) 09-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"
#include <winioctl.h>

#define DBG_FILETYPE        "FileType"

//
// Strings
//

// none

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

typedef struct {
    HANDLE FileHandle;
    HANDLE MapHandle;
} FILEACQUIREHANDLE, *PFILEACQUIREHANDLE;

//
// Globals
//

MIG_OBJECTTYPEID g_FileTypeId = 0;
GROWBUFFER g_FileConversionBuff = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

TYPE_ENUMFIRSTPHYSICALOBJECT EnumFirstPhysicalFile;
TYPE_ENUMNEXTPHYSICALOBJECT EnumNextPhysicalFile;
TYPE_ABORTENUMCURRENTPHYSICALNODE AbortEnumCurrentDir;
TYPE_ABORTENUMPHYSICALOBJECT AbortEnumPhysicalFile;
TYPE_CONVERTOBJECTTOMULTISZ ConvertFileToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToFile;
TYPE_GETNATIVEOBJECTNAME GetNativeFileName;
TYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalFile;
TYPE_RELEASEPHYSICALOBJECT ReleasePhysicalFile;
TYPE_DOESPHYSICALOBJECTEXIST DoesPhysicalFileExist;
TYPE_REMOVEPHYSICALOBJECT RemovePhysicalFile;
TYPE_CREATEPHYSICALOBJECT CreatePhysicalFile;
TYPE_REPLACEPHYSICALOBJECT ReplacePhysicalFile;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
pSetCompression (
    IN      PCTSTR NativePath
    )
{
    HANDLE fileHandle;
    USHORT compression = COMPRESSION_FORMAT_DEFAULT;
    DWORD bytesReturned;

    fileHandle = CreateFile (
                    NativePath,
                    GENERIC_READ|GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
    if (fileHandle != INVALID_HANDLE_VALUE) {
        DeviceIoControl (
            fileHandle,
            FSCTL_SET_COMPRESSION,
            &compression,
            sizeof (USHORT),
            NULL,
            0,
            &bytesReturned,
            NULL
            );
        CloseHandle (fileHandle);
    }

    return FALSE;
}

BOOL
pFileTypeEnumWorker (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PFILETREE_ENUM handle;

    handle = (PFILETREE_ENUM) EnumPtr->EtmHandle;

    EnumPtr->ObjectName = handle->EncodedFullName;
    EnumPtr->NativeObjectName = handle->NativeFullName;
    EnumPtr->Level = handle->CurrentLevel;
    EnumPtr->SubLevel = handle->CurrentLevel - handle->FileEnumInfo.RootLevel;
    EnumPtr->IsNode = (handle->Attributes & FILE_ATTRIBUTE_DIRECTORY);
    EnumPtr->IsLeaf = !EnumPtr->IsNode;
    if (EnumPtr->IsNode) {
        EnumPtr->ObjectNode = EnumPtr->NativeObjectName;
        EnumPtr->ObjectLeaf = NULL;
    } else {
        EnumPtr->ObjectNode = handle->Location;
        EnumPtr->ObjectLeaf = handle->Name;
    }

    MYASSERT ((EnumPtr->ObjectTypeId & ~PLATFORM_MASK) == g_FileTypeId);
    EnumPtr->Details.DetailsData = &handle->LastNode->FindData;

    return TRUE;
}

BOOL
EnumFirstPhysicalFile (
    PMIG_TYPEOBJECTENUM EnumPtr,
    MIG_OBJECTSTRINGHANDLE Pattern,
    UINT MaxLevel
    )
{
    PFILETREE_ENUM handle;
    BOOL result;

    if (!Pattern) {
        return FALSE;
    }

    handle = (PFILETREE_ENUM) IsmGetMemory (sizeof (FILETREE_ENUM));
    EnumPtr->EtmHandle = (LONG_PTR) handle;

    EnumPtr->Details.DetailsSize = sizeof (WIN32_FIND_DATA);

    result = EnumFirstFileInTreeEx (
                handle,
                Pattern,
                DRIVEENUM_FIXED,
                TRUE,
                TRUE,
                TRUE,
                TRUE,
                MaxLevel == NODE_LEVEL_MAX ? FILEENUM_ALL_SUBLEVELS : MaxLevel,
                FALSE,
                NULL
                );

    if (result) {
        result = pFileTypeEnumWorker (EnumPtr);
    } else {
        AbortEnumPhysicalFile (EnumPtr);
    }

    return result;
}

BOOL
EnumNextPhysicalFile (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PFILETREE_ENUM handle;
    BOOL result;

    handle = (PFILETREE_ENUM) EnumPtr->EtmHandle;

    result = EnumNextFileInTree (handle);

    if (result) {
        result = pFileTypeEnumWorker (EnumPtr);
    } else {
        AbortEnumPhysicalFile (EnumPtr);
    }

    return result;
}

VOID
AbortEnumCurrentDir (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PFILETREE_ENUM handle;

    handle = (PFILETREE_ENUM) EnumPtr->EtmHandle;

    if (handle) {
        handle->ControlFlags |= FECF_SKIPSUBDIRS|FECF_SKIPFILES;
    }
}

VOID
AbortEnumPhysicalFile (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    )
{
    PFILETREE_ENUM handle;

    handle = (PFILETREE_ENUM) EnumPtr->EtmHandle;

    if (handle) {
        AbortEnumFileInTree (handle);
        IsmReleaseMemory (handle);
    }

    ZeroMemory (EnumPtr, sizeof (MIG_TYPEOBJECTENUM));
}

PCTSTR
ConvertFileToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node, leaf;
    PWIN32_FIND_DATAW findData;
    DWORD size;
    PTSTR result = NULL;
    BOOL bresult = TRUE;
    PCSTR convertedStr;
    TCHAR buff[3];

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {

        g_FileConversionBuff.End = 0;

        GbCopyString (&g_FileConversionBuff, TEXT("\""));
        GbAppendString (&g_FileConversionBuff, node);
        if (leaf) {
            GbAppendString (&g_FileConversionBuff, TEXT("\\"));
            GbAppendString (&g_FileConversionBuff, leaf);
            GbAppendString (&g_FileConversionBuff, TEXT("\""));
        } else {
            GbAppendString (&g_FileConversionBuff, TEXT("\""));
        }

        MYASSERT (ObjectContent->Details.DetailsSize == sizeof (WIN32_FIND_DATAW));
        if ((ObjectContent->Details.DetailsSize == sizeof (WIN32_FIND_DATAW)) &&
            (ObjectContent->Details.DetailsData)
            ) {

            // let's save the WIN32_FIND_DATAW structure
            findData = (PWIN32_FIND_DATAW)ObjectContent->Details.DetailsData;
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->dwFileAttributes
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftCreationTime.dwLowDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftCreationTime.dwHighDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftLastAccessTime.dwLowDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftLastAccessTime.dwHighDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftLastWriteTime.dwLowDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->ftLastWriteTime.dwHighDateTime
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->nFileSizeHigh
                );
            wsprintf (
                (PTSTR) GbGrow (&g_FileConversionBuff, (sizeof (DWORD) * 2 + 3) * sizeof (TCHAR)),
                TEXT("0x%08X"),
                findData->nFileSizeLow
                );
#ifdef UNICODE
            GbCopyQuotedString (&g_FileConversionBuff, findData->cFileName);
            GbCopyQuotedString (&g_FileConversionBuff, findData->cAlternateFileName);
#else
            convertedStr = ConvertWtoA (findData->cFileName);
            if (convertedStr) {
                GbCopyQuotedString (&g_FileConversionBuff, convertedStr);
                FreeConvertedStr (convertedStr);
            } else {
                GbCopyQuotedString (&g_FileConversionBuff, TEXT(""));
            }
            convertedStr = ConvertWtoA (findData->cAlternateFileName);
            if (convertedStr) {
                GbCopyQuotedString (&g_FileConversionBuff, convertedStr);
                FreeConvertedStr (convertedStr);
            } else {
                GbCopyQuotedString (&g_FileConversionBuff, TEXT(""));
            }
#endif
            if ((!ObjectContent->ContentInFile) &&
                (ObjectContent->MemoryContent.ContentSize) &&
                (ObjectContent->MemoryContent.ContentBytes)
                ) {
                // write it in binary format
                size = 0;
                while (size < ObjectContent->MemoryContent.ContentSize) {
                    wsprintf (
                        buff,
                        TEXT("%2X"),
                        ObjectContent->MemoryContent.ContentBytes [size]
                        );
                    GbCopyString (&g_FileConversionBuff, buff);
                    size ++;
                }
            }

        } else {
            bresult = FALSE;
        }

        if (bresult) {
            GbCopyString (&g_FileConversionBuff, TEXT(""));
            result = IsmGetMemory (g_FileConversionBuff.End);
            CopyMemory (result, g_FileConversionBuff.Buf, g_FileConversionBuff.End);
        }

        g_FileConversionBuff.End = 0;

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToFile (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
#define indexFile   0
#define indexAttr   1
#define indexCtLdt  2
#define indexCtHdt  3
#define indexAtLdt  4
#define indexAtHdt  5
#define indexWtLdt  6
#define indexWtHdt  7
#define indexFsh    8
#define indexFsl    9
#define indexCFile  10
#define indexAFile  11
#define indexData   12
    MULTISZ_ENUM multiSzEnum;
    PCTSTR file = NULL;
    WIN32_FIND_DATAW findData;
    DWORD dummy;
    PTSTR filePtr, dirPtr;
    UINT index;

    g_FileConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    ZeroMemory (&findData, sizeof (WIN32_FIND_DATAW));

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        index = 0;
        do {
            if (index == indexFile) {
                file = multiSzEnum.CurrentString;
            }
            if (index == indexAttr) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.dwFileAttributes));
            }
            if (index == indexCtLdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftCreationTime.dwLowDateTime));
            }
            if (index == indexCtHdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftCreationTime.dwHighDateTime));
            }
            if (index == indexAtLdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftLastAccessTime.dwLowDateTime));
            }
            if (index == indexAtHdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftLastAccessTime.dwHighDateTime));
            }
            if (index == indexWtLdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftLastWriteTime.dwLowDateTime));
            }
            if (index == indexWtHdt) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.ftLastWriteTime.dwHighDateTime));
            }
            if (index == indexFsh) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.nFileSizeHigh));
            }
            if (index == indexFsl) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &(findData.nFileSizeLow));
            }
            if (index == indexCFile) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
#ifdef UNICODE
                    StringCopyTcharCount (findData.cFileName, multiSzEnum.CurrentString, MAX_PATH);
#else
                    DirectDbcsToUnicodeN (findData.cFileName, multiSzEnum.CurrentString, MAX_PATH);
#endif
                }
            }
            if (index == indexAFile) {
                if (!StringIMatch (multiSzEnum.CurrentString, TEXT("<empty>"))) {
#ifdef UNICODE
                    StringCopyTcharCount (findData.cAlternateFileName, multiSzEnum.CurrentString, 14);
#else
                    DirectDbcsToUnicodeN (findData.cAlternateFileName, multiSzEnum.CurrentString, 14);
#endif
                }
            }
            if (index >= indexData) {
                _stscanf (multiSzEnum.CurrentString, TEXT("%lx"), &dummy);
                *((PBYTE)GbGrow (&g_FileConversionBuff, sizeof (BYTE))) = (BYTE)dummy;
            }
            index ++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!file) {
        return FALSE;
    }

    if (ObjectContent) {

        ObjectContent->ObjectTypeId = MIG_FILE_TYPE;

        if (g_FileConversionBuff.End == 0) {
            ObjectContent->ContentInFile = TRUE;
            ObjectContent->FileContent.ContentSize = ((LONGLONG) findData.nFileSizeHigh << 32) | findData.nFileSizeLow;
        } else {
            ObjectContent->ContentInFile = FALSE;
            ObjectContent->MemoryContent.ContentSize = g_FileConversionBuff.End;
            ObjectContent->MemoryContent.ContentBytes = IsmGetMemory (ObjectContent->MemoryContent.ContentSize);
            CopyMemory (
                (PBYTE)ObjectContent->MemoryContent.ContentBytes,
                g_FileConversionBuff.Buf,
                ObjectContent->MemoryContent.ContentSize
                );
            g_FileConversionBuff.End = 0;
        }

        ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATAW);
        ObjectContent->Details.DetailsData = IsmGetMemory (sizeof (WIN32_FIND_DATAW));
        CopyMemory ((PBYTE)ObjectContent->Details.DetailsData, &findData, sizeof (WIN32_FIND_DATAW));
    }

    if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        *ObjectName = IsmCreateObjectHandle (file, NULL);
    } else {
        dirPtr = DuplicatePathString (file, 0);
        filePtr = _tcsrchr (dirPtr, TEXT('\\'));
        if (filePtr) {
            *filePtr = 0;
            filePtr ++;
        }
        *ObjectName = IsmCreateObjectHandle (dirPtr, filePtr);
        FreePathString (dirPtr);
    }

    return TRUE;
}

PCTSTR
GetNativeFileName (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PCTSTR node = NULL, leaf = NULL, tmp = NULL;
    UINT size;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        if (node) {
            tmp = JoinPaths (node, leaf);
        } else {
            tmp = DuplicatePathString (leaf, 0);
        }
        if (tmp) {
            size = SizeOfString (tmp);
            if (size) {
                result = IsmGetMemory (size);
                CopyMemory (result, tmp, size);
            }
            FreePathString (tmp);
        }
        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }
    return result;
}

BOOL
pIsDriveOnly (
    IN      PCTSTR FileName
    )
{
    return (FileName && FileName[0] && (FileName[1]==TEXT(':')) && (!FileName[2]));
}

BOOL
AcquirePhysicalFile (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PFILEACQUIREHANDLE handle;
    PWIN32_FIND_DATA findData;
#ifndef UNICODE
    PWIN32_FIND_DATAW findDataW;
#endif
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    BOOL result = FALSE;

    __try {

        handle = IsmGetMemory (sizeof (FILEACQUIREHANDLE));
        ZeroMemory (handle, sizeof (FILEACQUIREHANDLE));
        ObjectContent->EtmHandle = handle;

        findData = IsmGetMemory (sizeof (WIN32_FIND_DATA));
        ZeroMemory (findData, sizeof (WIN32_FIND_DATA));
        ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATA);
        ObjectContent->Details.DetailsData = findData;

        ObsSplitObjectString (ObjectName, &node, &leaf);
        nativeFileName = JoinPaths (node, leaf);

        if (!nativeFileName) {
            __leave;
        }

        if (pIsDriveOnly (nativeFileName)) {
            switch (ContentType) {
                case CONTENTTYPE_MEMORY:
                    ObjectContent->ContentInFile = FALSE;
                    result = TRUE;
                    break;
                case CONTENTTYPE_DETAILS_ONLY:
                case CONTENTTYPE_FILE:
                case CONTENTTYPE_ANY:
                    ObjectContent->ContentInFile = TRUE;
                    result = TRUE;
                    break;
                default:
                    DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in AcquirePhysicalFile: %d", ContentType));
            }
            findData->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
            StringCopy (findData->cFileName, nativeFileName);
            StringCopy (findData->cAlternateFileName, nativeFileName);

        } else if (DoesFileExistEx (nativeFileName, findData)) {
            if (findData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                switch (ContentType) {
                    case CONTENTTYPE_MEMORY:
                        ObjectContent->ContentInFile = FALSE;
                        result = TRUE;
                        break;
                    case CONTENTTYPE_DETAILS_ONLY:
                    case CONTENTTYPE_FILE:
                    case CONTENTTYPE_ANY:
                        ObjectContent->ContentInFile = TRUE;
                        result = TRUE;
                        break;
                    default:
                        DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in AcquirePhysicalFile: %d", ContentType));
                }
            } else {
                switch (ContentType) {
                    case CONTENTTYPE_MEMORY:
                        ObjectContent->ContentInFile = FALSE;
                        if ((!MemoryContentLimit) ||
                            ((MemoryContentLimit >= findData->nFileSizeLow) &&
                             (!findData->nFileSizeHigh)
                             )
                            ) {

                            ObjectContent->MemoryContent.ContentBytes = MapFileIntoMemory (
                                                                            nativeFileName,
                                                                            &handle->FileHandle,
                                                                            &handle->MapHandle
                                                                            );
                            if (ObjectContent->MemoryContent.ContentBytes) {
                                ObjectContent->MemoryContent.ContentSize = findData->nFileSizeLow;
                                result = TRUE;
                            } else {
                                if (findData->nFileSizeLow == 0) {
                                    result = TRUE;
                                }
                            }
                        }
                        break;
                    case CONTENTTYPE_DETAILS_ONLY:
                    case CONTENTTYPE_FILE:
                    case CONTENTTYPE_ANY:
                        ObjectContent->ContentInFile = TRUE;
                        ObjectContent->FileContent.ContentPath = PmDuplicateString (g_IsmPool, nativeFileName);
                        ObjectContent->FileContent.ContentSize = (LONGLONG) ((PWIN32_FIND_DATA)(ObjectContent->Details.DetailsData))->nFileSizeLow +
                                                                ((LONGLONG) ((PWIN32_FIND_DATA)(ObjectContent->Details.DetailsData))->nFileSizeHigh * 0x100000000);
                        result = TRUE;
                        break;
                    default:
                        DEBUGMSG ((DBG_WHOOPS, "Illegal ContentType in AcquirePhysicalFile: %d", ContentType));
                }
            }
        }
    }
    __finally {
        if (nativeFileName) {
            FreePathString (nativeFileName);
            nativeFileName = NULL;
        }

        ObsFree (node);
        node = NULL;

        ObsFree (leaf);
        leaf = NULL;
    }

    if (!result) {
        IsmReleaseMemory (findData);
        findData = NULL;
        IsmReleaseMemory (handle);
        handle = NULL;
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    } else {
#ifndef UNICODE
        // we need to convert the ANSI findData into UNICODE one
        findDataW = IsmGetMemory (sizeof (WIN32_FIND_DATAW));
        if (findDataW) {
            findDataW->dwFileAttributes = findData->dwFileAttributes;
            CopyMemory (&(findDataW->ftCreationTime), &(findData->ftCreationTime), sizeof (FILETIME));
            CopyMemory (&(findDataW->ftLastAccessTime), &(findData->ftLastAccessTime), sizeof (FILETIME));
            CopyMemory (&(findDataW->ftLastWriteTime), &(findData->ftLastWriteTime), sizeof (FILETIME));
            findDataW->nFileSizeHigh = findData->nFileSizeHigh;
            findDataW->nFileSizeLow = findData->nFileSizeLow;
            findDataW->dwReserved0 = findData->dwReserved0;
            findDataW->dwReserved1 = findData->dwReserved1;
            DirectDbcsToUnicodeN (findDataW->cFileName, findData->cFileName, MAX_PATH);
            DirectDbcsToUnicodeN (findDataW->cAlternateFileName, findData->cAlternateFileName, 14);
            ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATAW);
            ObjectContent->Details.DetailsData = findDataW;
            IsmReleaseMemory (findData);
        } else {
            IsmReleaseMemory (findData);
            ObjectContent->Details.DetailsSize = 0;
            ObjectContent->Details.DetailsData = NULL;
        }
#endif
    }
    return result;
}

BOOL
ReleasePhysicalFile (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    PFILEACQUIREHANDLE handle;
    BOOL result = TRUE;

    handle = (PFILEACQUIREHANDLE) ObjectContent->EtmHandle;

    if (handle) {
        if (ObjectContent->ContentInFile) {
            if (ObjectContent->FileContent.ContentPath) {
                IsmReleaseMemory (ObjectContent->FileContent.ContentPath);
            }
        } else {
            if (ObjectContent->MemoryContent.ContentBytes) {
                if (handle->FileHandle && handle->MapHandle) {
                    UnmapFile (
                        ObjectContent->MemoryContent.ContentBytes,
                        handle->MapHandle,
                        handle->FileHandle
                        );
                }
            }
        }
        IsmReleaseMemory (handle);
    }
    if (ObjectContent->Details.DetailsData) {
        IsmReleaseMemory (ObjectContent->Details.DetailsData);
    }
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    return result;
}

BOOL
DoesPhysicalFileExist (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    BOOL result;

    ObsSplitObjectString (ObjectName, &node, &leaf);
    nativeFileName = JoinPaths (node, leaf);

    if (pIsDriveOnly (nativeFileName)) {
        result = TRUE;
    } else {
        result = DoesFileExist (nativeFileName);
    }

    FreePathString (nativeFileName);
    nativeFileName = NULL;

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    return result;
}

BOOL
RemovePhysicalFile (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    WIN32_FIND_DATA findData;
    BOOL result = FALSE;

    ObsSplitObjectString (ObjectName, &node, &leaf);
    nativeFileName = JoinPaths (node, leaf);

    if (pIsDriveOnly (nativeFileName)) {
        result = TRUE;
    } else if (DoesFileExistEx (nativeFileName, &findData)) {
        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            // we do attempt to remove empty directories.
            // there is no problem in recording an operation that
            // will potentially fail (if the dir is not empty).
            IsmRecordOperation (
                JRNOP_DELETE,
                g_FileTypeId,
                ObjectName
                );

            result = RemoveDirectory (nativeFileName);
        } else {
            if (SetFileAttributes (nativeFileName, FILE_ATTRIBUTE_NORMAL)) {

                // record file deletion
                IsmRecordOperation (
                    JRNOP_DELETE,
                    g_FileTypeId,
                    ObjectName
                    );

                result = DeleteFile (nativeFileName);
            } else {
                PushError ();
                SetFileAttributes (nativeFileName, findData.dwFileAttributes);
                PopError ();
            }
        }
    } else {
        SetLastError (ERROR_FILE_NOT_FOUND);
    }

    PushError ();

    FreePathString (nativeFileName);
    nativeFileName = NULL;

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

BOOL
pTrackedCreateDirectory (
    IN      PCTSTR DirName
    )
{
    MIG_OBJECTSTRINGHANDLE objectName;
    PTSTR pathCopy;
    PTSTR p;
    BOOL result = TRUE;

    pathCopy = DuplicatePathString (DirName, 0);

    //
    // Advance past first directory
    //

    if (pathCopy[1] == TEXT(':') && pathCopy[2] == TEXT('\\')) {
        //
        // <drive>:\ case
        //

        p = _tcschr (&pathCopy[3], TEXT('\\'));

    } else if (pathCopy[0] == TEXT('\\') && pathCopy[1] == TEXT('\\')) {

        //
        // UNC case
        //

        p = _tcschr (pathCopy + 2, TEXT('\\'));
        if (p) {
            p = _tcschr (p + 1, TEXT('\\'));
        }

    } else {

        //
        // Relative dir case
        //

        p = _tcschr (pathCopy, TEXT('\\'));
    }

    //
    // Make all directories along the path
    //

    while (p) {

        *p = 0;

        if (!DoesFileExist (pathCopy)) {

            // record directory creation
            objectName = IsmCreateObjectHandle (pathCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_FileTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            result = CreateDirectory (pathCopy, NULL);
            if (!result) {
                break;
            }
        }

        *p = TEXT('\\');
        p = _tcschr (p + 1, TEXT('\\'));
    }

    //
    // At last, make the FullPath directory
    //

    if (result) {
        if (!DoesFileExist (pathCopy)) {

            // record directory creation
            objectName = IsmCreateObjectHandle (pathCopy, NULL);
            IsmRecordOperation (
                JRNOP_CREATE,
                g_FileTypeId,
                objectName
                );
            IsmDestroyObjectHandle (objectName);

            result = CreateDirectory (pathCopy, NULL);
        } else {
            result = FALSE;
            SetLastError (ERROR_ALREADY_EXISTS);
        }
    }

    FreePathString (pathCopy);

    return result;
}

BOOL
pSetFileTime (
    IN      PCTSTR FileName,
    IN      FILETIME *CreationTime,
    IN      FILETIME *LastAccessTime,
    IN      FILETIME *LastWriteTime
    )
{
    HANDLE fileHandle;
    BOOL result = FALSE;

    fileHandle = BfOpenFile (FileName);
    if (fileHandle) {
        result = SetFileTime (fileHandle, CreationTime, LastAccessTime, LastWriteTime);
        CloseHandle (fileHandle);
    }
    return result;
}

BOOL
CreatePhysicalFile (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    PWIN32_FIND_DATAW findData;
    HANDLE fileHandle;
    BOOL result = FALSE;
    DWORD attribs;

    if (!ObjectContent) {
        return FALSE;
    }

    ObsSplitObjectString (ObjectName, &node, &leaf);
    nativeFileName = JoinPaths (node, leaf);

    findData = (PWIN32_FIND_DATAW) (ObjectContent->Details.DetailsData);
    MYASSERT (findData);

    if (pIsDriveOnly (nativeFileName)) {
        result = TRUE;
    } else {
        if (!DoesFileExist (nativeFileName)) {

            if (findData) {
                if (findData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if (pTrackedCreateDirectory (nativeFileName)) {
                        result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                        if (!result) {
                            PushError ();
                            RemoveDirectory (nativeFileName);
                            PopError ();
                        }
                        if (result) {
                            if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                                pSetCompression (nativeFileName);
                            }
                        }
                        if (result) {
                            pSetFileTime (
                                nativeFileName,
                                &findData->ftCreationTime,
                                &findData->ftLastAccessTime,
                                &findData->ftLastWriteTime
                                );
                        }
                    }
                } else {
                    if (ObjectContent->ContentInFile) {

                        pTrackedCreateDirectory (node);

                        // record file creation
                        IsmRecordOperation (
                            JRNOP_CREATE,
                            g_FileTypeId,
                            ObjectName
                            );

                        if (ObjectContent->FileContent.ContentPath) {
                            if (CopyFile (ObjectContent->FileContent.ContentPath, nativeFileName, TRUE)) {

                                result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                                if (!result) {
                                    PushError ();
                                    DeleteFile (nativeFileName);
                                    PopError ();
                                }
                                if (result) {
                                    if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                                        pSetCompression (nativeFileName);
                                    }
                                }
                                if (result) {
                                    pSetFileTime (
                                        nativeFileName,
                                        &findData->ftCreationTime,
                                        &findData->ftLastAccessTime,
                                        &findData->ftLastWriteTime
                                        );
                                }
                            }
                        } else {
                            // just an empty  file
                            fileHandle = BfCreateFile (nativeFileName);
                            if (fileHandle) {

                                CloseHandle (fileHandle);
                                result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                                if (!result) {
                                    PushError ();
                                    DeleteFile (nativeFileName);
                                    PopError ();
                                }
                                if (result) {
                                    if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                                        pSetCompression (nativeFileName);
                                    }
                                }
                                if (result) {
                                    pSetFileTime (
                                        nativeFileName,
                                        &findData->ftCreationTime,
                                        &findData->ftLastAccessTime,
                                        &findData->ftLastWriteTime
                                        );
                                }
                            }
                        }
                    } else {
                        pTrackedCreateDirectory (node);

                        // record file creation
                        IsmRecordOperation (
                            JRNOP_CREATE,
                            g_FileTypeId,
                            ObjectName
                            );

                        fileHandle = BfCreateFile (nativeFileName);
                        if (fileHandle) {

                            result = BfWriteFile (fileHandle, ObjectContent->MemoryContent.ContentBytes, ObjectContent->MemoryContent.ContentSize);
                            CloseHandle (fileHandle);

                            if (!result) {
                                DeleteFile (nativeFileName);
                            } else {
                                result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                                if (!result) {
                                    PushError ();
                                    DeleteFile (nativeFileName);
                                    PopError ();
                                }
                                if (result) {
                                    if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                                        pSetCompression (nativeFileName);
                                    }
                                }
                                if (result) {
                                    pSetFileTime (
                                        nativeFileName,
                                        &findData->ftCreationTime,
                                        &findData->ftLastAccessTime,
                                        &findData->ftLastWriteTime
                                        );
                                }
                            }
                        }
                    }
                }
            } else {
                SetLastError (ERROR_INVALID_DATA);
            }
        } else {
            SetLastError (ERROR_ALREADY_EXISTS);
        }
    }

    PushError ();

    FreePathString (nativeFileName);
    nativeFileName = NULL;

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

BOOL
ReplacePhysicalFile (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PTSTR node = NULL;
    PTSTR leaf = NULL;
    PTSTR nativeFileName = NULL;
    PWIN32_FIND_DATAW findData;
    BOOL result = FALSE;
    DWORD attribs;

    if (!ObjectContent) {
        return FALSE;
    }

    ObsSplitObjectString (ObjectName, &node, &leaf);
    nativeFileName = JoinPaths (node, leaf);

    findData = (PWIN32_FIND_DATAW) (ObjectContent->Details.DetailsData);
    MYASSERT (findData);

    if (pIsDriveOnly (nativeFileName)) {
        result = TRUE;
    } else {
        if (leaf) {
            result = TRUE;
            if (DoesPhysicalFileExist (ObjectName)) {
                result = RemovePhysicalFile (ObjectName);
            }
            if (result) {
                result = CreatePhysicalFile (ObjectName, ObjectContent);
            }
        } else {
            if (DoesPhysicalFileExist (ObjectName)) {
                if (findData) {
                    result = SetFileAttributes (nativeFileName, findData->dwFileAttributes);
                    if (result) {
                        if (findData->dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
                            pSetCompression (nativeFileName);
                        }
                    }
                    if (result) {
                        pSetFileTime (
                            nativeFileName,
                            &findData->ftCreationTime,
                            &findData->ftLastAccessTime,
                            &findData->ftLastWriteTime
                            );
                    }
                } else {
                    SetLastError (ERROR_INVALID_DATA);
                }
            } else {
                result = CreatePhysicalFile (ObjectName, ObjectContent);
            }
        }
    }

    PushError ();

    FreePathString (nativeFileName);
    nativeFileName = NULL;

    ObsFree (node);
    node = NULL;

    ObsFree (leaf);
    leaf = NULL;

    PopError ();

    return result;
}

VOID
InitFileType (
    VOID
    )
{
    TYPE_REGISTER fileTypeData;

    ZeroMemory (&fileTypeData, sizeof (TYPE_REGISTER));
    fileTypeData.Priority = PRIORITY_FILE;
    fileTypeData.EnumFirstPhysicalObject = EnumFirstPhysicalFile;
    fileTypeData.EnumNextPhysicalObject = EnumNextPhysicalFile;
    fileTypeData.AbortEnumCurrentPhysicalNode = AbortEnumCurrentDir;
    fileTypeData.AbortEnumPhysicalObject = AbortEnumPhysicalFile;
    fileTypeData.ConvertObjectToMultiSz = ConvertFileToMultiSz;
    fileTypeData.ConvertMultiSzToObject = ConvertMultiSzToFile;
    fileTypeData.GetNativeObjectName = GetNativeFileName;
    fileTypeData.AcquirePhysicalObject = AcquirePhysicalFile;
    fileTypeData.ReleasePhysicalObject = ReleasePhysicalFile;
    fileTypeData.DoesPhysicalObjectExist = DoesPhysicalFileExist;
    fileTypeData.RemovePhysicalObject = RemovePhysicalFile;
    fileTypeData.CreatePhysicalObject = CreatePhysicalFile;
    fileTypeData.ReplacePhysicalObject = ReplacePhysicalFile;

    g_FileTypeId = IsmRegisterObjectType (
                        S_FILETYPE,
                        TRUE,
                        FALSE,
                        &fileTypeData
                        );
    MYASSERT (g_FileTypeId);
}

VOID
DoneFileType (
    VOID
    )
{
    GbFree (&g_FileConversionBuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\datatype.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    datatype.c

Abstract:

    Implements all callbacks for data type

Author:

    Calin Negreanu (calinn) 09-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_DATATYPE        "DataType"

//
// Strings
//

// none

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// none

//
// Globals
//

MIG_OBJECTTYPEID g_DataTypeId = 0;
HASHTABLE g_DataTable = NULL;
GROWBUFFER g_DataConversionBuff = INIT_GROWBUFFER;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

TYPE_CONVERTOBJECTTOMULTISZ ConvertDataToMultiSz;
TYPE_CONVERTMULTISZTOOBJECT ConvertMultiSzToData;
TYPE_ACQUIREPHYSICALOBJECT AcquirePhysicalData;
TYPE_RELEASEPHYSICALOBJECT ReleasePhysicalData;

//
// Macro expansion definition
//

// None

//
// Code
//

BOOL
DataTypeAddObject (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR ObjectLocation,
    IN      BOOL MakePersistent
    )
{
    PCTSTR objectLocation;
    BOOL result = TRUE;

    objectLocation = DuplicatePathString (ObjectLocation, 0);
    HtAddStringEx (g_DataTable, ObjectName, &objectLocation, FALSE);
    if (MakePersistent) {
        result = IsmMakePersistentObject (g_DataTypeId, ObjectName);
    }

    return result;
}

BOOL
AcquirePhysicalData (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    OUT     PMIG_CONTENT ObjectContent,
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit
    )
{
    PTSTR objectLocation;
    HASHITEM rc;
    PWIN32_FIND_DATA findData;
#ifndef UNICODE
    PWIN32_FIND_DATAW findDataW;
#endif
    BOOL result = FALSE;

    ObjectContent->Details.DetailsSize = 0;
    ObjectContent->Details.DetailsData = NULL;

    rc = HtFindStringEx (g_DataTable, ObjectName, &objectLocation, FALSE);
    if (rc) {
        if ((ContentType == CONTENTTYPE_ANY) ||
            (ContentType == CONTENTTYPE_FILE) ||
            (ContentType == CONTENTTYPE_DETAILS_ONLY)
            ) {
            ObjectContent->ContentInFile = TRUE;
            ObjectContent->FileContent.ContentPath = objectLocation;
            ObjectContent->FileContent.ContentSize = BfGetFileSize (objectLocation);

            findData = IsmGetMemory (sizeof (WIN32_FIND_DATA));
            if (findData) {
                ZeroMemory (findData, sizeof (WIN32_FIND_DATA));
                if (DoesFileExistEx (objectLocation, findData)) {
                    ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATA);
                    ObjectContent->Details.DetailsData = findData;
#ifndef UNICODE
                    // we need to convert the ANSI findData into UNICODE one
                    findDataW = IsmGetMemory (sizeof (WIN32_FIND_DATAW));
                    if (findDataW) {
                        findDataW->dwFileAttributes = findData->dwFileAttributes;
                        CopyMemory (&(findDataW->ftCreationTime), &(findData->ftCreationTime), sizeof (FILETIME));
                        CopyMemory (&(findDataW->ftLastAccessTime), &(findData->ftLastAccessTime), sizeof (FILETIME));
                        CopyMemory (&(findDataW->ftLastWriteTime), &(findData->ftLastWriteTime), sizeof (FILETIME));
                        findDataW->nFileSizeHigh = findData->nFileSizeHigh;
                        findDataW->nFileSizeLow = findData->nFileSizeLow;
                        findDataW->dwReserved0 = findData->dwReserved0;
                        findDataW->dwReserved1 = findData->dwReserved1;
                        DirectDbcsToUnicodeN (findDataW->cFileName, findData->cFileName, MAX_PATH);
                        DirectDbcsToUnicodeN (findDataW->cAlternateFileName, findData->cAlternateFileName, 14);
                        ObjectContent->Details.DetailsSize = sizeof (WIN32_FIND_DATAW);
                        ObjectContent->Details.DetailsData = findDataW;
                        IsmReleaseMemory (findData);
                    } else {
                        IsmReleaseMemory (findData);
                        ObjectContent->Details.DetailsSize = 0;
                        ObjectContent->Details.DetailsData = NULL;
                    }
#endif
                }
            }
            result = TRUE;
        }
    }
    if (!result) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }
    return result;
}

BOOL
ReleasePhysicalData (
    IN OUT  PMIG_CONTENT ObjectContent
    )
{
    if (ObjectContent->Details.DetailsData) {
        IsmReleaseMemory (ObjectContent->Details.DetailsData);
    }
    ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    return TRUE;
}

VOID
InitDataType (
    VOID
    )
{
    TYPE_REGISTER dataTypeData;

    g_DataTable = HtAllocWithData (sizeof (PCTSTR));

    ZeroMemory (&dataTypeData, sizeof (TYPE_REGISTER));
    dataTypeData.Priority = PRIORITY_DATA;
    dataTypeData.ConvertObjectToMultiSz = ConvertDataToMultiSz;
    dataTypeData.ConvertMultiSzToObject = ConvertMultiSzToData;
    dataTypeData.AcquirePhysicalObject = AcquirePhysicalData;
    dataTypeData.ReleasePhysicalObject = ReleasePhysicalData;

    g_DataTypeId = IsmRegisterObjectType (
                        S_DATATYPE,
                        FALSE,
                        TRUE,
                        &dataTypeData
                        );
    MYASSERT (g_DataTypeId);
}

VOID
DoneDataType (
    VOID
    )
{
    HASHTABLE_ENUM e;

    if (!g_DataTable) {
        return;
    }

    if (EnumFirstHashTableString (&e, g_DataTable)) {
        do {
            if (e.ExtraData) {
                DeleteFile (*((PCTSTR *) (e.ExtraData)));
                FreePathString (*((PCTSTR *) (e.ExtraData)));
            }
        } while (EnumNextHashTableString (&e));
    }

    HtFree (g_DataTable);
    g_DataTable = NULL;
}

PCTSTR
ConvertDataToMultiSz (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT ObjectContent
    )
{
    PCTSTR node;
    PCTSTR leaf;
    PTSTR result = NULL;

    if (IsmCreateObjectStringsFromHandle (ObjectName, &node, &leaf)) {
        g_DataConversionBuff.End = 0;
        GbCopyString (&g_DataConversionBuff, node);
        GbCopyQuotedString (&g_DataConversionBuff, leaf);
        GbCopyString (&g_DataConversionBuff, TEXT(""));

        result = IsmGetMemory (g_DataConversionBuff.End);
        CopyMemory (result, g_DataConversionBuff.Buf, g_DataConversionBuff.End);

        IsmDestroyObjectString (node);
        IsmDestroyObjectString (leaf);
    }

    return result;
}

BOOL
ConvertMultiSzToData (
    IN      PCTSTR ObjectMultiSz,
    OUT     MIG_OBJECTSTRINGHANDLE *ObjectName,
    OUT     PMIG_CONTENT ObjectContent          OPTIONAL
    )
{
#define indexExt  0
#define indexFile 1
    MULTISZ_ENUM multiSzEnum;
    PCTSTR dir = NULL;
    PCTSTR file = NULL;
    UINT index = 0;

    g_DataConversionBuff.End = 0;

    if (ObjectContent) {
        ZeroMemory (ObjectContent, sizeof (MIG_CONTENT));
    }

    if (EnumFirstMultiSz (&multiSzEnum, ObjectMultiSz)) {
        do {
            if (index == indexExt) {
                dir = multiSzEnum.CurrentString;
            } else if (index == indexFile) {
                file = multiSzEnum.CurrentString;
            }
            index++;
        } while (EnumNextMultiSz (&multiSzEnum));
    }

    if (!file) {
        return FALSE;
    }

    if (ObjectContent) {
        ObjectContent->ObjectTypeId = MIG_FILE_TYPE;
        ObjectContent->ContentInFile = TRUE;
    }

    *ObjectName = IsmCreateObjectHandle(dir, file);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\flowctrl.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    flowctrl.c

Abstract:

    Implements the control functionality for the ISM. This includes the enumeration manager, transport marshalling
    and apply module ordering.

Author:

    Marc R. Whitten (marcw) 15-Nov-1999

Revision History:

    marcw 1-Dec-1999 Added function level callback prioritization and non-enumerated callbacks.

--*/

//
// Includes
//

#include "pch.h"
#include "ism.h"
#include "ismp.h"

#define DBG_FLOW     "FlowCtrl"

//
// Strings
//

#define S_INI_SGMFUNCTIONHIGHPRIORITY   TEXT("Source.Gather Function High Priority")
#define S_INI_SGMFUNCTIONLOWPRIORITY    TEXT("Source.Gather Function Low Priority")

#define S_INI_DGMFUNCTIONHIGHPRIORITY   TEXT("Destination.Gather Function High Priority")
#define S_INI_DGMFUNCTIONLOWPRIORITY    TEXT("Destination.Gather Function Low Priority")

//
// Constants
//

#define MINIMUM_FUNCTION_PRIORITY   0xFFFFFFFF
#define MIDDLE_FUNCTION_PRIORITY    0x80000000
#define MAXIMUM_FUNCTION_PRIORITY   0x00000000

#define CALLBEFOREOBJECTENUMERATIONS    0
#define CALLAFTEROBJECTENUMERATIONS     1

//
// Macros
//

#define CALLBACK_ENUMFLAGS_TOP(b) ((PCALLBACK_ENUMFLAGS) ((b)->End > 0 ? ((b)->Buf + (b)->End - sizeof (CALLBACK_ENUMFLAGS)) : NULL))

//
// Types
//

typedef struct {
    UINT Level;
    BOOL Enabled;
    UINT EnableLevel;
    DWORD Flags;
} CALLBACK_ENUMFLAGS, *PCALLBACK_ENUMFLAGS;

typedef enum {
    CALLBACK_NORMAL     = 0x00000001,
    CALLBACK_HOOK,
    CALLBACK_EXCLUSION,
    CALLBACK_PHYSICAL_ENUM,
    CALLBACK_PHYSICAL_ACQUIRE
} CALLBACK_TYPE;

typedef struct _TAG_CALLBACKDATA {

    //
    // Callback Data
    //
    FARPROC Function;
    FARPROC Function2;
    UINT MaxLevel;
    UINT MinLevel;
    PPARSEDPATTERN NodeParsedPattern;
    PPARSEDPATTERN ExplodedNodeParsedPattern;
    PPARSEDPATTERN LeafParsedPattern;
    PPARSEDPATTERN ExplodedLeafParsedPattern;
    PCTSTR Pattern;
    ULONG_PTR CallbackArg;
    CALLBACK_TYPE CallbackType;

    //
    // Enumeration Control Members
    //
    GROWBUFFER EnumFlags;
    BOOL Done;
    BOOL Error;

    //
    // Prioritization and Identification Members
    //
    PCTSTR Group;
    PCTSTR Identifier;
    UINT Priority;

    //
    // Linkage.
    //
    struct _TAG_CALLBACKDATA * Next;
    struct _TAG_CALLBACKDATA * Prev;

} CALLBACKDATA, *PCALLBACKDATA;

typedef struct _TAG_ENUMDATA {

    PCTSTR Pattern;
    PPARSEDPATTERN NodeParsedPattern;
    PPARSEDPATTERN ExplodedNodeParsedPattern;
    PPARSEDPATTERN LeafParsedPattern;
    PPARSEDPATTERN ExplodedLeafParsedPattern;
    //
    // Linkage.
    //
    struct _TAG_ENUMDATA * Next;
    struct _TAG_ENUMDATA * Prev;

} ENUMDATA, *PENUMDATA;

typedef struct {

    MIG_OBJECTTYPEID ObjectTypeId;
    PCTSTR TypeName;
    PCALLBACKDATA PreEnumerationFunctionList;
    PCALLBACKDATA PostEnumerationFunctionList;
    PCALLBACKDATA FunctionList;
    PCALLBACKDATA ExclusionList;
    PCALLBACKDATA PhysicalEnumList;
    PCALLBACKDATA PhysicalAcquireList;
    PENUMDATA FirstEnum;
    PENUMDATA LastEnum;

} TYPEENUMINFO, *PTYPEENUMINFO;

typedef BOOL (NONENUMERATEDCALLBACK)(VOID);
typedef NONENUMERATEDCALLBACK *PNONENUMERATEDCALLBACK;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    PMIG_PHYSICALENUMADD AddCallback;
    ULONG_PTR AddCallbackArg;
    PCTSTR Node;
    PCTSTR Leaf;
} ENUMADDCALLBACK, *PENUMADDCALLBACK;



//
// Globals
//

PGROWLIST g_TypeData = NULL;
PGROWLIST g_GlobalTypeData = NULL;
PCALLBACKDATA g_PreEnumerationFunctionList = NULL;
PCALLBACKDATA g_PostEnumerationFunctionList = NULL;

PMHANDLE g_GlobalQueuePool;
PMHANDLE g_UntrackedFlowPool;
PMHANDLE g_CurrentQueuePool;
GROWBUFFER g_EnumerationList = INIT_GROWBUFFER;

GROWLIST g_AcquireList = INIT_GROWLIST;
GROWLIST g_EnumList = INIT_GROWLIST;
GROWLIST g_EnumAddList = INIT_GROWLIST;

#ifdef DEBUG

PCTSTR g_QueueFnName;

#define SETQUEUEFN(x)       g_QueueFnName = x

#else

#define SETQUEUEFN(x)

#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
pAddStaticExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedFullName
    );

//
// Macro expansion definition
//

// None

//
// Code
//


BOOL
pInsertCallbackIntoSortedList (
    IN      PMHANDLE Pool,
    IN OUT  PCALLBACKDATA * Head,
    IN      PCALLBACKDATA Data
    )

/*++

Routine Description:

  pInsertCallback into sorted list.

Arguments:

  Pool - Specifies the pool to allocate from
  Head - Specifies this head of the callback data list.
  Data - Specifies the data to add to the list.

Return Value:

  TRUE if the callbackdata was successfully added to the list, FALSE
  otherwise.

--*/
{

    PCALLBACKDATA cur = *Head;
    PCALLBACKDATA last = NULL;
    PCALLBACKDATA dataCopy = NULL;

    dataCopy = (PCALLBACKDATA) PmGetMemory (Pool, sizeof (CALLBACKDATA));
    CopyMemory (dataCopy, Data, sizeof (CALLBACKDATA));


    if (!cur || dataCopy->Priority < cur->Priority) {
        //
        // Add to the head of the list if necessary.
        //
        dataCopy->Next = cur;
        if (cur) {
            cur->Prev = dataCopy;
        }

        *Head = dataCopy;
    }
    else {

        //
        // Add inside the list.
        // Always goes through the while loop once (see the if above)
        //
        while (dataCopy->Priority >= cur->Priority) {
            last = cur;
            if (!cur->Next) {
                break;
            }
            cur = cur->Next;
        }
        //
        // Add immediately after cur
        //
        dataCopy->Next = last->Next;
        last->Next = dataCopy;
        dataCopy->Prev = last;
    }

    return TRUE;
}


BOOL
pRegisterCallback (
    IN      PMHANDLE Pool,
    IN OUT  PCALLBACKDATA * FunctionList,
    IN      FARPROC Callback,
    IN      FARPROC Callback2,
    IN      ULONG_PTR CallbackArg,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,             OPTIONAL
    IN      PCTSTR FunctionId,                          OPTIONAL
    IN      CALLBACK_TYPE CallbackType
    )

/*++

Routine Description:

  pRegisterCallback does the actual work of adding a callback to the
  necessary flow control data structures.

Arguments:

  Pool - Specifies the pool to allocate from

  FunctionList - Specifies the list of callback functions that will be
                 updated with the new function.

  Callback - Specifies the callback function to register

  Callback2 - Specifies the second callback function to register

  CallbackArg - Specifies a caller-defined value to be passed back on each
                enumeration

  Pattern - Optionally specifies the pattern that to be associated with
            the callback function

  FunctionId - Specifies the Function Identifer for the callback. This is used
               for function level prioritization.

Return Value:

  TRUE if the callback was successfully registered. FALSE otherwise.

--*/

{
    CALLBACKDATA data;
    INFSTRUCT is = INITINFSTRUCT_PMHANDLE;
    PTSTR nodePattern = NULL;
    PTSTR leafPattern = NULL;
    PCTSTR lowPriorityStr;
    PCTSTR highPriorityStr;
    BOOL result = TRUE;

    MYASSERT (g_CurrentGroup);

    //
    // Initialize callback data.
    //

    ZeroMemory (&data, sizeof (CALLBACKDATA));

    __try {

        data.Function = Callback;
        data.Function2 = Callback2;
        data.CallbackArg = CallbackArg;
        data.Group = PmDuplicateString (Pool, g_CurrentGroup);
        data.CallbackType = CallbackType;

        if (FunctionId) {
            data.Identifier = PmDuplicateString (Pool, FunctionId);
        }

        //
        // Store pattern information (pattern, max level, min level)
        //
        if (Pattern) {

            data.Pattern  = PmDuplicateString (Pool, Pattern);

            ObsSplitObjectStringEx (Pattern, &nodePattern, &leafPattern, NULL, FALSE);

            if (!nodePattern && !leafPattern) {
                DEBUGMSG ((DBG_ERROR, "Pattern specified has null node and leaf"));
                result = FALSE;
                __leave;
            }

            if (nodePattern) {

                GetNodePatternMinMaxLevels (nodePattern, NULL, &data.MinLevel, &data.MaxLevel);

                data.NodeParsedPattern = CreateParsedPatternEx (Pool, nodePattern);
                if (data.NodeParsedPattern) {
                    data.ExplodedNodeParsedPattern = ExplodeParsedPatternEx (Pool, data.NodeParsedPattern);
                }
                ObsFree (nodePattern);
                nodePattern = NULL;
            } else {
                if (data.CallbackType == CALLBACK_NORMAL) {
                    DEBUGMSG ((DBG_ERROR, "%s: Pattern must specify a node %s", g_QueueFnName, data.Pattern));
                    result = FALSE;
                    __leave;
                } else {
                    GetNodePatternMinMaxLevels (TEXT("*"), NULL, &data.MinLevel, &data.MaxLevel);
                    data.NodeParsedPattern = CreateParsedPatternEx (Pool, TEXT("*"));
                    data.ExplodedNodeParsedPattern = ExplodeParsedPatternEx (Pool, data.NodeParsedPattern);

                    DestroyParsedPattern (data.NodeParsedPattern);
                    data.NodeParsedPattern = NULL;
                }
            }
            if (leafPattern) {
                data.LeafParsedPattern = CreateParsedPatternEx (Pool, leafPattern);
                if (data.LeafParsedPattern) {
                    data.ExplodedLeafParsedPattern = ExplodeParsedPatternEx (Pool, data.LeafParsedPattern);
                }
                ObsFree (leafPattern);
                leafPattern = NULL;
            }
        }

        //
        // Get the priority for this function.
        //
        data.Priority = MIDDLE_FUNCTION_PRIORITY;

        if (FunctionId) {
            if (g_IsmModulePlatformContext == PLATFORM_SOURCE) {
                lowPriorityStr = S_INI_SGMFUNCTIONLOWPRIORITY;
                highPriorityStr = S_INI_SGMFUNCTIONHIGHPRIORITY;
            } else {
                lowPriorityStr = S_INI_DGMFUNCTIONLOWPRIORITY;
                highPriorityStr = S_INI_DGMFUNCTIONHIGHPRIORITY;
            }
            if (InfFindFirstLine (g_IsmInf, highPriorityStr, FunctionId, &is)) {

                data.Priority = MAXIMUM_FUNCTION_PRIORITY + is.Context.Line;
            }
            else if (InfFindFirstLine (g_IsmInf, lowPriorityStr, FunctionId, &is)) {

                data.Priority = MINIMUM_FUNCTION_PRIORITY - is.Context.Line;
            }
            InfCleanUpInfStruct (&is);
        }

        //
        // Add the function to the list.
        //
        pInsertCallbackIntoSortedList (Pool, FunctionList, &data);
    }
    __finally {

        InfCleanUpInfStruct (&is);

        if (nodePattern) {
            ObsFree (nodePattern);
            nodePattern = NULL;
        }
        if (leafPattern) {
            ObsFree (leafPattern);
            leafPattern = NULL;
        }
        if (!result) {
            if (data.NodeParsedPattern) {
                DestroyParsedPattern (data.NodeParsedPattern);
            }
            if (data.ExplodedNodeParsedPattern) {
                DestroyParsedPattern (data.ExplodedNodeParsedPattern);
            }
            if (data.LeafParsedPattern) {
                DestroyParsedPattern (data.LeafParsedPattern);
            }
            if (data.ExplodedLeafParsedPattern) {
                DestroyParsedPattern (data.ExplodedLeafParsedPattern);
            }
            ZeroMemory (&data, sizeof (CALLBACKDATA));
        }
    }

    return result;
}


BOOL
pTestContainer (
    IN      PPARSEDPATTERN NodeContainer,
    IN      PPARSEDPATTERN NodeContained,
    IN      PPARSEDPATTERN LeafContainer,
    IN      PPARSEDPATTERN LeafContained
    )
{
    MYASSERT (NodeContainer);
    MYASSERT (NodeContained);

    if ((!NodeContainer) ||
        (!NodeContained)
        ) {
        return FALSE;
    }
    if (!IsExplodedParsedPatternContainedEx (NodeContainer, NodeContained, FALSE)) {
        //they don't match
        return FALSE;
    }
    if (!LeafContained) {
        if (LeafContainer) {
            // If there is a leaf pattern for container the caller will get nodes
            // only if the node pattern has wild chars. So, since we know that the
            // contained node pattern is included in the container node pattern
            // we just need to see if the container node pattern includes wild chars.
            return WildCharsPattern (NodeContainer);
        } else {
            //both are NULL so...
            return TRUE;
        }
    } else {
        if (!LeafContainer) {
            // Even if the contained has a leaf pattern, it will get nodes only if
            // the node pattern has wild chars. So, since we know that the contained
            // node pattern is included in the container node pattern we just need
            // to see if the contained node pattern includes wild chars
            return WildCharsPattern (NodeContained);
        } else {
            //return the actual match of non-null parsed patterns
            return IsExplodedParsedPatternContainedEx (LeafContainer, LeafContained, TRUE);
        }
    }
}

BOOL
pTestContainerEx (
    IN      PPARSEDPATTERN NodeContainer,
    IN      PPARSEDPATTERN NodeContained,
    IN      PPARSEDPATTERN LeafContainer,
    IN      PPARSEDPATTERN LeafContained
    )
{
    MYASSERT (NodeContainer);
    MYASSERT (NodeContained);

    if ((!NodeContainer) ||
        (!NodeContained)
        ) {
        return FALSE;
    }

    if (!DoExplodedParsedPatternsIntersect (NodeContainer, NodeContained)) {
        if (!DoExplodedParsedPatternsIntersectEx (NodeContainer, NodeContained, TRUE)) {
            return FALSE;
        }
    }

    if (!LeafContained) {
        if (LeafContainer) {
            // If there is a leaf pattern for container the caller will get nodes
            // only if the node pattern has wild chars. So, since we know that the
            // contained node pattern is included in the container node pattern
            // we just need to see if the container node pattern includes wild chars.
            return WildCharsPattern (NodeContainer);
        } else {
            //both are NULL so...
            return TRUE;
        }
    } else {
        if (!LeafContainer) {
            // Even if the contained has a leaf pattern, it will get nodes only if
            // the node pattern has wild chars. So, since we know that the contained
            // node pattern is included in the container node pattern we just need
            // to see if the contained node pattern includes wild chars
            return WildCharsPattern (NodeContained);
        } else {
            //return the actual match of non-null parsed patterns
            return DoExplodedParsedPatternsIntersect (LeafContainer, LeafContained);
        }
    }
}

BOOL
pAddEnumeration (
    IN      PMHANDLE Pool,
    IN OUT  PTYPEENUMINFO TypeEnumInfo,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    )

/*++

Routine Description:

  pAddEnumeration Adds an enumeration string to the list of enumerations
  needed for a given type. Because the flow control module tries to use only
  a minimal set of enumerations, the actual enumeration may not be added.
  After a successful call to this function, any data needed by the specified
  enumeration will be enumerated.

Arguments:

  Pool          - Specifies the pool to allocate from
  TypeEnumInfo  - Specifies the type info structure that will receive the new
                  enumeration data.
  ObjectPattern - Specifies the enumeration pattern to add to the type.

Return Value:

  TRUE if the pattern was successfully added, FALSE otherwise.

--*/

{
    PENUMDATA enumData;
    PENUMDATA oldEnumData;
    PCTSTR nodePattern = NULL;
    PCTSTR leafPattern = NULL;
    PPARSEDPATTERN nodeParsedPattern = NULL;
    PPARSEDPATTERN explodedNodeParsedPattern = NULL;
    PPARSEDPATTERN leafParsedPattern = NULL;
    PPARSEDPATTERN explodedLeafParsedPattern = NULL;

    //
    // Add this to the enumeration list unless its already listed.
    //
    if (!ObsSplitObjectStringEx (ObjectPattern, &nodePattern, &leafPattern, NULL, FALSE)) {
        DEBUGMSG ((DBG_ERROR, "Bad pattern detected in pAddEnumeration: %s", ObjectPattern));
        return FALSE;
    }

    if (nodePattern) {
        nodeParsedPattern = CreateParsedPatternEx (Pool, nodePattern);
        if (nodeParsedPattern) {
            explodedNodeParsedPattern = ExplodeParsedPatternEx (Pool, nodeParsedPattern);
        }
        ObsFree (nodePattern);
        INVALID_POINTER (nodePattern);
    }

    if (leafPattern) {
        leafParsedPattern = CreateParsedPatternEx (Pool, leafPattern);
        if (leafParsedPattern) {
            explodedLeafParsedPattern = ExplodeParsedPatternEx (Pool, leafParsedPattern);
        }
        ObsFree (leafPattern);
        INVALID_POINTER (leafPattern);
    }

    enumData = TypeEnumInfo->FirstEnum;

    while (enumData) {
        if (pTestContainer (enumData->ExplodedNodeParsedPattern, explodedNodeParsedPattern, enumData->ExplodedLeafParsedPattern, explodedLeafParsedPattern)) {
            DEBUGMSG ((DBG_FLOW, "Enumeration %s not added. It will be handled during enumeration %s.", ObjectPattern, enumData->Pattern));
            break;
        }
        if (pTestContainer (explodedNodeParsedPattern, enumData->ExplodedNodeParsedPattern, explodedLeafParsedPattern, enumData->ExplodedLeafParsedPattern)) {
            DEBUGMSG ((DBG_FLOW, "Enumeration %s will replace enumeration %s.", ObjectPattern, enumData->Pattern));
            if (enumData->Prev) {
                enumData->Prev->Next = enumData->Next;
            }
            if (enumData->Next) {
                enumData->Next->Prev = enumData->Prev;
            }
            if (TypeEnumInfo->FirstEnum == enumData) {
                TypeEnumInfo->FirstEnum = enumData->Next;
            }
            if (TypeEnumInfo->LastEnum == enumData) {
                TypeEnumInfo->LastEnum = enumData->Prev;
            }
            PmReleaseMemory (Pool, enumData->Pattern);
            DestroyParsedPattern (enumData->ExplodedLeafParsedPattern);
            DestroyParsedPattern (enumData->LeafParsedPattern);
            DestroyParsedPattern (enumData->ExplodedNodeParsedPattern);
            DestroyParsedPattern (enumData->NodeParsedPattern);
            oldEnumData = enumData;
            enumData = enumData->Next;
            PmReleaseMemory (Pool, oldEnumData);
        } else {
            enumData = enumData->Next;
        }
    }

    if (enumData == NULL) {

        DEBUGMSG ((DBG_FLOW, "Adding Enumeration %s to the list of enumerations of type %s.", ObjectPattern, TypeEnumInfo->TypeName));

        enumData = (PENUMDATA) PmGetMemory (Pool, sizeof (ENUMDATA));
        ZeroMemory (enumData, sizeof (ENUMDATA));
        enumData->Pattern = PmDuplicateString (Pool, ObjectPattern);
        enumData->NodeParsedPattern = nodeParsedPattern;
        enumData->ExplodedNodeParsedPattern = explodedNodeParsedPattern;
        enumData->LeafParsedPattern = leafParsedPattern;
        enumData->ExplodedLeafParsedPattern = explodedLeafParsedPattern;
        if (TypeEnumInfo->LastEnum) {
            TypeEnumInfo->LastEnum->Next = enumData;
        }
        enumData->Prev = TypeEnumInfo->LastEnum;
        TypeEnumInfo->LastEnum = enumData;
        if (!TypeEnumInfo->FirstEnum) {
            TypeEnumInfo->FirstEnum = enumData;
        }
    } else {
        DestroyParsedPattern (explodedLeafParsedPattern);
        DestroyParsedPattern (leafParsedPattern);
        DestroyParsedPattern (explodedNodeParsedPattern);
        DestroyParsedPattern (nodeParsedPattern);
    }
    return TRUE;
}

PTYPEENUMINFO
pGetTypeEnumInfo (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      BOOL GlobalData
    )

/*++

Routine Description:

  pGetTypeEnumInfo returns the TypeEnumInfo for a specified type.

Arguments:

  ObjectTypeId - Specifies the object type.

  GlobalData - Specifies TRUE if the type enum data is global to the whole process,
               or FALSE if it is specific to the current enumeration queue.

Return Value:

  A TypeEnumInfo structure if one was found, NULL otherwise.

--*/

{
    UINT i;
    UINT count;
    PTYPEENUMINFO rTypeEnumInfo;
    PGROWLIST *typeData;

    if (GlobalData) {
        typeData = &g_GlobalTypeData;
    } else {
        typeData = &g_TypeData;
    }

    if (!(*typeData)) {
        return NULL;
    }

    count = GlGetSize (*typeData);

    //
    // Find the matching type info for this item.
    //
    for (i = 0; i < count; i++) {

        rTypeEnumInfo = (PTYPEENUMINFO) GlGetItem (*typeData, i);
        if (rTypeEnumInfo->ObjectTypeId == ObjectTypeId) {
            return rTypeEnumInfo;
        }
    }

    return NULL;
}

BOOL
pProcessQueueEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      FARPROC Callback,
    IN      FARPROC Callback2,                      OPTIONAL
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId,                      OPTIONAL
    IN      CALLBACK_TYPE CallbackType
    )

/*++

Routine Description:

  pProcessQueueEnumeration is used by Source Gather Modules and Destination Gather Modules
  in order to register a callback function to be called for a particular object enumeration.

Arguments:

  ObjectTypeId      - Specifies the object type for the enumeration.
  ObjectPattern     - Specifies the enumeration pattern to use.
  Callback          - Specifies the function to callback during the enumeration
  Callback2         - Specifies the second function to callback during the enumeration (used
                      for the free function of physical hooks)
  CallbackArg       - Specifies a caller-defined value to be passed back on
                      each enumeration
  FunctionId        - Specifies the function identifier string, which is used
                      to prioritize function calls. The function string must
                      match the priorization string in the control INF file.
  GrowEnumPattern   - Specifies if the global enumeration pattern should be
                      grown to include this one. If FALSE, this function just
                      wants to be called back for all objects matching the
                      pattern but does not want to force the enumeration of
                      the pattern.
  ExclusionCallback - Specifies TRUE if Callback is an exclusion callback, or
                      FALSE if Callback is an object enum callback

Return Value:

  TRUE if the enumeration was successfully queued, FALSE otherwise.

--*/
{
    PTYPEENUMINFO typeEnumInfo;
    PCALLBACKDATA * list;
    BOOL globalData;
    BOOL result = FALSE;
    MIG_OBJECTSTRINGHANDLE handle = NULL;
    PMHANDLE pool;

    __try {

        MYASSERT (ObjectTypeId);
        if (!ObjectPattern) {
            handle = IsmCreateSimpleObjectPattern (NULL, TRUE, NULL, TRUE);
            ObjectPattern = handle;
            if (!handle) {
                MYASSERT (FALSE);
                __leave;
            }
        }

        if (CallbackType == CALLBACK_PHYSICAL_ACQUIRE ||
            CallbackType == CALLBACK_PHYSICAL_ENUM ||
            CallbackType == CALLBACK_EXCLUSION
            ) {
            globalData = TRUE;
            pool = g_GlobalQueuePool;
        } else {
            globalData = FALSE;
            pool = g_CurrentQueuePool;
        }

        if (!g_CurrentGroup) {
            DEBUGMSG ((DBG_ERROR, "%s called outside of ISM-managed callback", g_QueueFnName));
            __leave;
        }

        typeEnumInfo = pGetTypeEnumInfo (ObjectTypeId, globalData);

        if (!typeEnumInfo) {

            DEBUGMSG ((DBG_ERROR, "%s: %d does not match a known object type.", g_QueueFnName, ObjectTypeId));
            __leave;

        }

        //
        // Save away the callback function and associated data.
        //

        switch (CallbackType) {

        case CALLBACK_EXCLUSION:
            list = &typeEnumInfo->ExclusionList;
            break;

        case CALLBACK_PHYSICAL_ENUM:
            list = &typeEnumInfo->PhysicalEnumList;
            break;

        case CALLBACK_PHYSICAL_ACQUIRE:
            list = &typeEnumInfo->PhysicalAcquireList;
            break;

        default:
            list = &typeEnumInfo->FunctionList;
            break;

        }

        if (!pRegisterCallback (
                pool,
                list,
                Callback,
                Callback2,
                CallbackArg,
                ObjectPattern,
                FunctionId,
                CallbackType
                )) {
            __leave;
        }

        if (CallbackType == CALLBACK_NORMAL) {
            //
            // Save the pattern into the object tree and link the callback function with it.
            //
            if (!pAddEnumeration (pool, typeEnumInfo, ObjectPattern)) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {
        if (handle) {
            IsmDestroyObjectHandle (handle);
        }
    }

    return result;
}


BOOL
IsmProhibitPhysicalEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_PHYSICALENUMCHECK EnumCheckCallback,       OPTIONAL
    IN      ULONG_PTR CallbackArg,                          OPTIONAL
    IN      PCTSTR FunctionId                               OPTIONAL
    )
{
    SETQUEUEFN(TEXT("IsmProhibitPhysicalEnum"));

    if (!ObjectPattern) {
        DEBUGMSG ((DBG_ERROR, "IsmProhibitPhysicalEnum: ObjectPattern is required"));
        return FALSE;
    }

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) EnumCheckCallback,
                NULL,
                CallbackArg,
                FunctionId,
                CALLBACK_PHYSICAL_ENUM
                );
}


BOOL
IsmAddToPhysicalEnum (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectBase,
    IN      PMIG_PHYSICALENUMADD EnumAddCallback,
    IN      ULONG_PTR CallbackArg                           OPTIONAL
    )
{
    PCTSTR newNode = NULL;
    PCTSTR newLeaf = NULL;
    UINT u;
    UINT count;
    ENUMADDCALLBACK callbackStruct;
    PENUMADDCALLBACK storedStruct;
    BOOL result = FALSE;
    UINT newTchars;
    UINT existTchars;
    UINT tchars;
    CHARTYPE ch;

    if (!ObjectTypeId || !ObjectBase || !EnumAddCallback) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // First test to see if the object base is already listed
    //

    ObsSplitObjectStringEx (ObjectBase, &newNode, &newLeaf, NULL, TRUE);

    if (!newNode) {
        DEBUGMSG ((DBG_ERROR, "IsmAddToPhysicalEnum requires a node"));
    } else {

        count = GlGetSize (&g_EnumAddList);

        for (u = 0 ; u < count ; u++) {

            storedStruct = (PENUMADDCALLBACK) GlGetItem (&g_EnumAddList, u);
            MYASSERT (storedStruct);

            if (storedStruct->AddCallback != EnumAddCallback) {

                if (StringIMatch (newNode, storedStruct->Node)) {
                    //
                    // Node is the same; leaf must be unique
                    //

                    if (!newLeaf || !storedStruct->Leaf) {
                        DEBUGMSG ((DBG_ERROR, "IsmAddToPhysicalEnum requires a unique object for %s", newNode));
                        break;
                    }

                    if (StringIMatch (newLeaf, storedStruct->Leaf)) {
                        DEBUGMSG ((
                            DBG_ERROR,
                            "IsmAddToPhysicalEnum does not have a unique leaf for %s leaf %s",
                            newNode,
                            newLeaf
                            ));
                        break;
                    }
                } else if (!newLeaf) {

                    //
                    // New node cannot be a prefix of an existing node, and vice-versa
                    //

                    newTchars = TcharCount (newNode);
                    existTchars = TcharCount (storedStruct->Node);

                    tchars = min (newTchars, existTchars);

                    //
                    // Compare only when new node might consume stored node
                    //

                    if (existTchars == tchars) {
                        // stored node is shortest; ignore if it has a leaf
                        if (storedStruct->Leaf) {
                            continue;
                        }
                    }

                    if (StringIMatchTcharCount (newNode, storedStruct->Node, tchars)) {

                        //
                        // Verify the end of the common prefix lands on either a nul or a
                        // backslash.  Otherwise, the prefix isn't common.
                        //

                        if (tchars == newTchars) {
                            ch = (CHARTYPE) _tcsnextc (newNode + tchars);
                        } else {
                            ch = (CHARTYPE) _tcsnextc (storedStruct->Node + tchars);
                        }

                        if (!ch || ch == TEXT('\\')) {

                            if (tchars == newTchars) {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "IsmAddToPhysicalEnum: %s is already handled by %s",
                                    newNode,
                                    storedStruct->Node
                                    ));
                            } else {
                                DEBUGMSG ((
                                    DBG_ERROR,
                                    "IsmAddToPhysicalEnum: %s is already handled by %s",
                                    storedStruct->Node,
                                    newNode
                                    ));
                            }
                            break;
                        }
                    }
                }
            }
        }

        if (u >= count) {

            ZeroMemory (&callbackStruct, sizeof (callbackStruct));

            callbackStruct.ObjectTypeId = ObjectTypeId & ~(PLATFORM_MASK);
            callbackStruct.Node = PmDuplicateString (g_UntrackedFlowPool, newNode);
            callbackStruct.Leaf = newLeaf ? PmDuplicateString (g_UntrackedFlowPool, newLeaf) : NULL;
            callbackStruct.AddCallback = EnumAddCallback;
            callbackStruct.AddCallbackArg = CallbackArg;

            GlAppend (&g_EnumAddList, (PBYTE) &callbackStruct, sizeof (ENUMADDCALLBACK));

            result = TRUE;
        }
    }

    ObsFree (newNode);
    ObsFree (newLeaf);

    return result;
}


BOOL
IsmRegisterPhysicalAcquireHook (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,           OPTIONAL
    IN      PMIG_PHYSICALACQUIREHOOK HookCallback,
    IN      PMIG_PHYSICALACQUIREFREE FreeCallback,          OPTIONAL
    IN      ULONG_PTR CallbackArg,                          OPTIONAL
    IN      PCTSTR FunctionId                               OPTIONAL
    )
{
    ObjectTypeId &= ~PLATFORM_MASK;

    SETQUEUEFN(TEXT("IsmRegisterPhysicalAcquireHook"));

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) HookCallback,
                (FARPROC) FreeCallback,
                CallbackArg,
                FunctionId,
                CALLBACK_PHYSICAL_ACQUIRE
                );
}


BOOL
IsmRegisterStaticExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedObjectName
    )
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    pAddStaticExclusion (ObjectTypeId, EncodedObjectName);

    return TRUE;
}


UINT
WINAPI
pMakeApplyCallback (
    IN      PCMIG_OBJECTENUMDATA Data,
    IN      ULONG_PTR CallerArg
    )
{
    if (CallerArg & QUEUE_MAKE_APPLY) {
        IsmMakeApplyObject (Data->ObjectTypeId, Data->ObjectName);
    } else if (CallerArg & QUEUE_MAKE_PERSISTENT) {
        IsmMakePersistentObject (Data->ObjectTypeId, Data->ObjectName);
    }

    if (CallerArg & QUEUE_OVERWRITE_DEST) {
        IsmAbandonObjectOnCollision ((Data->ObjectTypeId & ~PLATFORM_MASK)|PLATFORM_DESTINATION, Data->ObjectName);
    } else if (CallerArg & QUEUE_DONT_OVERWRITE_DEST) {
        IsmAbandonObjectOnCollision ((Data->ObjectTypeId & ~PLATFORM_MASK)|PLATFORM_SOURCE, Data->ObjectName);
    }

    if (CallerArg & QUEUE_MAKE_NONCRITICAL) {
        IsmMakeNonCriticalObject (Data->ObjectTypeId, Data->ObjectName);
    }

    return CALLBACK_ENUM_CONTINUE;
}


BOOL
IsmQueueEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,   OPTIONAL
    IN      PMIG_OBJECTENUMCALLBACK Callback,       OPTIONAL
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    )

/*++

Routine Description:

  IsmQueueEnumeration is used by Source Gather Modules and Destination Gather
  Modules in order to register a callback function to be called for a
  particular object enumeration.

Arguments:

  ObjectTypeId  - Specifies the object type for the enumeration.

  ObjectPattern - Specifies the enumeration pattern to use.  If not specified,
                  all objects for ObjectTypeId are queued.

  Callback      - Specifies the function to callback during the enumeration.
                  If not defined, the built-in ISM callback is used (which
                  marks the objects as persistent).

  CallbackArg   - Specifies a caller-defined value to be passed back on
                  each enumeration.  If Callback is NULL, then this argument
                  specifies zero or more of the following flags:

                    QUEUE_MAKE_PERSISTENT or QUEUE_MAKE_APPLY (mutually exclusive)
                    QUEUE_OVERWRITE_DEST or QUEUE_DONT_OVERWRITE_DEST (mutually exclusive)


  FunctionId    - Specifies the function identifier string, which is used to
                  prioritize function calls. The function string must match
                  the priorization string in the control INF file.  If
                  Callback is NULL, then this parameter is forced to the value
                  "SetDestPriority", "MakePersistent" or "MakeApply" depending
                  on CallbackArg.

Return Value:

  TRUE if the enumeration was successfully queued, FALSE otherwise.

--*/
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    SETQUEUEFN(TEXT("IsmQueueEnumeration"));

    if (!Callback) {
        Callback = pMakeApplyCallback;

        if (!CallbackArg) {
            CallbackArg = QUEUE_MAKE_APPLY;
        }

        if (CallbackArg & QUEUE_MAKE_APPLY) {
            FunctionId = TEXT("MakeApply");
        } else if (CallbackArg & QUEUE_MAKE_PERSISTENT) {
            FunctionId = TEXT("MakePersistent");
        } else {
            FunctionId = TEXT("SetDestPriority");
        }
    }

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) Callback,
                NULL,
                CallbackArg,
                FunctionId,
                CALLBACK_NORMAL
                );
}


BOOL
IsmHookEnumeration (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,
    IN      PMIG_OBJECTENUMCALLBACK Callback,
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    )

/*++

Routine Description:

  IsmHookEnumeration is used by Source Gather Modules and Destination Gather Modules
  in order to register a callback function to be called for a particular object enumeration. The
  difference to IsmQueueEnumeration is that this function does not expand the
  global enumeration pattern.

Arguments:

  ObjectTypeId  - Specifies the object type for the enumeration.

  ObjectPattern - Specifies the enumeration pattern to use.  If not specified,
                  all objects of type ObjectTypeId are hooked.

  Callback      - Specifies the function to callback during the enumeration

  CallbackArg   - Specifies a caller-defined value to be passed back on
                  each enumeration

  FunctionId    - Specifies the function identifier string, which is used to
                  prioritize function calls. The function string must match
                  the priorization string in the control INF file.

Return Value:

  TRUE if the enumeration was successfully queued, FALSE otherwise.

--*/
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    SETQUEUEFN(TEXT("IsmHookEnumeration"));

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) Callback,
                NULL,
                CallbackArg,
                FunctionId,
                CALLBACK_HOOK
                );
}


BOOL
IsmRegisterDynamicExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern,   OPTIONAL
    IN      PMIG_DYNAMICEXCLUSIONCALLBACK Callback,
    IN      ULONG_PTR CallbackArg,                  OPTIONAL
    IN      PCTSTR FunctionId                       OPTIONAL
    )
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    SETQUEUEFN(TEXT("IsmRegisterDynamicExclusion"));

    return pProcessQueueEnumeration (
                ObjectTypeId,
                ObjectPattern,
                (FARPROC) Callback,
                NULL,
                CallbackArg,
                FunctionId,
                CALLBACK_EXCLUSION
                );
}


BOOL
pRegisterNonEnumeratedCallback (
    IN      FARPROC Callback,
    IN      UINT WhenCalled,
    IN      PCTSTR FunctionId,  OPTIONAL
    IN      BOOL PerTypeId,
    IN      MIG_OBJECTTYPEID ObjectTypeId
    )

/*++

Routine Description:

  IsmRegisterNonEnumeratedCallback is used to register a function to be
  called either before or after the enumeration of data.

Arguments:

  Callback      - Specifies the function to call.
  WhenCalled    - Specifies the timing of the non-enumerated callback. Either
                  CALLBEFOREOBJECTENUMERATIONS or CALLAFTEROBJECTENUMERATIONS
  FunctionId    - Optionally specifies the function identifier string. This
                  parameter can be used to add function level prioritization to
                  the module.
  PerTypeId     - Specifies if the pre or post enumeration callback is per type
  ObjectTypeId  - Specifies the object type id if PerTypeId is TRUE

Return Value:

  TRUE if the function was successfully registered. FALSE otherwise.

--*/
{
    PTYPEENUMINFO typeEnumInfo;
    PCALLBACKDATA * list;

    MYASSERT (Callback);
    MYASSERT (WhenCalled == CALLBEFOREOBJECTENUMERATIONS || WhenCalled == CALLAFTEROBJECTENUMERATIONS);

    if (!g_CurrentGroup) {
        DEBUGMSG ((DBG_ERROR, "IsmRegisterNonEnumeratedCallback called outside of ISM-managed callback."));
        return FALSE;
    }

    if (PerTypeId) {
        typeEnumInfo = pGetTypeEnumInfo (ObjectTypeId, FALSE);

        if (!typeEnumInfo) {
            DEBUGMSG ((DBG_ERROR, "IsmRegisterNonEnumeratedCallback: %d does not match a known object type.", ObjectTypeId));
            return FALSE;
        }
        if (WhenCalled == CALLBEFOREOBJECTENUMERATIONS) {
            list = &(typeEnumInfo->PreEnumerationFunctionList);
        }
        else {
            list = &(typeEnumInfo->PostEnumerationFunctionList);
        }
    } else {
        if (WhenCalled == CALLBEFOREOBJECTENUMERATIONS) {
            list = &g_PreEnumerationFunctionList;
        }
        else {
            list = &g_PostEnumerationFunctionList;
        }
    }

    return pRegisterCallback (
                g_CurrentQueuePool,
                list,
                (FARPROC) Callback,
                NULL,
                (ULONG_PTR) 0,
                NULL,
                FunctionId,
                CALLBACK_NORMAL
                );
}

BOOL
IsmRegisterPreEnumerationCallback (
    IN      PMIG_PREENUMCALLBACK Callback,
    IN      PCTSTR FunctionId               OPTIONAL
    )
{
    return pRegisterNonEnumeratedCallback (
                (FARPROC) Callback,
                CALLBEFOREOBJECTENUMERATIONS,
                FunctionId,
                FALSE,
                0
                );
}

BOOL
IsmRegisterTypePreEnumerationCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_PREENUMCALLBACK Callback,
    IN      PCTSTR FunctionId               OPTIONAL
    )
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    return pRegisterNonEnumeratedCallback (
                (FARPROC) Callback,
                CALLBEFOREOBJECTENUMERATIONS,
                FunctionId,
                TRUE,
                ObjectTypeId
                );
}

BOOL
IsmRegisterPostEnumerationCallback (
    IN      PMIG_POSTENUMCALLBACK Callback,
    IN      PCTSTR FunctionId               OPTIONAL
    )
{
    return pRegisterNonEnumeratedCallback (
                (FARPROC) Callback,
                CALLAFTEROBJECTENUMERATIONS,
                FunctionId,
                FALSE,
                0
                );
}

BOOL
IsmRegisterTypePostEnumerationCallback (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PMIG_POSTENUMCALLBACK Callback,
    IN      PCTSTR FunctionId               OPTIONAL
    )
{
    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    return pRegisterNonEnumeratedCallback (
                (FARPROC) Callback,
                CALLAFTEROBJECTENUMERATIONS,
                FunctionId,
                TRUE,
                ObjectTypeId
                );
}

VOID
pCreateFunctionListForPattern (
    IN OUT  PGROWLIST List,
    IN      PTYPEENUMINFO TypeEnumInfo,
    IN      PCTSTR Pattern,
    IN      PPARSEDPATTERN ExplodedNodeParsedPattern,
    IN      PPARSEDPATTERN ExplodedLeafParsedPattern,
    IN      CALLBACK_TYPE CallbackType
    )

/*++

Routine Description:

  pCreateFunctionListForPattern enumerates all callback functions for a given
  type and determines if they could be interested in an enumeration keyed off
  of the given pattern. Since we use a minimal list of patterns, at each
  pattern we must come up with the list of callback functions associated with
  patterns contained by our minimal pattern.

Arguments:

  List     - Specifies the growlist where the callback functions are to be
             stored. After the function's return, this list contains all
             callback functions that are needed for the given enumeration
             pattern.

  TypeEnumInfo - Specifies the type to draw potential callback functions from.

  Pattern  - Specifies the minimal pattern to that will be used for
             enumeration.

  ExplodedNodeParsedPattern - Specifies the node portion of Pattern, in pre-parsed
                              exploded format.

  ExplodedLeafParsedPattern - Specifies the leaf portion of Pattern, in pre-parsed
                              exploded format.

  CallbackType - Specifies which type of callback list to use (a CALLBACK_* constant)

Return Value:

  None.

--*/

{

    PCALLBACKDATA data;
    BOOL processHooks = FALSE;

    if (!TypeEnumInfo) {
        return;
    }

    //
    // Loop through all functions for this type, and add functions that fall under the
    // current enumeration pattern.
    //

    switch (CallbackType) {

    case CALLBACK_EXCLUSION:
        data = TypeEnumInfo->ExclusionList;
        break;

    default:
        data = TypeEnumInfo->FunctionList;
        processHooks = TRUE;
        break;

    }

    if (!data) {
        return;
    }

    while (data) {
        if (pTestContainer (
                ExplodedNodeParsedPattern,
                data->ExplodedNodeParsedPattern,
                ExplodedLeafParsedPattern,
                data->ExplodedLeafParsedPattern
                )) {

            GlAppend (List, (PBYTE) data, sizeof (CALLBACKDATA));

        } else if (processHooks) {
            if (data->CallbackType == CALLBACK_HOOK) {

                if (pTestContainerEx (
                        data->ExplodedNodeParsedPattern,
                        ExplodedNodeParsedPattern,
                        data->ExplodedLeafParsedPattern,
                        ExplodedLeafParsedPattern
                        )) {

                    GlAppend (List, (PBYTE) data, sizeof (CALLBACKDATA));

                }
            }
        }

        data = data->Next;
    }
}

VOID
pDestroyFunctionListForPattern (
    IN OUT PGROWLIST List
    )

/*++

Routine Description:

  This function simply cleans up the resources associated with a function
  list.

Arguments:

  List - Specifies the growlist of callbackdata to clean up.

Return Value:

  None.

--*/

{
    UINT i;
    PCALLBACKDATA data;
    UINT count;

    //
    // Clean up enum modification stacks.
    //

    count = GlGetSize (List);

    for (i = 0; i < count; i++) {

        data = (PCALLBACKDATA) GlGetItem (List, i);
        GbFree (&data->EnumFlags);
    }

    //
    // Clean up list itself.
    //
    GlFree (List);
}


VOID
pAddStaticExclusion (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedFullName
    )
{
    HASHTABLE exclusionTable;

    if (!EncodedFullName) {
        //
        // Ignore request for bad name
        //
        return;
    }
    ObjectTypeId = ObjectTypeId & (~PLATFORM_MASK);

    exclusionTable = GetTypeExclusionTable (ObjectTypeId);
    if (!exclusionTable) {
        return;
    }
    HtAddString (exclusionTable, EncodedFullName);
}


BOOL
pIsObjectExcluded (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE EncodedFullName
    )
{
    HASHTABLE exclusionTable;

    if (!EncodedFullName) {
        return FALSE;
    }

    //
    // Check the hash table for an entry
    //

    ObjectTypeId = ObjectTypeId & (~PLATFORM_MASK);

    exclusionTable = GetTypeExclusionTable (ObjectTypeId);
    if (!exclusionTable) {
        return FALSE;
    }

    if (HtFindString (exclusionTable, EncodedFullName)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pIsObjectNodeExcluded (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR NodePattern,
    OUT     PBOOL PossiblePatternMatch      OPTIONAL
    )
{
    HASHTABLE exclusionTable;
    HASHTABLE_ENUM e;
    PCTSTR node;
    PTSTR wackedExclusion;
    PCTSTR firstWildcard = NULL;
    PCTSTR wildcard1;
    PCTSTR wildcard2;
    UINT patternStrTchars;
    UINT hashStrTchars;
    BOOL match = FALSE;

    ObjectTypeId = ObjectTypeId & (~PLATFORM_MASK);

    exclusionTable = GetTypeExclusionTable (ObjectTypeId);
    if (!exclusionTable) {
        return FALSE;
    }

    //
    // If NodePattern is a pattern, then PossiblePatternMatch is specified.
    // Otherwise, NodePattern is a specific node.
    //

    if (PossiblePatternMatch) {
        //
        // Computer the length of the non-pattern portion
        //

        *PossiblePatternMatch = FALSE;

        firstWildcard = NULL;

        wildcard1 = ObsFindNonEncodedCharInEncodedString (NodePattern, TEXT('*'));
        wildcard2 = ObsFindNonEncodedCharInEncodedString (NodePattern, TEXT('?'));

        if (wildcard1) {
            firstWildcard = wildcard1;
        }
        if (wildcard2) {
            if ((!firstWildcard) || (firstWildcard > wildcard2)) {
                firstWildcard = wildcard2;
            }
        }

        if (!firstWildcard) {
            firstWildcard = GetEndOfString (NodePattern);
        }
    } else {
        firstWildcard = GetEndOfString (NodePattern);
    }

    //
    // Enumerate all exclusions and check NodePattern against them
    //

    patternStrTchars = (HALF_PTR) (firstWildcard - NodePattern);

    if (EnumFirstHashTableString (&e, exclusionTable)) {
        do {
            if (IsmIsObjectHandleNodeOnly (e.String)) {
                IsmCreateObjectStringsFromHandle (e.String, &node, NULL);
                MYASSERT (node);

                hashStrTchars = TcharCount (node);
                if (hashStrTchars < patternStrTchars) {

                    //
                    // Require exclusion to be a prefix, ending in a backslash
                    //

                    wackedExclusion = DuplicatePathString (node, sizeof (TCHAR));
                    AppendWack (wackedExclusion);

                    if (StringIPrefix (NodePattern, wackedExclusion)) {
                        match = TRUE;
                    }

                    FreePathString (wackedExclusion);

                } else {

                    //
                    // Require exclusion to match identically
                    //

                    if (hashStrTchars == patternStrTchars &&
                        StringIMatch (NodePattern, e.String)
                        ) {

                        match = TRUE;

                    } else if (PossiblePatternMatch && !match) {

                        //
                        // We *might* have an exclusion match (we can't tell).
                        // If the pattern contains no wacks, then we assume
                        // the enumerated node will determine exclusion
                        // properly.
                        //
                        // This could be optimized further by checking if the
                        // character set of NodePattern is a subset of the
                        // exclusion string.
                        //

                        if (!_tcschr (NodePattern, TEXT('\\'))) {
                            *PossiblePatternMatch = TRUE;
                        }
                    }
                }

                IsmDestroyObjectString (node);
            }

        } while (!match && EnumNextHashTableString (&e));
    }

    return match;
}


BOOL
pShouldCallGatherCallback (
    IN      PMIG_TYPEOBJECTENUM Object,
    IN      PCALLBACKDATA Callback
    )

/*++

Routine Description:

  This function encapsulates the logic needed to determine wether or not to
  callback the specified callback. This is necessary because patterns
  requested by various Data Gather Modules are collapsed into a minimal set
  of enumeration patterns. Therefore, we only know that a particular callback
  may be interested in the current object. This function is used to make
  sure.

Arguments:

  Object   - Specifies the current object being enumerated.
  Callback - Specifies the callback data to be checked. This may be modified,
             if a previous enumeration change request by the callback has now
             expired.

Return Value:

  TRUE if the callback should be called, FALSE otherwise.

--*/

{
    PCALLBACK_ENUMFLAGS flags;
    BOOL result = FALSE;
    PTSTR tempString;

    if (Object->Level >= Callback->MinLevel && Object->Level <= Callback->MaxLevel ) {

        //
        // Don't call callbacks that have signaled they are finished or that have errored.
        //
        if (Callback->Done || Callback->Error) {
            return FALSE;
        }

        //
        // See if there is a enumeration modification in effect for this callback.
        //
        flags = CALLBACK_ENUMFLAGS_TOP(&Callback->EnumFlags);

        //
        // Remove stale entries in the modification list.
        //
        while (flags) {
            if (Object->IsNode) {
                if (flags->Level > Object->Level) {
                    Callback->EnumFlags.End -= sizeof (CALLBACK_ENUMFLAGS);
                    flags = CALLBACK_ENUMFLAGS_TOP (&Callback->EnumFlags);
                    continue;
                }
                if ((flags->Level == Object->Level) && (flags->Flags == CALLBACK_SKIP_LEAVES)) {
                    Callback->EnumFlags.End -= sizeof (CALLBACK_ENUMFLAGS);
                    flags = CALLBACK_ENUMFLAGS_TOP (&Callback->EnumFlags);
                    continue;
                }
            }
            if (Object->IsLeaf) {
                if (flags->Level > (Object->Level + 1)) {
                    Callback->EnumFlags.End -= sizeof (CALLBACK_ENUMFLAGS);
                    flags = CALLBACK_ENUMFLAGS_TOP (&Callback->EnumFlags);
                    continue;
                }
            }
            break;
        }

        if (flags && (!flags->Enabled) && Object->IsNode && (flags->EnableLevel == Object->Level)) {
            flags->Enabled = TRUE;
        }

        //
        // Check flags to see if we should call this function.
        //
        if (flags) {

            if (flags->Enabled && flags->Flags == CALLBACK_THIS_TREE_ONLY) {
                if (flags->Level == Object->Level) {
                    Callback->Done = TRUE;
                    return FALSE;
                }
            }

            if (flags->Enabled && flags->Flags == CALLBACK_SKIP_LEAVES) {
                if ((Object->IsLeaf) && (flags->Level == Object->Level + 1)) {
                    return FALSE;
                }
            }

            if (flags->Enabled && flags->Flags == CALLBACK_SKIP_NODES) {
                if (flags->Level <= Object->Level){
                    return FALSE;
                }
            }
            if (flags->Enabled && flags->Flags == CALLBACK_SKIP_TREE) {
                if (flags->Level <= (Object->IsLeaf?Object->Level+1:Object->Level)){
                    return FALSE;
                }
            }
        }

        //
        // If we haven't failed out yet, do a pattern match against the function's requested
        // enumeration.
        //

        result = TRUE;

        if (Object->ObjectNode) {

            if (Callback->NodeParsedPattern) {
                result = TestParsedPattern (Callback->NodeParsedPattern, Object->ObjectNode);

                if (!result) {
                    //
                    // let's try one more time with a wack at the end
                    //

                    tempString = JoinText (Object->ObjectNode, TEXT("\\"));
                    result = TestParsedPattern (Callback->NodeParsedPattern, tempString);
                    FreeText (tempString);

                }
            } else {
                result = Object->ObjectLeaf != NULL;
            }
        }

        if (result && Object->ObjectLeaf) {

            if (Callback->LeafParsedPattern) {
                result = TestParsedPattern (Callback->LeafParsedPattern, Object->ObjectLeaf);
                if (!result &&
                    ((Object->ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
                    (_tcschr (Object->ObjectLeaf, TEXT('.')) == NULL)
                    ) {
                    // let's try one more thing
                    tempString = JoinText (Object->ObjectLeaf, TEXT("."));
                    result = TestParsedPattern (Callback->LeafParsedPattern, tempString);
                    FreeText (tempString);
                }
            }
        }
    }

    return result;
}


BOOL
pProcessCallbackReturnCode (
    IN DWORD ReturnCode,
    IN PMIG_TYPEOBJECTENUM Object,
    IN OUT PCALLBACKDATA Callback
    )

/*++

Routine Description:

  This function encapsulates the logic for handling the return code of a
  callback function. Callback functions have the capability to alter the
  behavior of the enumeration with respect to themselves. This function takes
  care of logging those change requests.

Arguments:

  ReturnCode - Specifies a callback return code.
  Object     - Specifies the current object being enumerated.
  Callback   - Specifies the callback data structure responsible for the
               return code. May be modified if a change is required by the
               callback.

Return Value:

  TRUE if the return code was successfully processed, FALSE otherwise.

--*/

{
    PCALLBACK_ENUMFLAGS flags;

    if (ReturnCode & CALLBACK_ERROR) {

        //
        // the callback function encountered some error, will never be called again
        //
        Callback->Error = TRUE;

        DEBUGMSG ((DBG_ERROR, "A callback function returned an error while enumerating %s.", Object->ObjectName));

        //
        // NTRAID#NTBUG9-153257-2000/08/01-jimschm Add appropriate error handling here.
        //

    } else if (ReturnCode & CALLBACK_DONE_ENUMERATING) {

        //
        // the callback function is done enumerating, will never be called again
        //
        Callback->Done = TRUE;

    } else if (ReturnCode != CALLBACK_ENUM_CONTINUE) {

        //
        // Save callback enumeration flags into the callback's private stack.
        //

        if (ReturnCode & CALLBACK_THIS_TREE_ONLY) {
            flags = (PCALLBACK_ENUMFLAGS) GbGrow (&Callback->EnumFlags, sizeof(CALLBACK_ENUMFLAGS));
            flags->Level = Object->Level;
            flags->EnableLevel = Object->Level;
            flags->Enabled = FALSE;
            flags->Flags = CALLBACK_THIS_TREE_ONLY;
        }
        if (ReturnCode & CALLBACK_SKIP_NODES) {
            flags = (PCALLBACK_ENUMFLAGS) GbGrow (&Callback->EnumFlags, sizeof(CALLBACK_ENUMFLAGS));
            flags->Level = Object->IsLeaf?Object->Level+1:Object->Level;
            flags->EnableLevel = Object->IsLeaf?Object->Level+1:Object->Level;
            flags->Enabled = FALSE;
            flags->Flags = CALLBACK_SKIP_NODES;
        }
        if (ReturnCode & CALLBACK_SKIP_TREE) {
            flags = (PCALLBACK_ENUMFLAGS) GbGrow (&Callback->EnumFlags, sizeof(CALLBACK_ENUMFLAGS));
            flags->Level = Object->Level + 1;
            flags->EnableLevel = 0;
            flags->Enabled = TRUE;
            flags->Flags = CALLBACK_SKIP_TREE;
        }
        if (ReturnCode & CALLBACK_SKIP_LEAVES) {
            flags = (PCALLBACK_ENUMFLAGS) GbGrow (&Callback->EnumFlags, sizeof(CALLBACK_ENUMFLAGS));
            flags->Level = Object->Level + 1;
            flags->EnableLevel = 0;
            flags->Enabled = TRUE;
            flags->Flags = CALLBACK_SKIP_LEAVES;
        }
    }

    return TRUE;
}


BOOL
pDoSingleEnumeration (
    IN      PTYPEENUMINFO GlobalTypeEnumInfo,
    IN      PTYPEENUMINFO TypeEnumInfo,
    IN      PCTSTR ObjectPattern,
    IN      BOOL CallNormalCallbacks,
    IN      MIG_PROGRESSSLICEID SliceId     OPTIONAL
    )

/*++

Routine Description:

  Given a type structure and a pattern, this function runs an enumeration
  based on that pattern, calling all callbacks as needed in that enumeration.

Arguments:

  GlobalTypeEnumInfo - Specifies the type data for the exclude list. This parameter
                       supplies the excluded pattern list.

  TypeEnumInfo  - Specifies the type data for the enumeration to be run. This
                  parameter supplies the queued pattern lists.

  ObjectPattern - Specifies the pattern for the enumeration.

  CallNormalCallbacks - Specifies TRUE for normal callbacks to be processed,
                        or FALSE for hook callbacks to be processed

  SliceId - Specifies the progress bar slice ID, or 0 for no slice.  If
            specified, the slice ID will cause ticks to be generated for
            each container at level 3.


Return Value:

  TRUE if the enumeration was run successfully, FALSE otherwise.

--*/

{
    MIG_TYPEOBJECTENUM eObjects;
    GROWLIST funList = INIT_GROWLIST;
    GROWLIST exclFunList = INIT_GROWLIST;
    UINT i;
    PCALLBACKDATA callbackData;
    DWORD rc;
    MIG_OBJECTENUMDATA publicData;
    PTSTR leafPattern = NULL;
    PTSTR nodePattern = NULL;
    PPARSEDPATTERN nodeParsedPattern = NULL;
    PPARSEDPATTERN explodedNodeParsedPattern = NULL;
    PPARSEDPATTERN leafParsedPattern = NULL;
    PPARSEDPATTERN explodedLeafParsedPattern = NULL;
    PMIG_OBJECTENUMCALLBACK obEnumCallback;
    PMIG_DYNAMICEXCLUSIONCALLBACK exclusionCallback;
    UINT size;
    BOOL stop;
    BOOL b;
    BOOL fSkip;
    UINT fIndex;
    BOOL result = TRUE;
    static DWORD ticks;
    static UINT objects;
    BOOL extraExcludeCheck = FALSE;
    MIG_APPINFO appInfo;

    //
    // Is entire pattern excluded?
    //

    ObsSplitObjectStringEx (ObjectPattern, &nodePattern, &leafPattern, NULL, FALSE);

    if (nodePattern) {
        if (pIsObjectNodeExcluded (
                TypeEnumInfo->ObjectTypeId,
                nodePattern,
                &extraExcludeCheck
                )) {
            DEBUGMSG ((DBG_FLOW, "Pattern %s is completely excluded", ObjectPattern));

            ObsFree (nodePattern);
            return TRUE;
        }
    }

    //
    // Prepare parsed patterns for speed
    //

    if (nodePattern) {
        nodeParsedPattern = CreateParsedPatternEx (g_CurrentQueuePool, nodePattern);
        if (nodeParsedPattern) {
            explodedNodeParsedPattern = ExplodeParsedPatternEx (g_CurrentQueuePool, nodeParsedPattern);
        }
        ObsFree (nodePattern);
        INVALID_POINTER (nodePattern);
    }

    if (leafPattern) {
        leafParsedPattern = CreateParsedPatternEx (g_CurrentQueuePool, leafPattern);
        if (leafParsedPattern) {
            explodedLeafParsedPattern = ExplodeParsedPatternEx (g_CurrentQueuePool, leafParsedPattern);
        }
        ObsFree (leafPattern);
        INVALID_POINTER (leafPattern);
    }

    //
    // Perform enumeration
    //

    if (EnumFirstObjectOfType (&eObjects, TypeEnumInfo->ObjectTypeId, ObjectPattern, NODE_LEVEL_MAX)) {

        DEBUGMSG ((DBG_FLOW, "Enumerating objects of type %s with pattern %s.", TypeEnumInfo->TypeName, ObjectPattern));

        //
        // Get list of functions that want things from this particular enumeration.
        //

        pCreateFunctionListForPattern (
            &funList,
            TypeEnumInfo,
            ObjectPattern,
            explodedNodeParsedPattern,
            explodedLeafParsedPattern,
            CALLBACK_NORMAL
            );

        pCreateFunctionListForPattern (
            &exclFunList,
            GlobalTypeEnumInfo,
            ObjectPattern,
            explodedNodeParsedPattern,
            explodedLeafParsedPattern,
            CALLBACK_EXCLUSION
            );

        MYASSERT ((!CallNormalCallbacks) || GlGetSize (&funList));

        do {
            //
            // Should enumeration of this object be skipped?
            //

            objects++;
            LOG ((LOG_STATUS, (PCSTR) MSG_OBJECT_STATUS, objects, eObjects.NativeObjectName));

            if (!eObjects.ObjectLeaf) {
                // send our status to the app, but only for nodes to keep it fast
                ZeroMemory (&appInfo, sizeof (MIG_APPINFO));
                appInfo.Phase = g_CurrentPhase;
                appInfo.SubPhase = 0;
                appInfo.ObjectTypeId = (eObjects.ObjectTypeId & (~PLATFORM_MASK));
                appInfo.ObjectName = eObjects.ObjectName;
                IsmSendMessageToApp (ISMMESSAGE_APP_INFO, (ULONG_PTR) (&appInfo));
            }

            //
            // Is this object at level 3?  If so, tick the progress bar.
            //

            if (g_ProgressBarFn) {
                if (SliceId && !eObjects.ObjectLeaf && eObjects.SubLevel <= 3) {
                    IsmTickProgressBar (SliceId, 1);
                }
            }

            if (extraExcludeCheck && eObjects.ObjectNode) {
                if (pIsObjectNodeExcluded (
                        TypeEnumInfo->ObjectTypeId,
                        eObjects.ObjectNode,
                        NULL
                        )) {
                    DEBUGMSG ((DBG_FLOW, "Node %s is completely excluded", ObjectPattern));
                    AbortCurrentNodeEnum (&eObjects);
                    continue;
                }
            }

            if (pIsObjectExcluded (eObjects.ObjectTypeId, eObjects.ObjectName)) {
                DEBUGMSG ((DBG_FLOW, "Object %s is excluded", eObjects.ObjectName));

                //
                // If leaf is empty, abort enum of this node
                //

                if (!eObjects.ObjectLeaf) {
                    AbortCurrentNodeEnum (&eObjects);
                }

                continue;
            }

            if (eObjects.ObjectLeaf) {

                b = pIsObjectExcluded (
                        eObjects.ObjectTypeId,
                        ObsGetNodeLeafDivider (eObjects.ObjectName)
                        );

                if (b) {
                    DEBUGMSG ((DBG_FLOW, "Leaf %s is excluded", eObjects.ObjectLeaf));
                    continue;
                }
            }

            //
            // Call all dynamic exclusion functions
            //

            stop = FALSE;

            size = GlGetSize (&exclFunList);
            for (i = 0; i < size ; i++) {

                callbackData = (PCALLBACKDATA) GlGetItem (&exclFunList, i);

                if (pShouldCallGatherCallback (&eObjects, callbackData)) {

                    //
                    // Call the callback function
                    //

                    MYASSERT (!g_CurrentGroup);
                    g_CurrentGroup = callbackData->Group;

                    exclusionCallback = (PMIG_DYNAMICEXCLUSIONCALLBACK) callbackData->Function;
                    stop = exclusionCallback (
                                eObjects.ObjectTypeId,
                                eObjects.ObjectName,
                                callbackData->CallbackArg
                                );

                    g_CurrentGroup = NULL;

                    if (stop) {
                        break;
                    }
                }
            }

            if (stop) {
                DEBUGMSG ((
                    DBG_FLOW,
                    "Object %s is dynamically excluded",
                    eObjects.ObjectName
                    ));
                continue;
            }

            //
            // Check if the user wants to cancel.  If yes, fail with an error.
            //

            if (IsmCheckCancel()) {
                AbortObjectOfTypeEnum (&eObjects);
                SetLastError (ERROR_CANCELLED);
                result = FALSE;
                break;
            }

            //
            // Cycle through each of the list of functions looking for any that care about the current data.
            //

            size = GlGetSize (&funList);
            g_EnumerationList.End = 0;
            for (i = 0; i < size ; i++) {

                callbackData = (PCALLBACKDATA) GlGetItem (&funList, i);

                if (CallNormalCallbacks || (callbackData->CallbackType == CALLBACK_HOOK)) {

                    if (pShouldCallGatherCallback (&eObjects, callbackData)) {

                        fSkip = FALSE;

                        if (g_EnumerationList.End) {
                            fIndex = 0;
                            while (fIndex < g_EnumerationList.End) {
                                if (*((ULONG_PTR *)(g_EnumerationList.Buf + fIndex)) == (ULONG_PTR)callbackData->Function) {
                                    fSkip = TRUE;
                                }
                                fIndex += sizeof (callbackData->Function);
                                if (*((ULONG_PTR *)(g_EnumerationList.Buf + fIndex)) != (ULONG_PTR)callbackData->CallbackArg) {
                                    fSkip = FALSE;
                                }
                                fIndex += sizeof (callbackData->CallbackArg);
                                if (fSkip) {
                                    break;
                                }
                            }
                        }

                        if (!fSkip) {

                            CopyMemory (
                                GbGrow (&g_EnumerationList, sizeof (callbackData->Function)),
                                &(callbackData->Function),
                                sizeof (callbackData->Function)
                                );
                            CopyMemory (
                                GbGrow (&g_EnumerationList, sizeof (callbackData->CallbackArg)),
                                &(callbackData->CallbackArg),
                                sizeof (callbackData->CallbackArg)
                                );

                            //
                            // Copy the enumeration info to the public structure
                            //

                            publicData.ObjectTypeId = TypeEnumInfo->ObjectTypeId;
                            publicData.ObjectName = eObjects.ObjectName;
                            publicData.NativeObjectName = eObjects.NativeObjectName;
                            publicData.ObjectNode = eObjects.ObjectNode;
                            publicData.ObjectLeaf = eObjects.ObjectLeaf;

                            publicData.Level = eObjects.Level;
                            publicData.SubLevel = eObjects.SubLevel;
                            publicData.IsLeaf = eObjects.IsLeaf;
                            publicData.IsNode = eObjects.IsNode;

                            publicData.Details.DetailsSize = eObjects.Details.DetailsSize;
                            publicData.Details.DetailsData = eObjects.Details.DetailsData;

                            //
                            // Call the callback function
                            //

                            MYASSERT (!g_CurrentGroup);
                            g_CurrentGroup = callbackData->Group;

                            obEnumCallback = (PMIG_OBJECTENUMCALLBACK) callbackData->Function;

                            rc = obEnumCallback (&publicData, callbackData->CallbackArg);

                            g_CurrentGroup = NULL;

                            if (rc != CALLBACK_ENUM_CONTINUE) {
                                //
                                // Callback wants to make some sort of modification to its enumeration.
                                //
                                pProcessCallbackReturnCode (rc, &eObjects, callbackData);
                            }
                        }
                    }
                }
            }

        } while (EnumNextObjectOfType (&eObjects));

        //
        // Clean up function list.
        //
        pDestroyFunctionListForPattern (&funList);
        pDestroyFunctionListForPattern (&exclFunList);

    }
    ELSE_DEBUGMSG ((DBG_FLOW, "No objects found matching enumeration pattern %s.", ObjectPattern));

    DestroyParsedPattern (explodedLeafParsedPattern);
    DestroyParsedPattern (leafParsedPattern);
    DestroyParsedPattern (explodedNodeParsedPattern);
    DestroyParsedPattern (nodeParsedPattern);

    return result;
}


VOID
pCreatePhysicalTypeCallbackList (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      CALLBACK_TYPE CallbackType,
    IN OUT  PGROWLIST List
    )
{
    PTYPEENUMINFO typeEnumInfo;
    PCTSTR node;
    PCTSTR leaf;
    PCALLBACKDATA callbackData;
    BOOL callFn;

    //
    // Test object against all patterns of the type
    //

    typeEnumInfo = pGetTypeEnumInfo (ObjectTypeId & (~PLATFORM_MASK), TRUE);
    if (!typeEnumInfo) {
        return;
    }

    ObsSplitObjectStringEx (ObjectName, &node, &leaf, NULL, TRUE);
    if (!node && !leaf) {
        return;
    }

    switch (CallbackType) {

    case CALLBACK_PHYSICAL_ENUM:
        callbackData = typeEnumInfo->PhysicalEnumList;
        break;

    case CALLBACK_PHYSICAL_ACQUIRE:
        callbackData = typeEnumInfo->PhysicalAcquireList;
        break;

    default:
        MYASSERT (FALSE);
        return;
    }

    while (callbackData) {

        MYASSERT (callbackData->NodeParsedPattern);

        if (!node || TestParsedPattern (callbackData->NodeParsedPattern, node)) {

            if (callbackData->LeafParsedPattern && leaf) {
                callFn = TestParsedPattern (callbackData->LeafParsedPattern, leaf);
            } else if (leaf && !callbackData->LeafParsedPattern) {
                callFn = FALSE;
            } else {
                callFn = TRUE;
            }

            if (callFn) {
                GlAppend (List, (PBYTE) callbackData, sizeof (CALLBACKDATA));
            }
        }

        callbackData = callbackData->Next;
    }

    ObsFree (node);
    ObsFree (leaf);
}


BOOL
ExecutePhysicalAcquireCallbacks (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PMIG_CONTENT Content,                       OPTIONAL
    IN      MIG_CONTENTTYPE ContentType,
    IN      UINT MemoryContentLimit,
    OUT     PMIG_CONTENT *NewContent
    )
{
    UINT count;
    UINT u;
    PCALLBACKDATA callbackData;
    PMIG_PHYSICALACQUIREFREE acquireFree = NULL;
    PMIG_PHYSICALACQUIREHOOK acquireHook;
    PMIG_CONTENT updatedContent;
    BOOL result = TRUE;
    PMIG_CONTENT currentContent;

    pCreatePhysicalTypeCallbackList (
        ObjectTypeId,
        ObjectName,
        CALLBACK_PHYSICAL_ACQUIRE,
        &g_AcquireList
        );

    count = GlGetSize (&g_AcquireList);
    currentContent = Content;

    for (u = 0 ; u < count ; u++) {
        //
        // Call this function
        //

        callbackData = (PCALLBACKDATA) GlGetItem (&g_AcquireList, u);

        acquireHook = (PMIG_PHYSICALACQUIREHOOK) callbackData->Function;

        if (acquireHook) {

            updatedContent = NULL;

            if (!acquireHook (
                    ObjectName,
                    currentContent,
                    ContentType,
                    MemoryContentLimit,
                    &updatedContent,
                    FALSE,
                    callbackData->CallbackArg
                    )) {
                //
                // Hook says "don't acquire"
                //

                result = FALSE;
            }

            if (!result || updatedContent) {
                if (currentContent != Content) {
                    //
                    // Free previous hook content change
                    //

                    if (acquireFree) {
                        acquireFree (currentContent);
                        acquireFree = NULL;
                    }

                    currentContent = NULL;
                }

                if (updatedContent) {
                    //
                    // Hook provided replacement content
                    //

                    currentContent = updatedContent;
                    acquireFree = (PMIG_PHYSICALACQUIREFREE) callbackData->Function2;

                } else {
                    break;      // don't acquire -- we can stop now
                }
            }
        }
    }

    if (currentContent && acquireFree) {
        currentContent->IsmHandle = acquireFree;
    }

    *NewContent = currentContent != Content ? currentContent : NULL;

    GlReset (&g_AcquireList);

    return result;
}


BOOL
FreeViaAcquirePhysicalCallback (
    IN      PMIG_CONTENT Content
    )
{
    PMIG_PHYSICALACQUIREFREE acquireFree;

    if (!Content->IsmHandle) {
        return FALSE;
    }

    acquireFree = (PMIG_PHYSICALACQUIREFREE) Content->IsmHandle;
    if (acquireFree) {
        acquireFree (Content);
    }

    return TRUE;
}


BOOL
ExecutePhysicalEnumCheckCallbacks (
    IN      PMIG_TYPEOBJECTENUM ObjectEnum
    )
{
    UINT count;
    UINT u;
    PCALLBACKDATA callbackData;
    PMIG_PHYSICALENUMCHECK enumCheck;
    BOOL result = TRUE;

    pCreatePhysicalTypeCallbackList (
        ObjectEnum->ObjectTypeId,
        ObjectEnum->ObjectName,
        CALLBACK_PHYSICAL_ENUM,
        &g_EnumList
        );

    count = GlGetSize (&g_EnumList);

    for (u = 0 ; u < count ; u++) {
        //
        // Call this function
        //

        callbackData = (PCALLBACKDATA) GlGetItem (&g_EnumList, u);

        enumCheck = (PMIG_PHYSICALENUMCHECK) callbackData->Function;

        if (enumCheck) {

            if (!enumCheck (ObjectEnum, callbackData->CallbackArg)) {
                //
                // Hook says "skip"
                //

                result = FALSE;
                break;
            }
        } else {
            //
            // No callback means "skip"
            //

            result = FALSE;
            break;
        }
    }

    GlReset (&g_EnumList);

    return result;
}


BOOL
ExecutePhysicalEnumAddCallbacks (
    IN OUT  PMIG_TYPEOBJECTENUM ObjectEnum,
    IN      MIG_OBJECTSTRINGHANDLE Pattern,
    IN      MIG_PARSEDPATTERN ParsedPattern,
    IN OUT  PUINT CurrentCallback
    )
{
    BOOL result = FALSE;
    BOOL done;
    PENUMADDCALLBACK callback;
    MIG_OBJECTTYPEID objectTypeId;

    objectTypeId = ObjectEnum->ObjectTypeId & ~(PLATFORM_MASK);

    do {
        done = TRUE;

        if (GlGetSize (&g_EnumAddList) > *CurrentCallback) {

            callback = (PENUMADDCALLBACK) GlGetItem (&g_EnumAddList, *CurrentCallback);

            MYASSERT (callback);
            MYASSERT (callback->AddCallback);

            if (callback->ObjectTypeId != objectTypeId) {
                result = FALSE;
            } else {
                result = callback->AddCallback (ObjectEnum, Pattern, ParsedPattern, callback->AddCallbackArg, FALSE);
            }

            if (!result) {
                *CurrentCallback += 1;
                done = FALSE;
            }
        }
    } while (!done);

    return result;
}


VOID
AbortPhysicalEnumCallback (
    IN      PMIG_TYPEOBJECTENUM ObjectEnum,             ZEROED
    IN      UINT CurrentCallback
    )
{
    PENUMADDCALLBACK callback;

    if (GlGetSize (&g_EnumAddList) > CurrentCallback) {

        callback = (PENUMADDCALLBACK) GlGetItem (&g_EnumAddList, CurrentCallback);

        MYASSERT (callback);
        MYASSERT (callback->AddCallback);

        callback->AddCallback (ObjectEnum, NULL, NULL, callback->AddCallbackArg, TRUE);
    }

    ZeroMemory (ObjectEnum, sizeof (MIG_TYPEOBJECTENUM));
}


UINT
pEstimateSingleEnumerationTicks (
    IN      PTYPEENUMINFO TypeEnumInfo,
    IN      PCTSTR ObjectPattern
    )

/*++

Routine Description:

  Given a type structure and a pattern, this function runs an enumeration
  based on that pattern, counting all the containers 3 levels deep.  This
  is a quick approximation of how much work there is to do.

Arguments:

  TypeEnumInfo  - Specifies the type data for the enumeration to be run.
  ObjectPattern - Specifies the pattern for the enumeration.

Return Value:

  The number of containers exactly 3 levels deep in the object pattern.

--*/

{
    MIG_TYPEOBJECTENUM eObjects;
    PTSTR nodePattern = NULL;
    UINT ticks = 0;
    MIG_OBJECTSTRINGHANDLE nodeOnlyPattern;

    ObsSplitObjectStringEx (ObjectPattern, &nodePattern, NULL, NULL, FALSE);
    if (nodePattern) {
        nodeOnlyPattern = ObsBuildEncodedObjectStringEx (nodePattern, NULL, FALSE);

        ObsFree (nodePattern);
        INVALID_POINTER (nodePattern);
    } else {
        return 0;
    }

    if (EnumFirstObjectOfType (&eObjects, TypeEnumInfo->ObjectTypeId, nodeOnlyPattern, 3)) {

        DEBUGMSG ((DBG_FLOW, "Estimating number of objects of type %s with pattern %s.", TypeEnumInfo->TypeName, nodeOnlyPattern));

        do {

            if (eObjects.SubLevel <= 3) {
                ticks++;
            }

        } while (EnumNextObjectOfType (&eObjects));
    }
    ELSE_DEBUGMSG ((DBG_FLOW, "No objects found matching enumeration pattern %s.", nodeOnlyPattern));

    ObsFree (nodeOnlyPattern);

    return ticks;
}


BOOL
pCallNonEnumeratedCallbacks (
    IN PCALLBACKDATA FunctionList
    )

/*++

Routine Description:

  This function simply takes the provided list of CALLBACKDATA and for each
  function, calls it as a non-enumerated callback.

Arguments:

  FunctionList - Specifies the list of functions to call.

Return Value:

  TRUE if all functions were called successfully. FALSE otherwise.

--*/

{
    PCALLBACKDATA cur;
    BOOL rc;

    cur = FunctionList;

    while (cur) {

        MYASSERT (!g_CurrentGroup);
        g_CurrentGroup = cur->Group;

        rc = ((PNONENUMERATEDCALLBACK) cur->Function) ();

        if (!rc) {
            DEBUGMSG ((
                DBG_FLOW,
                "Group %s returned an error while calling its NonEnumerated Callback with id %s.",
                g_CurrentGroup,
                cur->Identifier ? cur->Identifier : TEXT("<Unidentified Function>")
                ));
        }

        g_CurrentGroup = NULL;
        cur = cur->Next;
    }

    return TRUE;
}


UINT
EstimateAllObjectEnumerations (
    MIG_PROGRESSSLICEID SliceId,
    BOOL PreEstimate
    )

/*++

Routine Description:

  EstimateAllObjectEnumerations computes a tick estimate for all enumerations
  that have been requested by Data Gather Modules (by calling
  IsmQueueEnumeration).

  The function loops through all known types and for each needed enumeration
  of that type, then calls down to a worker function to call to perform the
  actual enumeration.

Arguments:

  None.

Return Value:

  TRUE if enumerations were completed successfully. FALSE otherwise.

--*/

{
    PTYPEENUMINFO typeEnumInfo;
    MIG_OBJECTTYPEID typeId;
    PENUMDATA enumData;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;
    UINT ticks = 0;

    if (g_CurrentGroup) {
        DEBUGMSG ((DBG_ERROR, "EstimateAllObjectEnumerations cannot be called during another callback"));
        return 0;
    }

    if (!g_ProgressBarFn) {
        //
        // No need to estimate; no progress bar callback
        //

        return 0;
    }

    //
    // Initialize type data with all known types. Note that we require
    // the type manager to have been initialized before we are.
    //
    if (!IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        DEBUGMSG ((DBG_ERROR, "EstimateAllObjectEnumerations: No known types to enumerate"));
        return 0;
    }
    do {
        typeId = objTypeIdEnum.ObjectTypeId;

        if (g_IsmModulePlatformContext == PLATFORM_CURRENT) {
            typeId |= g_IsmCurrentPlatform;
        } else {
            typeId |= g_IsmModulePlatformContext;
        }

        typeEnumInfo = pGetTypeEnumInfo (typeId, FALSE);

        //
        // For each enumeration of this type, call the enumeration worker function
        //
        enumData = typeEnumInfo->FirstEnum;

        while (enumData) {
            if (PreEstimate) {
                ticks ++;
            } else {
                ticks += pEstimateSingleEnumerationTicks (typeEnumInfo, enumData->Pattern);
            }
            if (SliceId) {
                IsmTickProgressBar (SliceId, 1);
            }
            enumData = enumData->Next;
        }

    } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));

    return ticks;
}


BOOL
DoAllObjectEnumerations (
    IN      MIG_PROGRESSSLICEID SliceId
    )

/*++

Routine Description:

  DoAllObjectEnumerations is responsible for processing all enumerations that
  have been requested by Data Gather Modules (by calling
  IsmQueueEnumeration).

  The function:
  (1) Calls Pre EnumerationFunctions
  (2) Loops through all known types and for each needed enumeration of that type,
      calls down to a worker function to call to perform the actual enumeration.
  (3) Calls Post Enumeration Functions

Arguments:

  None.

Return Value:

  TRUE if enumerations were completed successfully. FALSE otherwise.

--*/

{
    PTYPEENUMINFO globalTypeEnumInfo;
    PTYPEENUMINFO typeEnumInfo;
    MIG_OBJECTTYPEID typeId;
    PENUMDATA enumData;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;
    BOOL result = TRUE;


    if (g_CurrentGroup) {
        DEBUGMSG ((DBG_ERROR, "DoAllObjectEnumerations cannot be called during another callback"));
        return FALSE;
    }

    //
    // Call any Pre-ObjectEnumeration functions.
    //
    pCallNonEnumeratedCallbacks (g_PreEnumerationFunctionList);

    //
    // Initialize type data with all known types. Note that we require
    // type type manager to have been initialized before we are.
    //
    if (!IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        DEBUGMSG ((DBG_ERROR, "DoAllObjectEnumerations: No known types to enumerate"));
        return FALSE;
    }
    do {
        typeId = objTypeIdEnum.ObjectTypeId;

        if (g_IsmModulePlatformContext == PLATFORM_CURRENT) {
            typeId |= g_IsmCurrentPlatform;
        } else {
            typeId |= g_IsmModulePlatformContext;
        }

        globalTypeEnumInfo = pGetTypeEnumInfo (typeId, TRUE);
        typeEnumInfo = pGetTypeEnumInfo (typeId, FALSE);

        pCallNonEnumeratedCallbacks (typeEnumInfo->PreEnumerationFunctionList);

        //
        // For each enumeration of this type, call the enumeration worker function
        //
        enumData = typeEnumInfo->FirstEnum;

        while (enumData && result) {
            result = pDoSingleEnumeration (
                        globalTypeEnumInfo,
                        typeEnumInfo,
                        enumData->Pattern,
                        TRUE,
                        SliceId
                        );

            enumData = enumData->Next;
        }

        if (result) {
            result = pCallNonEnumeratedCallbacks (typeEnumInfo->PostEnumerationFunctionList);
        }

    } while (IsmEnumNextObjectTypeId (&objTypeIdEnum) && result);

    //
    // Call any Post-ObjectEnumeration functions.
    //
    if (result) {
        result = pCallNonEnumeratedCallbacks (g_PostEnumerationFunctionList);
    }

    return result;
}


VOID
IsmExecuteHooks (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    )
{
    PTYPEENUMINFO globalTypeEnumInfo;
    PTYPEENUMINFO typeEnumInfo;
    PENUMDATA enumData;
    PCTSTR oldCurrentGroup;
    PCTSTR node = NULL;
    PCTSTR leaf = NULL;
    PCTSTR tempString;
    BOOL result;

    ObjectTypeId = FixEnumerationObjectTypeId (ObjectTypeId);

    globalTypeEnumInfo = pGetTypeEnumInfo (ObjectTypeId, TRUE);
    typeEnumInfo = pGetTypeEnumInfo (ObjectTypeId, FALSE);

    if (!globalTypeEnumInfo || !typeEnumInfo) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return;
    }

    enumData = typeEnumInfo->FirstEnum;

    if (!ObsSplitObjectStringEx (ObjectName, &node, &leaf, NULL, TRUE)) {
        DEBUGMSG ((DBG_ERROR, "Bad encoded object detected in IsmExecuteHooks: %s", ObjectName));
        return;
    }

    while (enumData) {
        result = TestParsedPattern (enumData->NodeParsedPattern, node);

        if (!result) {
            //
            // let's try one more time with a wack at the end
            //
            tempString = JoinText (node, TEXT("\\"));
            result = TestParsedPattern (enumData->NodeParsedPattern, tempString);
            FreeText (tempString);
        }

        if (result && leaf) {
            if (!enumData->LeafParsedPattern) {
                result = FALSE;
            } else {
                result = TestParsedPattern (enumData->LeafParsedPattern, leaf);
                if (!result &&
                    ((ObjectTypeId & (~PLATFORM_MASK)) == MIG_FILE_TYPE) &&
                    (_tcschr (leaf, TEXT('.')) == NULL)
                    ) {
                    // let's try one more thing
                    tempString = JoinText (leaf, TEXT("."));
                    result = TestParsedPattern (enumData->LeafParsedPattern, tempString);
                    FreeText (tempString);
                }
            }
        }

        if (result) {
            DEBUGMSG ((DBG_FLOW, "IsmExecuteHooks request for an object that was or will be enumerated: %s", ObjectName));
            break;
        }
        enumData = enumData->Next;
    }
    ObsFree (node);
    ObsFree (leaf);

    oldCurrentGroup = g_CurrentGroup;
    g_CurrentGroup = NULL;

    pDoSingleEnumeration (globalTypeEnumInfo, typeEnumInfo, ObjectName, FALSE, 0);

    g_CurrentGroup = oldCurrentGroup;

    SetLastError (ERROR_SUCCESS);
}

BOOL
InitializeFlowControl (
    VOID
    )

/*++

Routine Description:

  InitializeFlowControl is called to ready the flow control unit for work.
  This function takes care of initialization of basic resources needed by the
  flow control unit.

  Flow control is dependent upon the type manager module and can only be
  initialized after type manager intialization is completed.

Arguments:

  None.

Return Value:

  TRUE if flow control was able to successfully initialize, FALSE otherwise.

--*/
{
    g_GlobalQueuePool = PmCreateNamedPool ("Global Queue Pool");
    g_UntrackedFlowPool = PmCreatePool();
    PmDisableTracking (g_UntrackedFlowPool);
    g_CurrentQueuePool = PmCreateNamedPoolEx ("Current Queue Pool", 32768);

    return TRUE;
}


VOID
pAddTypeToEnumerationEnvironment (
    IN      PMHANDLE Pool,
    IN      PGROWLIST *TypeData,
    IN      MIG_OBJECTTYPEID TypeId
    )
{
    TYPEENUMINFO data;

    ZeroMemory (&data, sizeof (TYPEENUMINFO));
    data.ObjectTypeId = TypeId | g_IsmModulePlatformContext;
    data.TypeName = PmDuplicateString (Pool, GetObjectTypeName (TypeId));

    GlAppend (*TypeData, (PBYTE) &data, sizeof (TYPEENUMINFO));
}


VOID
AddTypeToGlobalEnumerationEnvironment (
    IN      MIG_OBJECTTYPEID TypeId
    )
{
    pAddTypeToEnumerationEnvironment (g_GlobalQueuePool, &g_GlobalTypeData, TypeId);
}


BOOL
PrepareEnumerationEnvironment (
    BOOL GlobalEnv
    )
{
    MIG_OBJECTTYPEID typeId;
    PGROWLIST *typeData;
    PMHANDLE pool;
    MIG_OBJECTTYPEIDENUM objTypeIdEnum;

    if (GlobalEnv) {
        typeData = &g_GlobalTypeData;
        pool = g_GlobalQueuePool;
    } else {
        typeData = &g_TypeData;
        pool = g_CurrentQueuePool;
    }

    *typeData = (PGROWLIST) PmGetMemory (pool, sizeof (GROWLIST));
    ZeroMemory (*typeData, sizeof (GROWLIST));

    //
    // Initialize type data with all known types. For global types, we expect
    // this list to be empty.
    //
    if (IsmEnumFirstObjectTypeId (&objTypeIdEnum)) {
        do {
            typeId = objTypeIdEnum.ObjectTypeId;
            pAddTypeToEnumerationEnvironment (pool, typeData, typeId);
        } while (IsmEnumNextObjectTypeId (&objTypeIdEnum));
    }

    return TRUE;
}

BOOL
ClearEnumerationEnvironment (
    IN      BOOL GlobalData
    )
{
    PGROWLIST *typeData;

    if (GlobalData) {
        typeData = &g_GlobalTypeData;
    } else {
        typeData = &g_TypeData;
    }

    if (*typeData) {
        //
        // Clean up the grow lists, but forget about the rest because
        // it all was allocated from the queue pool
        //

        GlFree (*typeData);
        *typeData = NULL;
    }

    g_PreEnumerationFunctionList = NULL;
    g_PostEnumerationFunctionList = NULL;

    if (GlobalData) {
        PmEmptyPool (g_GlobalQueuePool);
    } else {
        PmEmptyPool (g_CurrentQueuePool);
    }

    return TRUE;
}

VOID
TerminateFlowControl (
    VOID
    )

/*++

Routine Description:

  TerminateFlowControl should be called when flow control services are no
  longer needed. This function ensures that flow control resources are freed.

Arguments:

  None.

Return Value:

  None.

--*/

{
    GbFree (&g_EnumerationList);

    PmEmptyPool (g_CurrentQueuePool);
    PmDestroyPool (g_CurrentQueuePool);
    g_CurrentQueuePool = NULL;

    PmEmptyPool (g_GlobalQueuePool);
    PmDestroyPool (g_GlobalQueuePool);
    g_GlobalQueuePool = NULL;

    PmEmptyPool (g_UntrackedFlowPool);
    PmDestroyPool (g_UntrackedFlowPool);
    g_UntrackedFlowPool = NULL;

    GlFree (&g_AcquireList);
    GlFree (&g_EnumList);
    GlFree (&g_EnumAddList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\cobra\engine\ism\ismp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ismp.h

Abstract:

    Declares types, constants, macros, etc., internal to the ISM source modules.

Author:

    Jim Schmidt (jimschm) 02-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "logmsg.h"


//
// Strings
//

#define S_COMMON                        TEXT("Common")
#define S_PROHIBITED_COMBINATIONS       TEXT("Prohibited Operation Combinations")
#define S_IGNORED_COLLISIONS            TEXT("Ignored Operation Collisions")
#define S_SHORTLONG_TREE                TEXT("ShortLong")
#define S_OBJECTCOUNT                   TEXT("ObjectCount")

#define S_TOTAL_OBJECTS                 TEXT("TotalObjects")
#define S_LEFT_SIDE_OBJECTS             TEXT("LeftSideObjects")
#define S_PERSISTENT_OBJECTS            TEXT("PersistentObjects")
#define S_APPLY_OBJECTS                 TEXT("ApplyObjects")

#define S_TRANSPORT_PREFIX              TEXT("TransportVariable")

//
// Constants
//

#ifdef DEBUG

#define TRACK_ENTER()       TrackPushEx (NULL, File, Line, TRUE)
#define TRACK_LEAVE()       TrackPop ()

#else

#define TRACK_ENTER()
#define TRACK_LEAVE()

#endif

#define MAX_OBJECT_LEVEL 0xFFFFFFFF
#define ATTRIBUTE_INDEX 0
#define PROPERTY_INDEX  1
#define OPERATION_INDEX 2

//
// Used by short file names preservation
//
#define FILENAME_UNDECIDED     0x00000000
#define FILENAME_LONG          0x00000001
#define FILENAME_SHORT         0x00000002

//
// Used by rollback
//
#define JRN_SIGNATURE               0x4A4D5355   //USMJ
#define JRN_VERSION                 0x00000001
#define JOURNAL_HEADER_SIZE         (2 * sizeof (DWORD))
#define JOURNAL_USER_DATA_SIZE      (4 * MAX_TCHAR_PATH + sizeof (BOOL))
#define JOURNAL_FULL_HEADER_SIZE    (JOURNAL_HEADER_SIZE + JOURNAL_USER_DATA_SIZE)

// Used by per-user delayed operations journal
#define JRN_USR_SIGNATURE           0x4A4D534A   //USMU
#define JRN_USR_VERSION             0x00000001
#define JRN_USR_DIRTY               0x00000001
#define JRN_USR_COMPLETE            0x00000002
#define JRN_USR_HEADER_SIZE         (3 * sizeof (DWORD))

// High Priority/Low Priority operations
#define OP_HIGH_PRIORITY            0x00000001
#define OP_LOW_PRIORITY             0x00000002
#define OP_ALL_PRIORITY             OP_HIGH_PRIORITY|OP_LOW_PRIORITY

//
// Macros
//

#define ISRIGHTSIDEOBJECT(ObjectTypeId)     ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_DESTINATION)
#define ISLEFTSIDEOBJECT(ObjectTypeId)      ((ObjectTypeId & PLATFORM_MASK) == PLATFORM_SOURCE)

//
// Types
//

typedef struct {
    BOOL Initialized;
    PCTSTR EtmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PETMINITIALIZE EtmInitialize;
    PETMPARSE EtmParse;
    PETMTERMINATE EtmTerminate;
    PETMNEWUSERCREATED EtmNewUserCreated;
    BOOL ShouldBeCalled;
} ETMDATA, *PETMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR VcmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PVCMINITIALIZE VcmInitialize;
    PVCMPARSE VcmParse;
    PVCMQUEUEENUMERATION VcmQueueEnumeration;
    PVCMQUEUEHIGHPRIORITYENUMERATION VcmQueueHighPriorityEnumeration;
    PVCMTERMINATE VcmTerminate;
    BOOL ShouldBeCalled;
} VCMDATA, *PVCMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR SgmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PSGMINITIALIZE SgmInitialize;
    PSGMPARSE SgmParse;
    PSGMQUEUEENUMERATION SgmQueueEnumeration;
    PSGMQUEUEHIGHPRIORITYENUMERATION SgmQueueHighPriorityEnumeration;
    PSGMTERMINATE SgmTerminate;
    BOOL ShouldBeCalled;
} SGMDATA, *PSGMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR SamPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PSAMINITIALIZE SamInitialize;
    PSAMEXECUTE SamExecute;
    PSAMESTIMATEPROGRESSBAR SamEstimateProgressBar;
    PSAMTERMINATE SamTerminate;
    BOOL ShouldBeCalled;
} SAMDATA, *PSAMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR DgmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PDGMINITIALIZE DgmInitialize;
    PDGMQUEUEENUMERATION DgmQueueEnumeration;
    PDGMQUEUEHIGHPRIORITYENUMERATION DgmQueueHighPriorityEnumeration;
    PDGMTERMINATE DgmTerminate;
    BOOL ShouldBeCalled;
} DGMDATA, *PDGMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR DamPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PDAMINITIALIZE DamInitialize;
    PDAMEXECUTE DamExecute;
    PDAMESTIMATEPROGRESSBAR DamEstimateProgressBar;
    PDAMTERMINATE DamTerminate;
    BOOL ShouldBeCalled;
} DAMDATA, *PDAMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR CsmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PCSMINITIALIZE CsmInitialize;
    PCSMEXECUTE CsmExecute;
    PCSMESTIMATEPROGRESSBAR CsmEstimateProgressBar;
    PCSMTERMINATE CsmTerminate;
    BOOL ShouldBeCalled;
} CSMDATA, *PCSMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR OpmPath;
    PCTSTR Group;
    HANDLE LibHandle;
    POPMINITIALIZE OpmInitialize;
    POPMTERMINATE OpmTerminate;
    BOOL ShouldBeCalled;
} OPMDATA, *POPMDATA;

typedef struct {
    BOOL Initialized;
    PCTSTR TransportPath;
    PCTSTR Group;
    HANDLE LibHandle;
    PTRANSPORTINITIALIZE TransportInitialize;
    PTRANSPORTTERMINATE TransportTerminate;
    PTRANSPORTQUERYCAPABILITIES TransportQueryCapabilities;
    PTRANSPORTSETSTORAGE TransportSetStorage;
    PTRANSPORTRESETSTORAGE TransportResetStorage;
    PTRANSPORTSAVESTATE TransportSaveState;
    PTRANSPORTRESUMESAVESTATE TransportResumeSaveState;
    PTRANSPORTBEGINAPPLY TransportBeginApply;
    PTRANSPORTRESUMEAPPLY TransportResumeApply;
    PTRANSPORTACQUIREOBJECT TransportAcquireObject;
    PTRANSPORTRELEASEOBJECT TransportReleaseObject;
    PTRANSPORTENDAPPLY TransportEndApply;
    PTRANSPORTESTIMATEPROGRESSBAR TransportEstimateProgressBar;
    BOOL ShouldBeCalled;
} TRANSPORTDATA, *PTRANSPORTDATA;

typedef struct {
    MIG_PLATFORMTYPEID Platform;
    ENVENTRY_TYPE EnvEntryType;
    PCTSTR EnvEntryGroup;
    PCTSTR EnvEntryName;
    UINT EnvEntryDataSize;
    PBYTE EnvEntryData;
    MEMDB_ENUM Handle;
} ENV_ENTRY_ENUM, *PENV_ENTRY_ENUM;

typedef struct {
    HANDLE FileHandle;
    HANDLE MapHandle;
    TCHAR TempFile [MAX_PATH];
    BOOL Moved;
    BOOL OkToMove;
    ULONG_PTR TransportArg;
} ACQUIREHANDLE, *PACQUIREHANDLE;

typedef struct {
    MIG_OBJECTTYPEID ObjectTypeId;
    PPARSEDPATTERNW PlainNodeParsedPattern;
    PPARSEDPATTERNW NodeParsedPattern;
    PPARSEDPATTERNW LeafParsedPattern;
} DBENUM_ARGS, *PDBENUM_ARGS;

typedef struct {
    PCTSTR UserName;
    PCTSTR DomainName;
    PCTSTR AccountName;
    PCTSTR UserProfileRoot;
    PCTSTR MapKey;
    PCTSTR UserHive;
    PCTSTR UserStringSid;
    PSID UserSid;
    PCTSTR DelayedOpJrn;
    HANDLE DelayedOpJrnHandle;

    // internal members
    PMHANDLE AllocPool;
} TEMPORARYPROFILE, *PTEMPORARYPROFILE;

typedef struct {
    PCTSTR UserName;
    PCTSTR UserDomain;
    PCTSTR UserStringSid;
    PCTSTR UserProfilePath;

    // internal members
    PMHANDLE AllocPool;
} CURRENT_USER_DATA, *PCURRENT_USER_DATA;

//
// group registration enumeration
//

typedef struct {
    KEYHANDLE GroupOrItemId;
    BOOL ItemId;

    // private members
    MEMDB_ENUM EnumStruct;
} GROUPREGISTRATION_ENUM, *PGROUPREGISTRATION_ENUM;

typedef BOOL (GROUPITEM_CALLBACK_PROTOTYPE)(KEYHANDLE ItemId, BOOL FirstPass, ULONG_PTR Arg);
typedef GROUPITEM_CALLBACK_PROTOTYPE * GROUPITEM_CALLBACK;

typedef enum {
    RECURSE_NOT_NEEDED,
    RECURSE_SUCCESS,
    RECURSE_FAIL
} RECURSERETURN;

//
// Restore callbacks
//

typedef struct _TAG_RESTORE_STRUCT {
    PMIG_RESTORECALLBACK RestoreCallback;
    //
    // Linkage.
    //
    struct _TAG_RESTORE_STRUCT * Next;
} RESTORE_STRUCT, *PRESTORE_STRUCT;

typedef struct {
    PRESTORE_STRUCT RestoreStruct;
    PMIG_RESTORECALLBACK RestoreCallback;
} MIG_RESTORECALLBACK_ENUM, *PMIG_RESTORECALLBACK_ENUM;

//
// Object compare callbacks
//

typedef struct _TAG_COMPARE_STRUCT {
    MIG_OBJECTTYPEID ObjectTypeId;
    PMIG_COMPARECALLBACK CompareCallback;
    //
    // Linkage.
    //
    struct _TAG_COMPARE_STRUCT * Next;
} COMPARE_STRUCT, *PCOMPARE_STRUCT;

typedef struct {
    PCOMPARE_STRUCT CompareStruct;
    PMIG_COMPARECALLBACK CompareCallback;
} MIG_COMPARECALLBACK_ENUM, *PMIG_COMPARECALLBACK_ENUM;

//
// Globals
//

extern MIG_OBJECTCOUNT g_TotalObjects;
extern MIG_OBJECTCOUNT g_SourceObjects;
extern MIG_OBJECTCOUNT g_DestinationObjects;
extern PCTSTR g_CurrentGroup;
extern HINF g_IsmInf;
extern PMHANDLE g_IsmPool;
extern PMHANDLE g_IsmUntrackedPool;
extern UINT g_IsmCurrentPlatform;
extern UINT g_IsmModulePlatformContext;
extern MIG_ATTRIBUTEID g_PersistentAttributeId;
extern PTRANSPORTDATA g_SelectedTransport;
extern HANDLE g_ActivityEvent;
extern PCTSTR g_JournalDirectory;
extern HANDLE g_JournalHandle;
extern BOOL g_RollbackMode;
extern BOOL g_JournalUsed;
extern HASHTABLE g_ModuleTable;
extern HASHTABLE g_EtmTable;
extern HASHTABLE g_VcmTable;
extern HASHTABLE g_SgmTable;
extern HASHTABLE g_SamTable;
extern HASHTABLE g_DgmTable;
extern HASHTABLE g_DamTable;
extern HASHTABLE g_CsmTable;
extern HASHTABLE g_OpmTable;
extern PMIG_LOGCALLBACK g_LogCallback;
extern HASHTABLE g_TransportTable;
extern BOOL g_ExecutionInProgress;
extern GROWLIST g_AcquireHookList;
extern GROWLIST g_EnumHookList;
extern PPROGRESSBARFN g_ProgressBarFn;
extern MIG_PROGRESSPHASE g_CurrentPhase;

#ifdef PRERELEASE
// crash hooks
extern DWORD g_CrashCountObjects;
extern MIG_OBJECTTYPEID g_CrashNameTypeId;
extern PCTSTR g_CrashNameObject;
#endif

//
// Macro expansion list
//

// None

//
// Macro expansion definition
//

// None

//
// Private function prototypes
//

BOOL
CheckCancel (
    VOID
    );

MIG_OBJECTTYPEID
FixObjectTypeId (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

MIG_OBJECTTYPEID
FixEnumerationObjectTypeId (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
InitializeTypeMgr (
    VOID
    );

VOID
TerminateTypeMgr (
    VOID
    );

BOOL
InitializeEnv (
    VOID
    );

VOID
TerminateEnv (
    VOID
    );

BOOL
EnumFirstObjectOfType (
    OUT     PMIG_TYPEOBJECTENUM EnumPtr,
    IN      MIG_OBJECTTYPEID TypeId,
    IN      PCTSTR Pattern,
    IN      UINT MaxLevel
    );

BOOL
EnumNextObjectOfType (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    );

VOID
AbortObjectOfTypeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    );

VOID
AbortCurrentNodeEnum (
    IN OUT  PMIG_TYPEOBJECTENUM EnumPtr
    );

MIG_OBJECTTYPEID
GetObjectTypeId (
    IN      PCTSTR TypeName
    );

PCTSTR
GetObjectTypeName (
    IN      MIG_OBJECTTYPEID TypeId
    );

PCTSTR
GetDecoratedObjectPathFromName (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR ObjectName,
    IN      BOOL CanContainPattern
    );

BOOL
InitializeFlowControl (
    VOID
    );

VOID
TerminateFlowControl (
    VOID
    );

BOOL
DoAllObjectEnumerations (
    MIG_PROGRESSSLICEID SliceId
    );

UINT
EstimateAllObjectEnumerations (
    MIG_PROGRESSSLICEID SliceId,
    BOOL PreEstimate
    );

VOID
AddTypeToGlobalEnumerationEnvironment (
    IN      MIG_OBJECTTYPEID TypeId
    );

BOOL
PrepareEnumerationEnvironment (
    IN      BOOL GlobalEnvironment
    );

BOOL
ClearEnumerationEnvironment (
    IN      BOOL GlobalEnvironment
    );

LONGLONG
AppendProperty (
    PCMIG_BLOB Property
    );

BOOL
GetProperty (
    IN      LONGLONG Offset,
    IN OUT  PGROWBUFFER Buffer,                 OPTIONAL
    OUT     PBYTE PreAllocatedBuffer,           OPTIONAL
    OUT     PUINT Size,                         OPTIONAL
    OUT     PMIG_BLOBTYPE PropertyDataType      OPTIONAL
    );

BOOL
CreatePropertyStruct (
    OUT     PGROWBUFFER Buffer,
    OUT     PMIG_BLOB PropertyStruct,
    IN      LONGLONG Offset
    );

BOOL
IsObjectLocked (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
IsHandleLocked (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    );

BOOL
TestLock (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    );

VOID
LockHandle (
    IN      MIG_OBJECTID ObjectId,
    IN      KEYHANDLE Handle
    );

PCTSTR
GetObjectNameForDebugMsg (
    IN      MIG_OBJECTID ObjectId
    );

BOOL
InitializeOperations (
    VOID
    );

VOID
TerminateOperations (
    VOID
    );

BOOL
IsValidCName (
    IN      PCTSTR Name
    );

BOOL
IsValidCNameWithDots (
    IN      PCTSTR Name
    );

BOOL
MarkGroupIds (
    IN      PCTSTR MemDbKey
    );

BOOL
IsGroupId (
    IN      KEYHANDLE Id
    );

BOOL
IsItemId (
    IN      KEYHANDLE Id
    );

VOID
EngineError (
    VOID
    );

BOOL
ApplyOperationsOnObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      BOOL TreeFiltersOnly,
    IN      BOOL NoRestoreObject,
    IN      DWORD OperationPriority,
    IN      PMIG_CONTENT ApplyInput,            OPTIONAL
    OUT     PMIG_FILTEROUTPUT FilterOutput,
    OUT     PMIG_CONTENT ApplyOutput            OPTIONAL
    );

VOID
FreeApplyOutput (
    IN      PCMIG_CONTENT OriginalContent,
    IN      PMIG_CONTENT FinalContent
    );

VOID
FreeFilterOutput (
    IN      MIG_OBJECTSTRINGHANDLE OriginalString,
    IN      PMIG_FILTEROUTPUT FilterOutput
    );

KEYHANDLE
GetGroupOfId (
    IN      KEYHANDLE Handle
    );

BOOL
EnumFirstGroupRegistration (
    OUT     PGROUPREGISTRATION_ENUM EnumPtr,
    IN      KEYHANDLE GroupId
    );

BOOL
EnumNextGroupRegistration (
    IN OUT  PGROUPREGISTRATION_ENUM EnumPtr
    );

VOID
AbortGroupRegistrationEnum (
    IN      PGROUPREGISTRATION_ENUM EnumPtr
    );

BOOL
ValidateModuleName (
    IN      PCTSTR ModuleName
    );

RECURSERETURN
RecurseForGroupItems (
    IN      KEYHANDLE GroupId,
    IN      GROUPITEM_CALLBACK Callback,
    IN      ULONG_PTR Arg,
    IN      BOOL ExecuteOnly,
    IN      BOOL LogicalOrOnResults
    );

BOOL
InitializeProperties (
    IN      MIG_PLATFORMTYPEID Platform,
    IN      BOOL VcmMode
    );

VOID
TerminateProperties (
    IN      MIG_PLATFORMTYPEID Platform
    );

LONGLONG
OffsetFromPropertyDataId (
    IN      MIG_PROPERTYDATAID PropertyDataId
    );

BOOL
DbEnumFillStruct (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      PCTSTR Pattern,
    OUT     PDBENUM_ARGS Args
    );

VOID
DbEnumFreeStruct (
    IN      PDBENUM_ARGS Args
    );

BOOL
DbEnumFind (
    IN      PCWSTR KeySegment
    );

BOOL
DbEnumMatch (
    IN      PCVOID InboundArgs,
    IN      PCWSTR KeySegment
    );

BOOL
DbEnumFirst (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    OUT     PMEMDB_ENUM EnumPtr,
    IN      PCTSTR PatternString,
    OUT     PDBENUM_ARGS ArgsStruct
    );

VOID
EnvInvalidateCallbacks (
    VOID
    );

BOOL
EnvSaveEnvironment (
    IN OUT  PGROWLIST GrowList
    );

BOOL
EnvRestoreEnvironment (
    IN      PGROWLIST GrowList
    );

PTSTR
GetFirstSeg (
    IN      PCTSTR SrcFileName
    );

MIG_OBJECTID
GetObjectIdForModification (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE EncodedObjectName
    );

BOOL
RestoreObject (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      ENCODEDSTRHANDLE ObjectName,
    OUT     MIG_COMPARERESULT *Compare,             OPTIONAL
    IN      DWORD OperationPriority,
    OUT     PBOOL DeleteFailed
    );

BOOL
RegisterInternalAttributes (
    VOID
    );

BOOL
EnumFirstRestoreCallback (
    OUT     PMIG_RESTORECALLBACK_ENUM RestoreCallbackEnum
    );

BOOL
EnumNextRestoreCallback (
    OUT     PMIG_RESTORECALLBACK_ENUM RestoreCallbackEnum
    );

BOOL
ShouldObjectBeRestored (
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTID ObjectId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectName
    );

BOOL
EnumFirstCompareCallback (
    OUT     PMIG_COMPARECALLBACK_ENUM CompareCallbackEnum
    );

BOOL
EnumNextCompareCallback (
    OUT     PMIG_COMPARECALLBACK_ENUM CompareCallbackEnum
    );

VOID
InitRegistryType (
    VOID
    );

VOID
DoneRegistryType (
    VOID
    );

VOID
InitIniType (
    VOID
    );

VOID
DoneIniType (
    VOID
    );

VOID
InitFileType (
    VOID
    );

VOID
DoneFileType (
    VOID
    );

VOID
InitDataType (
    VOID
    );

VOID
DoneDataType (
    VOID
    );

BOOL
DataTypeAddObject (
    IN      MIG_OBJECTSTRINGHANDLE ObjectName,
    IN      PCTSTR ObjectLocation,
    IN      BOOL MakePersistent
    );

BOOL
CanObjectTypeBeRestored (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
CanObjectTypeBeModified (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

HASHTABLE
GetTypeExclusionTable (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
EnumFirstPhysicalObject (
    OUT     PMIG_OBJECT_ENUM ObjectEnum,
    IN      MIG_OBJECTTYPEID ObjectTypeId,
    IN      MIG_OBJECTSTRINGHANDLE ObjectPattern
    );

BOOL
EnumNextPhysicalObject (
    IN OUT  PMIG_OBJECT_ENUM ObjectEnum
    );

VOID
AbortPhysicalObjectEnum (
    IN      PMIG_OBJECT_ENUM ObjectEnum
    );

BOOL
IncrementTotalObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
IncrementPersistentObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
DecrementPersistentObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
IncrementApplyObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
DecrementApplyObjectCount (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

PMIG_OBJECTCOUNT
GetTypeObjectsStatistics (
    IN      MIG_OBJECTTYPEID ObjectTypeId
    );

BOOL
SavePerObjectStatistics (
    VOID
    );

BOOL
LoadPerObjectStatistics (
    VOID
    );

BOOL
EnvEnumerateFirstEntry (
    OUT     PENV_ENTRY_ENUM EnvEntryEnum,
    IN      MIG_PLATFORMTYPEID Platform,
    IN      PCTSTR Pattern
    );

BOOL
EnvEnumerateNextEntry (
    IN OUT  PENV_ENTRY_ENUM EnvEntryEnum
    );

VOID
AbortEnvEnumerateEntry (
    IN OUT  PENV_ENTRY_ENUM EnvEntryEnum
    );

PTEMPORARYPROFILE
OpenTemporaryProfile (
    IN      PCTSTR UserName,
    IN      PCTSTR Domain
    );

BOOL
SelectTemporaryProfile (
    IN      PTEMPORARYPROFILE Profile
    );

BOOL
CloseTemporaryProfile (
    IN      PTEMPORARYPROFILE Profile,
    IN      BOOL MakeProfilePermanent
    );

BOOL
MapUserProfile (
    IN      PCTSTR UserStringSid,
    IN      PCTSTR UserProfilePath
    );

BOOL
UnmapUserProfile (
    IN      PCTSTR UserStringSid
    );

BOOL
DeleteUserProfile (
    IN      PCTSTR UserStringSid,
