  Manager asks for additional property pages.

Arguments:

    Info  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    AddFunc - function ptr to call to add sheet.
    Lparam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

--*/
BOOL APIENTRY MxSerialPortPropPageProvider(LPVOID               Info,
                                         LPFNADDPROPSHEETPAGE AddFunc,
                                         LPARAM               Lparam
                                         )
{
   PSP_PROPSHEETPAGE_REQUEST pprPropPageRequest;
   PROPSHEETPAGE             psp;
   HPROPSHEETPAGE            hpsp;
   PPORT_PARAMS              params = NULL; 

   pprPropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;

   //
   // Allocate and zero out memory for the struct that will contain
   // page specific data
   //
   params = (PPORT_PARAMS) LocalAlloc(LPTR, sizeof(PORT_PARAMS));

   if (!params) {
       return FALSE;
   }

   if (pprPropPageRequest->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {
        InitPortParams(params,
                       pprPropPageRequest->DeviceInfoSet,
                       pprPropPageRequest->DeviceInfoData);

        hpsp = InitSettingsPage(&psp, params);
      
        if (!hpsp) {
            return FALSE;
        }
        
        if (!(*AddFunc)(hpsp, Lparam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
} /* SerialPortPropPageProvider */


UINT CALLBACK
PortSettingsDlgCallback(HWND hwnd,
                        UINT uMsg,
                        LPPROPSHEETPAGE ppsp)
{
    PPORT_PARAMS params;

    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        params = (PPORT_PARAMS) ppsp->lParam;
        LocalFree(params);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

void
Port_OnCommand(
    HWND DialogHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    );


BOOL
Port_OnInitDialog(
    HWND    DialogHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    );

BOOL
Port_OnNotify(
    HWND    DialogHwnd,
    LPNMHDR NmHdr
    );

/*++

Routine Description: PortSettingsDlgProc

    The windows control function for the Port Settings properties window

Arguments:

    hDlg, uMessage, wParam, lParam: standard windows DlgProc parameters

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
INT_PTR APIENTRY
PortSettingsDlgProc(IN HWND   hDlg,
                    IN UINT   uMessage,
                    IN WPARAM wParam,
                    IN LPARAM lParam)
{
    switch(uMessage) {
    case WM_COMMAND:
        Port_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_INITDIALOG:
        return Port_OnInitDialog(hDlg, (HWND)wParam, lParam); 

    case WM_NOTIFY:
        return Port_OnNotify(hDlg,  (NMHDR *)lParam);
    }

    return FALSE;
} /* PortSettingsDialogProc */


void
Port_OnCommand(
    HWND DialogHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PPORT_PARAMS params = (PPORT_PARAMS)GetWindowLongPtr(DialogHwnd, DWLP_USER);

    if (NotifyCode == CBN_SELCHANGE) {
        PropSheet_Changed(GetParent(DialogHwnd), DialogHwnd);
    }
    else {
        switch (ControlId) {
        //
        // Because this is a prop sheet, we should never get this.
        // All notifications for ctrols outside of the sheet come through
        // WM_NOTIFY
        //
        case IDCANCEL:
            EndDialog(DialogHwnd, 0); 
            return;
        }
    }
}


BOOL
Port_OnInitDialog(
    HWND    DialogHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PPORT_PARAMS params;

    //
    // on WM_INITDIALOG call, lParam points to the property
    // sheet page.
    //
    // The lParam field in the property sheet page struct is set by the
    // caller. When I created the property sheet, I passed in a pointer
    // to a struct containing information about the device. Save this in
    // the user window long so I can access it on later messages.
    //
    params = (PPORT_PARAMS) ((LPPROPSHEETPAGE)Lparam)->lParam;
    SetWindowLongPtr(DialogHwnd, DWLP_USER, (ULONG_PTR) params);
    
    //
    // Set up the combo boxes with choices
    //
    FillCommDlg(DialogHwnd);
    
    //
    // Read current settings
    //
    FillPortSettingsDlg(DialogHwnd, params);

  
    return TRUE;  // No need for us to set the focus.
}

BOOL
Port_OnNotify(
    HWND    DialogHwnd,
    LPNMHDR NmHdr
    )
{
    PPORT_PARAMS params = (PPORT_PARAMS)GetWindowLongPtr(DialogHwnd, DWLP_USER);

    switch (NmHdr->code) {
    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:
        //
        // Write out the com port options to the registry
        //
        SavePortSettingsDlg(DialogHwnd, params);
        SetWindowLongPtr(DialogHwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        return TRUE;
        
    default:
        return FALSE;
    }
}

VOID
SetCBFromRes(
    HWND   HwndCB,
    DWORD  ResId, 
    DWORD  Default,
    BOOL   CheckDecimal)
{
    TCHAR   szTemp[258], szDecSep[2], cSep;
    LPTSTR  pThis, pThat, pDecSep;
    int     iRV;
    
    if (CheckDecimal) {
        iRV = GetLocaleInfo(GetUserDefaultLCID(), LOCALE_SDECIMAL,szDecSep,2);

        if (iRV == 0) {
            //
            // following code can take only one char for decimal separator,
            // better leave the point as separator
            //
            CheckDecimal = FALSE;
        }
    }

    if (!LoadString(GhInst, ResId, szTemp, CharSizeOf(szTemp)))
        return;

    for (pThis = szTemp, cSep = *pThis++; pThis; pThis = pThat) {
        if (pThat = _tcschr( pThis, cSep))
            *pThat++ = TEXT('\0');

        if(CheckDecimal) {
            //
            // Assume dec separator in resource is '.', comment was put to this
            // effect
            //
            pDecSep = _tcschr(pThis,TEXT('.'));
            if (pDecSep) {
                //
                // assume decimal sep width == 1
                //
                *pDecSep = *szDecSep;
            }
        }
        SendMessage(HwndCB, CB_ADDSTRING, 0, (LPARAM) pThis);
    }

    SendMessage(HwndCB, CB_SETCURSEL, Default, 0L);
}

/*++

Routine Description: FillCommDlg

    Fill in baud rate, parity, etc in port dialog box

Arguments:

    hDlg: the window address

Return Value:

    BOOL: FALSE if function fails, TRUE if function passes

--*/
BOOL
FillCommDlg(
    HWND DialogHwnd
    )
{
    SHORT shIndex;
    TCHAR szTemp[81];

    //
    //  just list all of the baud rates
    //
    for(shIndex = 0; m_nBaudRates[shIndex]; shIndex++) {
        MyItoa(m_nBaudRates[shIndex], szTemp, 10);

        SendDlgItemMessage(DialogHwnd,
                           PP_PORT_BAUDRATE,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)szTemp);
    }

    //
    //  Set 9600 as default baud selection
    //
    shIndex = (USHORT) SendDlgItemMessage(DialogHwnd,
                                          PP_PORT_BAUDRATE,
                                          CB_FINDSTRING,
                                          (WPARAM)-1,
                                          (LPARAM)m_sz9600);

    shIndex = (shIndex == CB_ERR) ? 0 : shIndex;

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_BAUDRATE,
                       CB_SETCURSEL,
                       shIndex,
                       0L);

    for(shIndex = 0; m_nDataBits[shIndex]; shIndex++) {
        MyItoa(m_nDataBits[shIndex], szTemp, 10);

        SendDlgItemMessage(DialogHwnd,
                           PP_PORT_DATABITS,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)szTemp);
    }

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_DATABITS,
                       CB_SETCURSEL,
                       DEF_WORD,
                       0L);
    
    SetCBFromRes(GetDlgItem(DialogHwnd, PP_PORT_PARITY),
                 IDS_PARITY,
                 DEF_PARITY,
                 FALSE);
    
    SetCBFromRes(GetDlgItem(DialogHwnd, PP_PORT_STOPBITS),
                 IDS_BITS,
                 DEF_STOP,
                 TRUE);
    
    SetCBFromRes(GetDlgItem(DialogHwnd, PP_PORT_FLOWCTL),
                 IDS_FLOWCONTROL,
                 DEF_SHAKE,
                 FALSE);
    
    return 0;

} /* FillCommDlg */

/*++

Routine Description: FillPortSettingsDlg

    fill in the port settings dlg sheet

Arguments:

    params: the data to fill in
    hDlg:              address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
FillPortSettingsDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{
    HKEY  hDeviceKey;
    DWORD dwPortNameSize, dwError;
    TCHAR szCharBuffer[81];

    //
    // Open the device key for the source device instance, and retrieve its
    // "PortName" value.
    //
    hDeviceKey = SetupDiOpenDevRegKey(Params->DeviceInfoSet,
                                      Params->DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DEV,
                                      KEY_READ);

    if (INVALID_HANDLE_VALUE == hDeviceKey) {
        goto RetGetLastError;
    }

    dwPortNameSize = sizeof(Params->PortSettings.szComName);
    dwError = RegQueryValueEx(hDeviceKey,
                              m_szPortName,  // "PortName"
                              NULL,
                              NULL,
                              (PBYTE)Params->PortSettings.szComName,
                              &dwPortNameSize);

    RegCloseKey(hDeviceKey);

    if(ERROR_SUCCESS != dwError) {
        goto RetERROR;
    }

    //
    // create "com#:"
    //
    lstrcpy(szCharBuffer, Params->PortSettings.szComName);
    lstrcat(szCharBuffer, m_szColon);

    //
    // get values from system, fills in baudrate, parity, etc.
    //
    GetPortSettings(DialogHwnd, szCharBuffer, Params);

    if (!Params->ChangesEnabled) {
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_BAUDRATE), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_PARITY), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_DATABITS), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_STOPBITS), FALSE);
        EnableWindow(GetDlgItem(DialogHwnd, PP_PORT_FLOWCTL), FALSE);
    }

    return 0;

RetERROR:
    return dwError;

RetGetLastError:
   return GetLastError();
} /* FillPortSettingsDlg */




/*++

Routine Description: GetPortSettings

    Read in port settings from the system

Arguments:

    DialogHwnd:      address of the window
    ComName: the port we're dealing with
    Params:      where to put the information we're getting

Return Value:

    ULONG: returns error messages

--*/
void
GetPortSettings(
    IN HWND             DialogHwnd,
    IN PTCHAR           ComName,
    IN PPORT_PARAMS     Params
    )
{
    TCHAR  szParms[81];
    PTCHAR szCur, szNext;
    int    nIndex;

    //
    // read settings in from system
   //
    GetProfileString(m_szPorts,
                     ComName,
                     g_szNull,
                     szParms,
                     81);

    StripBlanks(szParms);
    if (lstrlen(szParms) == 0) {
        lstrcpy(szParms, m_szDefParams);
        WriteProfileString(m_szPorts, ComName, szParms);
    }

    szCur = szParms;

    //
    //  baud rate
    //
    szNext = strscan(szCur, m_szComma);
    if (*szNext) {
        //
        // If we found a comma, terminate
        //
        *szNext++ = 0;
    }

    //
    // current Baud Rate selection
    //
    if (*szCur) {
        Params->PortSettings.BaudRate = myatoi(szCur);
    }
    else {
        //
        // must not have been written, use default
        //
        Params->PortSettings.BaudRate = m_nBaudRates[DEF_BAUD];
    }

    //
    // set the current value in the dialog sheet
    //
    nIndex = (int)SendDlgItemMessage(DialogHwnd,
                                     PP_PORT_BAUDRATE,
                                     CB_FINDSTRING,
                                     (WPARAM)-1,
                                     (LPARAM)szCur);

    nIndex = (nIndex == CB_ERR) ? 0 : nIndex;

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_BAUDRATE,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    szCur = szNext;
 
    //
    //  parity
    //
    szNext = strscan(szCur, m_szComma);

    if (*szNext) {
        *szNext++ = 0;
    }
    StripBlanks(szCur);

    switch(*szCur) {
    case TEXT('o'):
        nIndex = PAR_ODD;
        break;

    case TEXT('e'):
        nIndex = PAR_EVEN;
        break;

    case TEXT('n'):
        nIndex = PAR_NONE;
        break;

    case TEXT('m'):
        nIndex = PAR_MARK;
        break;

    case TEXT('s'):
        nIndex = PAR_SPACE;
        break;

    default:
        nIndex = DEF_PARITY;
        break;
    }

    Params->PortSettings.Parity = nIndex;
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_PARITY,
                        CB_SETCURSEL,
                       nIndex,
                       0L);
    szCur = szNext;

    //
    //  word length: 4 - 8
    //
    szNext = strscan(szCur, m_szComma);

    if (*szNext) {
        *szNext++ = 0;
    }

    StripBlanks(szCur);
    nIndex = *szCur - TEXT('5');

    if (nIndex < 0 || nIndex > 3) {
        nIndex = DEF_WORD;
    }

    Params->PortSettings.DataBits = nIndex;
    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_DATABITS,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    szCur = szNext;

    //
    //  stop bits
    //
    szNext = strscan(szCur, m_szComma);

    if (*szNext) {
       *szNext++ = 0;
    }

    StripBlanks(szCur);

    if (!lstrcmp(szCur, TEXT("1"))) {
        nIndex = STOP_1;
    }
    else if(!lstrcmp(szCur, TEXT("1.5"))) {
        nIndex = STOP_15;
    }
    else if(!lstrcmp(szCur, TEXT("2"))) {
        nIndex = STOP_2;
    }
    else {
        nIndex = DEF_STOP;
    }

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_STOPBITS,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    Params->PortSettings.StopBits = nIndex;
    szCur = szNext;

    //
    //  handshaking: Hardware, xon/xoff, or none
    //
    szNext = strscan(szCur, m_szComma);

    if (*szNext) {
        *szNext++ = 0;
    }

    StripBlanks(szCur);

    if (*szCur == TEXT('p')) {
        nIndex = FLOW_HARD;
    }
    else if (*szCur == TEXT('x')) {
        nIndex = FLOW_XON;
    }
    else {
        nIndex = FLOW_NONE;
    }

    SendDlgItemMessage(DialogHwnd,
                       PP_PORT_FLOWCTL,
                       CB_SETCURSEL,
                       nIndex,
                       0L);

    Params->PortSettings.FlowControl = nIndex;
} /* GetPortSettings */


/*++

Routine Description: SavePortSettingsDlg

    save changes in the Ports Settings dlg sheet

Arguments:

    Params: where to save the data to
    ParentHwnd:              address of the window

Return Value:

    ULONG: returns error messages

--*/
ULONG
SavePortSettingsDlg(
    IN HWND             DialogHwnd,
    IN PPORT_PARAMS     Params
    )
{
    TCHAR szCharBuffer[81];

    //
    // create "com#:"
    //
    // lstrcpy(szCharBuffer, Params->pAdvancedData->szNewComName);
    lstrcpy(szCharBuffer, Params->PortSettings.szComName);
    lstrcat(szCharBuffer, m_szColon);
 
    //
    //  store changes to win.ini; broadcast changes to apps
    //
    SavePortSettings(DialogHwnd, szCharBuffer, Params);
 
    return 0;
} /* SavePortSettingsDlg */




/*++

Routine Description: SavePortSettings

    Read the dlg screen selections for baudrate, parity, etc.
    If changed from what we started with, then save them

Arguments:

    hDlg:      address of the window
    szComName: which comport we're dealing with
    Params:      contains, baudrate, parity, etc

Return Value:

    ULONG: returns error messages

--*/
void
SavePortSettings(
    IN HWND            DialogHwnd,
    IN PTCHAR          ComName,
    IN PPORT_PARAMS    Params
    )
{
    TCHAR           szBuild[MAX_PATH];
    ULONG           i;
    PP_PORTSETTINGS pppNewPortSettings;

    //
    //  Get the baud rate
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_BAUDRATE,
                                  WM_GETTEXT,
                                  18,
                                  (LPARAM)szBuild);
    if (!i) {
       goto Return;
    }

    pppNewPortSettings.BaudRate = myatoi(szBuild);

    //
    //  Get the parity setting
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_PARITY,
                                  CB_GETCURSEL,
                                  0,
                                  0L);

    if (i == CB_ERR || i == CB_ERRSPACE) {
        goto Return;
    }

    pppNewPortSettings.Parity = i;
    lstrcat(szBuild, m_pszParitySuf[i]);

    //
    //  Get the word length
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_DATABITS,
                                  CB_GETCURSEL,
                                  0,
                                  0L);

    if (i == CB_ERR || i == CB_ERRSPACE) {
        goto Return;
    }

    pppNewPortSettings.DataBits = i;
    lstrcat(szBuild, m_pszLenSuf[i]);

    //
    //  Get the stop bits
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_STOPBITS,
                                  CB_GETCURSEL,
                                  0,
                                  0L);

    if (i == CB_ERR || i == CB_ERRSPACE) {
        goto Return;
    }

    pppNewPortSettings.StopBits = i;
    lstrcat(szBuild, m_pszStopSuf[i]);

    //
    //  Get the flow control
    //
    i = (ULONG)SendDlgItemMessage(DialogHwnd,
                                  PP_PORT_FLOWCTL,
                                  CB_GETCURSEL,
                                  0,
                                  0L);

    if (i == CB_ERR || i == CB_ERRSPACE) {
        goto Return;
    }

    pppNewPortSettings.FlowControl = i;
    lstrcat(szBuild, m_pszFlowSuf[i]);

    //
    // if any of the values changed, then save it off
    //
    if (Params->PortSettings.BaudRate    != pppNewPortSettings.BaudRate ||
        Params->PortSettings.Parity      != pppNewPortSettings.Parity   ||
        Params->PortSettings.DataBits    != pppNewPortSettings.DataBits ||
        Params->PortSettings.StopBits    != pppNewPortSettings.StopBits ||
        Params->PortSettings.FlowControl != pppNewPortSettings.FlowControl) {

        //
        // Write settings string to [ports] section in win.ini
        // NT translates this if a translate key is set in registry
        // and it winds up getting written to
        // HKLM\Software\Microsoft\Windows NT\CurrentVersion\Ports
        //
        WriteProfileString(m_szPorts, ComName, szBuild);

        //
        // Send global notification message to all windows
        //
        SendWinIniChange((LPTSTR)m_szPorts);

        if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                       Params->DeviceInfoSet,
                                       Params->DeviceInfoData)) {
            //
            // Possibly do something here
            //
        }
    }

Return:
   return;

} /* SavePortSettings */



///////////////////////////////////////////////////////////////////////////////
//
//   MyItoa
//
//   Desc:  To convert from ANSI to Unicode string after calling
//          CRT itoa function.
//
///////////////////////////////////////////////////////////////////////////////

#define INT_SIZE_LENGTH 20

LPTSTR 
MyItoa(INT value, LPTSTR string, INT radix)
{

#ifdef UNICODE
   CHAR   szAnsi[INT_SIZE_LENGTH];

   _itoa(value, szAnsi, radix);
   MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAnsi, -1,
                       string, INT_SIZE_LENGTH );
#else

   _itoa(value, string, radix);

#endif

   return (string);
 
} // end of MyItoa()

///////////////////////////////////////////////////////////////////////////////
//
//  StripBlanks()
//
//   Strips leading and trailing blanks from a string.
//   Alters the memory where the string sits.
//
///////////////////////////////////////////////////////////////////////////////

void 
StripBlanks(LPTSTR pszString)
{
    LPTSTR  pszPosn;

    //
    //  strip leading blanks
    //

    pszPosn = pszString;

    while (*pszPosn == TEXT(' '))
        pszPosn++;

    if (pszPosn != pszString)
        lstrcpy(pszString, pszPosn);

    //
    //  strip trailing blanks
    //

    if ((pszPosn = pszString + lstrlen(pszString)) != pszString) {
       pszPosn = CharPrev(pszString, pszPosn);

       while (*pszPosn == TEXT(' '))
           pszPosn = CharPrev(pszString, pszPosn);

       pszPosn = CharNext(pszPosn);

       *pszPosn = TEXT('\0');
    }
}


LPTSTR 
strscan(LPTSTR pszString, 
		LPTSTR pszTarget)
{
    LPTSTR psz;

    if (psz = _tcsstr( pszString, pszTarget))
        return (psz);
    else
        return (pszString + lstrlen(pszString));
}

int 
myatoi(LPTSTR pszInt)
{
    int   retval;
    TCHAR cSave;

    for (retval = 0; *pszInt; ++pszInt) {
        if ((cSave = (TCHAR) (*pszInt - TEXT('0'))) > (TCHAR) 9)
            break;

        retval = (int) (retval * 10 + (int) cSave);
    }
    return (retval);
}

void 
SendWinIniChange(LPTSTR lpSection)
{
// NOTE: We have (are) gone through several iterations of which USER
//       api is the correct one to use.  The main problem for the Control
//       Panel is to avoid being HUNG if another app (top-level window)
//       is HUNG.  Another problem is that we pass a pointer to a message
//       string in our address space.  SendMessage will 'thunk' this properly
//       for each window, but PostMessage and SendNotifyMessage will not.
//       That finally brings us to try to use SendMessageTimeout(). 9/21/92
//
// Try SendNotifyMessage in build 260 or later - kills earlier builds
//    SendNotifyMessage ((HWND)-1, WM_WININICHANGE, 0L, (LONG)lpSection);
//    PostMessage ((HWND)-1, WM_WININICHANGE, 0L, (LONG)lpSection);
//  [stevecat] 4/4/92
//
//    SendMessage ((HWND)-1, WM_WININICHANGE, 0L, (LPARAM)lpSection);
//
    //  NOTE: The final parameter (LPDWORD lpdwResult) must be NULL

    SendMessageTimeout((HWND)-1, 
					   WM_WININICHANGE, 
					   0L, 
					   (WPARAM) lpSection,
					   SMTO_ABORTIFHUNG,
					   1000, 
					   NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\admin\intellio\mxport\mxport.cpp ===
/************************************************************************
    mxport.cpp
      -- export Intellio port driver co-installer

    History:  Date          Author      Comment
              8/14/00       Casper      Wrote it.

*************************************************************************/

#include <windows.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <stdio.h>
#include <msports.h>
#include <tchar.h>
#include <regstr.h>
#include "mxdef.h"
#include "moxacfg.h"
#include "regcfg.h"
#include "regtool.h"
#include "mxdebug.h"

HINSTANCE GhInst;

extern "C" int WINAPI DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved )
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        GhInst = hDll;
        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
    default:
        break;
    }

    return TRUE;
}




static BOOL SetParent(
			IN HDEVINFO		DeviceInfoSet,
			IN PSP_DEVINFO_DATA	DeviceInfoData,
			int	pidx,
			int port)
{
	DEVINST p_DevInst;
	CHAR	p_deviceid[MAX_DEVICE_ID_LEN];
	HDEVINFO	p_DeviceInfoSet;
	SP_DEVINFO_DATA p_DeviceInfoData;
	TCHAR	tmp[MAX_PATH];


   if(CM_Get_Parent(&p_DevInst, DeviceInfoData->DevInst, 0)!=CR_SUCCESS){
      Mx_Debug_Out(TEXT("SetParent: CM_GetParent fail\n"));
      return FALSE;
   }

   if(CM_Get_Device_ID(p_DevInst, p_deviceid, MAX_DEVICE_ID_LEN, 0)!= CR_SUCCESS){
      Mx_Debug_Out(TEXT("SetParent: CM_Get_Device_ID fail\n"));
      return FALSE;
   }

   if((p_DeviceInfoSet=SetupDiCreateDeviceInfoList(NULL, NULL))==INVALID_HANDLE_VALUE){
      Mx_Debug_Out(TEXT("SetParent: SetupDiCreateDeviceInfoList fail\n"));
      return FALSE;
   }

   p_DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
   if(SetupDiOpenDeviceInfo(p_DeviceInfoSet, p_deviceid,
      NULL, 0, &p_DeviceInfoData)==FALSE){
      Mx_Debug_Out(TEXT("SetParent: SetupDiOpenDeviceInfo fail\n"));
      return FALSE;
   }

   HKEY hkey, hkey1;
   hkey = SetupDiOpenDevRegKey(
         p_DeviceInfoSet, &p_DeviceInfoData,
            DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);

   if(hkey==INVALID_HANDLE_VALUE){
      SetupDiDestroyDeviceInfoList(p_DeviceInfoSet);
      Mx_Debug_Out(TEXT("SetParent: SetupDiOpenDevRegKey fail\n"));
      return FALSE;
   }


   wsprintf( tmp, TEXT("Parameters"));
   if(RegCreateKeyEx( hkey,
         tmp, 0, NULL, 0,
            KEY_ALL_ACCESS, NULL,
            &hkey1, NULL) != ERROR_SUCCESS){
      SetupDiDestroyDeviceInfoList(p_DeviceInfoSet);
      RegCloseKey(hkey);
      Mx_Debug_Out(TEXT("SetParent: Create Parameters key fail\n"));
        return FALSE;
   }
   RegCloseKey(hkey1);

    wsprintf( tmp, TEXT("Parameters\\port%03d"), pidx+1 );
    if(RegCreateKeyEx( hkey,
         tmp, 0, NULL, 0,
            KEY_ALL_ACCESS, NULL,
            &hkey1, NULL) != ERROR_SUCCESS){
      SetupDiDestroyDeviceInfoList(p_DeviceInfoSet);
      RegCloseKey(hkey);
      Mx_Debug_Out(TEXT("SetParent: Create Parameters\\port key fail\n"));
      return FALSE;
   }
   RegCloseKey(hkey);

   DWORD value;
   wsprintf(tmp, TEXT("COM%d"), port);
   RegSetValueEx( hkey1, TEXT("PortName"), 0,
         REG_SZ, (CONST BYTE*)tmp, lstrlen(tmp)+1);
	WriteINISetting(tmp);


   value = DEF_ISFIFO;
    RegSetValueEx( hkey1, TEXT("DisableFiFo"), 0,
         REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));

   value = DEF_TXFIFO;
   RegSetValueEx( hkey1, TEXT("TxMode"), 0,
         REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));

   value = DEFPOLL;
    RegSetValueEx( hkey1, TEXT("PollingPeriod"), 0,
         REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));

   SetupDiDestroyDeviceInfoList(p_DeviceInfoSet);
   RegCloseKey(hkey1);

   /* Set Device Parameters */
   hkey = SetupDiCreateDevRegKey(DeviceInfoSet,
         DeviceInfoData,   DICS_FLAG_GLOBAL, 0,
         DIREG_DEV, NULL, NULL);
   if(hkey==INVALID_HANDLE_VALUE){
      Mx_Debug_Out(TEXT("SetParent: SetupDiCreateDevRegKey fail\n"));
      return FALSE;
   }
   wsprintf(tmp, TEXT("COM%d"), port);
   RegSetValueEx( hkey, TEXT("PortName"), 0,
         REG_SZ, (CONST BYTE*)tmp, lstrlen(tmp)+1);

   value = DEFPOLL;
    RegSetValueEx( hkey, TEXT("PollingPeriod"), 0,
         REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));

   value = DEF_ISFIFO;
    RegSetValueEx( hkey1, TEXT("DisableFiFo"), 0,
         REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));

   value = DEF_TXFIFO;
   RegSetValueEx( hkey1, TEXT("TxMode"), 0,
         REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));


   RegCloseKey(hkey);

   return TRUE;
}





extern "C" DWORD CALLBACK MxPortCoInstaller(
			IN DI_FUNCTION	InstallFunction,
			IN HDEVINFO		DeviceInfoSet,
			IN PSP_DEVINFO_DATA	DeviceInfoData	/*OPTIONAL*/,
			IN OUT PCOINSTALLER_CONTEXT_DATA	Context
)
{
	DWORD	ret = NO_ERROR;
	TCHAR	szport[MAX_PATH];
	DWORD	rSize;
	int		bidx, pidx;
	int		portnum;
	TCHAR	DevInstId[MAX_DEVICE_ID_LEN];
	HKEY	hkey1;
	TCHAR	skey[MAX_PATH];
	DWORD	value;

   DWORD type = REG_SZ;
   DWORD size = MAX_PATH;

   switch(InstallFunction){
   case DIF_NEWDEVICEWIZARD_FINISHINSTALL:
   case DIF_PROPERTYCHANGE:
        if (SetupDiGetDeviceInstanceId(
            DeviceInfoSet, DeviceInfoData ,
            DevInstId, MAX_DEVICE_ID_LEN, &rSize) == FALSE){
         Mx_Debug_Out(TEXT("PortInstaller: SetupDiGetDeviceInstanceId fail\n"));
            return GetLastError();
      }

      bidx = 0;
      pidx = 0;

      if(_stscanf(DevInstId, TEXT("MXCARD\\MXCARDB%02dP%03d"), &bidx, &pidx)!=2){
      	 break;
      }
      
      wsprintf(skey, TEXT("%s\\%s\\%04d\\Parameters\\port%03d"),
         TEXT("SYSTEM\\CurrentControlSet\\Control\\Class"),
         TEXT("{50906CB8-BA12-11D1-BF5D-0000F805F530}"),
         bidx, pidx+1);

      if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,skey, 0, KEY_READ, &hkey1)!=ERROR_SUCCESS){
         Mx_Debug_Out(TEXT("PortInstaller: Open port key fail\n"));
         return GetLastError();
      }

      if(RegQueryValueEx(hkey1, TEXT("PortName"), 0, &type, (LPBYTE)skey, &size)==ERROR_SUCCESS){
         if(_stscanf(skey, TEXT("COM%3d"), &portnum)!=1){
            portnum = 0;
         }
      }else{
         Mx_Debug_Out(TEXT("PortInstaller: Query PortName fail\n"));
         portnum = 0;
      }

      RegCloseKey(hkey1);
      if(portnum==0)
         break;

      wsprintf(szport, TEXT("MOXA Communication Port %d (COM%d)"),
         pidx+1, portnum);

      SetupDiSetDeviceRegistryProperty(
         DeviceInfoSet, DeviceInfoData, SPDRP_FRIENDLYNAME,
         (PBYTE)szport, lstrlen(szport)+1);


      /* set Device Parameters */
      hkey1 = SetupDiCreateDevRegKey(DeviceInfoSet,
            DeviceInfoData,   DICS_FLAG_GLOBAL, 0,
            DIREG_DEV, NULL, NULL);
      if(hkey1==INVALID_HANDLE_VALUE){
         Mx_Debug_Out(TEXT("Propchange: SetupDiCreateDevRegKey fail\n"));
         break;
      }

      wsprintf(skey, TEXT("COM%d"), portnum);
      RegSetValueEx( hkey1, TEXT("PortName"), 0,
            REG_SZ, (CONST BYTE*)skey, lstrlen(skey)+1);

      value = DEFPOLL;
      RegSetValueEx( hkey1, TEXT("PollingPeriod"), 0,
            REG_DWORD, (CONST BYTE*)&value, sizeof(DWORD));

      RegCloseKey(hkey1);

      break;

   case DIF_INSTALLDEVICE:

      portnum = GetFreePort();
      if(!portnum){
         MessageBox(NULL, TEXT("No avaliable COM number"), "ERROR", MB_OK);
         return NO_ERROR;
      }

        if (SetupDiGetDeviceInstanceId(
               DeviceInfoSet, DeviceInfoData ,
            DevInstId, MAX_DEVICE_ID_LEN, &rSize) == FALSE){
         Mx_Debug_Out(TEXT("PortInstaller: SetupDiGetDeviceInstanceId fail\n"));
            return GetLastError();
      }
      bidx = 0;
      pidx = 0;
      if(_stscanf(DevInstId, TEXT("MXCARD\\MXCARDB%02dP%03d"), &bidx, &pidx)!=2){
         break;
      }
      

      if(SetParent(DeviceInfoSet, DeviceInfoData, pidx, portnum)){
/*       if(!SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData))
            return GetLastError();*/
      }
/*
      wsprintf(szport, "MOXA Communication Port %d (COM%d)",
         pidx+1, portnum);
      SetupDiSetDeviceRegistryProperty(
         DeviceInfoSet, DeviceInfoData, SPDRP_FRIENDLYNAME,
         (PBYTE)szport, lstrlen(szport));*/

      break;
   case DIF_REMOVE:
        if (SetupDiGetDeviceInstanceId(
               DeviceInfoSet, DeviceInfoData ,
            DevInstId, MAX_DEVICE_ID_LEN, &rSize) == FALSE){
         Mx_Debug_Out(TEXT("PortInstaller: SetupDiGetDeviceInstanceId fail\n"));
            return GetLastError();
      }
      bidx = 0;
      pidx = 0;

      if(_stscanf(DevInstId, TEXT("MXCARD\\MXCARDB%02dP%03d"), &bidx, &pidx)!=2)
          break;
      RemovePort(DeviceInfoSet, DeviceInfoData, pidx);
      //Can not call this function in here.
/*    if(!SetupDiRemoveDevice(DeviceInfoSet, DeviceInfoData)){
         return GetLastError();
      }*/
      break;
   default:
      break;
   }
   return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\admin\intereg\intestr.cpp ===
/************************************************************************
    intestr.cpp
      -- Intellio board configuration message

    History:  Date          Author      Comment
              8/14/00       Casper      Wrote it.

*************************************************************************/


#include "stdafx.h"


LPSTR Estr_MemFail = "Memory allocate failure !";
LPSTR Estr_CodNotFound = "file not found !";
LPSTR Estr_CodLength = "file length is worng !";
LPSTR Estr_CodErr = "file data content error !";
LPSTR Estr_IsaNotFound = " at base memory [%lX] not found !";
LPSTR Estr_Download = " at base memory [%lX] download failure !";
LPSTR Estr_CPUNotFound = " at base memory [%lX] CPU/Basic module not found !";
LPSTR Estr_PortsMismatch = " at base memory [%lX] ports number mismatch !";
LPSTR Estr_Absent = " at base memory [%lX] is absent or occupied by others !";
LPSTR Estr_IrqFail = " at base memory [%lX] interrupt failure !";
LPSTR Estr_PciIrqDup ="Interrupt number conflicts with another board, please re-configure your BIOS.";
LPSTR Estr_CPUDownloadFail =" at base memory [%lX] CPU/Basic module download failure !";

LPSTR Estr_ComNum = "Port %d(COM%d) Com number invalid !";
LPSTR Estr_ComDup = "COM number conflicts between Port%d and Port%d !";
LPSTR Estr_MemDup = "Memory bank conflict between board %d and board %d !";
LPSTR Estr_BrdComDup = "COM number conflict between board %d and board %d !";
LPSTR Estr_PortMax = "Selected COM ports have exceeded max port number !";
LPSTR Estr_LoadPci = "Load mxpci.sys service fail !\nCan not get PCI informantion.\n";
LPSTR Estr_IrqErr = "Selected ISA board IRQ conflict with PCI board IRQ !";

LPSTR Estr_PortUsed = "This COM name is being used by another device (such as another com port or \
modem). Using duplicate names can lead to inaccessible devices and \
changed setting. Do you want to continue?";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\admin\intereg\intetype.cpp ===
/************************************************************************
    intetype.cpp
      -- define Intellio board type array
	  -- export Intellio board type string conversion function

    History:  Date          Author      Comment
              8/14/00       Casper      Wrote it.

*************************************************************************/

#include "stdafx.h"

#include "moxacfg.h"
#include "intetype.h"


struct PCITABSTRC GINTE_PCITab[INTE_PCINUM] = {
/* Intellio */    
    { MX_CP204J_DEVID,  I_MX_CP204,     4, "CP-204J",   "CP204J"},
    { MX_C218TPCI_DEVID,  I_MX_C218TPCI,8, "C218Turbo/PCI", "C218TPCI"},
    { MX_C320TPCI_DEVID,  I_MX_C320TPCI,  8,"C320Turbo/PCI", "C320TPCI"},
};

struct ISATABSTRC GINTE_ISATab[INTE_ISANUM] ={
    {0, I_MX_C218T, 0, 8, "C218Turbo", "C218T"},
    {1, I_MX_C320T8, 0, 8, "C320Turbo", "C320T"},
    {2, I_MX_C320T16, 0, 16, "C320Turbo", "C320T"},
    {3, I_MX_C320T24, 0, 24, "C320Turbo", "C320T"},
    {4, I_MX_C320T32, 0, 32, "C320Turbo", "C320T"},
};


void Inte_GetTypeStr(WORD boardtype, int bustype, LPSTR typestr)
{
        int		i;

        if(bustype==MX_BUS_PCI){
            for(i=0; i<INTE_PCINUM; i++){
                if(GINTE_PCITab[i].boardtype == (boardtype & (~I_PORT_MSK))){
                    lstrcpy(typestr,GINTE_PCITab[i].typestr);
                    break;
                }
            }
            if(i==INTE_PCINUM)
                lstrcpy(typestr, NoType_Str);
        }else{
            for(i=0; i<INTE_ISANUM; i++){
                if(GINTE_ISATab[i].boardtype == boardtype){
                    lstrcpy(typestr,GINTE_ISATab[i].typestr);
                    break;
                }
            }
            if(i==INTE_ISANUM)
                lstrcpy(typestr, NoType_Str);
        }
}

void Inte_GetTypeStrPorts(WORD boardtype, int bustype, int ports, LPSTR typestr)
{
        char    tmp[TYPESTRLEN+10];
        int     i;

        Inte_GetTypeStr(boardtype, bustype, typestr);

        if((boardtype & I_IS_EXT) == I_MOXA_EXT){
            for(i=0; i<PORTSCNT; i++){
                if(ports == GPortsTab[i].ports){
                    wsprintf(tmp, "%s(%s)", typestr, GPortsTab[i].ports_str);
                    lstrcpy(typestr, tmp);
                    break;
                }
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\admin\registry\regtool.cpp ===
/************************************************************************
    regtool.cpp
      -- general registry configuration function

    History:  Date          Author      Comment
              8/14/00       Casper      Wrote it.

*************************************************************************/


#include "stdafx.h"
#include <tchar.h>
#include <string.h>
#include <stdio.h>
#include <msports.h>
#include "moxacfg.h"
#include "mxdebug.h"


ULONG MxGetVenDevId(LPTSTR data)
{
	ULONG   n1=0, n2 = 0;
	TCHAR   tmp[5];

	if (_tcsncmp(data, TEXT("PCI\\"), 4) != 0)
		return (n1);

	data += 4;
	while (*data) {
		if (_tcsncmp(data, TEXT("VEN_") ,4) == 0) {
			data += 4;
			lstrcpyn(tmp, data, 5);
			if(_stscanf(tmp, TEXT("%4X"), &n1)!=1){
				n1 = 0;
			}
			n1 <<= 16;
			data += 5;
			if (_tcsncmp(data, TEXT("DEV_"),4) == 0) {
				data += 4;
				lstrcpyn(tmp, data, 5);
				if(_stscanf(tmp, TEXT("%4X"), &n2)!=1){
					n2 = 0;
				}
				n1 += n2;
			}
			return (n1);
		}
		data++;
	}
	return (n1);
}

int GetFreePort(void)
{
	DWORD	maxport;
	LPBYTE	combuf;
	HCOMDB	hcomdb;
	int		port, i;

	port = 0;

	if(ComDBOpen(&hcomdb) != ERROR_SUCCESS){
		Mx_Debug_Out(TEXT("ComDBOpen fail\n"));
		return port;
	}

	ComDBGetCurrentPortUsage (hcomdb,
			NULL, 0, CDB_REPORT_BYTES, &maxport);

	combuf = new BYTE[maxport];

        if(combuf)
        {
            // init buffer
            ZeroMemory(combuf, maxport);

            ComDBGetCurrentPortUsage (hcomdb,
                            combuf, maxport, CDB_REPORT_BYTES, &maxport);


            if(maxport > MAXPORTS)
                    maxport  = MAXPORTS;

            for(i=0; i<(int)maxport; i++){
		if(combuf[i]==0){
			port = i+1;
			break;
		}else
			continue;
            }

            delete[] combuf;
        }

	BOOL	bret;
	if(port!=0)
		ComDBClaimPort (hcomdb, port, TRUE, &bret);

	ComDBClose(hcomdb);

	return port;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\enum.c ===
/*++
Module Name:

    ENUM.C

Abstract:

    This module contains the enumeration code needed to enumerate
all ports on multiport board, and ceate the PDOs.


Environment:

    kernel mode only

Notes:


Revision History:
   

--*/

#include <ntddk.h>
#include <ntddser.h>
#include "mxenum.h"
#include "mxlog.h"


static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MxenumCreatePDO)
#pragma alloc_text(PAGE, MxenumInitPDO)
#endif

void
MxenumInitPDO (
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData)
  
/*
Description:
    Common code to initialize a newly created serenum pdo.
    Called either when the control panel exposes a device or when Serenum senses
    a new device was attached.

Parameters:
    Pdo - The pdo
    FdoData - The fdo's device extension
    Exposed - Was this pdo was found by serenum (FALSE) or was it was EXPOSEd by 
        a control panel applet (TRUE)?
*/
{
    ULONG FdoFlags = FdoData->Self->Flags;
    PPDO_DEVICE_DATA pdoData = Pdo->DeviceExtension;
    NTSTATUS status;
    ULONG	 j;
    HANDLE	keyHandle;

    PAGED_CODE();
 
    Pdo->Flags |= DO_BUFFERED_IO;
    
    //
    // Increment the pdo's stacksize so that it can pass irps through
    //
    Pdo->StackSize += FdoData->Self->StackSize;
    
    //
    // Initialize the rest of the device extension
    //
    pdoData->IsFDO = FALSE;
    pdoData->Self = Pdo;

    pdoData->ParentFdo = FdoData->Self;

    pdoData->Started = FALSE; // irp_mn_start has yet to be received
    pdoData->Attached = TRUE; // attached to the bus
    pdoData->Removed = FALSE; // no irp_mn_remove as of yet
    
    pdoData->DeviceState = PowerDeviceD0;
    pdoData->SystemState = PowerSystemWorking;

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;
    Pdo->Flags |= DO_POWER_PAGABLE;

}


NTSTATUS
MxenumCreatePDO(IN PFDO_DEVICE_DATA FdoData)
/*++

Routine Description:

    This enumerates the serenum bus which is represented by Fdo (a pointer
    to the device object representing the serial bus). It creates new PDOs
    for any new devices which have been discovered since the last enumeration

Arguments:

    FdoData - Pointer to the fdo's device extension
                for the serial bus which needs to be enumerated

Return value:

    NTSTATUS

--*/
{

  
   NTSTATUS status = STATUS_SUCCESS;
   UNICODE_STRING pdoUniName;
   PDEVICE_OBJECT pdo;
   PPDO_DEVICE_DATA pdoData;
   ULONG i,j;
   WCHAR pdoName[] = MXENUM_PDO_NAME_BASE;
   UCHAR  hardwareId[] = MXENUM_PDO_HARDWARE_ID;
   UCHAR  deviceId[] = MXENUM_PDO_DEVICE_ID;
   ULONG FdoFlags = FdoData->Self->Flags;
  
  
   PAGED_CODE();
 
   MxenumKdPrint (MXENUM_DBG_TRACE,("MxenumCreatePDO\n"));
  
   RtlInitUnicodeString(&pdoUniName, pdoName);
  
   for (i = 0; i < FdoData->NumPorts;i++) {

	 PDEVICE_OBJECT currentDevice,previousDevice;

    	  //
        // Allocate a pdo
        //
 
  
        pdoName[19] = (WCHAR)('0' + FdoData->BoardIndex / 10);
	  deviceId[14] = (UCHAR)pdoName[19];
        pdoName[20] = (WCHAR)('0' + FdoData->BoardIndex % 10);
        deviceId[15] = (UCHAR)pdoName[20];
        pdoName[22] = (WCHAR)('0' + i / 100);
	  deviceId[17] = hardwareId[6] = (UCHAR)pdoName[22];
        pdoName[23] = (WCHAR)('0' + (i % 100)/10);
	  deviceId[18] = hardwareId[7] = (UCHAR)pdoName[23];
        pdoName[24] = (WCHAR)('0' + (i % 100)%10);
	  deviceId[19] = hardwareId[8] = (UCHAR)pdoName[24] ;


        previousDevice = currentDevice = FdoData->AttachedPDO;
	  while (currentDevice != NULL) {

              for (j = 0;(j < strlen(deviceId))&&(j < (ULONG)((PPDO_DEVICE_DATA)(currentDevice->DeviceExtension))->DeviceIDs.Length >> 1);j++) {
			if (deviceId[j] != ((PPDO_DEVICE_DATA)(currentDevice->DeviceExtension))->DeviceIDs.Buffer[j])
			    break;
 		  }
		  if (j == strlen(deviceId))
		      break;
  		  previousDevice = currentDevice;
		  currentDevice = ((PPDO_DEVICE_DATA)(currentDevice->DeviceExtension))->Next;
	  }
 
	  if (currentDevice == NULL) { // New,create one
            status = IoCreateDevice(FdoData->Self->DriverObject,
                              sizeof(PDO_DEVICE_DATA), &pdoUniName,
                               FILE_DEVICE_SERIAL_PORT,
                               FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &pdo);

            if (!NT_SUCCESS(status)) {
                MxenumKdPrint(MXENUM_DBG_TRACE, ("Create device failed\n"));
		    continue;

            }
            if (previousDevice)
 		     ((PPDO_DEVICE_DATA)(previousDevice->DeviceExtension))->Next = pdo;
            else
		     FdoData->AttachedPDO = pdo;
            MxenumInitPDO(pdo, FdoData);
		pdoData = pdo->DeviceExtension;
		pdoData->PortIndex = i;  // port indexed from 0
           
        }
	  else {
		continue;
	  }
 
     

        //
        // Initialize the rest of the device object
               
	  if (pdoData->HardwareIDs.Buffer)
		ExFreePool(pdoData->HardwareIDs.Buffer);
	  pdoData->HardwareIDs.Buffer = NULL;
      
        MxenumInitMultiString( &pdoData->HardwareIDs,hardwareId ,
                                       NULL);
        if (pdoData->CompIDs.Buffer)
		ExFreePool(pdoData->CompIDs.Buffer);
	  pdoData->CompIDs.Buffer = NULL;

        MxenumInitMultiString( &pdoData->CompIDs,
						   MXENUM_PDO_COMPATIBLE_ID,
                                       NULL);
        if (pdoData->DeviceIDs.Buffer)
		ExFreePool(pdoData->DeviceIDs.Buffer);
	  pdoData->DeviceIDs.Buffer = NULL;
 
        MxenumInitMultiString(&pdoData->DeviceIDs,
						   deviceId,
                                       NULL);
        FdoData->NumPDOs++;

 
   }
  

//   EnumPDOsErr:;

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\admin\registry\strdef.cpp ===
/************************************************************************
    strdef.cpp
      -- define GUI display string <--> string id conversion array struc
	  -- for All MOXA board.

    History:  Date          Author      Comment
              8/14/00       Casper      Wrote it.

*************************************************************************/
#include "stdafx.h"

#include "moxacfg.h"
#include "strdef.h"

LPCSTR Ldir_DiagReg = "Software\\MOXA\\Driver";
LPCSTR Ldir_mxkey = "mxkey";
LPCSTR Ldir_DiagDLL = "DiagDLL";
LPCSTR NoType_Str = "Unknown Board";

struct IRQTABSTRC  GIrqTab[IRQCNT] = {
       {2,  "2 (9)"},
       {3,  "3"},
       {4,  "4"},
       {5,  "5"},
       {7,  "7"},
       {10,  "10"},
       {11,  "11"},
       {12,  "12"},
       {15,  "15"},
};

struct PORTSTABSTRC GPortsTab[PORTSCNT] = {
       { 4,  "4 ports"  , 0},
       { 8,  "8 ports"  , I_8PORT},
       { 16, "16 ports" , I_16PORT},
       { 24, "24 ports" , I_24PORT},
       { 32, "32 ports" , I_32PORT}/*,
       { 64, "64 ports" , I_64PORT}*/
};

struct MODULETYPESTRC GModuleTypeTab[MODULECNT] = {
        { 8,  I_8PORT  ,"8 ports"},
        { 16, I_16PORT ,"16 ports"},
        { 24, I_24PORT ,"24 ports"},
        { 32, I_32PORT ,"32 ports"}/*,
        { 64, I_64PORT ,"64 ports"}*/
};   

struct MEMBANKSTRC GMemBankTab[MEMBANKCNT] = {
    {0xC8000,   "C8000"},
    {0xCC000,   "CC000"},
    {0xD0000,   "D0000"},
    {0xD4000,   "D4000"},
    {0xD8000,   "D8000"},
    {0xDC000,   "DC000"}
};

struct FIFOTABSTRC GFifoTab[FIFOCNT] = {
       {1, RX_FIFO_1, "1"},
       {4, RX_FIFO_4, "4"},
       {8, RX_FIFO_8, "8"},
       {14, RX_FIFO_14,"14"}
};


struct TXFIFOTABSTRC GTxFifoTab[TXFIFOCNT] = {
       {1, TX_FIFO_1, "1"},
       {2, TX_FIFO_2, "2"},
       {3, TX_FIFO_3, "3"},
       {4, TX_FIFO_4, "4"},
       {5, TX_FIFO_5, "5"},
       {6, TX_FIFO_6, "6"},
       {7, TX_FIFO_7, "7"},
       {8, TX_FIFO_8, "8"},
       {9, TX_FIFO_9, "9"},
       {10, TX_FIFO_10, "10"},
       {11, TX_FIFO_11, "11"},
       {12, TX_FIFO_12, "12"},
       {13, TX_FIFO_13, "13"},
       {14, TX_FIFO_14, "14"},
       {15, TX_FIFO_15, "15"},
       {16, TX_FIFO_16, "16"}
};


struct POLLSTRC GPollTab[POLLCNT] = {
	{ 0, 0 , "Manually"},
	{ 1, 10, "Every second"},
	{ 2, 50, "Every 5 seconds"},
	{ 3,100, "Every 10 seconds"},
	{ 4,300, "Every 30 seconds"},
	{ 5,600, "Every minute"}
};


#define MODULE_NUM      5
static LPSTR GModule[PORTSCNT]={
       "4 ports", "8 ports", "16 ports", "24 ports", "32 ports"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\admin\registry\regcfg.cpp ===
/************************************************************************
    regcfg.cpp
      -- general registry configuration function

    History:  Date          Author      Comment
              8/14/00       Casper      Wrote it.

*************************************************************************/

#include "stdafx.h"

#include <tchar.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <string.h>
#include <stdio.h>
#include <msports.h>
#include <regstr.h>

#include "moxacfg.h"
#include "strdef.h"
#include "mxdebug.h"

TCHAR  GszColon[]		= TEXT( ":" );
TCHAR  GszPorts[]		= TEXT( "Ports" );
TCHAR  GszDefParams[]	= TEXT( "9600,n,8,1" );
TCHAR  GszPortName[]	= REGSTR_VAL_PORTNAME;


void WriteINISetting(TCHAR *szPort)
{

	TCHAR  charBuffer[MAX_PATH];

	_tcscat(szPort, GszColon);
	charBuffer[0] = TEXT('\0');
	GetProfileString(GszPorts,
			szPort, TEXT(""), charBuffer, sizeof(charBuffer) / sizeof(TCHAR) );
	//
	// Check to see if the default string provided was copied in, if so, write
	// out the port defaults
	//
	if (charBuffer[0] == TEXT('\0')) {
		WriteProfileString(GszPorts, szPort, GszDefParams);
	}

}


void RemoveINISetting(TCHAR *szPort)
{

	_tcscat(szPort, GszColon);
	WriteProfileString(GszPorts, szPort, NULL);
}

/*
  Get COM Name from parameters\port??\PortName
*/
BOOL MxGetComNo(HDEVINFO DeviceInfoSet, 
				PSP_DEVINFO_DATA DeviceInfoData,
				LPMoxaOneCfg cfg)
{
	HKEY	hkey, hkey2;
	TCHAR	tmp[MAX_PATH];
	TCHAR	tmp1[MAX_PATH];
	DWORD	type;
	DWORD	len;
	DWORD	pcnt;

	hkey = SetupDiOpenDevRegKey(
				DeviceInfoSet, DeviceInfoData,
				DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);

	/* set default begin with COM 3 */
	for(int i=0; i<cfg->NPort; i++){
		cfg->ComNo[i] = 3+i;
	}

	if(hkey!=INVALID_HANDLE_VALUE){
		lstrcpy( tmp, TEXT("Parameters") );
		if(RegOpenKeyEx( hkey, tmp, 0, KEY_READ, &hkey2)!= ERROR_SUCCESS){
			RegCloseKey(hkey);
			Mx_Debug_Out(TEXT("Open Parameters key fail\n"));
			return FALSE;
		}

		type = REG_DWORD;
		len = MAX_PATH;
		pcnt=0;

		/* Intellio board need this key to know the ports number, */
		/* especially for C320Turbo series */
		if(RegQueryValueEx( hkey2, TEXT("NumPorts"), 0, 
				&type, (LPBYTE)&pcnt, &len)==ERROR_SUCCESS){
			cfg->NPort = pcnt;
			RegCloseKey(hkey2);	
		}
		
		/*
		Do not care the board is Intellio or Smartio....
		*/
		if(cfg->NPort<0 || cfg->NPort>CARD_MAXPORTS_INTE){
			RegCloseKey(hkey);
			Mx_Debug_Out(TEXT("cfg->NPort invalid\n"));
			return FALSE;
		}

		for(int i=0; i<cfg->NPort; i++){

			wsprintf( tmp, TEXT("Parameters\\port%03d"), i+1 );

			if(RegOpenKeyEx( hkey, tmp, 0, KEY_READ, &hkey2)!= ERROR_SUCCESS){
				Mx_Debug_Out(TEXT("Parameters\\port invalid\n"));
				continue;
			}
  
			type = REG_SZ;
			len = MAX_PATH;
			RegQueryValueEx( hkey2, TEXT("PortName"), 0, &type, (LPBYTE)tmp1, &len);

			if(_stscanf(tmp1, "COM%d", &(cfg->ComNo[i]))!=1){
				RegCloseKey(hkey2);
				RegCloseKey(hkey);
				return FALSE;
			}
			RegCloseKey(hkey2);
		}
		RegCloseKey(hkey);
	}else{
		Mx_Debug_Out(TEXT("GetCommNo SetupDiOpenDevRegKey invalid\n"));
		return FALSE;
	}

	return TRUE;
}





BOOL RemovePort(IN HDEVINFO		DeviceInfoSet,
				IN PSP_DEVINFO_DATA	DeviceInfoData,
				int	pidx)
{
	DEVINST p_DevInst;
	CHAR	p_deviceid[MAX_DEVICE_ID_LEN];
	HDEVINFO	p_DeviceInfoSet;
	SP_DEVINFO_DATA p_DeviceInfoData;
	TCHAR	tmp[MAX_PATH];


	if(CM_Get_Parent(&p_DevInst, DeviceInfoData->DevInst, 0)!=CR_SUCCESS){
		Mx_Debug_Out(TEXT("RemovePort: CM_Get_Parent fail\n"));
		return FALSE;
	}

	if(CM_Get_Device_ID(p_DevInst, p_deviceid, MAX_DEVICE_ID_LEN, 0)!= CR_SUCCESS){
		Mx_Debug_Out(TEXT("RemovePort: CM_GetDevice_ID fail\n"));
		return FALSE;
	}

	if((p_DeviceInfoSet=SetupDiCreateDeviceInfoList(NULL, NULL))==INVALID_HANDLE_VALUE){
		Mx_Debug_Out(TEXT("RemovePort: SetupDiCreateDeviceInfoList fail\n"));
		return FALSE;
	}

	p_DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
	if(SetupDiOpenDeviceInfo(p_DeviceInfoSet, p_deviceid, NULL, 0, &p_DeviceInfoData)==FALSE){
		Mx_Debug_Out(TEXT("RemovePort: SetupDiOpenDeviceInfo fail\n"));
		return FALSE;
	}

	HKEY hkey, hkey1;
	hkey = SetupDiOpenDevRegKey(
			p_DeviceInfoSet, &p_DeviceInfoData,
			DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);

	if(hkey==INVALID_HANDLE_VALUE){
		SetupDiDestroyDeviceInfoList(p_DeviceInfoSet);
		Mx_Debug_Out(TEXT("RemovePort: SetupDiOpenDevRegKey fail\n"));
		return FALSE;
	}


	wsprintf( tmp, TEXT("Parameters\\port%03d"), pidx+1 );
	if(RegOpenKeyEx( hkey, tmp, 0, KEY_READ, &hkey1)
			!= ERROR_SUCCESS){
		RegCloseKey(hkey);
		SetupDiDestroyDeviceInfoList(p_DeviceInfoSet);
		Mx_Debug_Out(tmp);
		Mx_Debug_Out(TEXT("RemovePort: open Parameters\\port fail\n"));
		return FALSE;
	}
	SetupDiDestroyDeviceInfoList(p_DeviceInfoSet);
	RegCloseKey(hkey);


	DWORD	type = REG_SZ;
	DWORD	len = MAX_PATH;
	int		port;
	if(RegQueryValueEx(hkey1,
			TEXT("PortName"), 0, &type, (LPBYTE)tmp, &len) != ERROR_SUCCESS){
		RegCloseKey(hkey1);
		Mx_Debug_Out(TEXT("RemovePort: Query PortName fail\n"));
		return FALSE;
	}

	if(_stscanf(tmp, TEXT("COM%d"), &port)!=1){
		port=0;
	}

	RemoveINISetting(tmp);

	RegCloseKey(hkey1);

	if(!port){
		Mx_Debug_Out(TEXT("RemovePort: COM num==0, fail\n"));
		return FALSE;
	}

	HCOMDB	hcomdb;
	if(ComDBOpen (&hcomdb) != ERROR_SUCCESS){
		Mx_Debug_Out(TEXT("RemovePort: ComDBOpen fail\n"));
		return FALSE;
	}

	ComDBReleasePort (hcomdb, port);
	ComDBClose(hcomdb);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\fileio.c ===
/*++
Module Name:

    fileio.c

Abstract:

    
Environment:

    kernel mode only

Notes:


Revision History:
   

--*/


#include <ntddk.h>
#include <wdmguid.h>
#include <ntddser.h>
#include <initguid.h>
#include "mxenum.h"
 
#ifdef _X86_

NTSTATUS Win2KOpenFile(PWCHAR filename, BOOLEAN read, PHANDLE phandle);
NTSTATUS Win2KCloseFile(HANDLE handle);
unsigned __int64 Win2KGetFileSize(HANDLE handle);
NTSTATUS Win2KReadFile(HANDLE handle, PVOID buffer, ULONG nbytes, PULONG pnumread);
NTSTATUS Win2KWriteFile(HANDLE handle, PVOID buffer, ULONG nbytes, PULONG pnumread);

///////////////////////////////////////////////////////////////////////////////

NTSTATUS MxenumOpenFile(PWCHAR filename, BOOLEAN read, PHANDLE phandle)
	{							// OpenFile
		return Win2KOpenFile(filename, read, phandle);
	}							// OpenFile

///////////////////////////////////////////////////////////////////////////////

NTSTATUS MxenumCloseFile(HANDLE handle)
	{							// CloseFile
		return Win2KCloseFile(handle);
	}							// CloseFile

///////////////////////////////////////////////////////////////////////////////

unsigned __int64 MxenumGetFileSize(HANDLE handle)
	{							// GetFileSize
		return Win2KGetFileSize(handle);
	}							// GetFileSize

///////////////////////////////////////////////////////////////////////////////

NTSTATUS MxenumReadFile(HANDLE handle, PVOID buffer, ULONG nbytes, PULONG pnumread)
	{							// ReadFile
		return Win2KReadFile(handle, buffer, nbytes, pnumread);
	}							// ReadFile

///////////////////////////////////////////////////////////////////////////////

NTSTATUS MxenumWriteFile(HANDLE handle, PVOID buffer, ULONG nbytes, PULONG pnumwritten)
	{							// WriteFile
		return Win2KWriteFile(handle, buffer, nbytes, pnumwritten);
	}							// WriteFile

///////////////////////////////////////////////////////////////////////////////

#else // not _X86_
	#define Win2KOpenFile OpenFile
	#define Win2KCloseFile CloseFile
	#define Win2KGetFileSize GetFileSize
	#define Win2KReadFile ReadFile
	#define Win2KWriteFile WriteFile
#endif // not _X86_

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

NTSTATUS Win2KOpenFile(PWCHAR filename, BOOLEAN read, PHANDLE phandle)
	{							// Win2KOpenFile
	NTSTATUS status;
	OBJECT_ATTRIBUTES oa;
	UNICODE_STRING usname;
	HANDLE hfile;
	IO_STATUS_BLOCK iostatus;

	RtlInitUnicodeString(&usname, filename);
	InitializeObjectAttributes(&oa, &usname, OBJ_CASE_INSENSITIVE, NULL, NULL);
	if (read)
		status = ZwCreateFile(&hfile, GENERIC_READ, &oa, &iostatus, NULL,
			0, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	else
		status = ZwCreateFile(&hfile, GENERIC_WRITE, &oa, &iostatus, NULL,
			FILE_ATTRIBUTE_NORMAL, 0, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
	if (NT_SUCCESS(status))
		*phandle = hfile;
	return status;
	}							// Win2KOpenFile

///////////////////////////////////////////////////////////////////////////////

NTSTATUS Win2KCloseFile(HANDLE handle)
	{							// Win2KCloseFile
	return ZwClose(handle);
	}							// Win2KCloseFile

///////////////////////////////////////////////////////////////////////////////

unsigned __int64 Win2KGetFileSize(HANDLE handle)
	{							// Win2KGetFileSize
	NTSTATUS status;
	IO_STATUS_BLOCK iostatus;
	FILE_STANDARD_INFORMATION fi;

	status = ZwQueryInformationFile(handle, &iostatus, (PVOID) &fi, sizeof(fi), FileStandardInformation);
	if (!NT_SUCCESS(status))
		return 0;

	return fi.EndOfFile.QuadPart;
	}							// Win2KGetFileSize

///////////////////////////////////////////////////////////////////////////////

NTSTATUS Win2KReadFile(HANDLE handle, PVOID buffer, ULONG nbytes, PULONG pnumread)
	{							// Win2KReadFile
	IO_STATUS_BLOCK iostatus;
	ZwReadFile(handle, NULL, NULL, NULL, &iostatus, buffer, nbytes, NULL, NULL);
	if (NT_SUCCESS(iostatus.Status))
		*pnumread = iostatus.Information;
	return iostatus.Status;
	}							// Win2KReadFile

///////////////////////////////////////////////////////////////////////////////

NTSTATUS Win2KWriteFile(HANDLE handle, PVOID buffer, ULONG nbytes, PULONG pnumwritten)
	{							// Win2KWriteFile
	IO_STATUS_BLOCK iostatus;
	ZwWriteFile(handle, NULL, NULL, NULL, &iostatus, buffer, nbytes, NULL, NULL);
	if (NT_SUCCESS(iostatus.Status))
		*pnumwritten = iostatus.Information;
	return iostatus.Status;
	}							// Win2KWriteFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\mxenum.c ===
/*++

Module Name:

    Mxenum.C

Abstract:

    This module contains contains the entry points 
    for a serial port bus enumerator PNP / WDM driver.


Environment:

    kernel mode only

Notes:


Revision History:
   


--*/

#include <ntddk.h>
#include <devioctl.h>
#include <initguid.h>
#include <wdmguid.h>
#include <ntddser.h>
#include "mxenum.h"

static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};


PWSTR    BoardDesc[5]={
	L"C218Turbo",
	L"C218Turbo/PCI",
	L"C320Turbo",
	L"C320Turbo/PCI",
	L"CP-204J"
           
};

PWSTR    DownloadErrMsg[7]={
	L"Fimware file not found or bad",
	L"Board not found",
	L"CPU module not found",
	L"Download fail",
	L"Download fail",
	L"CPU module download fail",
	L"UART module fail"
           
};

ULONG    NumBoardInstalled;


//
// Declare some entry functions as pageable, and make DriverEntry
// discardable
//

NTSTATUS DriverEntry(PDRIVER_OBJECT, PUNICODE_STRING);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, MxenumDriverUnload)
#pragma alloc_text(PAGE,MxenumLogError)
#endif

NTSTATUS
DriverEntry (
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING UniRegistryPath
    )
/*++
Routine Description:

    Initialize the entry points of the driver.

--*/
{
    ULONG i;

#if !DBG
    UNREFERENCED_PARAMETER (UniRegistryPath);
#endif

    MxenumKdPrint (MXENUM_DBG_TRACE,("Driver Entry\n"));
    MxenumKdPrint (MXENUM_DBG_TRACE, ("RegPath: %ws\n", UniRegistryPath->Buffer));
 
    //
    // Set ever slot to initially pass the request through to the lower
    // device object
    //
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
       DriverObject->MajorFunction[i] = MxenumDispatchPassThrough;
    }

  
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL]
        = MxenumInternIoCtl;


    DriverObject->MajorFunction [IRP_MJ_PNP] = MxenumPnPDispatch;
    DriverObject->MajorFunction [IRP_MJ_POWER] = MxenumPowerDispatch;
 
    DriverObject->DriverUnload = MxenumDriverUnload;
    DriverObject->DriverExtension->AddDevice = MxenumAddDevice;
    NumBoardInstalled = 0;

    return STATUS_SUCCESS;
}



NTSTATUS
MxenumSyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                      IN PKEVENT SerenumSyncEvent)
{
   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);


   KeSetEvent(SerenumSyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
MxenumInternIoCtl (
    PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++
Routine Description:

--*/
{
    PIO_STACK_LOCATION      pIrpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    PPDO_DEVICE_DATA        pdoData;
    PFDO_DEVICE_DATA        fdoData;

   

//    PAGED_CODE();

    status = STATUS_SUCCESS;
    pIrpStack = IoGetCurrentIrpStackLocation (Irp);
//    ASSERT (IRP_MJ_INTERNAL_DEVICE_CONTROL == pIrpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;
    pdoData = (PPDO_DEVICE_DATA) DeviceObject->DeviceExtension;

    //
    // We only take Internal Device Control requests for the PDO.
    // That is the objects on the bus (representing the serial ports)
   
    if (commonData->IsFDO) {
        status = STATUS_ACCESS_DENIED;
    } else if (pdoData->Removed) {
    //
    // This bus has received the PlugPlay remove IRP.  It will no longer
    // respond to external requests.
    //
    status = STATUS_DELETE_PENDING;

    } else {
 
        switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_MOXA_INTERNAL_BASIC_SETTINGS :
	  {
		PDEVICE_SETTINGS	pSettings;
		long	len;

            MxenumKdPrint(MXENUM_DBG_TRACE, ("Get Settings\n"));

            //
            // Check the buffer size
            //

            if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(DEVICE_SETTINGS)) {
                MxenumKdPrint(MXENUM_DBG_TRACE, ("Output buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
		Irp->IoStatus.Information = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
            pSettings = (PDEVICE_SETTINGS)Irp->AssociatedIrp.SystemBuffer;
		
		fdoData = (PFDO_DEVICE_DATA)(pdoData->ParentFdo->DeviceExtension);

		pSettings->BoardIndex = fdoData->BoardIndex;
    		pSettings->PortIndex = pdoData->PortIndex;
		pSettings->BoardType = fdoData->BoardType;
		pSettings->NumPorts = fdoData->NumPorts;
		pSettings->InterfaceType = fdoData->InterfaceType;
    		pSettings->BusNumber = fdoData->BusNumber;
            RtlCopyMemory(&pSettings->OriginalAckPort,&fdoData->OriginalAckPort,sizeof(PHYSICAL_ADDRESS));
            RtlCopyMemory(&pSettings->OriginalBaseAddress,&fdoData->OriginalBaseAddress,sizeof(PHYSICAL_ADDRESS));
     		pSettings->BaseAddress = fdoData->BaseAddress;
    		pSettings->AckPort = fdoData->AckPort;
    		pSettings->Interrupt.Level = fdoData->Interrupt.Level;
    		pSettings->Interrupt.Vector = fdoData->Interrupt.Vector;
    		pSettings->Interrupt.Affinity = fdoData->Interrupt.Affinity;
     
            status = STATUS_SUCCESS;
            MxenumKdPrint(MXENUM_DBG_TRACE, ("OK\n"));

            break;

	  }
  	  case IOCTL_MOXA_INTERNAL_BOARD_READY :
	  {
	
            MxenumKdPrint(MXENUM_DBG_TRACE, ("Get board ready\n"));

            //
            // Check the buffer size
            //

            if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {
                MxenumKdPrint(MXENUM_DBG_TRACE, ("Output buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }
		Irp->IoStatus.Information = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
		fdoData = (PFDO_DEVICE_DATA)(pdoData->ParentFdo->DeviceExtension);
		if (fdoData->Started == TRUE) {
		    *(PULONG)Irp->AssociatedIrp.SystemBuffer = 1;
		    MxenumKdPrint(MXENUM_DBG_TRACE, ("This board is ready\n"));
	      }
		else {
		    *(PULONG)Irp->AssociatedIrp.SystemBuffer = 0;
		    MxenumKdPrint(MXENUM_DBG_TRACE, ("This board is not ready\n"));
		}
		break;		

	  }
        default:
            status = STATUS_INVALID_PARAMETER;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}


VOID
MxenumDriverUnload (
    IN PDRIVER_OBJECT Driver
    )
/*++
Routine Description:
    Clean up everything we did in driver entry.

--*/
{
    UNREFERENCED_PARAMETER (Driver);
    PAGED_CODE();
 
    MxenumKdPrint(MXENUM_DBG_TRACE, ("Driver unload\n"));
    //
    // All the device objects should be gone.
    //

//    ASSERT (NULL == Driver->DeviceObject);

    //
    // Here we free any resources allocated in DriverEntry
    //

    return;
}

NTSTATUS
MxenumIncIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    InterlockedIncrement (&Data->OutstandingIO);
    if (Data->Removed) {

        if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
            KeSetEvent (&Data->RemoveEvent, 0, FALSE);
        }
        return STATUS_DELETE_PENDING;
    }
    return STATUS_SUCCESS;
}

VOID
MxenumDecIoCount (
    PFDO_DEVICE_DATA Data
    )
{
    if (0 == InterlockedDecrement (&Data->OutstandingIO)) {
        KeSetEvent (&Data->RemoveEvent, 0, FALSE);
    }
}

NTSTATUS
MxenumDispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:

    Passes a request on to the lower driver.

--*/
{
    PIO_STACK_LOCATION IrpStack = 
            IoGetCurrentIrpStackLocation( Irp );

#if 0
        MxenumKdPrint(MXENUM_DBG_TRACE,  
            ("[MxenumDispatchPassThrough] "
            "IRP: %8x; "
            "MajorFunction: %d\n",
            Irp, 
            IrpStack->MajorFunction ));
#endif

    //
    // Pass the IRP to the target
    //
   IoSkipCurrentIrpStackLocation (Irp);
    // BUGBUG:  VERIFY THIS FUNCTIONS CORRECTLY!!!
    
    if (((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension)->IsFDO) {
        return IoCallDriver( 
            ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension)->TopOfStack,
            Irp );
    } else {
        return IoCallDriver( 
            ((PFDO_DEVICE_DATA) ((PPDO_DEVICE_DATA) DeviceObject->
                DeviceExtension)->ParentFdo->DeviceExtension)->TopOfStack,
                Irp );
    }
}           

 


MXENUM_MEM_COMPARES
MxenumMemCompare(
    IN PHYSICAL_ADDRESS A,
    IN ULONG SpanOfA,
    IN PHYSICAL_ADDRESS B,
    IN ULONG SpanOfB
    )

/*++

Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.

--*/

{

    LARGE_INTEGER a;
    LARGE_INTEGER b;

    LARGE_INTEGER lower;
    ULONG lowerSpan;
    LARGE_INTEGER higher;

    a = A;
    b = B;

    if (a.QuadPart == b.QuadPart) {

        return AddressesAreEqual;

    }

    if (a.QuadPart > b.QuadPart) {

        higher = a;
        lower = b;
        lowerSpan = SpanOfB;

    } else {

        higher = b;
        lower = a;
        lowerSpan = SpanOfA;

    }

    if ((higher.QuadPart - lower.QuadPart) >= lowerSpan) {

        return AddressesAreDisjoint;

    }

    return AddressesOverlap;

}


VOID
MxenumLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PHYSICAL_ADDRESS P1,
    IN PHYSICAL_ADDRESS P2,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1,
    IN ULONG LengthOfInsert2,
    IN PWCHAR Insert2
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    PVOID objectToUse;
    SHORT dumpToAllocate = 0;
    PUCHAR ptrToFirstInsert;
    PUCHAR ptrToSecondInsert;


    if (ARGUMENT_PRESENT(DeviceObject)) {

        objectToUse = DeviceObject;

    } else {

        objectToUse = DriverObject;

    }

    if (MxenumMemCompare(
            P1,
            (ULONG)1,
            SerialPhysicalZero,
            (ULONG)1
            ) != AddressesAreEqual) {

        dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);

    }

    if (MxenumMemCompare(
            P2,
            (ULONG)1,
            SerialPhysicalZero,
            (ULONG)1
            ) != AddressesAreEqual) {

        dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);

    }

    errorLogEntry = IoAllocateErrorLogEntry(
                        objectToUse,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                dumpToAllocate + LengthOfInsert1 +
                                LengthOfInsert2)
                        );

    if ( errorLogEntry != NULL ) {

        RtlZeroMemory(
                (PUCHAR)errorLogEntry,
                (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                dumpToAllocate + LengthOfInsert1 +
                                LengthOfInsert2)
        );

        errorLogEntry->ErrorCode = SpecificIOStatus;
        errorLogEntry->SequenceNumber = SequenceNumber;
        errorLogEntry->MajorFunctionCode = MajorFunctionCode;
        errorLogEntry->RetryCount = RetryCount;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->DumpDataSize = dumpToAllocate;


        if (dumpToAllocate) {

            RtlCopyMemory(
                &errorLogEntry->DumpData[0],
                &P1,
                sizeof(PHYSICAL_ADDRESS)
                );

            if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

                RtlCopyMemory(
                  ((PUCHAR)&errorLogEntry->DumpData[0])+sizeof(PHYSICAL_ADDRESS),
                  &P2,
                  sizeof(PHYSICAL_ADDRESS)
                  );

                ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+(2*sizeof(PHYSICAL_ADDRESS));

            } else {

                ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+sizeof(PHYSICAL_ADDRESS);

            }

        } else {

            ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

        }

        ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

        if (LengthOfInsert1) {

            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                   (PUCHAR)errorLogEntry);
            RtlCopyMemory(
                ptrToFirstInsert,
                Insert1,
                LengthOfInsert1
                );

            if (LengthOfInsert2) {

                errorLogEntry->NumberOfStrings = 2;
                RtlCopyMemory(
                    ptrToSecondInsert,
                    Insert2,
                    LengthOfInsert2
                    );

            }

        }

        IoWriteErrorLogEntry(errorLogEntry);

    }

}


VOID
MxenumHexToString(PWSTR buffer, int port)
{
        unsigned short  io;

        buffer[0] = '0';
        buffer[1] = 'x';
        io = (USHORT)port;
        io >>= 12;
        io &= 0x000F;
        buffer[2] = (WCHAR)('0' + io);
        if ( io >= 0x000A )
            buffer[2] += (WCHAR)('A' - '9' - 1);
        io = (USHORT)port;
        io >>= 8;
        io &= 0x000F;
        buffer[3] = (WCHAR)('0' + io);
        if ( io >= 0x000A )
            buffer[3] += (WCHAR)('A' - '9' - 1);
        io = (USHORT)port;
        io >>= 4;
        io &= 0x000F;
        buffer[4] = (WCHAR)('0' + io);
        if ( io >= 0x000A )
            buffer[4] += (WCHAR)('A' - '9' - 1);
        io = (USHORT)port;
        io &= 0x000F;
        buffer[5] = (WCHAR)('0' + io);
        if ( io >= 0x000A )
            buffer[5] += (WCHAR)('A' - '9' - 1);
        buffer[6] = (WCHAR)0;
       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\mxenum.h ===
/*++
Module Name:

    mxenum.h

Abstract:

    This module contains the common private declarations for the serial port
    enumerator.


Environment:

    kernel mode only

Notes:


Revision History:


--*/

#ifndef MXENUM_H
#define MXENUM_H

#define REGISTRY_CLASS     L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\Class\\"
#define REGISTRY_PARAMETER L"Parameters\\"
#define MAXPORT_PER_CARD   32
#define MAX_BOARD   4

#define MXENUM_PDO_COMPATIBLE_ID 	"Mxport"
#define MXENUM_PDO_HARDWARE_ID   	"Mxport000"
#define MXENUM_PDO_DEVICE_ID  	"Mxcard\\MxcardB00P000"
#define MXENUM_PDO_NT_NAME   		L"MxcardB00P000"
#define MXENUM_PDO_NAME_BASE		L"\\Mxcard\\MxcardEnumB00P000"
#define MXENUM_PDO_DEVICE_TEXT	L"MOXA communication port" 
 
 
#define MXENUM_INSTANCE_IDS L"0000"
#define MXENUM_INSTANCE_IDS_LENGTH 5
  

#define	C218ISA		1
#define	C218PCI		2
#define	C320ISA		3
#define	C320PCI		4
#define	CP204J		5
#define MOXA_MAX_BOARD_TYPE	5

// Error code for download firmware 
#define 	Fail_FirmwareCode		1
#define 	Fail_FindBoard		2
#define 	Fail_FindCpumodule	3
#define 	Fail_Download		4
#define 	Fail_Checksum		5
#define 	Fail_Cpumodule		6
#define 	Fail_Uartmodule		7


#define MXENUM_POOL_TAG (ULONG)'eixM'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
   ExAllocatePoolWithTag(type, size, MXENUM_POOL_TAG)


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


//
// Debugging Output Levels
//

#define MXENUM_DBG_MASK  0x0000000F
#define MXENUM_DBG_NOISE               0x00000001
#define MXENUM_DBG_TRACE               0x00000002
#define MXENUM_DBG_INFO                0x00000004
#define MXENUM_DBG_ERROR               0x00000008

 
#define MXENUM_DEFAULT_DEBUG_OUTPUT_LEVEL MXENUM_DBG_MASK

#if DBG
#define MxenumKdPrint(_l_, _x_) \
            if (MXENUM_DEFAULT_DEBUG_OUTPUT_LEVEL & (_l_)) { \
               DbgPrint ("Mxcard.SYS: "); \
               DbgPrint _x_; \
            }

 
#define TRAP() DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_) KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_) KeLowerIrql(_x_)
#else
#define MxenumKdPrint(_l_, _x_)
#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif

#if !defined(MIN)
#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))
#endif

#define MOXA_IOCTL		0x800
#define IOCTL_MOXA_INTERNAL_BASIC_SETTINGS    CTL_CODE(FILE_DEVICE_SERIAL_PORT,MOXA_IOCTL+30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOXA_INTERNAL_BOARD_READY	    CTL_CODE(FILE_DEVICE_SERIAL_PORT,MOXA_IOCTL+31, METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef enum _MXENUM__MEM_COMPARES {
    AddressesAreEqual,
    AddressesOverlap,
    AddressesAreDisjoint
    } MXENUM_MEM_COMPARES,*PMXENUM_MEM_COMPARES;

//
// A common header for the device extensions of the PDOs and FDO
//

typedef struct _COMMON_DEVICE_DATA
{
    PDEVICE_OBJECT  Self;
    // A backpointer to the device object for which this is the extension

    CHAR            Reserved[2];
    BOOLEAN         IsFDO;
    BOOLEAN         PowerQueryLock;
    // Are we currently in a query power state?
    
    // A boolean to distringuish between PDO and FDO.

    SYSTEM_POWER_STATE  SystemState;
    DEVICE_POWER_STATE  DeviceState;
} COMMON_DEVICE_DATA, *PCOMMON_DEVICE_DATA;

//
// The device extension for the PDOs.
// That is the serial ports of which this bus driver enumerates.
// (IE there is a PDO for the 201 serial port).
//

typedef struct _PDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  ParentFdo;
    // A back pointer to the bus

    PDEVICE_OBJECT  Next;

    UNICODE_STRING  HardwareIDs;
  
    UNICODE_STRING  CompIDs;
    // compatible ids to the hardware id

    UNICODE_STRING  DeviceIDs;
    // Format: bus\device

    //
    // Text describing device
    //

    UNICODE_STRING DevDesc;

    BOOLEAN     Started;
    BOOLEAN     Attached;
    BOOLEAN     Removed;
    // When a device (PDO) is found on a bus and presented as a device relation
    // to the PlugPlay system, Attached is set to TRUE, and Removed to FALSE.
    // When the bus driver determines that this PDO is no longer valid, because
    // the device has gone away, it informs the PlugPlay system of the new
    // device relastions, but it does not delete the device object at that time.
    // The PDO is deleted only when the PlugPlay system has sent a remove IRP,
    // and there is no longer a device on the bus.
    //
    // If the PlugPlay system sends a remove IRP then the Removed field is set
    // to true, and all client (non PlugPlay system) accesses are failed.
    // If the device is removed from the bus Attached is set to FALSE.
    //
    // During a query relations Irp Minor call, only the PDOs that are
    // attached to the bus (and all that are attached to the bus) are returned
    // (even if they have been removed).
    //
    // During a remove device Irp Minor call, if and only if, attached is set
    // to FALSE, the PDO is deleted.
    //

   LIST_ENTRY  Link;
   // the link point to hold all the PDOs for a single bus together
   ULONG	PortIndex;
 
} PDO_DEVICE_DATA, *PPDO_DEVICE_DATA;


//
// The device extension of the bus itself.  From whence the PDO's are born.
//

typedef struct _FDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    ULONG           PollingPeriod;
    // The amount of time to wait between polling the serial port for detecting
    // pnp device attachment and removal.
 
   
    FAST_MUTEX      Mutex;
    // A syncronization for access to the device extension.

    
    UCHAR            NumPDOs;
    // A number to keep track of the Pdo we're allocating.
    // Increment every time we create a new PDO.  It's ok that it wraps.

    BOOLEAN         Started;
    // Are we on, have resources, etc?

    
    BOOLEAN         Removed;
    // Has this device been removed?  Should we fail any requests?

       
    BOOLEAN         PDOWasExposed;
    // Was the current pdo exposed to us using the expose IOCTL?
    // If so, on a query device relations, don't enumerate.

     
    BOOLEAN                     PDOForcedRemove;
        // Was the last PDO removed by force using the internal ioctl?
        // If so, when the next Query Device Relations is called, return only the 
        // currently enumerated pdos

    PDEVICE_OBJECT  AttachedPDO;

    // The last power state of the pdo set by me
    DEVICE_POWER_STATE  LastSetPowerState;
    

    PDEVICE_OBJECT  UnderlyingPDO;
    PDEVICE_OBJECT  TopOfStack;
    // the underlying bus PDO and the actual device object to which our
    // FDO is attached

    KEVENT          CallEvent;
    // An event on which to wait for IRPs sent to the lower device objects
    // to complete.

    ULONG           OutstandingIO;
    // the number of IRPs sent from the bus to the underlying device object

    KEVENT          RemoveEvent;
    // On remove device plugplay request we must wait until all outstanding
    // requests have been completed before we can actually delete the device
    // object.

    UNICODE_STRING DevClassAssocName;
    // The name returned from IoRegisterDeviceClass Association,
    // which is used as a handle for IoSetDev... and friends.

    ULONG	BoardIndex;
    ULONG	BoardType;
    ULONG	UsablePortMask;
    ULONG	NumPorts;
    ULONG	ClockRate;
    INTERFACE_TYPE     InterfaceType;
    ULONG	       BusNumber;
    PHYSICAL_ADDRESS   OriginalBaseAddress;
    PHYSICAL_ADDRESS   OriginalAckPort;
    PUCHAR		     BaseAddress;
    PUCHAR		     AckPort;
    BOOLEAN		     AddressMapped;


    struct {
        ULONG Level;
        ULONG Vector;
        ULONG Affinity;
    } Interrupt;
    
} FDO_DEVICE_DATA, *PFDO_DEVICE_DATA;

typedef struct _DEVICE_SETTINGS
{
    ULONG			BoardIndex;
    ULONG			PortIndex;
    ULONG			BoardType;
    ULONG			NumPorts;
    INTERFACE_TYPE	InterfaceType;
    ULONG	       	BusNumber;
    PHYSICAL_ADDRESS	OriginalBaseAddress;
    PHYSICAL_ADDRESS	OriginalAckPort;
    PUCHAR		  	BaseAddress;
    PUCHAR		      AckPort;
    struct {
        ULONG Level;
        ULONG Vector;
        ULONG Affinity;
    } Interrupt;
} DEVICE_SETTINGS, *PDEVICE_SETTINGS;

extern PWSTR    BoardDesc[5];
extern PWSTR    DownloadErrMsg[7];
extern ULONG    NumBoardInstalled;

//
// Prototypes
//

 
NTSTATUS
MxenumInternIoCtl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MxenumDriverUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MxenumPnPDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MxenumPowerDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MxenumRemove (
    PFDO_DEVICE_DATA            FdoData,
    PFDO_DEVICE_DATA            PdoData
    );

NTSTATUS
MxenumPnPRemovePDOs (
    PDEVICE_OBJECT      PFDdo
    );

NTSTATUS
MxenumPnPRemovePDO (
    PDEVICE_OBJECT PPdo
    );


NTSTATUS
MxenumAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusDeviceObject
    );



NTSTATUS
MxenumFdoPnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
MxenumPdoPnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
MxenumIncIoCount (
    PFDO_DEVICE_DATA   Data
    );

VOID
MxenumDecIoCount (
    PFDO_DEVICE_DATA   Data
    );

NTSTATUS
MxenumFdoPowerDispatch (
    PFDO_DEVICE_DATA    FdoData,
    PIRP                Irp
    );

NTSTATUS
MxenumPdoPowerDispatch (
    PPDO_DEVICE_DATA    FdoData,
    PIRP                Irp
    );

NTSTATUS
MxenumDispatchPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
   

                        
NTSTATUS
MxenumEnumComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );  

NTSTATUS
MxenumInitMultiString(PUNICODE_STRING MultiString,
                        ...);
    
NTSTATUS
MxenumCreatePDO(
    IN PFDO_DEVICE_DATA     FdoData
    );
    
NTSTATUS 
MxenumGetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength,
    OUT PULONG ActualLength);

NTSTATUS
MxenumPutRegistryKeyValue(
    IN HANDLE Handle,
    IN PWCHAR PKeyNameString,
    IN ULONG KeyNameStringLength,
    IN ULONG Dtype,
    IN PVOID PData,
    IN ULONG DataLength);
 
void
MxenumInitPDO (
    PDEVICE_OBJECT      pdoData, 
    PFDO_DEVICE_DATA    fdoData); 
 

NTSTATUS
MxenumGetBoardType(
    IN PDEVICE_OBJECT devObject,
    OUT PULONG boardType
    );

                  
  
VOID
MxenumLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PHYSICAL_ADDRESS P1,
    IN PHYSICAL_ADDRESS P2,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1,
    IN ULONG LengthOfInsert2,
    IN PWCHAR Insert2
    );

VOID
MxenumHexToString(
    IN PWSTR buffer,
    IN int port
    );


VOID
MxenumDelay(IN ULONG);

ULONG
MxenumGetClockRate( IN ULONG iobase);

// Portable file I/O routines

NTSTATUS 
MxenumOpenFile(PWCHAR filename,
	BOOLEAN read,
	PHANDLE phandle
	);

NTSTATUS
MxenumCloseFile(HANDLE handle);

unsigned __int64 
MxenumGetFileSize(HANDLE handle);

NTSTATUS 
MxenumReadFile(HANDLE handle,
	PVOID buffer,
	ULONG nbytes,
	PULONG pnumread
	);

NTSTATUS 
MxenumWriteFile(HANDLE handle,
	PVOID buffer,
	ULONG nbytes,
	PULONG pnumread
	);

MxenumMemCompare(
	IN PHYSICAL_ADDRESS A,
      IN ULONG SpanOfA,
      IN PHYSICAL_ADDRESS B,
      IN ULONG SpanOfB
      );

 
int
MxenumDownloadFirmware(PFDO_DEVICE_DATA deviceData,BOOLEAN NumPortDefined);

#endif // ndef SERENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\mxlog.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Abstract:

    Constant definitions for the I/O error code log values.

--*/

#ifndef _MXLOG_
#define _MXLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MXENUM_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough resources were available for the driver.
//
#define MXENUM_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0060001L)

//
// MessageId: MXENUM_NOT_INTELLIO_BOARDS
//
// MessageText:
//
//  Find a board but not Moxa's Intellio Family board,so disable it.
//
#define MXENUM_NOT_INTELLIO_BOARDS       ((NTSTATUS)0xC0060002L)

//
// MessageId: MXENUM_DRIVER_START
//
// MessageText:
//
//  Moxa Intellio Family driver started
//
#define MXENUM_DRIVER_START              ((NTSTATUS)0x40060003L)

//
// MessageId: MXENUM_DOWNLOAD_OK
//
// MessageText:
//
//  MOXA Intellio %2 series board found and downloaded successfully.
//
#define MXENUM_DOWNLOAD_OK               ((NTSTATUS)0x40060036L)

//
// MessageId: MXENUM_DOWNLOAD_FAIL
//
// MessageText:
//
//  MOXA Intellio %2 series board downloaded unsuccessfully (%3).
//
#define MXENUM_DOWNLOAD_FAIL             ((NTSTATUS)0xC0060037L)

#endif /* _MXLOG_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\mxload.c ===
/*++

Module Name:

    mxload.C

Abstract:
	The module contains the functions that download the
	firmware code to hardware.
  
Environment:

    kernel mode only

Notes:


Revision History:
   


--*/

#include <ntddk.h>
#include <wdmguid.h>
#include <ntddser.h>
#include <initguid.h>
#include "mxenum.h"
 

#define	BIOS			0
#define	BOARD_FIRMWARE	1
#define	MODULE_FIRMWARE	2


//
//	for C218 BIOS initialization
//
#define C218_ConfBase	0x800
#define C218_status	(C218_ConfBase + 0)	/* BIOS running status	*/
#define C218_diag	(C218_ConfBase + 2)	/* diagnostic status	*/
#define C218_key	(C218_ConfBase + 4)	/* WORD (0x218 for C218)*/
#define C218DLoad_len	(C218_ConfBase + 6)	/* WORD 		*/
#define C218check_sum	(C218_ConfBase + 8)	/* BYTE 		*/
#define C218chksum_ok	(C218_ConfBase + 0x0a)	/* BYTE (1:ok)		*/
#define C218_TestRx	(C218_ConfBase + 0x10)	/* 8 bytes for 8 ports	*/
#define C218_TestTx	(C218_ConfBase + 0x18)	/* 8 bytes for 8 ports	*/
#define C218_RXerr	(C218_ConfBase + 0x20)	/* 8 bytes for 8 ports	*/
#define C218_ErrFlag	(C218_ConfBase + 0x28)	/* 8 bytes for 8 ports	*/
#define C218_TestCnt	C218_ConfBase + 0x30	/* 8 words for 8 ports	   */
#define C218_LoadBuf	0x0f00
#define C218_KeyCode	0x218
#define CP204J_KeyCode	0x204


/*
 *	for C320 BIOS initialization
 */
#define C320_ConfBase	0x800
#define C320_status	C320_ConfBase + 0	/* BIOS running status	*/
#define C320_diag	C320_ConfBase + 2	/* diagnostic status	*/
#define C320_key	C320_ConfBase + 4	/* WORD (0320H for C320)*/
#define C320DLoad_len	C320_ConfBase + 6	/* WORD 		*/
#define C320check_sum	C320_ConfBase + 8	/* WORD 		*/
#define C320chksum_ok	C320_ConfBase + 0x0a	/* WORD (1:ok)		*/
#define C320bapi_len	C320_ConfBase + 0x0c	/* WORD 		*/
#define C320UART_no	C320_ConfBase + 0x0e	/* WORD 		*/

#define STS_init	0x05			/* for C320_status	*/

#define C320_LoadBuf	0x0f00

#define C320_KeyCode	0x320


#define FixPage_addr	0x0000		/* starting addr of static page  */
#define DynPage_addr	0x2000		/* starting addr of dynamic page */
#define Control_reg	0x1ff0		/* select page and reset control */
#define HW_reset	0x80



//
//	Dual-Ported RAM
//
#define DRAM_global	0
#define INT_data	(DRAM_global + 0)
#define Config_base	(DRAM_global + 0x108)


//
#define Magic_code	0x404
#define Magic_no	(Config_base + 0)
#define Card_model_no	(Config_base + 2)
#define Total_ports	(Config_base + 4)
#define C320B_len	(Config_base + 6)
#define Module_cnt	(Config_base + 8)
#define Module_no	(Config_base + 10)
#define C320B_restart	(Config_base + 12)
#define Card_Exist	(Config_base + 14)
#define Disable_Irq	(Config_base + 20)
#define TMS320Port1	(Config_base + 22)
#define TMS320Port2	(Config_base + 24) 
#define TMS320Clock	(Config_base + 26) 
 


//
//	DATA BUFFER in DRAM
//
#define Extern_table	0x400		/* Base address of the external table
					   (24 words *	64) total 3K bytes
					   (24 words * 128) total 6K bytes */
#define Extern_size	0x60		/* 96 bytes			*/
#define RXrptr		0		/* read pointer for RX buffer	*/
#define RXwptr		2		/* write pointer for RX buffer	*/
#define TXrptr		4		/* read pointer for TX buffer	*/
#define TXwptr		6		/* write pointer for TX buffer	*/
#define HostStat	8		/* IRQ flag and general flag	*/
#define FlagStat	10
#define Flow_control	0x0C	       /* B7 B6 B5 B4 B3 B2 B1 B0	     */
				       /*  x  x  x  x  |  |  |	|	     */
				       /*	       |  |  |	+ CTS flow   */
				       /*	       |  |  +--- RTS flow   */
				       /*	       |  +------ TX Xon/Xoff*/
				       /*	       +--------- RX Xon/Xoff*/

 
#define Break_cnt	0x0e		/* received break count 	*/
#define CD180TXirq	0x10		/* if non-0: enable TX irq	*/
#define RX_mask 	0x12
#define TX_mask 	0x14
#define Ofs_rxb 	0x16
#define Ofs_txb 	0x18
#define Page_rxb	0x1A
#define Page_txb	0x1C
#define EndPage_rxb	0x1E
#define EndPage_txb	0x20




#define C218rx_size	0x2000		/* 8K bytes */
#define C218tx_size	0x8000		/* 32K bytes */

#define C218rx_mask	(C218rx_size - 1)
#define C218tx_mask	(C218tx_size - 1)

#define C320p8rx_size	0x2000
#define C320p8tx_size	0x8000
#define C320p8rx_mask	(C320p8rx_size - 1)
#define C320p8tx_mask	(C320p8tx_size - 1)

#define C320p16rx_size	0x2000
#define C320p16tx_size	0x4000
#define C320p16rx_mask	(C320p16rx_size - 1)
#define C320p16tx_mask	(C320p16tx_size - 1)

#define C320p24rx_size	0x2000
#define C320p24tx_size	0x2000
#define C320p24rx_mask	(C320p24rx_size - 1)
#define C320p24tx_mask	(C320p24tx_size - 1)

#define C320p32rx_size	0x1000
#define C320p32tx_size	0x1000
#define C320p32rx_mask	(C320p32rx_size - 1)
#define C320p32tx_mask	(C320p32tx_size - 1)

#define Page_size	0x2000
#define Page_mask	(Page_size - 1)
#define C218rx_spage	3
#define C218tx_spage	4
#define C218rx_pageno	1
#define C218tx_pageno	4
#define C218buf_pageno	5

#define C320p8rx_spage	3
#define C320p8tx_spage	4
#define C320p8rx_pgno	1
#define C320p8tx_pgno	4
#define C320p8buf_pgno	5

#define C320p16rx_spage 3
#define C320p16tx_spage 4
#define C320p16rx_pgno	1
#define C320p16tx_pgno	2
#define C320p16buf_pgno 3

#define C320p24rx_spage 3
#define C320p24tx_spage 4
#define C320p24rx_pgno	1
#define C320p24tx_pgno	1
#define C320p24buf_pgno 2

#define C320p32rx_spage 3
#define C320p32tx_ofs	C320p32rx_size
#define C320p32tx_spage 3
#define C320p32buf_pgno 1

USHORT 	FirmwareBoardType[MOXA_MAX_BOARD_TYPE]  = {
			1, // C218Turbo
			1, // C218Turbo/PCI
			2, // C320Turbo
			2, // C320Turbo/PCI
			3  // CP-204J
		};


USHORT	C320rx_mask[4] = {
			C320p8rx_mask,
			C320p16rx_mask,
			C320p24rx_mask,
			C320p32rx_mask
		};

USHORT 	C320tx_mask[4] = {
			C320p8tx_mask,
			C320p16tx_mask,
			C320p24tx_mask,
			C320p32tx_mask
		};

USHORT 	C320tx_ofs[4] = {
			0,
			0,
			0,
			C320p32tx_ofs
		};

USHORT 	C320rx_spage[4]  = {
			C320p8rx_spage,
			C320p16rx_spage,
			C320p24rx_spage,
			C320p32rx_spage 

		};

USHORT 	C320tx_spage[4]  = {
			C320p8tx_spage,
			C320p16tx_spage,
			C320p24tx_spage,
			C320p32tx_spage
		};

USHORT 	C320buf_pgno[4] = {
			C320p8buf_pgno,
			C320p16buf_pgno,
			C320p24buf_pgno,
			C320p32buf_pgno
		};

USHORT 	C320tx_pgno[4] = {
			C320p8tx_pgno,
			C320p16tx_pgno,
			0,
			0
		};


UCHAR	fileHead[32];


int
MxenumDownloadFirmware(PFDO_DEVICE_DATA DeviceData,BOOLEAN NumPortDefined)
{

  HANDLE 	hfile;
  NTSTATUS	status;
  PWCHAR	fileName;
  PUCHAR	buffer;
  PUCHAR    ofs,base = DeviceData->BaseAddress;
  ULONG  	size[3],len, i,j,len1,len2,numread;
  USHORT   	retry;
  PUSHORT  	uptr;
  USHORT  	usum,module,keycode;

  switch (DeviceData->BoardType) {
  	case	C218ISA :
  	case	C218PCI :
		fileName = L"\\SystemRoot\\System32\\c218tnt.cod";
     		len = 32; // the length of firmware file head
		keycode = C218_KeyCode;
		break;

	case	CP204J :
		fileName = L"\\SystemRoot\\System32\\cp204jnt.cod";
     		len = 32; // the length of firmware file head
		keycode = CP204J_KeyCode;
		break;

	case	C320ISA :
	case	C320PCI :
		fileName = L"\\SystemRoot\\System32\\c320tnt.cod";
		len = 32; // the length of firmware file head
		keycode = C320_KeyCode;
		break;

  	default :
		return(Fail_Download);


  }

  if (!DeviceData->BaseAddress)
	return(Fail_Download);

  status = MxenumOpenFile(fileName, TRUE, &hfile);
  if (!NT_SUCCESS(status)) {
  	MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: open fail\n"));
      status = Fail_FirmwareCode;
	return(status);
  }
 
  numread = 0;
  status = MxenumReadFile(hfile, fileHead, len, &numread);
  if (!NT_SUCCESS(status) || (numread != len)) {
  	MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: read file head fail\n"));
      MxenumCloseFile(hfile);
      status = Fail_FirmwareCode;
	return(status);
  }

  if ((fileHead[0] != '4') || (fileHead[1] != '0') ||
	(fileHead[2] != '4') || (fileHead[3] != '0') ||
      (fileHead[7] != FirmwareBoardType[DeviceData->BoardType-1]) ||
	(fileHead[6] != 2)) {  // fileHead[6] == 2 for NT
	MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: invalid file head\n"));
      status = Fail_FirmwareCode;
      MxenumCloseFile(hfile);
	return(status);
  }
 
  switch (DeviceData->BoardType) {
  	
  	case C218ISA :
  	case C218PCI :
	case CP204J :

		len = 0;
  		for (i = 0; i < 2; i++) {
			size[i] = fileHead[17+i*2];
  		  	size[i] <<= 8;
  		  	size[i] += fileHead[16+i*2];
			if (size[i] <= 0) {
      			MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: invalid file head\n"));
			      status = Fail_FirmwareCode;
      			MxenumCloseFile(hfile);
				return(status);
  			}
			if (size[i] > len)
				len = size[i];
		}

		break;
 
  	default :
		len = 0;
		for (i = 0; i < 3; i++) {
			size[i] = fileHead[17+i*2];
  		  	size[i] <<= 8;
  		  	size[i] += fileHead[16+i*2];
			if (size[i] <= 0) {
      			MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: invalid file head\n"));
			      status = Fail_FirmwareCode;
      			MxenumCloseFile(hfile);
				return(status);
  			}
			if (size[i] > len)
				len = size[i];
		}

		break;
  }

  buffer = ExAllocatePool(PagedPool, len);
  if (!buffer) {
	MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: unable to allocate buffer size = %d\n",len));
      status = Fail_Download;
	MxenumCloseFile(hfile);
    	return(status);
  }
 
// ****************start to download bios

  status = 0;

// the data len of bios code
  len = size[BIOS];
 
  status = MxenumReadFile(hfile, buffer, len, &numread);
  if (!NT_SUCCESS(status) || (numread != len)) {
  	MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: read bios code fail\n"));
	status = Fail_FirmwareCode;
	goto DownloadFirmwareDone;
  }

  base[Control_reg] = HW_reset;              /* reset  */
  MxenumDelay(5);                              	  /* delay 10ms */
  for (i=0; i<4096; i++)
  	base[i] = 0;
  for (i=0; i<len; i++)
     	 base[i] = buffer[i];                   /* download BIOS */
  base[Control_reg] = 0;                	 /* release reset */

  // start to finding board

  MxenumDelay(1000);                              	 /* delay 2 secs */

  switch (DeviceData->BoardType) {
  	case C218ISA:
  	case C218PCI :
      case CP204J:
		retry = 0;
		while (*(PUSHORT)(base + C218_key) != keycode) {
			MxenumDelay(1);       	 
			if (retry++ > 50) /* wait for 100ms */
				break;
		}
   		if (*(PUSHORT)(base + C218_key) != keycode) {
                	MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: unable to find c218 board = %d\n",len));
	 		status = Fail_FindBoard;
         		goto DownloadFirmwareDone;
	 	}
           	break;
   	default:
		retry = 0;
		while (*(PUSHORT)(base + C320_key) != keycode) {
			MxenumDelay(1);       	 
			if (retry++ > 50) /* wait for 100ms */
				break;
		}

            if (*(PUSHORT)(base + C320_key) != keycode) {
               	MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: unable to find c320 board = %d\n",len));
	          	status = Fail_FindBoard;
         		goto DownloadFirmwareDone;
	 	}
		retry = 0;
		while (*(PUSHORT)(base + C320_status) != STS_init) {
			MxenumDelay(1);       	 
			if (retry++ > 1500) /* wait for 3s */
				break;
		}

		if (*(PUSHORT)(base + C320_status) != STS_init) {
               	MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: unable to find c320 board = %d\n",len));
	          	status = Fail_FindCpumodule;
         		goto DownloadFirmwareDone;
	 	}

  
            // start to download firmware of C320 board
            len = size[BOARD_FIRMWARE];	// the data len of C320 board firmware code
           
  		status = MxenumReadFile(hfile, buffer, len, &numread);
  		if (!NT_SUCCESS(status) || (numread != len)) {
  			MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: read c320 board firmware code fail\n"));
			status = Fail_FirmwareCode;
         		goto DownloadFirmwareDone;
	 	}
 
        	*(PUSHORT)&base[C320bapi_len] = (USHORT)(len - 7168 - 2);
        	base[Control_reg] = 1;          /* Select Page 1 */
        	for (i=0; i<7168; i++)
            	base[DynPage_addr + i] = buffer[i];
        	base[Control_reg] = 2;          /* Select Page 2 */
        	for (i=0; i<(len - 7168); i++)
            	base[DynPage_addr + i] = buffer[i+7168];
		break;
   }
   // start to downloading firmware 
   MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: start to download firmware\n"));

   // the data len of firmware code
   switch (DeviceData->BoardType) {
    	case C218ISA:
  	case C218PCI :
	case CP204J:
   		len = size[BOARD_FIRMWARE];
   		break;
      default :
		len = size[MODULE_FIRMWARE];
		break;
   }

   status = MxenumReadFile(hfile, buffer, len, &numread);
   if (!NT_SUCCESS(status) || (numread != len)) {
  	 MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: read firmware code fail\n"));
	status = Fail_FirmwareCode;
	goto DownloadFirmwareDone;
   }

   retry = 0;
  
   switch (DeviceData->BoardType) {
   	case C218ISA:
  	case C218PCI :
	case CP204J:
   		
   		do {
			j = 0;
    			usum = 0;
               	len1 = len >> 1;
               	uptr = (PUSHORT)buffer;
               	for (i=0; i<len1; i++)
                  	usum += uptr[i];
               	while (len1) {
               		if (len1 > 2048)
                  		len2 = 2048;
                  	else
                  		len2 = len1;
                 	 	len1 -= len2;
                  	for (i=0; i<len2<<1; i++)
                  		base[C218_LoadBuf+i] = buffer[j+i];
                 	 	j += i;
                  	*(PUSHORT)&(base[C218DLoad_len]) = (USHORT)len2;
                  	*(PUSHORT)&(base[C218_key]) = 0;
                  	for (i=0; i<100; i++) {
					if (*(PUSHORT)&(base[C218_key]) == keycode)
                          		 break;
                        		MxenumDelay(1);
                  	}
                  	if (*(PUSHORT)&(base[C218_key]) != keycode) {
                     		status = Fail_Download;
         				goto DownloadFirmwareDone;
				}


               	}
               	*(PUSHORT)&base[C218DLoad_len] = 0;
               	*(PUSHORT)&base[C218check_sum] = usum;
               	*(PUSHORT)&base[C218_key] = 0;
               	for (i=0; i<100; i++) {
                  	if (*(PUSHORT)&base[C218_key] == keycode)
                       		break;
                  	 MxenumDelay(1);
               	}
               	retry++;
   		} while ((base[C218chksum_ok] != 1) && (retry < 3));
            if (base[C218chksum_ok] != 1) {
			status = Fail_Checksum;
         		goto DownloadFirmwareDone;
		}
 
           	*(PUSHORT)&base[C218_key] = 0;
            for (i=0; i<100; i++) {
            	if (*(PUSHORT)&base[Magic_no] == Magic_code) 
            		break;
               	MxenumDelay(1);
            }
            if (*(PUSHORT)&base[Magic_no] != Magic_code) {
            	status = Fail_Download;
         		goto DownloadFirmwareDone;
		}

           	*(PUSHORT)&base[Disable_Irq] = 0;
            *(PUSHORT)&base[Magic_no] = 0;
            for (i=0; i<100; i++) {
            	if (*(PUSHORT)&base[Magic_no] == Magic_code)
            		break;
            	MxenumDelay(1);
            }
            if (*(PUSHORT)&base[Magic_no] != Magic_code) {
			status = Fail_Download;
         		goto DownloadFirmwareDone;
		}
            for (i=0; i<DeviceData->NumPorts; i++) {
              	ofs =   base + Extern_table + Extern_size * i;
              			*(PUSHORT)(ofs + RX_mask) = C218rx_mask;
               			*(PUSHORT)(ofs + TX_mask) = C218tx_mask;
              	*(PUSHORT)(ofs + Page_rxb) = (USHORT)(C218rx_spage + i * C218buf_pageno);
                	*(PUSHORT)(ofs + EndPage_rxb) = *(PUSHORT)(ofs + Page_rxb) + C218rx_pageno;
                	*(PUSHORT)(ofs + Page_txb) = (USHORT)(C218tx_spage + i * C218buf_pageno);
                	*(PUSHORT)(ofs + EndPage_txb) = *(PUSHORT)(ofs + Page_txb) + C218tx_pageno;
               
            }
         
            break;

   	default :
	
   		   	
    		do {
			j = 0;
			usum = 0;
    			len1 = len >> 1;
    			uptr = (PUSHORT)buffer;
    			for (i=0; i<len1; i++)
            				usum += uptr[i];
        			while (len1) {
                			if (len1 > 2048)
                    			len2 = 2048;
                			else
                    			len2 = len1;
                			len1 -= len2;
                			for (i=0; i<len2<<1; i++)
                    			base[C320_LoadBuf+i] = buffer[j+i];
                			j += i;
                			*(PUSHORT)&(base[C320DLoad_len]) = (USHORT)len2;
                			*(PUSHORT)&(base[C320_key]) = 0;
                			for (i=0; i<100; i++) {
                    			if (*(PUSHORT)&(base[C320_key]) == keycode)
                        			break;
                    			MxenumDelay(1);
                			}
                			if (*(PUSHORT)&(base[C320_key]) != keycode) {
						status = Fail_Download;
         					goto DownloadFirmwareDone;
					}
        			}
        			*(PUSHORT)&base[C320DLoad_len] = 0;
        			*(PUSHORT)&base[C320check_sum] = usum;
        			*(PUSHORT)&(base[C320_key]) = 0;
        			for (i=0; i<100; i++) {
            			if (*(PUSHORT)&(base[C320_key]) == keycode)
                				break;
            			MxenumDelay(1);
        			}
        			retry++;
    		} while ((base[C320chksum_ok] != 1) && (retry < 3));
    		if (base[C320chksum_ok] != 1) {
    			status = Fail_Checksum;
         		goto DownloadFirmwareDone;
		}
    		*(PUSHORT)&(base[C320_key]) = 0;
    		for (i=0; i<100; i++) {
        		if (*(PUSHORT)&base[Magic_no] == Magic_code)
            		break;
        		MxenumDelay(1);                               /* delay 2 ms */
    		}
    		if (*(PUSHORT)&base[Magic_no] != Magic_code) {
            	status = Fail_Download;
         		goto DownloadFirmwareDone;
		}
	      *(PUSHORT)&base[Disable_Irq] = 0;
            if (DeviceData->InterfaceType == PCIBus) {// ASIC board
                  *(PUSHORT)&base[TMS320Port1] = 0x3800;
                  *(PUSHORT)&base[TMS320Port2] = 0x3900;
                  *(PUSHORT)&base[TMS320Clock] = 28499; // 57 MHZ
	      }
            else {
                  *(PUSHORT)&base[TMS320Port1] = 0x3200;
                  *(PUSHORT)&base[TMS320Port2] = 0x3400;
                  *(PUSHORT)&base[TMS320Clock] = 19999;  // 40 MHZ
            }
            *(PUSHORT)&base[Magic_no] = 0;
            for (i=0; i<100; i++) {
                  if (*(PUSHORT)&base[Magic_no] == Magic_code)
                        break;
                  MxenumDelay(1);                         /* delay 2 ms */
            }
            if (*(PUSHORT)&base[Magic_no] != Magic_code)
                  return(Fail_Cpumodule);

		if (NumPortDefined == FALSE) {// it means the fisrt time install
                DeviceData->NumPorts = 8*base[Module_cnt];
		    module = base[Module_cnt];
		} 
		else {
		    module = (USHORT)(DeviceData->NumPorts/8);
   		    if (base[Module_cnt] < module)
                     return(Fail_Uartmodule);
		}
	
         	*(PUSHORT)&base[Module_no] = module;
    		*(PUSHORT)&base[Magic_no] = 0;
    		for (i=0; i<100; i++) {
        		if (*(PUSHORT)&base[Magic_no] == Magic_code)
            		break;
        		MxenumDelay(1);                               /* delay 2 ms */
    		}
    		if (*(PUSHORT)&base[Magic_no] != Magic_code) {
			status = Fail_Download;
         		goto DownloadFirmwareDone;
		}
		for (i=0; i<DeviceData->NumPorts; i++) {
               	 	ofs =   base + Extern_table + Extern_size * i;
                	      *(PUSHORT)(ofs + RX_mask) = C320rx_mask[module-1];
                		*(PUSHORT)(ofs + TX_mask) = C320tx_mask[module-1];
				*(PUSHORT)(ofs + Ofs_txb) = C320tx_ofs[module-1];
                		*(PUSHORT)(ofs + Page_rxb) = (USHORT)(C320rx_spage[module-1] + i * C320buf_pgno[module-1]);
                		*(PUSHORT)(ofs + EndPage_rxb) = *(PUSHORT)(ofs + Page_rxb);
                		*(PUSHORT)(ofs + Page_txb) = (USHORT)(C320tx_spage[module-1] + i * C320buf_pgno[module-1]);
                		*(PUSHORT)(ofs + EndPage_txb) = *(PUSHORT)(ofs + Page_txb) + C320tx_pgno[module-1];

            }

		break;

   }

DownloadFirmwareDone :;
   ExFreePool(buffer);
   MxenumCloseFile(hfile);
    
   MxenumKdPrint (MXENUM_DBG_TRACE,("DownloadFirmware: exit=%x\n",status));
   return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\registry.c ===
/*++
Module Name:

    registry.c

Abstract:

    This module contains the code that is used to get values from the
    registry and to manipulate entries in the registry.


Environment:

    Kernel mode

Revision History :

--*/
#include <ntddk.h>
#include <ntddser.h>
#include "mxenum.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,MxenumGetRegistryKeyValue)
#pragma alloc_text(PAGE,MxenumPutRegistryKeyValue)
#endif // ALLOC_PRAGMA


NTSTATUS
MxenumGetRegistryKeyValue (
                          IN HANDLE Handle,
                          IN PWCHAR KeyNameString,
                          IN ULONG KeyNameStringLength,
                          IN PVOID Data,
                          IN ULONG DataLength,  // Optional
                          OUT PULONG ActualLength)
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.

Arguments:

    Handle              Handle to the opened registry key

    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
    UNICODE_STRING              keyName;
    ULONG                       length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    PAGED_CODE();

    RtlInitUnicodeString (&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
      + DataLength;
    fullInfo = ExAllocatePool(PagedPool, length);

    if (fullInfo) {
        ntStatus = ZwQueryValueKey (Handle,
                                  &keyName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

        if (NT_SUCCESS(ntStatus)) {
            //
            // If there is enough room in the data buffer, copy the output
            //

            if (DataLength >= fullInfo->DataLength) {
                RtlCopyMemory (Data,
                    ((PUCHAR) fullInfo) + fullInfo->DataOffset,
                    fullInfo->DataLength);
            }
            if (ActualLength) {
                *ActualLength = fullInfo->DataLength;
            }
        }

        ExFreePool(fullInfo);
    }

    return ntStatus;
}




NTSTATUS 
MxenumPutRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
			  IN ULONG KeyNameStringLength, IN ULONG Dtype,
                    IN PVOID PData, IN ULONG DataLength)
/*++

Routine Description:

    Writes a registry key value to an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    PKeyNameString      ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString
    
    Dtype		REG_XYZ value type

    PData               Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
   NTSTATUS status;
   UNICODE_STRING keyname;

   PAGED_CODE();

    
   RtlInitUnicodeString(&keyname, NULL);
   keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
   keyname.Buffer = ExAllocatePool(PagedPool, keyname.MaximumLength);

   if (keyname.Buffer == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlAppendUnicodeToString(&keyname, PKeyNameString);

   status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

   ExFreePool(keyname.Buffer);
   
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\power.c ===
/*++
Module Name:

    POWER.C

Abstract:

    This module contains contains the plugplay power calls 
    for a serial port bus enumerator PNP / WDM driver.


Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <ntddk.h>
#include <ntddser.h>
#include "mxenum.h"
#include "mxlog.h"

static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};



#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, MxenumPowerDispatch)
#pragma alloc_text (PAGE, MxenumFdoPowerDispatch)
#pragma alloc_text (PAGE, MxenumPdoPowerDispatch)
#endif

NTSTATUS
MxenumPowerDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PCOMMON_DEVICE_DATA commonData;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
//    ASSERT (IRP_MJ_POWER == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        status = 
            MxenumFdoPowerDispatch ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                Irp);
    } else {

        status = 
            MxenumPdoPowerDispatch ((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension,
                Irp);
    }

    return status;
}     

NTSTATUS
MxenumFdoPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
MxenumFdoPowerDispatch(
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    )
/*++
--*/
{
    NTSTATUS            status;
    BOOLEAN             hookit = FALSE;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    UCHAR			minorFunction;

    stack = IoGetCurrentIrpStackLocation (Irp);
    minorFunction = stack->MinorFunction;
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    PAGED_CODE ();

    status = MxenumIncIoCount (Data);
    if (!NT_SUCCESS (status)) {
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
    status = Irp->IoStatus.Status;

    switch (minorFunction) {
    case IRP_MN_SET_POWER:
        MxenumKdPrint( MXENUM_DBG_TRACE,
                      ("Serenum-PnP Setting %s state to %d\n",
                      ((powerType == SystemPowerState) ?  "System" : "Device"),
                      powerState.SystemState));

        switch (powerType) {
        case DevicePowerState:
		status = Irp->IoStatus.Status = STATUS_SUCCESS;


            if (Data->DeviceState < powerState.DeviceState) {
                //
                // Powering down
  
                PoSetPowerState (Data->Self, powerType, powerState);
                Data->DeviceState = powerState.DeviceState;
            } else if (Data->DeviceState > powerState.DeviceState) {
                //
                // Powering Up
                //
                hookit = TRUE;
		}
            
            break;

        case SystemPowerState:
	      
            MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("In SystemPowerState\n"
					"	Current System state = %d\n"
					"	Device started = %d\n"
					"	System state to be set = %d\n"
					"	Irql = %x\n",
						Data->SystemState,
						Data->Started,
						powerState.SystemState,
						KeGetCurrentIrql()));
/* 3-22-01 by William
            if ((Data->SystemState == PowerSystemHibernate)&&
*/
            if ((Data->SystemState != PowerSystemWorking)&&
//		    (Data->Started == TRUE)&&
		    (powerState.SystemState == PowerSystemWorking)){

		    ULONG	i;
                MxenumKdPrint (MXENUM_DBG_TRACE,("Hook it\n"));
	//	    hookit = TRUE;
		   

                MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Start to download\n"));

		    i = 0;
                while (BoardDesc[Data->BoardType-1][i])
                   i++;
	          i <<= 1;

		    status = MxenumDownloadFirmware(Data,TRUE);
		    MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("BoardDesc(%d)->%ws\n",i,BoardDesc[Data->BoardType-1]));

		    if (status != 0) {
		        ULONG		j;

		        j = 0;
                    while (DownloadErrMsg[status-1][j])
                       j++;
	     	        j <<= 1;

		        MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Device started failure\n"));
#if 0
		        MxenumLogError(
                  	DeviceObject->DriverObject,
                  	NULL,
                  	SerialPhysicalZero,
                  	SerialPhysicalZero,
                  	0,
                  	0,
                   	0,
                   	19,
                    	STATUS_SUCCESS,
                    	MXENUM_DOWNLOAD_FAIL,
                    	i + sizeof (WCHAR),
                    	BoardDesc[Data->BoardType -1],
                    	j + sizeof (WCHAR),
                    	DownloadErrMsg[status -1]
                    	);
#endif

		        Data->Started = FALSE;
	   	                 	
	          }
	          else {
          	       MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Device started successfully\n"));
                   Data->Started = TRUE;    
		
	          }
		    
		}
	
	      status = STATUS_SUCCESS; // return SUCCESS anyway

		break;	
	  default:
	      break;
        }
        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power
        // irp.  This can be called here, or in the completetion
        // routine, but never the less must be called.
        //
	  Irp->IoStatus.Status = status;
        Data->SystemState = powerState.SystemState;
        IoCopyCurrentIrpStackLocationToNext (Irp);
        PoStartNextPowerIrp (Irp);
        PoCallDriver (Data->TopOfStack, Irp);
 
        MxenumDecIoCount (Data);
        return status;



    case IRP_MN_QUERY_POWER:
        //
        Data->PowerQueryLock = TRUE;
        status = Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:
        break;
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    if (hookit) {
        status = MxenumIncIoCount (Data);
//        ASSERT (STATUS_SUCCESS == status);
        IoSetCompletionRoutine (Irp,
                                MxenumFdoPowerComplete,
                                NULL,
                                TRUE,
                                TRUE,
                                TRUE);

        PoCallDriver (Data->TopOfStack, Irp);

    } else {
        //
        // Power IRPS come synchronously; drivers must call
        // PoStartNextPowerIrp, when they are ready for the next power
        // irp.  This can be called here, or in the completetion
        // routine, but never the less must be called.
        //
        PoStartNextPowerIrp (Irp);

        PoCallDriver (Data->TopOfStack, Irp);
    }

#if 0
    if ((minorFunction == IRP_MN_SET_POWER)&&
       		(powerType == SystemPowerState)) {
        Data->SystemState = powerState.SystemState;
    }
#endif

    MxenumDecIoCount (Data);
    return status;
   
}


NTSTATUS
MxenumFdoPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
--*/
{
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;
    PIO_STACK_LOCATION  stack;
    PFDO_DEVICE_DATA    data;
    NTSTATUS            status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER (Context);

    data = (PFDO_DEVICE_DATA) DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;
    MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("MxenumFdoPowerComplete,irql=%x\n",KeGetCurrentIrql()));


    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            //
            // Powering Up
            // 
//            ASSERT (powerState.DeviceState < data->DeviceState);
            data->DeviceState = powerState.DeviceState;

            PoSetPowerState (data->Self, powerType, powerState);

            break;

	  case SystemPowerState:
        {
		ULONG	i;

            MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Start to download\n"));

		i = 0;
            while (BoardDesc[data->BoardType-1][i])
               i++;
	      i <<= 1;

		status = MxenumDownloadFirmware(data,TRUE);
		MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("BoardDesc(%d)->%ws\n",i,BoardDesc[data->BoardType-1]));

		if (status != 0) {
		    ULONG		j;

		    j = 0;
                while (DownloadErrMsg[status-1][j])
                   j++;
	     	    j <<= 1;

		    MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Device started failure\n"));
		    MxenumLogError(
                  	DeviceObject->DriverObject,
                  	NULL,
                  	SerialPhysicalZero,
                  	SerialPhysicalZero,
                  	0,
                  	0,
                   	0,
                   	19,
                    	STATUS_SUCCESS,
                    	MXENUM_DOWNLOAD_FAIL,
                    	i + sizeof (WCHAR),
                    	BoardDesc[data->BoardType -1],
                    	j + sizeof (WCHAR),
                    	DownloadErrMsg[status -1]
                    	);

		   data->Started = FALSE;
	   	   status =  STATUS_UNSUCCESSFUL;
            	
	      }
	      else {
          	   MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Device started successfully\n"));
               data->Started = TRUE;    

	      }
	
	      break;
        }

        default:
            break;
        }
        break;
    
    case IRP_MN_QUERY_POWER:

//        ASSERT (IRP_MN_QUERY_POWER != stack->MinorFunction);
        break;

    default:
//        ASSERT (0xBADBAD == IRP_MN_QUERY_POWER);
        break;
    }

    PoStartNextPowerIrp (Irp);
    MxenumDecIoCount (data);


    return status;
  
}

VOID
MxenumPdoPowerComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Irp,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
MxenumPdoPowerDispatch (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    )
/*++
--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;
    POWER_STATE         powerState;
    POWER_STATE_TYPE    powerType;

    PAGED_CODE();

    status = Irp->IoStatus.Status;
 
    stack = IoGetCurrentIrpStackLocation (Irp);
    powerType = stack->Parameters.Power.Type;
    powerState = stack->Parameters.Power.State;

    switch (stack->MinorFunction) {
    case IRP_MN_SET_POWER:
        switch (powerType) {
        case DevicePowerState:
            if (PdoData->DeviceState > powerState.DeviceState) {
                PoSetPowerState (PdoData->Self, powerType, powerState);
                PdoData->DeviceState = powerState.DeviceState;
            } else if (PdoData->DeviceState < powerState.DeviceState) {
                //
                // Powering down.
                //
                PoSetPowerState (PdoData->Self, powerType, powerState);
                PdoData->DeviceState = powerState.DeviceState;
            }
            break;

        case SystemPowerState:
           status = STATUS_SUCCESS;
           break;

        default:
//            status = STATUS_NOT_IMPLEMENTED;
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        PdoData->PowerQueryLock = TRUE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_WAIT_WAKE:
    case IRP_MN_POWER_SEQUENCE:
    default:
//        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp (Irp);
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\flush.c ===
/*++

Module Name:

    flush.c

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
MoxaFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

   MoxaKdPrint(MX_DBG_TRACE,("Leaving MoxaFlush\n"));
    if ((extension->ControlDevice == TRUE)||(extension->DeviceIsOpened == FALSE)) {
 	  Irp->IoStatus.Status = STATUS_CANCELLED;
    	  Irp->IoStatus.Information=0L;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_CANCELLED;
    }


    if (MoxaIRPPrologue(Irp, extension) != STATUS_SUCCESS) {
    	  MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
        return STATUS_CANCELLED;
    }


    if (MoxaCompleteIfError(
	    DeviceObject,
	    Irp
	    ) != STATUS_SUCCESS) {

	return STATUS_CANCELLED;

    }

    Irp->IoStatus.Information = 0L;

    return MoxaStartOrQueue(
	       extension,
	       Irp,
	       &extension->WriteQueue,
	       &extension->CurrentWriteIrp,
	       MoxaStartFlush
	       );

}

NTSTATUS
MoxaStartFlush(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{

    PIRP newIrp;

    Extension->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    MoxaGetNextWrite(
	&Extension->CurrentWriteIrp,
	&Extension->WriteQueue,
	&newIrp,
	TRUE,
	Extension
	);

    if (newIrp)

	MoxaStartWrite(Extension);

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\pnp.c ===
/*++
Module Name:

    PNP.C

Abstract:

    This module contains contains the plugplay calls
    PNP / WDM BUS driver.


Environment:

    kernel mode only

Notes:


Revision History:
  
--*/

#include <ntddk.h>
#include <wdmguid.h>
#include <ntddser.h>
#include <initguid.h>
#include "mxenum.h"
#include "mxlog.h"

static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};


#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, MxenumAddDevice)
#pragma alloc_text (PAGE, MxenumPnPDispatch)
#pragma alloc_text (PAGE, MxenumFdoPnP)
#pragma alloc_text (PAGE, MxenumPdoPnP)
#pragma alloc_text (PAGE, MxenumPnPRemovePDOs)
#pragma alloc_text (PAGE, MxenumGetBoardType)
 
#endif


NTSTATUS
MxenumGetBoardType(IN PDEVICE_OBJECT devObject,OUT PULONG boardType)
{

   ULONG	i,j;
   UNICODE_STRING buffer;
   NTSTATUS status;

   PAGED_CODE();

   status = IoGetDeviceProperty (devObject,
                  DevicePropertyHardwareID,
                  0,
                  NULL,
                  (PLONG)&buffer.Length
			);
   if (buffer.Length < sizeof(L"mx1000")) {
	 return (STATUS_FAIL_CHECK);
   }

   buffer.Buffer = NULL;
   buffer.MaximumLength = buffer.Length + sizeof(WCHAR);
   buffer.Buffer = ExAllocatePool (PagedPool, buffer.MaximumLength);
   if (NULL == buffer.Buffer) {
	 return (STATUS_INSUFFICIENT_RESOURCES);
   }

   status = IoGetDeviceProperty (devObject,
                  DevicePropertyHardwareID,
                  buffer.Length,
                  buffer.Buffer,
                  (PULONG)&buffer.Length
			);
   if (!(NT_SUCCESS(status))) {
	 ExFreePool(buffer.Buffer);
	 return (status);
   }
 
 
   if (buffer.Length < sizeof(L"mx1000")) {
       ExFreePool(buffer.Buffer);
	 return (STATUS_FAIL_CHECK);
   }
  
   status = STATUS_FAIL_CHECK;
   if (((buffer.Buffer[0] == 'm')||(buffer.Buffer[0] == 'M'))&&
	 ((buffer.Buffer[1] == 'x')||(buffer.Buffer[1] == 'X'))&&
	 (buffer.Buffer[2] == '1')&&
       (buffer.Buffer[3] == '0')&&
       (buffer.Buffer[4] == '0')) {
 
	 switch ((UCHAR)buffer.Buffer[5]) {
	      case '0' :
                *boardType = C218ISA;
                status = STATUS_SUCCESS;
		    break;

	      case '1' :
	 	    *boardType = C320ISA;
                status = STATUS_SUCCESS;
		    break;


            case '2' :
               *boardType = C320ISA;
                status = STATUS_SUCCESS;
		    break;


            case '3' : 
               *boardType = C320ISA;
                status = STATUS_SUCCESS;
		    break;


            case '4' : 
               *boardType = C320ISA;
                status = STATUS_SUCCESS;
		    break;

	 }

    }
    else if (buffer.Length >= sizeof(L"pci\\ven_1393&dev_2180")) { 
  
        if (((buffer.Buffer[0] == 'p')||(buffer.Buffer[0] == 'P'))&&
	      ((buffer.Buffer[1] == 'c')||(buffer.Buffer[1] == 'C'))&&
            ((buffer.Buffer[2] == 'i')||(buffer.Buffer[2] == 'I'))) {
	       
		 if ((buffer.Buffer[17] == '2')&&
                 (buffer.Buffer[18] == '1')&&
                 (buffer.Buffer[19] == '8')&&
                 (buffer.Buffer[20] == '0') ) {

	 	     *boardType = C218PCI;
                 status = STATUS_SUCCESS;
		    

		 } else if ((buffer.Buffer[17] == '3')&&
                 (buffer.Buffer[18] == '2')&&
                 (buffer.Buffer[19] == '0')&&
                 (buffer.Buffer[20] == '0') ) {

	 	     *boardType = C320PCI;
                 status = STATUS_SUCCESS;
		   

		 } else if ((buffer.Buffer[17] == '2')&&
                 (buffer.Buffer[18] == '0')&&
                 (buffer.Buffer[19] == '4')&&
                 (buffer.Buffer[20] == '0') ) {

	 	     *boardType = CP204J;
                 status = STATUS_SUCCESS;
	  
		 }

        }
 
    }
     
    MxenumKdPrint (MXENUM_DBG_TRACE, ("BoardType: %x\n", *boardType));

    ExFreePool(buffer.Buffer);
    return (status);
   

}

NTSTATUS
MxenumUpdateNumberPortRegistry(IN PDEVICE_OBJECT DeviceObject)
{
    UNICODE_STRING	buffer,registryPath;
    NTSTATUS            status;


    status = IoGetDeviceProperty (((PFDO_DEVICE_DATA)(DeviceObject->DeviceExtension))->UnderlyingPDO,
               DevicePropertyDriverKeyName,
               0,
               NULL,
               (PULONG)&buffer.Length);
 

    buffer.Buffer = NULL;
    buffer.MaximumLength =   buffer.Length + sizeof(WCHAR);

    buffer.Buffer = ExAllocatePool (PagedPool, buffer.MaximumLength);

    registryPath.Buffer = NULL;
    registryPath.Length = 0;
    
    registryPath.MaximumLength = sizeof(REGISTRY_CLASS) +
					  buffer.Length +
					  sizeof(L"\\Parameters") +
					  sizeof(WCHAR);

    registryPath.Buffer = ExAllocatePool (PagedPool, registryPath.MaximumLength);

    if ((registryPath.Buffer == NULL)||(buffer.Buffer == NULL)) {
   
        if (registryPath.Buffer != NULL)
		ExFreePool(registryPath.Buffer);

	  if (buffer.Buffer == NULL)
            ExFreePool(buffer.Buffer);


     	  status = STATUS_INSUFFICIENT_RESOURCES;
	  return(status);

    }
    status = IoGetDeviceProperty (((PFDO_DEVICE_DATA)(DeviceObject->DeviceExtension))->UnderlyingPDO,
                DevicePropertyDriverKeyName,
                buffer.Length,
                buffer.Buffer,
                (PULONG)&buffer.Length);
    if (!(NT_SUCCESS(status))) {
  	
	  if (registryPath.Buffer != NULL)
		ExFreePool(registryPath.Buffer);

	  if (buffer.Buffer == NULL)
            ExFreePool(buffer.Buffer);

        return(status);
    }
    buffer.Length -= sizeof(WCHAR);  // remove the null char. 
    RtlZeroMemory(
        registryPath.Buffer,
        registryPath.MaximumLength
        );

    RtlAppendUnicodeToString(
        &registryPath,
        REGISTRY_CLASS
        );
  
 
    RtlAppendUnicodeStringToString(
        &registryPath,
        &buffer
        );
    RtlAppendUnicodeToString(
        &registryPath,
        L"\\Parameters"
        );

 
    registryPath.Buffer[(registryPath.Length >> 1)] = (WCHAR)0;

 
    status = RtlWriteRegistryValue( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     registryPath.Buffer,
                                     L"NumPorts",
                                     REG_DWORD, 
                				 &((PFDO_DEVICE_DATA)(DeviceObject->DeviceExtension))->NumPorts,
				             sizeof(ULONG));
    
 
    ExFreePool(buffer.Buffer);
    ExFreePool(registryPath.Buffer);
    return (status);
 
}
 
NTSTATUS
MxenumAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    BusPhysicalDeviceObject - Device object representing the bus.  That to which
        we attach a new FDO.

    DriverObject - This very self referenced driver.

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PFDO_DEVICE_DATA    DeviceData;
    ULONG               nameLength,i;
    ULONG			boardIndex = 0;
    PCM_RESOURCE_LIST resourceList = NULL;
    UNICODE_STRING	buffer,registryPath;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];

    PAGED_CODE ();

    MxenumKdPrint (MXENUM_DBG_TRACE,("Add Device,cnt = %d\n",
                                          NumBoardInstalled + 1));
    if (NumBoardInstalled >= MAX_BOARD) {
	  MxenumKdPrint (MXENUM_DBG_TRACE,("Too many board installed,abort this\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
	  return(status);
    }

    //
    //First, Create our FDO
    //
    status = IoCreateDevice (
                    DriverObject,  // our driver object
                    sizeof (FDO_DEVICE_DATA), // device object extension size
                    NULL, // FDOs do not have names
                    FILE_DEVICE_BUS_EXTENDER,
                    0, // No special characteristics
                    TRUE, // our FDO is exclusive
                    &deviceObject); // The device object created
    if (!(NT_SUCCESS(status))) {
        MxenumLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    19,
                    STATUS_SUCCESS,
                    MXENUM_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
        MxenumKdPrint (MXENUM_DBG_TRACE,("Unable to create device status=%x\n",status));

        return status;
    }

    DeviceData = (PFDO_DEVICE_DATA) deviceObject->DeviceExtension;
    RtlFillMemory (DeviceData, sizeof (FDO_DEVICE_DATA), 0);

    status=
	MxenumGetBoardType(BusPhysicalDeviceObject,
                       &DeviceData->BoardType);

    if (!NT_SUCCESS(status) || (DeviceData->BoardType > MOXA_MAX_BOARD_TYPE)) {
       MxenumLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    19,
                    STATUS_SUCCESS,
                    MXENUM_NOT_INTELLIO_BOARDS,
                    0,
                    NULL,
                    0,
                    NULL
                    );
       IoDeleteDevice (deviceObject);
       status = STATUS_INSUFFICIENT_RESOURCES;
	 return(status);
 
    }

    status = IoGetDeviceProperty (BusPhysicalDeviceObject,
               DevicePropertyDriverKeyName,
               0,
               NULL,
               (PULONG)&buffer.Length);
 

    buffer.Buffer = NULL;
    buffer.MaximumLength =   buffer.Length + sizeof(WCHAR);

    buffer.Buffer = ExAllocatePool (PagedPool, buffer.MaximumLength);

    registryPath.Buffer = NULL;
    registryPath.Length = 0;
    
    registryPath.MaximumLength = sizeof(REGISTRY_CLASS) +
					  buffer.Length +
					  sizeof(L"\\Parameters") +
					  sizeof(WCHAR);

    registryPath.Buffer = ExAllocatePool (PagedPool, registryPath.MaximumLength);

    if ((registryPath.Buffer == NULL)||(buffer.Buffer == NULL)) {
        IoDeleteDevice (deviceObject);
        MxenumLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    19,
                    STATUS_SUCCESS,
                    MXENUM_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );

        if (registryPath.Buffer != NULL)
		ExFreePool(registryPath.Buffer);

	  if (buffer.Buffer == NULL)
            ExFreePool(buffer.Buffer);


     	  status = STATUS_INSUFFICIENT_RESOURCES;
	  return(status);

    }
    status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                DevicePropertyDriverKeyName,
                buffer.Length,
                buffer.Buffer,
                (PULONG)&buffer.Length);
    if (!(NT_SUCCESS(status))) {
  	  IoDeleteDevice (deviceObject);
        MxenumLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    19,
                    STATUS_SUCCESS,
                    MXENUM_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );

	  if (registryPath.Buffer != NULL)
		ExFreePool(registryPath.Buffer);

	  if (buffer.Buffer == NULL)
            ExFreePool(buffer.Buffer);

        return(status);
    }
    buffer.Length -= sizeof(WCHAR);  // remove the null char. 

    buffer.Length >>= 1;
    
    boardIndex = (buffer.Buffer[buffer.Length-1] - '0') +
		     (buffer.Buffer[buffer.Length-2] - '0')*10 +
                 (buffer.Buffer[buffer.Length-3] - '0')*100 +
                 (buffer.Buffer[buffer.Length-4] - '0')*1000;

    buffer.Length <<= 1;

    RtlZeroMemory(
        registryPath.Buffer,
        registryPath.MaximumLength
        );

    RtlAppendUnicodeToString(
        &registryPath,
        REGISTRY_CLASS
        );
  
 
    RtlAppendUnicodeStringToString(
        &registryPath,
        &buffer
        );
    RtlAppendUnicodeToString(
        &registryPath,
        L"\\Parameters"
        );

 
    registryPath.Buffer[(registryPath.Length >> 1)] = (WCHAR)0;

 
    RtlZeroMemory (&paramTable[0], sizeof(paramTable));
    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"NumPorts";
    paramTable[0].EntryContext  = &DeviceData->NumPorts;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &DeviceData->NumPorts;
    paramTable[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     registryPath.Buffer,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
    MxenumKdPrint (MXENUM_DBG_TRACE,("parameter path -> %ws\n",
                                          registryPath.Buffer));
 
    if (!NT_SUCCESS(status) || (DeviceData->NumPorts <= 0) || (DeviceData->NumPorts > MAXPORT_PER_CARD) ) {
      
	 MxenumKdPrint (MXENUM_DBG_TRACE,("parameter path -> %ws\n",
                                          registryPath.Buffer));
	 MxenumKdPrint (MXENUM_DBG_TRACE,("NumPorts= %d,status=%x\n",
                                          DeviceData->NumPorts,status));
       MxenumKdPrint (MXENUM_DBG_TRACE,("This is the first time installation\n"));
       switch (DeviceData->BoardType) {
       case		C218ISA:
	 case		C218PCI:
		DeviceData->NumPorts = 8;
		break;
	 case		CP204J:
		DeviceData->NumPorts = 4;
		break;
	 case		C320ISA:
	 case		C320PCI:
	 default :
       	DeviceData->NumPorts = 0;
		break;
	 }
     }
 
    ExFreePool(buffer.Buffer);
    ExFreePool(registryPath.Buffer);
  
    status = IoGetDeviceProperty (BusPhysicalDeviceObject,
                               DevicePropertyLegacyBusType,
                               sizeof(ULONG),
                               &DeviceData->InterfaceType,
                               (PULONG)&buffer.Length);
    if (!(NT_SUCCESS(status))) {
        DeviceData->InterfaceType = (ULONG)Isa;
	  DeviceData->BusNumber = 0;
    }

    DeviceData->IsFDO = TRUE;
    DeviceData->Self = deviceObject;
    DeviceData->AttachedPDO = NULL;
    DeviceData->NumPDOs = 0;
    DeviceData->PDOWasExposed = FALSE;
    DeviceData->DeviceState = PowerDeviceD0;
    DeviceData->SystemState = PowerSystemWorking;
    DeviceData->LastSetPowerState = PowerDeviceD0;
     DeviceData->PDOForcedRemove = FALSE;
    DeviceData->BoardIndex = boardIndex;

    DeviceData->Removed = FALSE;

    // Set the PDO for use with PlugPlay functions
    DeviceData->UnderlyingPDO = BusPhysicalDeviceObject;


    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    DeviceData->TopOfStack = IoAttachDeviceToDeviceStack (
                                        deviceObject,
                                        BusPhysicalDeviceObject);

     // Bias outstanding request to 1 so that we can look for a
     // transition to zero when processing the remove device PlugPlay IRP.
     DeviceData->OutstandingIO = 1;

     KeInitializeEvent(&DeviceData->RemoveEvent,
                          SynchronizationEvent,
                          FALSE); // initialized to not signalled

     deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
     deviceObject->Flags |= DO_POWER_PAGABLE;
 
     //
     // Tell the PlugPlay system that this device will need an interface
     // device class shingle.
     //
     // It may be that the driver cannot hang the shingle until it starts
     // the device itself, so that it can query some of its properties.
     // (Aka the shingles guid (or ref string) is based on the properties
     // of the device.)
     //
     status = IoRegisterDeviceInterface (
                    BusPhysicalDeviceObject,
                    (LPGUID) &GUID_SERENUM_BUS_ENUMERATOR,
                    NULL, // No ref string
                    &DeviceData->DevClassAssocName);

     if (!NT_SUCCESS (status)) {
         MxenumKdPrint (MXENUM_DBG_TRACE,
                          ("AddDevice: IoRegisterDCA failed (%x)", status));
         IoDetachDevice (DeviceData->TopOfStack);
         IoDeleteDevice (deviceObject);
         return status;
     }

     //
     // If for any reason you need to save values in a safe location that
     // clients of this DeviceClassAssociate might be interested in reading
     // here is the time to do so, with the function
     // IoOpenDeviceClassRegistryKey
     // the symbolic link name used is was returned in
     // DeviceData->DevClassAssocName (the same name which is returned by
     // IoGetDeviceClassAssociations and the SetupAPI equivs.
     //

     //
     // Turn on the shingle and point it to the given device object.
     //
     status = IoSetDeviceInterfaceState (
                        &DeviceData->DevClassAssocName,
                        TRUE);

     if (!NT_SUCCESS (status)) {
         IoDetachDevice (DeviceData->TopOfStack);
         IoDeleteDevice (deviceObject);
         return status;
     }
     else
	     NumBoardInstalled++;
     return status;
}

NTSTATUS
MxenumFdoPnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Pirp,
    IN PVOID            Context
    );

NTSTATUS
MxenumPnPDispatch (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
Routine Description:
    Answer the plethora of Irp Major PnP IRPS.
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    KIRQL                   oldIrq;

    PAGED_CODE ();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
//    ASSERT (IRP_MJ_PNP == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
//        MxenumKdPrint (MXENUM_DBG_TRACE,
//                      ("PNP: Functional DO: %x IRP: %x\n", DeviceObject, Irp));

        status = MxenumFdoPnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PFDO_DEVICE_DATA) commonData);
        
    } else {
 //       MxenumKdPrint (MXENUM_DBG_TRACE,
 //                     ("PNP: Physical DO: %x IRP: %x\n", DeviceObject, Irp));

        status = MxenumPdoPnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PPDO_DEVICE_DATA) commonData);
    }

    return status;
}

NTSTATUS
MxenumFdoPnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    NTSTATUS    status;
    KIRQL       oldIrq;
    KEVENT      event;
    ULONG       length;
    ULONG       i;
    PLIST_ENTRY entry;
    PPDO_DEVICE_DATA    pdoData;
    PDEVICE_RELATIONS   relations;
    PRTL_QUERY_REGISTRY_TABLE QueryTable = NULL;
    

    PAGED_CODE ();

 
    status = MxenumIncIoCount (DeviceData);
    if (!NT_SUCCESS (status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return status;
    }
 
    
    switch (IrpStack->MinorFunction) {

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: 
    {
         HANDLE pnpKey;
         PKEVENT pResFiltEvent;
         PIO_RESOURCE_REQUIREMENTS_LIST pReqList;
         PIO_RESOURCE_LIST pResList;
         PIO_RESOURCE_DESCRIPTOR pResDesc;
         ULONG reqCnt;
         ULONG listNum;
	  

	   MxenumKdPrint (MXENUM_DBG_TRACE,("FDO:Query Resource Requirement\n"));

         pResFiltEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

         if (pResFiltEvent == NULL) {
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(  Irp, IO_NO_INCREMENT);
            MxenumDecIoCount (DeviceData);
            return STATUS_INSUFFICIENT_RESOURCES;
         }

         KeInitializeEvent(pResFiltEvent, SynchronizationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(Irp);
         IoSetCompletionRoutine(Irp, MxenumFdoPnPComplete, pResFiltEvent,
                                TRUE, TRUE, TRUE);

         status = IoCallDriver(DeviceData->TopOfStack, Irp);


         //
         // Wait for lower drivers to be done with the Irp
         //

         if (status == STATUS_PENDING) {
            KeWaitForSingleObject (pResFiltEvent, Executive, KernelMode, FALSE,
                                   NULL);
         }

         ExFreePool(pResFiltEvent);

 	   if (NT_SUCCESS(Irp->IoStatus.Status)&&
			 ((pReqList=(PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information) != NULL)) {

		MxenumKdPrint (MXENUM_DBG_TRACE,
			("ResourceRequireList:%x,%x,%x,%x,%x\n",
					pReqList->ListSize,
					pReqList->InterfaceType,
					pReqList->BusNumber,
					pReqList->SlotNumber,
					pReqList->AlternativeLists)
			);

		pResList = &pReqList->List[0];

		MxenumKdPrint (MXENUM_DBG_TRACE,
			("ResourceList:%x,%x,%x\n",
					pResList->Version,
					pResList->Revision,
					pResList->Count)
					 
			);
		for (i =0; i < pResList->Count; i++)  {
			pResDesc = &pResList->Descriptors[i];

			MxenumKdPrint (MXENUM_DBG_TRACE,
				("ResourceDesc:%x,%x,%x,%x\n",
					pResDesc->Option,
					pResDesc->Type,
					pResDesc->ShareDisposition,
					pResDesc->Flags)
		 		);
			switch (pResDesc->Type) {
			case CmResourceTypePort :
				MxenumKdPrint (MXENUM_DBG_TRACE,
					("Port:%x,%x,%x,%x,%x\n",
						pResDesc->u.Port.Length,
						pResDesc->u.Port.MinimumAddress.HighPart,
						pResDesc->u.Port.MinimumAddress.LowPart,
						pResDesc->u.Port.MaximumAddress.HighPart,
						pResDesc->u.Port.MaximumAddress.LowPart)
					);

				break;

			case CmResourceTypeInterrupt :
				MxenumKdPrint (MXENUM_DBG_TRACE,
					("Interrupt:%x,%x\n",
						pResDesc->u.Interrupt.MinimumVector,
						pResDesc->u.Interrupt.MaximumVector)
					);

				break;

			case CmResourceTypeMemory :
				MxenumKdPrint (MXENUM_DBG_TRACE,
					("Memory:%x,%x,%x,%x,%x\n",
						pResDesc->u.Memory.Length,
						pResDesc->u.Memory.MinimumAddress.HighPart,
						pResDesc->u.Memory.MinimumAddress.LowPart,
						pResDesc->u.Memory.MaximumAddress.HighPart,
						pResDesc->u.Memory.MaximumAddress.LowPart)
					);

				break;

			case CmResourceTypeBusNumber :
				MxenumKdPrint (MXENUM_DBG_TRACE,
					("BusNumber:%x,%x,%x\n",
						pResDesc->u.BusNumber.Length,
						pResDesc->u.BusNumber.MinBusNumber,
						pResDesc->u.BusNumber.MaxBusNumber)
					);

				break;

			default :
				break;

		}
     
	   }
      }
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      MxenumDecIoCount (DeviceData);
  
      return status;
    }
 
    case IRP_MN_START_DEVICE: 
	{
	   ULONG               addressSpace = 0;
         PHYSICAL_ADDRESS    translatedAddress;
	   BOOLEAN		     NumPortDefined;

        

        MxenumKdPrint (MXENUM_DBG_TRACE,("FDO:Start Device\n"));
        
        if (DeviceData->Started) {
            MxenumKdPrint (MXENUM_DBG_TRACE,
                ("Device already started\n"));
            status = STATUS_SUCCESS;
            break;
        }

        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //
        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                MxenumFdoPnPComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

//            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {
            PCM_PARTIAL_RESOURCE_LIST list;
            ULONG	nres;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR resource;
            if (!IrpStack->Parameters.StartDevice.AllocatedResources) {
		    DeviceData->Started = FALSE;
  	          status = STATUS_UNSUCCESSFUL;
		    break;
		}

            list = &IrpStack->Parameters.StartDevice.AllocatedResources->List[0].PartialResourceList;

		nres = list->Count;
           	resource = list->PartialDescriptors;
	
  
            DeviceData->InterfaceType = IrpStack->Parameters.StartDevice.AllocatedResources->List[0].InterfaceType;	
            DeviceData->BusNumber =	IrpStack->Parameters.StartDevice.AllocatedResources->List[0].BusNumber;

            for (i = 0; i < nres; ++i,++resource) {

		    switch(resource->Type) {
		
		    case CmResourceTypePort:
			{
				DeviceData->OriginalAckPort = resource->u.Port.Start;
				DeviceData->OriginalAckPort.LowPart += 0x4D;

				addressSpace = CM_RESOURCE_PORT_IO;
			      status = HalTranslateBusAddress(
                  		 	DeviceData->InterfaceType,
                     			DeviceData->BusNumber,
                     			DeviceData->OriginalAckPort,
                     			&addressSpace,
                     			&translatedAddress
                		);
				if (!NT_SUCCESS(status)) {
					MxenumKdPrint (MXENUM_DBG_TRACE,("FDO:translate io error!\n"));
				}
                		DeviceData->AckPort = (PUCHAR)translatedAddress.LowPart;
			
			      break;
			}
		    case CmResourceTypeMemory:
			{
  	 			DeviceData->OriginalBaseAddress = resource->u.Memory.Start;
				MxenumKdPrint (MXENUM_DBG_TRACE,("BaseAddr=%x\n",DeviceData->OriginalBaseAddress.LowPart));
	  			addressSpace = CM_RESOURCE_PORT_MEMORY;
                        HalTranslateBusAddress (
                               	DeviceData->InterfaceType,
                        	      DeviceData->BusNumber,
                        		DeviceData->OriginalBaseAddress,
                        		&addressSpace,
                        		&translatedAddress
                        );
            		DeviceData->BaseAddress = MmMapIoSpace(
                                    translatedAddress,
                                    0x4000L,
                                    FALSE
                        );
				

			      break;
			}

    		    case CmResourceTypeInterrupt:
			{
				 
				DeviceData->Interrupt.Level = resource->u.Interrupt.Level;
				DeviceData->Interrupt.Vector = resource->u.Interrupt.Vector;
				DeviceData->Interrupt.Affinity = resource->u.Interrupt.Affinity;
				MxenumKdPrint (MXENUM_DBG_TRACE,("Irq=%x\n",DeviceData->Interrupt.Vector));
	  
				break;
			}
	 
		    default :
			 
			      break;
		    }
	      }


            //
            // Now we can touch the lower device object as it is now started.
            //
            
            
            DeviceObject->Flags |= DO_BUFFERED_IO;
           
          
 		MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Start to download\n"));

		i = 0;
            while (BoardDesc[DeviceData->BoardType-1][i])
                   i++;
	      i <<= 1;

		if (DeviceData->NumPorts == 0) // Port not installed
			NumPortDefined = FALSE;
		else
			NumPortDefined = TRUE;
		status = MxenumDownloadFirmware(DeviceData,NumPortDefined);
		MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("BoardDesc(%d)->%ws\n",i,BoardDesc[DeviceData->BoardType-1]));

		if (status != 0) {
			ULONG		j;

			j = 0;
                  while (DownloadErrMsg[status-1][j])
                  	j++;
	      	j <<= 1;

			MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Device started failure\n"));
		      MxenumLogError(
                  	DeviceObject->DriverObject,
                  	NULL,
                  	SerialPhysicalZero,
                  	SerialPhysicalZero,
                  	0,
                  	0,
                   	0,
                   	19,
                    	STATUS_SUCCESS,
                    	MXENUM_DOWNLOAD_FAIL,
                    	i + sizeof (WCHAR),
                    	BoardDesc[DeviceData->BoardType -1],
                    	j + sizeof (WCHAR),
                    	DownloadErrMsg[status -1]
                       	);

		      DeviceData->Started = FALSE;
		 	status =  STATUS_UNSUCCESSFUL;
            	
		}
		else {
            	MxenumKdPrint (MXENUM_DBG_TRACE,
                             ("Start Device: Device started successfully\n"));
			MxenumLogError(
                  	DeviceObject->DriverObject,
                  	NULL,
                  	SerialPhysicalZero,
                  	SerialPhysicalZero,
                  	0,
                  	0,
                   	0,
                   	19,
                    	STATUS_SUCCESS,
                    	MXENUM_DOWNLOAD_OK,
  				i + sizeof (WCHAR),
                    	BoardDesc[DeviceData->BoardType -1],
                    	0,
                    	NULL
                    	);
      		DeviceData->Started = TRUE;
                  if (NumPortDefined == FALSE) // Port not installed
		   		MxenumUpdateNumberPortRegistry(DeviceObject);

		}
      
         
        }
        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //

        Irp->IoStatus.Information = 0;
        break;
	}

    case IRP_MN_QUERY_STOP_DEVICE:
        MxenumKdPrint (MXENUM_DBG_TRACE,
            ("FDO:Query Stop Device\n"));
 
        //
        // Test to see if there are any PDO created as children of this FDO
        // If there are then conclude the device is busy and fail the
        // query stop.
        //
        // BUGBUG
        // We could do better, by seing if the children PDOs are actually
        // currently open.  If they are not then we could stop, get new
        // resouces, fill in the new resouce values, and then when a new client
        // opens the PDO use the new resources.  But this works for now.
        //
 
        if (DeviceData->AttachedPDO) {
//            status = STATUS_UNSUCCESSFUL;
		break;
        } else {
//            status = STATUS_SUCCESS;
        }
  
 //       Irp->IoStatus.Status = status;
        IoSkipCurrentIrpStackLocation (Irp);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        MxenumDecIoCount (DeviceData);
 
        return status;

    case IRP_MN_STOP_DEVICE:
        MxenumKdPrint (MXENUM_DBG_TRACE,("FDO:Stop Device\n"));
 
        //
        // After the start IRP has been sent to the lower driver object, the
        // bus may NOT send any more IRPS down ``touch'' until another START
        // has occured.
        // What ever access is required must be done before the Irp is passed
        // on.
        //
        // Stop device means that the resources given durring Start device
        // are no revoked.  So we need to stop using them
        //
     

        DeviceData->Started = FALSE;

        //
        // We don't need a completion routine so fire and forget.
        //
        // Set the current stack location to the next stack location and
        // call the next device object.
        //
//        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
 
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        MxenumDecIoCount (DeviceData);
 
        return status;

    case IRP_MN_REMOVE_DEVICE:
        MxenumKdPrint (MXENUM_DBG_TRACE,("FDO:Remove Device\n"));
 
        //
        // The PlugPlay system has detected the removal of this device.  We
        // have no choice but to detach and delete the device object.
        // (If we wanted to express and interest in preventing this removal,
        // we should have filtered the query remove and query stop routines.)
        //
        // Note! we might receive a remove WITHOUT first receiving a stop.
        // ASSERT (!DeviceData->Removed);
        
        // We will accept no new requests
        //
        DeviceData->Removed = TRUE;

        //
        // Complete any outstanding IRPs queued by the driver here.
        //

        //
        // Make the DCA go away.  Some drivers may choose to remove the DCA
        // when they receive a stop or even a query stop.  We just don't care.
        //
        IoSetDeviceInterfaceState (&DeviceData->DevClassAssocName, FALSE);
  
        //
        // Here if we had any outstanding requests in a personal queue we should
        // complete them all now.
        //
        // Note, the device is guarenteed stopped, so we cannot send it any non-
        // PNP IRPS.
        //

        //
        // Fire and forget
        //
	  Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        //
        // Wait for all outstanding requests to complete
        //
        MxenumKdPrint (MXENUM_DBG_TRACE,
            ("Waiting for outstanding requests\n"));
        i = InterlockedDecrement (&DeviceData->OutstandingIO);

//        ASSERT (0 < i);

        if (0 != InterlockedDecrement (&DeviceData->OutstandingIO)) {
            MxenumKdPrint (MXENUM_DBG_TRACE,
                          ("Remove Device waiting for request to complete\n"));

            KeWaitForSingleObject (&DeviceData->RemoveEvent,
                                   Suspended,
                                   KernelMode,
                                   FALSE, // Not Alertable
                                   NULL); // No timeout
        }
 
        //
        // Free the associated resources
        //
	  if (DeviceData->AddressMapped)
		MmUnmapIoSpace(DeviceData->AckPort,0x80);
	  if (DeviceData->BaseAddress)
	  	MmUnmapIoSpace(DeviceData->BaseAddress,0x4000L);
        //
        // Detach from the underlying devices.
        //
        
        IoDetachDevice (DeviceData->TopOfStack);

        //
        // Clean up any resources here
       

        ExFreePool (DeviceData->DevClassAssocName.Buffer);
        

        //
        // Remove any PDO's we ejected
        //

        if (DeviceData->AttachedPDO != NULL) {

         MxenumPnPRemovePDOs(DeviceObject);
 
        }

        IoDeleteDevice(DeviceObject);
        NumBoardInstalled--;

        return status;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
    {
        PDEVICE_OBJECT  currentObj;

	  MxenumKdPrint (MXENUM_DBG_TRACE,("FDO:Query Device Relation\n"));
  
        if (BusRelations != IrpStack->Parameters.QueryDeviceRelations.Type) {
            //
            // We don't support this
            //
            MxenumKdPrint (MXENUM_DBG_TRACE,
                ("Query Device Relations - Non bus\n"));
            goto SER_FDO_PNP_DEFAULT;
        }

        if (DeviceData->AttachedPDO == NULL)
            MxenumCreatePDO( DeviceData );

        MxenumKdPrint (MXENUM_DBG_TRACE,
            ("Query Bus Relations\n"));
 
        DeviceData->PDOForcedRemove = FALSE;

        //
        // Tell the plug and play system about all the PDOs.
        //
        // There might also be device relations below and above this FDO,
        // so, be sure to propagate the relations from the upper drivers.
        //
        // No Completion routine is needed so long as the status is preset
        // to success.  (PDOs complete plug and play irps with the current
        // IoStatus.Status and IoStatus.Information as the default.)
        //
        
        //KeAcquireSpinLock (&DeviceData->Spin, &oldIrq);
 
        i = (0 == Irp->IoStatus.Information) ? 0 :
            ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;
        // The current number of PDOs in the device relations structure

        MxenumKdPrint (MXENUM_DBG_TRACE,
                           ("#PDOS = %d + %d\n", i, DeviceData->NumPDOs));

        length = sizeof(DEVICE_RELATIONS) +
                ((DeviceData->NumPDOs + i) * sizeof (PDEVICE_OBJECT));

        if ((DeviceData->NumPDOs + i) <= 0) {
            //
            // Set up and pass the IRP further down the stack
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;

         
            IoSkipCurrentIrpStackLocation (Irp);
 
            status = IoCallDriver (DeviceData->TopOfStack, Irp);
            MxenumDecIoCount (DeviceData);
 
            return status; 
        }
   
        relations = (PDEVICE_RELATIONS) ExAllocatePool (PagedPool, length);

        if (NULL == relations) {
            MxenumKdPrint (MXENUM_DBG_TRACE,
            	("Insufficient resources\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;
		break;
        }

        //
        // Copy in the device objects so far
        //
        if (i) {
            RtlCopyMemory (
                  relations->Objects,
                  ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                  i * sizeof (PDEVICE_OBJECT));
        }
        relations->Count = DeviceData->NumPDOs + i;

        //
        // For each PDO on this bus add a pointer to the device relations
        // buffer, being sure to take out a reference to that object.
        // The PlugPlay system will dereference the object when it is done with
        // it and free the device relations buffer.
        //
 
        currentObj = DeviceData->AttachedPDO; 
	  while ((i < relations->Count)&& (currentObj != NULL)) {
	      relations->Objects[i] = currentObj;
            ObReferenceObject (currentObj);
		currentObj = ((PPDO_DEVICE_DATA)(currentObj->DeviceExtension))->Next;
		i++;
	  }
 

        //
        // Set up and pass the IRP further down the stack
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        if (0 != Irp->IoStatus.Information) {
            ExFreePool ((PVOID) Irp->IoStatus.Information);
        }
        Irp->IoStatus.Information = (ULONG_PTR)relations;

 
        IoSkipCurrentIrpStackLocation (Irp);
 
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        MxenumDecIoCount (DeviceData);
 

        return status;
    }
    case IRP_MN_QUERY_REMOVE_DEVICE:
     	  MxenumKdPrint (MXENUM_DBG_TRACE,
            ("FDO:Query Remove Device\n"));
        //
        // If we were to fail this call then we would need to complete the
        // IRP here.  Since we are not, set the status to SUCCESS and
        // call the next driver.
        //
   
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
 
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        MxenumDecIoCount (DeviceData);
 
        return status;

  case IRP_MN_CANCEL_STOP_DEVICE:
      MxenumKdPrint(MXENUM_DBG_TRACE, ("FDO:Cancel Stop Device\n"));
 //       Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (Irp);
 
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        MxenumDecIoCount (DeviceData);
 
        return status;


    case IRP_MN_QUERY_BUS_INFORMATION: {
       PPNP_BUS_INFORMATION pBusInfo;

//       ASSERTMSG("Serenum appears not to be the sole bus?!?",
//                 Irp->IoStatus.Information == (ULONG_PTR)NULL);

       pBusInfo = ExAllocatePool(PagedPool, sizeof(PNP_BUS_INFORMATION));

       if (pBusInfo == NULL) {
          status = STATUS_INSUFFICIENT_RESOURCES;
          break;
       }

       pBusInfo->BusTypeGuid = GUID_BUS_TYPE_SERENUM;
       pBusInfo->LegacyBusType = DeviceData->InterfaceType;

       //
       // We really can't track our bus number since we can be torn
       // down with our bus
       //

       pBusInfo->BusNumber = DeviceData->BusNumber;
 

       Irp->IoStatus.Information = (ULONG_PTR)pBusInfo;
       status = STATUS_SUCCESS;
       break;
       }

SER_FDO_PNP_DEFAULT:
    default:

  
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //
        MxenumKdPrint (MXENUM_DBG_TRACE,("FDO:Default Case(%x)\n",IrpStack->MinorFunction));

        //
        // Fire and Forget
        //
        IoSkipCurrentIrpStackLocation (Irp);

        //
        // Done, do NOT complete the IRP, it will be processed by the lower
        // device object, which will complete the IRP
        //
 
        status = IoCallDriver (DeviceData->TopOfStack, Irp);
        MxenumDecIoCount (DeviceData);
 
        return status;
    }

    Irp->IoStatus.Status = status;
 
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    MxenumDecIoCount (DeviceData);
 
    return status;
}


NTSTATUS
MxenumFdoPnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->PendingReturned) {
        IoMarkIrpPending( Irp );
    }

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
MxenumPdoPnP (IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                 IN PIO_STACK_LOCATION IrpStack, IN PPDO_DEVICE_DATA DeviceData)
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{
   PDEVICE_CAPABILITIES    deviceCapabilities;
   ULONG                   information;
   PWCHAR                  buffer;
   ULONG                   length, i, j;
   NTSTATUS                status;
   KIRQL                   oldIrq;
   HANDLE                  keyHandle;
   PWCHAR returnBuffer = NULL;
 

   PAGED_CODE();
  
   status = Irp->IoStatus.Status;

   //
   // NB: since we are a bus enumerator, we have no one to whom we could
   // defer these irps.  Therefore we do not pass them down but merely
   // return them.
   //

   switch (IrpStack->MinorFunction) {
   case IRP_MN_QUERY_CAPABILITIES:

      MxenumKdPrint (MXENUM_DBG_TRACE,("PDO:Query Caps \n"));

      //
      // Get the packet.
      //

      deviceCapabilities=IrpStack->Parameters.DeviceCapabilities.Capabilities;

      //
      // Set the capabilities.
      //

      deviceCapabilities->Version = 1;
      deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);
	//
	// We support only Power state D0 and D3
	//

	deviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
	deviceCapabilities->DeviceState[PowerSystemSleeping1] = PowerSystemUnspecified;
	deviceCapabilities->DeviceState[PowerSystemSleeping2] = PowerSystemUnspecified;
	deviceCapabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
	deviceCapabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
	deviceCapabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;



      //
      // We cannot wake the system.
      //

      deviceCapabilities->SystemWake = PowerSystemUnspecified;
      deviceCapabilities->DeviceWake = PowerDeviceUnspecified;

      //
      // We have no latencies
      //

      deviceCapabilities->D1Latency = 0;
      deviceCapabilities->D2Latency = 0;
      deviceCapabilities->D3Latency = 0;

      //
      // No locking or ejection
      //

      deviceCapabilities->LockSupported = FALSE;
      deviceCapabilities->EjectSupported = FALSE;

      //
      // Device can be physically removed.
      // Technically there is no physical device to remove, but this bus
      // driver can yank the PDO from the PlugPlay system, when ever it
      // receives an IOCTL_SERENUM_REMOVE_PORT device control command.
      //

      deviceCapabilities->Removable = FALSE;

      //
      // not Docking device
      //

      deviceCapabilities->DockDevice = FALSE;

      deviceCapabilities->UniqueID = FALSE;
      deviceCapabilities->SilentInstall = TRUE;
      deviceCapabilities->RawDeviceOK = FALSE;
      deviceCapabilities->SurpriseRemovalOK = TRUE;

      status = STATUS_SUCCESS;
      break;

 
   case IRP_MN_QUERY_DEVICE_TEXT: {

      MxenumKdPrint (MXENUM_DBG_TRACE,("PDO:Query Device Text \n"));

      if (IrpStack->Parameters.QueryDeviceText.DeviceTextType
          != DeviceTextDescription) {
         break;
      }
 
      returnBuffer = ExAllocatePool(PagedPool,
		 sizeof(MXENUM_PDO_DEVICE_TEXT)+ sizeof(UNICODE_NULL));

      if (returnBuffer == NULL) {
         status = STATUS_INSUFFICIENT_RESOURCES;
         break;
      }

      status = STATUS_SUCCESS;

      RtlZeroMemory(returnBuffer,sizeof(MXENUM_PDO_DEVICE_TEXT)+ sizeof(UNICODE_NULL));
      RtlCopyMemory(returnBuffer, MXENUM_PDO_DEVICE_TEXT,
                    sizeof(MXENUM_PDO_DEVICE_TEXT));
	
      MxenumKdPrint(MXENUM_DBG_TRACE,
                            ("TextID: %ws\n", returnBuffer));


      Irp->IoStatus.Information = (ULONG_PTR)returnBuffer;

      break;
   }



   case IRP_MN_QUERY_ID:
      //
      // Query the IDs of the device
      //
      MxenumKdPrint(MXENUM_DBG_TRACE,
                      ("PDO:QueryID: 0x%x\n", IrpStack->Parameters.QueryId.IdType));

     
      switch (IrpStack->Parameters.QueryId.IdType) {


      case BusQueryInstanceID:
         //
         // Build an instance ID.  This is what PnP uses to tell if it has
         // seen this thing before or not.  Build it from the first hardware
         // id and the port number.
         //
         // NB since we do not incorperate the port number
         // this method does not produce unique ids;
         //
         // return 0000 for all devices and have the flag set to not unique
         //
 
         length = MXENUM_INSTANCE_IDS_LENGTH * sizeof(WCHAR);
         returnBuffer = ExAllocatePool(PagedPool, length);

         if (returnBuffer != NULL) {
            RtlCopyMemory(returnBuffer, MXENUM_INSTANCE_IDS, length);
		status = STATUS_SUCCESS;
         } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
         }

         MxenumKdPrint(MXENUM_DBG_TRACE,
                      ("InstanceID: %ws\n", returnBuffer));

         Irp->IoStatus.Information = (ULONG_PTR)returnBuffer;
         break;


      //
      // The other ID's we just copy from the buffers and are done.
      //

      case BusQueryDeviceID:
      case BusQueryHardwareIDs:
      case BusQueryCompatibleIDs:
         {
            PUNICODE_STRING pId;

	      status = STATUS_SUCCESS;
            switch (IrpStack->Parameters.QueryId.IdType) {
            case BusQueryDeviceID:
 
               pId = &DeviceData->DeviceIDs;
               break;

            case BusQueryHardwareIDs:
 
               pId = &DeviceData->HardwareIDs;
               break;

            case BusQueryCompatibleIDs:
 
               pId = &DeviceData->CompIDs;
               break;
            }
 
            buffer = pId->Buffer;

            if (buffer != NULL) {
               length = pId->Length;
               returnBuffer = ExAllocatePool(PagedPool, length);
               if (returnBuffer != NULL) {
                  RtlCopyMemory(returnBuffer, buffer, pId->Length);
               } else {
                  status = STATUS_INSUFFICIENT_RESOURCES;
               }
            }

            MxenumKdPrint(MXENUM_DBG_TRACE,
                            ("ID:%ws\n", returnBuffer));

            Irp->IoStatus.Information = (ULONG_PTR)returnBuffer;
         }
         break;
	  
      }
      break;

   case IRP_MN_QUERY_DEVICE_RELATIONS:

//      MxenumKdPrint (MXENUM_DBG_TRACE, ("PDO:Query Device Relation (type=%x) \n",IrpStack->Parameters.QueryDeviceRelations.Type));

      switch (IrpStack->Parameters.QueryDeviceRelations.Type) {
      case TargetDeviceRelation: {
         PDEVICE_RELATIONS pDevRel;

         //
         // No one else should respond to this since we are the PDO
         //

//         ASSERT(Irp->IoStatus.Information == 0);

         if (Irp->IoStatus.Information != 0) {
            break;
         }


         pDevRel = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

         if (pDevRel == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
         }

         pDevRel->Count = 1;
         pDevRel->Objects[0] = DeviceObject;
         ObReferenceObject(DeviceObject);

         status = STATUS_SUCCESS;
         Irp->IoStatus.Information = (ULONG_PTR)pDevRel;
         break;
      }


      default:
         break;
      }

      break;

   case IRP_MN_START_DEVICE: {
        
      MxenumKdPrint(MXENUM_DBG_TRACE, ("PDO:Start Device\n"));

      //
      // Here we do what ever initialization and ``turning on'' that is
      // required to allow others to access this device.
      //
     
        
      DeviceData->Started = TRUE;
      status = STATUS_SUCCESS;
      break;
   }


   case IRP_MN_STOP_DEVICE:

      MxenumKdPrint(MXENUM_DBG_TRACE,("PDO:Stop Device\n"));

      //
      // Here we shut down the device.  The opposite of start.
      //

      DeviceData->Started = FALSE;
      status = STATUS_SUCCESS;
      break;
	
   case IRP_MN_REMOVE_DEVICE:

      MxenumKdPrint(MXENUM_DBG_TRACE,("PDO:Remove Device\n"));
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_QUERY_STOP_DEVICE:

      MxenumKdPrint(MXENUM_DBG_TRACE,("PDO:Query Stop Device\n"));

      //
      // No reason here why we can't stop the device.
      // If there were a reason we should speak now for answering success
      // here may result in a stop device irp.
      //

      status = STATUS_SUCCESS;
      break;

   case IRP_MN_CANCEL_STOP_DEVICE:
      MxenumKdPrint(MXENUM_DBG_TRACE, ("PDO:Cancel Stop Device\n"));
      //
      // The stop was canceled.  Whatever state we set, or resources we put
      // on hold in anticipation of the forcoming STOP device IRP should be
      // put back to normal.  Someone, in the long list of concerned parties,
      // has failed the stop device query.
      //

      status = STATUS_SUCCESS;
      break;

   case IRP_MN_QUERY_REMOVE_DEVICE:

      MxenumKdPrint(MXENUM_DBG_TRACE,("PDO:Query Remove Device\n"));
      //
      // Just like Query Stop only now the impending doom is the remove irp
      //
      status = STATUS_SUCCESS;
      break;

   case IRP_MN_CANCEL_REMOVE_DEVICE:
   case IRP_MN_READ_CONFIG:
   case IRP_MN_WRITE_CONFIG: // we have no config space
   case IRP_MN_EJECT:
   case IRP_MN_SET_LOCK:
   case IRP_MN_QUERY_INTERFACE: // We do not have any non IRP based interfaces.
   default:
      MxenumKdPrint(MXENUM_DBG_TRACE,("PDO:PNP Not handled 0x%x\n",
                                                      IrpStack->MinorFunction));
      // this is a leaf node
      // status = STATUS_NOT_IMPLEMENTED
      // For PnP requests to the PDO that we do not understand we should
      // return the IRP WITHOUT setting the status or information fields.
      // They may have already been set by a filter (eg acpi).
      break;

   }

   Irp->IoStatus.Status = status;
   IoCompleteRequest (Irp, IO_NO_INCREMENT);
 

   return status;
}

NTSTATUS
MxenumPnPRemovePDOs (PDEVICE_OBJECT PFdo)
/*++
Routine Description:
    The PlugPlay subsystem has instructed that this PDO should be removed.

    We should therefore
    - Complete any requests queued in the driver
    - If the device is still attached to the system,
      then complete the request and return.
    - Otherwise, cleanup device specific allocations, memory, events...
    - Call IoDeleteDevice
    - Return from the dispatch routine.

    Note that if the device is still connected to the bus (IE in this case
    the control panel has not yet told us that the serial device has 
    disappeared) then the PDO must remain around, and must be returned during 
    any query Device relaions IRPS.

--*/

{
   PPDO_DEVICE_DATA PdoData;
   PDEVICE_OBJECT nextDevice;
   PDEVICE_OBJECT currentDevice = ((PFDO_DEVICE_DATA)PFdo->DeviceExtension)->AttachedPDO;
   ULONG	i = 0;
 
   PAGED_CODE();  

   while (currentDevice ) {
 
         PdoData = currentDevice->DeviceExtension;      
         PdoData->Removed = TRUE;

          //
          // Complete any outstanding requests with STATUS_DELETE_PENDING.
          //
          // Serenum does not queue any irps at this time so we have nothing to do.
          //
         //
         // Free any resources.
         //

         if (PdoData->HardwareIDs.Buffer)
             ExFreePool(PdoData->HardwareIDs.Buffer);

         if (PdoData->CompIDs.Buffer)
             ExFreePool(PdoData->CompIDs.Buffer);

         if (PdoData->DeviceIDs.Buffer)
             ExFreePool(PdoData->DeviceIDs.Buffer);
         MxenumKdPrint(MXENUM_DBG_TRACE,("PDO:MxenumPnPRemovePDOs = %x\n",currentDevice));

         nextDevice = PdoData->Next;
         IoDeleteDevice(currentDevice);
         currentDevice = nextDevice;   
    }
 
    ((PFDO_DEVICE_DATA)PFdo->DeviceExtension)->NumPDOs = 0;
    ((PFDO_DEVICE_DATA)PFdo->DeviceExtension)->AttachedPDO = NULL; 

    return STATUS_SUCCESS;
}
 

NTSTATUS
MxenumPnPRemovePDO (PDEVICE_OBJECT PPdo)
/*++
Routine Description:
    The PlugPlay subsystem has instructed that this PDO should be removed.
 
--*/

{
   PPDO_DEVICE_DATA PdoData;
   PDEVICE_OBJECT nextDevice,previousDevice;
   PDEVICE_OBJECT currentDevice = ((PFDO_DEVICE_DATA)((PPDO_DEVICE_DATA)PPdo->DeviceExtension)->ParentFdo->DeviceExtension)->AttachedPDO;
   
   nextDevice = previousDevice = NULL;
   while (currentDevice ) {
 
         PdoData = currentDevice->DeviceExtension;      
         if (currentDevice != PPdo) { 
		previousDevice = currentDevice;
	   	currentDevice = PdoData->Next;
		continue;
    	   }

         PdoData->Removed = TRUE;
	   
          //
          // Complete any outstanding requests with STATUS_DELETE_PENDING.
          //
          // Serenum does not queue any irps at this time so we have nothing to do.
          //
         //
         // Free any resources.
         //

         if (PdoData->HardwareIDs.Buffer)
             ExFreePool(PdoData->HardwareIDs.Buffer);

         if (PdoData->CompIDs.Buffer)
             ExFreePool(PdoData->CompIDs.Buffer);

         if (PdoData->DeviceIDs.Buffer)
             ExFreePool(PdoData->DeviceIDs.Buffer);
         MxenumKdPrint(MXENUM_DBG_TRACE,("PDO:MxenumPnPRemovePDOs = %x\n",currentDevice));

         nextDevice = PdoData->Next;
         IoDeleteDevice(currentDevice);
	   
         if (previousDevice != NULL)
	   	((PPDO_DEVICE_DATA)previousDevice->DeviceExtension)->Next = nextDevice;
	   else
      	((PFDO_DEVICE_DATA)((PPDO_DEVICE_DATA)PPdo->DeviceExtension)->ParentFdo->DeviceExtension)->AttachedPDO = nextDevice;

	   return STATUS_SUCCESS;

    }

    return STATUS_SUCCESS;
}
 


//
//  Unit of t is 1ms
//
VOID
MxenumDelay(IN ULONG t)
{
        LARGE_INTEGER   delay;

        t *= 10000;          /* delay unit = 100 ns */

        delay = RtlConvertUlongToLargeInteger(t);

        delay = RtlLargeIntegerNegate(delay);

        KeDelayExecutionThread(
            KernelMode,
            FALSE,
            &delay
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxenum\string.c ===
/*++
Module Name:

    STRING.C

Abstract:

    
Environment:

    kernel mode only

Notes:


Revision History:
   

--*/

#include <ntddk.h>
#include <stdarg.h>
#include <ntddser.h>
#include "mxenum.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, MxenumInitMultiString)
#endif

NTSTATUS
MxenumInitMultiString(PUNICODE_STRING MultiString,
                        ...)
/*++

    This routine will take a null terminated list of ascii strings and combine
    them together to generate a unicode multi-string block

Arguments:

    MultiString - a unicode structure in which a multi-string will be built
    ...         - a null terminated list of narrow strings which will be
             combined together. This list must contain at least a
        trailing NULL

Return Value:

    NTSTATUS

--*/
{
   ANSI_STRING ansiString;
   NTSTATUS status;
   PCSTR rawString;
   ULONG multiLength = 0;
   UNICODE_STRING unicodeString;
   va_list ap;
   ULONG i;

   PAGED_CODE();

   va_start(ap,MultiString);

   //
   // Make sure that we won't leak memory
   //

// ASSERT(MultiString->Buffer == NULL);

   rawString = va_arg(ap, PCSTR);

   while (rawString != NULL) {
      RtlInitAnsiString(&ansiString, rawString);
      multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
      rawString = va_arg(ap, PCSTR);
   }

   va_end( ap );

   if (multiLength == 0) {
      //
      // Done
      //
      RtlInitUnicodeString(MultiString, NULL);
   
      return STATUS_SUCCESS;
   }

   //
   // We need an extra null
   //
   multiLength += sizeof(WCHAR);

   MultiString->MaximumLength = (USHORT)multiLength;
   MultiString->Buffer = ExAllocatePool(PagedPool, multiLength);
   MultiString->Length = 0;

   if (MultiString->Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
   }

#if DBG
   RtlFillMemory(MultiString->Buffer, multiLength, 0xff);
#endif

   unicodeString.Buffer = MultiString->Buffer;
   unicodeString.MaximumLength = (USHORT) multiLength;

   va_start(ap, MultiString);
   rawString = va_arg(ap, PCSTR);

   while (rawString != NULL) {

      RtlInitAnsiString(&ansiString,rawString);
      status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);

      //
      // We don't allocate memory, so if something goes wrong here,
      // its the function that's at fault
      //
//    ASSERT(NT_SUCCESS(status));

      //
      // Check for any commas and replace them with NULLs
      //

//    ASSERT(unicodeString.Length % sizeof(WCHAR) == 0);

      for (i = 0; i < (unicodeString.Length / sizeof(WCHAR)); i++) {
         if (unicodeString.Buffer[i] == L'\x2C' ||
             unicodeString.Buffer[i] == L'\x0C' ) {
            unicodeString.Buffer[i] = L'\0'; 
         }
      }
      //
      // Move the buffers along
      //
      unicodeString.Buffer += ((unicodeString.Length / sizeof(WCHAR)) + 1);
      unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
      unicodeString.Length = 0;

      //
      // Next
      //

      rawString = va_arg(ap, PCSTR);
   } // while

   va_end(ap);

// ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));

   //
   // Stick the final null there
   //
   unicodeString.Buffer[0] = L'\0';

   //
   // Include the nulls in the length of the string
   //

   MultiString->Length = (USHORT)multiLength;
   MultiString->MaximumLength = MultiString->Length;
   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\isr.c ===
/*++

Module Name:

    isr.c


Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

BOOLEAN
MoxaISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )
{

    PMOXA_GLOBAL_DATA   globalData;
    PMOXA_DEVICE_EXTENSION extension;
    USHORT  boardNo, port, portNo, temp;
    PUSHORT ip;
    PIO_STACK_LOCATION irpSp;
    UCHAR       ack;
    BOOLEAN servicedAnInterrupt = FALSE;
    BOOLEAN thisPassServiced;
    PLIST_ENTRY firstInterruptEntry = Context;
    PLIST_ENTRY interruptEntry;
    PMOXA_MULTIPORT_DISPATCH	dispatch;

  
    MoxaIRQok = TRUE;
    if (!firstInterruptEntry)
		return (servicedAnInterrupt);

    MoxaKdPrint(MX_DBG_TRACE_ISR,("Enter ISR(first=%x)\n",firstInterruptEntry));
    if (IsListEmpty(firstInterruptEntry))
		return (servicedAnInterrupt);

    do {
   
		thisPassServiced = FALSE;
    	interruptEntry = firstInterruptEntry->Flink;

  	 	do {	

	 		PMOXA_CISR_SW cisrsw = 
	 			CONTAINING_RECORD(
                	interruptEntry,
                    MOXA_CISR_SW,
                    SharerList
                    );
			MoxaKdPrint(MX_DBG_TRACE_ISR,("CISRSW=%x\n",cisrsw));

			if (!cisrsw)
				return (servicedAnInterrupt);
			dispatch = &cisrsw->Dispatch;
			globalData = dispatch->GlobalData;
			boardNo = (USHORT)dispatch->BoardNo;
			if (!globalData || boardNo < 0)
				return (servicedAnInterrupt);
		
			MoxaKdPrint(MX_DBG_TRACE_ISR,("Board=%d,Pending=%x,IntIndx=%x,BoardReady=%d\n",
				boardNo,
				*globalData->IntPend[boardNo],
				*globalData->IntNdx[boardNo],
				globalData->BoardReady[boardNo]
				));
            if (globalData->PciIntAckBase[boardNo]) {
           	    ack = READ_PORT_UCHAR(globalData->PciIntAckBase[boardNo]);
				MoxaKdPrint(MX_DBG_TRACE_ISR,("Ack Interrupt%d/%x/%x\n",boardNo,globalData->PciIntAckBase[boardNo],ack));
           		ack |= 4;
           		WRITE_PORT_UCHAR(globalData->PciIntAckBase[boardNo],ack);

      		}

        	if ((globalData->BoardReady[boardNo] == TRUE)
				&&(*globalData->IntPend[boardNo] == 0xff)
				&&((*globalData->IntNdx[boardNo] == 0)||( *globalData->IntNdx[boardNo]==0x80))
				) {

        		servicedAnInterrupt = TRUE;
				thisPassServiced = TRUE;

            	ip = (PUSHORT)(globalData->IntTable[boardNo]
                		+ *globalData->IntNdx[boardNo]);

            	for (port=0; port<globalData->NumPorts[boardNo]; port++) {

		    		portNo = boardNo * MAXPORT_PER_CARD + port;
                		if (!(extension = globalData->Extension[portNo]))
				    		continue;

                		if ((temp = ip[extension->PortIndex]) != 0) {

                    		ip[extension->PortIndex] = 0;
                   
                    		if ((!extension->DeviceIsOpened) ||
								(extension->PowerState != PowerDeviceD0))
                        		continue;
		 

                    		if (temp & (IntrTx | IntrTxTrigger)) {
                        		if (extension->WriteLength) {

                           			if (!extension->IsrOutFlag) {
                                		extension->IsrOutFlag = 1;
                                		MoxaInsertQueueDpc(
                                          	&extension->IsrOutDpc,
                                           	NULL,
                                           	NULL,
							  				extension
          						  			);


                            		}
                        		}
                        		else if (*(PSHORT)(extension->PortOfs + HostStat) & (WakeupTx|WakeupTxTrigger)) {

                            			*(PSHORT)(extension->PortOfs + HostStat) &= ~(WakeupTx|WakeupTxTrigger);

                            			irpSp = IoGetCurrentIrpStackLocation(
                                        			extension->CurrentWriteIrp);
                            			extension->CurrentWriteIrp->IoStatus.Information =
                                        			irpSp->Parameters.Write.Length;
                            			MoxaInsertQueueDpc(
                                        	&extension->CompleteWriteDpc,
                                        	NULL,
                                        	NULL,
						    				extension
            				    			);

                        		}
                    		}

                    		if (temp & IntrRxTrigger) {
                        		if (extension->ReadLength) {

                            			if (!extension->IsrInFlag) {
                                			extension->IsrInFlag = 1;
                                			MoxaInsertQueueDpc(
                                            	&extension->IsrInDpc,
                                            	NULL,
                                            	NULL,
						    	  				extension
					              			);

                             			}
                        		}
                    		}

                    		if (temp & IntrRx) {

                        		if (extension->IsrWaitMask & SERIAL_EV_RXCHAR)
                            			extension->HistoryMask |= SERIAL_EV_RXCHAR;
                    		}

                    		if (temp & IntrEvent) {
                        		if (extension->IsrWaitMask & SERIAL_EV_RXFLAG)
                            			extension->HistoryMask |= SERIAL_EV_RXFLAG;
                    		}

                    		if (temp & IntrRx80Full) {

                        		if (extension->IsrWaitMask & SERIAL_EV_RX80FULL)
                            			extension->HistoryMask |= SERIAL_EV_RX80FULL;
                    		}

                    		if (temp & IntrBreak) {
                        		extension->ErrorWord |= SERIAL_ERROR_BREAK;
                        		if (extension->IsrWaitMask & SERIAL_EV_BREAK)
                            			extension->HistoryMask |= SERIAL_EV_BREAK;
                        		if (extension->HandFlow.ControlHandShake &
                            			SERIAL_ERROR_ABORT) {
                            		MoxaInsertQueueDpc(
                                		&extension->CommErrorDpc,
                                		NULL,
                                		NULL,
					  					extension
            			  				);

                        		}
                    		}

                    		if (temp & IntrLine) {

//
// 9-24-01 by William
//		
#if 0 
                        		MoxaInsertQueueDpc(
                                    		&extension->IntrLineDpc,
                                    		NULL,
                                    		NULL,
								extension
				            		);
#endif
								USHORT  modemStatus;

					 			MoxaFuncGetLineStatus(
				        			extension->PortOfs,
				        			&modemStatus
				        			);
								if (extension->IsrWaitMask & (SERIAL_EV_CTS |
                                  		SERIAL_EV_DSR |
                                  		SERIAL_EV_RLSD)) {
									USHORT change;

        							change = modemStatus ^ extension->ModemStatus;
        							if ((change & LSTATUS_CTS) &&
            							(extension->IsrWaitMask & SERIAL_EV_CTS))
            							extension->HistoryMask |= SERIAL_EV_CTS;
        							if ((change & LSTATUS_DSR) &&
            							(extension->IsrWaitMask & SERIAL_EV_DSR))
            							extension->HistoryMask |= SERIAL_EV_DSR;
        							if ((change & LSTATUS_DCD) &&
            							(extension->IsrWaitMask & SERIAL_EV_RLSD))
            							extension->HistoryMask |= SERIAL_EV_RLSD;
    							}

    							extension->ModemStatus = modemStatus;

// end

                    		}

                    		if (temp & IntrError) {
		
//
// 9-24-01 by William
//
#if 0
                        		MoxaInsertQueueDpc(
                                    	&extension->IntrErrorDpc,
                                    	NULL,
                                    	NULL,
										extension
                                    	);
#endif
								USHORT  dataError;

								MoxaFuncGetDataError(
            						extension->PortOfs,
				            		&dataError
				            		);

    							if ( dataError & SERIAL_ERROR_QUEUEOVERRUN ) { 
        							extension->PerfStats.BufferOverrunErrorCount++;
        						}
    							if (dataError & SERIAL_ERROR_OVERRUN) {
						      		extension->PerfStats.SerialOverrunErrorCount++;
						    	}
    							if (dataError & SERIAL_ERROR_PARITY) {
        							extension->PerfStats.ParityErrorCount++;
        						}
    							if (dataError & SERIAL_ERROR_FRAMING) {
	       							extension->PerfStats.FrameErrorCount++;
        						}
 
    							extension->ErrorWord |= (dataError &
            						(SERIAL_ERROR_OVERRUN | SERIAL_ERROR_PARITY |
             						SERIAL_ERROR_FRAMING | SERIAL_ERROR_QUEUEOVERRUN));


    							if (extension->IsrWaitMask & SERIAL_EV_ERR) {

        							if (dataError & (SERIAL_ERROR_OVERRUN |
				                           SERIAL_ERROR_PARITY |
                        				   SERIAL_ERROR_FRAMING))
						            	extension->HistoryMask |= SERIAL_EV_ERR;
								}
								if (extension->HandFlow.ControlHandShake &
						      		SERIAL_ERROR_ABORT) {
        							MoxaInsertQueueDpc(
						            	&extension->CommErrorDpc,
                            			NULL,
                            			NULL,
				    					extension
                            			);

                    			}
// end

                			}
			
                   			if (extension->IrpMaskLocation &&
                        		extension->HistoryMask) {
                        		*extension->IrpMaskLocation =
                        		extension->HistoryMask;
                        		extension->IrpMaskLocation = NULL;
                        		extension->HistoryMask = 0;
                        		extension->CurrentWaitIrp->IoStatus.Information =
                            			sizeof(ULONG);
                        		MoxaInsertQueueDpc(
                          			&extension->CommWaitDpc,
                            		NULL,
                            		NULL,
				    				extension
                            		);

                    		}
					}
                	

            	}

            	*globalData->IntPend[boardNo] = 0;

        	}
			interruptEntry = interruptEntry->Flink;
			servicedAnInterrupt |= thisPassServiced;

    	}
    	while (interruptEntry != firstInterruptEntry);
      
    }
    while (thisPassServiced == TRUE);

    MoxaKdPrint(MX_DBG_TRACE_ISR,("Exit ISR\n"));
   
    return (servicedAnInterrupt);

}

VOID
MoxaIsrIn(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    KeSynchronizeExecution(
        extension->Interrupt,
        MoxaIsrGetData,
        extension
        );

    IoReleaseCancelSpinLock(oldIrql);
    MoxaDpcEpilogue(extension, Dpc);
}

BOOLEAN
MoxaIsrGetData(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION extension = Context;
    PIO_STACK_LOCATION irpSp;
    USHORT  max;

    if (extension->ReadLength) {

        extension->NumberNeededForRead = extension->ReadLength;

        MoxaGetData(extension);

        extension->ReadLength = extension->NumberNeededForRead;

        if (!extension->ReadLength) {
            *(PSHORT)(extension->PortOfs + HostStat) &= ~WakeupRxTrigger;

            irpSp = IoGetCurrentIrpStackLocation(
                    extension->CurrentReadIrp);
            extension->CurrentReadIrp->IoStatus.Information =
                    irpSp->Parameters.Read.Length;

            extension->CountOnLastRead = MOXA_COMPLETE_READ_COMPLETE;

            MoxaInsertQueueDpc(
                &extension->CompleteReadDpc,
                NULL,
                NULL,
				extension
                );
        }
        else {
/* 8-14-01 by William
            max = *(PUSHORT)(extension->PortOfs + RX_mask) - 128;
*/           
			max = *(PUSHORT)(extension->PortOfs + RX_mask) - RX_offset;


            if (extension->NumberNeededForRead > max)

                *(PUSHORT)(extension->PortOfs + Rx_trigger) = max;

            else
                *(PUSHORT)(extension->PortOfs + Rx_trigger) =
                    (USHORT)extension->NumberNeededForRead;
            *(PSHORT)(extension->PortOfs + HostStat) |= WakeupRxTrigger;

        }
    }

    extension->IsrInFlag = 0;

    return FALSE;
}

VOID
MoxaIsrOut(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    KeSynchronizeExecution(
        extension->Interrupt,
        MoxaIsrPutData,
        extension
        );

    IoReleaseCancelSpinLock(oldIrql);
    MoxaDpcEpilogue(extension, Dpc);
}

BOOLEAN
MoxaIsrPutData(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION extension = Context;

    if (extension->WriteLength)

        MoxaPutData(extension);

    extension->IsrOutFlag = 0;

    return FALSE;
}

VOID
MoxaIntrLine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;
    PUCHAR  ofs = extension->PortOfs;
    USHORT  modemStatus;

    MoxaFuncGetLineStatus(
            ofs,
            &modemStatus
            );
    if (extension->IsrWaitMask & (SERIAL_EV_CTS |
                                  SERIAL_EV_DSR |
                                  SERIAL_EV_RLSD)) {
        USHORT change;

        change = modemStatus ^ extension->ModemStatus;
        if ((change & LSTATUS_CTS) &&
            (extension->IsrWaitMask & SERIAL_EV_CTS))
            extension->HistoryMask |= SERIAL_EV_CTS;
        if ((change & LSTATUS_DSR) &&
            (extension->IsrWaitMask & SERIAL_EV_DSR))
            extension->HistoryMask |= SERIAL_EV_DSR;
        if ((change & LSTATUS_DCD) &&
            (extension->IsrWaitMask & SERIAL_EV_RLSD))
            extension->HistoryMask |= SERIAL_EV_RLSD;
    }

    extension->ModemStatus = modemStatus;

    IoAcquireCancelSpinLock(&oldIrql);

    if (extension->IrpMaskLocation &&
        extension->HistoryMask) {

        *extension->IrpMaskLocation =
         extension->HistoryMask;
        extension->IrpMaskLocation = NULL;
        extension->HistoryMask = 0;
        extension->CurrentWaitIrp->IoStatus.Information =
            sizeof(ULONG);
        MoxaInsertQueueDpc(
            &extension->CommWaitDpc,
            NULL,
            NULL,
		extension
            );

    }

    IoReleaseCancelSpinLock(oldIrql);
    MoxaDpcEpilogue(extension, Dpc);
}

VOID
MoxaIntrError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;
    PUCHAR  ofs = extension->PortOfs;
    USHORT  dataError;

    KeAcquireSpinLock(
            &extension->ControlLock,
            &oldIrql
            );

    MoxaFuncGetDataError(
            ofs,
            &dataError
            );

    KeReleaseSpinLock(
            &extension->ControlLock,
            oldIrql
            );
 

    if ( dataError & SERIAL_ERROR_QUEUEOVERRUN ) { 
        extension->PerfStats.BufferOverrunErrorCount++;
    }
    if (dataError & SERIAL_ERROR_OVERRUN) {
        extension->PerfStats.SerialOverrunErrorCount++;
    }
    if (dataError & SERIAL_ERROR_PARITY) {
        extension->PerfStats.ParityErrorCount++;
    }
    if (dataError & SERIAL_ERROR_FRAMING) {
        extension->PerfStats.FrameErrorCount++;
    }
 
    extension->ErrorWord |= (dataError &
            (SERIAL_ERROR_OVERRUN | SERIAL_ERROR_PARITY |
             SERIAL_ERROR_FRAMING | SERIAL_ERROR_QUEUEOVERRUN));


    if (extension->IsrWaitMask & SERIAL_EV_ERR) {

        if (dataError & (SERIAL_ERROR_OVERRUN |
                           SERIAL_ERROR_PARITY |
                           SERIAL_ERROR_FRAMING))
            extension->HistoryMask |= SERIAL_EV_ERR;
    }

    if (extension->HandFlow.ControlHandShake &
        SERIAL_ERROR_ABORT) {
        MoxaInsertQueueDpc(
            &extension->CommErrorDpc,
            NULL,
            NULL,
		extension
            );

    }

    IoAcquireCancelSpinLock(&oldIrql);

    if (extension->IrpMaskLocation &&
        extension->HistoryMask) {

        *extension->IrpMaskLocation =
         extension->HistoryMask;
        extension->IrpMaskLocation = NULL;
        extension->HistoryMask = 0;
        extension->CurrentWaitIrp->IoStatus.Information =
            sizeof(ULONG);
        MoxaInsertQueueDpc(
            &extension->CommWaitDpc,
            NULL,
            NULL,
		extension
            );

    }
    IoReleaseCancelSpinLock(oldIrql);
    MoxaDpcEpilogue(extension, Dpc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\moxa.h ===
/*++

Module Name:

    moxa.h

Environment:

    Kernel mode

Revision History :

--*/



#define CONTROL_DEVICE_NAME L"\\Device\\MxCtl"
#define CONTROL_DEVICE_LINK L"\\DosDevices\\MXCTL"
//#define MOXA_DEVICE_NAME L"\\Device\\Mx000"
//#define MOXA_DEVICE_LINK L"\\DosDevices\\COMxxx"
//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY L"DosDevices"

#ifdef DEFINE_GUID
// {12FC95C1-CD81-11d3-84D5-0000E8CBD321}
#define MOXA_WMI_PORT_STATUS_GUID \
    { 0x12fc95c1, 0xcd81, 0x11d3, 0x84, 0xd5, 0x0, 0x0, 0xe8, 0xcb, 0xd3, 0x21}

DEFINE_GUID(MoxaWmiPortStatusGuid, 
0x12fc95c1, 0xcd81, 0x11d3, 0x84, 0xd5, 0x0, 0x0, 0xe8, 0xcb, 0xd3, 0x21);
#endif

typedef struct _MOXA_WMI_PORT_STATUS
{
    // The BaudRate property indicates the baud rate for this serial port
    USHORT LineStatus;
    USHORT FlowControl;
} MOXA_WMI_PORT_STATUS, *PMOXA_WMI_PORT_STATUS;



//
// Extension IoControlCode values for MOXA device.
//
#define MOXA_IOCTL		0x800
#define IOCTL_MOXA_Driver	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+0,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_LineInput	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+6,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_OQueue	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+11,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_IQueue	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+13,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_View 	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+14,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_TxLowWater	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+15,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_Statistic	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+16,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_LoopBack	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+17,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_UARTTest	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+18,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_IRQTest	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+19,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_LineStatus	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+20,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_PortStatus	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+21,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MOXA_Linked	CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+27,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MOXA_INTERNAL_BASIC_SETTINGS    CTL_CODE(FILE_DEVICE_SERIAL_PORT,MOXA_IOCTL+30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOXA_INTERNAL_BOARD_READY	    CTL_CODE(FILE_DEVICE_SERIAL_PORT,MOXA_IOCTL+31, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
#define MAX_COM 	256

//
//  status code for MOXA_IOCTL_Driver
//
#define MX_DRIVER	0x405

//
//  Definitions for MOXA cards
//
#define MAX_CARD			4
#define MAX_TYPE			6
#define MAXPORT_PER_CARD	32
#define MAX_PORT			128

#define	C218ISA		1
#define	C218PCI		2
#define	C320ISA		3
#define	C320PCI		4
#define	CP204J		5

//
//	for C218/CP204J BIOS initialization
//
#define C218_ConfBase	0x800
#define C218_status	(C218_ConfBase + 0)	/* BIOS running status	*/
#define C218_diag	(C218_ConfBase + 2)	/* diagnostic status	*/
#define C218_key	(C218_ConfBase + 4)	/* WORD (0x218 for C218)*/
#define C218DLoad_len	(C218_ConfBase + 6)	/* WORD 		*/
#define C218check_sum	(C218_ConfBase + 8)	/* BYTE 		*/
#define C218chksum_ok	(C218_ConfBase + 0x0a)	/* BYTE (1:ok)		*/
#define C218_TestRx	(C218_ConfBase + 0x10)	/* 8 bytes for 8 ports	*/
#define C218_TestTx	(C218_ConfBase + 0x18)	/* 8 bytes for 8 ports	*/
#define C218_RXerr	(C218_ConfBase + 0x20)	/* 8 bytes for 8 ports	*/
#define C218_ErrFlag	(C218_ConfBase + 0x28)	/* 8 bytes for 8 ports	*/
#define C218_TestCnt	C218_ConfBase + 0x30	/* 8 words for 8 ports	   */
#define C218_LoadBuf	0x0f00
#define C218_KeyCode	0x218

/*
 *	for C320 BIOS initialization
 */
#define C320_ConfBase	0x800
#define C320_status	C320_ConfBase + 0	/* BIOS running status	*/
#define C320_diag	C320_ConfBase + 2	/* diagnostic status	*/
#define C320_key	C320_ConfBase + 4	/* WORD (0320H for C320)*/
#define C320DLoad_len	C320_ConfBase + 6	/* WORD 		*/
#define C320check_sum	C320_ConfBase + 8	/* WORD 		*/
#define C320chksum_ok	C320_ConfBase + 0x0a	/* WORD (1:ok)		*/
#define C320bapi_len	C320_ConfBase + 0x0c	/* WORD 		*/
#define C320UART_no	C320_ConfBase + 0x0e	/* WORD 		*/
#define C320B_unlinked	(Config_base + 16)
#define C320_runOK	(Config_base + 18)
#define Disable_Irq	(Config_base + 20)
#define TMS320Port1	(Config_base + 22)
#define TMS320Port2	(Config_base + 24) 
#define TMS320Clock	(Config_base + 26) 


#define STS_init	0x05			/* for C320_status	*/

#define C320_LoadBuf	0x0f00

#define C320_KeyCode	0x320


#define FixPage_addr	0x0000		/* starting addr of static page  */
#define DynPage_addr	0x2000		/* starting addr of dynamic page */
#define Control_reg	0x1ff0		/* select page and reset control */
#define HW_reset	0x80


//
//	Function Codes
//
#define FC_CardReset	0x80
#define FC_ChannelReset 1
#define FC_EnableCH	2
#define FC_DisableCH	3
#define FC_SetParam	4
#define FC_SetMode	5
#define FC_SetRate	6
#define FC_LineControl	7
#define FC_LineStatus	8
#define FC_XmitControl	9
#define FC_FlushQueue	10
#define FC_SendBreak	11
#define FC_StopBreak	12
#define FC_LoopbackON	13
#define FC_LoopbackOFF	14
#define FC_ClrIrqTable	15
#define FC_SendXon	16
#define FC_SetTermIrq	17
#define FC_SetCntIrq	18
//#define FC_SetBreakIrq	19   // canceled
#define FC_SetLineIrq	20
#define FC_SetFlowCtl	21
#define FC_GenIrq	22
//#define FC_InCD180	23
//#define FC_OutCD180	24
#define FC_InUARTreg	23
#define FC_OutUARTreg	24
#define FC_SetXonXoff	25
//#define FC_OutCD180CCR	26 // canceled 
#define FC_ExtIQueue	27
#define FC_ExtOQueue	28
#define FC_ClrLineIrq	29
#define FC_HWFlowCtl	30
#define FC_SetBINmode	31
#define FC_SetEventCh	32
#define FC_SetTxtrigger 33
#define FC_SetRxtrigger 34
#define FC_GetClockRate 35
#define FC_SetBaud	36
#define FC_DTRcontrol	37
#define FC_RTScontrol	38
#define FC_SetXoffLimit 39
#define FC_SetFlowRepl	40
#define FC_SetDataMode	41
#define FC_GetDTRRTS	42
//#define FC_GetCCSR	43
#define FC_GetTXstat	43		/* for Windows NT */
#define FC_SetChars	44
#define FC_GetDataError 45
#define FC_ClearPort	46
#define FC_GetAll	47		//  (oqueue+linestatus+ccsr+dataerror)
#define FC_ImmSend	51
#define FC_SetXonState	52
#define FC_SetXoffState 53
#define FC_SetRxFIFOTrig	54
#define FC_SetTxFIFOCnt		55
#define Max_func		55 * 2
//
//	Dual-Ported RAM
//
#define DRAM_global	0
#define INT_data	(DRAM_global + 0)
#define Config_base	(DRAM_global + 0x108)

#define IRQindex	(INT_data + 0)
#define IRQpending	(INT_data + 4)
#define IRQtable	(INT_data + 8)

//
//	Interrupt Status
//
#define IntrRx		0x01		/* received data available     */
#define IntrTx		0x02		/* transmit buffer empty	*/
#define IntrError	0x04		/* data error			*/
#define IntrBreak	0x08		/* received break		*/
#define IntrLine	0x10		/* line status change		*/
#define IntrEvent	0x20		/* event character		*/
#define IntrRx80Full	0x40		/* Rx data over 80% full	*/
#define IntrEof 	0x80		/* received EOF char */
#define IntrRxTrigger	0x100		/* rx data count reach trigger value */
#define IntrTxTrigger	0x200		/* tx data count below trigger value*/
//
//
#define Magic_code	0x404
#define Magic_no	(Config_base + 0)
#define Card_model_no	(Config_base + 2)
#define Total_ports	(Config_base + 4)
#define C320B_len	(Config_base + 6)
#define Module_cnt	(Config_base + 8)
#define Module_no	(Config_base + 10)
#define C320B_restart	(Config_base + 12)
//#define Timer_10ms	(Config_base + 14)
#define Card_Exist	(Config_base + 14)
#define Disable_Irq	(Config_base + 20)
 


//
//	DATA BUFFER in DRAM
//
#define Extern_table	0x400		/* Base address of the external table
					   (24 words *	64) total 3K bytes
					   (24 words * 128) total 6K bytes */
#define Extern_size	0x60		/* 96 bytes			*/
#define RXrptr		0		/* read pointer for RX buffer	*/
#define RXwptr		2		/* write pointer for RX buffer	*/
#define TXrptr		4		/* read pointer for TX buffer	*/
#define TXwptr		6		/* write pointer for TX buffer	*/
#define HostStat	8		/* IRQ flag and general flag	*/
#define FlagStat	10
#define Flow_control	0x0C	       /* B7 B6 B5 B4 B3 B2 B1 B0	     */
				       /*  x  x  x  x  |  |  |	|	     */
				       /*	       |  |  |	+ CTS flow   */
				       /*	       |  |  +--- RTS flow   */
				       /*	       |  +------ TX Xon/Xoff*/
				       /*	       +--------- RX Xon/Xoff*/

 
#define Break_cnt	0x0e		/* received break count 	*/
#define CD180TXirq	0x10		/* if non-0: enable TX irq	*/
#define RX_mask 	0x12
#define TX_mask 	0x14
#define Ofs_rxb 	0x16
#define Ofs_txb 	0x18
#define Page_rxb	0x1A
#define Page_txb	0x1C
#define EndPage_rxb	0x1E
#define EndPage_txb	0x20

//#define DataCnt_IntrRx	0x22		/* available when WakeupRx on */
#define	Data_error	0x0022
                                        /* Updated by firmware and driver
                                           have to clear it after reference,
                                           Firmware will clear it only when
                                           FC_GetDataError called.
                                           B7 B6 B5 B4 B3 B2 B1 B0
                                           X  X  X  |  |  |  |  |
                                                    |  |  |  |  +--Break
                                                    |  |  |  +-----Framing
                                                    |  |  +--------Overrun
                                                    |  +-----------OqueueOverrun
                                                    +--------------Parity
					*/
#define ErrorIntr_Cnt	0x24
#define LineIntr_Cnt	0x26
#define	Rx_trigger	0x28
#define	Tx_trigger	0x2a

#define FuncCode	0x40
#define FuncArg 	0x42
#define FuncArg1	0x44

#define C218rx_size	0x2000		/* 8K bytes */
#define C218tx_size	0x8000		/* 32K bytes */

#define C218rx_mask	(C218rx_size - 1)
#define C218tx_mask	(C218tx_size - 1)

#define C320p8rx_size	0x2000
#define C320p8tx_size	0x8000
#define C320p8rx_mask	(C320p8rx_size - 1)
#define C320p8tx_mask	(C320p8tx_size - 1)

#define C320p16rx_size	0x2000
#define C320p16tx_size	0x4000
#define C320p16rx_mask	(C320p16rx_size - 1)
#define C320p16tx_mask	(C320p16tx_size - 1)

#define C320p24rx_size	0x2000
#define C320p24tx_size	0x2000
#define C320p24rx_mask	(C320p24rx_size - 1)
#define C320p24tx_mask	(C320p24tx_size - 1)

#define C320p32rx_size	0x1000
#define C320p32tx_size	0x1000
#define C320p32rx_mask	(C320p32rx_size - 1)
#define C320p32tx_mask	(C320p32tx_size - 1)

/* 8-14-01 by William */
#define RX_offset		256   

#define Page_size	0x2000
#define Page_mask	(Page_size - 1)
#define C218rx_spage	3
#define C218tx_spage	4
#define C218rx_pageno	1
#define C218tx_pageno	4
#define C218buf_pageno	5

#define C320p8rx_spage	3
#define C320p8tx_spage	4
#define C320p8rx_pgno	1
#define C320p8tx_pgno	4
#define C320p8buf_pgno	5

#define C320p16rx_spage 3
#define C320p16tx_spage 4
#define C320p16rx_pgno	1
#define C320p16tx_pgno	2
#define C320p16buf_pgno 3

#define C320p24rx_spage 3
#define C320p24tx_spage 4
#define C320p24rx_pgno	1
#define C320p24tx_pgno	1
#define C320p24buf_pgno 2

#define C320p32rx_spage 3
#define C320p32tx_ofs	C320p32rx_size
#define C320p32tx_spage 3
#define C320p32buf_pgno 1

//
//	Host Status
//
#define WakeupRx	0x01
#define WakeupTx	0x02
#define WakeupError	0x04
#define WakeupBreak	0x08
#define WakeupLine	0x10
#define WakeupEvent	0x20
#define WakeupRx80Full	0x40
#define WakeupEof	0x80
#define WakeupRxTrigger	0x100
#define WakeupTxTrigger	0x200
 

//
//	Flow_control
//
#define CTS_FlowCtl	1
#define RTS_FlowCtl	2
#define Tx_FlowCtl	4
#define Rx_FlowCtl	8
//
//	Flag status
//
 
#define Rx_over 	0x01		/* received data overflow	 */
#define Rx_xoff		0x02		/* Rx flow off by XOFF or CTS	 */
#define Tx_flowOff	0x04		/* Tx held by XOFF		 */
#define	Tx_enable	0x08		/* 1-Tx enable			 */
#define CTS_state	0x10		/* line status (CTS) 1-ON,0-OFF  */
#define DSR_state	0x20		/* line status (DSR) 1-ON,0-OFF  */
#define DCD_state	0x80		/* line status (DCD) 1-ON,0-OFF  */

//
//	LineStatus
//
#define LSTATUS_CTS	1
#define LSTATUS_DSR	2
#define LSTATUS_DCD	8

// Rx FIFO Trigger
#define	RxFIOFOTrig1	0  // trigger level = 1
#define	RxFIOFOTrig4	1  // trigger level = 4
#define	RxFIOFOTrig8	2  // trigger level = 8
#define	RxFIOFOTrig14	3  // trigger level = 14

//
//	DataMode
//
#define MOXA_5_DATA	    ((UCHAR)0x00)
#define MOXA_6_DATA	    ((UCHAR)0x01)
#define MOXA_7_DATA	    ((UCHAR)0x02)
#define MOXA_8_DATA	    ((UCHAR)0x03)
#define MOXA_DATA_MASK	    ((UCHAR)0x03)

#define MOXA_1_STOP	    ((UCHAR)0x00)
#define MOXA_1_5_STOP	    ((UCHAR)0x04)   // Only valid for 5 data bits
#define MOXA_2_STOP	    ((UCHAR)0x08)   // Not valid for 5 data bits
#define MOXA_STOP_MASK	    ((UCHAR)0x0c)

#define MOXA_NONE_PARITY    ((UCHAR)0x00)
#define MOXA_ODD_PARITY     ((UCHAR)0xc0)
#define MOXA_EVEN_PARITY    ((UCHAR)0x40)
#define MOXA_MARK_PARITY    ((UCHAR)0xa0)
#define MOXA_SPACE_PARITY   ((UCHAR)0x20)
#define MOXA_PARITY_MASK    ((UCHAR)0xe0)

#define MOXA_INT_MAPPED	    ((UCHAR)0x01)
#define MOXA_INT_IS_ROOT    ((UCHAR)0x02)

//
//
#define SERIAL_PNPACCEPT_OK                 0x0L
#define SERIAL_PNPACCEPT_REMOVING           0x1L
#define SERIAL_PNPACCEPT_STOPPING           0x2L
#define SERIAL_PNPACCEPT_STOPPED            0x4L
#define SERIAL_PNPACCEPT_SURPRISE_REMOVING  0x8L

#define SERIAL_PNP_ADDED                    0x0L
#define SERIAL_PNP_STARTED                  0x1L
#define SERIAL_PNP_QSTOP                    0x2L
#define SERIAL_PNP_STOPPING                 0x3L
#define SERIAL_PNP_QREMOVE                  0x4L
#define SERIAL_PNP_REMOVING                 0x5L
#define SERIAL_PNP_RESTARTING               0x6L

#define SERIAL_FLAGS_CLEAR                  0x0L
#define SERIAL_FLAGS_STARTED                0x1L
#define SERIAL_FLAGS_STOPPED                0x2L
#define SERIAL_FLAGS_BROKENHW               0x4L 


#define REGISTRY_MULTIPORT_CLASS     L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\Control\\Class\\{50906CB8-BA12-11D1-BF5D-0000F805F530}"
//
//
//
#define MOXA_WMI_GUID_LIST_SIZE 	6
//
//
// Debugging Output Levels
//

#define MX_DBG_MASK  0x000000FF
#define MX_DBG_NOISE               0x00000001
#define MX_DBG_TRACE               0x00000002
#define MX_DBG_INFO                0x00000004
#define MX_DBG_ERROR               0x00000008
#define MX_DBG_TRACE_ISR           0x00000010

 
 
#define MX_DEFAULT_DEBUG_OUTPUT_LEVEL (MX_DBG_MASK & ~MX_DBG_TRACE_ISR) 
//#define MX_DEFAULT_DEBUG_OUTPUT_LEVEL MX_DBG_MASK




#if DBG
 
#define MoxaKdPrint(_l_, _x_) \
            if (MX_DEFAULT_DEBUG_OUTPUT_LEVEL & (_l_)) { \
               DbgPrint ("Mxport.SYS: "); \
               DbgPrint _x_; \
            }
 
#define TRAP() DbgBreakPoint()
#define DbgRaiseIrql(_x_,_y_) KeRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_) KeLowerIrql(_x_)

#else
 
#define MoxaKdPrint(_l_, _x_)
#define TRAP()
#define DbgRaiseIrql(_x_,_y_)
#define DbgLowerIrql(_x_)

#endif

#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'pixM')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'pixM')


//
//


#define MoxaCompleteRequest(PDevExt, PIrp, PriBoost) \
   { \
      IoCompleteRequest((PIrp), (PriBoost)); \
      MoxaIRPEpilogue((PDevExt)); \
   }


typedef enum _MOXA_MEM_COMPARES {
    AddressesAreEqual,
    AddressesOverlap,
    AddressesAreDisjoint
    } MOXA_MEM_COMPARES,*PSERIAL_MEM_COMPARES;


#define DEVICE_OBJECT_NAME_LENGTH       128
#define SYMBOLIC_NAME_LENGTH            128
#define SERIAL_DEVICE_MAP               L"SERIALCOMM"


typedef struct _MOXA_DEVICE_STATE {
   //
   // TRUE if we need to set the state to open
   // on a powerup
   //

   BOOLEAN Reopen;

   //
   // Hardware registers
   //

   USHORT HostState;
   
} MOXA_DEVICE_STATE, *PMOXA_DEVICE_STATE;

#if DBG
#define MoxaLockPagableSectionByHandle(_secHandle) \
{ \
    MmLockPagableSectionByHandle((_secHandle)); \
    InterlockedIncrement(&MoxaGlobalData->PAGESER_Count); \
}

#define MoxaUnlockPagableImageSection(_secHandle) \
{ \
   InterlockedDecrement(&MoxaGlobalData->PAGESER_Count); \
   MmUnlockPagableImageSection(_secHandle); \
}


#else
#define MoxaLockPagableSectionByHandle(_secHandle) \
{ \
    MmLockPagableSectionByHandle((_secHandle)); \
}

#define MoxaUnlockPagableImageSection(_secHandle) \
{ \
   MmUnlockPagableImageSection(_secHandle); \
}

#endif // DBG



#define MoxaRemoveQueueDpc(_dpc, _pExt) \
{ \
  if (KeRemoveQueueDpc((_dpc))) { \
     InterlockedDecrement(&(_pExt)->DpcCount); \
  } \
}

#if DBG
typedef struct _DPC_QUEUE_DEBUG {
   PVOID Dpc;
   ULONG QueuedCount;
   ULONG FlushCount;
} DPC_QUEUE_DEBUG, *PDPC_QUEUE_DEBUG;

#define MAX_DPC_QUEUE 14
#endif


//
// ISR switch structure
//

typedef struct _SERIAL_MULTIPORT_DISPATCH {
    ULONG BoardNo;
    PVOID GlobalData;
/*
    ULONG NumPorts;
    PUCHAR CardBase;
    PUCHAR  PciIntAckBase;
    PUSHORT IntNdx;
    PUCHAR IntPend;
    PUCHAR IntTable;
    struct _MOXA_DEVICE_EXTENSION *ExtensionOfFisrtPort;
*/
} MOXA_MULTIPORT_DISPATCH,*PMOXA_MULTIPORT_DISPATCH;


typedef struct _MOXA_CISR_SW {
   MOXA_MULTIPORT_DISPATCH Dispatch;
   LIST_ENTRY SharerList;
} MOXA_CISR_SW, *PMOXA_CISR_SW;

struct _MOXA_DEVICE_EXTENSION;



typedef struct _MOXA_GLOBAL_DATA {
    PDRIVER_OBJECT DriverObject;
    UNICODE_STRING RegistryPath;
    PLIST_ENTRY InterruptShareList[MAX_CARD];
    USHORT  PciBusNum[MAX_CARD];
    USHORT  PciDevNum[MAX_CARD];
    INTERFACE_TYPE InterfaceType[MAX_CARD];
    ULONG   IntVector[MAX_CARD];
    PHYSICAL_ADDRESS PciIntAckPort[MAX_CARD];
    PUCHAR  PciIntAckBase[MAX_CARD];
    PHYSICAL_ADDRESS BankAddr[MAX_CARD];
    PKINTERRUPT Interrupt[MAX_CARD];
    KIRQL       Irql[MAX_CARD];
    KAFFINITY   ProcessorAffinity[MAX_CARD];

    ULONG CardType[MAX_CARD];
    ULONG NumPorts[MAX_CARD];
    ULONG BoardIndex[MAX_CARD];
    PUCHAR CardBase[MAX_CARD];
    PUSHORT IntNdx[MAX_CARD];
    PUCHAR IntPend[MAX_CARD];
    PUCHAR IntTable[MAX_CARD];
    struct _MOXA_DEVICE_EXTENSION *Extension[MAX_PORT];
    USHORT ComNo[MAX_CARD][MAXPORT_PER_CARD];
    UCHAR  PortFlag[MAX_CARD][MAXPORT_PER_CARD];
    PVOID PAGESER_Handle;
    BOOLEAN BoardReady[MAX_CARD];
#if DBG
    ULONG PAGESER_Count;
#endif // DBG

 
    } MOXA_GLOBAL_DATA,*PMOXA_GLOBAL_DATA;

typedef struct _CONFIG_DATA {
    LIST_ENTRY ConfigList;
    PHYSICAL_ADDRESS BankAddr;
    ULONG CardType;
    } CONFIG_DATA,*PCONFIG_DATA;


typedef struct _MOXA_DEVICE_EXTENSION {
    PDRIVER_OBJECT DriverObject;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT LowerDeviceObject;
    PDEVICE_OBJECT Pdo;
    PMOXA_GLOBAL_DATA GlobalData;
    BOOLEAN ControlDevice;
    BOOLEAN PortExist;
    PUCHAR PortBase;
    PUCHAR PortOfs;
    ULONG   PortIndex;  // The port index per board from 0 to MAXPORT_PER_CARD
    ULONG   PortNo; // The port index per system form 0 to MAX_PORT
    BOOLEAN DeviceIsOpened;
    PKINTERRUPT Interrupt;
    ULONG   ClockType;
    ULONG   CurrentBaud;
    UCHAR   DataMode;
    UCHAR   ValidDataMask;
    SERIAL_TIMEOUTS Timeouts;
    SERIAL_CHARS SpecialChars;
    UCHAR EscapeChar;
    SERIAL_HANDFLOW HandFlow;

    //
    // Holds performance statistics that applications can query.
    // Reset on each open.  Only set at device level.
    //
    SERIALPERF_STATS PerfStats;

    USHORT  ModemStatus;
    ULONG IsrWaitMask;
    ULONG HistoryMask;
    ULONG *IrpMaskLocation;
    ULONG RxBufferSize;
    ULONG TxBufferSize;
    ULONG BufferSizePt8;
    ULONG ErrorWord;
    ULONG TXHolding;
    ULONG WriteLength;
    PUCHAR  WriteCurrentChar;
    BOOLEAN AlreadyComplete;
    ULONG ReadLength;
    PUCHAR  ReadCurrentChar;
    ULONG NumberNeededForRead;
    LONG CountOnLastRead;
    ULONG ReadByIsr;
    ULONG TotalCharsQueued;
    ULONG SupportedBauds;
    ULONG MaxBaud;
    BOOLEAN SendBreak;
    KSPIN_LOCK ControlLock;
    PLIST_ENTRY InterruptShareList;
    LIST_ENTRY ReadQueue;
    LIST_ENTRY WriteQueue;
    LIST_ENTRY MaskQueue;
    LIST_ENTRY PurgeQueue;
    PIRP CurrentReadIrp;
    PIRP CurrentWriteIrp;
    PIRP CurrentMaskIrp;
    PIRP CurrentPurgeIrp;
    PIRP CurrentWaitIrp;
    KTIMER ReadRequestTotalTimer;
    KTIMER ReadRequestIntervalTimer;
    KTIMER WriteRequestTotalTimer;
    KDPC CompleteWriteDpc;
    KDPC CompleteReadDpc;
    KDPC TotalReadTimeoutDpc;
    KDPC IntervalReadTimeoutDpc;
    KDPC TotalWriteTimeoutDpc;
    KDPC CommErrorDpc;
    KDPC CommWaitDpc;
    KDPC IsrInDpc;
    KDPC IsrOutDpc;
//
// 9-24-01 by William
//
//  KDPC IntrLineDpc;
//  KDPC IntrErrorDpc;
// end
    //
    // This DPC is fired to set an event stating that all other
    // DPC's have been finish for this device extension so that
    // paged code may be unlocked.
    //

    KDPC IsrUnlockPagesDpc;

    LARGE_INTEGER IntervalTime;
    PLARGE_INTEGER IntervalTimeToUse;
    LARGE_INTEGER ShortIntervalAmount;
    LARGE_INTEGER LongIntervalAmount;
    LARGE_INTEGER CutOverAmount;
    LARGE_INTEGER LastReadTime;
    UCHAR IsrInFlag;
    UCHAR IsrOutFlag;
    USHORT ErrorCnt;
    USHORT LineIntrCnt;
    UCHAR  PortFlag;
    ULONG	BoardNo;
 
  
    // This is the water mark that the rxfifo should be
    // set to when the fifo is turned on.  This is not the actual
    // value, but the encoded value that goes into the register.
    //
    USHORT RxFifoTrigger;

    //
    // The number of characters to push out if a fifo is present.
    //
    USHORT TxFifoAmount;


 
    // This lock will be used to protect the accept / reject state
    // transitions and flags of the driver  It must be acquired
    // before a cancel lock
    //
    
    KSPIN_LOCK FlagsLock;

    // This is where keep track of the power state the device is in.
    //

    DEVICE_POWER_STATE PowerState;
   
    //
    // This links together all devobjs that this driver owns.
    // It is needed to search when starting a new device.
    //
    LIST_ENTRY AllDevObjs;

//
    // We keep a pointer around to our device name for dumps
    // and for creating "external" symbolic links to this
    // device.
    //
    UNICODE_STRING DeviceName;

    //
    // This points to the object directory that we will place
    // a symbolic link to our device name.
    //
    UNICODE_STRING ObjectDirectory;

 
    // Records whether we actually created the symbolic link name
    // at driver load time.  If we didn't create it, we won't try
    // to destroy it when we unload.
    //
    BOOLEAN CreatedSymbolicLink;

    //
    // Records whether we actually created an entry in SERIALCOMM
    // at driver load time.  If we didn't create it, we won't try
    // to destroy it when the device is removed.
    //
    BOOLEAN CreatedSerialCommEntry;

    //
    // This points to the symbolic link name that will be
    // linked to the actual nt device name.
    //
    UNICODE_STRING SymbolicLinkName;

    //
    // This points to the pure "COMx" name
    //
    WCHAR DosName[32];
    //
    // String where we keep the symbolic link that is returned to us when we
    // register our device under the COMM class with the Plug and Play manager.
    //

    UNICODE_STRING DeviceClassSymbolicName;
 

    //
    // Count of pending IRP's
    //

    ULONG PendingIRPCnt;

    //
    // Accepting requests?
    //

    ULONG DevicePNPAccept;

    //
    // No IRP's pending event
    //

    KEVENT PendingIRPEvent;

    //
    // PNP State
    //

    ULONG PNPState;

    //
    // Misc Flags
    //

    ULONG Flags;

    //
    // Open count
    //

    LONG OpenCount;
    
    //
    // Start sync event
    //

    KEVENT SerialStartEvent;

    //
    // Current state during powerdown
    //

    MOXA_DEVICE_STATE DeviceState;

    //
    // Device stack capabilites
    //

    DEVICE_POWER_STATE DeviceStateMap[PowerSystemMaximum];

    //
    // Event to signal transition to D0 completion
    //

    KEVENT PowerD0Event;

    //
    // List of stalled IRP's
    //

    LIST_ENTRY StalledIrpQueue;

    //
    // Mutex on open status
    //

    FAST_MUTEX OpenMutex;

    //
    // Mutex on close
    //

    FAST_MUTEX CloseMutex;

    //
    // TRUE if we own power policy
    //

    BOOLEAN OwnsPowerPolicy;

    //
    // SystemWake from devcaps
    //

    SYSTEM_POWER_STATE SystemWake;

    //
    // DeviceWake from devcaps
    //

    DEVICE_POWER_STATE DeviceWake;

    //
    // Should we enable wakeup
    //

    BOOLEAN SendWaitWake;


    //
    // Pending wait wake IRP
    //

    PIRP PendingWakeIrp;

    //
    // WMI Information
    //

    WMILIB_CONTEXT WmiLibInfo;

    //
    // Name to use as WMI identifier
    //

    UNICODE_STRING WmiIdentifier;

    //
    // WMI Comm Data
    //

    SERIAL_WMI_COMM_DATA WmiCommData;

    //
    // WMI HW Data
    //

    SERIAL_WMI_HW_DATA WmiHwData;

    //
    // Pending DPC count
    //

    ULONG DpcCount;

    //
    // Pending DPC event
    //

    KEVENT PendingDpcEvent;

    ULONG	PollingPeriod;



//
//
   
    } MOXA_DEVICE_EXTENSION,*PMOXA_DEVICE_EXTENSION;

typedef struct _MOXA_IOCTL_FUNC {
    PUCHAR   PortOfs;
    UCHAR    Command;
    USHORT   Argument;
    } MOXA_IOCTL_FUNC,*PMOXA_IOCTL_FUNC;


typedef struct _MOXA_IOCTL_GEN_FUNC {
    PUCHAR   PortOfs;
    UCHAR    Command;
    PUSHORT  Argument;
    USHORT   ArguSize;
    } MOXA_IOCTL_GEN_FUNC,*PMOXA_IOCTL_GEN_FUNC;

typedef struct _MOXA_IOCTL_FUNC_ARGU {
    PUCHAR   PortOfs;
    UCHAR    Command;
    PUSHORT  Argument;
    } MOXA_IOCTL_FUNC_ARGU,*PMOXA_IOCTL_FUNC_ARGU;

typedef struct _MOXA_IOCTL_SYNC {
    PMOXA_DEVICE_EXTENSION Extension;
    PVOID Data;
    } MOXA_IOCTL_SYNC,*PMOXA_IOCTL_SYNC;

typedef union _MOXA_IOCTL_DownLoad {
    struct {
	ULONG	CardNo;
	ULONG	Len;
	PUCHAR	Buf;
    } i;
    struct {
	ULONG	CardNo;
	ULONG	Status;
	PUCHAR	Buf;
    } o;
    } MOXA_IOCTL_DownLoad,*PMOXA_IOCTL_DownLoad;

typedef struct	_MOXA_IOCTL_LINPUT_IN {
    UCHAR    Terminater;
    ULONG    BufferSize;
    } MOXA_IOCTL_LINPUT_IN,*PMOXA_IOCTL_LINPUT_IN;

typedef struct	_MOXA_IOCTL_LINPUT_OUT {
    ULONG    DataLen;
    UCHAR    DataBuffer[1];
    } MOXA_IOCTL_LINPUT_OUT,*PMOXA_IOCTL_LINPUT_OUT;

typedef struct	_MOXA_IOCTL_PUTB {
    ULONG    DataLen;
    PUCHAR   DataBuffer;
    } MOXA_IOCTL_PUTB,*PMOXA_IOCTL_PUTB;

//
// The following three macros are used to initialize, increment
// and decrement reference counts in IRPs that are used by
// this driver.  The reference count is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define MOXA_INIT_REFERENCE(Irp) \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL;

#define MOXA_INC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))++)

#define MOXA_DEC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))--)

#define MOXA_REFERENCE_COUNT(Irp) \
    ((LONG)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))

//
// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
// to the interval timeout that it should complete.
//
#define MOXA_COMPLETE_READ_CANCEL ((LONG)-1)
#define MOXA_COMPLETE_READ_TOTAL ((LONG)-2)
#define MOXA_COMPLETE_READ_COMPLETE ((LONG)-3)
#define WRITE_LOW_WATER 128

//
// Moxa Utilities using data structure:
//
typedef struct	_MOXA_IOCTL_Statistic {
    ULONG    TxCount;		// total transmitted count
    ULONG    RxCount;		// total received count
    ULONG    LStatus;		// current line status
    ULONG    FlowCtl;		// current flow control setting
    } MOXA_IOCTL_Statistic,*PMOXA_IOCTL_Statistic;

typedef struct	_MOXA_IOCTL_PortStatus {
    USHORT   Open;			// open/close state
    USHORT   TxHold;			// Transmit holding reason
    ULONG    DataMode;			// current data bits/parity/stop bits
    ULONG    BaudRate;			// Current baud rate
    ULONG    MaxBaudRate;		// Max. baud rate
    ULONG    TxBuffer;			// Tx buffer size
    ULONG    RxBuffer;			// Rx buffer size
    ULONG    TxXonThreshold;		// Xon limit
    ULONG    TxXoffThreshold;		// Xoff limit
    ULONG    FlowControl;		// Current flow control setting.
    } MOXA_IOCTL_PortStatus,*PMOXA_IOCTL_PortStatus;

#define 	MX_PCI_VENID       		0x1393
#define 	MX_C218PCI_DEVID   		0x2180
#define 	MX_C320PCI_DEVID   		0x3200


struct	MoxaPciInfo {
    USHORT	BusNum;
    USHORT	DevNum;
};


typedef struct _MxConfig {
	 
	int			NoBoards;
	int			BusType[MAX_CARD];
	struct	MoxaPciInfo	Pci[MAX_CARD];
	int			BoardType[MAX_CARD];
	ULONG   		BaseAddr[MAX_CARD];
	ULONG			PciIrqAckPort[MAX_CARD];
        int			Irq[MAX_CARD];
//	INT			NoPorts[MAX_CARD];
	USHORT			ComNo[MAX_CARD][MAXPORT_PER_CARD];
#define DISABLE_FIFO	0x01
#define NORMAL_TX_MODE  0x02
	UCHAR			PortFlag[MAX_CARD][MAXPORT_PER_CARD];
      
} MOXA_Config,*PMOXA_Config;


#define	MAX_PCI_BOARDS	8
typedef struct _MxPciConfig {
	int			NoBoards;
	USHORT			DevId[MAX_PCI_BOARDS]; 
        USHORT			BusNum[MAX_PCI_BOARDS]; 
        USHORT			DevNum[MAX_PCI_BOARDS]; 
	ULONG   		BaseAddr[MAX_PCI_BOARDS];
	ULONG			PciIrqAckPort[MAX_PCI_BOARDS];
        int			Irq[MAX_PCI_BOARDS];
       
} MOXA_PCIConfig,*PMOXA_PCIConfig;

typedef struct _DEVICE_SETTINGS {
    ULONG			BoardIndex;
    ULONG			PortIndex;
    ULONG			BoardType;
    ULONG			NumPorts;
    INTERFACE_TYPE      InterfaceType;
    ULONG	      	BusNumber;
    PHYSICAL_ADDRESS    OriginalBaseAddress;
    PHYSICAL_ADDRESS    OriginalAckPort;
    PUCHAR		      BaseAddress;
    PUCHAR		      AckPort;

    struct {
        ULONG Level;
        ULONG Vector;
        ULONG Affinity;
    } Interrupt;

} DEVICE_SETTINGS, *PDEVICE_SETTINGS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\modmflow.c ===
/*++

Module Name:

    modmflow.c

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

BOOLEAN
MoxaSetupNewHandFlow(
    IN PVOID Context
    )
{

    PMOXA_IOCTL_SYNC S = Context;
    PMOXA_DEVICE_EXTENSION Extension = S->Extension;
    PSERIAL_HANDFLOW NewHandFlow = S->Data;
    SERIAL_HANDFLOW New = *NewHandFlow;
    USHORT flowControl = 0;
    PUCHAR  ofs = Extension->PortOfs;

    if ((!Extension->DeviceIsOpened) ||
	((Extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) !=
	 (New.ControlHandShake & SERIAL_CTS_HANDSHAKE)) ||
	((Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) !=
	 (New.FlowReplace & SERIAL_AUTO_TRANSMIT)) ||
	((Extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
	 (New.FlowReplace & SERIAL_AUTO_RECEIVE)) ||
	((Extension->HandFlow.FlowReplace & SERIAL_RTS_HANDSHAKE) !=
	 (New.FlowReplace & SERIAL_RTS_HANDSHAKE))) {

	if (New.ControlHandShake & SERIAL_CTS_HANDSHAKE)
	    flowControl |= CTS_FlowCtl;

	if (New.FlowReplace & SERIAL_RTS_HANDSHAKE)
	    flowControl |= RTS_FlowCtl;

	if (New.FlowReplace & SERIAL_AUTO_TRANSMIT)
	    flowControl |= Tx_FlowCtl;

	if (New.FlowReplace & SERIAL_AUTO_RECEIVE)
	    flowControl |= Rx_FlowCtl;

	MoxaFunc(ofs, FC_SetFlowCtl, flowControl);
    }

    if ((New.ControlHandShake & SERIAL_DTR_MASK) !=
		SERIAL_DTR_HANDSHAKE) {

	if ((New.ControlHandShake & SERIAL_DTR_MASK) ==
		SERIAL_DTR_CONTROL) {

	    MoxaFunc(ofs, FC_DTRcontrol, 1);  /* set DTR */
	    MoxaFlagBit[Extension->PortNo] |= 1;
	} else {

	    MoxaFunc(ofs, FC_DTRcontrol, 0);  /* clear DTR */
	    MoxaFlagBit[Extension->PortNo] &= 0xFE;
	}
    }

    if ((!Extension->DeviceIsOpened) ||
	((Extension->HandFlow.FlowReplace & SERIAL_RTS_HANDSHAKE) !=
	 (New.FlowReplace & SERIAL_RTS_HANDSHAKE))) {

	if (New.FlowReplace & SERIAL_RTS_HANDSHAKE) {

	    MoxaFunc(ofs, FC_RTScontrol, 1);  /* set RTS */
	    MoxaFlagBit[Extension->PortNo] |= 2;
	}
    }

    if ((New.FlowReplace & SERIAL_RTS_MASK) !=
		SERIAL_RTS_HANDSHAKE) {

	if ((New.FlowReplace & SERIAL_RTS_MASK) ==
		SERIAL_RTS_CONTROL) {

	    MoxaFunc(ofs, FC_RTScontrol, 1);  /* set RTS */
	    MoxaFlagBit[Extension->PortNo] |= 2;
	} else {

	    MoxaFunc(ofs, FC_RTScontrol, 0);  /* clear RTS */
	    MoxaFlagBit[Extension->PortNo] &= 0xFD;
	}
    }

    MoxaFunc(ofs, FC_SetXoffLimit, (USHORT)New.XoffLimit);

    MoxaFunc(ofs, FC_SetFlowRepl, (USHORT)New.FlowReplace);

    Extension->HandFlow = New;

    return FALSE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\ioctl.c ===
/*++

Module Name:

    ioctl.c

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
MoxaIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    NTSTATUS status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION irpSp;
    //
    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    ULONG ioControlCode;
    KIRQL oldIrql;



    //
    // We expect to be open so all our pages are locked down.  This is, after
    // all, an IO operation, so the device should be open first.
    //

    if (extension->DeviceIsOpened != TRUE) {
       Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       return STATUS_INVALID_DEVICE_REQUEST;
    }
  

    
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
 
    if (extension->ControlDevice) {
        if  (
            (ioControlCode != IOCTL_MOXA_GetSeg) &&
            (ioControlCode != IOCTL_MOXA_RdData) &&
            (ioControlCode != IOCTL_MOXA_WrData) &&
            (ioControlCode != IOCTL_MOXA_FiData) &&
            (ioControlCode != IOCTL_MOXA_Statistic) &&
            (ioControlCode != IOCTL_MOXA_Linked) &&
            (ioControlCode != IOCTL_MOXA_PortStatus)) {

		Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            return STATUS_INVALID_DEVICE_REQUEST;

	  }
    }
    else {

	  if ((status = MoxaIRPPrologue(Irp, extension))
        	!= STATUS_SUCCESS) {
       	Irp->IoStatus.Status = status;
       	MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
        	return status;
        }
        if (MoxaCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS)

            return STATUS_CANCELLED;
    }

    Irp->IoStatus.Information = 0L;
    status = STATUS_SUCCESS;
    switch (ioControlCode) {

    case IOCTL_SERIAL_SET_BAUD_RATE : {

        ULONG baudRate;
        SHORT divisor;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SERIAL_BAUD_RATE)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        else
            baudRate = ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;

        if (baudRate > extension->MaxBaud) {

            status = STATUS_INVALID_PARAMETER;
            break;
        }

        status = MoxaGetDivisorFromBaud(
                         extension->ClockType,
                         baudRate,
                         &divisor
                         );


        //
        // Make sure we are at power D0
        //
#if 0
        if (NT_SUCCESS(status)) {
           if (extension->PowerState != PowerDeviceD0) {
              status = MoxaGotoPowerState(extension->Pdo, extension,
                                            PowerDeviceD0);
              if (!NT_SUCCESS(status)) {
                 break;
              }
           }
        }
#endif
	  if (extension->PowerState != PowerDeviceD0) {
        	status = STATUS_INVALID_DEVICE_REQUEST;
        	break;
        }
//        MoxaKdPrint(MX_DBG_TRACE,("Set Baud to %d,divisor = %x,clock type=%x\n",baudRate,divisor,extension->ClockType));

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        if (NT_SUCCESS(status)) {

            extension->CurrentBaud = baudRate;
            extension->WmiCommData.BaudRate = baudRate;

            MoxaFunc(
                extension->PortOfs,
                FC_SetBaud,
                divisor
                );
        }
        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );
    
        break;
    }

    case IOCTL_SERIAL_GET_BAUD_RATE: {

        PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_BAUD_RATE)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        Br->BaudRate = extension->CurrentBaud;

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);

        break;

    }

    case IOCTL_SERIAL_SET_LINE_CONTROL: {

        PSERIAL_LINE_CONTROL Lc =
            ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

        UCHAR lData;
        UCHAR lStop;
        UCHAR lParity;
        UCHAR mask = 0xff;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SERIAL_LINE_CONTROL)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        //
        // Make sure we are at power D0
        //
#if 0
        if (extension->PowerState != PowerDeviceD0) {
            status = MoxaGotoPowerState(extension->Pdo, extension,
                                             PowerDeviceD0);
            if (!NT_SUCCESS(status)) {
               break;
            }
        }
#endif
	  if (extension->PowerState != PowerDeviceD0) {
        	status = STATUS_INVALID_DEVICE_REQUEST;
        	break;
        }


        switch (Lc->WordLength) {

        case 5:

            lData = MOXA_5_DATA;
            mask = 0x1f;
            break;

        case 6:

            lData = MOXA_6_DATA;
            mask = 0x3f;
            break;

        case 7:

            lData = MOXA_7_DATA;
            mask = 0x7f;
            break;

        case 8:

            lData = MOXA_8_DATA;
            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            goto DoneWithIoctl;
        }

        extension->WmiCommData.BitsPerByte = Lc->WordLength;

        switch (Lc->Parity) {

        case NO_PARITY:

            lParity = MOXA_NONE_PARITY;
            extension->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
            break;

        case EVEN_PARITY:

            lParity = MOXA_EVEN_PARITY;
            extension->WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;
            break;

        case ODD_PARITY:

            lParity = MOXA_ODD_PARITY;
            extension->WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;
            break;

        case SPACE_PARITY:

            lParity = MOXA_SPACE_PARITY;
            extension->WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;
            break;

        case MARK_PARITY: 

            lParity = MOXA_MARK_PARITY;
            extension->WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;
            break;

        default:

            status = STATUS_INVALID_PARAMETER;
            goto DoneWithIoctl;
        }

        switch (Lc->StopBits) {

        case STOP_BIT_1:

            lStop = MOXA_1_STOP;
            extension->WmiCommData.StopBits = SERIAL_WMI_STOP_1;

            break;

        case STOP_BITS_1_5:

            if (lData != MOXA_5_DATA) {

                status = STATUS_INVALID_PARAMETER;
                goto DoneWithIoctl;
            }
            lStop = MOXA_1_5_STOP;
            extension->WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;
            break;


        case STOP_BITS_2:

            if (lData == MOXA_5_DATA) {

                status = STATUS_INVALID_PARAMETER;
                goto DoneWithIoctl;
            }
            lStop = MOXA_2_STOP;
            extension->WmiCommData.StopBits = SERIAL_WMI_STOP_2;
            break;


        default:

            status = STATUS_INVALID_PARAMETER;
            goto DoneWithIoctl;

        }
   

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        extension->DataMode = lData | lParity | lStop;

        extension->ValidDataMask = mask;

        MoxaFunc(
                extension->PortOfs,
                FC_SetDataMode,
                extension->DataMode
                );

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;
    }

    case IOCTL_SERIAL_GET_LINE_CONTROL: {

        PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_LINE_CONTROL)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        if ((extension->DataMode & MOXA_DATA_MASK) == MOXA_5_DATA) {
            Lc->WordLength = 5;
        } else if ((extension->DataMode & MOXA_DATA_MASK)
                    == MOXA_6_DATA) {
            Lc->WordLength = 6;
        } else if ((extension->DataMode & MOXA_DATA_MASK)
                    == MOXA_7_DATA) {
            Lc->WordLength = 7;
        } else if ((extension->DataMode & MOXA_DATA_MASK)
                    == MOXA_8_DATA) {
            Lc->WordLength = 8;
        }

        if ((extension->DataMode & MOXA_PARITY_MASK)
                == MOXA_NONE_PARITY) {
            Lc->Parity = NO_PARITY;
        } else if ((extension->DataMode & MOXA_PARITY_MASK)
                == MOXA_ODD_PARITY) {
            Lc->Parity = ODD_PARITY;
        } else if ((extension->DataMode & MOXA_PARITY_MASK)
                == MOXA_EVEN_PARITY) {
            Lc->Parity = EVEN_PARITY;
        } else if ((extension->DataMode & MOXA_PARITY_MASK)
                == MOXA_MARK_PARITY) {
            Lc->Parity = MARK_PARITY;
        } else if ((extension->DataMode & MOXA_PARITY_MASK)
                == MOXA_SPACE_PARITY) {
            Lc->Parity = SPACE_PARITY;
        }

        if (extension->DataMode & MOXA_2_STOP) {
                Lc->StopBits = STOP_BITS_2;
        } else if (extension->DataMode & MOXA_1_5_STOP) {
                Lc->StopBits = STOP_BITS_1_5;
        } else {
                Lc->StopBits = STOP_BIT_1;
        }

        Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;
    }
    case IOCTL_SERIAL_SET_TIMEOUTS: {

        PSERIAL_TIMEOUTS newTimeouts =
            ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));


        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SERIAL_TIMEOUTS)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        if ((newTimeouts->ReadIntervalTimeout == MAXULONG) &&
            (newTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) &&
            (newTimeouts->ReadTotalTimeoutConstant == MAXULONG)) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        extension->Timeouts.ReadIntervalTimeout =
            newTimeouts->ReadIntervalTimeout;

        extension->Timeouts.ReadTotalTimeoutMultiplier =
            newTimeouts->ReadTotalTimeoutMultiplier;

        extension->Timeouts.ReadTotalTimeoutConstant =
            newTimeouts->ReadTotalTimeoutConstant;

        extension->Timeouts.WriteTotalTimeoutMultiplier =
            newTimeouts->WriteTotalTimeoutMultiplier;

        extension->Timeouts.WriteTotalTimeoutConstant =
            newTimeouts->WriteTotalTimeoutConstant;

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;
    }
    case IOCTL_SERIAL_GET_TIMEOUTS: {

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_TIMEOUTS)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        *((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) =
                extension->Timeouts;

        Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );


        break;
    }
    case IOCTL_SERIAL_SET_CHARS: {

        PSERIAL_CHARS newChars =
            ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));


        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SERIAL_CHARS)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
//
// 9-26-01 by William
//
//      if (newChars->XonChar == newChars->XoffChar) {
        if ((newChars->XonChar == newChars->XoffChar) &&
	      (extension->HandFlow.FlowReplace & (SERIAL_AUTO_TRANSMIT|SERIAL_AUTO_RECEIVE) )
	     ) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        if (extension->EscapeChar) {

            if ((extension->EscapeChar == newChars->XonChar) ||
                (extension->EscapeChar == newChars->XoffChar)) {

                status = STATUS_INVALID_PARAMETER;

                KeReleaseSpinLock(
                        &extension->ControlLock,
                        oldIrql
                        );
                break;
            }

        }

        extension->SpecialChars = *newChars;
        extension->WmiCommData.XonCharacter = newChars->XonChar;
        extension->WmiCommData.XoffCharacter = newChars->XoffChar;

        {
            int         i;
            PUCHAR      ofs;
            USHORT      cnt;

            ofs = extension->PortOfs;
            for (i=0; i<sizeof(SERIAL_CHARS); i++)
                (ofs + FuncArg)[i] = ((PUCHAR)newChars)[i];

/*12-11-00 by William
            cnt = 50;
            *(ofs + FuncCode) = FC_SetChars;
            while (*(ofs + FuncCode)) {
                MoxaDelay(1);
                if (--cnt == 0)
                        break;
   		}
*/

            *(ofs + FuncCode) = FC_SetChars;
            MoxaWaitFinish(ofs);
         
        }

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;

    }
    case IOCTL_SERIAL_GET_CHARS: {

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_CHARS)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        *((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) =
                extension->SpecialChars;
        Irp->IoStatus.Information = sizeof(SERIAL_CHARS);

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;
    }
    case IOCTL_SERIAL_SET_DTR:
    case IOCTL_SERIAL_CLR_DTR: {

#if 0
	  if (extension->PowerState != PowerDeviceD0) {

              status = MoxaGotoPowerState(extension->Pdo, extension, PowerDeviceD0);

              if (!NT_SUCCESS(status)) {
                   break;
              }
        }
#endif
	  if (extension->PowerState != PowerDeviceD0) {
        	status = STATUS_INVALID_DEVICE_REQUEST;
        	break;
        }


        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        if ((extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK)
            == SERIAL_DTR_HANDSHAKE) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            USHORT      arg;

            arg =
                ((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_DTR) ? (1):(0));

            MoxaFunc(
                extension->PortOfs,
                FC_DTRcontrol,
                arg
                );


            if ( arg )
                MoxaFlagBit[extension->PortNo] |= 1;
            else
                MoxaFlagBit[extension->PortNo] &= 0xFE;
        }

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;
    }

    case IOCTL_SERIAL_RESET_DEVICE: {

        break;
    }

    case IOCTL_SERIAL_SET_RTS:
    case IOCTL_SERIAL_CLR_RTS: {

#if 0
	  if (extension->PowerState != PowerDeviceD0) {

              status = MoxaGotoPowerState(extension->Pdo, extension, PowerDeviceD0);

              if (!NT_SUCCESS(status)) {
                   break;
              }
        }
#endif
	  if (extension->PowerState != PowerDeviceD0) {
        	status = STATUS_INVALID_DEVICE_REQUEST;
        	break;
        }


        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        if (((extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
             == SERIAL_RTS_HANDSHAKE) ||
            ((extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
             == SERIAL_TRANSMIT_TOGGLE)) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            USHORT      arg;

            arg =
                ((irpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_SET_RTS) ? (1):(0));
 
             MoxaFunc(
                extension->PortOfs,
                FC_RTScontrol,
                arg
                );

            if ( arg )
                MoxaFlagBit[extension->PortNo] |= 2;
            else
                MoxaFlagBit[extension->PortNo] &= 0xFD;
        }

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;

    }
    case IOCTL_SERIAL_SET_XOFF: {

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        extension->TXHolding |= SERIAL_TX_WAITING_FOR_XON;
        MoxaFlagBit[extension->PortNo] |= 4;

        MoxaFunc(
                extension->PortOfs,
                FC_SetXoffState,
                Magic_code
                );


        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;

    }
    case IOCTL_SERIAL_SET_XON: {

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        extension->TXHolding &= ~SERIAL_TX_WAITING_FOR_XON;
        MoxaFlagBit[extension->PortNo] &= 0xFB;

        MoxaFunc(
                extension->PortOfs,
                FC_SetXonState,
                Magic_code
                );



        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;

    }
    case IOCTL_SERIAL_SET_BREAK_ON: {

#if 0
	  if (extension->PowerState != PowerDeviceD0) {

              status = MoxaGotoPowerState(extension->Pdo, extension, PowerDeviceD0);

              if (!NT_SUCCESS(status)) {
                   break;
              }
        }
#endif
	  if (extension->PowerState != PowerDeviceD0) {
        	status = STATUS_INVALID_DEVICE_REQUEST;
        	break;
        }



        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        MoxaFunc(
                extension->PortOfs,
                FC_SendBreak,
                Magic_code
                );



        extension->SendBreak = TRUE;

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;
    }
    case IOCTL_SERIAL_SET_BREAK_OFF: {

#if 0
	  if (extension->PowerState != PowerDeviceD0) {

              status = MoxaGotoPowerState(extension->Pdo, extension, PowerDeviceD0);

              if (!NT_SUCCESS(status)) {
                   break;
              }
        }
#endif
	  if (extension->PowerState != PowerDeviceD0) {
        	status = STATUS_INVALID_DEVICE_REQUEST;
        	break;
        }


        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );
 
        MoxaFunc(
                extension->PortOfs,
                FC_StopBreak,
                Magic_code
                );
 
        extension->SendBreak = FALSE;

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;
    }
    case IOCTL_SERIAL_SET_QUEUE_SIZE: {

        break;
    }
    case IOCTL_SERIAL_GET_WAIT_MASK: {

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(ULONG);

        *((ULONG *)Irp->AssociatedIrp.SystemBuffer) = extension->IsrWaitMask;

        break;

    }
    case IOCTL_SERIAL_SET_WAIT_MASK: {

        ULONG newMask;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        else

            newMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);

        if (newMask & ~(SERIAL_EV_RXCHAR   |
                        SERIAL_EV_RXFLAG   |
                        SERIAL_EV_TXEMPTY  |
                        SERIAL_EV_CTS      |
                        SERIAL_EV_DSR      |
                        SERIAL_EV_RLSD     |
                        SERIAL_EV_BREAK    |
                        SERIAL_EV_ERR      |
                        SERIAL_EV_RING     |
                        SERIAL_EV_PERR     |
                        SERIAL_EV_RX80FULL |
                        SERIAL_EV_EVENT1   |
                        SERIAL_EV_EVENT2)) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        return  MoxaStartOrQueue(
                    extension,
                    Irp,
                    &extension->MaskQueue,
                    &extension->CurrentMaskIrp,
                    MoxaStartMask
                    );

    }
    case IOCTL_SERIAL_WAIT_ON_MASK: {

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        return  MoxaStartOrQueue(
                    extension,
                    Irp,
                    &extension->MaskQueue,
                    &extension->CurrentMaskIrp,
                    MoxaStartMask
                    );

    }
    case IOCTL_SERIAL_IMMEDIATE_CHAR: {
        UCHAR   c;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(UCHAR)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;

        }

        IoAcquireCancelSpinLock(&oldIrql);

        c = *((UCHAR *)(Irp->AssociatedIrp.SystemBuffer));

        IoReleaseCancelSpinLock(oldIrql);

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );
/* 9-14-01 by William
        MoxaFunc(
                extension->PortOfs,
                FC_ImmSend,
                c
                );

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );
*/
//
// 9-14-01 by William
//
        *(PUSHORT)(extension->PortOfs + FuncArg) = c;
        *(extension->PortOfs + FuncCode) = FC_ImmSend;

        if (MoxaWaitFinish(extension->PortOfs) == FALSE) {
            status = STATUS_UNSUCCESSFUL;
            KeReleaseSpinLock(
            	&extension->ControlLock,
                	oldIrql
                	);
		break;
        }
        KeReleaseSpinLock(
        	&extension->ControlLock,
            oldIrql
            );

        IoAcquireCancelSpinLock(&oldIrql);

        if (extension->Interrupt) {

           	KeSynchronizeExecution(
           		extension->Interrupt,
            	MoxaProcessEmptyTransmit,
               	extension
               	);
        }
        else {
            MoxaProcessEmptyTransmit(extension);
        }

        IoReleaseCancelSpinLock(oldIrql);

// end

        break;
    }
    case IOCTL_SERIAL_PURGE: {

        ULONG mask;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

       }


        mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));

        if ((!mask) || (mask & (~(SERIAL_PURGE_TXABORT |
                                  SERIAL_PURGE_RXABORT |
                                  SERIAL_PURGE_TXCLEAR |
                                  SERIAL_PURGE_RXCLEAR
                                 )
                               )
                       )) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        return  MoxaStartOrQueue(
                    extension,
                    Irp,
                    &extension->PurgeQueue,
                    &extension->CurrentPurgeIrp,
                    MoxaStartPurge
                    );

    }
    case IOCTL_SERIAL_GET_HANDFLOW: {

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_HANDFLOW)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        *((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) =
            extension->HandFlow;

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;

    }
    case IOCTL_SERIAL_SET_HANDFLOW: {

        MOXA_IOCTL_SYNC S;
        PSERIAL_HANDFLOW handFlow = Irp->AssociatedIrp.SystemBuffer;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SERIAL_HANDFLOW)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        if (handFlow->ControlHandShake & SERIAL_CONTROL_INVALID) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        if (handFlow->FlowReplace & SERIAL_FLOW_INVALID) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        if ((handFlow->ControlHandShake & SERIAL_DTR_MASK) ==
            SERIAL_DTR_MASK) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        if ((handFlow->XonLimit < 0) ||
            ((ULONG)handFlow->XonLimit > extension->RxBufferSize)) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

//
// 10-03-01 by William
//
//      if ((handFlow->XoffLimit < 0) ||
//          ((ULONG)handFlow->XoffLimit > extension->RxBufferSize)) {
//          status = STATUS_INVALID_PARAMETER;
//          break;
//
//      }

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        if (extension->EscapeChar) {

            if (handFlow->FlowReplace & SERIAL_ERROR_CHAR) {

                status = STATUS_INVALID_PARAMETER;

                KeReleaseSpinLock(
                        &extension->ControlLock,
                        oldIrql
                        );

                break;

            }

        }

       //
        // Set flowcontrol
        //
        S.Extension = extension;
        S.Data = handFlow;
        KeSynchronizeExecution(extension->Interrupt, MoxaSetupNewHandFlow, &S);


        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        break;

    }
    case IOCTL_SERIAL_GET_MODEMSTATUS: {
        USHORT  data;
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(ULONG);
        MoxaFuncGetLineStatus(extension->PortOfs, &data);
        *(PULONG)Irp->AssociatedIrp.SystemBuffer = (ULONG) (data << 4);

        break;

    }
    case IOCTL_SERIAL_GET_DTRRTS: {

        MOXA_IOCTL_FUNC_ARGU func;
        USHORT  modemControl;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(ULONG);

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );
 
        MoxaFunc(
                extension->PortOfs,
                FC_GetDTRRTS,
                0
                );
 

        modemControl = *(PUSHORT)(extension->PortOfs + FuncArg);

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        *(PULONG)Irp->AssociatedIrp.SystemBuffer = (ULONG)modemControl;

        break;

    }
    case IOCTL_SERIAL_GET_COMMSTATUS: {

        MOXA_IOCTL_SYNC S;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_STATUS)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

        S.Extension = extension;
        S.Data =  Irp->AssociatedIrp.SystemBuffer;

        IoAcquireCancelSpinLock(&oldIrql);

        KeSynchronizeExecution(
                extension->Interrupt,
                MoxaGetCommStatus,
                &S
                );

        IoReleaseCancelSpinLock(oldIrql);

        break;

    }
    case IOCTL_SERIAL_GET_PROPERTIES: {


        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_COMMPROP)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        MoxaGetProperties(
            extension,
            Irp->AssociatedIrp.SystemBuffer
            );

        Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);

        break;
    }
 
    case IOCTL_SERIAL_XOFF_COUNTER: {

        break;
    }
    case IOCTL_SERIAL_LSRMST_INSERT: {

        break;

    }
 
    case IOCTL_SERIAL_CONFIG_SIZE: {

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(ULONG);
        Irp->IoStatus.Status = STATUS_SUCCESS;

        *(PULONG)Irp->AssociatedIrp.SystemBuffer = 0;

        break;
    }
    case IOCTL_SERIAL_GET_STATS: {

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIALPERF_STATS)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
        Irp->IoStatus.Status = STATUS_SUCCESS;

        KeSynchronizeExecution(
            extension->Interrupt,
            MoxaGetStats,
            Irp
            );

        break;
    }
    case IOCTL_SERIAL_CLEAR_STATS: {

        KeSynchronizeExecution(
            extension->Interrupt,
            MoxaClearStats,
            extension
            );
        break;
    }
    case IOCTL_MOXA_Driver: {

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(ULONG);

        *(PULONG)Irp->AssociatedIrp.SystemBuffer = MX_DRIVER;

        break;
    }
#if 0
    case IOCTL_MOXA_Reset: {

        PMOXA_GLOBAL_DATA      globalData;
        PMOXA_DEVICE_EXTENSION portExt;
        SHORT   i;

        if (!extension->ControlDevice) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }
        if (*(PUSHORT)Irp->AssociatedIrp.SystemBuffer != 0x404) {

            status = STATUS_INVALID_PARAMETER;
            break;
        }

        globalData = extension->GlobalData;

        for (i=0; i<MAX_PORT; i++) {

            portExt = globalData->Extension[i];

            if (portExt)

                if (portExt->PortExist) {

                    portExt->PortExist = FALSE;

                    MoxaCancelTimer(&portExt->ReadRequestTotalTimer,portExt);
                    MoxaCancelTimer(&portExt->ReadRequestIntervalTimer,portExt);
                    MoxaCancelTimer(&portExt->WriteRequestTotalTimer,portExt);

                    KeRemoveQueueDpc(&portExt->CompleteWriteDpc);
                    KeRemoveQueueDpc(&portExt->CompleteReadDpc);
                    KeRemoveQueueDpc(&portExt->IsrOutDpc);
                    KeRemoveQueueDpc(&portExt->IsrInDpc);
                    KeRemoveQueueDpc(&portExt->TotalReadTimeoutDpc);
                    KeRemoveQueueDpc(&portExt->IntervalReadTimeoutDpc);
                    KeRemoveQueueDpc(&portExt->TotalWriteTimeoutDpc);
                    KeRemoveQueueDpc(&portExt->CommErrorDpc);
                    KeRemoveQueueDpc(&portExt->CommWaitDpc);
//
// 9-24-01 by William
//
//                  KeRemoveQueueDpc(&portExt->IntrLineDpc);
//                  KeRemoveQueueDpc(&portExt->IntrErrorDpc);
// end

                }
        }

        KeSynchronizeExecution(
                    extension->Interrupt,
                    MoxaClearDownLoad,
                    globalData
                    );

        break;
    }
  #endif
  
    case IOCTL_MOXA_LineInput: {

//
// 03-14-02 by William
//
#if 0
        if (irpSp->Parameters.DeviceIoControl.InputBufferLength !=
            sizeof(UCHAR)) {
#endif            
		if ((irpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(UCHAR)) ||
			(irpSp->Parameters.DeviceIoControl.OutputBufferLength < 1) ) {	
// end				
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        return  MoxaStartOrQueue(
                    extension,
                    Irp,
                    &extension->ReadQueue,
                    &extension->CurrentReadIrp,
                    MoxaStartRead
                    );

    }
   
    
   
    case IOCTL_MOXA_OQueue: {

        ULONG   count;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        count = GetDeviceTxQueueWithLock(extension) + extension->WriteLength
                + extension->TotalCharsQueued;

        *((PULONG)Irp->AssociatedIrp.SystemBuffer) = count;

        Irp->IoStatus.Information = sizeof(ULONG);

        break;
    }
 
    case IOCTL_MOXA_IQueue: {

        ULONG   count;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
        count = GetDeviceRxQueueWithLock(extension);

        *((PULONG)Irp->AssociatedIrp.SystemBuffer) = count;

        Irp->IoStatus.Information = sizeof(ULONG);
		
        break;
    }
    case IOCTL_MOXA_View: {

//
// 01-04-02 by William
//
//	    if (irpSp->Parameters.DeviceIoControl.InputBufferLength !=
//          sizeof(UCHAR)) {
//
//          status = STATUS_BUFFER_TOO_SMALL;
//          break;
//      }
//
		if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }
// end

        return  MoxaStartOrQueue(
                    extension,
                    Irp,
                    &extension->ReadQueue,
                    &extension->CurrentReadIrp,
                    MoxaStartRead
                    );

    }
    case IOCTL_MOXA_TxLowWater: {

        LONG    lowWater;
        PMOXA_DEVICE_EXTENSION ext;
        PUCHAR  ofs;
        USHORT  cardNo, port, portNo;

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(LONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(LONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        lowWater = *((PLONG)Irp->AssociatedIrp.SystemBuffer);

        if (lowWater > 1024)
                lowWater = 1024;

        if (lowWater >= 0) {

            MoxaTxLowWater = lowWater;

            for (cardNo=0; cardNo<MAX_CARD; cardNo++) {

                if ((!MoxaGlobalData->CardType[cardNo]) ||
                    (!MoxaGlobalData->NumPorts[cardNo]))
                        continue;

                for (port=0; port<MoxaGlobalData->NumPorts[cardNo]; port++) {
                    portNo = cardNo * MAXPORT_PER_CARD + port;
                    ext = MoxaGlobalData->Extension[portNo];
                    ofs = ext->PortOfs;
                    *(PUSHORT)(ofs + Tx_trigger) = (USHORT)(MoxaTxLowWater);
                }
            }
        }

        *((PLONG)Irp->AssociatedIrp.SystemBuffer) = MoxaTxLowWater;

        Irp->IoStatus.Information = sizeof(LONG);

        break;

    }

   
    case IOCTL_MOXA_GetSeg: {

        PMOXA_IOCTL_MxSet Ms = (PMOXA_IOCTL_MxSet)Irp->AssociatedIrp.SystemBuffer;
        PMOXA_GLOBAL_DATA Gd = (PMOXA_GLOBAL_DATA)extension->GlobalData;
        int               card;

        if (!extension->ControlDevice) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOXA_IOCTL_MxSet)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        for ( card=0; card<MAX_CARD; card++ ) {
            if ( !Gd->CardType[card] )
                break;
            Ms->type[card] = Gd->CardType[card];

            Ms->segment[card] = Gd->BankAddr[card].LowPart;
        }

        Ms->total_boards = card;

        Irp->IoStatus.Information = sizeof(MOXA_IOCTL_MxSet);
        break;
    }
    case IOCTL_MOXA_RdData: {

        PMOXA_IOCTL_BlkHead Bh = (PMOXA_IOCTL_BlkHead)Irp->AssociatedIrp.SystemBuffer;
        PMOXA_GLOBAL_DATA Gd = (PMOXA_GLOBAL_DATA)extension->GlobalData;
        PUCHAR            base;
        PUCHAR            buff;
        int               card, len, ofs, ndx;

        if (!extension->ControlDevice) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(MOXA_IOCTL_BlkHead)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        for ( card=0; card<MAX_CARD; card++ ) {
            if ( Bh->data_seg == Gd->BankAddr[card].LowPart )
                break;
        }
        if ( card == MAX_CARD ) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        base = Gd->CardBase[card];
        ofs = Bh->data_ofs;
        len = Bh->data_len;
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            (unsigned long)len) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        buff = (PUCHAR)(Irp->AssociatedIrp.SystemBuffer);
        for ( ndx=0; ndx<len; ndx++ ) {
            if ( (ndx + ofs) >= 0x4000 )
                break;
            buff[ndx] = base[ofs + ndx];
        }
        Irp->IoStatus.Information = ndx;
        break;
    }
    case IOCTL_MOXA_WrData: {

        PMOXA_IOCTL_WrData Wd = (PMOXA_IOCTL_WrData)Irp->AssociatedIrp.SystemBuffer;
        PMOXA_GLOBAL_DATA Gd = (PMOXA_GLOBAL_DATA)extension->GlobalData;
        PUCHAR            base;
        int               card, len, ofs, ndx;

        if (!extension->ControlDevice) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DWORD)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        for ( card=0; card<MAX_CARD; card++ ) {
            if ( Wd->datahead.data_seg == Gd->BankAddr[card].LowPart )
                break;
        }
        if ( card == MAX_CARD ) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        base = Gd->CardBase[card];
        ofs = Wd->datahead.data_ofs;
        len = Wd->datahead.data_len;
        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            (sizeof(MOXA_IOCTL_BlkHead) + len)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        for ( ndx=0; ndx<len; ndx++ ) {
            if ( (ndx + ofs) >= 0x4000 )
                break;
            base[ofs + ndx] = Wd->data[ndx];
        }
        *((PULONG)Irp->AssociatedIrp.SystemBuffer) = ndx;
        Irp->IoStatus.Information = sizeof(DWORD);
        break;
    }
    case IOCTL_MOXA_FiData: {

        PMOXA_IOCTL_FiData Fi = (PMOXA_IOCTL_FiData)Irp->AssociatedIrp.SystemBuffer;
        PMOXA_GLOBAL_DATA Gd = (PMOXA_GLOBAL_DATA)extension->GlobalData;
        PUCHAR            base;
        int               card, len, ofs, ndx;

        if (!extension->ControlDevice) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(MOXA_IOCTL_FiData)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DWORD)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        for ( card=0; card<MAX_CARD; card++ ) {
            if ( Fi->datahead.data_seg == Gd->BankAddr[card].LowPart )
                break;
        }
        if ( card == MAX_CARD ) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        base = Gd->CardBase[card];
        ofs = Fi->datahead.data_ofs;
        len = Fi->datahead.data_len;
        for ( ndx=0; ndx<len; ndx++ ) {
            if ( (ndx + ofs) >= 0x4000 )
                break;
            base[ofs + ndx] = Fi->fill_value;
        }
        *((PULONG)Irp->AssociatedIrp.SystemBuffer) = ndx;
        Irp->IoStatus.Information = sizeof(DWORD);
        break;
    }
    case IOCTL_MOXA_Linked: {

        PMOXA_GLOBAL_DATA Gd = extension->GlobalData;
        PUCHAR  base;
        ULONG   cardNo;

        if (!extension->ControlDevice) {

            status = STATUS_INVALID_PARAMETER;
            break;

        }

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(LONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        cardNo = *((PULONG)Irp->AssociatedIrp.SystemBuffer);
        if (cardNo >= MAX_CARD) {
           status = STATUS_INVALID_PARAMETER;
           break;
        }
        if ((Gd->CardType[cardNo] != C320ISA)&&(Gd->CardType[cardNo] != C320PCI)) {
           status = STATUS_INVALID_PARAMETER;
           break;
        }
        base = Gd->CardBase[cardNo];

        if (*((PUSHORT)(base + C320B_unlinked)) == Magic_no) {
           ((LONG)Irp->AssociatedIrp.SystemBuffer) = 1;
           Irp->IoStatus.Information = sizeof(LONG);
           break;
        }

        if (*((PUSHORT)(base + C320_runOK)) == Magic_no) {
           if (*((PUSHORT)(base + C320B_restart)) == Magic_no) { // C320B Reload OK
              ((LONG)Irp->AssociatedIrp.SystemBuffer) = 2;
              Irp->IoStatus.Information = sizeof(LONG);
              *((PUSHORT)(base + C320B_restart)) = 0;
           }
           else {   // OK
              ((LONG)Irp->AssociatedIrp.SystemBuffer) = 0;
              Irp->IoStatus.Information = sizeof(LONG);
           }
        }
        else { // Disconnected
           ((LONG)Irp->AssociatedIrp.SystemBuffer) = 1;
           Irp->IoStatus.Information = sizeof(LONG);
        }
        break;

    }

    case IOCTL_MOXA_Statistic: {

        PUSHORT com;
        USHORT  comNo[2];
        PMOXA_IOCTL_Statistic St;
        ULONG   size;
        int     ndx, portNo, nn;

        if (!extension->ControlDevice) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (irpSp->Parameters.DeviceIoControl.InputBufferLength < 4) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
	  com = (PUSHORT)Irp->AssociatedIrp.SystemBuffer;
        comNo[0] = com[0];
        comNo[1] = com[1];
        if ( comNo[1] < comNo[0] ) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        size = sizeof(MOXA_IOCTL_Statistic) * (comNo[1] - comNo[0] + 1);
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        St = (PMOXA_IOCTL_Statistic)Irp->AssociatedIrp.SystemBuffer;
        nn = 0;
        for ( ndx=(int)comNo[0]; ndx<=(int)comNo[1]; ndx++, nn++ ) {
            if ( ndx > MAX_COM )
                break;
            if ( (ndx <= 0) || (MoxaExtension[ndx] == NULL) )
                continue;
            portNo = (int)MoxaExtension[ndx]->PortNo;
            St[nn].TxCount = MoxaExtension[ndx]->PerfStats.TransmittedCount +
                             MoxaTotalTx[portNo];
            St[nn].RxCount = MoxaExtension[ndx]->PerfStats.ReceivedCount +
                             MoxaTotalRx[portNo];

          MoxaFuncGetLineStatus(
			MoxaExtension[ndx]->PortOfs,
			(PUSHORT)&MoxaExtension[ndx]->ModemStatus
			);

            St[nn].LStatus = (ULONG)MoxaExtension[ndx]->ModemStatus & 0x0F;
            St[nn].LStatus |= ((MoxaFlagBit[portNo] & 3) << 4);
            if ( MoxaExtension[ndx]->DeviceIsOpened )
                St[nn].LStatus |= 0x80;
            St[nn].FlowCtl = (MoxaExtension[ndx]->HandFlow.ControlHandShake
                             & SERIAL_CTS_HANDSHAKE) |
                             (MoxaExtension[ndx]->HandFlow.FlowReplace &
                             (SERIAL_RTS_HANDSHAKE | SERIAL_AUTO_TRANSMIT |
                             SERIAL_AUTO_RECEIVE));
        }
        Irp->IoStatus.Information = size;
        break;
    }
    case IOCTL_MOXA_LoopBack: {
        ULONG   mode; 
	  PMOXA_GLOBAL_DATA Gd = extension->GlobalData;


        if ((Gd->CardType[extension->BoardNo] == C320ISA) ||
		(Gd->CardType[extension->BoardNo] == C320PCI)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        } 

        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ULONG)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        mode = *(PULONG)Irp->AssociatedIrp.SystemBuffer;

        KeAcquireSpinLock(
            &extension->ControlLock,
            &oldIrql
            );

        MoxaFunc(
            extension->PortOfs,
            FC_DisableCH,
            Magic_code
            );


        if ( mode ) { 
         // Set loop back mode
            MoxaFunc(
                extension->PortOfs,
                FC_LoopbackON,
                Magic_code
                );


        } else {   
 
         // Reset loop back mode
            MoxaFunc(
                extension->PortOfs,
                FC_LoopbackOFF,
                Magic_code
                );

        }

        MoxaFunc(
            extension->PortOfs,
            FC_EnableCH,
            Magic_code
            );

        KeReleaseSpinLock(
            &extension->ControlLock,
            oldIrql
            );

        Irp->IoStatus.Information = 0;
        break;
    }
    case IOCTL_MOXA_UARTTest: {   
       
        int         ier, old;
        int         MoxaReadReg(PUCHAR, int);
        void        MoxaWriteReg(PUCHAR, int, int);

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(ULONG);
        *(ULONG *)Irp->AssociatedIrp.SystemBuffer = 0;

        KeAcquireSpinLock(
            &extension->ControlLock,
            &oldIrql
            );

        old = MoxaReadReg(extension->PortOfs, 1);
        MoxaWriteReg(extension->PortOfs, 1, 0);
        ier = MoxaReadReg(extension->PortOfs, 1);
        if ( ier == 0 ) {
            MoxaWriteReg(extension->PortOfs, 1, 3);
            ier = MoxaReadReg(extension->PortOfs, 1);
            if ( ier == 3 )
                *(ULONG *)Irp->AssociatedIrp.SystemBuffer = 1;
        }
        MoxaWriteReg(extension->PortOfs, 1, old);

        KeReleaseSpinLock(
            &extension->ControlLock,
            oldIrql
            );
       
        break;
    }
    case IOCTL_MOXA_IRQTest: {

        PUCHAR  ofs;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        ofs = extension->PortOfs;

        KeAcquireSpinLock(
                &extension->ControlLock,
                &oldIrql
                );

        MoxaIRQok = FALSE;
        MoxaFunc(
                ofs,
                FC_GenIrq,
                Magic_code
                );

        KeReleaseSpinLock(
                &extension->ControlLock,
                oldIrql
                );

        MoxaDelay(5);                           /* delay 10 msec */

        if ( MoxaIRQok )
            *((PULONG)Irp->AssociatedIrp.SystemBuffer) = 1;
        else
            *((PULONG)Irp->AssociatedIrp.SystemBuffer) = 0;

        Irp->IoStatus.Information = sizeof(ULONG);

        break;
    }
    case IOCTL_MOXA_LineStatus: {
        USHORT  data;

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(ULONG)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;

        }

        Irp->IoStatus.Information = sizeof(ULONG);
        MoxaFuncGetLineStatus(extension->PortOfs, &data);
        *(PULONG)Irp->AssociatedIrp.SystemBuffer = data;

        break;
    }
    case IOCTL_MOXA_PortStatus: {

        ULONG   comNo;
        PMOXA_IOCTL_PortStatus  Ps;
        if (!extension->ControlDevice) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(ULONG)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOXA_IOCTL_PortStatus)) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

	  comNo = *((PULONG)Irp->AssociatedIrp.SystemBuffer);

        if ( (comNo <= 0) || (comNo > MAX_COM) ||
             (MoxaExtension[comNo] == NULL) ) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        Ps = (PMOXA_IOCTL_PortStatus)Irp->AssociatedIrp.SystemBuffer;
        Ps->Open = (USHORT)MoxaExtension[comNo]->DeviceIsOpened;
        Ps->TxHold = 0;
        if (MoxaExtension[comNo]->HandFlow.ControlHandShake &
            SERIAL_CTS_HANDSHAKE) {
            if ((MoxaExtension[comNo]->ModemStatus & LSTATUS_CTS) == 0)
                Ps->TxHold |= 1;
        }
        if (MoxaExtension[comNo]->TXHolding & SERIAL_TX_WAITING_FOR_XON)
            Ps->TxHold |= 2;
        if (MoxaExtension[comNo]->SendBreak)
            Ps->TxHold |= 4;
        Ps->DataMode = MoxaExtension[comNo]->DataMode;
        Ps->BaudRate = MoxaExtension[comNo]->CurrentBaud;
        Ps->MaxBaudRate = MoxaExtension[comNo]->MaxBaud;
        Ps->TxBuffer = MoxaExtension[comNo]->TxBufferSize;
        Ps->RxBuffer = MoxaExtension[comNo]->RxBufferSize;
        Ps->TxXonThreshold = MoxaExtension[comNo]->HandFlow.XonLimit;
        Ps->TxXoffThreshold = MoxaExtension[comNo]->HandFlow.XoffLimit;
        Ps->FlowControl = (MoxaExtension[comNo]->HandFlow.ControlHandShake &
                           SERIAL_CTS_HANDSHAKE) |
                          (MoxaExtension[comNo]->HandFlow.FlowReplace &
                          (SERIAL_RTS_HANDSHAKE | SERIAL_AUTO_TRANSMIT |
                           SERIAL_AUTO_RECEIVE));
        Irp->IoStatus.Information = sizeof(MOXA_IOCTL_PortStatus);
        break;
    }

   

    default:

        status = STATUS_INVALID_PARAMETER;
        break;
    }

DoneWithIoctl:;

    Irp->IoStatus.Status = status;
    if (extension->ControlDevice) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {
        MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
    }

    return status;

}

BOOLEAN
MoxaGetCommStatus(
    IN PVOID Context
    )
{

    USHORT  dataError;

    PMOXA_DEVICE_EXTENSION extension = ((PMOXA_IOCTL_SYNC)Context)->Extension;
    PSERIAL_STATUS stat = ((PMOXA_IOCTL_SYNC)Context)->Data;
    PUCHAR  ofs = extension->PortOfs;
    MoxaFuncGetDataError(
            ofs,
            &dataError
            );
    stat->Errors =  (extension->ErrorWord|dataError);
    extension->ErrorWord = 0;

    stat->EofReceived = FALSE;

    {
        PUSHORT rptr, wptr;
        USHORT  lenMask, count;

 
        rptr = (PUSHORT)(ofs + RXrptr);
        wptr = (PUSHORT)(ofs + RXwptr);
        lenMask = *(PUSHORT)(ofs + RX_mask);
        count = (*wptr >= *rptr) ? (*wptr - *rptr)
                                 : (*wptr - *rptr + lenMask + 1);

        stat->AmountInInQueue = (ULONG)count;

        rptr = (PUSHORT)(ofs + TXrptr);
        wptr = (PUSHORT)(ofs + TXwptr);
        lenMask = *(PUSHORT)(ofs + TX_mask);
        count = (*wptr >= *rptr) ? (*wptr - *rptr)
                                 : (*wptr - *rptr + lenMask + 1);

        stat->AmountInOutQueue = extension->TotalCharsQueued
                + extension->WriteLength;

        stat->AmountInOutQueue += (ULONG)count;

    }

    stat->WaitForImmediate = FALSE;

    stat->HoldReasons = 0;

    MoxaFuncGetLineStatus(
			ofs,
			(PUSHORT)&extension->ModemStatus
			);


    if (extension->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) {

        if ((extension->ModemStatus & LSTATUS_CTS) == 0)

            stat->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;
    }
 
    if (*(PUSHORT)(extension->PortOfs + FlagStat) & Tx_flowOff)
       stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;

    if (*(PUSHORT)(extension->PortOfs + FlagStat) & Rx_xoff) 
	if (extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) 
		stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;
 
    if (extension->SendBreak)

        stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;

    stat->HoldReasons |= (extension->TXHolding & SERIAL_TX_WAITING_FOR_XON);

    return FALSE;

}

VOID
MoxaGetProperties(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN PSERIAL_COMMPROP Properties
    )
{

    RtlZeroMemory(
        Properties,
        sizeof(SERIAL_COMMPROP)
        );

    Properties->PacketLength = sizeof(SERIAL_COMMPROP);
    Properties->PacketVersion = 2;
    Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
    Properties->MaxTxQueue = Extension->TxBufferSize;
    Properties->MaxRxQueue = Extension->RxBufferSize;

    Properties->MaxBaud = SERIAL_BAUD_USER;
    Properties->SettableBaud = Extension->SupportedBauds;

    Properties->ProvSubType = SERIAL_SP_RS232;
    Properties->ProvCapabilities = SERIAL_PCF_DTRDSR |
                                   SERIAL_PCF_RTSCTS |
                                   SERIAL_PCF_CD     |
                                   SERIAL_PCF_PARITY_CHECK |
                                   SERIAL_PCF_XONXOFF |
                                   SERIAL_PCF_SETXCHAR |
                                   SERIAL_PCF_TOTALTIMEOUTS |
                                   SERIAL_PCF_INTTIMEOUTS;
    Properties->SettableParams = SERIAL_SP_PARITY |
                                 SERIAL_SP_BAUD |
                                 SERIAL_SP_DATABITS |
                                 SERIAL_SP_STOPBITS |
                                 SERIAL_SP_HANDSHAKING |
                                 SERIAL_SP_PARITY_CHECK |
                                 SERIAL_SP_CARRIER_DETECT;


    Properties->SettableData = SERIAL_DATABITS_5 |
                               SERIAL_DATABITS_6 |
                               SERIAL_DATABITS_7 |
                               SERIAL_DATABITS_8;

    Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                     SERIAL_STOPBITS_15 |
                                     SERIAL_STOPBITS_20 |
                                     SERIAL_PARITY_NONE |
                                     SERIAL_PARITY_ODD  |
                                     SERIAL_PARITY_EVEN |
                                     SERIAL_PARITY_MARK |
                                     SERIAL_PARITY_SPACE;

    Properties->CurrentTxQueue = Extension->TxBufferSize;
    Properties->CurrentRxQueue = Extension->RxBufferSize;

}

#if 0
BOOLEAN
MoxaClearDownLoad(
    IN PVOID Context
    )
{

    PMOXA_GLOBAL_DATA      globalData = Context;
    USHORT i;

    globalData->DownLoad = FALSE;

    for (i=0; i<MAX_CARD; i++)
        globalData->NumPorts[i] = 0;

    return FALSE;
}

#endif

VOID
InitPort(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN ULONG    RxBufSize,
    IN ULONG    TxBufSize,
    IN ULONG    MaxBaud
    )
{
    PUCHAR  ofs;
    ULONG	count;

    Extension->PortExist = TRUE;
    Extension->DeviceIsOpened = FALSE;
    Extension->OpenCount = 0;
    Extension->SendBreak = FALSE;
    Extension->OwnsPowerPolicy = TRUE;
    Extension->GlobalData = MoxaGlobalData;
    Extension->ControlDevice = FALSE;
    Extension->PowerState     = PowerDeviceD3;
    //
    // Initialize the count of IRP's pending
    //

    Extension->PendingIRPCnt = 1;

    //
    // Initialize the count of DPC's pending
    //

    Extension->DpcCount = 1;

    InitializeListHead(&Extension->ReadQueue);
    InitializeListHead(&Extension->WriteQueue);
    InitializeListHead(&Extension->MaskQueue);
    InitializeListHead(&Extension->PurgeQueue);

   
    InitializeListHead(&Extension->AllDevObjs);
    InitializeListHead(&Extension->StalledIrpQueue);


    ExInitializeFastMutex(&Extension->OpenMutex);
    ExInitializeFastMutex(&Extension->CloseMutex);

    KeInitializeEvent(&Extension->PendingIRPEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&Extension->PendingDpcEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&Extension->PowerD0Event, SynchronizationEvent, FALSE);

    KeInitializeSpinLock(&Extension->ControlLock);

    KeInitializeTimer(&Extension->ReadRequestTotalTimer);
    KeInitializeTimer(&Extension->ReadRequestIntervalTimer);
    KeInitializeTimer(&Extension->WriteRequestTotalTimer);

    KeInitializeDpc(
        &Extension->CompleteWriteDpc,
        MoxaCompleteWrite,
        Extension
        );

    KeInitializeDpc(
        &Extension->IsrOutDpc,
        MoxaIsrOut,
        Extension
        );

    KeInitializeDpc(
        &Extension->CompleteReadDpc,
        MoxaCompleteRead,
        Extension
        );

    KeInitializeDpc(
        &Extension->IsrInDpc,
        MoxaIsrIn,
        Extension
        );

    KeInitializeDpc(
        &Extension->TotalReadTimeoutDpc,
        MoxaReadTimeout,
        Extension
        );

    KeInitializeDpc(
        &Extension->IntervalReadTimeoutDpc,
        MoxaIntervalReadTimeout,
        Extension
        );

    KeInitializeDpc(
        &Extension->TotalWriteTimeoutDpc,
        MoxaWriteTimeout,
        Extension
        );

    KeInitializeDpc(
        &Extension->CommErrorDpc,
        MoxaCommError,
        Extension
        );

    KeInitializeDpc(
        &Extension->CommWaitDpc,
        MoxaCompleteWait,
        Extension
        );

//
// 9-24-01 by William
//
#if 0
    KeInitializeDpc(
        &Extension->IntrLineDpc,
        MoxaIntrLine,
        Extension
        );

    KeInitializeDpc(
        &Extension->IntrErrorDpc,
        MoxaIntrError,
        Extension
        );
#endif
// end

    KeInitializeDpc(
	  &Extension->IsrUnlockPagesDpc, 
	  MoxaUnlockPages,
	  Extension);


   
    Extension->SpecialChars.EofChar = 0;
    Extension->SpecialChars.ErrorChar = 0;
    Extension->SpecialChars.BreakChar = 0;
    Extension->SpecialChars.EventChar = 0;
    Extension->SpecialChars.XonChar = 0x11;
    Extension->SpecialChars.XoffChar = 0x13;

//    Extension->HandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
    Extension->HandFlow.ControlHandShake = 0;

//    Extension->HandFlow.FlowReplace = SERIAL_RTS_CONTROL;
    Extension->HandFlow.FlowReplace = 0;


    Extension->DataMode = MOXA_8_DATA | MOXA_NONE_PARITY;

    Extension->ValidDataMask = 0xff;
    Extension->CurrentBaud = 38400;

    Extension->RxBufferSize = RxBufSize;
    Extension->TxBufferSize = TxBufSize;

    Extension->HandFlow.XoffLimit = Extension->RxBufferSize >> 3;
    Extension->HandFlow.XonLimit = Extension->RxBufferSize >> 1;

    Extension->BufferSizePt8 = ((3*(Extension->RxBufferSize>>2))+
                                   (Extension->RxBufferSize>>4));

    Extension->SupportedBauds =
                        SERIAL_BAUD_USER    |
                        SERIAL_BAUD_075     |
                        SERIAL_BAUD_110     |
                        SERIAL_BAUD_134_5   |
                        SERIAL_BAUD_150     |
                        SERIAL_BAUD_300     |
                        SERIAL_BAUD_600     |
                        SERIAL_BAUD_1200    |
                        SERIAL_BAUD_1800    |
                        SERIAL_BAUD_2400    |
                        SERIAL_BAUD_4800    |
                        SERIAL_BAUD_7200    |
                        SERIAL_BAUD_9600    |
                        SERIAL_BAUD_14400   |
                        SERIAL_BAUD_19200   |
                        SERIAL_BAUD_38400;
                       
                
    Extension->DeviceIsOpened = FALSE;

    Extension->ShortIntervalAmount.QuadPart = -1;
    Extension->LongIntervalAmount.QuadPart = -10000000;
    Extension->CutOverAmount.QuadPart = 200000000;

  
    ofs = Extension->PortOfs;
    count = 0;

    while ((*(ofs + FuncCode) != 0)&&(count++ < 500))
        MoxaDelay(1);

    *(ofs + FuncCode) = FC_GetClockRate;
    count = 0;
    while ((*(ofs + FuncCode) != 0)&&(count++ < 500))   /* wait cmd process completed */
        MoxaDelay(1);

    Extension->ClockType = *(ofs + FuncArg);    /* 0, 1, 2 */

    if (Extension->ClockType) {

        Extension->SupportedBauds |= SERIAL_BAUD_57600;

        if (Extension->ClockType == 2)

            Extension->SupportedBauds |= SERIAL_BAUD_115200;

    }
 

    Extension->MaxBaud = MaxBaud;
   
}

BOOLEAN
MoxaGetStats(
    IN PVOID Context
    )

/*++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    return the perf stats to the caller.


Arguments:

    Context - Pointer to a the irp.

Return Value:

    This routine always returns FALSE.

--*/

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation((PIRP)Context);
    PMOXA_DEVICE_EXTENSION extension = irpSp->DeviceObject->DeviceExtension;
    PSERIALPERF_STATS sp = ((PIRP)Context)->AssociatedIrp.SystemBuffer;

    *sp = extension->PerfStats;
    return FALSE;

}

BOOLEAN
MoxaClearStats(
    IN PVOID Context
    )

/*++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    clear the perf stats.


Arguments:

    Context - Pointer to a the extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    PSERIALPERF_STATS   perf_stats;
    int                 port;

    perf_stats = &((PMOXA_DEVICE_EXTENSION)Context)->PerfStats;
    port = (int)(((PMOXA_DEVICE_EXTENSION)Context)->PortNo);
    MoxaTotalRx[port] += perf_stats->ReceivedCount;
    MoxaTotalTx[port] += perf_stats->TransmittedCount;
    RtlZeroMemory(
        perf_stats,
        sizeof(SERIALPERF_STATS)
        );
  
    return FALSE;

}

MoxaReadReg(
    IN PUCHAR   PortOfs,
    IN int      reg
    )
{
    USHORT      value;

    *(PUSHORT)(PortOfs + FuncArg) = (USHORT)reg;

    *(PortOfs + FuncCode) = FC_InUARTreg;
     MoxaWaitFinish(PortOfs);
    value = *(PUSHORT)(PortOfs + FuncArg1);
    return((int)value);
}

void
MoxaWriteReg(
    IN PUCHAR   PortOfs,
    IN int      reg,
    IN int      value
    )
{

    *(PUSHORT)(PortOfs + FuncArg1) = (USHORT)value;

    *(PUSHORT)(PortOfs + FuncArg) = (USHORT)reg;

    *(PortOfs + FuncCode) = FC_OutUARTreg;

    MoxaWaitFinish(PortOfs);

}

//
// Internal Ioctl
//


NTSTATUS
MoxaInternalIoControl(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This routine provides the initial processing for all of the
    internal Ioctrls for the serial device.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION pIrpStack;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

    //
    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    //
    KIRQL OldIrql;

    NTSTATUS prologueStatus;

    if (pDevExt->ControlDevice) {        // Control Device

        status = STATUS_CANCELLED;
        PIrp->IoStatus.Information = 0L;
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(
            PIrp,
            0
            );
        return status;
    }


    if ((prologueStatus = MoxaIRPPrologue(PIrp, pDevExt))
        != STATUS_SUCCESS) {
       MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
       return prologueStatus;
    }

    if (MoxaCompleteIfError(PDevObj, PIrp) != STATUS_SUCCESS) {
        return STATUS_CANCELLED;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
    PIrp->IoStatus.Information = 0L;
    status = STATUS_SUCCESS;

    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Send a wait-wake IRP
    //

    case IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE:
	 pDevExt->SendWaitWake = TRUE;
       status = STATUS_SUCCESS;
       break;

    case IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE:
	 pDevExt->SendWaitWake = FALSE;
       if (pDevExt->PendingWakeIrp != NULL) {
          IoCancelIrp(pDevExt->PendingWakeIrp);
       }

       status = STATUS_SUCCESS;
       break;


    //
    // Put the serial port in a "filter-driver" appropriate state
    //
    // WARNING: This code assumes it is being called by a trusted kernel
    // entity and no checking is done on the validity of the settings
    // passed to IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS
    //
    // If validity checking is desired, the regular ioctl's should be used
    //

    case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
    case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS: {
       SERIAL_BASIC_SETTINGS basic;
       PSERIAL_BASIC_SETTINGS pBasic;
       SHORT AppropriateDivisor;
       MOXA_IOCTL_SYNC S;

       if (pIrpStack->Parameters.DeviceIoControl.IoControlCode
           == IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS) {
          

          //
          // Check the buffer size
          //

          if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(SERIAL_BASIC_SETTINGS)) {
             status = STATUS_BUFFER_TOO_SMALL;
             break;
          }

          //
          // Everything is 0 -- timeouts and flow control.  If
          // We add additional features, this zero memory method
          // may not work.
          //

          RtlZeroMemory(&basic, sizeof(SERIAL_BASIC_SETTINGS));

          PIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
          pBasic = (PSERIAL_BASIC_SETTINGS)PIrp->AssociatedIrp.SystemBuffer;

          //
          // Save off the old settings
          //

          RtlCopyMemory(&pBasic->Timeouts, &pDevExt->Timeouts,
                        sizeof(SERIAL_TIMEOUTS));

          RtlCopyMemory(&pBasic->HandFlow, &pDevExt->HandFlow,
                        sizeof(SERIAL_HANDFLOW));
	    pBasic->RxFifo = pDevExt->RxFifoTrigger;
	    pBasic->TxFifo = pDevExt->TxFifoAmount;

          //
          // Point to our new settings
          //

          pBasic = &basic;
       } else { // restoring settings
          if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength
              < sizeof(SERIAL_BASIC_SETTINGS)) {
             status = STATUS_BUFFER_TOO_SMALL;
             break;
          }

          pBasic = (PSERIAL_BASIC_SETTINGS)PIrp->AssociatedIrp.SystemBuffer;
       }

       KeAcquireSpinLock(&pDevExt->ControlLock, &OldIrql);

       //
       // Set the timeouts
       //

       RtlCopyMemory(&pDevExt->Timeouts, &pBasic->Timeouts,
                     sizeof(SERIAL_TIMEOUTS));

       //
       // Set flowcontrol
       //
       
       S.Extension = pDevExt;
       S.Data = &pBasic->HandFlow;
       KeSynchronizeExecution(pDevExt->Interrupt, MoxaSetupNewHandFlow, &S);

      
       pDevExt->TxFifoAmount = (USHORT)pBasic->TxFifo;
       pDevExt->RxFifoTrigger = (USHORT)pBasic->RxFifo;

       MoxaFunc(pDevExt->PortOfs, FC_SetTxFIFOCnt,pDevExt->TxFifoAmount);
       MoxaFunc(pDevExt->PortOfs, FC_SetRxFIFOTrig,pDevExt->RxFifoTrigger);

  
       KeReleaseSpinLock(&pDevExt->ControlLock, OldIrql);


       break;
    }

    default:
       status = STATUS_INVALID_PARAMETER;
       break;

    }

    PIrp->IoStatus.Status = status;

    MoxaCompleteRequest(pDevExt, PIrp, 0);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\moxa.c ===
/*++

Module Name:

    moxa.c

Environment:

    Kernel mode

Revision History :

--*/
#include "precomp.h"

PMOXA_GLOBAL_DATA       MoxaGlobalData;

LONG    MoxaTxLowWater = WRITE_LOW_WATER;
BOOLEAN MoxaIRQok;
ULONG   MoxaLoopCnt;

UCHAR                   MoxaFlagBit[MAX_PORT];
ULONG                   MoxaTotalTx[MAX_PORT];
ULONG                   MoxaTotalRx[MAX_PORT];
PMOXA_DEVICE_EXTENSION  MoxaExtension[MAX_COM+1];

/************ USED BY MoxaStartWrite ***********/
    BOOLEAN     WRcompFlag;

/************ USED BY ImmediateChar ***********/
    PUCHAR  ICbase, ICofs, ICbuff;
    PUSHORT ICrptr, ICwptr;
    USHORT  ICtxMask, ICspage, ICepage, ICbufHead;
    USHORT  ICtail, IChead, ICcount;
    USHORT  ICpageNo, ICpageOfs;

/************ USED BY MoxaPutData **************/
    PUCHAR  PDbase, PDofs, PDbuff, PDwriteChar;
    PUSHORT PDrptr, PDwptr;
    USHORT  PDtxMask, PDspage, PDepage, PDbufHead;
    USHORT  PDtail, PDhead, PDcount, PDcount2;
    USHORT  PDcnt, PDlen, PDpageNo, PDpageOfs;
    ULONG   PDdataLen;

/************ USED BY MoxaGetData **************/
    PUCHAR  GDbase, GDofs, GDbuff, GDreadChar;
    PUSHORT GDrptr, GDwptr;
    USHORT  GDrxMask, GDspage, GDepage, GDbufHead;
    USHORT  GDtail, GDhead, GDcount, GDcount2;
    USHORT  GDcnt, GDlen, GDpageNo, GDpageOfs;
    ULONG   GDdataLen;

/************ USED BY MoxaIntervalReadTimeout ***/
    PUCHAR  IRTofs;
    PUSHORT IRTrptr, IRTwptr;
    USHORT  IRTrxMask;


/************ USED BY MoxaLineInput & MoxaView **********/
    UCHAR   LIterminater;
    ULONG   LIbufferSize, LIi;
    PUCHAR  LIdataBuffer;
    PUCHAR  LIbase, LIofs, LIbuff;
    PUSHORT LIrptr, LIwptr;
    USHORT  LIrxMask, LIspage, LIepage, LIbufHead;
    USHORT  LItail, LIhead, LIcount, LIcount2;
    USHORT  LIcnt, LIlen, LIpageNo, LIpageOfs;

/************ USED BY MoxaPutB **********/
    PUCHAR  PBbase, PBofs, PBbuff, PBwriteChar;
    PUSHORT PBrptr, PBwptr;
    USHORT  PBtxMask, PBspage, PBepage, PBbufHead;
    USHORT  PBtail, PBhead, PBcount, PBcount2;
    USHORT  PBcnt, PBpageNo, PBpageOfs;
    ULONG   PBdataLen;
 
const PHYSICAL_ADDRESS MoxaPhysicalZero = {0};
 


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.

    This routine will gather the configuration information,
    report resource usage, attempt to initialize all serial
    devices, connect to interrupts for ports.  If the above
    goes reasonably well it will fill in the dispatch points,
    reset the serial devices and then return to the system.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS if we could initialize a single device,
    otherwise STATUS_SERIAL_NO_DEVICE_INITED.

--*/

{

    NTSTATUS                    status;
    PDEVICE_OBJECT              currentDevice;
    UNICODE_STRING              deviceNameUnicodeString;
    UNICODE_STRING              deviceLinkUnicodeString;
    PMOXA_DEVICE_EXTENSION      extension;
    ULONG 				  i;
   
  

    MoxaGlobalData = ExAllocatePool(
                        NonPagedPool,
                        sizeof(MOXA_GLOBAL_DATA)
                        );
 
    if (!MoxaGlobalData) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
            MoxaGlobalData,
            sizeof(MOXA_GLOBAL_DATA)
            );

    MoxaGlobalData->DriverObject = DriverObject;

    MoxaGlobalData->RegistryPath.MaximumLength = RegistryPath->Length;
    MoxaGlobalData->RegistryPath.Length = RegistryPath->Length;
    MoxaGlobalData->RegistryPath.Buffer = ExAllocatePool(
                        PagedPool,
                        MoxaGlobalData->RegistryPath.MaximumLength
                        );
 
    if (!MoxaGlobalData->RegistryPath.Buffer) {
//	  MmUnlockPagableImageSection(lockPtr);
	  ExFreePool(MoxaGlobalData);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        MoxaGlobalData->RegistryPath.Buffer,
        MoxaGlobalData->RegistryPath.MaximumLength
        );

    RtlMoveMemory(MoxaGlobalData->RegistryPath.Buffer,
                 RegistryPath->Buffer, RegistryPath->Length);

 
    RtlInitUnicodeString (
                    &deviceNameUnicodeString,
                    CONTROL_DEVICE_NAME
                    );
    //
    // Create MXCTL device object
    //

    status = IoCreateDevice(
                DriverObject,
                sizeof(MOXA_DEVICE_EXTENSION),
                &deviceNameUnicodeString,
                FILE_DEVICE_SERIAL_PORT,
                0,
                TRUE,
                &currentDevice
                );

    if (!NT_SUCCESS(status)) {

 	  ExFreePool(MoxaGlobalData->RegistryPath.Buffer);
        ExFreePool(MoxaGlobalData);

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlInitUnicodeString (
                    &deviceLinkUnicodeString,
                    CONTROL_DEVICE_LINK
                    );

    IoCreateSymbolicLink (
                &deviceLinkUnicodeString,
                &deviceNameUnicodeString
                );

    extension = currentDevice->DeviceExtension;

    RtlZeroMemory(
            extension,
            sizeof(MOXA_DEVICE_EXTENSION)
            );

    extension->GlobalData = MoxaGlobalData;

    //
    //  This device is used for MOXA defined ioctl functions
    //
    extension->ControlDevice = TRUE;
 
    //
    // Initialize the Driver Object with driver's entry points
    //

    DriverObject->DriverUnload = MoxaUnload;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = MoxaFlush;
    DriverObject->MajorFunction[IRP_MJ_WRITE]  = MoxaWrite;
    DriverObject->MajorFunction[IRP_MJ_READ]   = MoxaRead;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = MoxaIoControl;
    DriverObject->MajorFunction[IRP_MJ_CREATE] =MoxaCreateOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = MoxaClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = MoxaCleanup;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] =
        MoxaQueryInformationFile;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] =
        MoxaSetInformationFile;

   DriverObject->MajorFunction[IRP_MJ_PNP]  = MoxaPnpDispatch;
 
   DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]
                     = MoxaInternalIoControl;
   
   DriverObject->MajorFunction[IRP_MJ_POWER]   = MoxaPowerDispatch;

   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]
     = MoxaSystemControlDispatch; 

   DriverObject->DriverExtension->AddDevice   = MoxaAddDevice;
//
// 9-03-01 by William
//
   MoxaLoop();

//
// 7-20-01 by William
//
   MoxaInitTimeOutProc();
    
   return STATUS_SUCCESS;
}

 

VOID
MoxaInitializeDevices(
    IN PDRIVER_OBJECT DriverObject,
    IN PMOXA_GLOBAL_DATA GlobalData
    )

/*++

Routine Description:

    This routine will set up names, creates the device, creates symbolic link.

Arguments:

    DriverObject - Just used to create the device object.

    GlobalData - Pointer to MOXA global data.

Return Value:

    None.

--*/

{
      
}

 

VOID
MoxaUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
 
     MoxaKdPrint(MX_DBG_TRACE,("Enter MoxaUnload\n"));
//
// 7-20-01 by William
//
     MoxaStopTimeOutProc();

     ExFreePool(MoxaGlobalData->RegistryPath.Buffer);
     ExFreePool(MoxaGlobalData);
 
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\mxdebug.h ===
/*++

Module Name:

    moxadebug.h

Environment:

    Kernel mode

Revision History :

--*/

#define MOXA_IOCTL          0x800
#define IOCTL_MOXA_GetSeg   CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+100, \
                                     METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOXA_RdData   CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+101, \
                                     METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOXA_WrData   CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+102, \
                                     METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOXA_FiData   CTL_CODE(FILE_DEVICE_SERIAL_PORT, MOXA_IOCTL+103, \
                                     METHOD_BUFFERED, FILE_ANY_ACCESS)

#define DWORD   ULONG

typedef struct mxset {
        DWORD   total_boards;
        DWORD   type[4];        /* 1 - C218, 2 - C3208 ..... */
        DWORD   segment[4];     /* value = C800, CC00, D000 ..... */
} MOXA_IOCTL_MxSet,*PMOXA_IOCTL_MxSet;

typedef struct blkhead {
        DWORD   data_seg;       /* C800, CC00 .... */
        DWORD   data_ofs;       /* 0000 - 3FFF */
        DWORD   data_len;       /* data length */
} MOXA_IOCTL_BlkHead,*PMOXA_IOCTL_BlkHead;

typedef struct wrdata {
        struct blkhead  datahead;
        char            data[1];        /* length = datahead.data_len */
} MOXA_IOCTL_WrData,*PMOXA_IOCTL_WrData;

typedef struct fidata {
        struct blkhead  datahead;
        char            fill_value;
} MOXA_IOCTL_FiData,*PMOXA_IOCTL_FiData;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\moxaext.h ===
/*++

Module Name:

    moxaext.h

Environment:

    Kernel mode

Revision History :

--*/



extern PMOXA_GLOBAL_DATA	MoxaGlobalData;
extern ULONG			MOXAPortsPerCard[MAX_TYPE];
extern ULONG			MoxaLoopCnt;
extern BOOLEAN			MoxaIRQok;
extern LONG			MoxaTxLowWater;

extern UCHAR			MoxaFlagBit[MAX_PORT];
extern ULONG			MoxaTotalTx[MAX_PORT];
extern ULONG			MoxaTotalRx[MAX_PORT];
extern PMOXA_DEVICE_EXTENSION	MoxaExtension[MAX_COM+1];

/************ USED BY MoxaStartWrite ***********/
extern BOOLEAN			WRcompFlag;

/************ USED BY ImmediateChar ***********/
extern PUCHAR			ICbase, ICofs, ICbuff;
extern PUSHORT			ICrptr, ICwptr;
extern USHORT			ICtxMask, ICspage, ICepage, ICbufHead;
extern USHORT			ICtail, IChead, ICcount;
extern USHORT			ICpageNo, ICpageOfs;

/************ USED BY MoxaPutData **************/
extern PUCHAR			PDbase, PDofs, PDbuff, PDwriteChar;
extern PUSHORT			PDrptr, PDwptr;
extern USHORT			PDtxMask, PDspage, PDepage, PDbufHead;
extern USHORT			PDtail, PDhead, PDcount, PDcount2;
extern USHORT			PDcnt, PDlen, PDpageNo, PDpageOfs;
extern ULONG			PDdataLen;

/************ USED BY MoxaGetData **************/
extern PUCHAR			GDbase, GDofs, GDbuff, GDreadChar;
extern PUSHORT			GDrptr, GDwptr;
extern USHORT			GDrxMask, GDspage, GDepage, GDbufHead;
extern USHORT			GDtail, GDhead, GDcount, GDcount2;
extern USHORT			GDcnt, GDlen, GDpageNo, GDpageOfs;
extern ULONG			GDdataLen;

/************ USED BY MoxaIntervalReadTimeout ***/
extern PUCHAR			IRTofs;
extern PUSHORT			IRTrptr, IRTwptr;
extern USHORT			IRTrxMask;


/************ USED BY MoxaLineInput & MoxaView **********/
extern UCHAR			LIterminater;
extern ULONG			LIbufferSize, LIi;
extern PUCHAR			LIdataBuffer;
extern PUCHAR			LIbase, LIofs, LIbuff;
extern PUSHORT			LIrptr, LIwptr;
extern USHORT			LIrxMask, LIspage, LIepage, LIbufHead;
extern USHORT			LItail, LIhead, LIcount, LIcount2;
extern USHORT			LIcnt, LIlen, LIpageNo, LIpageOfs;

/************ USED BY MoxaPutB **********/
extern PUCHAR			PBbase, PBofs, PBbuff, PBwriteChar;
extern PUSHORT			PBrptr, PBwptr;
extern USHORT			PBtxMask, PBspage, PBepage, PBbufHead;
extern USHORT			PBtail, PBhead, PBcount, PBcount2;
extern USHORT			PBcnt, PBpageNo, PBpageOfs;
extern ULONG			PBdataLen;

extern const PHYSICAL_ADDRESS MoxaPhysicalZero;
 
extern WMIGUIDREGINFO MoxaWmiGuidList[MOXA_WMI_GUID_LIST_SIZE];



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\moxadf.h ===
/*++

Module Name:

    moxadf.h

Environment:

    Kernel mode

Revision History :

--*/

typedef
NTSTATUS
(*PMOXA_START_ROUTINE) (
    IN PMOXA_DEVICE_EXTENSION
    );

typedef
VOID
(*PMOXA_GET_NEXT_ROUTINE) (
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PMOXA_DEVICE_EXTENSION extension
    );

//
//	main.c
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
MoxaGetConfigInfo(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PMOXA_GLOBAL_DATA GlobalData
    );

NTSTATUS
MoxaGetConfigInfo1(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    OUT PMOXA_GLOBAL_DATA GlobalData
    );
 
VOID
MoxaInitializeDevices(
    IN PDRIVER_OBJECT DriverObject,
    IN PMOXA_GLOBAL_DATA GlobalData
    );

VOID
MoxaDeleteDevices(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
MoxaReportResourcesDevice(
    IN PMOXA_GLOBAL_DATA GlobalData,
    OUT BOOLEAN *ConflictDetected
    );

VOID
MoxaUnReportResourcesDevice(
    IN PMOXA_GLOBAL_DATA GlobalData
    );

VOID
MoxaUnload(
    IN PDRIVER_OBJECT DriverObject
    );


//
//	openclos.c
//
NTSTATUS
MoxaGetPortPropertyFromRegistry(IN PMOXA_DEVICE_EXTENSION  extension);

NTSTATUS
MoxaCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MoxaReset(
    IN PMOXA_DEVICE_EXTENSION Extension
    );

NTSTATUS
MoxaClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

LARGE_INTEGER
MoxaGetCharTime(
    IN PMOXA_DEVICE_EXTENSION Extension
    );

NTSTATUS
MoxaCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
//	ioctl.c
//
NTSTATUS
MoxaIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
MoxaSetFuncCode(
    IN PVOID Context
    );

BOOLEAN
MoxaSetFuncArgu(
    IN PVOID Context
    );

BOOLEAN
MoxaSetFuncGetArgu(
    IN PVOID Context
    );

BOOLEAN
MoxaGetCommStatus(
    IN PVOID Context
    );

VOID
MoxaGetProperties(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN PSERIAL_COMMPROP Properties
    );

#if 0

BOOLEAN
MoxaClearDownLoad(
    IN PVOID Context
    );

#endif

 
VOID
InitPort(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN ULONG	RxBufSize,
    IN ULONG	TxBufSize,
    IN ULONG	MaxBauds
    );

BOOLEAN
MoxaGetStats(
    IN PVOID Context
    );

BOOLEAN
MoxaClearStats(
    IN PVOID Context
    );

//
//	utils.c
//
NTSTATUS
MoxaCompleteIfError(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MoxaDelay(
    IN ULONG	t
    );

VOID
MoxaFunc(
    IN PUCHAR	PortOfs,
    IN UCHAR	Command,
    IN USHORT	Argument
    );

VOID
MoxaFunc1(
    IN PUCHAR	PortOfs,
    IN UCHAR	Command,
    IN USHORT	Argument
    );


VOID
MoxaFuncWithLock(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN UCHAR	Command,
    IN USHORT	Argument
    );

VOID
MoxaFuncGetLineStatus(
    IN PUCHAR	PortOfs,
    IN PUSHORT	Argument
    );

VOID
MoxaFuncGetDataError(
    IN PUCHAR	PortOfs,
    IN PUSHORT	Argument
    );

VOID
MoxaLoop();

BOOLEAN
MoxaWaitFinish(
    IN PUCHAR	PortOfs
    );

BOOLEAN
MoxaWaitFinish1(
    IN PUCHAR	PortOfs
    );

BOOLEAN
MoxaDumbWaitFinish(
    IN PUCHAR	PortOfs
    );

VOID
MoxaFuncWithDumbWait(
    IN PUCHAR	PortOfs,
    IN UCHAR	Command,
    IN USHORT	Argument
    );


NTSTATUS
MoxaGetDivisorFromBaud(
    IN ULONG ClockType,
    IN LONG DesiredBaud,
    OUT PSHORT AppropriateDivisor
    );

NTSTATUS
MoxaStartOrQueue(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PMOXA_START_ROUTINE Starter
    );

VOID
MoxaCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
MoxaGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PMOXA_DEVICE_EXTENSION extension
    );

VOID
MoxaTryToCompleteCurrent(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PMOXA_START_ROUTINE Starter OPTIONAL,
    IN PMOXA_GET_NEXT_ROUTINE GetNextIrp OPTIONAL
    );

VOID
MoxaRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PMOXA_DEVICE_EXTENSION pDevExt
    );

VOID
MoxaKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
MoxaCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

USHORT
GetDeviceTxQueueWithLock(
    IN PMOXA_DEVICE_EXTENSION Extension
    );

USHORT
GetDeviceTxQueue(
    IN PMOXA_DEVICE_EXTENSION Extension
    );

USHORT
GetDeviceRxQueueWithLock(
    IN PMOXA_DEVICE_EXTENSION Extension
    );


VOID
MoxaUnlockPages(IN PKDPC PDpc, IN PVOID PDeferredContext,
                  IN PVOID PSysContext1, IN PVOID PSysContext2);

VOID
MoxaLoop();

//
//	qsfile.c
//
NTSTATUS
MoxaQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MoxaSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
//	modmflow.c
//
BOOLEAN
MoxaSetupNewHandFlow(
    IN     IN PVOID Context
    );

//
//	write.c
//

NTSTATUS
MoxaWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MoxaStartWrite(
    IN PMOXA_DEVICE_EXTENSION Extension
    );

BOOLEAN
MoxaPutB(
    IN PVOID Context
    );

BOOLEAN
MoxaOut(
    IN PVOID Context
    );

BOOLEAN
MoxaPutData (
    IN PMOXA_DEVICE_EXTENSION Extension
    );

VOID
MoxaGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PMOXA_DEVICE_EXTENSION Extension
    );

VOID
MoxaCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
MoxaGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
MoxaProcessEmptyTransmit(
    IN PVOID Context
    );

VOID
MoxaCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
MoxaWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );


//
//	read.c
//
NTSTATUS
MoxaRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MoxaStartRead(
    IN PMOXA_DEVICE_EXTENSION Extension
    );

BOOLEAN
MoxaLineInput(
    IN PVOID Context
    );

BOOLEAN
MoxaView(
    IN PVOID Context
    );

BOOLEAN
MoxaIn(
    IN PVOID Context
    );

VOID
MoxaGetData(
    IN PMOXA_DEVICE_EXTENSION	Extension
    );

BOOLEAN
MoxaInSwitchToUser(
    IN PVOID Context
    );

VOID
MoxaCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
MoxaGrabReadFromIsr(
    IN PVOID Context
    );

VOID
MoxaCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
MoxaReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
MoxaIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
MoxaCheckInQueue(
    IN PMOXA_DEVICE_EXTENSION	Extension
    );

BOOLEAN
MoxaPollGetData(
    IN PVOID Context
    );

//
//	flush.c
//
NTSTATUS
MoxaFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MoxaStartFlush(
    IN PMOXA_DEVICE_EXTENSION Extension
    );

//
//	waitmask.c
//
NTSTATUS
MoxaStartMask(
    IN PMOXA_DEVICE_EXTENSION Extension
    );

BOOLEAN
MoxaFinishOldWait(
    IN PVOID Context
    );

VOID
MoxaCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
MoxaGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
MoxaGiveWaitToIsr(
    IN PVOID Context
    );

VOID
MoxaCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

//
//	purge.c
//
NTSTATUS
MoxaStartPurge(
    IN PMOXA_DEVICE_EXTENSION Extension
    );


//
//	isr.c
//
BOOLEAN
MoxaISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

VOID
MoxaIsrIn(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
MoxaIsrGetData(
    IN PVOID Context
    );

VOID
MoxaIsrOut(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
MoxaIsrPutData(
    IN PVOID Context
    );

//
// 9-24-01 by William
//
#if 0
VOID
MoxaIntrLine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
MoxaIntrError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );
#endif
// end

//
//
//


VOID
MoxaConnectInterrupt(
    IN PDRIVER_OBJECT  ,
    IN PMOXA_GLOBAL_DATA
    );
 
USHORT
MoxaFindPCIBoards(
    IN PMOXA_Config
    );

NTSTATUS
MoxaGetBoardType(IN PDEVICE_OBJECT devObject,
    OUT PULONG boardType
    );

NTSTATUS
MoxaCreateDevObj(IN PDRIVER_OBJECT DriverObject,
	IN PUNICODE_STRING pDeviceObjName,
	IN PDEVICE_SETTINGS  pSettings,
      OUT PDEVICE_OBJECT *NewDeviceObject
	);

NTSTATUS
MoxaSyncCompletion(IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp,
      IN PKEVENT MoxaSyncEvent
	);

NTSTATUS
MoxaAddDevice(IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT PPdo
	);

#if 0
NTSTATUS
MoxaDoExternalNaming(IN PMOXA_DEVICE_EXTENSION PDevExt,
      IN PDRIVER_OBJECT PDrvObj
	);

NTSTATUS
MoxaGetPortInfo(IN PDEVICE_OBJECT PDevObj, 
      OUT PCONFIG_DATA PConfig,
      IN PSERIAL_USER_DATA PUserData
	);

NTSTATUS
MoxaStartDevice(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp
	);

NTSTATUS
MoxaFinishStartDevice(IN PDEVICE_OBJECT PDevObj,
      IN PCM_RESOURCE_LIST PResList,
      IN PCM_RESOURCE_LIST PTrResList,
      PSERIAL_USER_DATA PUserData
	);

VOID
MoxaUndoExternalNaming(IN PMOXA_DEVICE_EXTENSION Extension);
#endif

NTSTATUS
MoxaPnpDispatch(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp
	);

MOXA_MEM_COMPARES
MoxaMemCompare(
	IN PHYSICAL_ADDRESS A,
	IN ULONG SpanOfA,
	IN PHYSICAL_ADDRESS B,
	IN ULONG SpanOfB
	);

VOID
MoxaLogError(
	IN PDRIVER_OBJECT DriverObject,
      IN PDEVICE_OBJECT DeviceObject OPTIONAL,
      IN PHYSICAL_ADDRESS P1,
      IN PHYSICAL_ADDRESS P2,
      IN ULONG SequenceNumber,
      IN UCHAR MajorFunctionCode,
      IN UCHAR RetryCount,
      IN ULONG UniqueErrorValue,
      IN NTSTATUS FinalStatus,
      IN NTSTATUS SpecificIOStatus,
      IN ULONG LengthOfInsert1,
      IN PWCHAR Insert1,
      IN ULONG LengthOfInsert2,
      IN PWCHAR Insert2
      );

 
VOID
MoxaIRPEpilogue(IN PMOXA_DEVICE_EXTENSION PDevExt);

NTSTATUS
MoxaIRPPrologue(IN PIRP PIrp,
	IN PMOXA_DEVICE_EXTENSION PDevExt
	);

VOID
MoxaFilterCancelQueued(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp);

VOID
MoxaKillAllStalled(IN PDEVICE_OBJECT PDevObj);


NTSTATUS
MoxaFilterIrps(IN PIRP PIrp,
	IN PMOXA_DEVICE_EXTENSION PDevExt);


VOID
MoxaUnstallIrps(IN PMOXA_DEVICE_EXTENSION PDevExt);


VOID
MoxaSetDeviceFlags(IN PMOXA_DEVICE_EXTENSION PDevExt,
	OUT PULONG PFlags, 
      IN ULONG Value,
	IN BOOLEAN Set
	);

#define MoxaSetFlags(PDevExt, Value) \
   MoxaSetDeviceFlags((PDevExt), &(PDevExt)->Flags, (Value), TRUE)
#define MoxaClearFlags(PDevExt, Value) \
   MoxaSetDeviceFlags((PDevExt), &(PDevExt)->Flags, (Value), FALSE)
#define MoxaSetAccept(PDevExt, Value) \
   MoxaSetDeviceFlags((PDevExt), &(PDevExt)->DevicePNPAccept, (Value), TRUE)
#define MoxaClearAccept(PDevExt, Value) \
   MoxaSetDeviceFlags((PDevExt), &(PDevExt)->DevicePNPAccept, (Value), FALSE)

NTSTATUS
MoxaPoCallDriver(PMOXA_DEVICE_EXTENSION PDevExt,
	PDEVICE_OBJECT PDevObj,
      PIRP PIrp
	);

NTSTATUS
MoxaIoCallDriver(PMOXA_DEVICE_EXTENSION PDevExt,
	PDEVICE_OBJECT PDevObj,
      PIRP PIrp
	);


VOID
MoxaKillPendingIrps(PDEVICE_OBJECT PDevObj);

NTSTATUS
MoxaRemoveDevObj(IN PDEVICE_OBJECT PDevObj);

NTSTATUS
MoxaIoSyncIoctlEx(ULONG Ioctl,
	BOOLEAN Internal,
	PDEVICE_OBJECT PDevObj,
      PKEVENT PEvent,
	PIO_STATUS_BLOCK PIoStatusBlock,
      PVOID PInBuffer,
	ULONG InBufferLen,
	PVOID POutBuffer,                    // output buffer - optional
      ULONG OutBufferLen
	);

NTSTATUS
MoxaIoSyncReq(PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp,
	PKEVENT PEvent
	);

NTSTATUS
MoxaSystemPowerCompletion(IN PDEVICE_OBJECT PDevObj,
	UCHAR MinorFunction,
      IN POWER_STATE PowerState,
	IN PVOID Context,
      PIO_STATUS_BLOCK IoStatus
	);

VOID
MoxaSaveDeviceState(IN PMOXA_DEVICE_EXTENSION PDevExt);

VOID
MoxaRestoreDeviceState(IN PMOXA_DEVICE_EXTENSION PDevExt);

NTSTATUS
MoxaSetPowerD0(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp
	);

NTSTATUS
MoxaGotoPowerState(IN PDEVICE_OBJECT PDevObj,
      IN PMOXA_DEVICE_EXTENSION PDevExt,
      IN DEVICE_POWER_STATE DevPowerState
	);

NTSTATUS
MoxaSetPowerD3(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp
	);

NTSTATUS
MoxaSendWaitWake(PMOXA_DEVICE_EXTENSION PDevExt);

NTSTATUS
MoxaWakeCompletion(IN PDEVICE_OBJECT PDevObj,
	IN UCHAR MinorFunction,
      IN POWER_STATE PowerState,
	IN PVOID Context,
      IN PIO_STATUS_BLOCK IoStatus
	);

NTSTATUS
MoxaPowerDispatch(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp);

NTSTATUS
MoxaDoExternalNaming(IN PMOXA_DEVICE_EXTENSION PDevExt,
      IN PDRIVER_OBJECT PDrvObj);

VOID
MoxaUndoExternalNaming(IN PMOXA_DEVICE_EXTENSION Extension);

NTSTATUS
MoxaInternalIoControl(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp
	);

NTSTATUS
MoxaSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

NTSTATUS
MoxaTossWMIRequest(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp,
      IN ULONG GuidIndex
	);

NTSTATUS
MoxaSetWmiDataItem(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp,
      IN ULONG GuidIndex,
	IN ULONG InstanceIndex,
      IN ULONG DataItemId,
      IN ULONG BufferSize,
	IN PUCHAR PBuffer
	);

NTSTATUS
MoxaSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp,
      IN ULONG GuidIndex,
	IN ULONG InstanceIndex,
      IN ULONG BufferSize,
      IN PUCHAR PBuffer
	);

NTSTATUS
MoxaQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj,
	IN PIRP PIrp,
      IN ULONG GuidIndex, 
      IN ULONG InstanceIndex,
      IN ULONG InstanceCount,
      IN OUT PULONG InstanceLengthArray,
      IN ULONG OutBufferSize,
      OUT PUCHAR PBuffer
	);

NTSTATUS
MoxaQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj,
	OUT PULONG PRegFlags,
      OUT PUNICODE_STRING PInstanceName,
      OUT PUNICODE_STRING *PRegistryPath,
      OUT PUNICODE_STRING MofResourceName,
      OUT PDEVICE_OBJECT *Pdo
	);

BOOLEAN
MoxaInsertQueueDpc(IN PRKDPC PDpc,
	IN PVOID Sarg1,
	IN PVOID Sarg2,
      IN PMOXA_DEVICE_EXTENSION PDevExt
	);


BOOLEAN
MoxaSetTimer(IN PKTIMER Timer,
	IN LARGE_INTEGER DueTime,
      IN PKDPC Dpc OPTIONAL,
	IN PMOXA_DEVICE_EXTENSION PDevExt
	);

BOOLEAN
MoxaCancelTimer(IN PKTIMER Timer,
	IN PMOXA_DEVICE_EXTENSION PDevExt
	);

VOID
MoxaDpcEpilogue(IN PMOXA_DEVICE_EXTENSION PDevExt,
	PKDPC PDpc
	);

VOID
MoxaReleaseResources(IN PMOXA_DEVICE_EXTENSION pDevExt);

VOID
MoxaDisableInterfacesResources(IN PDEVICE_OBJECT PDevObj,
	BOOLEAN DisableUART);

BOOLEAN
MoxaCleanInterruptShareLists(IN PMOXA_DEVICE_EXTENSION pDevExt );

BOOLEAN
MoxaRemoveLists(IN PVOID Context);

//
// registry.c
//

NTSTATUS 
MoxaPutRegistryKeyValue(
	IN HANDLE Handle,
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength,
	IN ULONG Dtype,
      IN PVOID PData,
	IN ULONG DataLength
	);

NTSTATUS 
MoxaGetRegistryKeyValue (
	IN HANDLE Handle,
      IN PWCHAR KeyNameString,
      IN ULONG KeyNameStringLength,
      IN PVOID Data,
      IN ULONG DataLength,
      OUT PULONG ActualLength
	);
// 
// timer.c
//

void    MoxaInitTimeOutProc(void);
void    MoxaStopTimeOutProc(void);
BOOLEAN MoxaAddTimeOutProc(
        PMOXA_DEVICE_EXTENSION extension
);
BOOLEAN MoxaDelTimeOutProc(
        PMOXA_DEVICE_EXTENSION extension
);
ULONG   MoxaGetModemStatus(
        PMOXA_DEVICE_EXTENSION extension
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\power.c ===
/*++

Module Name:

    power.c

Abstract:

    This module contains the code that handles the power IRPs for the serial
    driver.


Environment:

    Kernel mode

Revision History :
  

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGEMX0, MoxaGotoPowerState)
//#pragma alloc_text(PAGEMX0, MoxaPowerDispatch)
//#pragma alloc_text(PAGEMX0, MoxaSetPowerD0)
//#pragma alloc_text(PAGEMX0, MoxaSetPowerD3)
//#pragma alloc_text(PAGEMX0, MoxaSaveDeviceState)
//#pragma alloc_text(PAGEMX0, MoxaRestoreDeviceState)
//#pragma alloc_text(PAGEMX0, MoxaSendWaitWake)
#endif // ALLOC_PRAGMA



NTSTATUS
MoxaSystemPowerCompletion(IN PDEVICE_OBJECT PDevObj, UCHAR MinorFunction,
                            IN POWER_STATE PowerState, IN PVOID Context,
                            PIO_STATUS_BLOCK IoStatus)
/*++

Routine Description:

    This routine is the completion routine for PoRequestPowerIrp calls
    in this module.

Arguments:

    PDevObj - Pointer to the device object the irp is completing for
    
    MinorFunction - IRP_MN_XXXX value requested
    
    PowerState - Power state request was made of
    
    Context - Event to set or NULL if no setting required
    
    IoStatus - Status block from request

Return Value:

    VOID


--*/
{
   if (Context != NULL) {
      KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, 0);
   }

   return STATUS_SUCCESS;
}




VOID
MoxaSaveDeviceState(IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine saves the device state of the UART

Arguments:

    PDevExt - Pointer to the device extension for the devobj to save the state
              for.

Return Value:

    VOID


--*/
{
	PMOXA_DEVICE_STATE pDevState = &PDevExt->DeviceState;
	KIRQL oldIrql;
   
 //  PAGED_CODE();

	MoxaKdPrint (MX_DBG_TRACE, ("Entering MoxaSaveDeviceState\n"));
         

      MoxaKillAllReadsOrWrites(
      	PDevExt->DeviceObject,
            &PDevExt->WriteQueue,
            &PDevExt->CurrentWriteIrp
            );

	MoxaKillAllReadsOrWrites(
            PDevExt->DeviceObject,
            &PDevExt->ReadQueue,
            &PDevExt->CurrentReadIrp
            );
 
      //
      // Clean out the Tx/Rx queue
      //
      KeAcquireSpinLock(
      	&PDevExt->ControlLock,
            &oldIrql
            );

      PDevExt->TotalCharsQueued = 0;

      MoxaFunc(                           // flush input/output queue
      	PDevExt->PortOfs,
            FC_FlushQueue,
            2
            );

      KeReleaseSpinLock(
      	&PDevExt->ControlLock,
            oldIrql
            );
    
	//
	// Read necessary registers direct
	//

	pDevState->HostState = *(PUSHORT)(PDevExt->PortOfs + HostStat);
    
	MoxaKdPrint (MX_DBG_TRACE, ("Leaving MoxaSaveDeviceState\n"));
}



VOID
MoxaRestoreDeviceState(IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine restores the device state of the UART

Arguments:

    PDevExt - Pointer to the device extension for the devobj to restore the
    state for.

Return Value:

    VOID


--*/
{
   PMOXA_DEVICE_STATE pDevState = &PDevExt->DeviceState;
   SHORT divisor;
   USHORT  max;


   
 //  PAGED_CODE();

   MoxaKdPrint (MX_DBG_TRACE, ("Enter MoxaRestoreDeviceState\n"));
   MoxaKdPrint (MX_DBG_TRACE, ("------  PDevExt: %x\n", PDevExt));

   if (PDevExt->DeviceState.Reopen == TRUE) {

       USHORT      arg,i;

       //MoxaFunc1(PDevExt->PortOfs, FC_ChannelReset, Magic_code);
       //
       // Restore Host Stat
       //

       *(PUSHORT)(PDevExt->PortOfs + HostStat) = pDevState->HostState;
       MoxaFunc1(PDevExt->PortOfs, FC_SetDataMode, PDevExt->DataMode);

       MoxaGetDivisorFromBaud(
                        PDevExt->ClockType,
                        PDevExt->CurrentBaud,
                        &divisor
                        );

       MoxaFunc1(PDevExt->PortOfs, FC_SetBaud, divisor);
          
       *(PUSHORT)(PDevExt->PortOfs+ Tx_trigger) = (USHORT)MoxaTxLowWater;
       MoxaFunc1(PDevExt->PortOfs, FC_SetTxFIFOCnt, PDevExt->TxFifoAmount);
       MoxaFunc1(PDevExt->PortOfs, FC_SetRxFIFOTrig,PDevExt->RxFifoTrigger);
           MoxaFunc1(PDevExt->PortOfs, FC_SetLineIrq,Magic_code);
       MoxaFunc1(PDevExt->PortOfs, FC_SetXoffLimit, (USHORT)PDevExt->HandFlow.XoffLimit);
       MoxaFunc1(PDevExt->PortOfs, FC_SetFlowRepl, (USHORT)PDevExt->HandFlow.FlowReplace);

       
	 arg = (MoxaFlagBit[PDevExt->PortNo] & 3); 
       MoxaFunc1(
                PDevExt->PortOfs,
                FC_LineControl,
                arg
                );
  
       for (i=0; i<sizeof(SERIAL_CHARS); i++)
            (PDevExt->PortOfs + FuncArg)[i] = ((PUCHAR)&PDevExt->SpecialChars)[i];
       *(PDevExt->PortOfs + FuncCode) = FC_SetChars;
       MoxaWaitFinish1(PDevExt->PortOfs);
    
       PDevExt->ModemStatus = *(PUSHORT)(PDevExt->PortOfs + FlagStat) >> 4;

  	 if (PDevExt->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE)
	    arg = CTS_FlowCtl;

	 if (PDevExt->HandFlow.FlowReplace & SERIAL_RTS_HANDSHAKE)
	    arg |= RTS_FlowCtl;

	 if (PDevExt->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
	    arg |= Tx_FlowCtl;

	 if (PDevExt->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
	    arg |= Rx_FlowCtl;

	 MoxaFunc1(PDevExt->PortOfs,FC_SetFlowCtl, arg);
       if (MoxaFlagBit[PDevExt->PortNo] & 4)
           MoxaFunc1(PDevExt->PortOfs,FC_SetXoffState,Magic_code);
       MoxaFunc1(PDevExt->PortOfs, FC_EnableCH, Magic_code);


       if (PDevExt->NumberNeededForRead) 
 		MoxaKdPrint (MX_DBG_TRACE, ("NumberNeededForRead=%d\n",PDevExt->NumberNeededForRead));

    	 PDevExt->DeviceState.Reopen = FALSE;

   }
   MoxaKdPrint (MX_DBG_TRACE, ("Exit restore\n"));

}



NTSTATUS
MoxaPowerDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_POWER major code (power IRPs).

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{

   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   PDEVICE_OBJECT pPdo = pDevExt->Pdo;
   BOOLEAN acceptingIRPs;

 //  PAGED_CODE();
   if (pDevExt->ControlDevice) {        // Control Device

    	  PoStartNextPowerIrp(PIrp);
        status = STATUS_CANCELLED;
        PIrp->IoStatus.Information = 0L;
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(
            PIrp,
            0
            );
        return status;
   }


   if ((status = MoxaIRPPrologue(PIrp, pDevExt)) != STATUS_SUCCESS) {
      PoStartNextPowerIrp(PIrp);
      MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

  
   switch (pIrpStack->MinorFunction) {

   case IRP_MN_WAIT_WAKE:
      MoxaKdPrint (MX_DBG_TRACE, ("Got IRP_MN_WAIT_WAKE Irp\n"));
      break;


   case IRP_MN_POWER_SEQUENCE:
      MoxaKdPrint (MX_DBG_TRACE, ("Got IRP_MN_POWER_SEQUENCE Irp\n"));
      break;


   case IRP_MN_SET_POWER:
      MoxaKdPrint (MX_DBG_TRACE,("Got IRP_MN_SET_POWER Irp\n"));

      //
      // Perform different ops if it was system or device
      //

      switch (pIrpStack->Parameters.Power.Type) {
      case SystemPowerState: {
            POWER_STATE powerState;

            //
            // They asked for a system power state change
            //

            MoxaKdPrint (MX_DBG_TRACE, ("------: SystemPowerState\n"));

            //
            // We will only service this if we are policy owner -- we
            // don't need to lock on this value since we only service
            // one power request at a time.
            //

            if (pDevExt->OwnsPowerPolicy != TRUE) {
               status = STATUS_SUCCESS;
               goto PowerExit;
            }


            switch (pIrpStack->Parameters.Power.State.SystemState) {
            case PowerSystemUnspecified:
               powerState.DeviceState = PowerDeviceUnspecified;
               break;

            case PowerSystemWorking:
               powerState.DeviceState = PowerDeviceD0;
               break;

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
            case PowerSystemMaximum:
               powerState.DeviceState = PowerDeviceD3;
               break;

            default:
               status = STATUS_SUCCESS;
               goto PowerExit;
               break;
            }


            PoSetPowerState(PDevObj, pIrpStack->Parameters.Power.Type,
                            pIrpStack->Parameters.Power.State);

            //
            // Send IRP to change device state
            //

            PoRequestPowerIrp(pPdo, IRP_MN_SET_POWER, powerState, NULL, NULL,
                              NULL);

            goto PowerExit;
         }

      case DevicePowerState:
         MoxaKdPrint (MX_DBG_TRACE, ("------: DevicePowerState\n"));
         break;

      default:
         MoxaKdPrint (MX_DBG_TRACE, ("------: UNKNOWN PowerState\n"));
         goto PowerExit;
      }


      //
      // If we are already in the requested state, just pass the IRP down
      //

      if (pDevExt->PowerState
          == pIrpStack->Parameters.Power.State.DeviceState) {
         MoxaKdPrint (MX_DBG_TRACE, ("Already in requested power state\n")
                    );

         break;
      }


      switch (pIrpStack->Parameters.Power.State.DeviceState) {

      case PowerDeviceD0:
         MoxaKdPrint (MX_DBG_TRACE,("Going to power state D0\n"));
         return MoxaSetPowerD0(PDevObj, PIrp);

      case PowerDeviceD1:  
      case PowerDeviceD2: 
      case PowerDeviceD3:
         MoxaKdPrint (MX_DBG_TRACE,("Going to power state D3\n"));
         return MoxaSetPowerD3(PDevObj, PIrp);

      default:
         break;
      }
      break;



   case IRP_MN_QUERY_POWER:

      MoxaKdPrint (MX_DBG_TRACE,("Got IRP_MN_QUERY_POWER Irp\n"));

      //
      // Check if we have a wait-wake pending and if so,
      // ensure we don't power down too far.
      //

      if (pDevExt->PendingWakeIrp != NULL) {
         if (pIrpStack->Parameters.Power.Type == SystemPowerState
             && pIrpStack->Parameters.Power.State.SystemState
             > pDevExt->SystemWake) {
            status = PIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            PoStartNextPowerIrp(PIrp);
            MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;
         }
      }

      //
      // If no wait-wake, always successful
      //

      PIrp->IoStatus.Status = STATUS_SUCCESS;
      PoStartNextPowerIrp(PIrp);
      IoSkipCurrentIrpStackLocation(PIrp);
      return MoxaPoCallDriver(pDevExt, pLowerDevObj, PIrp);

   }   // switch (pIrpStack->MinorFunction)


   PowerExit:;

   PoStartNextPowerIrp(PIrp);


   //
   // Pass to the lower driver
   //
   IoSkipCurrentIrpStackLocation(PIrp);
   status = MoxaPoCallDriver(pDevExt, pLowerDevObj, PIrp);

   return status;
}






NTSTATUS
MoxaSetPowerD0(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This routine Decides if we need to pass the power Irp down the stack
    or not.  It then either sets up a completion handler to finish the 
    initialization or calls the completion handler directly.

Arguments:

    PDevObj - Pointer to the devobj we are changing power state on

    PIrp - Pointer to the IRP for the current request

Return Value:

    Return status of either PoCallDriver of the call to the initialization
    routine.


--*/

{
   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status;
   ULONG	boardReady = 0;
   KEVENT	event;
   IO_STATUS_BLOCK IoStatusBlock;

  // PAGED_CODE();

   MoxaKdPrint (MX_DBG_TRACE, ("In MoxaSetPowerD0\n"));
   MoxaKdPrint (MX_DBG_TRACE, ("SetPowerD0 has IRP %x\n", PIrp));

//   ASSERT(pDevExt->LowerDeviceObject);

   //
   // Set up completion to init device when it is on
   //

   KeClearEvent(&pDevExt->PowerD0Event);


   IoCopyCurrentIrpStackLocationToNext(PIrp);
   IoSetCompletionRoutine(PIrp, MoxaSyncCompletion, &pDevExt->PowerD0Event,
                          TRUE, TRUE, TRUE);

   MoxaKdPrint (MX_DBG_TRACE, ("Calling next driver\n"));

   status = PoCallDriver(pDevExt->LowerDeviceObject, PIrp);

   if (status == STATUS_PENDING) {
      MoxaKdPrint (MX_DBG_TRACE, ("Waiting for next driver\n"));
      KeWaitForSingleObject (&pDevExt->PowerD0Event, Executive, KernelMode,
                             FALSE, NULL);
   } else {
      if (!NT_SUCCESS(status)) {
         PIrp->IoStatus.Status = status;
         PoStartNextPowerIrp(PIrp);
         MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
         return status;
      }
   }

   if (!NT_SUCCESS(PIrp->IoStatus.Status)) {
      PoStartNextPowerIrp(PIrp);
      MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return PIrp->IoStatus.Status;
   }

   KeInitializeEvent(&event, NotificationEvent, FALSE);
   
   MoxaKdPrint(MX_DBG_TRACE,("Get board ready ...\n"));

   status = MoxaIoSyncIoctlEx(IOCTL_MOXA_INTERNAL_BOARD_READY, TRUE,
                                  pDevExt->LowerDeviceObject, &event, &IoStatusBlock,
                                  NULL, 0, &boardReady,
                                  sizeof(boardReady));
   MoxaKdPrint(MX_DBG_TRACE,("status=%x,boardReady=%x\n",status,boardReady));

   if (NT_SUCCESS(status) && boardReady) {
	
   	//
   	// Restore the device
   	//

    	//
   	// Theoretically we could change states in the middle of processing
   	// the restore which would result in a bad PKINTERRUPT being used
   	// in MoxaRestoreDeviceState().
   	//

   	if (pDevExt->PNPState == SERIAL_PNP_STARTED) {
      	MoxaRestoreDeviceState(pDevExt);
   	}
 	pDevExt->PowerState = PowerDeviceD0;
	MoxaGlobalData->BoardReady[pDevExt->BoardNo] = TRUE;
   }
   else
	MoxaGlobalData->BoardReady[pDevExt->BoardNo] = FALSE;

 
   //
   // Now that we are powered up, call PoSetPowerState
   //

   PoSetPowerState(PDevObj, pIrpStack->Parameters.Power.Type,
                  pIrpStack->Parameters.Power.State);

   PoStartNextPowerIrp(PIrp);
   MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);


   MoxaKdPrint (MX_DBG_TRACE,("Leaving MoxaSetPowerD0\n"));
   return STATUS_SUCCESS;
}



NTSTATUS
MoxaGotoPowerState(IN PDEVICE_OBJECT PDevObj,
                     IN PMOXA_DEVICE_EXTENSION PDevExt,
                     IN DEVICE_POWER_STATE DevPowerState)
/*++

Routine Description:

    This routine causes the driver to request the stack go to a particular
    power state.

Arguments:

    PDevObj - Pointer to the device object for this device
    
    PDevExt - Pointer to the device extension we are working from

    DevPowerState - the power state we wish to go to

Return Value:

    The function value is the final status of the call


--*/
{
   KEVENT gotoPowEvent;
   NTSTATUS status;
   POWER_STATE powerState;

 //  PAGED_CODE();

   MoxaKdPrint (MX_DBG_TRACE,("In MoxaGotoPowerState\n"));

   powerState.DeviceState = DevPowerState;

   KeInitializeEvent(&gotoPowEvent, SynchronizationEvent, FALSE);

   status = PoRequestPowerIrp(PDevObj, IRP_MN_SET_POWER, powerState,
                              MoxaSystemPowerCompletion, &gotoPowEvent,
                              NULL);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&gotoPowEvent, Executive, KernelMode, FALSE, NULL);
      status = STATUS_SUCCESS;
   }

#if DBG
   if (!NT_SUCCESS(status)) {
      MoxaKdPrint (MX_DBG_TRACE,("MoxaGotoPowerState FAILED\n"));
   }
#endif

   MoxaKdPrint (MX_DBG_TRACE,("Leaving MoxaGotoPowerState\n"));

   return status;
}





NTSTATUS
MoxaSetPowerD3(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This routine handles the SET_POWER minor function. 

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

//   PAGED_CODE();

   MoxaKdPrint (MX_DBG_TRACE,("In MoxaSetPowerD3\n"));    

   //
   // Before we power down, call PoSetPowerState
   //

   PoSetPowerState(PDevObj, pIrpStack->Parameters.Power.Type,
                   pIrpStack->Parameters.Power.State);

   pDevExt->PowerState = PowerDeviceD3;
   //
   // If the device is not closed, disable interrupts and allow the fifo's
   // to flush.
   //

   if (pDevExt->DeviceIsOpened == TRUE) {
      LARGE_INTEGER charTime;

      pDevExt->DeviceState.Reopen = TRUE;

      //
      // Save the device state
      // 
      MoxaSaveDeviceState(pDevExt);
      MoxaFunc1(pDevExt->PortOfs, FC_DisableCH, Magic_code);
    
      MoxaKdPrint (MX_DBG_TRACE,("Port Disabled\n"));    

   }

   //
   // If the device is not open, we don't need to save the state;
   // we can just reset the device on power-up
   //


   PIrp->IoStatus.Status = STATUS_SUCCESS;

   

   //
   // For what we are doing, we don't need a completion routine
   // since we don't race on the power requests.
   //

   PIrp->IoStatus.Status = STATUS_SUCCESS;

   PoStartNextPowerIrp(PIrp);
   IoSkipCurrentIrpStackLocation(PIrp);

   return MoxaPoCallDriver(pDevExt, pDevExt->LowerDeviceObject, PIrp);
}



NTSTATUS
MoxaSendWaitWake(PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine causes a waitwake IRP to be sent

Arguments:

    PDevExt - Pointer to the device extension for this device

Return Value:

    STATUS_INVALID_DEVICE_STATE if one is already pending, else result
    of call to PoRequestPowerIrp.


--*/
{
   NTSTATUS status;
   PIRP pIrp;
   POWER_STATE powerState;
   
  // PAGED_CODE();

   //
   // Make sure one isn't pending already -- serial will only handle one at
   // a time.
   //

   if (PDevExt->PendingWakeIrp != NULL) {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Make sure we are capable of waking the machine
   //

   if (PDevExt->SystemWake <= PowerSystemWorking) {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Send IRP to request wait wake and add a pending irp flag
   //
   //

   InterlockedIncrement(&PDevExt->PendingIRPCnt);

   powerState.SystemState = PDevExt->SystemWake;

   status = PoRequestPowerIrp(PDevExt->Pdo, IRP_MN_WAIT_WAKE,
                              powerState, MoxaWakeCompletion, PDevExt, &pIrp);

   if (status == STATUS_PENDING) {
         status = STATUS_SUCCESS;
         PDevExt->PendingWakeIrp = pIrp;
   } else if (!NT_SUCCESS(status)) {
      MoxaIRPEpilogue(PDevExt);
   }

   return status;
}

NTSTATUS
MoxaWakeCompletion(IN PDEVICE_OBJECT PDevObj, IN UCHAR MinorFunction,
                     IN POWER_STATE PowerState, IN PVOID Context,
                     IN PIO_STATUS_BLOCK IoStatus)
/*++

Routine Description:

    This routine handles completion of the waitwake IRP. 

Arguments:

    PDevObj - Pointer to the device object for this device
    
    MinorFunction - Minor function previously supplied to PoRequestPowerIrp

    PowerState - PowerState previously supplied to PoRequestPowerIrp
    
    Context - a pointer to the device extension
    
    IoStatus - current/final status of the waitwake IRP

Return Value:

    The function value is the final status of attempting to process the
    waitwake.


--*/
{
   NTSTATUS status;
   PMOXA_DEVICE_EXTENSION pDevExt = (PMOXA_DEVICE_EXTENSION)Context;
   POWER_STATE powerState;

   status = IoStatus->Status;

   if (NT_SUCCESS(status)) {
      NTSTATUS tmpStatus;
      PIRP pIrp;
      PKEVENT pEvent;

      //
      // A wakeup has occurred -- powerup our stack
      //

      powerState.DeviceState = PowerDeviceD0;

      pEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

      if (pEvent == NULL) {
         status = STATUS_INSUFFICIENT_RESOURCES;
         goto ErrorExitWakeCompletion;
      }

      KeInitializeEvent(pEvent, SynchronizationEvent, FALSE);

      tmpStatus = PoRequestPowerIrp(pDevExt->Pdo, IRP_MN_SET_POWER, powerState,
                                    MoxaSystemPowerCompletion, pEvent,
                                    NULL);

      if (tmpStatus == STATUS_PENDING) {
         KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, NULL);
         tmpStatus = STATUS_SUCCESS;
      }

      ExFreePool(pEvent);

      if (!NT_SUCCESS(tmpStatus)) {
         status = tmpStatus;
         goto ErrorExitWakeCompletion;
      }

      //
      // Send another WaitWake Irp
      //

      powerState.SystemState = pDevExt->SystemWake;

      tmpStatus = PoRequestPowerIrp(pDevExt->Pdo, IRP_MN_WAIT_WAKE,
                                    powerState, MoxaWakeCompletion,
                                    pDevExt, &pIrp);

      if (tmpStatus == STATUS_PENDING) {
         pDevExt->PendingWakeIrp = pIrp;
         goto ExitWakeCompletion;
      }

      status = tmpStatus;
   }

ErrorExitWakeCompletion:;
   pDevExt->PendingWakeIrp = NULL;
   MoxaIRPEpilogue(pDevExt);

ExitWakeCompletion:;
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\openclos.c ===
/*++

Module Name:

    openclos.c

Environment:

    Kernel mode

Revision History :

--*/


#include "precomp.h"


NTSTATUS
MoxaGetPortPropertyFromRegistry(IN PMOXA_DEVICE_EXTENSION extension)
{

      NTSTATUS            status;
      HANDLE		  keyHandle;
	ULONG			  data=0,dataLen;

	extension->RxFifoTrigger = 3;   // for 550C UART
      extension->TxFifoAmount = 16;  // for 550C UART
      extension->PortFlag = 0;

      status = IoOpenDeviceRegistryKey(extension->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_READ, &keyHandle);

      if (!NT_SUCCESS(status)) {
         //
         // This is a fatal error.  If we can't get to our registry key,
         // we are sunk.
         //
  	   return (status);
        
      }
	
      status = MoxaGetRegistryKeyValue(
                keyHandle, 
                L"DisableFiFo",
                sizeof(L"DisableFiFo"),
                &data,
                sizeof(ULONG),
		    &dataLen);
      
      if (NT_SUCCESS(status)) {
	 	if (data) {
        		extension->RxFifoTrigger = 0;
        		extension->TxFifoAmount = 1;
    		}
   
	}
      MoxaKdPrint(MX_DBG_TRACE, 
                          ("TxFifoSize/RxFifoTrig=%x/%x\n", extension->TxFifoAmount ,extension->RxFifoTrigger ));
	    
      status = MoxaGetRegistryKeyValue(
                keyHandle, 
                L"TxMode",
                sizeof(L"TxMode"),
                &data,
                sizeof(ULONG),
		    &dataLen);

	
      if (NT_SUCCESS(status) && data )
       	extension->PortFlag = NORMAL_TX_MODE;
	
      	MoxaKdPrint(MX_DBG_TRACE, 
                          ("TxMode=%x/%x\n", extension->PortFlag ,status));

	ZwClose(keyHandle);

	return (status);
 
}


NTSTATUS
MoxaCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    NTSTATUS	status;

    MoxaKdPrint(MX_DBG_TRACE,("MoxaCreateOpen\n"));
    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options &
        FILE_DIRECTORY_FILE) {

        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );
        MoxaKdPrint(MX_DBG_TRACE,("Is a directory,open failed\n"));
        return STATUS_NOT_A_DIRECTORY;

    }

    if (extension->ControlDevice) {
        extension->ErrorWord = 0;
	  extension->DeviceIsOpened = TRUE;
        Irp->IoStatus.Status = STATUS_SUCCESS;

        Irp->IoStatus.Information = 0;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );

        return STATUS_SUCCESS;
    }


    if (!extension->PortExist) {

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

        Irp->IoStatus.Information = 0;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );
        MoxaKdPrint(MX_DBG_TRACE,("No such device,open failed\n"));
        return STATUS_NO_SUCH_DEVICE;

    }


    if (extension->PNPState != SERIAL_PNP_STARTED) {
       Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       MoxaKdPrint(MX_DBG_TRACE,("Device is not started,open failed\n"));
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Lock out changes to PnP state until we have our open state decided
    //

    ExAcquireFastMutex(&extension->OpenMutex);

    if ((status = MoxaIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       ExReleaseFastMutex(&extension->OpenMutex);
       MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       MoxaKdPrint(MX_DBG_TRACE,("MoxaIRPPrologue status=%x,open failed\n",status));
       return status;
    }

    if (InterlockedIncrement(&extension->OpenCount) != 1) {
       ExReleaseFastMutex(&extension->OpenMutex);
       InterlockedDecrement(&extension->OpenCount);
       Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
       MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       MoxaKdPrint(MX_DBG_TRACE,("Open count greater than 1,open failed\n",status));
       return STATUS_ACCESS_DENIED;
    }


    //
    // Ok, it looks like we really are going to open.  Lock down the
    // driver.
    //
    //    MoxaLockPagableSectionByHandle(MoxaGlobalsData->PAGESER_Handle);

    //
    // Retreive the properties of port
    //
    MoxaGetPortPropertyFromRegistry(extension);

    //
    // Power up the stack
    //

//    (void)MoxaGotoPowerState(DeviceObject, extension, PowerDeviceD0);
    if ((extension->PowerState != PowerDeviceD0)||
	  (MoxaGlobalData->BoardReady[extension->BoardNo] == FALSE)) {
       MoxaKdPrint(MX_DBG_TRACE,("Board is not ready,open failed\n"));
	 ExReleaseFastMutex(&extension->OpenMutex);
       InterlockedDecrement(&extension->OpenCount);
       Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
       MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_ACCESS_DENIED;
    }

    MoxaKdPrint(MX_DBG_TRACE,("Device Opened,TxFiFo=%d,RxFiFo=%d,PortFlag=%x\n",
                 extension->TxFifoAmount,extension->RxFifoTrigger,extension->PortFlag));


    //
    // Not currently waiting for wake up
    //

    extension->SendWaitWake = FALSE;


    extension->HandFlow.XoffLimit = extension->RxBufferSize >> 3;
    extension->HandFlow.XonLimit = extension->RxBufferSize >> 1;

    extension->BufferSizePt8 = ((3*(extension->RxBufferSize>>2))+
                                   (extension->RxBufferSize>>4));

    extension->WriteLength = 0;
    extension->ReadLength = 0;

    extension->TotalCharsQueued = 0;

    extension->IrpMaskLocation = NULL;
    extension->HistoryMask = 0;
    extension->IsrWaitMask = 0;

    extension->WmiCommData.XoffXmitThreshold = extension->HandFlow.XoffLimit;
    extension->WmiCommData.XonXmitThreshold = extension->HandFlow.XonLimit;


    //
    // Clear out the statistics.
    //

    KeSynchronizeExecution(
        extension->Interrupt,
        MoxaClearStats,
        extension
        );

    extension->EscapeChar = 0;
    extension->ErrorWord = 0;

    MoxaReset(extension);

 
    MoxaFuncWithLock(extension, FC_SetTxFIFOCnt, extension->TxFifoAmount);
    MoxaFuncWithLock(extension, FC_SetRxFIFOTrig,extension->RxFifoTrigger);

    MoxaFuncWithLock(extension, FC_EnableCH, Magic_code);
 
/* 6-1-1998 by William */
/* 4-26-99 by William */
    MoxaFuncWithLock(extension, FC_SetLineIrq,Magic_code);
 
/* 5-31-1998 by William
    MoxaFuncWithLock(extension, FC_GetAll, 0);
    extension->ModemStatus = *(PUSHORT)(extension->PortOfs + FuncArg + 2);
*/
    extension->ModemStatus = *(PUSHORT)(extension->PortOfs + FlagStat) >> 4;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;

    extension->DeviceIsOpened = TRUE;
    //
    // Mark the device as busy for WMI
    //
    extension->WmiCommData.IsBusy = TRUE;

    //
    // 7-20-01 by William
    //
    MoxaAddTimeOutProc(extension);

    ExReleaseFastMutex(&extension->OpenMutex);


    MoxaCompleteRequest(
	  extension,
        Irp,
        IO_NO_INCREMENT
        );

    return STATUS_SUCCESS;

}

VOID
MoxaReset(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{
    SHORT divisor;
    PUCHAR  ofs;
    MOXA_IOCTL_SYNC S;

    ofs = Extension->PortOfs;

    MoxaKdPrint (MX_DBG_TRACE, ("Enter MoxaReset\n"));
    MoxaFuncWithLock(Extension, FC_ChannelReset, Magic_code);
    MoxaFuncWithLock(Extension, FC_SetDataMode, Extension->DataMode);
    MoxaGetDivisorFromBaud(
                        Extension->ClockType,
                        Extension->CurrentBaud,
                        &divisor
                        );

    MoxaFuncWithLock(Extension, FC_SetBaud, divisor);
    S.Extension = Extension;
    S.Data = &Extension->HandFlow;

    MoxaSetupNewHandFlow(
                    &S
                    );
    *(PUSHORT)(ofs + Tx_trigger) = (USHORT)MoxaTxLowWater;
}


NTSTATUS
MoxaClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    LARGE_INTEGER allSentDelay;
    LARGE_INTEGER charTime;
    PUCHAR  ofs;
    LONG    count,count1;
    ULONG	openCount,pendingDPCs;
    NTSTATUS	status;


//    MoxaKdPrint(MX_DBG_TRACE,("%ws,Closing ...\n",extension->DosName));

    if (extension->ControlDevice) {
        MoxaKdPrint(MX_DBG_TRACE,("Control Device Closed\n"));
        Irp->IoStatus.Status = STATUS_SUCCESS;

        Irp->IoStatus.Information=0L;
	  extension->DeviceIsOpened = FALSE;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );

        return STATUS_SUCCESS;
    }

    //
    // Grab a mutex
    //

    ExAcquireFastMutex(&extension->CloseMutex);
 

    //
    // We succeed a close on a removing device
    //

    //
    // 7-20-01 by William
    //
    MoxaDelTimeOutProc(extension);

    if ((status = MoxaIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       MoxaKdPrint (MX_DBG_ERROR,("Close prologue failed for: %x\n",Irp));
       if (status == STATUS_DELETE_PENDING) {
           status = Irp->IoStatus.Status = STATUS_SUCCESS;
       }

       MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       openCount = InterlockedDecrement(&extension->OpenCount);
  //     ASSERT(openCount == 0);
       ExReleaseFastMutex(&extension->CloseMutex);
       return status;
    }


    //ASSERT(extension->OpenCount == 1);

    if (extension->OpenCount != 1) {
       MoxaKdPrint (MX_DBG_ERROR,("Close open count bad for: 0x%x\n",Irp));
       MoxaKdPrint (MX_DBG_ERROR,("------: Count: %x  Addr: 0x%x\n",
                              extension->OpenCount, &extension->OpenCount));
       ExReleaseFastMutex(&extension->CloseMutex);
       Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
       MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_INVALID_DEVICE_REQUEST;
    }


    charTime = RtlLargeIntegerNegate(MoxaGetCharTime(extension));

    extension->DeviceIsOpened = FALSE;
    //
    // Mark device as not busy for WMI
    //
    extension->WmiCommData.IsBusy = FALSE;


    ofs = extension->PortOfs;

    if (extension->SendBreak) {
        MoxaFuncWithLock(extension, FC_StopBreak, Magic_code);
        extension->SendBreak = FALSE;
    }

    if (*(ofs + FlagStat) & Rx_xoff)
        MoxaFuncWithLock(extension, FC_SendXon, 0);

/* 7-21-99 by William
    count = GetDeviceTxQueueWithLock(extension);
    count += extension->TotalCharsQueued;

    //
    //  Wait data all sent
    //

    count += 10;

    allSentDelay = RtlExtendedIntegerMultiply(
                       charTime,
                       count
                       );

    KeDelayExecutionThread(
        KernelMode,
        TRUE,
        &allSentDelay
        );
*/


    //
    //  Wait data all sent
    //

    count1 = 0;
    while (TRUE) {

    	  count = GetDeviceTxQueueWithLock(extension);
        	  count += extension->TotalCharsQueued;
	  
	  if (count == count1)
		break;
	  else
		count1 = count;
  
                  allSentDelay = RtlExtendedIntegerMultiply(
                   	charTime,
                       	count + 10
                       	);

                  KeDelayExecutionThread(
        		KernelMode,
        		TRUE,
        		&allSentDelay
        		);
    }



    MoxaFuncWithLock(extension, FC_SetFlowCtl, 0);
    MoxaFuncWithLock(extension, FC_DTRcontrol, 0);    /* clear DTR */
    MoxaFuncWithLock(extension, FC_RTScontrol, 0);    /* clear RTS */
    MoxaFuncWithLock(extension, FC_ClrLineIrq, Magic_code);
    MoxaFlagBit[extension->PortNo] &= 0xFC;

    *(PUSHORT)(ofs + HostStat) = 0;

    MoxaFuncWithLock(extension, FC_DisableCH, Magic_code);
    //
    // Stop waiting for wakeup
    //

    extension->SendWaitWake = FALSE;

    if (extension->PendingWakeIrp != NULL) {
       IoCancelIrp(extension->PendingWakeIrp);
    }


    //
    // Power down our device stack
    //
//    (void)MoxaGotoPowerState(DeviceObject, extension, PowerDeviceD3);

    Irp->IoStatus.Status = STATUS_SUCCESS;

    Irp->IoStatus.Information=0L;

    
    MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
    //
    // Unlock the pages.  If this is the last reference to the section
    // then the driver code will be flushed out.
    //

    //
    // First, we have to let the DPC's drain.  No more should be queued
    // since we aren't taking interrupts now....
    //

    pendingDPCs = InterlockedDecrement(&extension->DpcCount);
    if (pendingDPCs) {
	 MoxaKdPrint(MX_DBG_TRACE,("DpcCount = %d\n",extension->DpcCount));
       MoxaKdPrint(MX_DBG_TRACE,("Drainging DPC's: %x\n",Irp));
       KeWaitForSingleObject(&extension->PendingDpcEvent, Executive,
                             KernelMode, FALSE, NULL);
    }


    //
    // Pages must be locked to release the mutex, so don't unlock
    // them until after we release the mutex
    //
    ExReleaseFastMutex(&extension->CloseMutex);

    //
    // Reset for next open
    //
    InterlockedIncrement(&extension->DpcCount);

    openCount = InterlockedDecrement(&extension->OpenCount);

    //ASSERT(openCount == 0);
//    MoxaKdPrint(MX_DBG_TRACE,("%ws,close completed.\n",extension->DosName));
  
 //   MoxaUnlockPagableImageSection(MoxaGlobalsData->PAGESER_Handle);
    return STATUS_SUCCESS;
}

LARGE_INTEGER
MoxaGetCharTime(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{

    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;


    if ((Extension->DataMode & MOXA_DATA_MASK)
                == MOXA_5_DATA) {
        dataSize = 5;
    } else if ((Extension->DataMode & MOXA_DATA_MASK)
                == MOXA_6_DATA) {
        dataSize = 6;
    } else if ((Extension->DataMode & MOXA_DATA_MASK)
                == MOXA_7_DATA) {
        dataSize = 7;
    } else if ((Extension->DataMode & MOXA_DATA_MASK)
                == MOXA_8_DATA) {
        dataSize = 8;
    } else {
	  dataSize = 8;
    }

    paritySize = 1;
    if ((Extension->DataMode & MOXA_PARITY_MASK)
            == MOXA_NONE_PARITY) {

        paritySize = 0;

    }

    if (Extension->DataMode & MOXA_STOP_MASK) {

        //
        // Even if it is 1.5, for sanities sake were going
        // to say 2.
        //

        stopSize = 2;

    } else {

        stopSize = 1;

    }

    //
    // First we calculate the number of 100 nanosecond intervals
    // are in a single bit time (Approximately).
    //

    bitTime = (10000000+(Extension->CurrentBaud-1))/Extension->CurrentBaud;
    charTime = bitTime + ((dataSize+paritySize+stopSize)*bitTime);

    return RtlConvertUlongToLargeInteger(charTime);

}

NTSTATUS
MoxaCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    KIRQL oldIrql;
    NTSTATUS	status;

    if ((!extension->ControlDevice)&&(extension->DeviceIsOpened == TRUE)) {

       //
       // We succeed a cleanup on a removing device
       //

    	 if ((status = MoxaIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       	if (status == STATUS_DELETE_PENDING) {
       		status = Irp->IoStatus.Status = STATUS_SUCCESS;
       	}
       	MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
        	return status;
        } 

        //
        // First kill all the reads and writes.
        //

        MoxaKillAllReadsOrWrites(
            DeviceObject,
            &extension->WriteQueue,
            &extension->CurrentWriteIrp
            );

        MoxaKillAllReadsOrWrites(
            DeviceObject,
            &extension->ReadQueue,
            &extension->CurrentReadIrp
            );

        //
        // Next get rid of purges.
        //

        MoxaKillAllReadsOrWrites(
            DeviceObject,
            &extension->PurgeQueue,
            &extension->CurrentPurgeIrp
            );

        //
        // Get rid of any mask operations.
        //

        MoxaKillAllReadsOrWrites(
            DeviceObject,
            &extension->MaskQueue,
            &extension->CurrentMaskIrp
            );

        //
        // Now get rid a pending wait mask irp.
        //

        IoAcquireCancelSpinLock(&oldIrql);

        if (extension->CurrentWaitIrp) {

            PDRIVER_CANCEL cancelRoutine;

            cancelRoutine = extension->CurrentWaitIrp->CancelRoutine;
            extension->CurrentWaitIrp->Cancel = TRUE;

            if (cancelRoutine) {

                extension->CurrentWaitIrp->CancelIrql = oldIrql;
                extension->CurrentWaitIrp->CancelRoutine = NULL;

                cancelRoutine(
                    DeviceObject,
                    extension->CurrentWaitIrp
                    );

	      }
/* 8-30-01 by William */
	 	else
            	IoReleaseCancelSpinLock(oldIrql); 


        }
        else

            IoReleaseCancelSpinLock(oldIrql); 

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information=0L;
        MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
	
    }
    else {
	 Irp->IoStatus.Status = STATUS_SUCCESS;
    	 Irp->IoStatus.Information=0L;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
   
    }
    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\mxlog.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Abstract:

    Constant definitions for the I/O error code log values.

--*/

#ifndef _MXLOG_
#define _MXLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SERIAL_KERNEL_DEBUGGER_ACTIVE
//
// MessageText:
//
//  The kernel debugger is already using %2.
//
#define SERIAL_KERNEL_DEBUGGER_ACTIVE    ((NTSTATUS)0x40060001L)

//
// MessageId: SERIAL_FIFO_PRESENT
//
// MessageText:
//
//  While validating that %2 was really a serial port.
//
#define SERIAL_FIFO_PRESENT              ((NTSTATUS)0x40060002L)

//
// MessageId: SERIAL_USER_OVERRIDE
//
// MessageText:
//
//  User configuration data for parameter %2 overriding firmware configuration data.
//
#define SERIAL_USER_OVERRIDE             ((NTSTATUS)0x40060003L)

//
// MessageId: SERIAL_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %2.
//
#define SERIAL_NO_SYMLINK_CREATED        ((NTSTATUS)0x80060004L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_CREATED     ((NTSTATUS)0x80060005L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_DELETED
//
// MessageText:
//
//  Unable to delete the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_DELETED     ((NTSTATUS)0x80060006L)

//
// MessageId: SERIAL_UNREPORTED_IRQL_CONFLICT
//
// MessageText:
//
//  Another driver on the system, which did not report its resources, has already claimed the interrupt used by %2.
//
#define SERIAL_UNREPORTED_IRQL_CONFLICT  ((NTSTATUS)0xC0060007L)

//
// MessageId: SERIAL_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough resources were available for the driver.
//
#define SERIAL_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0060008L)

//
// MessageId: SERIAL_UNSUPPORTED_CLOCK_RATE
//
// MessageText:
//
//  The baud clock rate configuration is not supported on device %2.
//
#define SERIAL_UNSUPPORTED_CLOCK_RATE    ((NTSTATUS)0xC0060009L)

//
// MessageId: SERIAL_REGISTERS_NOT_MAPPED
//
// MessageText:
//
//  The hardware locations for %2 could not be translated to something the memory management system could understand.
//
#define SERIAL_REGISTERS_NOT_MAPPED      ((NTSTATUS)0xC006000AL)

//
// MessageId: SERIAL_RESOURCE_CONFLICT
//
// MessageText:
//
//  The hardware resources for %2 are already in use by another device.
//
#define SERIAL_RESOURCE_CONFLICT         ((NTSTATUS)0xC006000BL)

//
// MessageId: SERIAL_NO_BUFFER_ALLOCATED
//
// MessageText:
//
//  No memory could be allocated in which to place new data for %2.
//
#define SERIAL_NO_BUFFER_ALLOCATED       ((NTSTATUS)0xC006000CL)

//
// MessageId: SERIAL_IER_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the interrupt enable register contained enabled bits in a must be zero bitfield.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_IER_INVALID               ((NTSTATUS)0xC006000DL)

//
// MessageId: SERIAL_MCR_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the modem control register contained enabled bits in a must be zero bitfield.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_MCR_INVALID               ((NTSTATUS)0xC006000EL)

//
// MessageId: SERIAL_IIR_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the interrupt id register contained enabled bits in a must be zero bitfield.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_IIR_INVALID               ((NTSTATUS)0xC006000FL)

//
// MessageId: SERIAL_DL_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the baud rate register could not be set consistantly.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_DL_INVALID                ((NTSTATUS)0xC0060010L)

//
// MessageId: SERIAL_NOT_ENOUGH_CONFIG_INFO
//
// MessageText:
//
//  Some firmware configuration information was incomplete.
//
#define SERIAL_NOT_ENOUGH_CONFIG_INFO    ((NTSTATUS)0xC0060011L)

//
// MessageId: SERIAL_NO_PARAMETERS_INFO
//
// MessageText:
//
//  No Parameters subkey was found for user defined data.  This is odd, and it also means no user configuration can be found.
//
#define SERIAL_NO_PARAMETERS_INFO        ((NTSTATUS)0xC0060012L)

//
// MessageId: SERIAL_UNABLE_TO_ACCESS_CONFIG
//
// MessageText:
//
//  Specific user configuration data is unretrievable.
//
#define SERIAL_UNABLE_TO_ACCESS_CONFIG   ((NTSTATUS)0xC0060013L)

//
// MessageId: SERIAL_INVALID_PORT_INDEX
//
// MessageText:
//
//  On parameter %2 which indicates a multiport card, must have a port index specified greater than 0.
//
#define SERIAL_INVALID_PORT_INDEX        ((NTSTATUS)0xC0060014L)

//
// MessageId: SERIAL_PORT_INDEX_TOO_HIGH
//
// MessageText:
//
//  On parameter %2 which indicates a multiport card, the port index for the multiport card is too large.
//
#define SERIAL_PORT_INDEX_TOO_HIGH       ((NTSTATUS)0xC0060015L)

//
// MessageId: SERIAL_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type for %2 is not recognizable.
//
#define SERIAL_UNKNOWN_BUS               ((NTSTATUS)0xC0060016L)

//
// MessageId: SERIAL_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type for %2 is not available on this computer.
//
#define SERIAL_BUS_NOT_PRESENT           ((NTSTATUS)0xC0060017L)

//
// MessageId: SERIAL_BUS_INTERRUPT_CONFLICT
//
// MessageText:
//
//  The bus specified for %2 does not support the specified method of interrupt.
//
#define SERIAL_BUS_INTERRUPT_CONFLICT    ((NTSTATUS)0xC0060018L)

//
// MessageId: SERIAL_INVALID_USER_CONFIG
//
// MessageText:
//
//  Can not find any configured MOXA Smartio/Industio  series board.
//
#define SERIAL_INVALID_USER_CONFIG       ((NTSTATUS)0xC0060019L)

//
// MessageId: SERIAL_DEVICE_TOO_HIGH
//
// MessageText:
//
//  The user specified port for %2 is way too high in physical memory.
//
#define SERIAL_DEVICE_TOO_HIGH           ((NTSTATUS)0xC006001AL)

//
// MessageId: SERIAL_STATUS_TOO_HIGH
//
// MessageText:
//
//  The status port for %2 is way too high in physical memory.
//
#define SERIAL_STATUS_TOO_HIGH           ((NTSTATUS)0xC006001BL)

//
// MessageId: SERIAL_STATUS_CONTROL_CONFLICT
//
// MessageText:
//
//  The status port for %2 overlaps the control registers for the device.
//
#define SERIAL_STATUS_CONTROL_CONFLICT   ((NTSTATUS)0xC006001CL)

//
// MessageId: SERIAL_CONTROL_OVERLAP
//
// MessageText:
//
//  The control registers for %2 overlaps with the %3 control registers.
//
#define SERIAL_CONTROL_OVERLAP           ((NTSTATUS)0xC006001DL)

//
// MessageId: SERIAL_STATUS_OVERLAP
//
// MessageText:
//
//  The status register for %2 overlaps the %3 control registers.
//
#define SERIAL_STATUS_OVERLAP            ((NTSTATUS)0xC006001EL)

//
// MessageId: SERIAL_STATUS_STATUS_OVERLAP
//
// MessageText:
//
//  The status register for %2 overlaps with the %3 status register.
//
#define SERIAL_STATUS_STATUS_OVERLAP     ((NTSTATUS)0xC006001FL)

//
// MessageId: SERIAL_CONTROL_STATUS_OVERLAP
//
// MessageText:
//
//  The control registers for %2 overlaps the %3 status register.
//
#define SERIAL_CONTROL_STATUS_OVERLAP    ((NTSTATUS)0xC0060020L)

//
// MessageId: SERIAL_MULTI_INTERRUPT_CONFLICT
//
// MessageText:
//
//  Two ports, %2 and %3, on a single multiport card can't have two different interrupts.
//
#define SERIAL_MULTI_INTERRUPT_CONFLICT  ((NTSTATUS)0xC0060021L)

//
// MessageId: SERIAL_DISABLED_PORT
//
// MessageText:
//
//  Disabling %2 as requested by the configuration data.
//
#define SERIAL_DISABLED_PORT             ((NTSTATUS)0x40060022L)

//
// MessageId: SERIAL_GARBLED_PARAMETER
//
// MessageText:
//
//  Parameter %2 data is unretrievable from the registry.
//
#define SERIAL_GARBLED_PARAMETER         ((NTSTATUS)0xC0060023L)

//
// MessageId: SERIAL_DLAB_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the contents of the divisor latch register was identical to the interrupt enable and the recieve registers.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_DLAB_INVALID              ((NTSTATUS)0xC0060024L)

//
// MessageId: SERIAL_INVALID_MOXA_BOARDS
//
// MessageText:
//
//  Can not find any MOXA Smartio/Industio  series board.
//
#define SERIAL_INVALID_MOXA_BOARDS       ((NTSTATUS)0xC0060025L)

//
// MessageId: SERIAL_INVALID_COM_NUMBER
//
// MessageText:
//
//  The COM number(COM %2) of the %3  board conflicts with others.
//
#define SERIAL_INVALID_COM_NUMBER        ((NTSTATUS)0xC0060026L)

//
// MessageId: SERIAL_PORT_FOUND
//
// MessageText:
//
//  Serial  port %2, has been enabled.
//
#define SERIAL_PORT_FOUND                ((NTSTATUS)0x40060027L)

//
// MessageId: SERIAL_INVALID_IRQ_NUMBER
//
// MessageText:
//
//  %2, with first serial  port %3, IRQ number is invalid.
//
#define SERIAL_INVALID_IRQ_NUMBER        ((NTSTATUS)0xC0060028L)

//
// MessageId: SERIAL_INVALID_ASIC_BOARD
//
// MessageText:
//
//  Can not find the configured %2  board (CAP=%3)!
//
#define SERIAL_INVALID_ASIC_BOARD        ((NTSTATUS)0xC0060029L)

#endif /* _MXLOG_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\purge.c ===
/*++
 
Module Name:

    purge.c

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
MoxaStartPurge(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{

    PIRP newIrp;


   
    do {

        ULONG mask;

        mask = *((ULONG *)
                 (Extension->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));

        if (mask & SERIAL_PURGE_TXABORT) {

            KIRQL oldIrql;

            MoxaKillAllReadsOrWrites(
                Extension->DeviceObject,
                &Extension->WriteQueue,
                &Extension->CurrentWriteIrp
                );

            //
            // Clean out the Tx queue
            //
            KeAcquireSpinLock(
                &Extension->ControlLock,
                &oldIrql
                );

            Extension->TotalCharsQueued = 0;

            MoxaFunc(                           // flush output queue
                Extension->PortOfs,
                FC_FlushQueue,
                1
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                oldIrql
                );
        }

        if (mask & SERIAL_PURGE_RXABORT) {

            MoxaKillAllReadsOrWrites(
                Extension->DeviceObject,
                &Extension->ReadQueue,
                &Extension->CurrentReadIrp
                );
        }

        if (mask & SERIAL_PURGE_TXCLEAR) {

            KIRQL oldIrql;

            //
            // Clean out the Tx queue
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &oldIrql
                );


            MoxaFunc(                           // flush output queue
                Extension->PortOfs,
                FC_FlushQueue,
                1
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                oldIrql
                );

        }

        if (mask & SERIAL_PURGE_RXCLEAR) {

            KIRQL oldIrql;

            //
            // Clean out the Rx queue
            //
            // Note that we do this under protection of the
            // the drivers control lock so that we don't hose
            // the pointers if there is currently a read that
            // is reading out of the buffer.
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &oldIrql
                );


            MoxaFunc(                           // flush input queue
                Extension->PortOfs,
                FC_FlushQueue,
                0
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                oldIrql
                );

        }

        Extension->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
        Extension->CurrentPurgeIrp->IoStatus.Information = 0;

        MoxaGetNextIrp(
            &Extension->CurrentPurgeIrp,
            &Extension->PurgeQueue,
            &newIrp,
            TRUE,
		Extension
            );

    } while (newIrp);

    return STATUS_SUCCESS;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\pnp.c ===
/*++

Module Name:

    Pnp.c

Abstract:

    This module contains the code that handles the plug and play
    IRPs for the serial driver.


Environment:

    Kernel mode

--*/

#include "precomp.h"


#if 0 
#ifdef ALLOC_PRAGMA
 
#pragma alloc_text(PAGEMX0, MoxaCreateDevObj)
#pragma alloc_text(PAGEMX0, MoxaAddDevice)
#pragma alloc_text(PAGEMX0, MoxaPnpDispatch)
#pragma alloc_text(PAGEMX0, MoxaStartDevice)
#pragma alloc_text(PAGEMX0, MoxaFinishStartDevice)
#pragma alloc_text(PAGEMX0, MoxaGetPortInfo)
#pragma alloc_text(PAGEMX0, MoxaDoExternalNaming)
#pragma alloc_text(PAGEMX0, MoxaUndoExternalNaming)
#endif // ALLOC_PRAGMA

#endif

//
// Instantiate the GUID
//

#if !defined(FAR)
#define FAR
#endif // !defined(FAR)

#include <initguid.h>

DEFINE_GUID(GUID_CLASS_COMPORT, 0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08,
            0x00, 0x3e, 0x30, 0x1f, 0x73);


#if DBG

UCHAR *SerSystemCapString[] = {
   "PowerSystemUnspecified",
   "PowerSystemWorking",
   "PowerSystemSleeping1",
   "PowerSystemSleeping2",
   "PowerSystemSleeping3",
   "PowerSystemHibernate",
   "PowerSystemShutdown",
   "PowerSystemMaximum"
};

UCHAR *SerDeviceCapString[] = {
   "PowerDeviceUnspecified",
   "PowerDeviceD0",
   "PowerDeviceD1",
   "PowerDeviceD2",
   "PowerDeviceD3",
   "PowerDeviceMaximum"
};

#endif // DBG



NTSTATUS
MoxaSyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                     IN PKEVENT MoxaSyncEvent)
{

   KeSetEvent(MoxaSyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
MoxaCreateDevObj(IN PDRIVER_OBJECT DriverObject,
			 IN PUNICODE_STRING pDeviceObjName,
			 IN PDEVICE_SETTINGS  pSettings,
                   OUT PDEVICE_OBJECT *NewDeviceObject)

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Serial controller PDO.

Arguments:

    DriverObject - a pointer to the driver object this is created under
    NewDeviceObject - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    
   PDEVICE_OBJECT deviceObject = NULL;
   PMOXA_DEVICE_EXTENSION pDevExt = NULL;
   NTSTATUS status = STATUS_SUCCESS;
   HANDLE	pnpKey;
   ULONG	maxBaud,rxBufferSize,txBufferSize;

 //  PAGED_CODE ();
 
   MoxaKdPrint(MX_DBG_TRACE,("Enter MoxaCreateDevObj\n")); 
 
   if (pDeviceObjName == NULL) {
      MoxaLogError(DriverObject, NULL, MoxaPhysicalZero, MoxaPhysicalZero,
                     0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                     0, NULL, 0, NULL);
	MoxaKdPrint(MX_DBG_ERROR,("MoxaCreateDevice: Couldn't allocate memory for device name\n"));
      return STATUS_SUCCESS;

   }
 
   //
   // Create the device object
   //
   MoxaKdPrint(MX_DBG_TRACE,("Create the device object\n")); 

   status = IoCreateDevice(DriverObject, sizeof(MOXA_DEVICE_EXTENSION),
                           pDeviceObjName, FILE_DEVICE_SERIAL_PORT, 0, TRUE,
                           &deviceObject);
   

   if (!NT_SUCCESS(status)) {
      MoxaKdPrint(MX_DBG_ERROR,("MoxaAddDevice: Create device failed - %x \n",
                             status));
      goto MoxaCreateDevObjError;    
   }

   //ASSERT(deviceObject != NULL);


   //
   // The device object has a pointer to an area of non-paged
   // pool allocated for this device.  This will be the device
   // extension. Zero it out.
   //

   pDevExt = deviceObject->DeviceExtension;
   RtlZeroMemory(pDevExt, sizeof(MOXA_DEVICE_EXTENSION));
   

   //
   // Allocate Pool and save the nt device name in the device extension.
   //

   MoxaKdPrint(MX_DBG_TRACE,("Allocate Pool and save the nt device name in the device extension\n")); 
   pDevExt->DeviceName.Buffer =
      ExAllocatePool(PagedPool, pDeviceObjName->Length + sizeof(WCHAR));

   if (!pDevExt->DeviceName.Buffer) {

      MoxaLogError(
                    DriverObject,
                    NULL,
                    MoxaPhysicalZero,
                    MoxaPhysicalZero,
                    0,
                    0,
                    0,
                    19,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      MoxaKdPrint(MX_DBG_ERROR,
                ("MoxaAddDevice: Couldn't allocate memory for DeviceName\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto MoxaCreateDevObjError;
   } 

   pDevExt->DeviceName.MaximumLength = pDeviceObjName->Length
      + sizeof(WCHAR);

   //
   // Zero fill it.
   //

   RtlZeroMemory(pDevExt->DeviceName.Buffer,
                 pDevExt->DeviceName.MaximumLength);

   RtlAppendUnicodeStringToString(&pDevExt->DeviceName, pDeviceObjName);

   
   //
   // Set up the device extension.
   //

   MoxaKdPrint(MX_DBG_TRACE,("Set up the device extension\n")); 
   
   pDevExt->PortBase = pSettings->BaseAddress;
   pDevExt->PortOfs = pSettings->BaseAddress + Extern_table + Extern_size * pSettings->PortIndex;

   pDevExt->DeviceObject   = deviceObject;
   pDevExt->DriverObject   = DriverObject;
   
   switch (pSettings->BoardType) {
   case C218ISA :
   case C218PCI :
   case CP204J :
		maxBaud = 921600L;
		rxBufferSize = C218rx_size;
		txBufferSize = C218tx_size;
		break;
   default :
		maxBaud = 460800L;
		switch (pSettings->NumPorts) {
		case 8 :
			rxBufferSize = C320p8rx_size;
			txBufferSize = C320p8tx_size;
			break;
		case 16 :
			rxBufferSize = C320p16rx_size;
			txBufferSize = C320p16tx_size;
			break;
		case 24 :
			rxBufferSize = C320p24rx_size;
			txBufferSize = C320p24tx_size;
			break;
		case 32 :
			rxBufferSize = C320p32rx_size;
			txBufferSize = C320p32tx_size;
			break;
		}
	
		break;
   }
   MoxaKdPrint(MX_DBG_TRACE,("Init port,%d,%d,%d\n",rxBufferSize,txBufferSize,maxBaud)); 
   InitPort(pDevExt,rxBufferSize ,txBufferSize ,maxBaud);

   deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
   *NewDeviceObject = deviceObject;

   MoxaKdPrint(MX_DBG_TRACE,("Leave MoxaCreateDevObj\n") );
   return STATUS_SUCCESS;


   MoxaCreateDevObjError:

   MoxaKdPrint(MX_DBG_ERROR,("MoxaCreateDevObj Error, Cleaning up\n") );

   //
   // Free the allocated strings for the NT and symbolic names if they exist.
   //
  
   if (pDevExt) {
      if (pDevExt->DeviceName.Buffer != NULL) {
         ExFreePool(pDevExt->DeviceName.Buffer);
      }
   }
   if (deviceObject) {
      IoDeleteDevice(deviceObject);
   }


   *NewDeviceObject = NULL;

   MoxaKdPrint(MX_DBG_TRACE,("Leave MoxaCreateDevObj\n") );

   return status;
}

NTSTATUS
MoxaAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PPdo)

/*++

Routine Description:

    This routine creates a functional device object for com ports in the
    system and attaches them to the physical device objects for the ports


Arguments:

    DriverObject - a pointer to the object for this driver
    
    PPdo - a pointer to the PDO in the stack we need to attach to

Return Value:

    status from device creation and initialization

--*/

{
   PDEVICE_OBJECT pNewDevObj = NULL;
   PDEVICE_OBJECT pLowerDevObj = NULL;
   NTSTATUS status;
   PMOXA_DEVICE_EXTENSION pDevExt;
   HANDLE	keyHandle;
   UNICODE_STRING	deviceObjName;
   DEVICE_SETTINGS	settings;
   IO_STATUS_BLOCK IoStatusBlock;
   KEVENT event;
   ULONG	comNo,i;
   WCHAR 	comName[8];


  
   //PAGED_CODE();

   MoxaKdPrint(MX_DBG_TRACE,("Enter MoxaAddDevice with PPdo 0x%x\n", PPdo));
 
   if (PPdo == NULL) {
      //
      // Return no more devices
      //

      MoxaKdPrint(MX_DBG_TRACE,("NO_MORE_ENTRIES\n"));

      return (STATUS_NO_MORE_ENTRIES);
   }

   KeInitializeEvent(&event, NotificationEvent, FALSE);

   MoxaKdPrint(MX_DBG_TRACE,("MoxaIoSyncIoctlEx\n"));

   status = MoxaIoSyncIoctlEx(IOCTL_MOXA_INTERNAL_BASIC_SETTINGS, TRUE,
                                  PPdo, &event, &IoStatusBlock,
                                  NULL, 0, &settings,
                                  sizeof(DEVICE_SETTINGS));
   MoxaKdPrint(MX_DBG_TRACE,("status=%x\n",status));

   if (!NT_SUCCESS(status)) {
	MoxaKdPrint (MX_DBG_TRACE,("Get settings Fail\n"));
    	status = STATUS_UNSUCCESSFUL;
	return(status);
   }


   status = IoOpenDeviceRegistryKey(PPdo, PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_READ, &keyHandle);
   if (!NT_SUCCESS(status)) {
         //
         // This is a fatal error.  If we can't get to our registry key,
         // we are sunk.
         //
         MoxaKdPrint (MX_DBG_TRACE,
                          ("IoOpenDeviceRegistryKey failed - %x\n", status));
	   return (status);
        
    }
	
    status = MoxaGetRegistryKeyValue(
                keyHandle, 
                L"PortName",
                sizeof(L"PortName"),
                comName,
                sizeof(comName),
		    &i);

   ZwClose(keyHandle);
   if (status == STATUS_SUCCESS) {

      comName[i >>1] = (WCHAR )0;

   	MoxaKdPrint (MX_DBG_TRACE,("Get settings OK\n"));
	MoxaKdPrint (MX_DBG_TRACE,("BoardIndex = %x\n",settings.BoardIndex));
	MoxaKdPrint (MX_DBG_TRACE,("PortIndex = %x\n",settings.PortIndex));
	MoxaKdPrint (MX_DBG_TRACE,("InterfaceType = %x\n",settings.InterfaceType));
	MoxaKdPrint (MX_DBG_TRACE,("BusNumber = %x\n",settings.BusNumber));

      MoxaKdPrint (MX_DBG_TRACE,("OriginalBaseAddress = %x\n",settings.OriginalBaseAddress.LowPart));
	MoxaKdPrint (MX_DBG_TRACE,("OriginalAckPort = %x\n",settings.OriginalAckPort.LowPart));
	MoxaKdPrint (MX_DBG_TRACE,("BaseAddress = %x\n",settings.BaseAddress));
	MoxaKdPrint (MX_DBG_TRACE,("AckPort = %x\n",settings.AckPort));
	MoxaKdPrint (MX_DBG_TRACE,("InterruptVector = %x\n",settings.Interrupt.Vector));
	MoxaKdPrint (MX_DBG_TRACE,("InterruptLevel = %x\n",settings.Interrupt.Level));
	MoxaKdPrint (MX_DBG_TRACE,("InterruptAffinity = %x\n",settings.Interrupt.Affinity));

//	MoxaKdPrint (MX_DBG_TRACE,("ComName = %ws\n",comName));
	

   }
   else {
	MoxaKdPrint (MX_DBG_TRACE,("Get settings Fail\n"));
    	status = STATUS_UNSUCCESSFUL;
	return(status);
   }

   //
   // Zero out allocated memory pointers so we know if they must be freed
   //
   
   deviceObjName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR)
                                   + sizeof(WCHAR);

   deviceObjName.Buffer = ExAllocatePool(PagedPool,deviceObjName.MaximumLength);
   if (deviceObjName.Buffer == NULL) {
	 MoxaKdPrint(MX_DBG_ERROR,("Unable to allocate buffer for device object name\n"));
       status = STATUS_INSUFFICIENT_RESOURCES;
       return (status);
   }

  
   RtlZeroMemory(deviceObjName.Buffer,deviceObjName.MaximumLength);
   deviceObjName.Length = 0;
   
   RtlAppendUnicodeToString(&deviceObjName, L"\\Device\\MxcardB00P000");

   deviceObjName.Buffer[15] = (WCHAR)('0' + settings.BoardIndex / 10);
   deviceObjName.Buffer[16] = (WCHAR)('0' + settings.BoardIndex % 10);
   deviceObjName.Buffer[18] = (WCHAR)('0' + settings.PortIndex / 100);
   deviceObjName.Buffer[19] = (WCHAR)('0' + (settings.PortIndex % 100)/10);
   deviceObjName.Buffer[20] = (WCHAR)('0' + (settings.PortIndex % 100)%10);
//   MoxaKdPrint(MX_DBG_TRACE,("Device->%ws\n",deviceObjName.Buffer));

   //
   // create and initialize the new device object
   //

   status = MoxaCreateDevObj(DriverObject, &deviceObjName,&settings,&pNewDevObj);

   if (deviceObjName.Buffer)
	ExFreePool(deviceObjName.Buffer);


   if (!NT_SUCCESS(status)) {
 
     MoxaKdPrint(MX_DBG_ERROR,
                 ("MoxaAddDevice - error creating new devobj [%#08lx]\n",
                  status));
     
      return status;
   }


   //
   // Layer our DO on top of the lower device object
   // The return value is a pointer to the device object to which the
   // DO is actually attached.
   //

   pLowerDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, PPdo);


   //
   // No status. Do the best we can.
   //
   //ASSERT(pLowerDevObj != NULL);


   pDevExt = pNewDevObj->DeviceExtension;
   pDevExt->LowerDeviceObject = pLowerDevObj;
   pDevExt->Pdo = PPdo;

   //
   // Make the device visible via a device association as well.
   // The reference string is the eight digit device index
   //
   status = IoRegisterDeviceInterface(PPdo, (LPGUID)&GUID_CLASS_COMPORT,
                                      NULL, &pDevExt->DeviceClassSymbolicName);

   if (!NT_SUCCESS(status)) {
/*
      MoxaKdPrint (MX_DBG_ERROR,("Couldn't register class association\n"
                             "------- for port %wZ\n",
                                 &pDevExt->DeviceName));

*/
      pDevExt->DeviceClassSymbolicName.Buffer = NULL;
  
   }


   //
   // Specify that this driver only supports buffered IO.  This basically
   // means that the IO system copies the users data to and from
   // system supplied buffers.
   //
   // Also specify that we are power pagable.
   //

   pNewDevObj->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;

   //
   // Fill in global data
   //

   for (i = 0; i < MAX_CARD; i++)
	if ((MoxaGlobalData->CardType[i])
		&&(MoxaGlobalData->BoardIndex[i] == settings.BoardIndex))
		break;
   if (i == MAX_CARD) {
      for (i = 0; i < MAX_CARD; i++)
		if (!MoxaGlobalData->CardType[i])
			break;
	MoxaGlobalData->BoardIndex[i] = settings.BoardIndex;
   }
   pDevExt->BoardNo = i;
   MoxaKdPrint(MX_DBG_TRACE,("Board Number = %d\n",pDevExt->BoardNo));
   if (!MoxaGlobalData->CardType[pDevExt->BoardNo]) {
   	MoxaGlobalData->PciBusNum[pDevExt->BoardNo] = (USHORT)settings.BusNumber;
 //   USHORT  PciDevNum[MAX_CARD];
      MoxaGlobalData->InterfaceType[pDevExt->BoardNo] = settings.InterfaceType;
      MoxaGlobalData->IntVector[pDevExt->BoardNo]= settings.Interrupt.Vector;
      RtlCopyMemory(&MoxaGlobalData->PciIntAckPort[pDevExt->BoardNo],&settings.OriginalAckPort,sizeof(PHYSICAL_ADDRESS));
      RtlCopyMemory(&MoxaGlobalData->BankAddr[pDevExt->BoardNo],&settings.OriginalBaseAddress,sizeof(PHYSICAL_ADDRESS));
      MoxaGlobalData->PciIntAckBase[pDevExt->BoardNo] = settings.AckPort;
      MoxaGlobalData->CardType[pDevExt->BoardNo] = settings.BoardType;
      
    	MoxaGlobalData->CardBase[pDevExt->BoardNo] = settings.BaseAddress;
      MoxaGlobalData->IntNdx[pDevExt->BoardNo] = (PUSHORT)(settings.BaseAddress + IRQindex);
      MoxaGlobalData->IntPend[pDevExt->BoardNo] = settings.BaseAddress + IRQpending;
      MoxaGlobalData->IntTable[pDevExt->BoardNo] = settings.BaseAddress + IRQtable;
	MoxaGlobalData->NumPorts[pDevExt->BoardNo] = settings.NumPorts;  
	MoxaKdPrint(MX_DBG_TRACE,("Int ndx,pend,table = %x,%x,%x\n",
			MoxaGlobalData->IntNdx[pDevExt->BoardNo],
			MoxaGlobalData->IntPend[pDevExt->BoardNo],
			MoxaGlobalData->IntTable[pDevExt->BoardNo])
			 );   
   }

   pDevExt->PortIndex = settings.PortIndex;
   pDevExt->PortNo = pDevExt->BoardNo*MAXPORT_PER_CARD + settings.PortIndex;
   RtlZeroMemory(pDevExt->DosName,
                 sizeof(pDevExt->DosName));
   RtlCopyMemory(pDevExt->DosName,
                      comName,
                      wcslen(comName)*sizeof(WCHAR)
                      );

    
   comNo = wcslen(comName);
   if (comNo >= 4) {
	 comNo -= 3;
	 if (comNo >= 3) {
		comNo = (comName[5] - '0') + 
			(comName[4] - '0')*10 +
			(comName[3] - '0')*100;
	 }
	 else if (comNo >= 2) {
	      comNo = (comName[4] - '0') + 
			(comName[3] - '0')*10; 
		 
	 }
	 else if (comNo >= 1) {
		comNo = (comName[3] - '0');
 	 }
		
   }
   MoxaKdPrint(MX_DBG_TRACE,("ComNo=%d/len=%d\n",comNo,wcslen(comName)));
   if ((comNo > 0) && (comNo <= MAX_COM)) {
       MoxaExtension[comNo] = pDevExt;
       MoxaGlobalData->ComNo[pDevExt->BoardNo][pDevExt->PortIndex] = (USHORT)comNo;
   }
   else
	comNo = 0;
   MoxaGlobalData->Extension[pDevExt->PortNo] = pDevExt;
   MoxaKdPrint(MX_DBG_TRACE,("Leave MoxaAddDevice\n"));

   return status;
}


NTSTATUS
MoxaFinishStartDevice(IN PDEVICE_OBJECT PDevObj)
  
/*++

Routine Description:

    This routine does serial-specific procedures to start a device.  It
    does this either for a legacy device detected by its registry entries,
    or for a PnP device after the start IRP has been sent down the stack.


Arguments:

   PDevObj    -  Pointer to the devobj that is starting
   
   
  Return Value:

    STATUS_SUCCESS on success, something else appropriate on failure


--*/

{
   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   HANDLE pnpKey;
   ULONG i,com,one = 1;
   PKINTERRUPT                 moxaInterrupt;
   ULONG                       systemVector;
   KIRQL                       irql;
   KAFFINITY                   processorAffinity;
   PMOXA_CISR_SW cisrsw;
   PMOXA_MULTIPORT_DISPATCH	 dispatch;



   //PAGED_CODE();

   //
   // See if this is a restart, and if so don't reallocate the world
   //

   if (pDevExt->Flags & SERIAL_FLAGS_STOPPED) {

      MoxaClearFlags(pDevExt, SERIAL_FLAGS_STOPPED);

      pDevExt->PNPState = SERIAL_PNP_RESTARTING;

   }

   //
   // See if we are in the proper power state.
   //
 

   if (pDevExt->PowerState != PowerDeviceD0) {

      status = MoxaGotoPowerState(pDevExt->Pdo, pDevExt, PowerDeviceD0);

      if (!NT_SUCCESS(status)) {
         goto MoxaFinishStartDeviceError;
      }
   }

   //
   // The hardware that is set up to NOT interrupt, connect an interrupt. 
   //

   if (!(MoxaGlobalData->Interrupt[pDevExt->BoardNo]) 
		&& MoxaGlobalData->IntVector[pDevExt->BoardNo]) {

      KINTERRUPT_MODE	interruptMode;

   /*
      MoxaKdPrint(MX_DBG_ERROR,("About to connect to interrupt for port %wZ\n"
                 "------- address of extension is %x\n"
		     "------- interface of device is %x\n"
		     "------- bus number of device is %x\n"
		     "------- int. vector of device is %x\n"
		     "------- type of device is %d\n",
		     &pDevExt->DeviceName, pDevExt,
		     MoxaGlobalData->InterfaceType[pDevExt->BoardNo],
                 MoxaGlobalData->PciBusNum[pDevExt->BoardNo],
                 MoxaGlobalData->IntVector[pDevExt->BoardNo],
		     MoxaGlobalData->CardType[pDevExt->BoardNo])
                );
*/
      cisrsw = ExAllocatePool(
                        NonPagedPool,
                        sizeof(MOXA_CISR_SW)
                        );
 
      if (!cisrsw) {
/*
      	MoxaKdPrint(MX_DBG_ERROR,("Couldn't allocate CISR_SW for "
                                "%wZ\n", &pDevExt->DeviceName));
*/
		status = SERIAL_INSUFFICIENT_RESOURCES;
         	MoxaLogError(PDevObj->DriverObject, NULL,
            	      MoxaPhysicalZero,
                        MoxaPhysicalZero, 0, 0, 0, 1, status,
                        SERIAL_INSUFFICIENT_RESOURCES,
                        pDevExt->DeviceName.Length + sizeof(WCHAR),
                        pDevExt->DeviceName.Buffer, 0, NULL);

         
         	goto MoxaFinishStartDeviceError;
     	}
	dispatch = &cisrsw->Dispatch;
 
	dispatch->BoardNo = pDevExt->BoardNo;
	dispatch->GlobalData = MoxaGlobalData;
 
	for (i = 0; i < MAX_CARD; i++) 
		if ((MoxaGlobalData->Interrupt[i]) &&
 		    (MoxaGlobalData->IntVector[i] == MoxaGlobalData->IntVector[pDevExt->BoardNo])&&
		    (MoxaGlobalData->InterfaceType[i] == MoxaGlobalData->InterfaceType[pDevExt->BoardNo]))  
			break;

	if (i != MAX_CARD) {
 		MoxaGlobalData->Interrupt[pDevExt->BoardNo] =
      	pDevExt->Interrupt = MoxaGlobalData->Interrupt[i];
      	MoxaGlobalData->Irql[pDevExt->BoardNo] = MoxaGlobalData->Irql[i];
      	MoxaGlobalData->ProcessorAffinity[pDevExt->BoardNo] = MoxaGlobalData->ProcessorAffinity[i];
            pDevExt->InterruptShareList=
		MoxaGlobalData->InterruptShareList[pDevExt->BoardNo] = MoxaGlobalData->InterruptShareList[i];
		InsertTailList(pDevExt->InterruptShareList,&cisrsw->SharerList);
		MoxaKdPrint(MX_DBG_ERROR,("Interrupt share with %d/%x\n",i,
                        pDevExt->InterruptShareList));


    
	}
	else {
/* for debug
PLIST_ENTRY interruptEntry;
PMOXA_CISR_SW cisrsw1;
*/

		MoxaGlobalData->InterruptShareList[pDevExt->BoardNo] = ExAllocatePool(
                        NonPagedPool,
                        sizeof(LIST_ENTRY)
                        );
 
      	if (!MoxaGlobalData->InterruptShareList[pDevExt->BoardNo]) {
/*
            	MoxaKdPrint(MX_DBG_ERROR,("Couldn't allocate InterruptShareList for "
                                "%wZ\n", &pDevExt->DeviceName));
*/
			ExFreePool(cisrsw);
			status = SERIAL_INSUFFICIENT_RESOURCES;
      		MoxaLogError(PDevObj->DriverObject, NULL,
                        MoxaPhysicalZero,
                        MoxaPhysicalZero, 0, 0, 0, 1, status,
                        SERIAL_INSUFFICIENT_RESOURCES,
                        pDevExt->DeviceName.Length + sizeof(WCHAR),
                        pDevExt->DeviceName.Buffer, 0, NULL);

         
         		goto MoxaFinishStartDeviceError;
      	}

		pDevExt->InterruptShareList=MoxaGlobalData->InterruptShareList[pDevExt->BoardNo];
  
    		InitializeListHead(pDevExt->InterruptShareList);

    		InsertTailList(pDevExt->InterruptShareList,&cisrsw->SharerList);
/*
interruptEntry = interruptEntry->Flink;
MoxaKdPrint(MX_DBG_ERROR,("list entry %x/%x/%x\n",interruptEntry,interruptEntry->Flink,
interruptEntry->Blink));
interruptEntry = pDevExt->InterruptShareList;
MoxaKdPrint(MX_DBG_ERROR,("list head %x/%x/%x\n",interruptEntry,interruptEntry->Flink,
interruptEntry->Blink));


if (IsListEmpty(MoxaGlobalData->InterruptShareList[pDevExt->BoardNo]))
	MoxaKdPrint(MX_DBG_ERROR,("list empty\n"));
cisrsw1 = CONTAINING_RECORD(  interruptEntry,
                                                     MOXA_CISR_SW,
                                                     SharerList
                                                     );
MoxaKdPrint(MX_DBG_ERROR,("cisrsw %x/%x\n",cisrsw,cisrsw1));



*/

      	systemVector = HalGetInterruptVector(
      			(ULONG)MoxaGlobalData->InterfaceType[pDevExt->BoardNo],
                        (ULONG)MoxaGlobalData->PciBusNum[pDevExt->BoardNo],
                        MoxaGlobalData->IntVector[pDevExt->BoardNo],
                        MoxaGlobalData->IntVector[pDevExt->BoardNo],
                        &irql,
                        &processorAffinity
                        );

		MoxaKdPrint(MX_DBG_ERROR,("System Vector = %x,%x,%x,%x\n",systemVector,irql,processorAffinity,
                        MoxaGlobalData->InterruptShareList[pDevExt->BoardNo]));

	      if (MoxaGlobalData->InterfaceType[pDevExt->BoardNo] == PCIBus)
			interruptMode = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
		else 
			interruptMode = CM_RESOURCE_INTERRUPT_LATCHED;

      	status = IoConnectInterrupt(
                        &moxaInterrupt,
                        MoxaISR,
                        MoxaGlobalData->InterruptShareList[pDevExt->BoardNo],
                        NULL,
                        systemVector,
                        irql,
                        irql,
                        interruptMode,
                        TRUE,
                        processorAffinity,
                        FALSE
                        );


      	if (!NT_SUCCESS(status)) {
/*
         		MoxaKdPrint(MX_DBG_ERROR,("Couldn't connect to interrupt for "
                                "%wZ(status=%x)\n", &pDevExt->DeviceName,status));
*/
			ExFreePool(cisrsw);
	
			status = SERIAL_UNREPORTED_IRQL_CONFLICT;			
         		MoxaLogError(PDevObj->DriverObject, NULL,
                        MoxaPhysicalZero,
                        MoxaPhysicalZero, 0, 0, 0, 1, status,
                        SERIAL_UNREPORTED_IRQL_CONFLICT,
                        pDevExt->DeviceName.Length + sizeof(WCHAR),
                        pDevExt->DeviceName.Buffer, 0, NULL);

         	
         		goto MoxaFinishStartDeviceError;
      	}
		MoxaGlobalData->Interrupt[pDevExt->BoardNo] =
      	pDevExt->Interrupt = moxaInterrupt;
      	MoxaGlobalData->Irql[pDevExt->BoardNo] = irql;
      	MoxaGlobalData->ProcessorAffinity[pDevExt->BoardNo] = processorAffinity;
	}
     
   }
   else {
      pDevExt->Interrupt = MoxaGlobalData->Interrupt[pDevExt->BoardNo];
      pDevExt->InterruptShareList=MoxaGlobalData->InterruptShareList[pDevExt->BoardNo];

   }


   //
   // Add the PDevObj to the master list
   //
 
  // InsertTailList(&MoxaGlobalData->AllDevObjs, &pDevExt->AllDevObjs);


   //
   // This should set up everything as it should be when
   // a device is to be opened.  We do need to lower the
   // modem lines, and disable the recalcitrant fifo
   // so that it will show up if the user boots to dos.
   //
/*

   KeSynchronizeExecution( //Disables the fifo.
                           pDevExt->Interrupt,
                           SerialMarkClose,
                           pDevExt
                         );
*/
 
   if (pDevExt->PNPState == SERIAL_PNP_ADDED ) {

      //
      // Do the external naming now that the device is accessible.
      //
 
      status = MoxaDoExternalNaming(pDevExt, pDevExt->DeviceObject->
                                      DriverObject);


      if (!NT_SUCCESS(status)) {
         MoxaKdPrint(MX_DBG_ERROR,("External Naming Failed - Status %x\n",
                                status));

         //
         // Allow the device to start anyhow
         //

         status = STATUS_SUCCESS;
//         goto MoxaFinishStartDeviceError;

      }
     
   } else {
      MoxaKdPrint(MX_DBG_ERROR,("Not doing external naming -- state is %x\n",
                               pDevExt->PNPState));
   }

   
MoxaFinishStartDeviceError:;

   if (!NT_SUCCESS (status)) {

      MoxaKdPrint(MX_DBG_TRACE,("Cleaning up failed start\n"));

      //
      // Resources created by this routine will be cleaned up by the remove
      //

      if (pDevExt->PNPState == SERIAL_PNP_RESTARTING) {
         //
         // Kill all that lives and breathes -- we'll clean up the
         // rest on the impending remove
         //

         MoxaKillPendingIrps(PDevObj);

         //
         // In fact, pretend we're removing so we don't take any
         // more irps
         //

         MoxaSetAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);
         MoxaClearFlags(pDevExt, SERIAL_FLAGS_STARTED);
      }
   } else { // SUCCESS

      //
      // Fill in WMI hardware data
      //
 
      pDevExt->WmiHwData.IrqNumber = MoxaGlobalData->Irql[pDevExt->BoardNo];
      pDevExt->WmiHwData.IrqLevel = MoxaGlobalData->Irql[pDevExt->BoardNo];
      pDevExt->WmiHwData.IrqVector = MoxaGlobalData->IntVector[pDevExt->BoardNo];
      pDevExt->WmiHwData.IrqAffinityMask =MoxaGlobalData->ProcessorAffinity[pDevExt->BoardNo];
      pDevExt->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LATCHED;
      pDevExt->WmiHwData.BaseIOAddress = (ULONGLONG)MoxaGlobalData->BankAddr[pDevExt->BoardNo].LowPart;


      //
      // Fill in WMI device state data (as defaults)
      //
 
      pDevExt->WmiCommData.BaudRate = pDevExt->CurrentBaud;
	switch (pDevExt->DataMode & MOXA_DATA_MASK) {
	case MOXA_5_DATA :
		pDevExt->WmiCommData.BitsPerByte = 5;
		break;
	case MOXA_6_DATA :
		pDevExt->WmiCommData.BitsPerByte = 6;
		break;
      case MOXA_7_DATA :
		pDevExt->WmiCommData.BitsPerByte = 7;
		break;
      case MOXA_8_DATA :
	default :
		pDevExt->WmiCommData.BitsPerByte = 8;
		break;
	}
      pDevExt->WmiCommData.ParityCheckEnable = (pDevExt->DataMode & MOXA_NONE_PARITY)
         ? FALSE : TRUE;

      switch (pDevExt->DataMode & MOXA_PARITY_MASK) {
      case MOXA_NONE_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
         break;

      case MOXA_ODD_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;
         break;

      case MOXA_EVEN_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;
         break;

      case MOXA_MARK_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;
         break;

      case MOXA_SPACE_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;
         break;

      default:
         ASSERTMSG(0, "SERIAL: Illegal Parity setting for WMI");
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
         break;
      } 

	switch (pDevExt->DataMode & MOXA_STOP_MASK) {
	
	case MOXA_1_5_STOP :
		pDevExt->WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;
		break;
      case MOXA_2_STOP :
		pDevExt->WmiCommData.StopBits = SERIAL_WMI_STOP_2;
		break;
	case MOXA_1_STOP :
	default :
		pDevExt->WmiCommData.StopBits = SERIAL_WMI_STOP_1;
		break;
	}

    
      pDevExt->WmiCommData.XoffCharacter = pDevExt->SpecialChars.XoffChar;
      pDevExt->WmiCommData.XoffXmitThreshold = pDevExt->HandFlow.XoffLimit;
      pDevExt->WmiCommData.XonCharacter = pDevExt->SpecialChars.XonChar;
      pDevExt->WmiCommData.XonXmitThreshold = pDevExt->HandFlow.XonLimit;
      pDevExt->WmiCommData.MaximumBaudRate
         = pDevExt->MaxBaud;
      pDevExt->WmiCommData.MaximumOutputBufferSize = pDevExt->TxBufferSize;
	pDevExt->WmiCommData.MaximumInputBufferSize = pDevExt->RxBufferSize;
      pDevExt->WmiCommData.Support16BitMode = FALSE;
      pDevExt->WmiCommData.SupportDTRDSR = TRUE;
      pDevExt->WmiCommData.SupportIntervalTimeouts = TRUE;
      pDevExt->WmiCommData.SupportParityCheck = TRUE;
      pDevExt->WmiCommData.SupportRTSCTS = TRUE;
      pDevExt->WmiCommData.SupportXonXoff = TRUE;
      pDevExt->WmiCommData.SettableBaudRate = TRUE;
      pDevExt->WmiCommData.SettableDataBits = TRUE;
      pDevExt->WmiCommData.SettableFlowControl = TRUE;
      pDevExt->WmiCommData.SettableParity = TRUE;
      pDevExt->WmiCommData.SettableParityCheck = TRUE;
      pDevExt->WmiCommData.SettableStopBits = TRUE;
      pDevExt->WmiCommData.IsBusy = FALSE;
      

      if (pDevExt->PNPState == SERIAL_PNP_ADDED) {
         PULONG countSoFar = &IoGetConfigurationInformation()->SerialCount;
         (*countSoFar)++;

         //
         // Register for WMI
         //

         pDevExt->WmiLibInfo.GuidCount = sizeof(MoxaWmiGuidList) /
                                              sizeof(WMIGUIDREGINFO);
         pDevExt->WmiLibInfo.GuidList = MoxaWmiGuidList;
 
         pDevExt->WmiLibInfo.QueryWmiRegInfo = MoxaQueryWmiRegInfo;
         pDevExt->WmiLibInfo.QueryWmiDataBlock = MoxaQueryWmiDataBlock;
         pDevExt->WmiLibInfo.SetWmiDataBlock = MoxaSetWmiDataBlock;
         pDevExt->WmiLibInfo.SetWmiDataItem = MoxaSetWmiDataItem;
         pDevExt->WmiLibInfo.ExecuteWmiMethod = NULL;
         pDevExt->WmiLibInfo.WmiFunctionControl = NULL;

         IoWMIRegistrationControl(PDevObj, WMIREG_ACTION_REGISTER);

      }

      if (pDevExt->PNPState == SERIAL_PNP_RESTARTING) {
         //
         // Release the stalled IRP's
         //

         MoxaUnstallIrps(pDevExt);
      }

      pDevExt->PNPState = SERIAL_PNP_STARTED;
      MoxaClearAccept(pDevExt, ~SERIAL_PNPACCEPT_OK);
      MoxaSetFlags(pDevExt, SERIAL_FLAGS_STARTED);
/*
	MoxaLogError(PDevObj->DriverObject, NULL,
                        MoxaPhysicalZero,
                        MoxaPhysicalZero, 0, 0, 0, 1, status,
                        SERIAL_PORT_FOUND,
                        pDevExt->DosName.Length + sizeof(WCHAR),
                        pDevExt->DosName.Buffer, 0, NULL);
*/

     
   }
   
   MoxaKdPrint(MX_DBG_TRACE,("leaving MoxaFinishStartDevice\n"));

   return status;
}




NTSTATUS
MoxaStartDevice(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This routine first passes the start device Irp down the stack then
    it picks up the resources for the device, ititializes, puts it on any
    appropriate lists (i.e shared interrupt or interrupt status) and 
    connects the interrupt.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    Return status


--*/

{
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;
   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   PKEVENT pStartEvent;
 

   //PAGED_CODE();
 

   pStartEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

   if (pStartEvent == NULL) {
       PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
       MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
       return STATUS_INSUFFICIENT_RESOURCES;
   }

   KeInitializeEvent(pStartEvent, SynchronizationEvent, FALSE);

   //
   // Pass this down to the next device object
   //

   KeInitializeEvent(pStartEvent, SynchronizationEvent,
                     FALSE);

   IoCopyCurrentIrpStackLocationToNext(PIrp);
   IoSetCompletionRoutine(PIrp, MoxaSyncCompletion,
                          pStartEvent, TRUE, TRUE, TRUE);

   status = IoCallDriver(pLowerDevObj, PIrp);


   //
   // Wait for lower drivers to be done with the Irp
   //

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject (pStartEvent, Executive, KernelMode,
                             FALSE, NULL);

      status = PIrp->IoStatus.Status;
   }

   ExFreePool(pStartEvent);

   if (!NT_SUCCESS(status)) {
      MoxaKdPrint(MX_DBG_TRACE,("error with IoCallDriver %x\n", status));
      return status;
   }


   //
   // Do the serial specific items to start the device
   //
 
   status = MoxaFinishStartDevice(PDevObj);
 
   return status;
}

 

NTSTATUS
MoxaDoExternalNaming(IN PMOXA_DEVICE_EXTENSION PDevExt,
                       IN PDRIVER_OBJECT PDrvObj)

/*++

Routine Description:

    This routine will be used to create a symbolic link
    to the driver name in the given object directory.

    It will also create an entry in the device map for
    this device - IF we could create the symbolic link.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    None.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   UNICODE_STRING linkName;
   PDEVICE_OBJECT pLowerDevObj, pDevObj;
   ULONG bufLen,i;


   //PAGED_CODE();

   pDevObj = PDevExt->DeviceObject;
   pLowerDevObj = PDevExt->LowerDeviceObject;
   RtlZeroMemory(&linkName, sizeof(UNICODE_STRING));

   linkName.MaximumLength = SYMBOLIC_NAME_LENGTH*sizeof(WCHAR);
   linkName.Buffer = ExAllocatePool(PagedPool, linkName.MaximumLength
                                    + sizeof(WCHAR));
   if (linkName.Buffer == NULL) {
      MoxaLogError(PDrvObj, pDevObj, MoxaPhysicalZero, MoxaPhysicalZero,
                     0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                     0, NULL, 0, NULL);
      MoxaKdPrint (MX_DBG_ERROR, ("Couldn't allocate memory for device name"
                             "\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto MoxaDoExternalNamingError;

   }

   RtlZeroMemory(linkName.Buffer, linkName.MaximumLength + sizeof(WCHAR));


   

   bufLen = wcslen(PDevExt->DosName) * sizeof(WCHAR) + sizeof(UNICODE_NULL);

   PDevExt->WmiIdentifier.Buffer = ExAllocatePool(PagedPool, bufLen);

   if (PDevExt->WmiIdentifier.Buffer == NULL) {
      MoxaLogError(PDrvObj, pDevObj, MoxaPhysicalZero, MoxaPhysicalZero,
                    0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                    0, NULL, 0, NULL);
      MoxaKdPrint (MX_DBG_ERROR,
                 (" Couldn't allocate memory for WMI name\n"));
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto MoxaDoExternalNamingError;
   }

   RtlZeroMemory(PDevExt->WmiIdentifier.Buffer, bufLen);

   PDevExt->WmiIdentifier.Length = 0;
   PDevExt->WmiIdentifier.MaximumLength = (USHORT)bufLen;
   RtlAppendUnicodeToString(&PDevExt->WmiIdentifier, PDevExt->DosName);


   //
   // Create the "\\DosDevices\\<symbolicName>" string
   //
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, DEFAULT_DIRECTORY);
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, PDevExt->DosName);

   //
   // Allocate Pool and save the symbolic link name in the device extension.
   //
   PDevExt->SymbolicLinkName.MaximumLength = linkName.Length + sizeof(WCHAR);
   PDevExt->SymbolicLinkName.Buffer
      = ExAllocatePool(PagedPool, PDevExt->SymbolicLinkName.MaximumLength);

   if (!PDevExt->SymbolicLinkName.Buffer) {

      MoxaLogError(PDrvObj, pDevObj, MoxaPhysicalZero, MoxaPhysicalZero,
                    0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                    0, NULL, 0, NULL);
      MoxaKdPrint (MX_DBG_ERROR,
                 ("Couldn't allocate memory for symbolic link name\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto MoxaDoExternalNamingError;
   }

   

   //
   // Zero fill it.
   //

   RtlZeroMemory(PDevExt->SymbolicLinkName.Buffer,
                 PDevExt->SymbolicLinkName.MaximumLength);

   RtlAppendUnicodeStringToString(&PDevExt->SymbolicLinkName,
                                  &linkName);

   

//   MoxaKdPrint (MX_DBG_ERROR,("DosName is %ws\n",
//                         &PDevExt->DosName));

   //
 

   status = IoCreateSymbolicLink (&PDevExt->SymbolicLinkName,
                                  &PDevExt->DeviceName);
   if (!NT_SUCCESS(status)) {

      //
      // Oh well, couldn't create the symbolic link.  No point
      // in trying to create the device map entry.
      //

      MoxaLogError(PDrvObj, pDevObj, MoxaPhysicalZero, MoxaPhysicalZero,
                     0, 0, 0, 52, status, SERIAL_NO_SYMLINK_CREATED,
                     PDevExt->DeviceName.Length + sizeof(WCHAR),
                     PDevExt->DeviceName.Buffer, 0, NULL);
/*
      MoxaKdPrint (MX_DBG_ERROR,
                ("Couldn't create the symbolic link\n"
                 "------- for port %wZ\n",
                 &PDevExt->DeviceName)
                );
*/
      goto MoxaDoExternalNamingError;

   }

   PDevExt->CreatedSymbolicLink = TRUE;


   status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM",
                                   PDevExt->DeviceName.Buffer, REG_SZ,
                                   PDevExt->DosName,
                                   wcslen(PDevExt->DosName)*sizeof(WCHAR) + sizeof(WCHAR));
   if (!NT_SUCCESS(status)) {

      MoxaLogError(PDrvObj, pDevObj, MoxaPhysicalZero, MoxaPhysicalZero,
                     0, 0, 0, 53, status, SERIAL_NO_DEVICE_MAP_CREATED,
                     PDevExt->DeviceName.Length + sizeof(WCHAR),
                     PDevExt->DeviceName.Buffer, 0, NULL);
/*
      MoxaKdPrint (MX_DBG_ERROR,("Couldn't create the device map entry\n"
                             "------- for port %wZ\n", &PDevExt->DeviceName));
*/
      goto MoxaDoExternalNamingError;
   }

   PDevExt->CreatedSerialCommEntry = TRUE;
                
             
   // 
   // Now set the symbolic link for the association
   //
        
   status = IoSetDeviceInterfaceState(&PDevExt->DeviceClassSymbolicName,
                                         TRUE);
/*
   if (!NT_SUCCESS(status)) {
      MoxaKdPrint (MX_DBG_ERROR,("Couldn't set class association\n"
                             "------- for port %wZ\n",
                             &PDevExt->DeviceName));
   }
*/
   MoxaDoExternalNamingError:;

   //
   // Clean up error conditions
   //

   if (!NT_SUCCESS(status)) {
      
      if (PDevExt->CreatedSymbolicLink ==  TRUE) {
         IoDeleteSymbolicLink(&PDevExt->SymbolicLinkName);
         PDevExt->CreatedSymbolicLink = FALSE;
      }

      if (PDevExt->SymbolicLinkName.Buffer != NULL) {
         ExFreePool(PDevExt->SymbolicLinkName.Buffer);
         PDevExt->SymbolicLinkName.Buffer = NULL;
      }

      if (PDevExt->DeviceName.Buffer != NULL) {
         RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                                PDevExt->DeviceName.Buffer);
      }

      if (PDevExt->DeviceClassSymbolicName.Buffer) {
         IoSetDeviceInterfaceState (&PDevExt->DeviceClassSymbolicName, FALSE);
      }

      if (PDevExt->WmiIdentifier.Buffer != NULL) {
         ExFreePool(PDevExt->WmiIdentifier.Buffer);
         PDevExt->WmiIdentifier.Buffer = NULL;
      }
   }

   //
   // Always clean up our temp buffers.
   //

   if (linkName.Buffer != NULL) {
      ExFreePool(linkName.Buffer);
   }

   return status;
}


VOID
MoxaUndoExternalNaming(IN PMOXA_DEVICE_EXTENSION Extension)

/*++

Routine Description:

    This routine will be used to delete a symbolic link
    to the driver name in the given object directory.

    It will also delete an entry in the device map for
    this device if the symbolic link had been created.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    None.

--*/

{

   NTSTATUS status;

   //PAGED_CODE();
/*
   MoxaKdPrint (MX_DBG_ERROR,("In MoxaUndoExternalNaming for\n"
              "------- extension: %x of port %wZ\n",
              Extension,&Extension->DeviceName)
             );
*/
   
   //
   // We're cleaning up here.  One reason we're cleaning up
   // is that we couldn't allocate space for the directory
   // name or the symbolic link.
   //

   if (Extension->SymbolicLinkName.Buffer &&
       Extension->CreatedSymbolicLink) {

            if (Extension->DeviceClassSymbolicName.Buffer) {
               status = IoSetDeviceInterfaceState (&Extension->
                                                   DeviceClassSymbolicName,
                                                   FALSE);
            
               //
               // IoRegisterDeviceClassInterface() allocated this string for us,
               // and we no longer need it.
               //

               ExFreePool( Extension->DeviceClassSymbolicName.Buffer );
            }


      IoDeleteSymbolicLink (&Extension->SymbolicLinkName);

   }

   if (Extension->WmiIdentifier.Buffer) {
      ExFreePool(Extension->WmiIdentifier.Buffer);
      Extension->WmiIdentifier.MaximumLength
         = Extension->WmiIdentifier.Length = 0;
      Extension->WmiIdentifier.Buffer = NULL;
   }

   //
   // We're cleaning up here.  One reason we're cleaning up
   // is that we couldn't allocate space for the NtNameOfPort.
   //

   if ((Extension->DeviceName.Buffer != NULL)
        && Extension->CreatedSerialCommEntry) {

      status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                                     Extension->DeviceName.Buffer);

      if (!NT_SUCCESS(status)) {

         MoxaLogError(
                       Extension->DeviceObject->DriverObject,
                       Extension->DeviceObject,
                       MoxaPhysicalZero,
                       MoxaPhysicalZero,
                       0,
                       0,
                       0,
                       55,
                       status,
                       SERIAL_NO_DEVICE_MAP_DELETED,
                       Extension->DeviceName.Length+sizeof(WCHAR),
                       Extension->DeviceName.Buffer,
                       0,
                       NULL
                       );
/*
         MoxaKdPrint (MX_DBG_ERROR,("Couldn't delete value entry %wZ\n",
                    &Extension->DeviceName)
                   );
*/

      }
   }
}


 

NTSTATUS
MoxaPnpDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_PNP major code (plug-and-play IRPs).

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status;
   PDEVICE_CAPABILITIES pDevCaps;


   //PAGED_CODE();
   if (pDevExt->ControlDevice) {        // Control Device

        status = STATUS_CANCELLED;
        PIrp->IoStatus.Information = 0L;
        PIrp->IoStatus.Status = status;
        IoCompleteRequest(
            PIrp,
            0
            );
        return status;
   }

   if ((status = MoxaIRPPrologue(PIrp, pDevExt)) != STATUS_SUCCESS) {
      MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

  
   switch (pIrpStack->MinorFunction) {
   case IRP_MN_QUERY_CAPABILITIES: {
      PKEVENT pQueryCapsEvent;
      SYSTEM_POWER_STATE cap;

      MoxaKdPrint (MX_DBG_TRACE,("Got IRP_MN_QUERY_DEVICE_CAPABILITIES "
                               "IRP\n"));

      pQueryCapsEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

      if (pQueryCapsEvent == NULL) {
         PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
         MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      KeInitializeEvent(pQueryCapsEvent, SynchronizationEvent, FALSE);

      IoCopyCurrentIrpStackLocationToNext(PIrp);
      IoSetCompletionRoutine(PIrp, MoxaSyncCompletion, pQueryCapsEvent,
                             TRUE, TRUE, TRUE);

      status = IoCallDriver(pLowerDevObj, PIrp);


      //
      // Wait for lower drivers to be done with the Irp
      //

      if (status == STATUS_PENDING) {
         KeWaitForSingleObject(pQueryCapsEvent, Executive, KernelMode, FALSE,
                               NULL);
      }

      ExFreePool(pQueryCapsEvent);

      status = PIrp->IoStatus.Status;

      if (pIrpStack->Parameters.DeviceCapabilities.Capabilities == NULL) {
         goto errQueryCaps;
      }

      //
      // Save off their power capabilities
      //

      MoxaKdPrint (MX_DBG_ERROR,("SERIAL: Mapping power capabilities\n"));

      pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

      pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

      for (cap = PowerSystemSleeping1; cap < PowerSystemMaximum;
           cap++) {
#if DBG
         MoxaKdPrint (MX_DBG_ERROR, ("  SERIAL: %d: %s <--> %s\n",
                                  cap, SerSystemCapString[cap],
                                  SerDeviceCapString[pDevCaps->DeviceState[cap]]
                                  ));
#endif

         pDevExt->DeviceStateMap[cap] = pDevCaps->DeviceState[cap];
      }

      pDevExt->DeviceStateMap[PowerSystemUnspecified]
         = PowerDeviceUnspecified;

      pDevExt->DeviceStateMap[PowerSystemWorking]
        = PowerDeviceD0;

      pDevExt->SystemWake = pDevCaps->SystemWake;
      pDevExt->DeviceWake = pDevCaps->DeviceWake;

      errQueryCaps:;

      MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   case IRP_MN_QUERY_DEVICE_RELATIONS:
      //
      // We just pass this down -- serenum enumerates our bus for us.
      //

      MoxaKdPrint (MX_DBG_TRACE,("Got IRP_MN_QUERY_DEVICE_RELATIONS "
                                "Irp\n"));

      switch (pIrpStack->Parameters.QueryDeviceRelations.Type) {
      case BusRelations:
         MoxaKdPrint (MX_DBG_TRACE,("------- BusRelations Query\n"));
         break;

      case EjectionRelations:
         MoxaKdPrint (MX_DBG_TRACE, ("------- EjectionRelations Query\n"));
         break;

      case PowerRelations:
         MoxaKdPrint (MX_DBG_TRACE, ("------- PowerRelations Query\n"));
         break;

      case RemovalRelations:
         MoxaKdPrint (MX_DBG_TRACE, ("------- RemovalRelations Query\n"));
         break;

      case TargetDeviceRelation:
         MoxaKdPrint (MX_DBG_TRACE,("------- TargetDeviceRelation Query\n"));
         break;

      default:
         MoxaKdPrint (MX_DBG_TRACE,("------- Unknown Query\n"));
         break;
      }

      break;


   case IRP_MN_START_DEVICE: {
      PVOID startLockPtr;

      MoxaKdPrint (MX_DBG_TRACE, ("Got IRP_MN_START_DEVICE Irp\n"));

      //
      // MoxaStartDevice will pass this Irp to the next driver,
      // and process it as completion so just complete it here.
      //
// to be finish
//      MoxaLockPagableSectionByHandle(MoxaGlobalData->PAGESER_Handle);

      //
      // Make sure the stack is powered up
      //

  //    status = MoxaGotoPowerState(PDevObj, pDevExt, PowerDeviceD0);

//      if (status == STATUS_SUCCESS) {
            status = MoxaStartDevice(PDevObj, PIrp);
 //     }

 //       MoxaUnlockPagableImageSection(MoxaGlobalData->PAGESER_Handle);


      PIrp->IoStatus.Status = status;

      MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   
   case IRP_MN_QUERY_PNP_DEVICE_STATE:
      {
	   MoxaKdPrint (MX_DBG_TRACE,("Got IRP_MN_QUERY_PNP_DEVICE_STATE Irp\n"));

         if (pDevExt->Flags & SERIAL_FLAGS_BROKENHW) {
            (PNP_DEVICE_STATE)PIrp->IoStatus.Information |= PNP_DEVICE_FAILED;
	      status = PIrp->IoStatus.Status = STATUS_SUCCESS;
         }
   
         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return MoxaIoCallDriver(pDevExt, pLowerDevObj, PIrp);
	   
      }

   case IRP_MN_STOP_DEVICE:
      {
         ULONG pendingIRPs;
         KIRQL oldIrql;

         MoxaKdPrint (MX_DBG_TRACE,("Got IRP_MN_STOP_DEVICE Irp\n"));
         MoxaKdPrint (MX_DBG_TRACE, ("------- for device %x\n", pLowerDevObj));

        
         MoxaSetFlags(pDevExt, SERIAL_FLAGS_STOPPED);
         MoxaSetAccept(pDevExt,SERIAL_PNPACCEPT_STOPPED);
         MoxaClearAccept(pDevExt, SERIAL_PNPACCEPT_STOPPING);

         pDevExt->PNPState = SERIAL_PNP_STOPPING;

         //
         // From this point on all non-PNP IRP's will be queued
         //

         //
         // Decrement for entry here
         //

         InterlockedDecrement(&pDevExt->PendingIRPCnt);

         //
         // Decrement for stopping
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         //
         // Re-increment the count for later
         //

         InterlockedIncrement(&pDevExt->PendingIRPCnt);

         //
         // We need to free resources...basically this is a remove
         // without the detach from the stack.
         //

//         if (pDevExt->Flags & SERIAL_FLAGS_STARTED) {
                MoxaReleaseResources(pDevExt); 
//         }

         //
         // Pass the irp down
         //

         IoSkipCurrentIrpStackLocation(PIrp);

         return IoCallDriver(pLowerDevObj, PIrp);
	   
      }

     case IRP_MN_CANCEL_STOP_DEVICE:


      MoxaKdPrint (MX_DBG_TRACE,("Got "
                               "IRP_MN_CANCEL_STOP_DEVICE Irp\n"));
      MoxaKdPrint (MX_DBG_TRACE, ("------- for device %x\n", pLowerDevObj));
 
      if (pDevExt->PNPState == SERIAL_PNP_QSTOP) {
         //
         // Restore the device state
         //
         pDevExt->PNPState = SERIAL_PNP_STARTED;
         MoxaClearAccept(pDevExt, SERIAL_PNPACCEPT_STOPPING);
      }

      IoCopyCurrentIrpStackLocationToNext(PIrp);
      return MoxaIoCallDriver(pDevExt, pLowerDevObj, PIrp);
	

   case IRP_MN_CANCEL_REMOVE_DEVICE:


      MoxaKdPrint (MX_DBG_TRACE, ("Got "
                               "IRP_MN_CANCEL_REMOVE_DEVICE Irp\n"));
      MoxaKdPrint (MX_DBG_TRACE, ("------- for device %x\n", pLowerDevObj));

      //
      // Restore the device state
      //

      pDevExt->PNPState = SERIAL_PNP_STARTED;
      MoxaClearAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);
      IoCopyCurrentIrpStackLocationToNext(PIrp);
      return MoxaIoCallDriver(pDevExt, pLowerDevObj, PIrp);
	

   case IRP_MN_QUERY_REMOVE_DEVICE:
      {
         KIRQL oldIrql;


         MoxaKdPrint (MX_DBG_TRACE, ("Got "
                                  "IRP_MN_QUERY_REMOVE_DEVICE Irp\n"));
         MoxaKdPrint (MX_DBG_TRACE,("------- for device %x\n", pLowerDevObj));

         ExAcquireFastMutex(&pDevExt->OpenMutex);

         //
         // See if we should succeed a remove query
         //

         if (pDevExt->DeviceIsOpened) {
            ExReleaseFastMutex(&pDevExt->OpenMutex);
            status = PIrp->IoStatus.Status = STATUS_DEVICE_BUSY;
            MoxaKdPrint (MX_DBG_TRACE,("------- failing; device open\n"));
            MoxaCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;
         }

         pDevExt->PNPState = SERIAL_PNP_QREMOVE;
         MoxaSetAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);
         ExReleaseFastMutex(&pDevExt->OpenMutex);

	   IoSkipCurrentIrpStackLocation(PIrp);
         return MoxaIoCallDriver(pDevExt, pLowerDevObj, PIrp);
	
      }

   case IRP_MN_SURPRISE_REMOVAL:
      {
         ULONG pendingIRPs;
         KIRQL oldIrql;


         MoxaKdPrint (MX_DBG_TRACE, ("Got IRP_MN_SURPRISE_REMOVAL Irp\n"));
         MoxaKdPrint (MX_DBG_TRACE,("------- for device %x\n", pLowerDevObj));
         //
         // Prevent any new I/O to the device
         //

         MoxaSetAccept(pDevExt, SERIAL_PNPACCEPT_SURPRISE_REMOVING);

         //
         // Dismiss all pending requests
         //

         MoxaKillPendingIrps(PDevObj);

         //
         // Wait for any pending requests we raced on.
         //

         //
         // Decrement once for ourselves
         //

         InterlockedDecrement(&pDevExt->PendingIRPCnt);

         //
         // Decrement for the remove
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         //
         // Reset for subsequent remove
         //

         InterlockedIncrement(&pDevExt->PendingIRPCnt);

         //
         // Remove any external interfaces and release resources
         //

         MoxaDisableInterfacesResources(PDevObj, FALSE); // to be finish

         IoSkipCurrentIrpStackLocation(PIrp);
         return MoxaIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_REMOVE_DEVICE:

      {
         ULONG pendingIRPs;
         KIRQL oldIrql;

         MoxaKdPrint (MX_DBG_TRACE,(" Got IRP_MN_REMOVE_DEVICE Irp\n"));
         MoxaKdPrint (MX_DBG_TRACE, ("------- for device %x\n", pLowerDevObj));

         //
         // If we get this, we have to remove
         //
      
         //
         // Mark as not accepting requests
         //

         MoxaSetAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);

         //
         // Complete all pending requests
         //

         MoxaKillPendingIrps(PDevObj);


         //
         // Pass the irp down
         //
         
	   IoCopyCurrentIrpStackLocationToNext(PIrp);

  

         //
         // We do decrement here because we incremented on entry here.
         //

         status = MoxaIoCallDriver(pDevExt, pLowerDevObj, PIrp);

         //
         // Wait for any pending requests we raced on.
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);
         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         //
         // Remove us
         //

         MoxaRemoveDevObj(PDevObj);
         return status;
      }

   default:
	MoxaKdPrint (MX_DBG_TRACE,
		(" Got PNP IRP %x,we don't process it and just pass it down.\n",
		pIrpStack->MinorFunction));
      break;



   }   // switch (pIrpStack->MinorFunction)

   //
   // Pass to driver beneath us
   //
   IoSkipCurrentIrpStackLocation(PIrp);
   status = MoxaIoCallDriver(pDevExt, pLowerDevObj, PIrp);
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\precomp.h ===
#include <stddef.h>
#include <ntddk.h>
#include <ntddser.h>
#include <wmilib.h>
#include <wmidata.h>
#include "moxa.h"
#include "moxadf.h"
#include "moxaext.h"
#include "mxdebug.h"
#include "mxlog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\qsfile.c ===
/*++

Module Name:

    qsfile.c


Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
MoxaQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION irpSp;

    PMOXA_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    if (Extension->ControlDevice) {        // Control Device
        status = STATUS_CANCELLED;

        Irp->IoStatus.Information = 0L;

        Irp->IoStatus.Status = status;

        IoCompleteRequest(
            Irp,
            0
            );
	
        return status;
    }

    if ((status = MoxaIRPPrologue(Irp,
                                    (PMOXA_DEVICE_EXTENSION)DeviceObject->
                                    DeviceExtension)) != STATUS_SUCCESS) {
       MoxaCompleteRequest((PMOXA_DEVICE_EXTENSION)DeviceObject->
                            DeviceExtension, Irp, IO_NO_INCREMENT);
       return status;
    }
    if (MoxaCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {

        return STATUS_CANCELLED;

    }
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    status = STATUS_SUCCESS;
    if (irpSp->Parameters.QueryFile.FileInformationClass ==
        FileStandardInformation) {

        PFILE_STANDARD_INFORMATION buf = Irp->AssociatedIrp.SystemBuffer;
        buf->AllocationSize.QuadPart = 0;
        buf->EndOfFile = buf->AllocationSize;
        buf->NumberOfLinks = 0;
        buf->DeletePending = FALSE;
        buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } else if (irpSp->Parameters.QueryFile.FileInformationClass ==
               FilePositionInformation) {
        ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->
            CurrentByteOffset.QuadPart = 0;
        Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

    } else {

        status = STATUS_INVALID_PARAMETER;

    }

    Irp->IoStatus.Status = status;
    MoxaCompleteRequest((PMOXA_DEVICE_EXTENSION)DeviceObject->
                          DeviceExtension, Irp, 0);

    return status;

}

NTSTATUS
MoxaSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS status;

    PMOXA_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    if (Extension->ControlDevice) {        // Control Device
        status = STATUS_CANCELLED;

        Irp->IoStatus.Information = 0L;

        Irp->IoStatus.Status = status;

        IoCompleteRequest(
            Irp,
            0
            );
  
        return status;
    }
    if ((status = MoxaIRPPrologue(Irp,
                                    (PMOXA_DEVICE_EXTENSION)DeviceObject->
                                    DeviceExtension)) != STATUS_SUCCESS) {
       MoxaCompleteRequest((PMOXA_DEVICE_EXTENSION)DeviceObject->
                            DeviceExtension, Irp, IO_NO_INCREMENT);
       return status;
    }

    if (MoxaCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {
        return STATUS_CANCELLED;

    }
    Irp->IoStatus.Information = 0L;
    if ((IoGetCurrentIrpStackLocation(Irp)->
            Parameters.SetFile.FileInformationClass ==
         FileEndOfFileInformation) ||
        (IoGetCurrentIrpStackLocation(Irp)->
            Parameters.SetFile.FileInformationClass ==
         FileAllocationInformation)) {

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;

    }

    Irp->IoStatus.Status = status;
    MoxaCompleteRequest((PMOXA_DEVICE_EXTENSION)DeviceObject->
                          DeviceExtension, Irp, 0);
    return status;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\read.c ===
/*++

Module Name:

    read.c


Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
MoxaRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    NTSTATUS	status;
    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    if ((extension->ControlDevice == TRUE)||
	  (extension->DeviceIsOpened == FALSE) ||
	  (extension->PowerState != PowerDeviceD0) ) {
 	  Irp->IoStatus.Status = STATUS_CANCELLED;
    	  Irp->IoStatus.Information=0L;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_CANCELLED;
    }

//    MoxaKdPrint(MX_DBG_TRACE,("Enter MoxaRead\n"));

    if ((status = MoxaIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
    	  MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
        return status;
    }

    if (MoxaCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {

        return STATUS_CANCELLED;

    }

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length read.  If it is zero length
    // then we are already done!
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length) {

        //
        // Well it looks like we actually have to do some
        // work.  Put the read on the queue so that we can
        // process it when our previous reads are done.
        //

        return MoxaStartOrQueue(
                   extension,
                   Irp,
                   &extension->ReadQueue,
                   &extension->CurrentReadIrp,
                   MoxaStartRead
                   );

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;

        MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);

        return STATUS_SUCCESS;

    }
}

BOOLEAN
MoxaLineInput(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION extension = Context;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(extension->CurrentReadIrp);
    LIterminater = *(PUCHAR)extension->CurrentReadIrp->AssociatedIrp.SystemBuffer;
    LIbufferSize = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    LIdataBuffer = (PUCHAR)extension->CurrentReadIrp->AssociatedIrp.SystemBuffer;

    LIbase = extension->PortBase;
    LIofs = extension->PortOfs;
    LIbuff = LIbase + DynPage_addr;
    LIrptr = (PUSHORT)(LIofs + RXrptr);
    LIwptr = (PUSHORT)(LIofs + RXwptr);
    LIrxMask = *(PUSHORT)(LIofs + RX_mask);
    LIspage = *(PUSHORT)(LIofs + Page_rxb);
    LIepage = *(PUSHORT)(LIofs + EndPage_rxb);
    LIhead = *LIrptr;
    LItail = *LIwptr;

    LIcount = (LItail >= LIhead)  ? (LItail - LIhead)
                                  : (LItail - LIhead + LIrxMask + 1);

    if (!LIcount)             /* Rx buffer no data! */

        return FALSE;

    if (LIspage == LIepage) {

        LIbufHead = *(PUSHORT)(LIofs + Ofs_rxb);

        *(LIbase + Control_reg) = (UCHAR)LIspage;

        LIi = 0;
        do {
            LIi++;
            *LIdataBuffer = LIbuff[LIbufHead+LIhead++];
            LIhead &= LIrxMask;
            if (*LIdataBuffer == LIterminater)
                break;
            LIdataBuffer++;
//          if (LIhead == *LIwptr)
            if ( (LIhead == *LIwptr) && (LIi < LIbufferSize) )

                return FALSE;

        } while (LIi < LIbufferSize);
    }
    else {

        LIpageNo = LIspage + (LIhead >> 13);
        LIpageOfs = LIhead & Page_mask;

        *(LIbase + Control_reg) = (UCHAR)LIpageNo;

        LIi = 0;
        do {
            LIi++;
            *LIdataBuffer = LIbuff[LIpageOfs++];
            LIhead++;
            LIhead &= LIrxMask;

            if (*LIdataBuffer == LIterminater)
                break;

            LIdataBuffer++;

//          if (LIhead == *LIwptr)
            if ( (LIhead == *LIwptr) && (LIi < LIbufferSize) )

                return FALSE;

            if (LIpageOfs == Page_size) {
                if (++LIpageNo == LIepage)
                    LIpageNo = LIspage;
                *(LIbase + Control_reg) = (UCHAR)LIpageNo;
                LIpageOfs = 0;
            }
        } while (LIi < LIbufferSize);
    }

    *LIrptr = LIhead;

    extension->CurrentReadIrp->IoStatus.Information = LIi;

    extension->PerfStats.ReceivedCount += LIi; 

    if (*(LIofs + FlagStat) & Rx_xoff) {

        LIcount = (*LIwptr >= *LIrptr) ? (*LIwptr - *LIrptr)
                                       : (*LIwptr - *LIrptr + LIrxMask + 1);

        if (LIcount < extension->HandFlow.XonLimit)

            MoxaFuncWithDumbWait(LIofs, FC_SendXon, 0);

    }

    return FALSE;
}

BOOLEAN
MoxaView(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION extension = Context;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(extension->CurrentReadIrp);
    LIbufferSize = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    LIdataBuffer = (PUCHAR)extension->CurrentReadIrp->AssociatedIrp.SystemBuffer;

    LIbase = extension->PortBase;
    LIofs = extension->PortOfs;
    LIbuff = LIbase + DynPage_addr;
    LIrptr = (PUSHORT)(LIofs + RXrptr);
    LIwptr = (PUSHORT)(LIofs + RXwptr);
    LIrxMask = *(PUSHORT)(LIofs + RX_mask);
    LIspage = *(PUSHORT)(LIofs + Page_rxb);
    LIepage = *(PUSHORT)(LIofs + EndPage_rxb);
    LIhead = *LIrptr;
    LItail = *LIwptr;

    LIcount = (LItail >= LIhead)  ? (LItail - LIhead)
                                  : (LItail - LIhead + LIrxMask + 1);

    if (!LIcount)             /* Rx buffer no data! */

        return FALSE;

    if (LIcount > LIbufferSize)
        LIcount = (USHORT)LIbufferSize;
    LIlen = (USHORT)LIcount;

    if (LIspage == LIepage) {

        LIbufHead = *(PUSHORT)(LIofs + Ofs_rxb);

        *(LIbase + Control_reg) = (UCHAR)LIspage;

        if (LIhead & 1) {

            *LIdataBuffer++ = LIbuff[LIbufHead+LIhead++];
            LIhead &= LIrxMask;
            LIcount--;
        }
        LIcount2 = LIcount >> 1;

        while (LIcount2--) {

            *((PUSHORT)LIdataBuffer)++ = *(PUSHORT)&(LIbuff[LIbufHead+LIhead]);
            LIhead += 2;
            LIhead &= LIrxMask;
        }

        if (LIcount & 1) {

            *LIdataBuffer++ = LIbuff[LIbufHead+LIhead++];
            LIhead &= LIrxMask;
        }
    }
    else {

        LIpageNo = LIspage + (LIhead >> 13);
        LIpageOfs = LIhead & Page_mask;

        do {

            LIcnt = Page_size - LIpageOfs;

            if (LIcnt > LIcount)
                LIcnt = LIcount;

            LIcount -= LIcnt;

            if (LIcnt) {

                *(LIbase + Control_reg) = (UCHAR)LIpageNo;

                if (LIpageOfs & 1) {

                    *LIdataBuffer++ = LIbuff[LIpageOfs++];
                    LIcnt--;
                }

                LIcount2 = LIcnt >> 1;

                while (LIcount2--) {

                    *((PUSHORT)LIdataBuffer)++ = *(PUSHORT)&(LIbuff[LIpageOfs]);
                    LIpageOfs += 2;
                }

                if (LIcnt & 1)
                    *LIdataBuffer++ = LIbuff[LIpageOfs++];

            }
            if (LIcount == 0)
                break;

            if (++LIpageNo == LIepage)
                LIpageNo = LIspage;

            LIpageOfs = 0;

        } while (TRUE);
    }

    extension->CurrentReadIrp->IoStatus.Information = LIlen;

    return FALSE;
}

BOOLEAN
MoxaIn(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION extension = Context;

    extension->ReadCurrentChar = extension->CurrentReadIrp->AssociatedIrp.SystemBuffer;

    MoxaGetData(extension);

    return FALSE;

}

VOID
MoxaGetData(
    IN PMOXA_DEVICE_EXTENSION   Extension
    )
{
//KdPrint(("In MoxaGetData\n"));

    GDbase = Extension->PortBase;
    GDofs = Extension->PortOfs;
    GDbuff = GDbase + DynPage_addr;
    GDrptr = (PUSHORT)(GDofs + RXrptr);
    GDwptr = (PUSHORT)(GDofs + RXwptr);
    GDrxMask = *(PUSHORT)(GDofs + RX_mask);
    GDspage = *(PUSHORT)(GDofs + Page_rxb);
    GDepage = *(PUSHORT)(GDofs + EndPage_rxb);
    GDhead = *GDrptr;
    GDtail = *GDwptr;

    GDdataLen = Extension->NumberNeededForRead;

    GDreadChar = Extension->ReadCurrentChar;

    GDcount = (GDtail >= GDhead)  ? (GDtail - GDhead)
                                  : (GDtail - GDhead + GDrxMask + 1);

    if (!GDcount)             /* Rx buffer no data! */

        return;

    if (GDspage == GDepage) {

        GDbufHead = *(PUSHORT)(GDofs + Ofs_rxb);

        if (GDcount > GDdataLen)
            GDcount = (USHORT)GDdataLen;

        GDdataLen -= GDcount;

        GDlen = GDcount;

        *(GDbase + Control_reg) = (UCHAR)GDspage;

        if (GDhead & 1) {

            *GDreadChar++ = GDbuff[GDbufHead+GDhead++];
            GDhead &= GDrxMask;
            GDcount--;
        }
        GDcount2 = GDcount >> 1;

        while (GDcount2--) {

            *((PUSHORT)GDreadChar)++ = *(PUSHORT)&(GDbuff[GDbufHead+GDhead]);
            GDhead += 2;
            GDhead &= GDrxMask;
        }

        if (GDcount & 1) {

            *GDreadChar++ = GDbuff[GDbufHead+GDhead++];
            GDhead &= GDrxMask;
        }

        *GDrptr = GDhead;
    }
    else {

        if (GDcount > GDdataLen)
            GDcount = (USHORT)GDdataLen;

        GDdataLen -= GDcount;

        GDlen = GDcount;

        GDpageNo = GDspage + (GDhead >> 13);
        GDpageOfs = GDhead & Page_mask;

        do {

            GDcnt = Page_size - GDpageOfs;

            if (GDcnt > GDcount)
                GDcnt = GDcount;

            GDcount -= GDcnt;

            if (GDcnt) {

                *(GDbase + Control_reg) = (UCHAR)GDpageNo;

                if (GDpageOfs & 1) {

                    *GDreadChar++ = GDbuff[GDpageOfs++];
                    GDcnt--;
                }

                GDcount2 = GDcnt >> 1;

                while (GDcount2--) {

                    *((PUSHORT)GDreadChar)++ = *(PUSHORT)&(GDbuff[GDpageOfs]);
                    GDpageOfs += 2;
                }

                if (GDcnt & 1)
                    *GDreadChar++ = GDbuff[GDpageOfs++];

            }
            if (GDcount == 0)
                break;

            if (++GDpageNo == GDepage)
                GDpageNo = GDspage;

            GDpageOfs = 0;

        } while (TRUE);

        *GDrptr = (GDhead + GDlen) & GDrxMask;
    }

    Extension->NumberNeededForRead = GDdataLen;

    Extension->ReadCurrentChar = GDreadChar;

    Extension->CurrentReadIrp->IoStatus.Information += GDlen;

    Extension->PerfStats.ReceivedCount += GDlen; 
    if (*(GDofs + FlagStat) & Rx_xoff) {

        GDcount = (*GDwptr >= *GDrptr) ? (*GDwptr - *GDrptr)
                                       : (*GDwptr - *GDrptr + GDrxMask + 1);

        if (GDcount < Extension->HandFlow.XonLimit)

            MoxaFuncWithDumbWait(GDofs, FC_SendXon, 0);

    }
}


BOOLEAN
MoxaInSwitchToUser(
    IN PVOID Context
    )
{

    PMOXA_DEVICE_EXTENSION extension = Context;
    USHORT  max;

    *(PUSHORT)(extension->PortOfs + Rx_trigger) = 1;

    *(PUSHORT)(extension->PortOfs + HostStat) |= WakeupRxTrigger;
    MoxaGetData(extension);

    extension->ReadLength = extension->NumberNeededForRead;

    if (extension->NumberNeededForRead) {

/* 8-14-01 by William
        max = *(PUSHORT)(extension->PortOfs + RX_mask) - 128;
*/
        max = *(PUSHORT)(extension->PortOfs + RX_mask) - RX_offset;


        if (extension->NumberNeededForRead > max)

            *(PUSHORT)(extension->PortOfs + Rx_trigger) = max;

        else

            *(PUSHORT)(extension->PortOfs + Rx_trigger) = (USHORT)extension->NumberNeededForRead;

        MOXA_INC_REFERENCE(extension->CurrentReadIrp);

        extension->CountOnLastRead =
            extension->CurrentReadIrp->IoStatus.Information;

        extension->ReadByIsr = 0;

        IoSetCancelRoutine(
            extension->CurrentReadIrp,
            MoxaCancelCurrentRead
            );

        MOXA_INC_REFERENCE(extension->CurrentReadIrp);

    }
    else
        *(PSHORT)(extension->PortOfs + HostStat) &= ~WakeupRxTrigger;

    return FALSE;

}

NTSTATUS
MoxaStartRead(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{

    PIO_STACK_LOCATION irpSp;
    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG ioControlCode;
    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;


    do {

      irpSp = IoGetCurrentIrpStackLocation(Extension->CurrentReadIrp);
//
//          Check if MOXA_IOCTL_xxx request
//
      if (irpSp->MajorFunction != IRP_MJ_READ) {

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &controlIrql
                );

            IoAcquireCancelSpinLock(&oldIrql);

            if (Extension->CurrentReadIrp->Cancel) {

                Extension->CurrentReadIrp->IoStatus.Status =
                    STATUS_CANCELLED;

                IoReleaseCancelSpinLock(oldIrql);

                KeReleaseSpinLock(
                    &Extension->ControlLock,
                    controlIrql
                    );

                if (!setFirstStatus) {

                    firstStatus = STATUS_CANCELLED;
                    setFirstStatus = TRUE;
                }

            }
            else {

                ioControlCode =
                    irpSp->Parameters.DeviceIoControl.IoControlCode;

                if (ioControlCode == IOCTL_MOXA_LineInput)

                    KeSynchronizeExecution(
                        Extension->Interrupt,
                        MoxaLineInput,
                        Extension
                        );

                else

                    KeSynchronizeExecution(
                        Extension->Interrupt,
                        MoxaView,
                        Extension
                        );

                Extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

                IoReleaseCancelSpinLock(oldIrql);

                KeReleaseSpinLock(
                    &Extension->ControlLock,
                    controlIrql
                    );

                if (!setFirstStatus) {

                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;
                }
            }
      }
      else {
        Extension->NumberNeededForRead =
            IoGetCurrentIrpStackLocation(Extension->CurrentReadIrp)
                ->Parameters.Read.Length;

        useTotalTimer = FALSE;
        returnWithWhatsPresent = FALSE;
        os2ssreturn = FALSE;
        crunchDownToOne = FALSE;
        useIntervalTimer = FALSE;

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &controlIrql
            );

        timeoutsForIrp = Extension->Timeouts;

        KeReleaseSpinLock(
            &Extension->ControlLock,
            controlIrql
            );

        //
        // Calculate the interval timeout for the read.
        //
        if (timeoutsForIrp.ReadIntervalTimeout &&
            (timeoutsForIrp.ReadIntervalTimeout !=
             MAXULONG)) {

            useIntervalTimer = TRUE;

            Extension->IntervalTime.QuadPart =
                UInt32x32To64(
                    timeoutsForIrp.ReadIntervalTimeout,
                    10000
                    );


            if (Extension->IntervalTime.QuadPart >=
                Extension->CutOverAmount.QuadPart) {

                Extension->IntervalTimeToUse =
                    &Extension->LongIntervalAmount;

            } else {

                Extension->IntervalTimeToUse =
                    &Extension->ShortIntervalAmount;

            }

        }
        if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {

            //
            // We need to do special return quickly stuff here.
            //
            // 1) If both constant and multiplier are
            //    0 then we return immediately with whatever
            //    we've got, even if it was zero.
            //
            // 2) If constant and multiplier are not MAXULONG
            //    then return immediately if any characters
            //    are present, but if nothing is there, then
            //    use the timeouts as specified.
            //
            // 3) If multiplier is MAXULONG then do as in
            //    "2" but return when the first character
            //    arrives.
            //

            if (!timeoutsForIrp.ReadTotalTimeoutConstant &&
                !timeoutsForIrp.ReadTotalTimeoutMultiplier) {

                returnWithWhatsPresent = TRUE;

            } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                        &&
                       (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        != MAXULONG)) {

                useTotalTimer = TRUE;
                os2ssreturn = TRUE;
                multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

            } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                        &&
                       (timeoutsForIrp.ReadTotalTimeoutMultiplier
                        == MAXULONG)) {

                useTotalTimer = TRUE;
                os2ssreturn = TRUE;
                crunchDownToOne = TRUE;
                multiplierVal = 0;
                constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

            }

        } else {

            //
            // If both the multiplier and the constant are
            // zero then don't do any total timeout processing.
            //

            if (timeoutsForIrp.ReadTotalTimeoutMultiplier ||
                timeoutsForIrp.ReadTotalTimeoutConstant) {

                //
                // We have some timer values to calculate.
                //

                useTotalTimer = TRUE;
                multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

            }

        }
        if (useTotalTimer) {

            totalTime.QuadPart = ((LONGLONG)(UInt32x32To64(
                                      Extension->NumberNeededForRead,
                                      multiplierVal
                                      )
                                      + constantVal))
                                  * -10000;

        }

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &controlIrql
            );

        MOXA_INIT_REFERENCE(Extension->CurrentReadIrp);

        IoAcquireCancelSpinLock(&oldIrql);
        if (Extension->CurrentReadIrp->Cancel) {

            Extension->CurrentReadIrp->IoStatus.Status =
                STATUS_CANCELLED;

            Extension->CurrentReadIrp->IoStatus.Information = 0;

            IoReleaseCancelSpinLock(oldIrql);

            KeReleaseSpinLock(
                &Extension->ControlLock,
                controlIrql
                );

            if (!setFirstStatus) {

                firstStatus = STATUS_CANCELLED;
                setFirstStatus = TRUE;

            }

        }
        else {

            KeSynchronizeExecution(
                Extension->Interrupt,
                MoxaIn,
                Extension
                );
            if (returnWithWhatsPresent || (!Extension->NumberNeededForRead) ||
                (os2ssreturn &&
                 Extension->CurrentReadIrp->IoStatus.Information)) {

            //
            // We got all we needed for this read.
            //

                Extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

                IoReleaseCancelSpinLock(oldIrql);

                KeReleaseSpinLock(
                    &Extension->ControlLock,
                    controlIrql
                    );

                if (!setFirstStatus) {

                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;
                }
            }
            else {

                //
                // If we are supposed to crunch the read down to
                // one character, then update the read length
                // in the irp and truncate the number needed for
                // read down to one. Note that if we are doing
                // this crunching, then the information must be
                // zero (or we would have completed above) and
                // the number needed for the read must still be
                // equal to the read length.
                //

                if (crunchDownToOne) {

                    Extension->NumberNeededForRead = 1;
                    IoGetCurrentIrpStackLocation(
                            Extension->CurrentReadIrp
                            )->Parameters.Read.Length = 1;
                }
                KeSynchronizeExecution(
                    Extension->Interrupt,
                    MoxaInSwitchToUser,
                    Extension
                    );

                if (Extension->NumberNeededForRead) {

                    if (useTotalTimer) {

                        MOXA_INC_REFERENCE(Extension->CurrentReadIrp);

                        MoxaSetTimer(
                            &Extension->ReadRequestTotalTimer,
                            totalTime,
                            &Extension->TotalReadTimeoutDpc,
				    Extension
                            );

                    }

                    if (useIntervalTimer) {

                        MOXA_INC_REFERENCE(Extension->CurrentReadIrp);

                        KeQuerySystemTime(
                            &Extension->LastReadTime
                            );
                        MoxaSetTimer(
                            &Extension->ReadRequestIntervalTimer,
                            *Extension->IntervalTimeToUse,
                            &Extension->IntervalReadTimeoutDpc,
                            Extension
                            );


                    }

                    IoMarkIrpPending(Extension->CurrentReadIrp);

                    IoReleaseCancelSpinLock(oldIrql);

                    KeReleaseSpinLock(
                        &Extension->ControlLock,
                        controlIrql
                        );

                    if (!setFirstStatus) {

                        firstStatus = STATUS_PENDING;
                    }
                    return firstStatus;

                } else {

                    Extension->CurrentReadIrp->IoStatus.Status =
                        STATUS_SUCCESS;

                    IoReleaseCancelSpinLock(oldIrql);

                    KeReleaseSpinLock(
                        &Extension->ControlLock,
                        controlIrql
                        );

                    if (!setFirstStatus) {

                        firstStatus = STATUS_SUCCESS;
                        setFirstStatus = TRUE;
                    }
                }
            }
        }
      }
        //
        // Well the operation is complete.
        //

      MoxaGetNextIrp(
            &Extension->CurrentReadIrp,
            &Extension->ReadQueue,
            &newIrp,
            TRUE,
		Extension
            );

    } while (newIrp);

    return firstStatus;

}

VOID
MoxaCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    extension->CountOnLastRead = MOXA_COMPLETE_READ_CANCEL;

    MoxaTryToCompleteCurrent(
        extension,
        MoxaGrabReadFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        MoxaStartRead,
        MoxaGetNextIrp
        );

}

BOOLEAN
MoxaGrabReadFromIsr(
    IN PVOID Context
    )
{

    PMOXA_DEVICE_EXTENSION extension = Context;

    if (extension->ReadLength) {

        extension->CurrentReadIrp->IoStatus.Information =
            IoGetCurrentIrpStackLocation(
            extension->CurrentReadIrp
            )->Parameters.Read.Length -
            extension->ReadLength;

        *(PSHORT)(extension->PortOfs + HostStat) &= ~WakeupRxTrigger;

        extension->ReadLength = 0;

        MOXA_DEC_REFERENCE(extension->CurrentReadIrp);

    }

    return FALSE;

}

VOID
MoxaCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    extension->CountOnLastRead = MOXA_COMPLETE_READ_COMPLETE;

    MoxaTryToCompleteCurrent(
        extension,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        MoxaStartRead,
        MoxaGetNextIrp
        );

     MoxaDpcEpilogue(extension, Dpc);
}

VOID
MoxaReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    if (extension->CountOnLastRead == MOXA_COMPLETE_READ_COMPLETE) {

        MoxaTryToCompleteCurrent(
            extension,
            NULL,
            oldIrql,
            STATUS_SUCCESS,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            MoxaStartRead,
            MoxaGetNextIrp
            );
        MoxaDpcEpilogue(extension, Dpc);
        return;
    }

    if (MoxaCheckInQueue(extension)) {

        KeSynchronizeExecution(
            extension->Interrupt,
            MoxaPollGetData,
            extension
        );

        if (!extension->ReadLength) {
            extension->CountOnLastRead = MOXA_COMPLETE_READ_COMPLETE;

            MOXA_DEC_REFERENCE(extension->CurrentReadIrp);

            MoxaTryToCompleteCurrent(
                extension,
                NULL,
                oldIrql,
                STATUS_SUCCESS,
                &extension->CurrentReadIrp,
                &extension->ReadQueue,
                &extension->ReadRequestIntervalTimer,
                &extension->ReadRequestTotalTimer,
                MoxaStartRead,
                MoxaGetNextIrp
            );
            MoxaDpcEpilogue(extension, Dpc);
            return;
        }

    }


    extension->CountOnLastRead = MOXA_COMPLETE_READ_TOTAL;

    MoxaTryToCompleteCurrent(
        extension,
        MoxaGrabReadFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        MoxaStartRead,
        MoxaGetNextIrp
        );
    MoxaDpcEpilogue(extension, Dpc);

}

VOID
MoxaIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;
    USHORT count;

/*
PUCHAR base;
base = extension->PortBase;
*/
    IoAcquireCancelSpinLock(&oldIrql);

    if (extension->CountOnLastRead == MOXA_COMPLETE_READ_TOTAL) {

        MoxaTryToCompleteCurrent(
            extension,
            MoxaGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            MoxaStartRead,
            MoxaGetNextIrp
            );

    }
    else if (extension->CountOnLastRead == MOXA_COMPLETE_READ_COMPLETE) {

        MoxaTryToCompleteCurrent(
            extension,
            NULL,
            oldIrql,
            STATUS_SUCCESS,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            MoxaStartRead,
            MoxaGetNextIrp
            );

    }
    else if (extension->CountOnLastRead == MOXA_COMPLETE_READ_CANCEL) {

        MoxaTryToCompleteCurrent(
            extension,
            MoxaGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            MoxaStartRead,
            MoxaGetNextIrp
            );

    }
    else {

        if (extension->CountOnLastRead) {
//base[0x300]++;

            IRTofs = extension->PortOfs;
            IRTrptr = (PUSHORT)(IRTofs + RXrptr);
            IRTwptr = (PUSHORT)(IRTofs + RXwptr);
            IRTrxMask = *(PUSHORT)(IRTofs + RX_mask);

            count = (*IRTwptr >= *IRTrptr) ? (*IRTwptr - *IRTrptr)
                                : (*IRTwptr - *IRTrptr + IRTrxMask + 1);

            if (count > extension->ReadByIsr) {
//base[0x301]++;

                extension->ReadByIsr = count;

                KeQuerySystemTime(
                    &extension->LastReadTime
                    );

                MoxaSetTimer(
                    &extension->ReadRequestIntervalTimer,
                    *extension->IntervalTimeToUse,
                    &extension->IntervalReadTimeoutDpc,
                    extension
                    );


                IoReleaseCancelSpinLock(oldIrql);

            }
            else {

                LARGE_INTEGER currentTime;
//base[0x302]++;

                KeQuerySystemTime(
                    &currentTime
                    );
                if ((currentTime.QuadPart - extension->LastReadTime.QuadPart) >=
                    extension->IntervalTime.QuadPart) {

//base[0x303]++;


                    if (MoxaCheckInQueue(extension)) {
//base[0x304]++;

                        KeSynchronizeExecution(
                            extension->Interrupt,
                            MoxaPollGetData,
                            extension
                        );

                        if (!extension->ReadLength) {
//base[0x305]++;

                            extension->CountOnLastRead =
                                MOXA_COMPLETE_READ_COMPLETE;

                            MOXA_DEC_REFERENCE(extension->CurrentReadIrp);

                            MoxaTryToCompleteCurrent(
                                extension,
                                NULL,
                                oldIrql,
                                STATUS_SUCCESS,
                                &extension->CurrentReadIrp,
                                &extension->ReadQueue,
                                &extension->ReadRequestIntervalTimer,
                                &extension->ReadRequestTotalTimer,
                                MoxaStartRead,
                                MoxaGetNextIrp
                            );
                            MoxaDpcEpilogue(extension, Dpc);
                            return;
                        }

                    }
//base[0x306]++;

                    MoxaTryToCompleteCurrent(
                        extension,
                        MoxaGrabReadFromIsr,
                        oldIrql,
                        STATUS_TIMEOUT,
                        &extension->CurrentReadIrp,
                        &extension->ReadQueue,
                        &extension->ReadRequestIntervalTimer,
                        &extension->ReadRequestTotalTimer,
                        MoxaStartRead,
                        MoxaGetNextIrp
                        );

                }
                else {
//base[0x307]++;

                    MoxaSetTimer(
                        &extension->ReadRequestIntervalTimer,
                        *extension->IntervalTimeToUse,
                        &extension->IntervalReadTimeoutDpc,
                        extension
                        );

                    IoReleaseCancelSpinLock(oldIrql);

                }
            }
        }
        else {
//base[0x308]++;

            IRTofs = extension->PortOfs;
            IRTrptr = (PUSHORT)(IRTofs + RXrptr);
            IRTwptr = (PUSHORT)(IRTofs + RXwptr);
            IRTrxMask = *(PUSHORT)(IRTofs + RX_mask);

            count = (*IRTwptr >= *IRTrptr) ? (*IRTwptr - *IRTrptr)
                                : (*IRTwptr - *IRTrptr + IRTrxMask + 1);

            if (count) {
//base[0x309]++;
                extension->CountOnLastRead = count;
                extension->ReadByIsr = count;
                KeQuerySystemTime(
                        &extension->LastReadTime
                        );
            }

            MoxaSetTimer(
                &extension->ReadRequestIntervalTimer,
                *extension->IntervalTimeToUse,
                &extension->IntervalReadTimeoutDpc,
                extension
                );


            IoReleaseCancelSpinLock(oldIrql);

        }
    }
    MoxaDpcEpilogue(extension, Dpc);
}

BOOLEAN
MoxaCheckInQueue(
    IN PMOXA_DEVICE_EXTENSION   Extension
    )
{

    PUCHAR  ofs;
    PUSHORT rptr, wptr;

    ofs = Extension->PortOfs;
    GDrptr = (PUSHORT)(ofs + RXrptr);
    GDwptr = (PUSHORT)(ofs + RXwptr);
    if (*GDrptr != *GDwptr)
        return TRUE;
    else
        return FALSE;
}

BOOLEAN
MoxaPollGetData(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION extension = Context;
    PIO_STACK_LOCATION irpSp;

    MoxaGetData(extension);

    extension->ReadLength = extension->NumberNeededForRead;

    if (!extension->ReadLength) {

        *(PSHORT)(extension->PortOfs + HostStat) &= ~WakeupRxTrigger;

        irpSp = IoGetCurrentIrpStackLocation(
                    extension->CurrentReadIrp);
        extension->CurrentReadIrp->IoStatus.Information =
                    irpSp->Parameters.Read.Length;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\serlog.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Abstract:

    Constant definitions for the I/O error code log values.

--*/

#ifndef _SERLOG_
#define _SERLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SERIAL_KERNEL_DEBUGGER_ACTIVE
//
// MessageText:
//
//  The kernel debugger is already using %2.
//
#define SERIAL_KERNEL_DEBUGGER_ACTIVE    ((NTSTATUS)0x40060001L)

//
// MessageId: SERIAL_FIFO_PRESENT
//
// MessageText:
//
//  While validating that %2 was really a serial port.
//
#define SERIAL_FIFO_PRESENT              ((NTSTATUS)0x40060002L)

//
// MessageId: SERIAL_USER_OVERRIDE
//
// MessageText:
//
//  User configuration data for parameter %2 overriding firmware configuration data.
//
#define SERIAL_USER_OVERRIDE             ((NTSTATUS)0x40060003L)

//
// MessageId: SERIAL_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %2.
//
#define SERIAL_NO_SYMLINK_CREATED        ((NTSTATUS)0x80060004L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_CREATED     ((NTSTATUS)0x80060005L)

//
// MessageId: SERIAL_NO_DEVICE_MAP_DELETED
//
// MessageText:
//
//  Unable to delete the device map entry for %2.
//
#define SERIAL_NO_DEVICE_MAP_DELETED     ((NTSTATUS)0x80060006L)

//
// MessageId: SERIAL_UNREPORTED_IRQL_CONFLICT
//
// MessageText:
//
//  Another driver on the system, which did not report its resources, has already claimed the interrupt used by %2.
//
#define SERIAL_UNREPORTED_IRQL_CONFLICT  ((NTSTATUS)0xC0060007L)

//
// MessageId: SERIAL_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough resources were available for the driver.
//
#define SERIAL_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0060008L)

//
// MessageId: SERIAL_UNSUPPORTED_CLOCK_RATE
//
// MessageText:
//
//  The baud clock rate configuration is not supported on device %2.
//
#define SERIAL_UNSUPPORTED_CLOCK_RATE    ((NTSTATUS)0xC0060009L)

//
// MessageId: SERIAL_REGISTERS_NOT_MAPPED
//
// MessageText:
//
//  The hardware locations for %2 could not be translated to something the memory management system could understand.
//
#define SERIAL_REGISTERS_NOT_MAPPED      ((NTSTATUS)0xC006000AL)

//
// MessageId: SERIAL_RESOURCE_CONFLICT
//
// MessageText:
//
//  The hardware resources for %2 are already in use by another device.
//
#define SERIAL_RESOURCE_CONFLICT         ((NTSTATUS)0xC006000BL)

//
// MessageId: SERIAL_NO_BUFFER_ALLOCATED
//
// MessageText:
//
//  No memory could be allocated in which to place new data for %2.
//
#define SERIAL_NO_BUFFER_ALLOCATED       ((NTSTATUS)0xC006000CL)

//
// MessageId: SERIAL_IER_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the interrupt enable register contained enabled bits in a must be zero bitfield.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_IER_INVALID               ((NTSTATUS)0xC006000DL)

//
// MessageId: SERIAL_MCR_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the modem control register contained enabled bits in a must be zero bitfield.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_MCR_INVALID               ((NTSTATUS)0xC006000EL)

//
// MessageId: SERIAL_IIR_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the interrupt id register contained enabled bits in a must be zero bitfield.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_IIR_INVALID               ((NTSTATUS)0xC006000FL)

//
// MessageId: SERIAL_DL_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the baud rate register could not be set consistantly.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_DL_INVALID                ((NTSTATUS)0xC0060010L)

//
// MessageId: SERIAL_NOT_ENOUGH_CONFIG_INFO
//
// MessageText:
//
//  Some firmware configuration information was incomplete.
//
#define SERIAL_NOT_ENOUGH_CONFIG_INFO    ((NTSTATUS)0xC0060011L)

//
// MessageId: SERIAL_NO_PARAMETERS_INFO
//
// MessageText:
//
//  No Parameters subkey was found for user defined data.  This is odd, and it also means no user configuration can be found.
//
#define SERIAL_NO_PARAMETERS_INFO        ((NTSTATUS)0xC0060012L)

//
// MessageId: SERIAL_UNABLE_TO_ACCESS_CONFIG
//
// MessageText:
//
//  Specific user configuration data is unretrievable.
//
#define SERIAL_UNABLE_TO_ACCESS_CONFIG   ((NTSTATUS)0xC0060013L)

//
// MessageId: SERIAL_INVALID_PORT_INDEX
//
// MessageText:
//
//  On parameter %2 which indicates a multiport card, must have a port index specified greater than 0.
//
#define SERIAL_INVALID_PORT_INDEX        ((NTSTATUS)0xC0060014L)

//
// MessageId: SERIAL_PORT_INDEX_TOO_HIGH
//
// MessageText:
//
//  On parameter %2 which indicates a multiport card, the port index for the multiport card is too large.
//
#define SERIAL_PORT_INDEX_TOO_HIGH       ((NTSTATUS)0xC0060015L)

//
// MessageId: SERIAL_UNKNOWN_BUS
//
// MessageText:
//
//  The bus type for %2 is not recognizable.
//
#define SERIAL_UNKNOWN_BUS               ((NTSTATUS)0xC0060016L)

//
// MessageId: SERIAL_BUS_NOT_PRESENT
//
// MessageText:
//
//  The bus type for %2 is not available on this computer.
//
#define SERIAL_BUS_NOT_PRESENT           ((NTSTATUS)0xC0060017L)

//
// MessageId: SERIAL_BUS_INTERRUPT_CONFLICT
//
// MessageText:
//
//  The bus specified for %2 does not support the specified method of interrupt.
//
#define SERIAL_BUS_INTERRUPT_CONFLICT    ((NTSTATUS)0xC0060018L)

//
// MessageId: SERIAL_INVALID_USER_CONFIG
//
// MessageText:
//
//  Can not find any configured MOXA Smartio/Industio  series board.
//
#define SERIAL_INVALID_USER_CONFIG       ((NTSTATUS)0xC0060019L)

//
// MessageId: SERIAL_DEVICE_TOO_HIGH
//
// MessageText:
//
//  The user specified port for %2 is way too high in physical memory.
//
#define SERIAL_DEVICE_TOO_HIGH           ((NTSTATUS)0xC006001AL)

//
// MessageId: SERIAL_STATUS_TOO_HIGH
//
// MessageText:
//
//  The status port for %2 is way too high in physical memory.
//
#define SERIAL_STATUS_TOO_HIGH           ((NTSTATUS)0xC006001BL)

//
// MessageId: SERIAL_STATUS_CONTROL_CONFLICT
//
// MessageText:
//
//  The status port for %2 overlaps the control registers for the device.
//
#define SERIAL_STATUS_CONTROL_CONFLICT   ((NTSTATUS)0xC006001CL)

//
// MessageId: SERIAL_CONTROL_OVERLAP
//
// MessageText:
//
//  The control registers for %2 overlaps with the %3 control registers.
//
#define SERIAL_CONTROL_OVERLAP           ((NTSTATUS)0xC006001DL)

//
// MessageId: SERIAL_STATUS_OVERLAP
//
// MessageText:
//
//  The status register for %2 overlaps the %3 control registers.
//
#define SERIAL_STATUS_OVERLAP            ((NTSTATUS)0xC006001EL)

//
// MessageId: SERIAL_STATUS_STATUS_OVERLAP
//
// MessageText:
//
//  The status register for %2 overlaps with the %3 status register.
//
#define SERIAL_STATUS_STATUS_OVERLAP     ((NTSTATUS)0xC006001FL)

//
// MessageId: SERIAL_CONTROL_STATUS_OVERLAP
//
// MessageText:
//
//  The control registers for %2 overlaps the %3 status register.
//
#define SERIAL_CONTROL_STATUS_OVERLAP    ((NTSTATUS)0xC0060020L)

//
// MessageId: SERIAL_MULTI_INTERRUPT_CONFLICT
//
// MessageText:
//
//  Two ports, %2 and %3, on a single multiport card can't have two different interrupts.
//
#define SERIAL_MULTI_INTERRUPT_CONFLICT  ((NTSTATUS)0xC0060021L)

//
// MessageId: SERIAL_DISABLED_PORT
//
// MessageText:
//
//  Disabling %2 as requested by the configuration data.
//
#define SERIAL_DISABLED_PORT             ((NTSTATUS)0x40060022L)

//
// MessageId: SERIAL_GARBLED_PARAMETER
//
// MessageText:
//
//  Parameter %2 data is unretrievable from the registry.
//
#define SERIAL_GARBLED_PARAMETER         ((NTSTATUS)0xC0060023L)

//
// MessageId: SERIAL_DLAB_INVALID
//
// MessageText:
//
//  While validating that %2 was really a serial port, the contents of the divisor latch register was identical to the interrupt enable and the recieve registers.
//  The device is assumed not to be a serial port and will be deleted.
//
#define SERIAL_DLAB_INVALID              ((NTSTATUS)0xC0060024L)

//
// MessageId: SERIAL_INVALID_MOXA_BOARDS
//
// MessageText:
//
//  Can not find any MOXA Smartio/Industio  series board.
//
#define SERIAL_INVALID_MOXA_BOARDS       ((NTSTATUS)0xC0060025L)

//
// MessageId: SERIAL_INVALID_COM_NUMBER
//
// MessageText:
//
//  The COM number(COM %2) of the %3  board conflicts with others.
//
#define SERIAL_INVALID_COM_NUMBER        ((NTSTATUS)0xC0060026L)

//
// MessageId: SERIAL_PORT_FOUND
//
// MessageText:
//
//  Serial  port %2, has been enabled.
//
#define SERIAL_PORT_FOUND                ((NTSTATUS)0x40060027L)

//
// MessageId: SERIAL_INVALID_IRQ_NUMBER
//
// MessageText:
//
//  %2, with first serial  port %3, IRQ number is invalid.
//
#define SERIAL_INVALID_IRQ_NUMBER        ((NTSTATUS)0xC0060028L)

//
// MessageId: SERIAL_INVALID_ASIC_BOARD
//
// MessageText:
//
//  Can not find the configured %2  board (CAP=%3)!
//
#define SERIAL_INVALID_ASIC_BOARD        ((NTSTATUS)0xC0060029L)

#endif /* _NTIOLOGC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\bindrop\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\spx.inf: $(_INX)\spx.inx $(_LNG)\spx.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@

$(O)\spxports.inf: $(_INX)\spxports.inx $(_LNG)\spxports.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\wmi.c ===
/*++

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"
#include <wmistr.h>


NTSTATUS
MoxaSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PMOXA_DEVICE_EXTENSION pDevExt
      = (PMOXA_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
 

   MoxaKdPrint(MX_DBG_TRACE,("Enter MoxaSystemControlDispatch\n"));
    status = WmiSystemControl(   &pDevExt->WmiLibInfo,
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            MoxaKdPrint(MX_DBG_TRACE,("-----IrpProcessed\n"));
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            MoxaKdPrint(MX_DBG_TRACE,("-----IrpNotCompleted\n"));

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            MoxaKdPrint(MX_DBG_TRACE,("-----IrpForward or IrpNotWmi (disposition=%x)\n",disposition));
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            MoxaKdPrint(MX_DBG_TRACE,("-----Default Case (disposition=%x)\n",disposition));
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }        
    }
    
    return(status);

}


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4
#define WMI_MOXA_PORT_STATUS       5

GUID SerialPortNameGuid = SERIAL_PORT_WMI_NAME_GUID;
GUID SerialPortCommGuid = SERIAL_PORT_WMI_COMM_GUID;
GUID SerialPortHWGuid = SERIAL_PORT_WMI_HW_GUID;
GUID SerailPortPerfGuid = SERIAL_PORT_WMI_PERF_GUID;
GUID SerialPortPropertiesGuid = SERIAL_PORT_WMI_PROPERTIES_GUID;
GUID MoxaPortModemStatusGuid = MOXA_WMI_PORT_STATUS_GUID;

WMIGUIDREGINFO MoxaWmiGuidList[MOXA_WMI_GUID_LIST_SIZE] =
{
    { &SerialPortNameGuid, 1, 0 },
    { &SerialPortCommGuid, 1, 0 },
    { &SerialPortHWGuid, 1, 0 },
    { &SerailPortPerfGuid, 1, 0 },
    { &SerialPortPropertiesGuid, 1, 0},
    { &MoxaPortModemStatusGuid, 1, 0}
};

//
// WMI System Call back functions
//




NTSTATUS
MoxaTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex)
{
   PMOXA_DEVICE_EXTENSION pDevExt;
   NTSTATUS status;
  
   pDevExt = (PMOXA_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   switch (GuidIndex) {

   case WMI_SERIAL_PORT_NAME_INFORMATION:
   case WMI_SERIAL_PORT_COMM_INFORMATION:
   case WMI_SERIAL_PORT_HW_INFORMATION:
   case WMI_SERIAL_PORT_PERF_INFORMATION:
   case WMI_SERIAL_PORT_PROPERTIES:
   case WMI_MOXA_PORT_STATUS:

      status = STATUS_INVALID_DEVICE_REQUEST;
      break;

   default:
      status = STATUS_WMI_GUID_NOT_FOUND;
      break;
   }

   status = WmiCompleteRequest(PDevObj, PIrp,
                                 status, 0, IO_NO_INCREMENT);

   return status;
}



NTSTATUS
MoxaSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    PBuffer has the new values for the data item


Return Value:

    status

--*/
{
  
   //
   // Toss this request -- we don't support anything for it
   //

   return MoxaTossWMIRequest(PDevObj, PIrp, GuidIndex);
}



NTSTATUS
MoxaSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    PBuffer has the new values for the data block


Return Value:

    status

--*/
{
  
   //
   // Toss this request -- we don't support anything for it
   //

   return MoxaTossWMIRequest(PDevObj, PIrp, GuidIndex);
}



NTSTATUS
MoxaQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex, 
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    PBuffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG size = 0;
    PMOXA_DEVICE_EXTENSION pDevExt
       = (PMOXA_DEVICE_EXTENSION)PDevObj->DeviceExtension;

  
    switch (GuidIndex) {
    case WMI_SERIAL_PORT_NAME_INFORMATION:
       size = pDevExt->WmiIdentifier.Length;

       if (OutBufferSize < (size + sizeof(USHORT))) {
            size += sizeof(USHORT);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

       if (pDevExt->WmiIdentifier.Buffer == NULL) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           break;
        }

        //
        // First, copy the string over containing our identifier
        //

        *(USHORT *)PBuffer = (USHORT)size;
        (UCHAR *)PBuffer += sizeof(USHORT);

        RtlCopyMemory(PBuffer, pDevExt->WmiIdentifier.Buffer, size);

        //
        // Increment total size to include the WORD containing our len
        //

        size += sizeof(USHORT);
        *InstanceLengthArray = size;
                
        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
       size = sizeof(SERIAL_WMI_COMM_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
        }

        *InstanceLengthArray = size;
        *(PSERIAL_WMI_COMM_DATA)PBuffer = pDevExt->WmiCommData;

        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_HW_INFORMATION:
       size = sizeof(SERIAL_WMI_HW_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
       }

       *InstanceLengthArray = size;
       *(PSERIAL_WMI_HW_DATA)PBuffer = pDevExt->WmiHwData;

       status = STATUS_SUCCESS;

       break;

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
    {
	SERIAL_WMI_PERF_DATA wmiPerfStats;

      size = sizeof(SERIAL_WMI_PERF_DATA);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
 
	wmiPerfStats.ReceivedCount = pDevExt->PerfStats.ReceivedCount;
	wmiPerfStats.TransmittedCount = pDevExt->PerfStats.TransmittedCount;
	wmiPerfStats.FrameErrorCount = pDevExt->PerfStats.FrameErrorCount;
	wmiPerfStats.SerialOverrunErrorCount = pDevExt->PerfStats.SerialOverrunErrorCount;
	wmiPerfStats.BufferOverrunErrorCount = pDevExt->PerfStats.BufferOverrunErrorCount;
	wmiPerfStats.ParityErrorCount = pDevExt->PerfStats.ParityErrorCount;

      *(PSERIAL_WMI_PERF_DATA)PBuffer = wmiPerfStats;

      status = STATUS_SUCCESS;

      break;
    }

    case WMI_SERIAL_PORT_PROPERTIES: 
      size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
      MoxaGetProperties(
                pDevExt,
                (PSERIAL_COMMPROP)PBuffer
                );
    	
      *((PULONG)(((PSERIAL_COMMPROP)PBuffer)->ProvChar)) = 0;



      status = STATUS_SUCCESS;

      break;

    case WMI_MOXA_PORT_STATUS:
      size = sizeof(MOXA_WMI_PORT_STATUS) + sizeof(ULONG);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
    	MoxaFuncGetLineStatus(
				     pDevExt->PortOfs,
				     (PUSHORT)&(((PMOXA_WMI_PORT_STATUS)PBuffer)->LineStatus)
				     );
      ((PMOXA_WMI_PORT_STATUS)PBuffer)->LineStatus |= ((MoxaFlagBit[pDevExt->PortNo] & 3) << 4);
      ((PMOXA_WMI_PORT_STATUS)PBuffer)->FlowControl = (USHORT)((pDevExt->HandFlow.ControlHandShake
                             & SERIAL_CTS_HANDSHAKE) |
                             (pDevExt->HandFlow.FlowReplace &
                             (SERIAL_RTS_HANDSHAKE | SERIAL_AUTO_TRANSMIT |
                             SERIAL_AUTO_RECEIVE)));

	
      status = STATUS_SUCCESS;

      break;



    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( PDevObj, PIrp,
                                  status, size, IO_NO_INCREMENT);

    return status;
}



NTSTATUS
MoxaQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo)
                                                  
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
   PMOXA_DEVICE_EXTENSION pDevExt
       = (PMOXA_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   
   *PRegFlags = WMIREG_FLAG_INSTANCE_PDO;
   *PRegistryPath = &MoxaGlobalData->RegistryPath;
   *Pdo = pDevExt->Pdo;
    RtlInitUnicodeString(MofResourceName,L"MofResource");

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\write.c ===
/*++

Module Name:

    write.c

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
MoxaWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS	status;
    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

//   MoxaKdPrint(MX_DBG_TRACE,("Enter MoxaWrite\n"));
    if ((extension->ControlDevice == TRUE)||
	  (extension->DeviceIsOpened == FALSE) ||
	  (extension->PowerState != PowerDeviceD0) ) {

 	  Irp->IoStatus.Status = STATUS_CANCELLED;
    	  Irp->IoStatus.Information=0L;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_CANCELLED;
    }

    if ((status = MoxaIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
        MoxaCompleteRequest(extension, Irp, IO_NO_INCREMENT);
        return status;
    }


    if (MoxaCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {

        return STATUS_CANCELLED;

    }

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) {

        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //

        return MoxaStartOrQueue(
                    extension,
                    Irp,
                    &extension->WriteQueue,
                    &extension->CurrentWriteIrp,
                    MoxaStartWrite
                    );

    }

    else {

        Irp->IoStatus.Status = STATUS_SUCCESS;

        MoxaCompleteRequest(
		extension,
            Irp,
            0
            );

        return STATUS_SUCCESS;

    }
}

NTSTATUS
MoxaStartWrite(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{

    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;
    LARGE_INTEGER totalTime;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN useATimer;
    SERIAL_TIMEOUTS timeouts;
    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;

    do {

        irpSp = IoGetCurrentIrpStackLocation(
                            Extension->CurrentWriteIrp
                            );
//
//          Check if MOXA_IOCTL_PutB request
//
      if (irpSp->MajorFunction != IRP_MJ_WRITE) {

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &controlIrql
            );

        IoAcquireCancelSpinLock(&oldIrql);

        if (Extension->CurrentWriteIrp->Cancel) {

            Extension->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            IoReleaseCancelSpinLock(oldIrql);

            KeReleaseSpinLock(
                &Extension->ControlLock,
                controlIrql
                );

            if (!setFirstStatus) {

                firstStatus = STATUS_CANCELLED;
                setFirstStatus = TRUE;

            }
        }
        else {

            KeSynchronizeExecution(
                Extension->Interrupt,
                MoxaPutB,
                Extension
                );

            if (!setFirstStatus) {

                setFirstStatus = TRUE;
                firstStatus = STATUS_SUCCESS;

            }

            Extension->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

            Extension->CurrentWriteIrp->IoStatus.Information = sizeof(ULONG);

            IoReleaseCancelSpinLock(oldIrql);

            KeReleaseSpinLock(
                &Extension->ControlLock,
                controlIrql
                );
        }
      }
      else {
/*
 *      Extension->TotalCharsQueued NOT include current write
 *
 */
        IoAcquireCancelSpinLock(&oldIrql);

        Extension->TotalCharsQueued -=
                IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
                    ->Parameters.Write.Length;

        IoReleaseCancelSpinLock(oldIrql);

        useATimer = FALSE;

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &controlIrql
            );

        timeouts = Extension->Timeouts;

        KeReleaseSpinLock(
            &Extension->ControlLock,
            controlIrql
            );

        if (timeouts.WriteTotalTimeoutConstant ||
            timeouts.WriteTotalTimeoutMultiplier) {

            useATimer = TRUE;

            totalTime = RtlEnlargedUnsignedMultiply(
                            irpSp->Parameters.Write.Length,
                            timeouts.WriteTotalTimeoutMultiplier
                            );

            totalTime = RtlLargeIntegerAdd(
                            totalTime,
                            RtlConvertUlongToLargeInteger(
                                timeouts.WriteTotalTimeoutConstant
                                )
                            );

            totalTime = RtlExtendedIntegerMultiply(
                            totalTime,
                            -10000
                            );

        }

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &controlIrql
            );

        MOXA_INIT_REFERENCE(Extension->CurrentWriteIrp);

        IoAcquireCancelSpinLock(&oldIrql);

        if (Extension->CurrentWriteIrp->Cancel) {

            Extension->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            IoReleaseCancelSpinLock(oldIrql);

            KeReleaseSpinLock(
                &Extension->ControlLock,
                controlIrql
                );

            if (!setFirstStatus) {

                firstStatus = STATUS_CANCELLED;
                setFirstStatus = TRUE;

            }
        }
        else {

            KeSynchronizeExecution(
                Extension->Interrupt,
                MoxaOut,
                Extension
                );

            if (WRcompFlag) {   /* complete write */

                if (!setFirstStatus) {

                    setFirstStatus = TRUE;
                    firstStatus = STATUS_SUCCESS;

                }

                Extension->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

                Extension->CurrentWriteIrp->IoStatus.Information =
                                        irpSp->Parameters.Write.Length;

                IoReleaseCancelSpinLock(oldIrql);

                KeReleaseSpinLock(
                    &Extension->ControlLock,
                    controlIrql
                    );

            }
            else {
                if (!setFirstStatus) {

                    IoMarkIrpPending(Extension->CurrentWriteIrp);
                    setFirstStatus = TRUE;
                    firstStatus = STATUS_PENDING;

                }

                IoSetCancelRoutine(
                    Extension->CurrentWriteIrp,
                    MoxaCancelCurrentWrite
                    );

                MOXA_INC_REFERENCE(Extension->CurrentWriteIrp);

                if (useATimer) {

                    MoxaSetTimer(
                        &Extension->WriteRequestTotalTimer,
                        totalTime,
                        &Extension->TotalWriteTimeoutDpc,
    				Extension
                        );

                    MOXA_INC_REFERENCE(Extension->CurrentWriteIrp);
                }

                IoReleaseCancelSpinLock(oldIrql);

                KeReleaseSpinLock(
                    &Extension->ControlLock,
                    controlIrql
                    );

                break;
            }

        }
      }

      MoxaGetNextWrite(
            &Extension->CurrentWriteIrp,
            &Extension->WriteQueue,
            &newIrp,
            TRUE,
		Extension
            );

    } while (newIrp);

    return firstStatus;

}


BOOLEAN
MoxaPutB(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION extension = Context;
    PMOXA_IOCTL_PUTB    Pb;
/*
    PUCHAR  base, ofs, buff, writeChar;
    PUSHORT rptr, wptr;
    USHORT  txMask, spage, epage, bufHead;
    USHORT  tail, head, count, count2;
    USHORT  cnt, pageNo, pageOfs;
    ULONG   dataLen;
*/

    Pb = (PMOXA_IOCTL_PUTB)extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer;
    PBdataLen = Pb->DataLen;
    PBwriteChar = Pb->DataBuffer;

    PBbase = extension->PortBase;
    PBofs = extension->PortOfs;
    PBbuff = PBbase + DynPage_addr;
    PBrptr = (PUSHORT)(PBofs + TXrptr);
    PBwptr = (PUSHORT)(PBofs + TXwptr);
    PBtxMask = *(PUSHORT)(PBofs + TX_mask);
    PBspage = *(PUSHORT)(PBofs + Page_txb);
    PBepage = *(PUSHORT)(PBofs + EndPage_txb);
    PBtail = *PBwptr;
    PBhead = *PBrptr;

    PBcount = (PBhead > PBtail)   ? (PBhead - PBtail - 1)
                                  : (PBhead - PBtail + PBtxMask);

    if (PBcount < PBdataLen) {      /* Tx buffer no enough space! */

        *(PULONG)extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer = 0;
        return FALSE;
    }

    if (PBspage == PBepage) {

        PBbufHead = *(PUSHORT)(PBofs + Ofs_txb);

        PBcount = (USHORT)PBdataLen;

        *(PBbase + Control_reg) = (UCHAR)PBspage;

        if (PBtail & 1) {

            PBbuff[PBbufHead+PBtail++] = *PBwriteChar++;
            PBtail &= PBtxMask;
            PBcount--;
        }
        PBcount2 = PBcount >> 1;

        while (PBcount2--) {

            *(PUSHORT)&(PBbuff[PBbufHead+PBtail]) = *((PUSHORT)PBwriteChar)++;
            PBtail += 2;
            PBtail &= PBtxMask;
        }

        if (PBcount & 1) {

            PBbuff[PBbufHead+PBtail++] = *PBwriteChar++;
            PBtail &= PBtxMask;
        }

        *PBwptr = PBtail;

        *(PBofs + CD180TXirq) = 1;     /* start to send */
    }
    else {

        PBcount = (USHORT)PBdataLen;
        PBpageNo = PBspage + (PBtail >> 13);
        PBpageOfs = PBtail & Page_mask;

        do {

            PBcnt = Page_size - PBpageOfs;

            if (PBcnt > PBcount)
                PBcnt = PBcount;

            PBcount -= PBcnt;

            if (PBcnt) {

                *(PBbase + Control_reg) = (UCHAR)PBpageNo;

                if (PBpageOfs & 1) {

                    PBbuff[PBpageOfs++] = *PBwriteChar++;
                    PBcnt--;
                }

                PBcount2 = PBcnt >> 1;

                while (PBcount2--) {
                    *(PUSHORT)&(PBbuff[PBpageOfs]) = *((PUSHORT)PBwriteChar)++;
                    PBpageOfs += 2;
                }
                if (PBcnt & 1)
                    PBbuff[PBpageOfs++] = *PBwriteChar++;

            }
            if (PBcount == 0)
                break;

            if (++PBpageNo == PBepage)
                PBpageNo = PBspage;

            PBpageOfs = 0;

        } while (TRUE);

        *PBwptr = (USHORT)((PBtail + PBdataLen) & PBtxMask);

        *(PBofs + CD180TXirq) = 1;        /* start to send */
    }

    extension->PerfStats.TransmittedCount += PBdataLen; 

    return FALSE;
}


BOOLEAN
MoxaOut(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION extension = Context;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(
                    extension->CurrentWriteIrp
                    );

    extension->WriteLength = irpSp->Parameters.Write.Length;
    extension->WriteCurrentChar =
        extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer;

    if (MoxaPutData(extension)) {

        MOXA_INC_REFERENCE(extension->CurrentWriteIrp);
        if (extension->PortFlag & NORMAL_TX_MODE)
            *(PUSHORT)(extension->PortOfs + HostStat) |= WakeupTx;
        else
            *(PUSHORT)(extension->PortOfs + HostStat) |= WakeupTxTrigger;

        WRcompFlag = FALSE;
    }
    else

        WRcompFlag = TRUE;

    return FALSE;

}


BOOLEAN
MoxaPutData (
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{
/*
    PUCHAR  base, ofs, buff, writeChar;
    PUSHORT rptr, wptr;
    USHORT  txMask, spage, epage, bufHead;
    USHORT  tail, head, count, count2;
    USHORT  cnt, len, pageNo, pageOfs;
    ULONG   dataLen;
*/

    PDbase = Extension->PortBase;
    PDofs = Extension->PortOfs;
    PDbuff = PDbase + DynPage_addr;
    PDrptr = (PUSHORT)(PDofs + TXrptr);
    PDwptr = (PUSHORT)(PDofs + TXwptr);
    PDtxMask = *(PUSHORT)(PDofs + TX_mask);
    PDspage = *(PUSHORT)(PDofs + Page_txb);
    PDepage = *(PUSHORT)(PDofs + EndPage_txb);
    PDtail = *PDwptr;
    PDhead = *PDrptr;

    PDdataLen = Extension->WriteLength;
    PDwriteChar = Extension->WriteCurrentChar;

    PDcount = (PDhead > PDtail)   ? (PDhead - PDtail - 1)
                                  : (PDhead - PDtail + PDtxMask);

    if (!PDcount)             /* Tx buffer no space! */

        return TRUE;

    if (PDspage == PDepage) {


        PDbufHead = *(PUSHORT)(PDofs + Ofs_txb);

        if (PDcount > PDdataLen)
            PDcount = (USHORT)PDdataLen;

        PDdataLen -= PDcount;

        PDlen = PDcount;

        *(PDbase + Control_reg) = (UCHAR)PDspage;

        if (PDtail & 1) {

            PDbuff[PDbufHead+PDtail++] = *PDwriteChar++;
            PDtail &= PDtxMask;
            PDcount--;
        }
        PDcount2 = PDcount >> 1;

        while (PDcount2--) {

            *(PUSHORT)&(PDbuff[PDbufHead+PDtail]) = *((PUSHORT)PDwriteChar)++;
            PDtail += 2;
            PDtail &= PDtxMask;
        }

        if (PDcount & 1) {

            PDbuff[PDbufHead+PDtail++] = *PDwriteChar++;
            PDtail &= PDtxMask;
        }

        *PDwptr = PDtail;

        *(PDofs + CD180TXirq) = 1;     /* start to send */
    }
    else {

        if (PDcount > PDdataLen)
            PDcount = (USHORT)PDdataLen;

        PDdataLen -= PDcount;

        PDlen = PDcount;
        PDpageNo = PDspage + (PDtail >> 13);
        PDpageOfs = PDtail & Page_mask;
        do {

            PDcnt = Page_size - PDpageOfs;

            if (PDcnt > PDcount)
                PDcnt = PDcount;

            PDcount -= PDcnt;

            if (PDcnt) {

                *(PDbase + Control_reg) = (UCHAR)PDpageNo;

                if (PDpageOfs & 1) {

                    PDbuff[PDpageOfs++] = *PDwriteChar++;
                    PDcnt--;
                }

                PDcount2 = PDcnt >> 1;

                while (PDcount2--) {
                    *(PUSHORT)&(PDbuff[PDpageOfs]) = *((PUSHORT)PDwriteChar)++;
                    PDpageOfs += 2;
                }
                if (PDcnt & 1)
                    PDbuff[PDpageOfs++] = *PDwriteChar++;

            }
            if (PDcount == 0)
                break;

            if (++PDpageNo == PDepage)
                PDpageNo = PDspage;

            PDpageOfs = 0;

        } while (TRUE);

        *PDwptr = (PDtail + PDlen) & PDtxMask;

        *(PDofs + CD180TXirq) = 1;
    }

    Extension->PerfStats.TransmittedCount += PDlen; 

    Extension->WriteLength = PDdataLen;

    if (PDdataLen) {

        Extension->WriteCurrentChar = PDwriteChar;

        return TRUE;
    }
     else if (Extension->PortFlag & NORMAL_TX_MODE) {
        return TRUE;
    }
    else {

        PDtail = *PDwptr;
        PDhead = *PDrptr;
        PDcount = (PDtail >= PDhead)  ? (PDtail - PDhead)
                                      : (PDtail - PDhead + PDtxMask + 1);
        if (PDcount >= MoxaTxLowWater)

                return TRUE;
        else

                return FALSE;

    }
}


VOID
MoxaGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{

 
    PMOXA_DEVICE_EXTENSION extension = CONTAINING_RECORD(
                                            QueueToProcess,
                                            MOXA_DEVICE_EXTENSION,
                                            WriteQueue
                                            );
   UNREFERENCED_PARAMETER(Extension);

    do {


        //
        // We could be completing a flush.
        //
/*
 *      extension->TotalCharsQueued NOT include current write
 *
        if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
            == IRP_MJ_WRITE) {

            KIRQL oldIrql;

            IoAcquireCancelSpinLock(&oldIrql);

            extension->TotalCharsQueued -=
                IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                    ->Parameters.Write.Length;

            IoReleaseCancelSpinLock(oldIrql);

        }
*/
        MoxaGetNextIrp(
            CurrentOpIrp,
            QueueToProcess,
            NewIrp,
            CompleteCurrent,
		extension
            );

        if (!*NewIrp) {

            KIRQL oldIrql;

            IoAcquireCancelSpinLock(&oldIrql);

            KeSynchronizeExecution(
                extension->Interrupt,
                MoxaProcessEmptyTransmit,
                extension
                );

            IoReleaseCancelSpinLock(oldIrql);

            break;

        }
        else if (IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction
                   == IRP_MJ_FLUSH_BUFFERS) {

            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;

        }
        else {

            break;

        }

    } while (TRUE);
}


VOID
MoxaCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    MoxaTryToCompleteCurrent(
        extension,
        MoxaGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &extension->CurrentWriteIrp,
        &extension->WriteQueue,
        NULL,
        &extension->WriteRequestTotalTimer,
        MoxaStartWrite,
        MoxaGetNextWrite
        );

}

BOOLEAN
MoxaGrabWriteFromIsr(
    IN PVOID Context
    )
{
    PMOXA_DEVICE_EXTENSION  extension = Context;
 
    if (*(PUSHORT)(extension->PortOfs + HostStat) & (WakeupTx|WakeupTxTrigger)) {
        extension->CurrentWriteIrp->IoStatus.Information =
            IoGetCurrentIrpStackLocation(
            extension->CurrentWriteIrp
            )->Parameters.Write.Length -
            extension->WriteLength -
            GetDeviceTxQueue(extension);
 
        *(PUSHORT)(extension->PortOfs + HostStat) &= ~(WakeupTx|WakeupTxTrigger);
        extension->WriteLength = 0;

        MOXA_DEC_REFERENCE(extension->CurrentWriteIrp);

        MoxaFuncWithDumbWait(extension->PortOfs, FC_FlushQueue, 1);    // flush OQueue

    }

    return FALSE;

}

BOOLEAN
MoxaProcessEmptyTransmit(
    IN PVOID Context
    )
{

    PMOXA_DEVICE_EXTENSION extension = Context;

    if ((extension->IsrWaitMask & SERIAL_EV_TXEMPTY) &&
        (!extension->CurrentWriteIrp) &&
        IsListEmpty(&extension->WriteQueue)) {

        extension->HistoryMask |= SERIAL_EV_TXEMPTY;
        if (extension->IrpMaskLocation) {

            *extension->IrpMaskLocation = extension->HistoryMask;
            extension->IrpMaskLocation = NULL;
            extension->HistoryMask = 0;

            extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            MoxaInsertQueueDpc(
                &extension->CommWaitDpc,
                NULL,
                NULL,
		    extension
                );


        }

    }

    return FALSE;
}

VOID
MoxaCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    MoxaTryToCompleteCurrent(
        extension,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &extension->CurrentWriteIrp,
        &extension->WriteQueue,
        NULL,
        &extension->WriteRequestTotalTimer,
        MoxaStartWrite,
        MoxaGetNextWrite
        );

     MoxaDpcEpilogue(extension, Dpc);


}

VOID
MoxaWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    MoxaTryToCompleteCurrent(
        extension,
        MoxaGrabWriteFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &extension->CurrentWriteIrp,
        &extension->WriteQueue,
        NULL,
        &extension->WriteRequestTotalTimer,
        MoxaStartWrite,
        MoxaGetNextWrite
        );
     MoxaDpcEpilogue(extension, Dpc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\registry.c ===
/*++

Module Name:

    registry.c

Abstract:

    This module contains the code that is used to get values from the
    registry and to manipulate entries in the registry.

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"
 
NTSTATUS 
MoxaGetRegistryKeyValue (
                          IN HANDLE Handle,
                          IN PWCHAR KeyNameString,
                          IN ULONG KeyNameStringLength,
                          IN PVOID Data,
                          IN ULONG DataLength,
                          OUT PULONG ActualLength)

/*++

Routine Description:

    Reads a registry key value from an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
   UNICODE_STRING              keyName;
   ULONG                       length;
   PKEY_VALUE_FULL_INFORMATION fullInfo;

   NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

  
   MoxaKdPrint (MX_DBG_TRACE, ("Enter SerialGetRegistryKeyValue\n"));

   if (ActualLength) {
   	*ActualLength = 0;
   }
 
   RtlInitUnicodeString (&keyName, KeyNameString);

   length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
      + DataLength;
   fullInfo = ExAllocatePool(PagedPool, length); 

   if (fullInfo) {
      ntStatus = ZwQueryValueKey (Handle,
                                  &keyName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

      if (NT_SUCCESS(ntStatus)) {
         //
         // If there is enough room in the data buffer, copy the output
         //

         if (DataLength >= fullInfo->DataLength) {
            RtlCopyMemory (Data, 
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset, 
                           fullInfo->DataLength);
		if (ActualLength) {
                *ActualLength = fullInfo->DataLength;
            }

         }
      }
	else {
		MoxaKdPrint (MX_DBG_TRACE, ("GetRegistryKeyValue fail (%x)\n",ntStatus));	
	}

      ExFreePool(fullInfo);
   }

   return ntStatus;
}




NTSTATUS 
MoxaPutRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
			  IN ULONG KeyNameStringLength, IN ULONG Dtype,
                          IN PVOID PData, IN ULONG DataLength)
/*++

Routine Description:

    Writes a registry key value to an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    PKeyNameString      ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString
    
    Dtype		REG_XYZ value type

    PData               Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
   NTSTATUS status;
   UNICODE_STRING keyname;

   MoxaKdPrint (MX_DBG_TRACE,("Enter MoxaPutRegistryKeyValue\n"));

   RtlInitUnicodeString(&keyname, NULL);
   keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
   keyname.Buffer = ExAllocatePool(PagedPool, keyname.MaximumLength);

   if (keyname.Buffer == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlAppendUnicodeToString(&keyname, PKeyNameString);

   status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

   ExFreePool(keyname.Buffer);
   
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\timer.c ===
#include "precomp.h"

#define MAXPORTS        128

struct _ObjLink {
        struct _ObjLink *           sNext;
        PMOXA_DEVICE_EXTENSION 	extension;
};
typedef struct _ObjLink         ObjLink;

static ObjLink  openDevice[MAXPORTS];
static ObjLink *pFree;
static ObjLink *pHeader;
static ObjLink *pTailer;
static KTIMER   pollTimer;
static KDPC     pollDpc;

void            MoxaTimeOutProcIsr(
                        IN PKDPC Dpc,
                        IN PVOID DeferredContext,
                        IN PVOID SystemContext1,
                        IN PVOID SystemContext2
                        );
static void     MoxaResetTimeOutProc(void);

void MoxaInitTimeOutProc()
{
	int     i;

      pHeader = NULL;
      pTailer = NULL;
      pFree = &openDevice[0];
      for ( i=0; i<MAXPORTS; i++ )
      	openDevice[i].sNext = &openDevice[i + 1];
      openDevice[MAXPORTS - 1].sNext = NULL;
      KeInitializeDpc(
      	&pollDpc,
            MoxaTimeOutProcIsr,
            NULL
            );
      KeInitializeTimer(&pollTimer);
}

void MoxaStopTimeOutProc()
{

      KeRemoveQueueDpc(&pollDpc);
      KeCancelTimer(&pollTimer);
}

BOOLEAN MoxaAddTimeOutProc(
      PMOXA_DEVICE_EXTENSION	extension
)
{
	ObjLink *pTmp;

      if ( pFree == NULL )
      	return(FALSE);

      pTmp = pFree;
      pFree = pFree->sNext;
      pTmp->sNext = NULL;
      pTmp->extension = extension;


      if ( pHeader == NULL )
      	pHeader = pTmp;
      else
            pTailer->sNext = pTmp;
      pTailer = pTmp;
                      
      if ( pHeader == pTailer )
      	MoxaResetTimeOutProc();
      return(TRUE);
}

BOOLEAN MoxaDelTimeOutProc(
      PMOXA_DEVICE_EXTENSION	extension
)
{
	ObjLink *next;
      ObjLink *prev;

      next = pHeader;
      prev = NULL;
      while ( next ) {
      	if ( next->extension == extension )
                break;
            prev = next;
            next = prev->sNext;
      }
      if ( next == NULL )
            return(FALSE);
      if ( prev ) {
            prev->sNext = next->sNext;
            if ( prev->sNext == NULL )
                pTailer = prev;
      } else {
            pHeader = next->sNext;
      }
      next->sNext = pFree;
      pFree = next;
      return(TRUE);
}

void MoxaTimeOutProcIsr(
	IN PKDPC Dpc,
	IN PVOID DeferredContext,
	IN PVOID SystemContext1,
	IN PVOID SystemContext2
)
{
	ObjLink *next;
    KIRQL oldIrql;
    PMOXA_DEVICE_EXTENSION 	extension;


    if ( (next = pHeader) == NULL )
		return;
    while ( next ) {
		if ((extension = next->extension) == NULL) {
	    	next = next->sNext;
	     	continue;
	 	}

        if ((extension->ReadLength >  0) &&
 	     		(*(PSHORT)(extension->PortOfs + HostStat) &WakeupRxTrigger) ) {
			PUCHAR  ofs;
    		PUSHORT rptr, wptr;
    		USHORT  lenMask, count;

   	 		IoAcquireCancelSpinLock(&oldIrql);
 
        	ofs = extension->PortOfs;
    		rptr = (PUSHORT)(ofs + RXrptr);
    		wptr = (PUSHORT)(ofs + RXwptr);
    		lenMask = *(PUSHORT)(ofs + RX_mask);
    		count = (*wptr >= *rptr) ? (*wptr - *rptr)
                            		: (*wptr - *rptr + lenMask + 1);

			if (count >= *(PUSHORT)(ofs + Rx_trigger)) {

    				if (extension->Interrupt) {
    					KeSynchronizeExecution(
        					extension->Interrupt,
        					MoxaIsrGetData,
        					extension
        					);
    				}
     				else {
					MoxaIsrGetData(extension);
     				}
			}

    		IoReleaseCancelSpinLock(oldIrql);
		}

		next = next->sNext;
	}
    MoxaResetTimeOutProc();
}


static void MoxaResetTimeOutProc()
{
	LARGE_INTEGER   time;

      //
      //  Add time out process routine.
      //
      time.QuadPart = -1000000;       /* 100 msec */

      KeSetTimer(
      	&pollTimer,
      	time,
            &pollDpc
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\waitmask.c ===
/*++

Module Name:

    waitmask.c
Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
MoxaStartMask(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{

    PIO_STACK_LOCATION irpSp;
    PIRP newIrp;
    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;

    do {

	irpSp = IoGetCurrentIrpStackLocation(Extension->CurrentMaskIrp);
	if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
	    IOCTL_SERIAL_SET_WAIT_MASK) {
	    KeSynchronizeExecution(
		Extension->Interrupt,
		MoxaFinishOldWait,
		Extension
		);

	    Extension->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

	    if (!setFirstStatus) {

		firstStatus = STATUS_SUCCESS;
		setFirstStatus = TRUE;

	    }

	    MoxaGetNextIrp(
		&Extension->CurrentMaskIrp,
		&Extension->MaskQueue,
		&newIrp,
		TRUE,
		Extension
		);

	}
	else {
	    //
	    //	    IOCTL_SERIAL_WAIT_ON_MASK
	    //
	    // First make sure that we have a non-zero mask.
	    // If the app queues a wait on a zero mask it can't
	    // be statisfied so it makes no sense to start it.
	    //

	    if ((!Extension->IsrWaitMask) || (Extension->CurrentWaitIrp)) {

		Extension->CurrentMaskIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

		if (!setFirstStatus) {

		    firstStatus = STATUS_INVALID_PARAMETER;
		    setFirstStatus = TRUE;

		}

		MoxaGetNextIrp(
		    &Extension->CurrentMaskIrp,
		    &Extension->MaskQueue,
		    &newIrp,
		    TRUE,
		    Extension
		    );

	    }
	    else {

		KIRQL oldIrql;

		IoAcquireCancelSpinLock(&oldIrql);

		if (Extension->CurrentMaskIrp->Cancel) {

		    Extension->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

		    IoReleaseCancelSpinLock(oldIrql);

		    if (!setFirstStatus) {

			firstStatus = STATUS_CANCELLED;
			setFirstStatus = TRUE;

		    }

		    MoxaGetNextIrp(
			&Extension->CurrentMaskIrp,
			&Extension->MaskQueue,
			&newIrp,
			TRUE,
			Extension
			);

		}
		else {

		    if (!setFirstStatus) {

			firstStatus = STATUS_PENDING;
			setFirstStatus = TRUE;

			IoMarkIrpPending(Extension->CurrentMaskIrp);

		    }

		    Extension->CurrentWaitIrp = Extension->CurrentMaskIrp;

		    MOXA_INIT_REFERENCE(Extension->CurrentWaitIrp);

		    IoSetCancelRoutine(
			Extension->CurrentWaitIrp,
			MoxaCancelWait
			);

		    //
		    // Since the cancel routine has a reference to
		    // the irp we need to update the reference
		    // count.
		    //

		    MOXA_INC_REFERENCE(Extension->CurrentWaitIrp);

		    KeSynchronizeExecution(
			Extension->Interrupt,
			MoxaGiveWaitToIsr,
			Extension
			);

		    IoReleaseCancelSpinLock(oldIrql);

		    MoxaGetNextIrp(
			&Extension->CurrentMaskIrp,
			&Extension->MaskQueue,
			&newIrp,
			FALSE,
			Extension
			);

		}
	    }
	}

    } while (newIrp);

    return firstStatus;

}

BOOLEAN
MoxaFinishOldWait(
    IN PVOID Context
    )
{

    PMOXA_DEVICE_EXTENSION extension = Context;
    PUCHAR		   ofs;

    if (extension->IrpMaskLocation) {

	//
	// The isr still "owns" the irp.
	//
	*extension->IrpMaskLocation = 0;
	extension->IrpMaskLocation = NULL;

	extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

	//
	// We don't decrement the reference since the completion routine
	// will do that.
	//

	MoxaInsertQueueDpc(
	    &extension->CommWaitDpc,
	    NULL,
	    NULL,
	    extension
	    );


    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    extension->HistoryMask &= *((ULONG *)extension->CurrentMaskIrp->
					    AssociatedIrp.SystemBuffer);

    extension->IsrWaitMask = *((ULONG *)extension->CurrentMaskIrp->
					    AssociatedIrp.SystemBuffer);

    ofs = extension->PortOfs;

    if (extension->IsrWaitMask & SERIAL_EV_RXCHAR)

	*(PUSHORT)(ofs + HostStat) |= WakeupRx;
    else

	*(PUSHORT)(ofs + HostStat) &= ~WakeupRx;

    if (extension->IsrWaitMask & SERIAL_EV_RXFLAG)

	*(PUSHORT)(ofs + HostStat) |= WakeupEvent;
    else

	*(PUSHORT)(ofs + HostStat) &= ~WakeupEvent;

    if (extension->IsrWaitMask & SERIAL_EV_RX80FULL)

	*(PUSHORT)(ofs + HostStat) |= WakeupRx80Full;
    else

	*(PUSHORT)(ofs + HostStat) &= ~WakeupRx80Full;

    if (extension->IsrWaitMask & SERIAL_EV_ERR) {
	*(PUSHORT)(ofs + HostStat) |= WakeupError;
    }
    else {
	*(PUSHORT)(ofs + HostStat) &= ~WakeupError;
    }


    if (extension->IsrWaitMask & SERIAL_EV_BREAK)  {
	*(PUSHORT)(ofs + HostStat) |= WakeupBreak;
    }
    else {
	*(PUSHORT)(ofs + HostStat) &= ~WakeupBreak;
    }

 
 
    return FALSE;
}

VOID
MoxaCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    MoxaTryToCompleteCurrent(
	extension,
	MoxaGrabWaitFromIsr,
	Irp->CancelIrql,
	STATUS_CANCELLED,
	&extension->CurrentWaitIrp,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
	);

}

BOOLEAN
MoxaGrabWaitFromIsr(
    IN PVOID Context
    )
{

    PMOXA_DEVICE_EXTENSION extension = Context;

    if (extension->IrpMaskLocation) {

	//
	// The isr still "owns" the irp.
	//

	*extension->IrpMaskLocation = 0;
	extension->IrpMaskLocation = NULL;

	extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

	//
	// Since the isr no longer references the irp we need to
	// decrement the reference count.
	//

	MOXA_DEC_REFERENCE(extension->CurrentWaitIrp);

    }

    return FALSE;
}

BOOLEAN
MoxaGiveWaitToIsr(
    IN PVOID Context
    )
{

    PMOXA_DEVICE_EXTENSION extension = Context;

    MOXA_INC_REFERENCE(extension->CurrentWaitIrp);

    if (!extension->HistoryMask)

	extension->IrpMaskLocation =
	    extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer;

    else {

	*((ULONG *)extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer) =
	    extension->HistoryMask;
	extension->HistoryMask = 0;
	extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
	extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

	MoxaInsertQueueDpc(
	    &extension->CommWaitDpc,
	    NULL,
	    NULL,
	    extension
	    );


    }

    return FALSE;
}

VOID
MoxaCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    MoxaTryToCompleteCurrent(
	extension,
	NULL,
	oldIrql,
	STATUS_SUCCESS,
	&extension->CurrentWaitIrp,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
	);
     MoxaDpcEpilogue(extension, Dpc);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\moxa\intellio\driver\mxport\utils.c ===
/*++

Module Name:

    utils.c


Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


NTSTATUS
MoxaCompleteIfError(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to test.

Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.

--*/

{

    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    USHORT      dataError;


    if (extension->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) {

        if (extension->ErrorWord) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.
        //

            if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
                (irpSp->Parameters.DeviceIoControl.IoControlCode !=
                 IOCTL_SERIAL_GET_COMMSTATUS)) {

                status = STATUS_CANCELLED;
                Irp->IoStatus.Status = STATUS_CANCELLED;
                Irp->IoStatus.Information = 0;

                MoxaCompleteRequest(extension, Irp, 0);

            }
        }
    }

    return status;

}

//
//  t is 2ms
//
VOID
MoxaDelay(
    IN ULONG    t
    )
{
    LARGE_INTEGER delay;

    t *= 20000;          /* delay unit = 100 ns */

    delay = RtlConvertUlongToLargeInteger(t);

    delay = RtlLargeIntegerNegate(delay);

    KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &delay
        );
}

/* Must migrate to MoxaFunc1 for performace resaon */
VOID
MoxaFunc(
    IN PUCHAR   PortOfs,
    IN UCHAR    Command,
    IN USHORT   Argument
    )
{

    *(PUSHORT)(PortOfs + FuncArg) = Argument;

    *(PortOfs + FuncCode) = Command;

    MoxaWaitFinish(PortOfs);
}

VOID
MoxaFunc1(
    IN PUCHAR   PortOfs,
    IN UCHAR    Command,
    IN USHORT   Argument
    )
{

    *(PUSHORT)(PortOfs + FuncArg) = Argument;

    *(PortOfs + FuncCode) = Command;

    MoxaWaitFinish1(PortOfs);
}

VOID
MoxaFuncWithDumbWait(
    IN PUCHAR   PortOfs,
    IN UCHAR    Command,
    IN USHORT   Argument
    )
{

    *(PUSHORT)(PortOfs + FuncArg) = Argument;

    *(PortOfs + FuncCode) = Command;

    MoxaDumbWaitFinish(PortOfs);
}

VOID
MoxaFuncWithLock(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN UCHAR    Command,
    IN USHORT   Argument
    )
{
    PUCHAR   ofs;
    KIRQL   oldIrql;

    KeAcquireSpinLock(
            &Extension->ControlLock,
            &oldIrql
            );

    ofs = Extension->PortOfs;

    *(PUSHORT)(ofs + FuncArg) = Argument;

    *(ofs + FuncCode) = Command;

    MoxaWaitFinish(ofs);

    KeReleaseSpinLock(
            &Extension->ControlLock,
            oldIrql
            );
}

VOID
MoxaFuncGetLineStatus(
    IN PUCHAR   PortOfs,
    IN PUSHORT  Argument
    )
{
    *Argument = *(PUSHORT)(PortOfs + FlagStat) >> 4;

}

VOID
MoxaFuncGetDataError(
    IN PUCHAR   PortOfs,
    IN PUSHORT  Argument
    )
{
    *Argument = *(PUSHORT)(PortOfs + Data_error); 
    *(PUSHORT)(PortOfs + Data_error) = 0;

}

BOOLEAN
MoxaDumbWaitFinish(
    IN PUCHAR   PortOfs
    )
{
    LARGE_INTEGER   targetTc, newTc, currTc, newTc1;
    ULONG           unit, count;
    LARGE_INTEGER   interval;           /* 0.5 ms */
    USHORT          cnt = 1000;         /* timeout = 500 ms */


    KeQueryTickCount(&currTc);

    unit = KeQueryTimeIncrement();

    currTc = RtlExtendedIntegerMultiply(currTc, unit);

    interval = RtlConvertUlongToLargeInteger(5000L);

    targetTc = RtlLargeIntegerAdd(currTc, interval);

    do {

        count = 0;

/*********************************************************************
NOTE!   sometimes I cann't leave the while loop. beacuse
        newTc = 0 (I don't know why). So I must set boundary
        MoxaLoopCnt to quit!
/*********************************************************************/
        do {

            KeQueryTickCount(&newTc);

            newTc = RtlExtendedIntegerMultiply(newTc, unit);

            if (++count > MoxaLoopCnt)
                break;

        } while (!RtlLargeIntegerGreaterThanOrEqualTo(newTc, targetTc));

        if (*(PortOfs + FuncCode))

            targetTc = RtlLargeIntegerAdd(targetTc, interval);
        else

            return TRUE;


    } while (cnt--);

    return FALSE;
}

BOOLEAN
MoxaWaitFinish(
    IN PUCHAR   PortOfs
    )
{
    LARGE_INTEGER   targetTc, newTc, currTc, newTc1;
    ULONG           unit, count;
    LARGE_INTEGER   interval;           /* 0.5 ms */
    USHORT          cnt = 1000;         /* timeout = 500 ms */


    KeQueryTickCount(&currTc);

    unit = KeQueryTimeIncrement();

    currTc = RtlExtendedIntegerMultiply(currTc, unit);

    interval = RtlConvertUlongToLargeInteger(5000L);

    targetTc = RtlLargeIntegerAdd(currTc, interval);

    do {

        count = 0;

/*********************************************************************
NOTE!   sometimes I cann't leave the while loop. beacuse
        newTc = 0 (I don't know why). So I must set boundary
        MoxaLoopCnt to quit!
/*********************************************************************/
        do {

            KeQueryTickCount(&newTc);

            newTc = RtlExtendedIntegerMultiply(newTc, unit);

            if (++count > MoxaLoopCnt)
                break;

        } while (!RtlLargeIntegerGreaterThanOrEqualTo(newTc, targetTc));

        if (*(PortOfs + FuncCode))

            targetTc = RtlLargeIntegerAdd(targetTc, interval);
        else

            return TRUE;


    } while (cnt--);

    return FALSE;
}

 
BOOLEAN
MoxaWaitFinish1(
    IN PUCHAR   PortOfs
    )
{
     
    USHORT          cnt = 250;         /* timeout = 500 ms */

    while (cnt--) {
	if (*(PortOfs + FuncCode))
		MoxaDelay(1L);
	else
		return TRUE;
    }
    return FALSE;
}
 

NTSTATUS
MoxaGetDivisorFromBaud(
    IN ULONG ClockType,
    IN LONG DesiredBaud,
    OUT PSHORT AppropriateDivisor
    )
{

    NTSTATUS status = STATUS_SUCCESS;
    ULONG clockRate;
    SHORT calculatedDivisor;
    ULONG denominator;
    ULONG remainder;

    //
    // Allow up to a 1 percent error
    //

    ULONG maxRemain98 = 98304;
    ULONG maxRemain11 = 110592;
    ULONG maxRemain14 = 147456;
    ULONG maxRemain;

    if (ClockType == 1)

        clockRate = 11059200;
    else if (ClockType == 2)

        clockRate = 14745600;
    else

        clockRate = 9830400;

    //
    // Reject any non-positive bauds.
    //

    denominator = DesiredBaud * (ULONG)16;

    if (DesiredBaud <= 0) {

        *AppropriateDivisor = -1;

    } else if ((LONG)denominator < DesiredBaud) {

        //
        // If the desired baud was so huge that it cause the denominator
        // calculation to wrap, don't support it.
        //

        *AppropriateDivisor = -1;

    } else {

        if (ClockType == 0) {           /* ver1.0 BOX */

            maxRemain = maxRemain98;

        }
        else if (ClockType == 1) {      /* ver2.0 BOX */

            maxRemain = maxRemain11;

        }
        else {                          /* ver3.0 BOX */

            maxRemain = maxRemain14;

        }

        calculatedDivisor = (SHORT)(clockRate / denominator);

        remainder = clockRate % denominator;

        //
        // Round up.
        //

        if (((remainder * 2) > clockRate) && (DesiredBaud != 110))

            calculatedDivisor++;

        //
        // Only let the remainder calculations effect us if
        // the baud rate is > 9600.
        //

        if (DesiredBaud >= 9600)

            //
            // If the remainder is less than the maximum remainder (wrt
            // the clockRate) or the remainder + the maximum remainder is
            // greater than or equal to the clockRate then assume that the
            // baud is ok.
            //

            if ((remainder >= maxRemain) && ((remainder+maxRemain) < clockRate))

                calculatedDivisor = -1;

        //
        // Don't support a baud that causes the denominator to
        // be larger than the clock.
        //

        if (denominator > clockRate)

            calculatedDivisor = -1;

        *AppropriateDivisor = calculatedDivisor;

    }

    if (*AppropriateDivisor == -1) {

        status = STATUS_INVALID_PARAMETER;

    }

    return status;

}

NTSTATUS
MoxaStartOrQueue(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PMOXA_START_ROUTINE Starter
    )
{

    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction
        == IRP_MJ_WRITE)

        Extension->TotalCharsQueued +=
            IoGetCurrentIrpStackLocation(Irp)
            ->Parameters.Write.Length;

    if ((IsListEmpty(QueueToExamine)) &&
        !(*CurrentOpIrp)) {

        //
        // There were no current operation.  Mark this one as
        // current and start it up.
        //

        *CurrentOpIrp = Irp;

        IoReleaseCancelSpinLock(oldIrql);

        return Starter(Extension);

    } else {

        //
        // We don't know how long the irp will be in the
        // queue.  So we need to handle cancel.
        //

        if (Irp->Cancel) {

            Irp->IoStatus.Status = STATUS_CANCELLED;

            IoReleaseCancelSpinLock(oldIrql);

            MoxaCompleteRequest(Extension, Irp, 0);

            return STATUS_CANCELLED;

        } else {

            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            InsertTailList(
                QueueToExamine,
                &Irp->Tail.Overlay.ListEntry
                );

            IoSetCancelRoutine(
                Irp,
                MoxaCancelQueued
                );

            IoReleaseCancelSpinLock(oldIrql);

            return STATUS_PENDING;

        }

    }

}

VOID
MoxaCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    //
    // If this is a write irp then take the amount of characters
    // to write and subtract it from the count of characters to write.
    //

    if (irpSp->MajorFunction == IRP_MJ_WRITE)

        extension->TotalCharsQueued -= irpSp->Parameters.Write.Length;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    MoxaCompleteRequest(extension,
	Irp,
//	IO_SERIAL_INCREMENT
	IO_NO_INCREMENT
	);


}

VOID
MoxaGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PMOXA_DEVICE_EXTENSION extension
    )

{

    PIRP oldIrp;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    oldIrp = *CurrentOpIrp;

    if (!IsListEmpty(QueueToProcess)) {

        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(
                            headOfList,
                            IRP,
                            Tail.Overlay.ListEntry
                            );

        IoSetCancelRoutine(
            *CurrentOpIrp,
            NULL
            );

    } else {

        *CurrentOpIrp = NULL;

    }

    *NextIrp = *CurrentOpIrp;

    IoReleaseCancelSpinLock(oldIrql);

    if (CompleteCurrent) {

        if (oldIrp) {

              MoxaCompleteRequest(extension,
                oldIrp,
//                IO_SERIAL_INCREMENT
		    IO_NO_INCREMENT
                );

        }

    }

}

VOID
MoxaTryToCompleteCurrent(
    IN PMOXA_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PMOXA_START_ROUTINE Starter OPTIONAL,
    IN PMOXA_GET_NEXT_ROUTINE GetNextIrp OPTIONAL
    )
{

    if (*CurrentOpIrp == NULL) {
	IoReleaseCancelSpinLock(IrqlForRelease);
	return;
    }
    MOXA_DEC_REFERENCE(*CurrentOpIrp);

    if (SynchRoutine) {

        KeSynchronizeExecution(
            Extension->Interrupt,
            SynchRoutine,
            Extension
            );
    }

    MoxaRundownIrpRefs(
        CurrentOpIrp,
        IntervalTimer,
        TotalTimer,
	  Extension
        );

    if (!MOXA_REFERENCE_COUNT(*CurrentOpIrp)) {

        PIRP newIrp;


        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if (StatusToUse == STATUS_CANCELLED)

            (*CurrentOpIrp)->IoStatus.Information = 0;

        if (GetNextIrp) {

            IoReleaseCancelSpinLock(IrqlForRelease);

            GetNextIrp(
                CurrentOpIrp,
                QueueToProcess,
                &newIrp,
                TRUE,
		    Extension
                );

            if (newIrp)

                Starter(Extension);

        }
        else {

            PIRP oldIrp = *CurrentOpIrp;

            *CurrentOpIrp = NULL;

            IoReleaseCancelSpinLock(IrqlForRelease);

            MoxaCompleteRequest(Extension,
                oldIrp,
//                IO_SERIAL_INCREMENT
		    IO_NO_INCREMENT
                );
        }

    } else {

        IoReleaseCancelSpinLock(IrqlForRelease);

    }
}

VOID
MoxaRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PMOXA_DEVICE_EXTENSION pDevExt)

    {

    if ((*CurrentOpIrp)->CancelRoutine) {

        MOXA_DEC_REFERENCE(*CurrentOpIrp);

        IoSetCancelRoutine(
            *CurrentOpIrp,
            NULL
            );

    }

    if (IntervalTimer) {

        if (MoxaCancelTimer(IntervalTimer,pDevExt)) {

            MOXA_DEC_REFERENCE(*CurrentOpIrp);

        }

    }

    if (TotalTimer) {


        if (MoxaCancelTimer(TotalTimer,pDevExt)) {

            MOXA_DEC_REFERENCE(*CurrentOpIrp);

        }

    }

}


BOOLEAN
MoxaInsertQueueDpc(IN PRKDPC PDpc, IN PVOID Sarg1, IN PVOID Sarg2,
                     IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to queue DPC's for the serial driver.

Arguments:

   PDpc thru Sarg2  - Standard args to KeInsertQueueDpc()

   PDevExt - Pointer to the device extension for the device that needs to
             queue a DPC

Return Value:

   Kicks up return value from KeInsertQueueDpc()

--*/
{
   BOOLEAN queued;


   InterlockedIncrement(&PDevExt->DpcCount);

   queued = KeInsertQueueDpc(PDpc, Sarg1, Sarg2);

   if (!queued) {
      ULONG pendingCnt;

      pendingCnt = InterlockedDecrement(&PDevExt->DpcCount);

      if (pendingCnt == 0) {
         KeSetEvent(&PDevExt->PendingIRPEvent, IO_NO_INCREMENT, FALSE);
      }
   }

   return queued;
}





BOOLEAN
MoxaSetTimer(IN PKTIMER Timer, IN LARGE_INTEGER DueTime,
               IN PKDPC Dpc OPTIONAL, IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to set timers for the serial driver.
   
Arguments:

   Timer - pointer to timer dispatcher object
   
   DueTime - time at which the timer should expire
   
   Dpc - option Dpc
   
   PDevExt - Pointer to the device extension for the device that needs to
             set a timer

Return Value:

   Kicks up return value from KeSetTimer()

--*/
{
   BOOLEAN set;


   InterlockedIncrement(&PDevExt->DpcCount);

   set = KeSetTimer(Timer, DueTime, Dpc);

   if (set) {
      InterlockedDecrement(&PDevExt->DpcCount);
   }

   return set;
}


BOOLEAN
MoxaCancelTimer(IN PKTIMER Timer, IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to cancel timers for the serial driver.
   
Arguments:

   Timer - pointer to timer dispatcher object
   
   PDevExt - Pointer to the device extension for the device that needs to
             set a timer

Return Value:

   True if timer was cancelled

--*/
{
   BOOLEAN cancelled;

   cancelled = KeCancelTimer(Timer);

   if (cancelled) {
      MoxaDpcEpilogue(PDevExt, Timer->Dpc);
   }

   return cancelled;
}


VOID
MoxaDpcEpilogue(IN PMOXA_DEVICE_EXTENSION PDevExt, PKDPC PDpc)
/*++

Routine Description:

   This function must be called at the end of every dpc function.
   
Arguments:

   PDevObj - Pointer to the device object we are tracking dpc's for.

Return Value:

   None.

--*/
{
   LONG pendingCnt;
#if 1 // !DBG
   UNREFERENCED_PARAMETER(PDpc);
#endif

   pendingCnt = InterlockedDecrement(&PDevExt->DpcCount);

   // ASSERT(pendingCnt >= 0);

   if (pendingCnt == 0) {
      KeSetEvent(&PDevExt->PendingDpcEvent, IO_NO_INCREMENT, FALSE);
   }
}




VOID
MoxaKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )
{

    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;

    //
    // We acquire the cancel spin lock.  This will prevent the
    // irps from moving around.
    //

    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(QueueToClean)) {

        PIRP currentLastIrp = CONTAINING_RECORD(
                                  QueueToClean->Blink,
                                  IRP,
                                  Tail.Overlay.ListEntry
                                  );

        RemoveEntryList(QueueToClean->Blink);

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;
/* 8-30-01 by William 
	 
        cancelRoutine(
            DeviceObject,
            currentLastIrp
            );

        IoAcquireCancelSpinLock(&cancelIrql);
*/
	  if (cancelRoutine) {
   	  	cancelRoutine(
            	DeviceObject,
            	currentLastIrp
            	);

        	IoAcquireCancelSpinLock(&cancelIrql);
	  }
	

    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //

    if (*CurrentOpIrp) {


        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //

        if (cancelRoutine) {

            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancelable state.  We simply
            // mark it as canceled and call the cancel routine for
            // it.
            //

            cancelRoutine(
                DeviceObject,
                *CurrentOpIrp
                );

        }
        else

            IoReleaseCancelSpinLock(cancelIrql);

    }
    else

        IoReleaseCancelSpinLock(cancelIrql);

}

VOID
MoxaCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )
{

    PMOXA_DEVICE_EXTENSION extension = DeferredContext;

    MoxaKillAllReadsOrWrites(
        extension->DeviceObject,
        &extension->WriteQueue,
        &extension->CurrentWriteIrp
        );

    MoxaKillAllReadsOrWrites(
        extension->DeviceObject,
        &extension->ReadQueue,
        &extension->CurrentReadIrp
        );
    MoxaDpcEpilogue(extension, Dpc);
}

USHORT
GetDeviceTxQueueWithLock(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{
    KIRQL controlIrql, oldIrql;
    PUCHAR  ofs;
    PUSHORT rptr, wptr;
    USHORT  lenMask, count;

    IoAcquireCancelSpinLock(&oldIrql);
    ofs = Extension->PortOfs;
    rptr = (PUSHORT)(ofs + TXrptr);
    wptr = (PUSHORT)(ofs + TXwptr);
    lenMask = *(PUSHORT)(ofs + TX_mask);
    count = (*wptr >= *rptr) ? (*wptr - *rptr)
                             : (*wptr - *rptr + lenMask + 1);

    KeAcquireSpinLock(
        &Extension->ControlLock,
        &controlIrql
        );

    *(ofs + FuncCode) = FC_ExtOQueue;

    MoxaWaitFinish(ofs);

    count += *(PUSHORT)(ofs + FuncArg);

    KeReleaseSpinLock(
        &Extension->ControlLock,
        controlIrql
        );

    IoReleaseCancelSpinLock(oldIrql);

    return count;
}

USHORT
GetDeviceTxQueue(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{
    PUCHAR  ofs;
    PUSHORT rptr, wptr;
    USHORT  lenMask, count;

    ofs = Extension->PortOfs;
    rptr = (PUSHORT)(ofs + TXrptr);
    wptr = (PUSHORT)(ofs + TXwptr);
    lenMask = *(PUSHORT)(ofs + TX_mask);
    count = (*wptr >= *rptr) ? (*wptr - *rptr)
                             : (*wptr - *rptr + lenMask + 1);
   *(ofs + FuncCode) = FC_ExtOQueue;
    MoxaDumbWaitFinish(ofs);

    count += *(PUSHORT)(ofs + FuncArg);

    return count;
}

USHORT
GetDeviceRxQueueWithLock(
    IN PMOXA_DEVICE_EXTENSION Extension
    )
{
    KIRQL controlIrql, oldIrql;
    PUCHAR  ofs;
    PUSHORT rptr, wptr;
    USHORT  lenMask, count;

    IoAcquireCancelSpinLock(&oldIrql);
    ofs = Extension->PortOfs;
    rptr = (PUSHORT)(ofs + RXrptr);
    wptr = (PUSHORT)(ofs + RXwptr);
    lenMask = *(PUSHORT)(ofs + RX_mask);
    count = (*wptr >= *rptr) ? (*wptr - *rptr)
                             : (*wptr - *rptr + lenMask + 1);

    KeAcquireSpinLock(
        &Extension->ControlLock,
        &controlIrql
        );

    *(ofs + FuncCode) = FC_ExtIQueue;

    MoxaWaitFinish(ofs);

    count += *(PUSHORT)(ofs + FuncArg);

    KeReleaseSpinLock(
        &Extension->ControlLock,
        controlIrql
        );

    IoReleaseCancelSpinLock(oldIrql);

    return count;
}

VOID
MoxaLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET errorLogEntry;

   PVOID objectToUse;
   SHORT dumpToAllocate = 0;
   PUCHAR ptrToFirstInsert;
   PUCHAR ptrToSecondInsert;

   //PAGED_CODE();

   if (Insert1 == NULL) {
      LengthOfInsert1 = 0;
   }

   if (Insert2 == NULL) {
      LengthOfInsert2 = 0;
   }


   if (ARGUMENT_PRESENT(DeviceObject)) {

      objectToUse = DeviceObject;

   } else {

      objectToUse = DriverObject;

   }

   if (MoxaMemCompare(
                       P1,
                       (ULONG)1,
                       MoxaPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   if (MoxaMemCompare(
                       P2,
                       (ULONG)1,
                       MoxaPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   errorLogEntry = IoAllocateErrorLogEntry(
                                          objectToUse,
                                          (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                                  dumpToAllocate
                                                  + LengthOfInsert1 +
                                                  LengthOfInsert2)
                                          );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = MajorFunctionCode;
      errorLogEntry->RetryCount = RetryCount;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = dumpToAllocate;

      if (dumpToAllocate) {

         RtlCopyMemory(
                      &errorLogEntry->DumpData[0],
                      &P1,
                      sizeof(PHYSICAL_ADDRESS)
                      );

         if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(
                         ((PUCHAR)&errorLogEntry->DumpData[0])
                         +sizeof(PHYSICAL_ADDRESS),
                         &P2,
                         sizeof(PHYSICAL_ADDRESS)
                         );

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+(2*sizeof(PHYSICAL_ADDRESS));

         } else {

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+sizeof(PHYSICAL_ADDRESS);


         }

      } else {

         ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      }

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         }

      }

      IoWriteErrorLogEntry(errorLogEntry);

   }

}



MOXA_MEM_COMPARES
MoxaMemCompare(
                IN PHYSICAL_ADDRESS A,
                IN ULONG SpanOfA,
                IN PHYSICAL_ADDRESS B,
                IN ULONG SpanOfB
                )

/*++

Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.

--*/

{

   LARGE_INTEGER a;
   LARGE_INTEGER b;

   LARGE_INTEGER lower;
   ULONG lowerSpan;
   LARGE_INTEGER higher;

   //PAGED_CODE();

   a = A;
   b = B;

   if (a.QuadPart == b.QuadPart) {

      return AddressesAreEqual;

   }

   if (a.QuadPart > b.QuadPart) {

      higher = a;
      lower = b;
      lowerSpan = SpanOfB;

   } else {

      higher = b;
      lower = a;
      lowerSpan = SpanOfA;

   }

   if ((higher.QuadPart - lower.QuadPart) >= lowerSpan) {

      return AddressesAreDisjoint;

   }

   return AddressesOverlap;

}




VOID
MoxaFilterCancelQueued(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This routine will be used cancel irps on the stalled queue.
    
Arguments:

    PDevObj - Pointer to the device object.
    
    PIrp - Pointer to the Irp to cancel

Return Value:

    None.

--*/
{
   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   RemoveEntryList(&PIrp->Tail.Overlay.ListEntry);

   IoReleaseCancelSpinLock(PIrp->CancelIrql);
}

VOID
MoxaKillAllStalled(IN PDEVICE_OBJECT PDevObj)
{
   KIRQL cancelIrql;
   PDRIVER_CANCEL cancelRoutine;
   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

   IoAcquireCancelSpinLock(&cancelIrql);

   while (!IsListEmpty(&pDevExt->StalledIrpQueue)) {

      PIRP currentLastIrp = CONTAINING_RECORD(pDevExt->StalledIrpQueue.Blink,
                                              IRP, Tail.Overlay.ListEntry);

      RemoveEntryList(pDevExt->StalledIrpQueue.Blink);

      cancelRoutine = currentLastIrp->CancelRoutine;
      currentLastIrp->CancelIrql = cancelIrql;
      currentLastIrp->CancelRoutine = NULL;
      currentLastIrp->Cancel = TRUE;

      cancelRoutine(PDevObj, currentLastIrp);

      IoAcquireCancelSpinLock(&cancelIrql);
   }

   IoReleaseCancelSpinLock(cancelIrql);
}

NTSTATUS
MoxaFilterIrps(IN PIRP PIrp, IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine will be used to approve irps for processing.
    If an irp is approved, success will be returned.  If not,
    the irp will be queued or rejected outright.  The IoStatus struct
    and return value will appropriately reflect the actions taken.
    
Arguments:

    PIrp - Pointer to the Irp to cancel
    
    PDevExt - Pointer to the device extension

Return Value:

    None.

--*/
{
   PIO_STACK_LOCATION pIrpStack;
   KIRQL oldIrqlFlags;

   pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

   KeAcquireSpinLock(&PDevExt->FlagsLock, &oldIrqlFlags);

   if ((PDevExt->DevicePNPAccept == SERIAL_PNPACCEPT_OK)
       && ((PDevExt->Flags & SERIAL_FLAGS_BROKENHW) == 0)) {
      KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);
      return STATUS_SUCCESS;
   }

   if ((PDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_REMOVING)
       || (PDevExt->Flags & SERIAL_FLAGS_BROKENHW)
       || (PDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_SURPRISE_REMOVING)) {

      KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);

      //
      // Accept all PNP IRP's -- we assume PNP can synchronize itself
      //

      if (pIrpStack->MajorFunction == IRP_MJ_PNP) {
         return STATUS_SUCCESS;
      }

      PIrp->IoStatus.Status = STATUS_DELETE_PENDING;
      return STATUS_DELETE_PENDING;
   }

   if (PDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_STOPPING) {
       KIRQL oldIrql;

       KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);


      //
      // Accept all PNP IRP's -- we assume PNP can synchronize itself
      //

      if (pIrpStack->MajorFunction == IRP_MJ_PNP) {
         return STATUS_SUCCESS;
      }

      IoAcquireCancelSpinLock(&oldIrql);

      if (PIrp->Cancel) {
         IoReleaseCancelSpinLock(oldIrql);
         PIrp->IoStatus.Status = STATUS_CANCELLED;
         return STATUS_CANCELLED;
      } else {
         //
         // Mark the Irp as pending
         //

         PIrp->IoStatus.Status = STATUS_PENDING;
         IoMarkIrpPending(PIrp);

         //
         // Queue up the IRP
         //

         InsertTailList(&PDevExt->StalledIrpQueue,
                        &PIrp->Tail.Overlay.ListEntry);

         IoSetCancelRoutine(PIrp, MoxaFilterCancelQueued);
         IoReleaseCancelSpinLock(oldIrql);
         return STATUS_PENDING;
      }
   }

   KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);

   return STATUS_SUCCESS;
}


VOID
MoxaUnstallIrps(IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine will be used to restart irps temporarily stalled on
    the stall queue due to a stop or some such nonsense.
    
Arguments:

    PDevExt - Pointer to the device extension

Return Value:

    None.

--*/
{
   PLIST_ENTRY pIrpLink;
   PIRP pIrp;
   PIO_STACK_LOCATION pIrpStack;
   PDEVICE_OBJECT pDevObj;
   PDRIVER_OBJECT pDrvObj;
   KIRQL oldIrql;

   MoxaKdPrint(
                MX_DBG_TRACE,
                ("Entering MoxaUnstallIrps\n"));
   IoAcquireCancelSpinLock(&oldIrql);

   pIrpLink = PDevExt->StalledIrpQueue.Flink;

   while (pIrpLink != &PDevExt->StalledIrpQueue) {
      pIrp = CONTAINING_RECORD(pIrpLink, IRP, Tail.Overlay.ListEntry);
      pIrpLink = pIrp->Tail.Overlay.ListEntry.Flink;
      RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
      pDevObj = pIrpStack->DeviceObject;
      pDrvObj = pDevObj->DriverObject;
      IoSetCancelRoutine(pIrp, NULL);
      IoReleaseCancelSpinLock(oldIrql);

      MoxaKdPrint(MX_DBG_TRACE,("Unstalling Irp 0x%x with 0x%x\n",
                               pIrp, pIrpStack->MajorFunction));

      pDrvObj->MajorFunction[pIrpStack->MajorFunction](pDevObj, pIrp);

      IoAcquireCancelSpinLock(&oldIrql);
   }

   IoReleaseCancelSpinLock(oldIrql);

   MoxaKdPrint(MX_DBG_TRACE,("Leaving MoxaUnstallIrps\n"));
}






NTSTATUS
MoxaIRPPrologue(IN PIRP PIrp, IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called at any IRP dispatch entry point.  It,
   with SerialIRPEpilogue(), keeps track of all pending IRP's for the given
   PDevObj.
   
Arguments:

   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:

    Tentative status of the Irp.

--*/
{
   InterlockedIncrement(&PDevExt->PendingIRPCnt);

   return MoxaFilterIrps(PIrp, PDevExt);
}




VOID
MoxaIRPEpilogue(IN PMOXA_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called at any IRP dispatch entry point.  It,
   with MoxaIRPPrologue(), keeps track of all pending IRP's for the given
   PDevObj.
   
Arguments:

   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:

   None.

--*/
{
   LONG pendingCnt;

   pendingCnt = InterlockedDecrement(&PDevExt->PendingIRPCnt);
//MoxaKdPrint(MX_DBG_TRACE,("MoxaIRPEpilogue = %x\n",PDevExt));

//   ASSERT(pendingCnt >= 0);

   if (pendingCnt == 0) {
      KeSetEvent(&PDevExt->PendingIRPEvent, IO_NO_INCREMENT, FALSE);
   }
}

VOID
MoxaSetDeviceFlags(IN PMOXA_DEVICE_EXTENSION PDevExt, OUT PULONG PFlags, 
                     IN ULONG Value, IN BOOLEAN Set)
/*++

Routine Description:

   Sets flags in a value protected by the flags spinlock.  This is used
   to set values that would stop IRP's from being accepted.
   
Arguments:
   PDevExt - Device extension attached to PDevObj
   
   PFlags - Pointer to the flags variable that needs changing
   
   Value - Value to modify flags variable with
   
   Set - TRUE if |= , FALSE if &=
   
Return Value:

   None.

--*/
{
   KIRQL oldIrql;

   KeAcquireSpinLock(&PDevExt->FlagsLock, &oldIrql);

   if (Set) {
      *PFlags |= Value;
   } else {
      *PFlags &= ~Value;
   }

   KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrql);
}


NTSTATUS
MoxaIoCallDriver(PMOXA_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                   PIRP PIrp)
/*++

Routine Description:

   This function must be called instead of IoCallDriver.  It automatically
   updates Irp tracking for PDevObj.
   
Arguments:
   PDevExt - Device extension attached to PDevObj
   
   PDevObj - Pointer to the device object we are tracking pending IRP's for.
   
   PIrp - Pointer to the Irp we are passing to the next driver.

Return Value:

   None.

--*/
{
   NTSTATUS status;

   status = IoCallDriver(PDevObj, PIrp);
   MoxaIRPEpilogue(PDevExt);
   return status;
}




NTSTATUS
MoxaPoCallDriver(PMOXA_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                   PIRP PIrp)
/*++

Routine Description:

   This function must be called instead of PoCallDriver.  It automatically
   updates Irp tracking for PDevObj.
   
Arguments:
   PDevExt - Device extension attached to PDevObj
   
   PDevObj - Pointer to the device object we are tracking pending IRP's for.
   
   PIrp - Pointer to the Irp we are passing to the next driver.

Return Value:

   None.

--*/
{
   NTSTATUS status;

   status = PoCallDriver(PDevObj, PIrp);
   MoxaIRPEpilogue(PDevExt);
   return status;
}


VOID
MoxaKillPendingIrps(PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   This routine kills any irps pending for the passed device object.
   
Arguments:

    PDevObj - Pointer to the device object whose irps must die.

Return Value:

    VOID

--*/
{
   PMOXA_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL oldIrql;
   
   MoxaKdPrint (MX_DBG_TRACE,("Enter MoxaKillPendingIrps\n"));

   //
   // First kill all the reads and writes.
   //

   MoxaKillAllReadsOrWrites(PDevObj, &pDevExt->WriteQueue,
                               &pDevExt->CurrentWriteIrp);

   MoxaKillAllReadsOrWrites(PDevObj, &pDevExt->ReadQueue,
                               &pDevExt->CurrentReadIrp);

   //
   // Next get rid of purges.
   //

   MoxaKillAllReadsOrWrites(PDevObj, &pDevExt->PurgeQueue,
                               &pDevExt->CurrentPurgeIrp);

   //
   // Get rid of any mask operations.
   //

   MoxaKillAllReadsOrWrites(PDevObj, &pDevExt->MaskQueue,
                               &pDevExt->CurrentMaskIrp);

   //
   // Now get rid a pending wait mask irp.
   //

   IoAcquireCancelSpinLock(&oldIrql);

   if (pDevExt->CurrentWaitIrp) {

       PDRIVER_CANCEL cancelRoutine;

       cancelRoutine = pDevExt->CurrentWaitIrp->CancelRoutine;
       pDevExt->CurrentWaitIrp->Cancel = TRUE;

       if (cancelRoutine) {

           pDevExt->CurrentWaitIrp->CancelIrql = oldIrql;
           pDevExt->CurrentWaitIrp->CancelRoutine = NULL;

           cancelRoutine(PDevObj, pDevExt->CurrentWaitIrp);

       }

   } else {

       IoReleaseCancelSpinLock(oldIrql);

   }

   //
   // Cancel any pending wait-wake irps
   //

   if (pDevExt->PendingWakeIrp != NULL) {
       IoCancelIrp(pDevExt->PendingWakeIrp);
       pDevExt->PendingWakeIrp = NULL;
   }

   //
   // Finally, dump any stalled IRPS
   //

   MoxaKillAllStalled(PDevObj);


   MoxaKdPrint (MX_DBG_TRACE, ("Leave MoxaKillPendingIrps\n"));
}



VOID
MoxaReleaseResources(IN PMOXA_DEVICE_EXTENSION pDevExt)
/*++

Routine Description:

    Releases resources (not pool) stored in the device extension.
    
Arguments:

    pDevExt - Pointer to the device extension to release resources from.

Return Value:

    VOID

--*/
{
//   PAGED_CODE();
   BOOLEAN	anyPortExist = TRUE;
   ULONG    port,i;
   PDEVICE_OBJECT	pDevObj;
   UNICODE_STRING	deviceLinkUnicodeString;
   PMOXA_DEVICE_EXTENSION pDevExt1;
 
   MoxaKdPrint(MX_DBG_TRACE,("Enter MoxaReleaseResources\n"));

   
 
//   KeSynchronizeExecution(pDevExt->Interrupt, MoxaCleanInterruptShareLists, pDevExt);
MoxaCleanInterruptShareLists(pDevExt);


   //
   // Stop servicing interrupts if we are the last one
   //

   for (i = 0; i < MoxaGlobalData->NumPorts[pDevExt->BoardNo]; i++) {
	 port = pDevExt->BoardNo*MAXPORT_PER_CARD + i;
	 if ((pDevExt1 = MoxaGlobalData->Extension[port]) != NULL) {
   	     if (pDevExt1->PortIndex != pDevExt->PortIndex) {
               MoxaKdPrint(MX_DBG_TRACE,("There is still a port in this board %d/%d\n",i,port));
	 	   break;
	     }
	 }
   }

   if ( i == MoxaGlobalData->NumPorts[pDevExt->BoardNo]) {
       MoxaKdPrint(MX_DBG_TRACE,("It is the last port of this board\n"));
       anyPortExist = FALSE;
       
       for (i = 0; i < MAX_CARD; i++) {
	     if (MoxaGlobalData->CardType[i] && (i != pDevExt->BoardNo))	
		   break;
       }
       if (i == MAX_CARD) {
	     MoxaKdPrint(MX_DBG_TRACE,("No more devices,so delete control device\n"));
  	     RtlInitUnicodeString (
                    &deviceLinkUnicodeString,
                    CONTROL_DEVICE_LINK
                    );

           IoDeleteSymbolicLink(&deviceLinkUnicodeString);
	     pDevObj=MoxaGlobalData->DriverObject->DeviceObject;
	     while (pDevObj) {
	            MoxaKdPrint(MX_DBG_TRACE,("There is still a devices\n"));
		      if (((PMOXA_DEVICE_EXTENSION)(pDevObj->DeviceExtension))->ControlDevice) {
			    MoxaKdPrint(MX_DBG_TRACE,("Is Control Device,so delete it\n"));
			    IoDeleteDevice(pDevObj);
			    break;
		      }
		      pDevObj=pDevObj->NextDevice;
	     }
	
		
       }
	

   }

   pDevExt->Interrupt = NULL;
  
   //
   // Stop handling timers
   //

   MoxaCancelTimer(&pDevExt->ReadRequestTotalTimer, pDevExt);
   MoxaCancelTimer(&pDevExt->ReadRequestIntervalTimer, pDevExt);
   MoxaCancelTimer(&pDevExt->WriteRequestTotalTimer, pDevExt);
  

   //
   // Stop servicing DPC's
   //

   MoxaRemoveQueueDpc(&pDevExt->CompleteWriteDpc, pDevExt);
   MoxaRemoveQueueDpc(&pDevExt->CompleteReadDpc, pDevExt);
   MoxaRemoveQueueDpc(&pDevExt->TotalReadTimeoutDpc, pDevExt);
   MoxaRemoveQueueDpc(&pDevExt->IntervalReadTimeoutDpc, pDevExt);
   MoxaRemoveQueueDpc(&pDevExt->TotalWriteTimeoutDpc, pDevExt);
   MoxaRemoveQueueDpc(&pDevExt->CommErrorDpc, pDevExt);
   MoxaRemoveQueueDpc(&pDevExt->CommWaitDpc, pDevExt);
  
   //
   // Remove us from any lists we may be on
   //
   
   MoxaGlobalData->Extension[pDevExt->PortNo] = NULL;
   MoxaExtension[MoxaGlobalData->ComNo[pDevExt->BoardNo][pDevExt->PortIndex]] = NULL;

   if (anyPortExist == FALSE ) {
       MoxaKdPrint(MX_DBG_TRACE,("Free the global info. associated with this board\n"));
       MoxaGlobalData->Interrupt[pDevExt->BoardNo] = NULL;
  	 MoxaGlobalData->CardType[pDevExt->BoardNo] = 0;
	 MoxaGlobalData->InterfaceType[pDevExt->BoardNo] = 0;
	 MoxaGlobalData->IntVector[pDevExt->BoardNo] = 0;
	 MoxaGlobalData->PciIntAckBase[pDevExt->BoardNo] = NULL;
	 MoxaGlobalData->CardBase[pDevExt->BoardNo] = 0;
	 MoxaGlobalData->IntNdx[pDevExt->BoardNo] = NULL;
	 MoxaGlobalData->IntPend[pDevExt->BoardNo] = NULL;
	 MoxaGlobalData->IntTable[pDevExt->BoardNo] = NULL;
	 MoxaGlobalData->NumPorts[pDevExt->BoardNo] = 0;
	 RtlZeroMemory(&MoxaGlobalData->PciIntAckPort[pDevExt->BoardNo],sizeof(PHYSICAL_ADDRESS));
       RtlZeroMemory(&MoxaGlobalData->BankAddr[pDevExt->BoardNo],sizeof(PHYSICAL_ADDRESS));
        
   }
 
    
}


VOID
MoxaDisableInterfacesResources(IN PDEVICE_OBJECT PDevObj,
                                 BOOLEAN DisableUART)
{
   PMOXA_DEVICE_EXTENSION pDevExt
      = (PMOXA_DEVICE_EXTENSION)PDevObj->DeviceExtension;

 //  PAGED_CODE();

   MoxaKdPrint(MX_DBG_TRACE,("Enter MoxaDisableInterfaces\n"));

   //
   // Only do these many things if the device has started and still
   // has resources allocated
   //

//   if (pDevExt->Flags & SERIAL_FLAGS_STARTED) {
       if (!(pDevExt->Flags & SERIAL_FLAGS_STOPPED)) {

          if (DisableUART) {
             //
             // Mask off interrupts
             //

      // ?????       DISABLE_ALL_INTERRUPTS(pDevExt->Controller);
          }

          MoxaReleaseResources(pDevExt);
       }

      //
      // Remove us from WMI consideration
      //

      IoWMIRegistrationControl(PDevObj, WMIREG_ACTION_DEREGISTER);
//   }

   //
   // Undo external names
   //

   MoxaUndoExternalNaming(pDevExt);
}





NTSTATUS
MoxaRemoveDevObj(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    Removes a serial device object from the system.
    
Arguments:

    PDevObj - A pointer to the Device Object we want removed.

Return Value:

    Always TRUE

--*/
{
   PMOXA_DEVICE_EXTENSION pDevExt
      = (PMOXA_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   //PAGED_CODE();


 
   MoxaKdPrint (MX_DBG_TRACE,("Enter MoxaRemoveDevObj\n"));

   if (!(pDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_SURPRISE_REMOVING)) {
      //
      // Disable all external interfaces and release resources
      //

      MoxaDisableInterfacesResources(PDevObj,TRUE);  
   }
 
   IoDetachDevice(pDevExt->LowerDeviceObject);

   //
   // Free memory allocated in the extension
   //

   if (pDevExt->DeviceName.Buffer != NULL) {
      ExFreePool(pDevExt->DeviceName.Buffer);
   }

   if (pDevExt->SymbolicLinkName.Buffer != NULL) {
      ExFreePool(pDevExt->SymbolicLinkName.Buffer);
   }

   if (pDevExt->ObjectDirectory.Buffer) {
      ExFreePool(pDevExt->ObjectDirectory.Buffer);
   }

   //
   // Delete the devobj
   //

   IoDeleteDevice(PDevObj);


   MoxaKdPrint (MX_DBG_TRACE, ("Leave SerialRemoveDevObj\n"));

   return STATUS_SUCCESS;
}

NTSTATUS
MoxaIoSyncIoctlEx(ULONG Ioctl, BOOLEAN Internal, PDEVICE_OBJECT PDevObj,
                      PKEVENT PEvent, PIO_STATUS_BLOCK PIoStatusBlock,
                      PVOID PInBuffer, ULONG InBufferLen, PVOID POutBuffer,                    // output buffer - optional
                      ULONG OutBufferLen)
/*++

Routine Description:
    Performs a synchronous IO control request by waiting on the event object
    passed to it.  The IRP is deallocated by the IO system when finished.

Return value:
    NTSTATUS

--*/
{
    PIRP pIrp;
    NTSTATUS status;

    KeClearEvent(PEvent);

    // Allocate an IRP - No need to release
    // When the next-lower driver completes this IRP, the IO Mgr releases it.

    pIrp = IoBuildDeviceIoControlRequest(Ioctl, PDevObj, PInBuffer, InBufferLen,
                                         POutBuffer, OutBufferLen, Internal,
                                         PEvent, PIoStatusBlock);

    if (pIrp == NULL) {
        MoxaKdPrint (MX_DBG_TRACE, ("Failed to allocate IRP\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = MoxaIoSyncReq(PDevObj, pIrp, PEvent);


    if (status == STATUS_SUCCESS) {
       status = PIoStatusBlock->Status;
    }

    return status;
}


NTSTATUS
MoxaIoSyncReq(PDEVICE_OBJECT PDevObj, IN PIRP PIrp, PKEVENT PEvent)
/*++

Routine Description:
    Performs a synchronous IO request by waiting on the event object
    passed to it.  The IRP is deallocated by the IO system when finished.

Return value:
    NTSTATUS

--*/
{
   NTSTATUS status;

   status = IoCallDriver(PDevObj, PIrp);

   if (status == STATUS_PENDING) {
      // wait for it...
      status = KeWaitForSingleObject(PEvent, Executive, KernelMode, FALSE,
                                     NULL);
   }

    return status;
}


BOOLEAN
MoxaCleanInterruptShareLists(IN PMOXA_DEVICE_EXTENSION pDevExt )
/*++

Routine Description:

    Removes a device object from any of the serial linked lists it may
    appear on.
    
Arguments:

    Context - Actually a PMOXA_DEVICE_EXTENSION (for the devobj being
              removed).

Return Value:

  
--*/
{
   PLIST_ENTRY interruptEntry;
   PMOXA_CISR_SW cisrsw;
   PMOXA_DEVICE_EXTENSION pDevExt1;
   PMOXA_GLOBAL_DATA globalData = pDevExt->GlobalData;
   ULONG	cardNo,port,i;
   PMOXA_MULTIPORT_DISPATCH	dispatch;


//   ASSERT(!IsListEmpty(pDevExt->InterruptShareList));
   if (IsListEmpty(pDevExt->InterruptShareList))
	return (FALSE);

   //
   // Stop servicing interrupts if we are the last one
   //

   for ( i = 0; i < globalData->NumPorts[pDevExt->BoardNo]; i++) {
       port = pDevExt->BoardNo*MAXPORT_PER_CARD + i;
	 if ((pDevExt1 = globalData->Extension[port]) != NULL) {
   	     if (pDevExt1->PortIndex != pDevExt->PortIndex) {
               MoxaKdPrint(MX_DBG_TRACE,("There is still a port in this board %d/%d\n",i,port));
	 	   break;
	     }
	 }
   }

   if ( i != globalData->NumPorts[pDevExt->BoardNo])
	 return (TRUE);

   MoxaKdPrint(MX_DBG_TRACE,("It is the last port of this board\n"));
   MoxaKdPrint(MX_DBG_TRACE,("Interrupt share list = %x\n",pDevExt->InterruptShareList));

  
   interruptEntry = (pDevExt->InterruptShareList)->Flink;

   do {
       MoxaKdPrint(MX_DBG_TRACE,("find list\n"));
       cisrsw = CONTAINING_RECORD(interruptEntry,
                                  MOXA_CISR_SW,
                                  SharerList
                                  );
       MoxaKdPrint(MX_DBG_TRACE,("cisrsw = %x\n",cisrsw));

      if (!cisrsw)
	    return (FALSE);
	dispatch = &cisrsw->Dispatch;
	cardNo = dispatch->BoardNo;
      MoxaKdPrint(MX_DBG_TRACE,("cardNo = %x\n",cardNo));
      if (cardNo == pDevExt->BoardNo) {
      
          MoxaRemoveLists(interruptEntry);
          MoxaKdPrint(MX_DBG_TRACE,("list removed\n"));
          if (IsListEmpty(pDevExt->InterruptShareList)) {
 	        MoxaKdPrint(MX_DBG_TRACE,("No more board use this IRQ so Disconnect it\n"));
              IoDisconnectInterrupt(pDevExt->Interrupt);
              MoxaKdPrint(MX_DBG_TRACE,("free share list\n"));
    		  ExFreePool(pDevExt->InterruptShareList);
          }
          MoxaKdPrint(MX_DBG_TRACE,("free others\n"));

    	    ExFreePool(cisrsw);
          MoxaKdPrint(MX_DBG_TRACE,("free ok\n"));
	    return (TRUE);
	}
      interruptEntry = interruptEntry->Flink;
      MoxaKdPrint(MX_DBG_TRACE,("get next\n"));

   }
   while (interruptEntry != pDevExt->InterruptShareList);

   return (FALSE);
}


BOOLEAN
MoxaRemoveLists(IN PVOID Context)
/*++

Routine Description:

    Removes a list entry from the InterruptShareList.
        
Arguments:

    Context - Actually a list entry of InterruptShareList .

Return Value:

    Always TRUE

--*/
{
   	PLIST_ENTRY 	pListEntry = (PLIST_ENTRY)Context;
 
	RemoveEntryList(pListEntry);
	return (TRUE);
}


VOID
MoxaUnlockPages(IN PKDPC PDpc, IN PVOID PDeferredContext,
                  IN PVOID PSysContext1, IN PVOID PSysContext2)
/*++

Routine Description:

   This function is a DPC routine queue from the ISR if he released the
   last lock on pending DPC's.
   
Arguments:

   PDpdc, PSysContext1, PSysContext2 -- not used
   
   PDeferredContext -- Really the device extension

Return Value:

   None.

--*/
{
   PMOXA_DEVICE_EXTENSION pDevExt
      = (PMOXA_DEVICE_EXTENSION)PDeferredContext;

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(PSysContext1);
   UNREFERENCED_PARAMETER(PSysContext2);

   KeSetEvent(&pDevExt->PendingDpcEvent, IO_NO_INCREMENT, FALSE);
}

VOID
MoxaLoop()
{
    LARGE_INTEGER   targetTc, newTc, currTc, newTc1;
    ULONG           unit, count;
    LARGE_INTEGER   interval;           /* 1 ms */

    KeQueryTickCount(&currTc);

    unit = KeQueryTimeIncrement();

    currTc = RtlExtendedIntegerMultiply(currTc, unit);

    interval = RtlConvertUlongToLargeInteger(10000L);

    targetTc = RtlLargeIntegerAdd(currTc, interval);

    MoxaLoopCnt = 0;

    do {

        KeQueryTickCount(&newTc);

        newTc = RtlExtendedIntegerMultiply(newTc, unit);

        MoxaLoopCnt++;

    } while (!RtlLargeIntegerGreaterThanOrEqualTo(newTc, targetTc));

    MoxaLoopCnt += 0x1000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\immediat.c ===
#include "precomp.h"		
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    immediat.c

Abstract:

    This module contains the code that is very specific to transmit
    immediate character operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


VOID
SerialGetNextImmediate(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    );


VOID
SerialStartImmediate(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will calculate the timeouts needed for the
    write.  It will then hand the irp off to the isr.  It
    will need to be careful incase the irp has been canceled.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;


    UseATimer = FALSE;
    pPort->CurrentImmediateIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pPort->CurrentImmediateIrp);

    //
    // Calculate the timeout value needed for the
    // request.  Note that the values stored in the
    // timeout record are in milliseconds.  Note that
    // if the timeout values are zero then we won't start
    // the timer.
    //

    KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
        
    Timeouts = pPort->Timeouts;

    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
        

    if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier) 
	{
        UseATimer = TRUE;

        //
        // We have some timer values to calculate.
        //

        TotalTime = RtlEnlargedUnsignedMultiply(1, Timeouts.WriteTotalTimeoutMultiplier);
        TotalTime = RtlLargeIntegerAdd(TotalTime, RtlConvertUlongToLargeInteger(Timeouts.WriteTotalTimeoutConstant));
        TotalTime = RtlExtendedIntegerMultiply(TotalTime, -10000);
    }

    //
    // As the irp might be going to the isr, this is a good time
    // to initialize the reference count.
    //
    SERIAL_INIT_REFERENCE(pPort->CurrentImmediateIrp);

    //
    // We need to see if this irp should be canceled.
    //
    IoAcquireCancelSpinLock(&OldIrql);

    if(pPort->CurrentImmediateIrp->Cancel) 
	{

        PIRP OldIrp = pPort->CurrentImmediateIrp;

        pPort->CurrentImmediateIrp = NULL;
        IoReleaseCancelSpinLock(OldIrql);

        OldIrp->IoStatus.Status = STATUS_CANCELLED;
        OldIrp->IoStatus.Information = 0;

		SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(OldIrp, 0);

    } 
	else 
	{
        //
        // We give the irp to to the isr to write out.
        // We set a cancel routine that knows how to
        // grab the current write away from the isr.
        //
        IoSetCancelRoutine(pPort->CurrentImmediateIrp, SerialCancelImmediate);
            
        //
        // Since the cancel routine knows about the irp we
        // increment the reference count.
        //

        SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);

        if(UseATimer) 
		{

            KeSetTimer(&pPort->ImmediateTotalTimer, TotalTime, &pPort->TotalImmediateTimeoutDpc);

            //
            // Since the timer knows about the irp we increment
            // the reference count.
            //
            SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);
        }

        KeSynchronizeExecution(pCard->Interrupt,SerialGiveImmediateToIsr,pPort);

        IoReleaseCancelSpinLock(OldIrql);
    }

}

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabImmediateFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

VOID
SerialGetNextImmediate(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This routine is used to complete the current immediate
    irp.  Even though the current immediate will always
    be completed and there is no queue associated with it,
    we use this routine so that we can try to satisfy
    a wait for transmit queue empty event.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.  This should point
                   to CurrentImmediateIrp.

    QueueToProcess - Always NULL.

    NewIrp - Always NULL on exit to this routine.

    CompleteCurrent - Should always be true for this routine.


Return Value:

    None.

--*/

{

    KIRQL OldIrql;
	PCARD_DEVICE_EXTENSION pCard = NULL;

	PIRP OldIrp = *CurrentOpIrp;

    UNREFERENCED_PARAMETER(QueueToProcess);
    UNREFERENCED_PARAMETER(CompleteCurrent);

	pPort = CONTAINING_RECORD(CurrentOpIrp,PORT_DEVICE_EXTENSION,CurrentImmediateIrp);
	pCard = pPort->pParentCardExt;

    IoAcquireCancelSpinLock(&OldIrql);

    ASSERT(pPort->TotalCharsQueued >= 1);
    pPort->TotalCharsQueued--;

    *CurrentOpIrp = NULL;
    *NewIrp = NULL;
    KeSynchronizeExecution(
        pCard->Interrupt,
        SerialProcessEmptyTransmit,
        pPort
        );

    IoReleaseCancelSpinLock(OldIrql);

	SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(OldIrp, IO_SERIAL_INCREMENT);
}

VOID
SerialCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabImmediateFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TransmitImmediate = TRUE;
    pPort->ImmediateChar =
        *((UCHAR *)
         (pPort->CurrentImmediateIrp->AssociatedIrp.SystemBuffer));

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);

    //
    // Check first to see if a write is going on.  If
    // there is then we'll just slip in during the write.
    //

    if (!pPort->WriteLength) {

        //
        // If there is no normal write transmitting then we
        // will "re-enable" the transmit holding register empty
        // interrupt.  The 8250 family of devices will always
        // signal a transmit holding register empty interrupt
        // *ANY* time this bit is set to one.  By doing things
        // this way we can simply use the normal interrupt code
        // to start off this write.
        //
        // We've been keeping track of whether the transmit holding
        // register is empty so it we only need to do this
        // if the register is empty.
        //

        if (pPort->HoldingEmpty) {
//---------------------------------------------------- VIV  8/5/1993 begin 
//            DISABLE_ALL_INTERRUPTS(pPort->Controller);
//            ENABLE_ALL_INTERRUPTS(pPort->Controller);
            Io8_EnableTxInterrupts(pPort);
//---------------------------------------------------- VIV  8/5/1993 end   

        }

    }

    return FALSE;

}

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->TransmitImmediate) {

        pPort->TransmitImmediate = FALSE;

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentImmediateIrp);

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\io8_log.h ===
/*++

Copyright (c) 1998  Specialix International Ltd.

Abstract:

    Constant definitions for the I/O error code log values.

--*/

#ifndef IO8_LOG_H
#define IO8_LOG_H

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SPX_SEVERITY_SUCCESS
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_SUCCESS             ((NTSTATUS)0x00060001L)

//
// MessageId: SPX_SEVERITY_INFORMATIONAL
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_INFORMATIONAL       ((NTSTATUS)0x40060002L)

//
// MessageId: SPX_SEVERITY_WARNING
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_WARNING             ((NTSTATUS)0x80060003L)

//
// MessageId: SPX_SEVERITY_ERROR
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_ERROR               ((NTSTATUS)0xC0060004L)


#endif // End of IO8_LOG.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\error.c ===
#include "precomp.h"			
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the code that is very specific to error
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device object.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialKillAllReadsOrWrites(
        pPort->DeviceObject,
        &pPort->WriteQueue,
        &pPort->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        pPort->DeviceObject,
        &pPort->ReadQueue,
        &pPort->CurrentReadIrp
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\flush.c ===
#include "precomp.h"				
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module contains the code that is very specific to flush
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


NTSTATUS
SerialStartFlush(
    IN PPORT_DEVICE_EXTENSION pPort
    );


NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    Irp->IoStatus.Information = 0L;

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    return SerialStartOrQueue(pPort, Irp, &pPort->WriteQueue, &pPort->CurrentWriteIrp, SerialStartFlush);
}


NTSTATUS
SerialStartFlush(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.

Arguments:

    pPort - Points to the serial device extension

Return Value:

    This will always return STATUS_SUCCESS.

--*/

{

    PIRP NewIrp;

    pPort->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    //
    // The following call will actually complete the flush.
    //
    SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);
        
    if(NewIrp) 
	{
        ASSERT(NewIrp == pPort->CurrentWriteIrp);
        SerialStartWrite(pPort);
    }

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\io8_iioc.c ===
/************************************************************************/
/*																		*/
/*	Title		:	IO8 support funcs for INTERNAL IOCTLs				*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Support functions to support the					*/
/*					INTERNAL IOCTLs for specific hardware:				*/
/*					XXX_SetHandFlow										*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#include "precomp.h"

/*****************************************************************************
*****************************                     ****************************
*****************************   XXX_SetHandFlow   ****************************
*****************************                     ****************************
******************************************************************************

prototype:		void XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_IOCTL_SYNC pS)

description:	Call to set the handshaking and flow control

parameters:		pPort points to the port device extension structure
				pS points to a serial ioctl synchronization structure

returns:		STATUS_SUCCESS

*/

void XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort,IN PSERIAL_IOCTL_SYNC pS)
{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	KeSynchronizeExecution(pCard->Interrupt, SerialSetHandFlow, pS);

}	/* XXX_SetHandFlow */
                                                        
/* End of IO8_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\io8_nt.c ===
#include "precomp.h"

/***************************************************************************\
*                                                                           *
*     IO8P_NT.C    -   IO8+ Intelligent I/O Board driver                    *
*                                                                           *
*     Copyright (c) 1992-1993 Ring Zero Systems, Inc.                       *
*     All Rights Reserved.                                                  *
*                                                                           *
\***************************************************************************/


// Io8_ prefix is used for Export functions.

#define inb( x )        READ_PORT_UCHAR( x )
#define outb( x, y )    WRITE_PORT_UCHAR( x, y )


/*************************************************************************\ 
*                                                                         *
* Internal Functions                                                      *
*                                                                         *
\*************************************************************************/
UCHAR io8_ibyte( PPORT_DEVICE_EXTENSION pPort, UCHAR Reg );
VOID  io8_obyte( PPORT_DEVICE_EXTENSION pPort, UCHAR Reg, UCHAR Value );

UCHAR io8_ibyte_addr( PUCHAR Addr, UCHAR Reg );
VOID io8_obyte_addr( PUCHAR Addr, UCHAR Reg, UCHAR Value );

BOOLEAN io8_set_ivect( ULONG Vector, PUCHAR Controller );
VOID io8_init( IN PVOID Context );

VOID let_command_finish( PPORT_DEVICE_EXTENSION pPort );

VOID io8_txint( IN PVOID Context );
VOID io8_rxint( IN PVOID Context );
VOID io8_mint( IN PVOID Context );

BOOLEAN SendTxChar( IN PVOID Context );
VOID PutReceivedChar( IN PPORT_DEVICE_EXTENSION pPort );
UCHAR GetModemStatusNoChannel( IN PVOID Context );
VOID ExceptionHandle( IN PPORT_DEVICE_EXTENSION pPort, IN UCHAR exception );
VOID EnableTxInterruptsNoChannel( IN PVOID Context );

BOOLEAN Acknowledge( PCARD_DEVICE_EXTENSION pCard, UCHAR srsr );

/*************************************************************************\ 
*                                                                         *
* BOOLEAN Io8_SwitchCardInterrupt(IN PVOID Context)                       *
*                                                                         *
* Check for an IO8 at given address                                       *
\*************************************************************************/
BOOLEAN Io8_SwitchCardInterrupt(IN PVOID Context)
{
	PCARD_DEVICE_EXTENSION	pCard	= Context;
	PUCHAR					Addr	= pCard->Controller;

	outb(Addr + 1, GSVR & 0x7F);	// Select harmless register without top bit set.  
	
	return TRUE;
}

/*************************************************************************\ 
*                                                                         *
* BOOLEAN Io8_Present( IN PVOID Context )                                 *
*                                                                         *
* Check for an IO8 at given address                                       *
\*************************************************************************/
BOOLEAN Io8_Present( IN PVOID Context )
{
	PCARD_DEVICE_EXTENSION pCard = Context;
	PUCHAR Addr = pCard -> Controller;

	volatile int wait = 0;		// don't want wait to be optimised
	CHAR ready = 0, channel;
	unsigned char u, DSR_status, firm;

	// Reset card
	io8_obyte_addr( Addr, CAR & 0x7F, 0 );
	io8_obyte_addr( Addr, CCR & 0x7F, CHIP_RESET );
 
	// wait for GSVR to become set to 0xFF - this indicates card is ready 
	wait = 0;

	while ( ( wait < 500 ) && ( !ready ) )
	{
		u = io8_ibyte_addr( Addr, GSVR );

		if ( u == GSV_IDLE )
		{
			// also check that CCR has become zero
			u = io8_ibyte_addr( Addr, CCR );

			if ( u == 0 )
				ready = 1;
			else
				SerialDump( SERDIAG1,( "IO8+: GSVR FF but CCR not zero!\n", 0 ) );
		}
	  
		wait++;
	}

  
	if ( ready ) 
	{
		SerialDump( SERDIAG1,( "IO8+: card is ready -  wait %d\n",wait ) );
	}
	else
	{
		SerialDump( SERDIAG1,( "IO8+: Card not ready. GSVR %d, wait %d\n",u,wait ) );
		return 0; 
	}

	// Set GSVR to zero
	io8_obyte_addr( Addr, GSVR & 0x7F, 0 );

	// Read firmware version
	firm = io8_ibyte_addr( Addr, GFRCR );

	SerialDump( SERDIAG1,( "IO8+: Firmware revision %x\n", firm ) );

	// Read card ID from DSR lines
	u = 0;

	for(channel = 7; channel >= 0; channel--)
	{
		io8_obyte_addr(Addr, CAR & 0x7F, channel);

		u <<= 1;
		
		DSR_status = io8_ibyte_addr(Addr, MSVR);
		
		u |= ( ( ( ~DSR_status ) & MSVR_DSR ) / MSVR_DSR);
	}

	SerialDump( SERDIAG1,( "IO8+: card id is %u\n",u ) );

	if((u != IDENT)&&(u != IDENTPCI))
	{
		SerialDump( SERDIAG1,( "IO8+: Card at 0x%x, f/ware %u, wrong IDENT. Read %u, want %u\n",
					Addr,firm,u,IDENT ) );
	  return 0;
	}

  return u;
}




/*************************************************************************\ 
*                                                                         *
* BOOLEAN Io8_ResetBoard(IN PVOID Context)                                *
*                                                                         *
* Set interrupt vector for card and initialize.                           *
*                                                                         *
\*************************************************************************/
BOOLEAN Io8_ResetBoard(IN PVOID Context)
{
	PCARD_DEVICE_EXTENSION pCard = Context;

	if(pCard->InterfaceType == Isa)
	{
		if(!io8_set_ivect(pCard->OriginalVector, pCard->Controller))
			return FALSE;
	}

	io8_init(pCard);

	return TRUE;
}




/*************************************************************************\ 
*                                                                         *
* BOOLEAN io8_set_ivect( ULONG Vector, PUCHAR Controller )                *
*                                                                         *
* Tell card interrupt vector                                              *
*                                                                         *
\*************************************************************************/
BOOLEAN io8_set_ivect( ULONG Vector, PUCHAR Controller )
{ 
	UCHAR low_int = 0, high_int = 0;

	SerialDump( SERDIAG1,( "IO8+: io8_set_ivect for %x, Vector %ld.\n",
              Controller, Vector ) );
  
	switch ( Vector )
	{
	case 9 : low_int = 1; high_int = 1; break;
	  
	case 11: low_int = 0; high_int = 1; break;
	  
	case 12: low_int = 1; high_int = 0; break;
	  
	case 15: low_int = 0; high_int = 0; break;
	  
	default:
		SerialDump( SERDIAG1,( "IO8+: int vector unknown.\n", 0 ) );
		return FALSE;
	}

	// interrupts from the card should be disabled while we're doing this.
	io8_obyte_addr( Controller, CAR & 0x7f, 0 );
	io8_obyte_addr( Controller, MSVRTS & 0x7f, low_int );

	io8_obyte_addr( Controller, CAR & 0x7f, 1 );
	io8_obyte_addr( Controller, MSVRTS & 0x7f, high_int );

  return TRUE;
}


                                                                        

/***************************************************************************\
*                                                                           *
* VOID io8_init( IN PVOID Context )                                         *
*                                                                           *
* Initialise routine, called once at system startup.                        *
*                                                                           *
\***************************************************************************/
VOID io8_init( IN PVOID Context )
{
	PCARD_DEVICE_EXTENSION pCard = Context;
	ULONG count;

	// set prescaler registers. Frequency set is
	// clock frequency ( 12 500 000 )/count
	// count=25000 gives 2 ms period

	count = 25000;
	io8_obyte_addr( pCard->Controller, PPRL, ( UCHAR )( count & 0xff ) );
	io8_obyte_addr( pCard->Controller, PPRH, ( UCHAR )( ( count>>8 ) & 0xff ) );
	pCard->CrystalFrequency = 25000000;		/* Default crystal frequency */
//  io8_obyte_addr( pCard->Controller, SRCR, SRCR_REG_ACK_EN );
//  io8_obyte_addr( pCard->Controller, MSMR, 0xF5 );
//  io8_obyte_addr( pCard->Controller, TSMR, 0xF6 );
//  io8_obyte_addr( pCard->Controller, RSMR, 0xF7 );
}




/*************************************************************************\ 
*                                                                         *
* BOOLEAN Io8_ResetChannel( IN PVOID Context )                            *
*                                                                         *
* Initialize Channel.                                                     *
* SRER Interrupts will be enabled in EnableAllInterrupts().               *
*                                                                         *
* Return Value:                                                           *
*           Always FALSE.                                                 *
*                                                                         *
\*************************************************************************/
BOOLEAN Io8_ResetChannel( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	SETBAUD	SetBaud;

	SerialDump( SERDIAG1,( "IO8+: In Io8_ResetChannel for %x, Channel %d.\n",
				pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );
                                                                        
	//--------------------------------------------------------------------
	//
	// Software reset channel - this may affect RTS0 and RTS1, so
	// disable interrupts from card to avoid confusion
	//
	//--------------------------------------------------------------------

	let_command_finish( pPort );
	io8_obyte( pPort, CCR & 0x7f, CHAN_RESET );

	// To be safe, wait now for previous command to finish, with ints disabled.
	while ( io8_ibyte( pPort, CCR & 0x7f ) )
		SerialDump( SERDIAG1,( "IO8+: Wait for CCR.\n",0 ) );

	// Set up RTS0 and RTS1 for correct interrupt.
	io8_set_ivect( pCard->OriginalVector, pCard->Controller );

	//--------------------------------------------------------------------


	// Set Receive timeout
	io8_obyte( pPort, RTPR, 25 );

	// Enable register based service request acknowledgements.
	io8_obyte( pPort, SRCR, SRCR_REG_ACK_EN );

	// Set Xon/Xoff chars.
	Io8_SetChars( pPort );

	//
	// Now we set the line control, modem control, and the
	// baud to what they should be.
	//
	Io8_SetLineControl( pPort );
	SerialSetupNewHandFlow( pPort, &pPort->HandFlow );
	SerialHandleModemUpdate( pPort, FALSE );
	SetBaud.Baudrate = pPort->CurrentBaud;
	SetBaud.pPort = pPort;
	Io8_SetBaud(&SetBaud);

#if 0
	// Make sure that DTR is raised
	io8_obyte( pPort, MSVDTR, MSVR_DTR );
#endif

	// Enable Tx and Rx
	let_command_finish( pPort );
	io8_obyte( pPort, CCR, TXMTR_ENABLE | RCVR_ENABLE );

	// Service Request Enable Register will be set in EnableAllInterrupts();

	pPort->HoldingEmpty = TRUE;

	return FALSE;
}

#ifdef	TEST_CRYSTAL_FREQUENCY
/*****************************************************************************
****************************                     *****************************
****************************   Io8_TestCrystal   *****************************
****************************                     *****************************
******************************************************************************

Prototype:	BOOLEAN	Io8_TestCrystal(IN PVOID Context)

Description:	Determine the frequency of the crystal input to the CD1864/65 as follows:
				-	Assume default frequency of 25Mhz
				-	Set first channel to internal loopback,50,n,8,1
				-	Time sending of 5 characters (should be 1000mS at 25Mhz)
				-	CrystalFrequency = 25 000 000 * PeriodmS / 1000

Parameters:	Context points to a port device extension

Returns:	FALSE

*/

#define	DIVISOR_50	(USHORT)(25000000L / (16 * 2 * 50))		/* 50 baud divisior @ 25Mhz */

ULONG	KnownFrequencies[] = {25000000,50000000,16666666,33000000,66000000};
#define	MAXKNOWNFREQUENCIES	(sizeof(KnownFrequencies)/sizeof(ULONG))

BOOLEAN	Io8_TestCrystal(IN PVOID Context)
{
	PPORT_DEVICE_EXTENSION	pPort = Context;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	LARGE_INTEGER 			Delay1;
	LARGE_INTEGER 			Delay2;
	LARGE_INTEGER			Frequency;
	ULONG					Timeout = 0;
	ULONG					Latency;
	ULONG					Count;
	ULONG					Remainder;
	int						loop;

	SerialDump(SERDIAG1,("IO8+: In Io8_TestCrystal for %x, channel %d\n",
		pCard->Controller, pPort->ChannelNumber));

/* Select channel... */

	io8_obyte(pPort,CAR,pPort->ChannelNumber);		/* Select Channel */
	let_command_finish(pPort);					/* Wait for command to finish */

/* Reset channel... */

	io8_obyte(pPort,CCR&0x7f,CHAN_RESET);			/* Reset channel */
	
	while(io8_ibyte(pPort,CCR&0x7f));				/* Wait for command to finish */
	
	io8_obyte(pPort,RTPR,25);						/* Set receive timeout */
  	io8_obyte(pPort,SRCR,SRCR_REG_ACK_EN);			/* Enable register based service request acks */

/* Set channel speed and configuration... */

	io8_obyte(pPort,COR1,COR1_8_BIT|COR1_1_STOP|COR1_NO_PARITY);/* None,8,1 */
	io8_obyte(pPort,COR2,COR2_LLM);				/* Local Loopback Mode */
	io8_obyte(pPort,COR3,COR3_RXFIFO5);				/* Rx Int after 5 characters */
	io8_obyte(pPort,CCR,CCR_CHANGE_COR1|CCR_CHANGE_COR2|CCR_CHANGE_COR3);/* Notify COR123 changes */
	let_command_finish(pPort);					/* Wait for command to finish */
	io8_obyte(pPort,RBPRL,(UCHAR)(DIVISOR_50&0xFF));		/* Program receive divisors */
	io8_obyte(pPort,RBPRH,(UCHAR)(DIVISOR_50>>8));		/* to 50 baud */
	io8_obyte(pPort,TBPRL,(UCHAR)(DIVISOR_50&0xFF));		/* Program transmit divisors */
	io8_obyte(pPort,TBPRH,(UCHAR)(DIVISOR_50>>8));		/* to 50 baud */

/* Enable transmitter and receiver... */

	io8_obyte(pPort,CCR,TXMTR_ENABLE|RCVR_ENABLE);		/* Enable receiver and transmitter */
	let_command_finish(pPort);					/* Wait for command to finish */

/* Perform the first test with 5 characters... */

	pPort->CrystalFreqTestRxCount = 0;				/* Reset receive count */
	pPort->CrystalFreqTestChars = 5;				/* First test is with 5 characters */
	pPort->CrystalFreqTest = CRYSTALFREQTEST_TX;		/* Start test off */
	io8_obyte(pPort,SRER,SRER_RXDATA|SRER_TXMPTY);		/* Enable Rx/Tx interrupts */
	Timeout = 0;							/* Reset timeout */

	while((Timeout < 10000)&&(pPort->CrystalFreqTest))		/* Wait for test to finish, or timeout after 10 seconds */
	{
		Delay1 = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));	/* 100mS */
		KeDelayExecutionThread(KernelMode,FALSE,&Delay1);/* Wait */
		Timeout += 100;						/* Increase timeout */
	}

	io8_obyte(pPort,SRER,0);					/* Disable Rx/Tx interrupts */
	
	if(pPort->CrystalFreqTest)					/* If still set, then test has timed out */
	{
		SerialDump(SERERRORS,("IO8+: Io8_TestCrystal#1 for %x, Test Timeout\n",pCard->Controller));
		pPort->CrystalFreqTest = 0;				/* Reset test */
	}
	else	
		Delay1 = RtlLargeIntegerSubtract(pPort->CrystalFreqTestStopTime,pPort->CrystalFreqTestStartTime);

/* Perform second test for 1 character... */
	
	pPort->CrystalFreqTestRxCount = 0;				/* Reset receive count */
	pPort->CrystalFreqTestChars = 2;				/* Second test with 2 characters */
	pPort->CrystalFreqTest = CRYSTALFREQTEST_TX;		/* Start test off */
	io8_obyte(pPort,SRER,SRER_RXDATA|SRER_TXMPTY);		/* Enable Rx/Tx interrupts */
	Timeout = 0;
	/* Reset timeout */
	while((Timeout < 10000)&&(pPort->CrystalFreqTest))		/* Wait for test to finish, or timeout after 10 seconds */
	{
		Delay2 = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));	/* 100mS */
		KeDelayExecutionThread(KernelMode,FALSE,&Delay2);/* Wait */
		Timeout += 100;						/* Increase timeout */
	}

	io8_obyte(pPort,SRER,0);					/* Disable Rx/Tx interrupts */

/* Process the test results... */

	if(pPort->CrystalFreqTest)					/* If still set, then test has timed out */
	{
		SerialDump(SERERRORS,("IO8+: Io8_TestCrystal#2 for %x, Test Timeout\n",pCard->Controller));
		pPort->CrystalFreqTest = 0;				/* Reset test */
	}
	else
	{
		Delay2 = RtlLargeIntegerSubtract(pPort->CrystalFreqTestStopTime,pPort->CrystalFreqTestStartTime);
		Latency = (5 * Delay2.LowPart - 2 * Delay1.LowPart) / 2;
		Frequency = RtlExtendedLargeIntegerDivide
		(
			RtlEnlargedUnsignedMultiply(25000000L,10000000L),
			(ULONG)(Delay1.LowPart-Latency),
			&Remainder
		);

		SerialDump(SERDIAG1,("IO8+: In Io8_TestCrystal for %x, Delay = %ld nS, Latency = %ld nS, Frequency = %ld Hz\n",
			pCard->Controller,Delay1.LowPart-Latency,Latency,Frequency.LowPart));
		
		pCard->CrystalFrequency = Frequency.LowPart;	/* Set to the new frequency */
		
		for(loop = 0; loop < MAXKNOWNFREQUENCIES; loop++)	/* Check against known frequencies */
		{
			if((Frequency.LowPart >= (KnownFrequencies[loop]/100*95))
			 &&(Frequency.LowPart <= (KnownFrequencies[loop]/100*105)))
			{						/* Match +- 5% of known frequency */
			 	pCard->CrystalFrequency = KnownFrequencies[loop];
				break;
			}
		}

		SerialDump(SERDIAG1,("IO8+: In Io8_TestCrystal for %x, using frequency = %ld Hz\n",
			pCard->Controller,pCard->CrystalFrequency));

		Count = (pCard->CrystalFrequency*2/1000)/2;	/* Calculate prescaler for 2mS period */
		io8_obyte(pPort,PPRL,(UCHAR)(Count&0xff));		/* Reprogram prescaler for new frequency */
		io8_obyte(pPort,PPRH,(UCHAR)((Count>>8)&0xff));
	}

/* Disable the receiver, transmitter and interrupts... */

	io8_obyte(pPort,CCR,TXMTR_DISABLE|RCVR_DISABLE);		/* Disable receiver and transmitter */
	let_command_finish(pPort);					/* Wait for command to finish */

	return(FALSE);							/* Done */

} /* Io8_TestCrystal */
#endif

/*****************************************************************************
******************************                 *******************************
******************************   Io8_SetBaud   *******************************
******************************                 *******************************
******************************************************************************

Prototype:	BOOLEAN	Io8_SetBaud(IN PVOID Context)

Description:	Attempt to set the specified baud rate if error is +/- 5%

Parameters:	Context points to a SETBAUD structure

Returns:	FALSE

*/

BOOLEAN	Io8_SetBaud(IN PVOID Context)
{
	PSETBAUD				pSetBaud	= Context;
	PPORT_DEVICE_EXTENSION	pPort		= pSetBaud->pPort;
	PCARD_DEVICE_EXTENSION	pCard		= pPort->pParentCardExt;
	ULONG					Frequency	= pCard->CrystalFrequency;
	USHORT					Divisor;
	ULONG					Remainder;
	ULONG					ActualBaudrate;
	long					BaudError;

	SerialDump(SERDIAG1,("IO8+: In Io8_SetBaud %ld for %x, Channel %d.\n",
		pSetBaud->Baudrate, pCard->Controller, pPort->ChannelNumber));

// Calculate the divisor, actual baudrate and error... 

	if(pSetBaud->Baudrate > 0)
	{
		Divisor = (USHORT)(Frequency / (16 * 2 * pSetBaud->Baudrate));	// divisior need for this rate 
		Remainder = Frequency % (16 * 2 * pSetBaud->Baudrate);			// remainder 
		
		if(Remainder >= 16 * pSetBaud->Baudrate) 
			Divisor++;		// Round up divisor 
		
		if(Divisor > 0)
		{
			ActualBaudrate = Frequency / (16 * 2 * Divisor);				// actual rate to be set 
			BaudError = 100 - (ActualBaudrate * 100 / pSetBaud->Baudrate);	// % error 
			
			SerialDump(SERDIAG1,("IO8+: Divisor = %d, ActualBaudrate = %ld, BaudError = %ld\n",
				Divisor, ActualBaudrate, BaudError));

// Only set rate if error is within acceptable limits... 

			if((BaudError <= 5L) && (BaudError >= -5L))
			{
				io8_obyte(pPort, CAR, pPort->ChannelNumber);		// Select channel to program 
				io8_obyte(pPort, RBPRL, (UCHAR)(Divisor & 0xFF));	// Program receive divisors 
				io8_obyte(pPort, RBPRH, (UCHAR)(Divisor>>8));
				io8_obyte(pPort, TBPRL, (UCHAR)(Divisor & 0xFF));	// Program transmit divisors 
				io8_obyte(pPort, TBPRH, (UCHAR)(Divisor>>8));
				pPort->CurrentBaud = pSetBaud->Baudrate;			// Update the port extension 
				pSetBaud->Result = TRUE;							// Success 
			}
			else	
				pSetBaud->Result = FALSE;	// Failure 
		}
		else
			pSetBaud->Result = FALSE;	// Failure 
	}
	else
		pSetBaud->Result = FALSE;		// Failure 


	return FALSE;						// Done 

} // Io8_SetBaud 


/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_SetLineControl( IN PVOID Context )                            *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the Line Control of the device.                                    *
*                                                                           *
* Context - Pointer to a structure that contains a pointer to               *
*           the device extension.                                           *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_SetLineControl( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR LineControl;
	UCHAR cor1=0;

	SerialDump( SERDIAG1,( "IO8+: In Io8_SetLineControl <%X> for %x, Channel %d.\n",
			  pPort->LineControl, pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	LineControl = pPort->LineControl;

	cor1 = LineControl & SERIAL_DATA_MASK;

	if ( ( LineControl & SERIAL_STOP_MASK ) == SERIAL_2_STOP )
		cor1 |= COR1_2_STOP;
	else if ( ( LineControl & SERIAL_STOP_MASK ) == SERIAL_1_5_STOP )
		cor1 |= COR1_1_HALF_STOP;
	else if ( ( LineControl & SERIAL_STOP_MASK ) == SERIAL_1_STOP )
		cor1 |= COR1_1_STOP;

	if ( ( LineControl & SERIAL_PARITY_MASK ) == SERIAL_EVEN_PARITY )
		cor1 |= COR1_EVEN_PARITY;
	else if ( ( LineControl & SERIAL_PARITY_MASK ) == SERIAL_ODD_PARITY )
		cor1 |= COR1_ODD_PARITY;
	else if ( ( LineControl & SERIAL_PARITY_MASK ) == SERIAL_NONE_PARITY )
		cor1 |= COR1_NO_PARITY;
	else if ( ( LineControl & SERIAL_PARITY_MASK ) == SERIAL_MARK_PARITY )
		cor1 |= COR1_MARK_PARITY;
	else if ( ( LineControl & SERIAL_PARITY_MASK ) == SERIAL_SPACE_PARITY )
		cor1 |= COR1_SPACE_PARITY;

	SerialDump( SERDIAG3,( "IO8+: In Io8_SetLineControl: COR1 = <%X>\n", cor1 ) );

	io8_obyte( pPort, COR1, cor1 );
	let_command_finish( pPort );
	io8_obyte( pPort, CCR, COR1_CHANGED );
	return FALSE;
}




/***************************************************************************\
*                                                                           *
* VOID Io8_SetChars( IN PVOID Context )                                     *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set Special Chars.                                                     *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Io8_SetChars( IN PVOID Context )
{
	  PPORT_DEVICE_EXTENSION pPort = Context;
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
 
	// Set special chars 3 and 4 to the same values, otherwise null chars will
	// be interpreted as special chars.
	io8_obyte( pPort, SCHR1, pPort->SpecialChars.XonChar );
	io8_obyte( pPort, SCHR2, pPort->SpecialChars.XoffChar );
	io8_obyte( pPort, SCHR3, pPort->SpecialChars.XonChar );
	io8_obyte( pPort, SCHR4, pPort->SpecialChars.XoffChar );
}




/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_SetDTR( IN PVOID Context )                                    *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the DTR in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_SetDTR( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;


	SerialDump( SERDIAG1,( "IO8+: Setting DTR for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );
	io8_obyte( pPort, MSVDTR, MSVR_DTR );

	return FALSE;
}




/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_ClearDTR( IN PVOID Context )                                  *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the DTR in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_ClearDTR( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
    PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;


	SerialDump( SERDIAG1,( "IO8+: Clearing DTR for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );
	io8_obyte( pPort, MSVDTR, 0 );
	
	return FALSE;
}




/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_SendXon( IN PVOID Context )                                   *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to send Xoff Character.                                                   *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_SendXon( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
    PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	let_command_finish( pPort );
	io8_obyte( pPort, CCR, CCR_SEND_SC1 );


	//
	// If we send an xon, by definition we
	// can't be holding by Xoff.
	//
	pPort->TXHolding &= ~SERIAL_TX_XOFF;

	//
	// If we are sending an xon char then
	// by definition we can't be "holding"
	// up reception by Xoff.
	//
	pPort->RXHolding &= ~SERIAL_RX_XOFF;

	SerialDump( SERDIAG1,( "IO8+: Sending Xon for %x, Channel %d. "
			  "RXHolding = %d, TXHolding = %d\n",
			  pCard->Controller, pPort->ChannelNumber,
			  pPort->RXHolding, pPort->TXHolding ) );

	return FALSE;
}




#if 0

/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_SendXoff( IN PVOID Context )                                  *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to send Xoff Character.                                                   *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_SendXoff( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;


	//
	// We can't be sending an Xoff character
	// if the transmission is already held
	// up because of Xoff.  Therefore, if we
	// are holding then we can't send the char.
	//

	if ( pPort->TXHolding )
	{
		SerialDump( SERDIAG1,( "IO8+: Sending Xoff for %x, Channel %d.\n",
					pCard->Controller, pPort->ChannelNumber ) );
		return FALSE;
	}

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	let_command_finish( pPort );
	io8_obyte( pPort, CCR, CCR_SEND_SC2 );

	SerialDump( SERDIAG1,( "IO8+: Sending Xoff for %x, Channel %d. "
			  "RXHolding = %d, TXHolding = %d\n",
			  pCard->Controller, pPort->ChannelNumber,
			  pPort->RXHolding, pPort->TXHolding ) );

	return FALSE;
}

#endif




/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_SetFlowControl( IN PVOID Context )                            *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set Flow Control                                                       *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_SetFlowControl( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
  	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR cor2 = 0, cor3 = 0, mcor1 = 0;

	SerialDump( SERDIAG1,( "IO8+: Setting Flow Control RTS = <%X>, CTS = <%X> "
			  "for %x, Channel %d.\n",
			  pPort->HandFlow.FlowReplace,
			  pPort->HandFlow.ControlHandShake,
			  pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	// Enable detection of modem signal transition - Detect high to low
	mcor1 |= MCOR1_DSRZD | MCOR1_CDZD | MCOR1_CTSZD;


	if ( pPort->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE )
	{
		SerialDump( SERDIAG1,( "IO8+: Setting CTS Flow Control.\n",0 ) );
		cor2 |= COR2_CTSAE;
	}

	if ( (pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
		SERIAL_RTS_HANDSHAKE )
	{
		SerialDump( SERDIAG1,( "IO8+: Setting RTS Flow Control.\n",0 ) );
		mcor1 |= MCOR1_DTR_THR_6;
		cor3 |= COR3_RXFIFO5; // Should be 1 less than mcor1 threshold.
	}
	else
	{
		cor3 |= COR3_RXFIFO6;
	}


#if 0
	if ( ( pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK ) ==
		 SERIAL_TRANSMIT_TOGGLE )
	{
		SerialDump( SERDIAG1,( "IO8+: Setting RTS Automatic Output.\n",0 ) );
		cor2 |= COR2_RTSAO;   // RTS Automatic Output Enable
	}
#endif

	if ( pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE )
	{
		SerialDump( SERDIAG1,( "IO8+: Setting Receive Xon/Xoff Flow Control.\n",0 ) );
	}

	if ( pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT )
	{
		SerialDump( SERDIAG1,( "IO8+: Setting Transmit Xon/Xoff Flow Control.\n",0 ) );
		cor3 |= COR3_SCDE;
		cor2 |= COR2_TXIBE;
	}

	io8_obyte( pPort, COR2, cor2 );
	io8_obyte( pPort, COR3, cor3 );
	io8_obyte( pPort, MCOR1, mcor1 );

	// Enable detection of modem signal transition - Detect low to high
	io8_obyte( pPort, MCOR2, MCOR2_DSROD | MCOR2_CDOD | MCOR2_CTSOD );

	let_command_finish( pPort );
	io8_obyte( pPort, CCR, COR1_CHANGED | COR2_CHANGED | COR3_CHANGED );
	let_command_finish( pPort );

#if 0
	// Set RTS high if mask is not SERIAL_TRANSMIT_TOGGLE and not 0,
	// else set it low.
	if ( ( pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK ) !=
		 SERIAL_TRANSMIT_TOGGLE )
	{
	if ( ( pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK ) != 0 )
		SerialSetRTS( pPort );
	else
		SerialClrRTS( pPort );
	}
#endif

  return FALSE;
}




/***************************************************************************\
*                                                                           *
* VOID Io8_Simulate_Xon( IN PVOID Context )                                 *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Simulate Xon received.                                                 *
* Disable and Reenable Transmitter in CCR will do it.                       *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Io8_Simulate_Xon( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
  	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	SerialDump( SERDIAG1,( "IO8+: Io8_Simulate_Xoff for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	// Disabe and Enable Tx
	let_command_finish( pPort );
	io8_obyte( pPort, CCR, TXMTR_DISABLE );
	io8_obyte( pPort, CCR, TXMTR_ENABLE );
}




/***************************************************************************\
*                                                                           *
* UCHAR Io8_GetModemStatus( IN PVOID Context )                              *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Get Modem Status in UART style.                                        *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           MSR Register - UART Style.                                      *
*                                                                           *
\***************************************************************************/
UCHAR Io8_GetModemStatus( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

  return( GetModemStatusNoChannel( pPort ) );
}




/***************************************************************************\
*                                                                           *
* UCHAR GetModemStatusNoChannel( IN PVOID Context )                         *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Get Modem Status in UART style in Interrupt Time.                      *
* Does'n need to set channel.                                               *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           MSR Register - UART Style.                                      *
*                                                                           *
\***************************************************************************/
UCHAR GetModemStatusNoChannel( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR ModemStatus = 0, Status;
	ModemStatus |= SERIAL_MSR_DSR;	/* John always indicate DSR on */


	// Get Signal States ---------------------------------------------------
	Status = io8_ibyte( pPort, MSVR );

	if ( Status & MSVR_CD )
		ModemStatus |= SERIAL_MSR_DCD;

	// DSR is not present on the IO8. Return CTS status instead
	if ( Status & MSVR_CTS )
	{
		ModemStatus |= SERIAL_MSR_CTS;
//John		ModemStatus |= SERIAL_MSR_DSR;
	}

	// Get Signal Change States --------------------------------------------
	Status = io8_ibyte( pPort, MDCR );

	if ( Status & MDCR_DDCD )
		ModemStatus |= SERIAL_MSR_DDCD;

	if ( Status & MDCR_DCTS )
	{
		ModemStatus |= SERIAL_MSR_DCTS;
//John		ModemStatus |= SERIAL_MSR_DDSR;
	}

	SerialDump( SERDIAG1,( "IO8+: Get Modem Status for %x, Channel %d. Status = %x\n",
				  pCard->Controller, pPort->ChannelNumber, ModemStatus ) );
	
	return ModemStatus;
}




/***************************************************************************\
*                                                                           *
* UCHAR Io8_GetModemControl( IN PVOID Context )                             *
*                                                                           *
* This routine which is not only called at interrupt level is used          *
* to Get Modem Control - RTS/DTR in UART style. RTS is a DTR output in Io8+.*
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           MCR Register - UART Style.                                      *
*                                                                           *
\***************************************************************************/
ULONG Io8_GetModemControl( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	ULONG ModemControl = 0;
	UCHAR Status;

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	// Get Signal States ---------------------------------------------------
	Status = io8_ibyte( pPort, MSVR );

	if ( Status & MSVR_DTR )
	{
		ModemControl |= SERIAL_MCR_DTR;
		ModemControl |= SERIAL_MCR_RTS;
	}

	return( ModemControl );
}




/***************************************************************************\
*                                                                           *
* VOID Io8_EnableAllInterrupts( IN PVOID Context )                          *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Enable All Interrupts.                                                 *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Io8_EnableAllInterrupts( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	SerialDump( SERDIAG1,( "IO8+: EnableAllInterrupts for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	// Set Service Request Enable Register.
	io8_obyte( pPort, SRER, SRER_CONFIG );
}




/***************************************************************************\
*                                                                           *
* VOID Io8_DisableAllInterrupts( IN PVOID Context )                         *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Disable All Interrupts.                                                *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Io8_DisableAllInterrupts( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	SerialDump( SERDIAG1,( "IO8+: DisableAllInterrupts for %x, Channel %d.\n",
              pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );
	io8_obyte( pPort, SRER, 0 ); 
}




/***************************************************************************\
*                                                                           *
* VOID Io8_EnableTxInterrupts( IN PVOID Context )                           *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Enable Tx Interrupts.                                                  *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Io8_EnableTxInterrupts( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;

	io8_obyte( pPort, CAR, pPort->ChannelNumber );
	EnableTxInterruptsNoChannel( pPort );
}




/***************************************************************************\
*                                                                           *
* VOID EnableTxInterruptsNoChannel( IN PVOID Context )                      *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Enable Tx Interrupts.                                                  *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID EnableTxInterruptsNoChannel( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR en_reg;

	SerialDump( SERDIAG2,( "IO8+: EnableTxInterruptsNoChannel for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );


	en_reg = io8_ibyte( pPort, SRER );
	en_reg |= SRER_TXRDY;
	io8_obyte( pPort, SRER, en_reg ); 
}




/***************************************************************************\
*                                                                           *
* VOID DisableTxInterruptsNoChannel( IN PVOID Context )                     *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Disable Tx Interrupt.                                                  *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID DisableTxInterruptsNoChannel( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
    PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR en_reg;

	SerialDump( SERDIAG2,( "IO8+: DisTxIntsNoChann for %x, Chan %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	en_reg = io8_ibyte( pPort, SRER );
	en_reg &= ( ~SRER_TXRDY );
	io8_obyte( pPort, SRER, en_reg ); 
}




/***************************************************************************\
*                                                                           *
* VOID Io8_EnableRxInterrupts( IN PVOID Context )                           *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Enable Rx Interrupts.                                                  *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Io8_EnableRxInterrupts( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR en_reg;

	SerialDump( SERDIAG1,( "IO8+: Io8_EnableRxInterrupts for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	en_reg = io8_ibyte( pPort, SRER );
	en_reg |= SRER_RXDATA;
	io8_obyte( pPort, SRER, en_reg ); 
}




/***************************************************************************\
*                                                                           *
* VOID Io8_DisableRxInterruptsNoChannel( IN PVOID Context )                 *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Disable Rx Interrupt                                                   *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Io8_DisableRxInterruptsNoChannel( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
  	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR en_reg;

	SerialDump( SERDIAG1,( "IO8+: Io8_DisableRxInterruptsNoChannel for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	en_reg = io8_ibyte( pPort, SRER );
	en_reg &= ( ~SRER_RXDATA );
	io8_obyte( pPort, SRER, en_reg ); 
}




/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_TurnOnBreak( IN PVOID Context )                               *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Turn Break On.                                                         *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_TurnOnBreak( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
    PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR cor2;

	SerialDump( SERDIAG1,( "IO8+: Io8_TurnOnBreak for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	// Enable Embedded Transmitter Commands.
	cor2 = io8_ibyte( pPort, COR2 );
	cor2 |= COR2_ETC;
	io8_obyte( pPort, COR2, cor2 );

	// Now embed the Send Break sequence (0x00,0x81) in the
	// data stream

	io8_obyte( pPort, TDR, 0x00 );
	io8_obyte( pPort, TDR, 0x81 );

#if 0
	io8_obyte( pPort, TDR, 0x00 );
	io8_obyte( pPort, TDR, 0x82 );
	io8_obyte( pPort, TDR, 0x90 );  // break time

	io8_obyte( pPort, TDR, 0x00 );
	io8_obyte( pPort, TDR, 0x83 );

	cor2 &= ~COR2_ETC;
	io8_obyte( pPort, COR2, cor2 );
#endif

	return FALSE;
}




/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_TurnOffBreak( IN PVOID Context )                               *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Turn Break On.                                                         *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_TurnOffBreak( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR cor2;

	SerialDump( SERDIAG1,( "IO8+: Io8_TurnOffBreak for %x, Channel %d.\n",
			  pCard->Controller, pPort->ChannelNumber ) );

	io8_obyte( pPort, CAR, pPort->ChannelNumber );

	// Enable Embedded Transmitter Commands.
	cor2 = io8_ibyte( pPort, COR2 );
	cor2 |= COR2_ETC;
	io8_obyte( pPort, COR2, cor2 );

	// Now embed the Stop Break (0x00,0x83) in the data stream.
	io8_obyte( pPort, TDR, 0x00 );
	io8_obyte( pPort, TDR, 0x83 );

	cor2 &= ~COR2_ETC;
	io8_obyte( pPort, COR2, cor2 );

	return FALSE;
}




/***************************************************************************\
*                                                                           *
* BOOLEAN Io8_Interrupt( IN PVOID Context )                                 *
*                                                                           *
\***************************************************************************/
BOOLEAN Io8_Interrupt( IN PVOID Context )
{
	UCHAR srsr, channel;
	PCARD_DEVICE_EXTENSION pCard = Context;
	PPORT_DEVICE_EXTENSION pPort;

	BOOLEAN ServicedAnInterrupt = FALSE;

	SerialDump( SERDIAG1, ( "IO8+: Io8_Interrupt for %x.\n", pCard->Controller ) );


#ifndef	BUILD_SPXMINIPORT
	if(pCard->PnpPowerFlags & PPF_POWERED)
#endif
	{

		//
		// Which service type is required? 
		// Keep going until all types of request have been satisfied
		//
		while( ( srsr = io8_ibyte_addr( pCard->Controller, SRSR ) ) != 0 )
		{
			ServicedAnInterrupt = TRUE;

			//
			// Acknowledge first request if any.
			//
			if ( !Acknowledge( pCard, srsr ) )
			{
				// Strange situation.
				SerialDump( SERDIAG1, ( "IO8+: Isr: Strange Situation 1 for %x.\n", pCard->Controller ) );
				io8_obyte_addr( pCard->Controller, EOSRR, 0 );  // Tell card we've finished servicing
				continue;
			}

			//
			// Read channel number.
			//
			channel = io8_ibyte_addr( pCard -> Controller, GSCR1 );
			channel = ( channel >> 2 ) & 0x7;


			//
			// Get Extension.
			//
			pPort = pCard->AttachedPDO[channel]->DeviceExtension;

			if ( pPort == NULL )
			{
				SerialDump( SERDIAG1, ( "IO8+: Isr: Extension is 0 for channel %d.\n", channel ) );
				io8_obyte( pPort, EOSRR, 0 );  // Tell card we've finished servicing
				continue;
			}

			if ( !pPort->DeviceIsOpen )
			{
#ifdef TEST_CRYSTAL_FREQUENCY
				if(pPort->CrystalFreqTest)				/* Testing for crystal frequency ? */
				{
					if((srsr&SRSR_IREQ2_MASK) == (SRSR_IREQ2_EXT|SRSR_IREQ2_INT))		/* Transmit interrupt ? */
					{
						if(pPort->CrystalFreqTest == CRYSTALFREQTEST_TX)		/* Transmit phase 1 ? */
						{
							LARGE_INTEGER	TimeStamp1;
							LARGE_INTEGER	TimeStamp2;
							int	loop;

							KeQuerySystemTime(&TimeStamp1);				/* Timestamp#1 */
							
							do							/* Synchronize test with the system timer */
							{
								KeQuerySystemTime(&TimeStamp2);			/* Timestamp#2 */

							} while(RtlLargeIntegerEqualTo(TimeStamp1,TimeStamp2));	/* Wait until timestamp changes over */

							for(loop = 0; loop < pPort->CrystalFreqTestChars; loop++)
								io8_obyte(pPort,TDR,'a');			/* Write out 5 test characters */
						
							KeQuerySystemTime(&pPort->CrystalFreqTestStartTime);/* Timestamp the beginning of the test */
							pPort->CrystalFreqTest = CRYSTALFREQTEST_RX;	/* Set for receive phase of test */
						}
						else if(pPort->CrystalFreqTest == CRYSTALFREQTEST_RX)	/* Receive phase ? */
						{								/* Transmit is now empty, */
							KeQuerySystemTime(&pPort->CrystalFreqTestStopTime);	/* so, timestamp the end of the test */
							io8_obyte(pPort,SRER,SRER_RXDATA);			/* Rx interrupts only */
						}
					}

					if(((srsr&SRSR_IREQ3_MASK) == (SRSR_IREQ3_EXT|SRSR_IREQ3_INT))		/* Receive phase ? */
					&&(pPort->CrystalFreqTest == CRYSTALFREQTEST_RX))
					{
						int	count;

						if(io8_ibyte(pPort,RCSR) == 0)				/* No exceptions ? */
						{
							count = io8_ibyte(pPort,RDCR);			/* Get number of bytes to be read */
							pPort->CrystalFreqTestRxCount += count;		/* Keep a count */
							
							if(pPort->CrystalFreqTestRxCount >= pPort->CrystalFreqTestChars)
								pPort->CrystalFreqTest = 0;			/* Reset test */
							
							while(count--) io8_ibyte(pPort,RDR);		/* Drain received characters */
						}
					}
				}
				else
#endif	/* TEST_CRYSTAL_FREQUENCY */
					SerialDump( SERDIAG1,( "IO8+: Isr: No DeviceIsOpen for %x, Channel %d.\n",
							  pCard->Controller, pPort->ChannelNumber ) );


				io8_obyte( pPort, EOSRR, 0 );  // Tell card we've finished servicing
				continue;
			}

			// Do RX service request first
			if ( ( srsr & SRSR_IREQ3_MASK ) == ( SRSR_IREQ3_EXT | SRSR_IREQ3_INT ) ) 
			{
				io8_rxint( pPort );
				io8_obyte( pPort, EOSRR, 0 );  // Tell card we've finished servicing
				continue;
			}

			// Do TX service request next
			if ( ( srsr & SRSR_IREQ2_MASK ) == ( SRSR_IREQ2_EXT | SRSR_IREQ2_INT ) ) 
			{
				io8_txint( pPort );
				io8_obyte( pPort, EOSRR, 0 );  // Tell card we've finished servicing
				continue;
			}

			// Do modem service request next
			if ( ( srsr & SRSR_IREQ1_MASK ) == ( SRSR_IREQ1_EXT | SRSR_IREQ1_INT ) ) 
			{
				io8_mint( pPort );
				io8_obyte( pPort, EOSRR, 0 );  // Tell card we've finished servicing
				continue;
			}
		}
	}

	// Extra time loooks like is needed by board.
	io8_obyte_addr( pCard->Controller, EOSRR, 0 );  // Tell card we've finished servicing
	
	return ServicedAnInterrupt;
}




/***************************************************************************\
*                                                                           *
* BOOLEAN Acknowledge( PCARD_DEVICE_EXTENSION pCard, UCHAR srsr )        *
*                                                                           *
\***************************************************************************/
BOOLEAN Acknowledge( PCARD_DEVICE_EXTENSION pCard, UCHAR srsr )
{
	// Do RX service request first
	if ( ( srsr & SRSR_IREQ3_MASK ) == ( SRSR_IREQ3_EXT | SRSR_IREQ3_INT ) )
	{
		io8_ibyte_addr( pCard -> Controller, RRAR ); // Acknowledge service request
		return TRUE;
	}

	// Do TX service request next
	if ( ( srsr & SRSR_IREQ2_MASK ) == ( SRSR_IREQ2_EXT | SRSR_IREQ2_INT ) ) 
	{
		io8_ibyte_addr( pCard -> Controller, TRAR );  // Acknowledge service request
		return TRUE;
	}

	// Do modem service request next
	if ( ( srsr & SRSR_IREQ1_MASK ) == ( SRSR_IREQ1_EXT | SRSR_IREQ1_INT ) ) 
	{
		io8_ibyte_addr( pCard -> Controller, MRAR );  // Acknowledge service request
		return TRUE;
	}

	return FALSE;
}




/***************************************************************************\
*                                                                           *
* VOID io8_txint( IN PVOID Context )                                        *
*                                                                           *
\***************************************************************************/
VOID io8_txint( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	UCHAR i;

#if 0
	SerialDump( SERDIAG2,( "t!" ) );
#endif

	//
	// if we need to do break handling, do it now
	//
	if (pPort->DoBreak)
	{
		if (pPort->DoBreak==BREAK_START)
			SerialTurnOnBreak(pPort);
		else
			SerialTurnOffBreak(pPort);

		pPort->DoBreak=0;
	}


	for ( i = 0 ; i < 8 ; i++ )
	{
		if ( !( pPort->WriteLength | pPort->TransmitImmediate |
			pPort->SendXoffChar | pPort->SendXonChar ) )
		break;

		SendTxChar( pPort );
	}

	// If no more chars to send disable tx int
	if ( !pPort->WriteLength )
	{
		DisableTxInterruptsNoChannel( pPort );

		// Means that interrupts has to be reenabled.
		pPort->HoldingEmpty = TRUE;   
	}
	else
		pPort->HoldingEmpty = FALSE;
}




/***************************************************************************\
*                                                                           *
* BOOLEAN SendTxChar( IN PVOID Context )                                    *
*                                                                           *
\***************************************************************************/
BOOLEAN SendTxChar( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
  	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;


	//  Extension->HoldingEmpty = TRUE;

	if( pPort->WriteLength | pPort->TransmitImmediate |
		pPort->SendXoffChar | pPort->SendXonChar )
	{
		//
		// Even though all of the characters being
		// sent haven't all been sent, this variable
		// will be checked when the transmit queue is
		// empty.  If it is still true and there is a
		// wait on the transmit queue being empty then
		// we know we finished transmitting all characters
		// following the initiation of the wait since
		// the code that initiates the wait will set
		// this variable to false.
		//
		// One reason it could be false is that
		// the writes were cancelled before they
		// actually started, or that the writes
		// failed due to timeouts.  This variable
		// basically says a character was written
		// by the isr at some point following the
		// initiation of the wait.
		//

		//VIV    Extension->EmptiedTransmit = TRUE;

		//
		// If we have output flow control based on
		// the modem status lines, then we have to do
		// all the modem work before we output each
		// character. ( Otherwise we might miss a
		// status line change. )
		//

#if 0   //VIV ???
		if ( pPort->HandFlow.ControlHandShake & SERIAL_OUT_HANDSHAKEMASK )
		{
			SerialHandleModemUpdate(pPort, TRUE);
		}
#endif

		//
		// We can only send the xon character if
		// the only reason we are holding is because
		// of the xoff.  ( Hardware flow control or
		// sending break preclude putting a new character
		// on the wire. )
		//

		if ( pPort->SendXonChar && !( pPort->TXHolding & ~SERIAL_TX_XOFF ) )
		{
#if 0 //VIVTEMP
			if ( ( pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK ) 
				== SERIAL_TRANSMIT_TOGGLE )
			{
				//
				// We have to raise if we're sending this character.
				//

				SerialSetRTS( pPort );

		//        WRITE_TRANSMIT_HOLDING( 
		//                Extension->Controller,
		//                Extension->SpecialChars.XonChar
		//                );
				io8_obyte( pPort, TDR, pPort->SpecialChars.XonChar );

				KeInsertQueueDpc( 
					&pPort->StartTimerLowerRTSDpc,
					NULL,
					NULL
					)?pPort->CountOfTryingToLowerRTS++:0;
			}
			else
			{
		//        WRITE_TRANSMIT_HOLDING( 
		//            Extension->Controller,
		//            Extension->SpecialChars.XonChar
		//            );

#endif
				io8_obyte( pPort, TDR, pPort->SpecialChars.XonChar );

#if 0
			}
#endif
			pPort->SendXonChar = FALSE;
//			Extension->HoldingEmpty = FALSE;

		  //
		  // If we send an xon, by definition we
		  // can't be holding by Xoff.
		  //

		  pPort->TXHolding &= ~SERIAL_TX_XOFF;

		  //
		  // If we are sending an xon char then
		  // by definition we can't be "holding"
		  // up reception by Xoff.
		  //

		  pPort->RXHolding &= ~SERIAL_RX_XOFF;

		  SerialDump( SERDIAG1,( "IO8+: io8_txint. Send Xon Char for %x, Channel %d. "
				  "RXHolding = %d, TXHolding = %d\n",
				  pCard->Controller, pPort->ChannelNumber,
				  pPort->RXHolding, pPort->TXHolding ) );


//#endif  //VIVTEMP
		}
		else if ( pPort->SendXoffChar && !pPort->TXHolding )
		{
#if 0 //VIVTEMP
			if ( ( pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK ) 
				== SERIAL_TRANSMIT_TOGGLE )
			{
				//
				// We have to raise if we're sending
				// this character.
				//

				SerialSetRTS( pPort );

				//WRITE_TRANSMIT_HOLDING( 
				//    Extension->Controller,
				//    Extension->SpecialChars.XoffChar
				//    );
				io8_obyte( pPort, TDR, pPort->SpecialChars.XoffChar );

				KeInsertQueueDpc( 
					&pPort->StartTimerLowerRTSDpc,
					NULL,
					NULL
					)?pPort->CountOfTryingToLowerRTS++:0;
			}
			else
			{

//				WRITE_TRANSMIT_HOLDING( 
//					Extension->Controller,
//					Extension->SpecialChars.XoffChar
//					);
#endif
			  io8_obyte( pPort, TDR, pPort->SpecialChars.XoffChar );
#if 0
			}
#endif

			//
			// We can't be sending an Xoff character
			// if the transmission is already held
			// up because of Xoff.  Therefore, if we
			// are holding then we can't send the char.
			//

			//
			// If the application has set xoff continue
			// mode then we don't actually stop sending
			// characters if we send an xoff to the other
			// side.
			//

			if ( !( pPort->HandFlow.FlowReplace & SERIAL_XOFF_CONTINUE ) )
			{
				pPort->TXHolding |= SERIAL_TX_XOFF;

#if 0   //VIVTEMP ???
				if ( ( pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK ) ==
				   SERIAL_TRANSMIT_TOGGLE )
				{

					KeInsertQueueDpc( 
						&pPort->StartTimerLowerRTSDpc,
						NULL,
						NULL
						)?pPort->CountOfTryingToLowerRTS++:0;
				}
#endif
			}

			pPort->SendXoffChar = FALSE;
//			Extension->HoldingEmpty = FALSE;

			//
			// Even if transmission is being held
			// up, we should still transmit an immediate
			// character if all that is holding us
			// up is xon/xoff ( OS/2 rules ).
			//

			SerialDump( SERDIAG1,( "IO8+: io8_txint. Send Xoff Char for %x, Channel %d. "
				  "RXHolding = %d, TXHolding = %d\n",
				  pCard->Controller, pPort->ChannelNumber,
				  pPort->RXHolding, pPort->TXHolding ) );


//#endif  //VIVTEMP
		}
		else if ( pPort->TransmitImmediate && ( !pPort->TXHolding ||
				( pPort->TXHolding == SERIAL_TX_XOFF ) ) )
		{
			SerialDump( SERDIAG1,( "IO8+: io8_txint. TransmitImmediate.\n", 0 ) );

			pPort->TransmitImmediate = FALSE;

#if 0
			if ( ( pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK ) ==
				 SERIAL_TRANSMIT_TOGGLE )
			{
				//
				// We have to raise if we're sending
				// this character.
				//

				SerialSetRTS( pPort );

//				WRITE_TRANSMIT_HOLDING( Extension->Controller, Extension->ImmediateChar );
				io8_obyte( pPort, TDR, pPort->ImmediateChar );

				KeInsertQueueDpc( 
				  &pPort->StartTimerLowerRTSDpc,
				  NULL,
				  NULL
				  )?pPort->CountOfTryingToLowerRTS++:0;
			}
			else
			{
//				WRITE_TRANSMIT_HOLDING( Extension->Controller, Extension->ImmediateChar );
#endif
				io8_obyte( pPort, TDR, pPort->ImmediateChar );
#if 0
			}
#endif

//			Extension->HoldingEmpty = FALSE;

			KeInsertQueueDpc( 
				&pPort->CompleteImmediateDpc,
				NULL,
				NULL
				);

		}
		else if ( !pPort->TXHolding )
		{
#if 0
			if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE)
			{
				//
				// We have to raise if we're sending
				// this character.
				//

				SerialSetRTS( pPort );

//				WRITE_TRANSMIT_HOLDING( Extension->Controller, *( Extension->WriteCurrentChar ) );
				io8_obyte( pPort, TDR, *( pPort->WriteCurrentChar ) );

				KeInsertQueueDpc( 
				  &pPort->StartTimerLowerRTSDpc,
				  NULL,
				  NULL
				  )?pPort->CountOfTryingToLowerRTS++:0;
			}
			else
			{
//				WRITE_TRANSMIT_HOLDING( Extension->Controller, *( Extension->WriteCurrentChar ) );
#endif
				io8_obyte(pPort, TDR, *( pPort->WriteCurrentChar ) );
#if 0
			}
#endif

//			Extension->HoldingEmpty = FALSE;
			pPort->WriteCurrentChar++;
			pPort->WriteLength--;

			pPort->PerfStats.TransmittedCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
			pPort->WmiPerfData.TransmittedCount++;
#endif

			if(!pPort->WriteLength)
			{
				PIO_STACK_LOCATION IrpSp;
				//
				// No More characters left.  This
				// write is complete.  Take care
				// when updating the information field,
				// we could have an xoff counter masquerading
				// as a write irp.
				//

				IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp); 

				pPort->CurrentWriteIrp->IoStatus.Information
					= ( IrpSp->MajorFunction == IRP_MJ_WRITE ) 
					? ( IrpSp->Parameters.Write.Length ) : ( 1 );

				KeInsertQueueDpc(&pPort->CompleteWriteDpc, NULL, NULL); 
			}
		}
	}
  return TRUE;
}




/***************************************************************************\
*                                                                           *
* VOID io8_rxint( IN PVOID Context )                                        *
*                                                                           *
\***************************************************************************/
VOID io8_rxint( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
  	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	UCHAR exception;
	USHORT count;

#if 0
	SerialDump( SERDIAG2,( "r!" ) );
#endif
	exception = io8_ibyte( pPort, RCSR );
  
	if ( exception != 0 )
	{
		ExceptionHandle( pPort, exception );
		return;
	}

	count = io8_ibyte( pPort, RDCR );

	for( ; count ; count-- )
	{
		if ( !( pPort->CharsInInterruptBuffer < pPort->BufferSize ) )
		{
			//
			// We have no room for new character.
			// The situation can happen only if we do not have any flow control,
			// because if we do, Rx Interrupts will be stoped in SerialPutChar().
			//
			Io8_DisableRxInterruptsNoChannel( pPort );

			// Interrupts will be reenabled in SerialHandleReducedIntBuffer().
			pPort->RXHolding |= SERIAL_RX_FULL;

//---------------------------------------------------- VIV  7/30/1993 begin 
			SerialDump( SERDIAG1,( "IO8+: io8_rxint. Rx Full !!! for %x, Channel %d. "
                "RXHolding = %d, TXHolding = %d\n",
                pCard->Controller, pPort->ChannelNumber,
                pPort->RXHolding, pPort->TXHolding ) );
//---------------------------------------------------- VIV  7/30/1993 end   

			return;
		}

		PutReceivedChar( pPort );
	}
}




/***************************************************************************\
*                                                                           *
* VOID ExceptionHandle(                                                     *
*   IN PPORT_DEVICE_EXTENSION pPort, IN UCHAR exception )             *
*                                                                           *
* Convert current status (RCSR reguster) to UART styte Line Status Register *
* and Handle it. It will be combination of OE, PE, FE, BI.                  *
*                                                                           *
\***************************************************************************/
VOID ExceptionHandle(IN PPORT_DEVICE_EXTENSION pPort, IN UCHAR exception)
{
	UCHAR LineStatus = 0;

	if(exception & RCSR_SCD1)
	{
		SerialDump( SERDIAG1,( "IO8+: io8_rxint. Xon Detected. TXHolding = %d\n",
                pPort->TXHolding ) );

		if(pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)
		{
			pPort->TXHolding &= ~SERIAL_TX_XOFF;
			//  if ( Extension->HoldingEmpty == TRUE )
			//    EnableTxInterruptsNoChannel( Extension );
		}
	}


	if(exception & RCSR_SCD2)
	{
		SerialDump( SERDIAG1,( "IO8+: io8_rxint. Xoff Detected. TXHolding = %d\n",
                pPort->TXHolding ) );

		if ( pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT )
		{
			pPort->TXHolding |= SERIAL_TX_XOFF;
			//  DisableTxInterruptsNoChannel( Extension );
			//  Extension->HoldingEmpty = TRUE;
		}
	}

	if(exception & RCSR_OVERRUN)
		LineStatus |= SERIAL_LSR_OE;

	if(exception & RCSR_FRAME)
		LineStatus |= SERIAL_LSR_FE;

	if(exception & RCSR_PARITY)
		LineStatus |= SERIAL_LSR_PE;

	if(exception & RCSR_BREAK)
		LineStatus |= SERIAL_LSR_BI;

	if(LineStatus)
		SerialProcessLSR(pPort, LineStatus);
}




/***************************************************************************\
*                                                                           *
* VOID PutReceivedChar(                                                     *
*   IN PPORT_DEVICE_EXTENSION pPort )										*
*                                                                           *
\***************************************************************************/
VOID PutReceivedChar( IN PPORT_DEVICE_EXTENSION pPort )
{
	UCHAR ReceivedChar;

//      ReceivedChar = READ_RECEIVE_BUFFER( Extension->Controller );
	ReceivedChar = io8_ibyte( pPort, RDR );

	ReceivedChar &= pPort->ValidDataMask;

	if ( !ReceivedChar &&
       ( pPort->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING ) )
	{
		//
		// If what we got is a null character
		// and we're doing null stripping, then
		// we simply act as if we didn't see it.
		//

		return;
		//goto ReceiveDoLineStatus;
	}


#if 0   //VIV.1 - We never here because Automatic Transmit is Enabled.
        //But we will receive Exception Interrupt.

	if((pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) 
		&& ((ReceivedChar == pPort->SpecialChars.XonChar) 
		|| (ReceivedChar == pPort->SpecialChars.XoffChar)))
	{

		//
		// No matter what happens this character
		// will never get seen by the app.
		//

		if(ReceivedChar == pPort->SpecialChars.XoffChar)
		{
			pPort->TXHolding |= SERIAL_TX_XOFF;

			if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) 
				== SERIAL_TRANSMIT_TOGGLE)
			{
				KeInsertQueueDpc( 
					&pPort->StartTimerLowerRTSDpc,
					NULL,
					NULL
					)?pPort->CountOfTryingToLowerRTS++:0;
			}
		}
		else
		{
			if ( pPort->TXHolding & SERIAL_TX_XOFF )
			{
				//
				// We've got the xon.  Cause the
				// transmission to restart.
				//
				// Prod the transmit.
				//

				SerialProdXonXoff( pPort, TRUE );
			}
		}

		return;
		// goto ReceiveDoLineStatus;
	}
#endif

	//
	// Check to see if we should note
	// the receive character or special
	// character event.
	//

	if(pPort->IsrWaitMask)
	{
		if(pPort->IsrWaitMask & SERIAL_EV_RXCHAR)
		{
		  pPort->HistoryMask |= SERIAL_EV_RXCHAR;
		}

		if((pPort->IsrWaitMask & SERIAL_EV_RXFLAG) 
			&& (pPort->SpecialChars.EventChar == ReceivedChar))
		{
		  pPort->HistoryMask |= SERIAL_EV_RXFLAG;
		}

		if(pPort->IrpMaskLocation && pPort->HistoryMask)
		{
			*pPort->IrpMaskLocation = pPort->HistoryMask;
			pPort->IrpMaskLocation = NULL;
			pPort->HistoryMask = 0;

			pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
			
			KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
		}
	}

	SerialPutChar( pPort, ReceivedChar );

	//
	// If we're doing line status and modem
	// status insertion then we need to insert
	// a zero following the character we just
	// placed into the buffer to mark that this
	// was reception of what we are using to
	// escape.
	//

	if(pPort->EscapeChar && (pPort->EscapeChar == ReceivedChar))
	{
		SerialPutChar( pPort, SERIAL_LSRMST_ESCAPE );
	}


	//ReceiveDoLineStatus:    ;
	// if ( !( SerialProcessLSR( Extension ) & SERIAL_LSR_DR ) ) {
	//
	// No more characters, get out of the
	// loop.
	//
	// break;
	//}
}




/***************************************************************************\
*                                                                           *
* VOID io8_mint( IN PVOID Context )                                         *
*                                                                           *
\***************************************************************************/
VOID io8_mint( IN PVOID Context )
{
	PPORT_DEVICE_EXTENSION pPort = Context;
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;


	SerialDump( SERDIAG2,( "IO8+: io8_mint for %x, Channel %d.\n",
			 pCard->Controller, pPort->ChannelNumber ) );

	SerialHandleModemUpdate( pPort, FALSE );

	// clear modem change register
	io8_obyte( pPort, MDCR, 0 );
}




/***************************************************************************\
*                                                                           *
* UCHAR io8_ibyte( PPORT_DEVICE_EXTENSION pPort, UCHAR Reg )				*
*                                                                           *
\***************************************************************************/
UCHAR io8_ibyte( PPORT_DEVICE_EXTENSION pPort, UCHAR Reg )
{
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	outb( pCard->Controller + 1, Reg );
	return( inb( pCard->Controller ) );
}




/***************************************************************************\
*                                                                           *
* VOID io8_obyte(                                                           *
*       PPORT_DEVICE_EXTENSION pPort, UCHAR Reg, UCHAR Value )				*
*                                                                           *
\***************************************************************************/
VOID io8_obyte( PPORT_DEVICE_EXTENSION pPort, UCHAR Reg, UCHAR Value )
{
   	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	outb( pCard->Controller + 1, Reg );
	outb( pCard->Controller, Value );
}




/***************************************************************************\
*                                                                           *
* UCHAR io8_ibyte_addr( PUCHAR Addr, UCHAR Reg )                            *
*                                                                           *
\***************************************************************************/
UCHAR io8_ibyte_addr( PUCHAR Addr, UCHAR Reg )
{
	outb( Addr + 1, Reg );
	return( inb( Addr ) );
}




/***************************************************************************\
*                                                                           *
* VOID io8_obyte_addr( PUCHAR Addr, UCHAR Reg, UCHAR Value )                *
*                                                                           *
\***************************************************************************/
VOID io8_obyte_addr( PUCHAR Addr, UCHAR Reg, UCHAR Value )
{
	outb( Addr + 1, Reg );
	outb( Addr, Value );
}




/***************************************************************************\
*                                                                           *
* VOID let_command_finish( PPORT_DEVICE_EXTENSION pPort )					*
*                                                                           *
* Busy wait for CCR to become zero, indicating that command has completed.  *
*                                                                           *
\***************************************************************************/
VOID let_command_finish( PPORT_DEVICE_EXTENSION pPort )
{
  volatile int wait = 0;  // don't want wait to be optimised

  while( ( io8_ibyte( pPort, CCR ) != 0 ) && ( wait < 500 ) )
	  wait++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\io8_isr.c ===
#include "precomp.h"	
/***************************************************************************\
*                                                                           *
*     ISR.C    -   IO8+ Intelligent I/O Board driver                        *
*                                                                           *
*     Copyright (c) 1992-1993 Ring Zero Systems, Inc.                       *
*     All Rights Reserved.                                                  *
*                                                                           *
\***************************************************************************/

/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    isr.c

Abstract:

    This module contains the interrupt service routine for the
    serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


BOOLEAN SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This is the interrupt service routine for the serial port driver.
    It will determine whether the serial port is the source of this
    interrupt.  If it is, then this routine will do the minimum of
    processing to quiet the interrupt.  It will store any information
    necessary for later processing.

Arguments:

    InterruptObject - Points to the interrupt object declared for this
    device.  We *do not* use this parameter.

    Context - This is really a pointer to the device extension for this
    device.

Return Value:

    This function will return TRUE if the serial port is the source
    of this interrupt, FALSE otherwise.

--*/

{
    //
    // Holds the information specific to handling this device.
    //
    PCARD_DEVICE_EXTENSION pCard = Context;

    //
    // Will hold whether we've serviced any interrupt causes in this
    // routine.
    //
    BOOLEAN ServicedAnInterrupt;

    UNREFERENCED_PARAMETER(InterruptObject);

    ServicedAnInterrupt = Io8_Interrupt(pCard);
    return ServicedAnInterrupt;
}

VOID
SerialPutChar(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN UCHAR CharToPut
    )


/*++

Routine Description:

    This routine, which only runs at device level, takes care of
    placing a character into the typeahead (receive) buffer.

Arguments:

    pPort - The serial device extension.

Return Value:

    None.

--*/

// VIV - Io8p
{

	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

#if 0   //VIV
  //
  // If we have dsr sensitivity enabled then
  // we need to check the modem status register
  // to see if it has changed.
  //

  if (pPort->HandFlow.ControlHandShake &  SERIAL_DSR_SENSITIVITY)
  {
    SerialHandleModemUpdate(pPort, FALSE);

    if (pPort->RXHolding & SERIAL_RX_DSR)
    {
      //
      // We simply act as if we haven't
      // seen the character if we have dsr
      // sensitivity and the dsr line is low.
      //

      return;
    }
  }
#endif

  //
  // If the xoff counter is non-zero then decrement it.
  // If the counter then goes to zero, complete that irp.
  //

//#if 0   //VIVTEMP ?
  if (pPort->CountSinceXoff)
  {
    pPort->CountSinceXoff--;

    if (!pPort->CountSinceXoff)
    {
      pPort->CurrentXoffIrp->IoStatus.Status = STATUS_SUCCESS;
      pPort->CurrentXoffIrp->IoStatus.Information = 0;
      KeInsertQueueDpc(
           &pPort->XoffCountCompleteDpc,
           NULL,
           NULL
           );
      }
  }
//#endif

  //
  // Check to see if we are copying into the
  // users buffer or into the interrupt buffer.
  //
  // If we are copying into the user buffer
  // then we know there is always room for one more.
  // (We know this because if there wasn't room
  // then that read would have completed and we
  // would be using the interrupt buffer.)
  //
  // If we are copying into the interrupt buffer
  // then we will need to check if we have enough
  // room.
  //

  if (pPort->ReadBufferBase != pPort->InterruptReadBuffer)
  {
    //
    // Increment the following value so
    // that the interval timer (if one exists
    // for this read) can know that a character
    // has been read.
    //

    pPort->ReadByIsr++;

	pPort->PerfStats.ReceivedCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
	pPort->WmiPerfData.ReceivedCount++;
#endif

    //
    // We are in the user buffer.  Place the
    // character into the buffer.  See if the
    // read is complete.
    //

    *pPort->CurrentCharSlot = CharToPut;

    if (pPort->CurrentCharSlot == pPort->LastCharSlot)
    {
      //
      // We've filled up the users buffer.
      // Switch back to the interrupt buffer
      // and send off a DPC to Complete the read.
      //
      // It is inherent that when we were using
      // a user buffer that the interrupt buffer
      // was empty.
      //

      pPort->ReadBufferBase = pPort->InterruptReadBuffer;
      pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
      pPort->FirstReadableChar = pPort->InterruptReadBuffer;
      pPort->LastCharSlot =
        pPort->InterruptReadBuffer + (pPort->BufferSize - 1);
      pPort->CharsInInterruptBuffer = 0;

      pPort->CurrentReadIrp->IoStatus.Information =
          IoGetCurrentIrpStackLocation(
              pPort->CurrentReadIrp
              )->Parameters.Read.Length;

      KeInsertQueueDpc(
          &pPort->CompleteReadDpc,
          NULL,
          NULL
          );

    }
    else
    {
      //
      // Not done with the users read.
      //

      pPort->CurrentCharSlot++;
    }

  }
  else
  {
    //
    // We need to see if we reached our flow
    // control threshold.  If we have then
    // we turn on whatever flow control the
    // owner has specified.  If no flow
    // control was specified, well..., we keep
    // trying to receive characters and hope that
    // we have enough room.  Note that no matter
    // what flow control protocol we are using, it
    // will not prevent us from reading whatever
    // characters are available.
    //

    // VIV: We do not have an Automatic Rx Flow Control. We need just
    // stop receiving and Handshake line will be droped by the chip.

    if ( ( pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK ) ==
           SERIAL_DTR_HANDSHAKE)
    {
      //
      // If we are already doing a
      // dtr hold then we don't have
      // to do anything else.
      //
      if (!(pPort->RXHolding & SERIAL_RX_DTR))
      {
        if ((pPort->BufferSize - pPort->HandFlow.XoffLimit)
              <= (pPort->CharsInInterruptBuffer+1))
        {
          pPort->RXHolding |= SERIAL_RX_DTR;
//---------------------------------------------------- VIV  7/30/1993 begin 
//          SerialClrDTR(pPort);
          Io8_DisableRxInterruptsNoChannel( pPort );
//---------------------------------------------------- VIV  7/30/1993 end   

//---------------------------------------------------- VIV  7/30/1993 begin 
          SerialDump( SERDIAG1,( "IO8+: SerialPutChar() RX_DTR for %x, Channel %d. "
                  "RXHolding = %d, TXHolding = %d\n",
                  pCard->Controller, pPort->ChannelNumber,
                  pPort->RXHolding, pPort->TXHolding ) );
//---------------------------------------------------- VIV  7/30/1993 end   
        }
      }
    }

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
          SERIAL_RTS_HANDSHAKE)
    {
      //
      // If we are already doing a
      // rts hold then we don't have
      // to do anything else.
      //
      if (!(pPort->RXHolding & SERIAL_RX_RTS))
      {
        if ((pPort->BufferSize - pPort->HandFlow.XoffLimit)
              <= (pPort->CharsInInterruptBuffer+1))
        {
          pPort->RXHolding |= SERIAL_RX_RTS;
//---------------------------------------------------- VIV  7/30/1993 begin 
//          SerialClrRTS(pPort);
          Io8_DisableRxInterruptsNoChannel( pPort );
//---------------------------------------------------- VIV  7/30/1993 end   

//---------------------------------------------------- VIV  7/30/1993 begin 
          SerialDump( SERDIAG1,( "IO8+: SerialPutChar() RX_RTS for %x, Channel %d. "
                  "RXHolding = %d, TXHolding = %d\n",
                  pCard->Controller, pPort->ChannelNumber,
                  pPort->RXHolding, pPort->TXHolding ) );
//---------------------------------------------------- VIV  7/30/1993 end   
        }
      }
    }

    if (pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
    {
      //
      // If we are already doing a
      // xoff hold then we don't have
      // to do anything else.
      //
      if (!(pPort->RXHolding & SERIAL_RX_XOFF))
      {
        if ((pPort->BufferSize - pPort->HandFlow.XoffLimit)
              <= (pPort->CharsInInterruptBuffer+1))
        {
          pPort->RXHolding |= SERIAL_RX_XOFF;

          //
          // If necessary cause an
          // off to be sent.
          //
          SerialProdXonXoff(
              pPort,
              FALSE
              );
//---------------------------------------------------- VIV  7/30/1993 begin 
          SerialDump( SERDIAG1,( "IO8+: SerialPutChar() RX_XOFF for %x, Channel %d. "
                  "RXHolding = %d, TXHolding = %d\n",
                  pCard->Controller, pPort->ChannelNumber,
                  pPort->RXHolding, pPort->TXHolding ) );
//---------------------------------------------------- VIV  7/30/1993 end   
        }
      }
    }

    if (pPort->CharsInInterruptBuffer < pPort->BufferSize)
    {

      *pPort->CurrentCharSlot = CharToPut;
      pPort->CharsInInterruptBuffer++;

  	  pPort->PerfStats.ReceivedCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
	pPort->WmiPerfData.ReceivedCount++;
#endif
      //
      // If we've become 80% full on this character
      // and this is an interesting event, note it.
      //

      if (pPort->CharsInInterruptBuffer == pPort->BufferSizePt8)
      {
        if (pPort->IsrWaitMask & SERIAL_EV_RX80FULL)
        {
          pPort->HistoryMask |= SERIAL_EV_RX80FULL;

          if (pPort->IrpMaskLocation)
          {
            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->
                IoStatus.Information = sizeof(ULONG);
            KeInsertQueueDpc(
                &pPort->CommWaitDpc,
                NULL,
                NULL
                );
          }
        }
      }

      //
      // Point to the next available space
      // for a received character.  Make sure
      // that we wrap around to the beginning
      // of the buffer if this last character
      // received was placed at the last slot
      // in the buffer.
      //

      if (pPort->CurrentCharSlot == pPort->LastCharSlot)
      {
        pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
      }
      else
      {
        pPort->CurrentCharSlot++;
      }
    }
    else
    {

		pPort->PerfStats.BufferOverrunErrorCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
	pPort->WmiPerfData.BufferOverrunErrorCount++;
#endif

#if 0  // VIV !!!
// VIV: We never get here because we check this condition before

      //
      // We have a new character but no room for it.
      //

      pPort->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;

      if (pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
      {
        //
        // Place the error character into the last
        // valid place for a character.  Be careful!,
        // that place might not be the previous location!
        //

        if (pPort->CurrentCharSlot == pPort->InterruptReadBuffer)
        {
          *(pPort->InterruptReadBuffer+(pPort->BufferSize-1)) =
                pPort->SpecialChars.ErrorChar;
        }
        else
        {
          *(pPort->CurrentCharSlot-1) = pPort->SpecialChars.ErrorChar;
        }
      }

      //
      // If the application has requested it, abort all reads
      // and writes on an error.
      //

      if (pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT)
      {
        KeInsertQueueDpc(
            &pPort->CommErrorDpc,
            NULL,
            NULL
            );
      }
#endif  // VIV
    }
  }
}

UCHAR
SerialProcessLSR(
    IN PPORT_DEVICE_EXTENSION pPort, UCHAR LineStatus
    )

/*++

Routine Description:

    This routine, which only runs at device level, reads the
    ISR and totally processes everything that might have
    changed.

Arguments:

    pPort - The serial device pPort.

Return Value:

    The value of the line status register.

--*/
//VIV - Io8
{
//VIV: Function is called from ExceptionHandle, so
//     Line Status will be combination of OE, PE, FE, BI.

#if 0
  SerialDump( SERDIAG1,( "spLSR() %x\n", LineStatus ) );
#endif


//VIV    UCHAR LineStatus = READ_LINE_STATUS(pPort->Controller);

//VIV    pPort->HoldingEmpty = !!(LineStatus & SERIAL_LSR_THRE);

    //
    // If the line status register is just the fact that
    // the trasmit registers are empty or a character is
    // received then we want to reread the interrupt
    // identification register so that we just pick up that.
    //

    if (LineStatus & ~(SERIAL_LSR_THRE | SERIAL_LSR_TEMT
                       | SERIAL_LSR_DR)) {

        //
        // We have some sort of data problem in the receive.
        // For any of these errors we may abort all current
        // reads and writes.
        //
        //
        // If we are inserting the value of the line status
        // into the data stream then we should put the escape
        // character in now.
        //

        if (pPort->EscapeChar) {

            SerialPutChar(
                pPort,
                pPort->EscapeChar
                );

            SerialPutChar(
                pPort,
                (UCHAR)((LineStatus & SERIAL_LSR_DR)?
                    (SERIAL_LSRMST_LSR_DATA):(SERIAL_LSRMST_LSR_NODATA))
                );

            SerialPutChar(
                pPort,
                LineStatus
                );

#if 0 // VIV: We never get here, because of an errors only set in the LineStatus
            if (LineStatus & SERIAL_LSR_DR) {

                SerialPutChar(
                    pPort,
                    READ_RECEIVE_BUFFER(pPort->Controller)
                    );
            }
#endif
        }


        if (LineStatus & SERIAL_LSR_OE) {

            pPort->ErrorWord |= SERIAL_ERROR_OVERRUN;

			pPort->PerfStats.SerialOverrunErrorCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
			pPort->WmiPerfData.SerialOverrunErrorCount++;
#endif

            if (pPort->HandFlow.FlowReplace &
                SERIAL_ERROR_CHAR) {

                SerialPutChar(
                    pPort,
                    pPort->SpecialChars.ErrorChar
                    );

            }

#if 0 // VIV: We never get here, because of an errors only set in the LineStatus
            if (LineStatus & SERIAL_LSR_DR) {

                SerialPutChar(
                    pPort,
                    READ_RECEIVE_BUFFER(
                        pPort->Controller
                        )
                    );
            }
#endif
        }

        if (LineStatus & SERIAL_LSR_BI) {

            pPort->ErrorWord |= SERIAL_ERROR_BREAK;

            if (pPort->HandFlow.FlowReplace &
                SERIAL_BREAK_CHAR) {

                SerialPutChar(
                    pPort,
                    pPort->SpecialChars.BreakChar
                    );

            }

        } else {

            //
            // Framing errors only count if they
            // occur exclusive of a break being
            // received.
            //

            if (LineStatus & SERIAL_LSR_PE) {

                pPort->ErrorWord |= SERIAL_ERROR_PARITY;
				pPort->PerfStats.ParityErrorCount++;	// Increment counter for performance stats.

#ifdef WMI_SUPPORT 
				pPort->WmiPerfData.ParityErrorCount++;
#endif


                if (pPort->HandFlow.FlowReplace &
                    SERIAL_ERROR_CHAR) {

                    SerialPutChar(
                        pPort,
                        pPort->SpecialChars.ErrorChar
                        );

                }

            }

            if (LineStatus & SERIAL_LSR_FE) {

                pPort->ErrorWord |= SERIAL_ERROR_FRAMING;
				pPort->PerfStats.FrameErrorCount++;		// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
				pPort->WmiPerfData.FrameErrorCount++;
#endif


                if (pPort->HandFlow.FlowReplace &
                    SERIAL_ERROR_CHAR) {

                    SerialPutChar(
                        pPort,
                        pPort->SpecialChars.ErrorChar
                        );

                }

            }

        }

        //
        // If the application has requested it,
        // abort all the reads and writes
        // on an error.
        //

        if (pPort->HandFlow.ControlHandShake &
            SERIAL_ERROR_ABORT) {

            KeInsertQueueDpc(
                &pPort->CommErrorDpc,
                NULL,
                NULL
                );

        }

        //
        // Check to see if we have a wait
        // pending on the comm error events.  If we
        // do then we schedule a dpc to satisfy
        // that wait.
        //

        if (pPort->IsrWaitMask) {

            if ((pPort->IsrWaitMask & SERIAL_EV_ERR) &&
                (LineStatus & (SERIAL_LSR_OE |
                               SERIAL_LSR_PE |
                               SERIAL_LSR_FE))) {

                pPort->HistoryMask |= SERIAL_EV_ERR;

            }

            if ((pPort->IsrWaitMask & SERIAL_EV_BREAK) &&
                (LineStatus & SERIAL_LSR_BI)) {

                pPort->HistoryMask |= SERIAL_EV_BREAK;

            }

            if (pPort->IrpMaskLocation &&
                pPort->HistoryMask) {

                *pPort->IrpMaskLocation =
                 pPort->HistoryMask;
                pPort->IrpMaskLocation = NULL;
                pPort->HistoryMask = 0;

                pPort->CurrentWaitIrp->IoStatus.Information =
                    sizeof(ULONG);
                KeInsertQueueDpc(
                    &pPort->CommWaitDpc,
                    NULL,
                    NULL
                    );

            }

        }


#if 0 // VIV: We never get here, but still hide this part.

        if (LineStatus & SERIAL_LSR_THRE) {

            //
            // There is a hardware bug in some versions
            // of the 16450 and 550.  If THRE interrupt
            // is pending, but a higher interrupt comes
            // in it will only return the higher and
            // *forget* about the THRE.
            //
            // A suitable workaround - whenever we
            // are *all* done reading line status
            // of the device we check to see if the
            // transmit holding register is empty.  If it is
            // AND we are currently transmitting data
            // enable the interrupts which should cause
            // an interrupt indication which we quiet
            // when we read the interrupt id register.
            //

            if (pPort->WriteLength |
                pPort->TransmitImmediate) {

                DISABLE_ALL_INTERRUPTS(
                    pPort->Controller
                    );
                ENABLE_ALL_INTERRUPTS(
                    pPort->Controller
                    );

            }

        }
#endif
    }

    return LineStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\io8_pnp.c ===
#include "precomp.h"

/////////////////////////////////////////////////////////////////////////////////////
//  This file contains all functions that are needed to integrate between the 
//  generic PnP code and the product specific code.
/////////////////////////////////////////////////////////////////////////////////////

#define FILE_ID		IO8_PNP_C		// File ID for Event Logging see IO8_DEFS.H for values.


// Prototypes
// End of Prototypes

NTSTATUS
XXX_CardGetResources(	
	IN PDEVICE_OBJECT pDevObject, 
	IN PCM_RESOURCE_LIST PResList,
	IN PCM_RESOURCE_LIST PTrResList
	)

/* ++
Routine Description:

	Stores resources given to us by the PnP manager 
	in the card's device extension.

Arguments:

    pDevObject - Pointer to the device object.
    
    PResList - Pointer to the untranslated resources requested.
    
    PTrResList - Pointer to the translated resources requested.

Return Value:

    STATUS_SUCCESS.

--*/

{

	PCARD_DEVICE_EXTENSION pCard		= pDevObject->DeviceExtension;
	NTSTATUS status						= STATUS_NOT_IMPLEMENTED;

	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	ULONG count				= 0;
	ULONG i					= 0;

	PCM_FULL_RESOURCE_DESCRIPTOR	pFullResourceDesc		= NULL, pFullTrResourceDesc		= NULL;
	PCM_PARTIAL_RESOURCE_LIST		pPartialResourceList	= NULL, pPartialTrResourceList	= NULL;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR	pPartialResourceDesc	= NULL, pPartialTrResourceDesc	= NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardGetResources for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	SpxDbgMsg(SPX_MISC_DBG, ("%s: Resource pointer is 0x%X\n", PRODUCT_NAME, PResList));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: Translated resource pointer is 0x%X\n", PRODUCT_NAME, PTrResList));

	if ((PResList == NULL) || (PTrResList == NULL)) 
	{
		// This shouldn't happen in theory
		ASSERT(PResList != NULL);
		ASSERT(PTrResList != NULL);

		sprintf(szErrorMsg, "Card %d has been given no resources.", pCard->CardNumber);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,		// Driver Object
						pCard->DeviceObject,		// Device Object (Optional)
						PhysicalZero,				// Physical Address 1
						PhysicalZero,				// Physical Address 2
						0,							// SequenceNumber
						0,							// Major Function Code
						0,							// RetryCount
						FILE_ID | __LINE__,			// UniqueErrorValue
						STATUS_SUCCESS,				// FinalStatus
						szErrorMsg);				// Error Message

		// This status is as appropriate as I can think of
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Each resource list should have only one set of resources
	ASSERT(PResList->Count == 1);
	ASSERT(PTrResList->Count == 1);

	pFullResourceDesc	= &PResList->List[0];
	pFullTrResourceDesc	= &PTrResList->List[0];

	// Find out the card type... 
	if((pCard->CardType = SpxGetNtCardType(pCard->DeviceObject)) == -1)
	{
		sprintf(szErrorMsg, "Card %d is unrecognised.", pCard->CardNumber);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message


		return(STATUS_DEVICE_DOES_NOT_EXIST);
	}

	// Find out which raw resources have been given to us.
	if (pFullResourceDesc)
	{
		pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
		count                   = pPartialResourceList->Count;	// Number of Partial Resource Descriptors

		// Pull out the stuff that is in the full descriptor.
		pCard->InterfaceType	= pFullResourceDesc->InterfaceType;
		pCard->BusNumber		= pFullResourceDesc->BusNumber;

		// Now run through the partial resource descriptors looking for the port and interrupt.
		for (i = 0; i < count; i++, pPartialResourceDesc++) 
		{
			switch (pPartialResourceDesc->Type) 
			{

			case CmResourceTypeMemory:
				break;

			case CmResourceTypePort: 
				{
					pCard->RawPhysAddr		= pPartialResourceDesc->u.Port.Start;
					pCard->PhysAddr			= pPartialResourceDesc->u.Port.Start;
					pCard->SpanOfController	= pPartialResourceDesc->u.Port.Length;
					break;
				}

			case CmResourceTypeInterrupt: 
				{
					pCard->OriginalIrql			= pPartialResourceDesc->u.Interrupt.Level;
					pCard->OriginalVector		= pPartialResourceDesc->u.Interrupt.Vector;
					pCard->ProcessorAffinity	= pPartialResourceDesc->u.Interrupt.Affinity;

					if(pPartialResourceDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED)
						pCard->InterruptMode	= Latched;
					else
						pCard->InterruptMode	= LevelSensitive; 

					switch(pPartialResourceDesc->ShareDisposition)
					{
					case CmResourceShareDeviceExclusive:
						pCard->InterruptShareable	= FALSE;
						break;

					case CmResourceShareDriverExclusive:
						pCard->InterruptShareable	= FALSE;
						break;

					case CmResourceShareShared:
					default:
						pCard->InterruptShareable	= TRUE;
						break;
					}


					break;
				}

			default:
				break;

			}

		}
	}


	// Do the same for the translated resources.
	if (pFullTrResourceDesc)
	{
		pPartialTrResourceList	= &pFullTrResourceDesc->PartialResourceList;
		pPartialTrResourceDesc	= pPartialTrResourceList->PartialDescriptors;
		count					= pPartialTrResourceList->Count;	// Number of Partial Resource Descriptors

		// Pull out the stuff that is in the full descriptor.
		pCard->InterfaceType		= pFullTrResourceDesc->InterfaceType;
		pCard->BusNumber			= pFullTrResourceDesc->BusNumber;

		// Now run through the partial resource descriptors looking for the interrupt,
		for (i = 0; i < count; i++, pPartialTrResourceDesc++) 
		{
			switch (pPartialTrResourceDesc->Type) 
			{

			case CmResourceTypeMemory: 
				{
					if(pPartialTrResourceDesc->u.Memory.Length == 0x80)	// Must be config space 
					{
						pCard->PCIConfigRegisters		= pPartialTrResourceDesc->u.Memory.Start;
						pCard->SpanOfPCIConfigRegisters	= pPartialTrResourceDesc->u.Memory.Length;
					}
					break;
				}
			
			case CmResourceTypePort: 
				{
					break;
				}

			case CmResourceTypeInterrupt: 
				{
					pCard->TrIrql				= (KIRQL) pPartialTrResourceDesc->u.Interrupt.Level;
					pCard->TrVector				= pPartialTrResourceDesc->u.Interrupt.Vector;
					pCard->ProcessorAffinity	= pPartialTrResourceDesc->u.Interrupt.Affinity;
					break;
				}

			default:
				break;
			}
		}

	}

	status = STATUS_SUCCESS;

	return status;
}




NTSTATUS
XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardInit for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));



    pCard->OurIsr			= SerialISR;
    pCard->OurIsrContext	= pCard;


	return status;
}

NTSTATUS
XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;
	UCHAR CardID	= 0;
	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardStart for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));


	pCard->Controller = (PUCHAR) pCard->PhysAddr.LowPart;

	CardID = Io8_Present(pCard);	// Find out if the card is present and the type of card.

	if((CardID != IDENT) && (CardID != IDENTPCI))
	{
		sprintf(szErrorMsg, "Card at %08X%08X: Unrecognised or malfunctioning.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message
	
		return STATUS_UNSUCCESSFUL;
	}

	switch(pCard->InterfaceType)
	{
	case Isa:
		pCard->InterruptMode		= Latched;
		pCard->InterruptShareable	= FALSE;	
		break;

	case PCIBus:
		pCard->InterruptMode		= LevelSensitive;
		pCard->InterruptShareable	= TRUE;	
		break;

	default:
		sprintf(szErrorMsg, "Card at %08X%08X: Unsupported interface type.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message


		return STATUS_UNSUCCESSFUL;		// Unrecognised card or no working card exists.
	}


	if(!Io8_ResetBoard(pCard))
		return STATUS_UNSUCCESSFUL;		// Reset Failed.


	if((!pCard->Interrupt) && (pCard->OurIsr))
    {
		  SpxDbgMsg(SPX_MISC_DBG, ("%s: About to connect to interrupt for card %d at I/O addr 0x%X\n",
					PRODUCT_NAME, pCard->CardNumber, pCard->Controller));

		  status = IoConnectInterrupt( &(pCard->Interrupt),
									   pCard->OurIsr,
									   pCard->OurIsrContext,
									   NULL,
									   pCard->TrVector,
									   pCard->TrIrql,
									   pCard->TrIrql,
									   pCard->InterruptMode,
									   pCard->InterruptShareable,
									   pCard->ProcessorAffinity,
									   FALSE );
					   

		  if(!SPX_SUCCESS(status))
		  {
				SpxDbgMsg(SPX_ERRORS, ("%s: Couldn't connect to interrupt for Card %d\n",
					PRODUCT_NAME, pCard->CardNumber));
			
				sprintf(szErrorMsg, "Card at %08X%08X: Failed to connect to IRQ %d.", 
						pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart, pCard->TrVector);
		
				Spx_LogMessage(	STATUS_SEVERITY_ERROR,
								pCard->DriverObject,			// Driver Object
								pCard->DeviceObject,			// Device Object (Optional)
								PhysicalZero,					// Physical Address 1
								PhysicalZero,					// Physical Address 2
								0,								// SequenceNumber
								0,								// Major Function Code
								0,								// RetryCount
								FILE_ID | __LINE__,				// UniqueErrorValue
								STATUS_SUCCESS,					// FinalStatus
								szErrorMsg);					// Error Message
				return(status);
		  }
	}

	KeSynchronizeExecution(pCard->Interrupt, Io8_ResetBoard, pCard);


	pCard->NumberOfPorts	= PRODUCT_MAX_PORTS;	

	return status;
}

NTSTATUS
XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardStop for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));
	
	Io8_SwitchCardInterrupt(pCard);		// Stop Card from interrupting

	IoDisconnectInterrupt(pCard->Interrupt);		// Disconnect from Interrupt.

	pCard->InterfaceType		= InterfaceTypeUndefined;
	pCard->PhysAddr				= PhysicalZero;
	pCard->SpanOfController		= 0;
	pCard->OriginalIrql			= 0;
	pCard->OriginalVector		= 0;
	pCard->ProcessorAffinity	= 0;
	pCard->TrIrql				= 0;
	pCard->TrVector				= 0;
	pCard->Controller			= 0;

	return status;
}


NTSTATUS
XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardDeInit for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

    pCard->OurIsr				= NULL;
    pCard->OurIsrContext		= NULL;

	return status;
}



NTSTATUS
XXX_PortInit(IN	PPORT_DEVICE_EXTENSION pPort)
{
	// Initialise port device extension.	
	PCARD_DEVICE_EXTENSION pCard	= pPort->pParentCardExt;
	NTSTATUS status					= STATUS_SUCCESS;
	SHORT PortType = 0;
	CHAR szTemp[50];		// Space to hold string 
	CHAR szCard[10];		// Space to hold card type string 
	int i = 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortInit for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

#ifndef BUILD_SPXMINIPORT
	// Form an InstanceID for the port.
	if(!SPX_SUCCESS(status = Spx_CreatePortInstanceID(pPort)))
		return status;
#endif

	// Create port DeviceID, HardwareID and device description.
	sprintf(szCard, "IO8");

	if(pPort->PortNumber < 8)
	{
		PortType = IO8_RJ12;
	}
	

	// Initialise device identifiers... 
	switch(PortType)
	{	
	case IO8_RJ12:
		sprintf(szTemp,"%s\\IO8&RJ12", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"%s\\IO8&RJ12", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Perle I/O8+ Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	default:
		sprintf(szTemp,"%s\\XXXXXXXX", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"%s\\XXXXXXXX", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);

		sprintf(szTemp,"Perle Serial Port %d of Unknown Type.", pPort->PortNumber + 1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);

		status = STATUS_UNSUCCESSFUL;
		break;
	}

/* Not required as we are using INF file 
	// Create device loacation string.
	i = sprintf(szTemp, "Port %d on ", pPort->PortNumber + 1);

	if(pCard->InterfaceType == Isa)
		sprintf(szTemp+i, "ISA Adapter 0x%04lX", pCard->PhysAddr);
	else
		sprintf(szTemp+i, "PCI Adapter 0x%04lX", pCard->PhysAddr);

	Spx_InitMultiString(FALSE, &pPort->DevLocation, szTemp, NULL);
*/

	pPort->ChannelNumber = (UCHAR) pPort->PortNumber;	// This should not be needed

	return status;
}




NTSTATUS
XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortStart for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	// Initialize the list heads for the read, write, and mask queues... 
	InitializeListHead(&pPort->ReadQueue);
	InitializeListHead(&pPort->WriteQueue);
	InitializeListHead(&pPort->MaskQueue);
	InitializeListHead(&pPort->PurgeQueue);

	// Initialize the spinlock associated with fields read (& set) by IO Control functions... 
	KeInitializeSpinLock(&pPort->ControlLock);

	// Initialize the timers used to timeout operations... 
	KeInitializeTimer(&pPort->ReadRequestTotalTimer);
	KeInitializeTimer(&pPort->ReadRequestIntervalTimer);
	KeInitializeTimer(&pPort->WriteRequestTotalTimer);
	KeInitializeTimer(&pPort->ImmediateTotalTimer);
	KeInitializeTimer(&pPort->XoffCountTimer);

	// Initialise the dpcs that will be used to complete or timeout various IO operations... 
	KeInitializeDpc(&pPort->CommWaitDpc, SerialCompleteWait, pPort);
	KeInitializeDpc(&pPort->CompleteReadDpc, SerialCompleteRead, pPort);
	KeInitializeDpc(&pPort->CompleteWriteDpc, SerialCompleteWrite, pPort);
	KeInitializeDpc(&pPort->TotalImmediateTimeoutDpc, SerialTimeoutImmediate, pPort);
	KeInitializeDpc(&pPort->TotalReadTimeoutDpc, SerialReadTimeout, pPort);
	KeInitializeDpc(&pPort->IntervalReadTimeoutDpc, SerialIntervalReadTimeout, pPort);
	KeInitializeDpc(&pPort->TotalWriteTimeoutDpc, SerialWriteTimeout, pPort);
	KeInitializeDpc(&pPort->CommErrorDpc, SerialCommError, pPort);
	KeInitializeDpc(&pPort->CompleteImmediateDpc, SerialCompleteImmediate, pPort);
	KeInitializeDpc(&pPort->XoffCountTimeoutDpc, SerialTimeoutXoff, pPort);
	KeInitializeDpc(&pPort->XoffCountCompleteDpc, SerialCompleteXoff, pPort);

	// Default device control fields... 
	pPort->SpecialChars.XonChar			= SERIAL_DEF_XON;
	pPort->SpecialChars.XoffChar		= SERIAL_DEF_XOFF;
	pPort->HandFlow.ControlHandShake	= SERIAL_DTR_CONTROL;
	pPort->HandFlow.FlowReplace			= SERIAL_RTS_CONTROL;

	// Default line configuration: 1200,E,7,1 
	pPort->CurrentBaud		= 1200;
	pPort->LineControl		= SERIAL_EVEN_PARITY | SERIAL_7_DATA | SERIAL_1_STOP;
	pPort->ValidDataMask	= 0x7F;

	// Default xon/xoff limits... 
	pPort->HandFlow.XoffLimit	= pPort->BufferSize >> 3;
	pPort->HandFlow.XonLimit	= pPort->BufferSize >> 1;
	pPort->BufferSizePt8		= ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));


	SpxDbgMsg(SPX_MISC_DBG,	("%s: The default interrupt read buffer size is: %d\n"
								"------  The XoffLimit is                         : %d\n"
								"------  The XonLimit is                          : %d\n"
								"------  The pt 8 size is                         : %d\n",
								PRODUCT_NAME,
								pPort->BufferSize,
								pPort->HandFlow.XoffLimit,
								pPort->HandFlow.XonLimit,
								pPort->BufferSizePt8 ));

	// Define which baud rates can be supported... 
	pPort->SupportedBauds = SERIAL_BAUD_USER;
	pPort->SupportedBauds |= SERIAL_BAUD_075;
	pPort->SupportedBauds |= SERIAL_BAUD_110;
	pPort->SupportedBauds |= SERIAL_BAUD_134_5;
	pPort->SupportedBauds |= SERIAL_BAUD_150;
	pPort->SupportedBauds |= SERIAL_BAUD_300;
	pPort->SupportedBauds |= SERIAL_BAUD_600;
	pPort->SupportedBauds |= SERIAL_BAUD_1200;
	pPort->SupportedBauds |= SERIAL_BAUD_1800;
	pPort->SupportedBauds |= SERIAL_BAUD_2400;
	pPort->SupportedBauds |= SERIAL_BAUD_4800;
	pPort->SupportedBauds |= SERIAL_BAUD_7200;
	pPort->SupportedBauds |= SERIAL_BAUD_9600;
	pPort->SupportedBauds |= SERIAL_BAUD_14400;
	pPort->SupportedBauds |= SERIAL_BAUD_19200;
	pPort->SupportedBauds |= SERIAL_BAUD_38400;
	pPort->SupportedBauds |= SERIAL_BAUD_56K;
	pPort->SupportedBauds |= SERIAL_BAUD_57600;
	pPort->SupportedBauds |= SERIAL_BAUD_115200;

	// Set up values for interval timing... 
	pPort->ShortIntervalAmount.LowPart	= 1;
	pPort->ShortIntervalAmount.HighPart = 0;
	pPort->ShortIntervalAmount = RtlLargeIntegerNegate(pPort->ShortIntervalAmount);
	pPort->LongIntervalAmount.LowPart	= 10000000;
	pPort->LongIntervalAmount.HighPart	= 0;
	pPort->LongIntervalAmount = RtlLargeIntegerNegate(pPort->LongIntervalAmount);
	pPort->CutOverAmount.LowPart		= 200000000;
	pPort->CutOverAmount.HighPart		= 0;


#ifdef WMI_SUPPORT
	//
	// Fill in WMI hardware data
	//

	pPort->WmiHwData.IrqNumber			= pCard->TrIrql;
	pPort->WmiHwData.IrqVector			= pCard->TrVector;
	pPort->WmiHwData.IrqLevel			= pCard->TrIrql;
	pPort->WmiHwData.IrqAffinityMask	= pCard->ProcessorAffinity;
	
	if(pCard->InterruptMode == Latched)
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LATCHED;
	else
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LEVEL;

	pPort->WmiHwData.BaseIOAddress = (ULONG_PTR)pCard->Controller;


	//
	// Fill in WMI device state data (as defaults)
	//

	pPort->WmiCommData.BaudRate					= pPort->CurrentBaud;
	UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
	UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);

	pPort->WmiCommData.MaximumBaudRate			= 115200U;	// 115200k baud max
	pPort->WmiCommData.MaximumOutputBufferSize	= (UINT32)((ULONG)-1);
	pPort->WmiCommData.MaximumInputBufferSize	= (UINT32)((ULONG)-1);

	pPort->WmiCommData.Support16BitMode			= FALSE;
	pPort->WmiCommData.SupportDTRDSR			= TRUE;
	pPort->WmiCommData.SupportIntervalTimeouts	= TRUE;
	pPort->WmiCommData.SupportParityCheck		= TRUE;
	pPort->WmiCommData.SupportRTSCTS			= TRUE;
	pPort->WmiCommData.SupportXonXoff			= TRUE;
	pPort->WmiCommData.SettableBaudRate			= TRUE;
	pPort->WmiCommData.SettableDataBits			= TRUE;
	pPort->WmiCommData.SettableFlowControl		= TRUE;
	pPort->WmiCommData.SettableParity			= TRUE;
	pPort->WmiCommData.SettableParityCheck		= TRUE;
	pPort->WmiCommData.SettableStopBits			= TRUE;
	pPort->WmiCommData.IsBusy					= FALSE;


	// Fill in wmi perf data (all zero's)
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));


	//
    // Register for WMI
	//
	
	SpxPort_WmiInitializeWmilibContext(&pPort->WmiLibInfo);


	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_REGISTER);
#endif
	



#ifdef TEST_CRYSTAL_FREQUENCY
	if(pPort->PortNumber == 0)
		Io8_TestCrystal(pPort);		// Test Crystal Frequency when starting first port.
#endif

	// Initialise the port hardware... 
	KeSynchronizeExecution(pCard->Interrupt, Io8_ResetChannel, pPort);	// Apply initial port settings 
	KeSynchronizeExecution(pCard->Interrupt, SerialClrRTS, pPort);		// Clear RTS signal
	KeSynchronizeExecution(pCard->Interrupt, SerialClrDTR, pPort);		// Clear DTR signal 

	return status;
}


NTSTATUS
XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortStop for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

#ifdef WMI_SUPPORT
	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_DEREGISTER);
#endif

	// Cancel timers...
    KeCancelTimer( &pPort->ReadRequestTotalTimer );
    KeCancelTimer( &pPort->ReadRequestIntervalTimer );
    KeCancelTimer( &pPort->WriteRequestTotalTimer );
    KeCancelTimer( &pPort->ImmediateTotalTimer );
    KeCancelTimer( &pPort->XoffCountTimer );

	// Cancel pending DPCs...
    KeRemoveQueueDpc( &pPort->CompleteWriteDpc );
    KeRemoveQueueDpc( &pPort->CompleteReadDpc );
    KeRemoveQueueDpc( &pPort->TotalReadTimeoutDpc );
    KeRemoveQueueDpc( &pPort->IntervalReadTimeoutDpc );
    KeRemoveQueueDpc( &pPort->TotalWriteTimeoutDpc );
    KeRemoveQueueDpc( &pPort->CommErrorDpc );
    KeRemoveQueueDpc( &pPort->CompleteImmediateDpc );
    KeRemoveQueueDpc( &pPort->TotalImmediateTimeoutDpc );
    KeRemoveQueueDpc( &pPort->CommWaitDpc );
    KeRemoveQueueDpc( &pPort->XoffCountTimeoutDpc );
    KeRemoveQueueDpc( &pPort->XoffCountCompleteDpc );

	return status;
}

NTSTATUS
XXX_PortDeInit(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortDeInit for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	// Free identifier string allocations... 
	if(pPort->DeviceID.Buffer != NULL)
		SpxFreeMem(pPort->DeviceID.Buffer);

	if(pPort->InstanceID.Buffer != NULL)
		SpxFreeMem(pPort->InstanceID.Buffer);
	
	if(pPort->HardwareIDs.Buffer != NULL)	
		SpxFreeMem(pPort->HardwareIDs.Buffer);

	if(pPort->DevDesc.Buffer != NULL)
		SpxFreeMem(pPort->DevDesc.Buffer);

	if(pPort->DevLocation.Buffer != NULL)
		SpxFreeMem(pPort->DevLocation.Buffer);

	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\ioctl.c ===
#include "precomp.h"			
/***************************************************************************\
*                                                                           *
*     IOCTL.C    -   IO8+ Intelligent I/O Board driver                      *
*                                                                           *
*     Copyright (c) 1992-1993 Ring Zero Systems, Inc.                       *
*     All Rights Reserved.                                                  *
*                                                                           *
\***************************************************************************/

/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module contains the ioctl dispatcher as well as a couple
    of routines that are generally just called in response to
    ioctl calls.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

// Prototypes
BOOLEAN SerialGetModemUpdate(IN PVOID Context);
BOOLEAN SerialGetCommStatus(IN PVOID Context);
BOOLEAN SerialSetEscapeChar(IN PVOID Context);
// end of prototypes    
    


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SerialGetStats(IN PVOID Context) 
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    return the perf stats to the caller.
//
// Arguments:
//    Context - Pointer to a the irp.
//
// Return Value:
//    This routine always returns FALSE.
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
SerialGetStats(IN PVOID Context)
{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation((PIRP)Context);
    PPORT_DEVICE_EXTENSION pPort = irpSp->DeviceObject->DeviceExtension;
    PSERIALPERF_STATS sp = ((PIRP)Context)->AssociatedIrp.SystemBuffer;

	*sp = *((PSERIALPERF_STATS) &pPort->PerfStats);

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SerialClearStats(IN PVOID Context) 
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    clear the perf stats.
//
// Arguments:
//    Context - Pointer to a the extension.
//
// Return Value:
//    This routine always returns FALSE.
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
SerialClearStats(IN PVOID Context)
{
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)Context;

    RtlZeroMemory(&pPort->PerfStats, sizeof(SERIALPERF_STATS));

#ifdef WMI_SUPPORT
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));	
#endif

    return FALSE;
}



BOOLEAN
SerialSetChars(IN PVOID Context)
/*++

Routine Description:

    This routine is used to set the special characters for the
    driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a special characters
              structure.

Return Value:

    This routine always returns FALSE.

--*/
{
    ((PSERIAL_IOCTL_SYNC)Context)->pPort->SpecialChars =
        *((PSERIAL_CHARS)(((PSERIAL_IOCTL_SYNC)Context)->Data));

    Io8_SetChars(((PSERIAL_IOCTL_SYNC)Context)->pPort);
    return FALSE;
}


BOOLEAN
SerialGetModemUpdate(IN PVOID Context)
/*++

Routine Description:

    This routine is simply used to call the interrupt level routine
    that handles modem status update.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/
{
    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

    *Result = SerialHandleModemUpdate(pPort, FALSE);

    return FALSE;
}


BOOLEAN
SerialGetCommStatus(IN PVOID Context)
/*++

Routine Description:

    This is used to get the current state of the serial driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a serial status
              record.

Return Value:

    This routine always returns FALSE.

--*/
{
    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    PSERIAL_STATUS Stat = ((PSERIAL_IOCTL_SYNC)Context)->Data;

    Stat->Errors = pPort->ErrorWord;
    pPort->ErrorWord = 0;

    //
    // BUG BUG We need to do something about eof (binary mode).
    //
    Stat->EofReceived = FALSE;

    Stat->AmountInInQueue = pPort->CharsInInterruptBuffer;

    Stat->AmountInOutQueue = pPort->TotalCharsQueued;

    if(pPort->WriteLength) 
	{
        // By definition if we have a writelength the we have a current write irp.
        ASSERT(pPort->CurrentWriteIrp);
        ASSERT(Stat->AmountInOutQueue >= pPort->WriteLength);
        ASSERT((IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->
                Parameters.Write.Length) >= pPort->WriteLength);
                
        Stat->AmountInOutQueue -=
            IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)
            ->Parameters.Write.Length - (pPort->WriteLength);
    }

    Stat->WaitForImmediate = pPort->TransmitImmediate;

    Stat->HoldReasons = 0;

    if(pPort->TXHolding) 
	{

        if(pPort->TXHolding & SERIAL_TX_CTS) 
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;

        if(pPort->TXHolding & SERIAL_TX_DSR)
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;

        if(pPort->TXHolding & SERIAL_TX_DCD)
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;

        if(pPort->TXHolding & SERIAL_TX_XOFF)
            Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;

        if(pPort->TXHolding & SERIAL_TX_BREAK) 
            Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;


    }

    if(pPort->RXHolding & SERIAL_RX_DSR) 
        Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;

    if(pPort->RXHolding & SERIAL_RX_XOFF)
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;


	SerialDump(SERDIAG1,("IO8: Err 0x%x HR 0x%x inq 0x%x outq 0x%x\n",
		Stat->Errors,Stat->HoldReasons, Stat->AmountInInQueue,
		Stat->AmountInOutQueue));

    return FALSE;

}

BOOLEAN
SerialSetEscapeChar(IN PVOID Context)
/*++

Routine Description:

    This is used to set the character that will be used to escape
    line status and modem status information when the application
    has set up that line status and modem status should be passed
    back in the data stream.

Arguments:

    Context - Pointer to the irp that is specify the escape character.
              Implicitly - An escape character of 0 means no escaping
              will occur.

Return Value:

    This routine always returns FALSE.

--*/
{
    PPORT_DEVICE_EXTENSION pPort 
		= IoGetCurrentIrpStackLocation((PIRP)Context)->DeviceObject->DeviceExtension;

    pPort->EscapeChar = *(PUCHAR)((PIRP)Context)->AssociatedIrp.SystemBuffer;

    return FALSE;
}


NTSTATUS
SerialIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine provides the initial processing for all of the
    Ioctrls for the serial device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/
{
    // The status that gets returned to the caller and set in the Irp.
    NTSTATUS Status;

    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    PIO_STACK_LOCATION IrpSp;

    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    KIRQL OldIrql;


	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;


	IrpSp = IoGetCurrentIrpStackLocation(Irp);
	Irp->IoStatus.Information = 0L;
	Status = STATUS_SUCCESS;

    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) 
	{

    case IOCTL_SERIAL_SET_BAUD_RATE: 
		{
			SETBAUD	SetBaud;
			ULONG BaudRate;
			//
			// Will hold the value of the appropriate divisor for
			// the requested baud rate.  If the baudrate is invalid
			// (because the device won't support that baud rate) then
			// this value is undefined.
			//
			// Note: in one sense the concept of a valid baud rate
			// is cloudy.  We could allow the user to request any
			// baud rate.  We could then calculate the divisor needed
			// for that baud rate.  As long as the divisor wasn't less
			// than one we would be "ok".  (The percentage difference
			// between the "true" divisor and the "rounded" value given
			// to the hardware might make it unusable, but... )  It would
			// really be up to the user to "Know" whether the baud rate
			// is suitable.  So much for theory, *We* only support a given
			// set of baud rates.
			//
			SerialDump( SERDIAG3, ("SERIAL: SET_BAUD_RATE\n"));

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BAUD_RATE)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			} 
			else 
			{
				BaudRate = ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;
			}
			
			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			SetBaud.Baudrate = BaudRate;
			SetBaud.pPort = pPort;
			KeSynchronizeExecution(pCard->Interrupt, Io8_SetBaud, &SetBaud);

			if(!SetBaud.Result)
			{
				Status = STATUS_INVALID_PARAMETER;
			}
#ifdef WMI_SUPPORT
			else
			{
				pPort->WmiCommData.BaudRate = BaudRate;
			}
#endif
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

    case IOCTL_SERIAL_GET_BAUD_RATE: 
		{
			PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;
			SerialDump( SERDIAG3, ("SERIAL: GET_BAUD_RATE\n"));
        
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength <sizeof(SERIAL_BAUD_RATE)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			Br->BaudRate = pPort->CurrentBaud;

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            
			Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);

			break;
		}

    case IOCTL_SERIAL_SET_LINE_CONTROL: 
		{
			// Points to the line control record in the Irp.
			PSERIAL_LINE_CONTROL Lc = ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

			UCHAR LData;
			UCHAR LStop;
			UCHAR LParity;
			UCHAR Mask = 0xff;

			SerialDump( SERDIAG3, ("SERIAL: SET_LINE_CONTROL\n"));

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_LINE_CONTROL))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			switch (Lc->WordLength) 
			{
			case 5: 
				{
					LData = SERIAL_5_DATA;
					Mask = 0x1f;
					break;
				}

			case 6: 
				{
					LData = SERIAL_6_DATA;
					Mask = 0x3f;
					break;
				}

			case 7: 
				{
					LData = SERIAL_7_DATA;
					Mask = 0x7f;
					break;
				}

			case 8: 
				{
					LData = SERIAL_8_DATA;
					break;
				}

			default: 
				{
					Status = STATUS_INVALID_PARAMETER;
					goto DoneWithIoctl;
				}
			}


			switch (Lc->Parity) 
			{
			case NO_PARITY: 
				LParity = SERIAL_NONE_PARITY;
				break;

			case EVEN_PARITY:
				LParity = SERIAL_EVEN_PARITY;
				break;

			case ODD_PARITY:
				LParity = SERIAL_ODD_PARITY;
				break;


			case SPACE_PARITY: 
				LParity = SERIAL_SPACE_PARITY;
				break;

			case MARK_PARITY: 
				LParity = SERIAL_MARK_PARITY;
				break;

			default:
				Status = STATUS_INVALID_PARAMETER;
				goto DoneWithIoctl;
				break;
			}

			switch (Lc->StopBits) 
			{
			case STOP_BIT_1: 
				{
					LStop = SERIAL_1_STOP;
					break;
				}

			case STOP_BITS_1_5: 
				{
					if (LData != SERIAL_5_DATA) 
					{
						Status = STATUS_INVALID_PARAMETER;
						goto DoneWithIoctl;
					}

					LStop = SERIAL_1_5_STOP;
					break;
				}
          
			case STOP_BITS_2: 
				{
					if (LData == SERIAL_5_DATA) 
					{
						Status = STATUS_INVALID_PARAMETER;
						goto DoneWithIoctl;
					}

					LStop = SERIAL_2_STOP;
					break;
				}

			default: 
				{
					Status = STATUS_INVALID_PARAMETER;
					goto DoneWithIoctl;
				}
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
            
			pPort->LineControl 
				= (UCHAR)((pPort->LineControl & SERIAL_LCR_BREAK) | (LData | LParity | LStop));
                    
			pPort->ValidDataMask = Mask;

			KeSynchronizeExecution(pCard->Interrupt, Io8_SetLineControl, pPort);

#ifdef WMI_SUPPORT
			UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
#endif

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_GET_LINE_CONTROL: 
		{
            PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            SerialDump( SERDIAG3, ("SERIAL: GET_LINE_CONTROL\n"));
            
			if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_LINE_CONTROL))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                

            if ((pPort->LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA) 
			{
                Lc->WordLength = 5;
            } 
			else if ((pPort->LineControl & SERIAL_DATA_MASK) == SERIAL_6_DATA)
			{
                Lc->WordLength = 6;
            } 
			else if ((pPort->LineControl & SERIAL_DATA_MASK) == SERIAL_7_DATA)
			{
                Lc->WordLength = 7;
            } 
			else if ((pPort->LineControl & SERIAL_DATA_MASK) == SERIAL_8_DATA)
			{
                Lc->WordLength = 8;
            }


            if ((pPort->LineControl & SERIAL_PARITY_MASK) == SERIAL_NONE_PARITY)
			{
                Lc->Parity = NO_PARITY;
            } 
			else if ((pPort->LineControl & SERIAL_PARITY_MASK) == SERIAL_ODD_PARITY)
			{
                Lc->Parity = ODD_PARITY;
            } 
			else if ((pPort->LineControl & SERIAL_PARITY_MASK) == SERIAL_EVEN_PARITY)
			{
                Lc->Parity = EVEN_PARITY;
            } 
			else if ((pPort->LineControl & SERIAL_PARITY_MASK) == SERIAL_MARK_PARITY)
			{
                Lc->Parity = MARK_PARITY;
            } 
			else if ((pPort->LineControl & SERIAL_PARITY_MASK) == SERIAL_SPACE_PARITY) 
			{
                Lc->Parity = SPACE_PARITY;
            }


            if (pPort->LineControl & SERIAL_2_STOP) 
			{
                if (Lc->WordLength == 5) 
				{
                    Lc->StopBits = STOP_BITS_1_5;
                } 
				else 
				{
                    Lc->StopBits = STOP_BITS_2;
                }
            } 
			else 
			{
                Lc->StopBits = STOP_BIT_1;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

    case IOCTL_SERIAL_SET_TIMEOUTS: 
		{
            PSERIAL_TIMEOUTS NewTimeouts = ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));

            SerialDump( SERDIAG3, ("SERIAL: SET_TIMEOUTS\n"));
  
			if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_TIMEOUTS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            pPort->Timeouts.ReadIntervalTimeout			= NewTimeouts->ReadIntervalTimeout;
            pPort->Timeouts.ReadTotalTimeoutMultiplier	= NewTimeouts->ReadTotalTimeoutMultiplier;
            pPort->Timeouts.ReadTotalTimeoutConstant	= NewTimeouts->ReadTotalTimeoutConstant;
            pPort->Timeouts.WriteTotalTimeoutMultiplier = NewTimeouts->WriteTotalTimeoutMultiplier;
            pPort->Timeouts.WriteTotalTimeoutConstant	= NewTimeouts->WriteTotalTimeoutConstant;

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

    case IOCTL_SERIAL_GET_TIMEOUTS: 
		{
            SerialDump( SERDIAG3, ("SERIAL: GET_TIMEOUTS\n"));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_TIMEOUTS))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            *((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) = pPort->Timeouts;
            Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            
			break;
        }

    case IOCTL_SERIAL_SET_CHARS: 
		{
            SERIAL_IOCTL_SYNC S;
            PSERIAL_CHARS NewChars = ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));

            SerialDump( SERDIAG3, ("SERIAL: SET_CHARS\n"));
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_CHARS))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // The only thing that can be wrong with the chars
            // is that the xon and xoff characters are the same.
            if (NewChars->XonChar == NewChars->XoffChar) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            // We acquire the control lock so that only one request can GET or SET 
            // the characters at a time.  The sets could be synchronized by the 
            // interrupt spinlock, but that wouldn't prevent multiple gets at the same time.

            S.pPort = pPort;
            S.Data = NewChars;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                

            // Under the protection of the lock, make sure that the xon and xoff 
            // characters aren't the same as the escape character.

            if (pPort->EscapeChar) 
			{
                if((pPort->EscapeChar == NewChars->XonChar) 
					|| (pPort->EscapeChar == NewChars->XoffChar)) 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

                    break;
                }
            }

            KeSynchronizeExecution(pCard->Interrupt, SerialSetChars, &S);

#ifdef WMI_SUPPORT
			UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
#endif

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
                
            break;
        }

    case IOCTL_SERIAL_GET_CHARS: 
		{
            SerialDump( SERDIAG3, ("SERIAL: GET_CHARS\n"));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_CHARS))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            *((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) = pPort->SpecialChars;
            Irp->IoStatus.Information = sizeof(SERIAL_CHARS);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
                
            break;
        }

    case IOCTL_SERIAL_SET_DTR:
    case IOCTL_SERIAL_CLR_DTR: 
		{

            //
            // We acquire the lock so that we can check whether
            // automatic dtr flow control is enabled.  If it is
            // then we return an error since the app is not allowed
            // to touch this if it is automatic.
            //

			if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_DTR)
            	SerialDump( SERDIAG3, ("SERIAL: SET_DTR\n"));
			else
            	SerialDump( SERDIAG3, ("SERIAL: CLR_DTR\n"));

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            if ((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
			{
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

            } 
			else 
			{
                KeSynchronizeExecution(pCard->Interrupt,
					((IrpSp->Parameters.DeviceIoControl.IoControlCode 
					== IOCTL_SERIAL_SET_DTR) ? (SerialSetDTR):(SerialClrDTR)),
                    pPort);
            }

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

    case IOCTL_SERIAL_RESET_DEVICE: 
		{
            SerialDump( SERDIAG3, ("SERIAL: RESET_DEVICE\n"));
            break;
        }

    case IOCTL_SERIAL_SET_RTS:
    case IOCTL_SERIAL_CLR_RTS: 
		{
            //
            // We acquire the lock so that we can check whether
            // automatic rts flow control or transmit toggleing
            // is enabled.  If it is then we return an error since
            // the app is not allowed to touch this if it is automatic
            // or toggling.
            //

            SerialDump( SERDIAG3, ("SERIAL: SET/CLR_RTS\n"));
            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
               
            if(((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE)
				|| ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE)) 
			{
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            } 
			else 
			{
                KeSynchronizeExecution(pCard->Interrupt,
                    ((IrpSp->Parameters.DeviceIoControl.IoControlCode 
					== IOCTL_SERIAL_SET_RTS) ? (SerialSetRTS):(SerialClrRTS)),
                    pPort);
            }

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

	case IOCTL_SERIAL_SET_XOFF: 
		{
            SerialDump( SERDIAG3, ("SERIAL: SET_XOFF\n"));

            KeSynchronizeExecution(pCard->Interrupt, SerialPretendXoff, pPort);

            break;
        }

        
	case IOCTL_SERIAL_SET_XON: 
		{
            SerialDump( SERDIAG3, ("SERIAL: SET_XON\n"));

            KeSynchronizeExecution(pCard->Interrupt, SerialPretendXon, pPort);

            break;
        }

        
	case IOCTL_SERIAL_SET_BREAK_ON: 
		{

            SerialDump( SERDIAG3, ("SERIAL: SET_BREAK_ON\n"));
			pPort->DoBreak = BREAK_START;
			Io8_EnableTxInterrupts(pPort);

            break;
        }

        
	case IOCTL_SERIAL_SET_BREAK_OFF: 
		{

            SerialDump( SERDIAG3, ("SERIAL: SET_BREAK_OFF\n"));
			pPort->DoBreak = BREAK_END;
			Io8_EnableTxInterrupts(pPort);

            break;
        }
        
	case IOCTL_SERIAL_SET_QUEUE_SIZE: 
		{
            //
            // Type ahead buffer is fixed, so we just validate
            // the the users request is not bigger that our
            // own internal buffer size.
            //

            PSERIAL_QUEUE_SIZE Rs = ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));
                
            SerialDump( SERDIAG3, ("SERIAL: SET_QUEUE_SIZE\n"));

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_QUEUE_SIZE)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // We have to allocate the memory for the new
            // buffer while we're still in the context of the
            // caller.  We don't even try to protect this
            // with a lock because the value could be stale
            // as soon as we release the lock - The only time
            // we will know for sure is when we actually try
            // to do the resize.
            //

            if (Rs->InSize <= pPort->BufferSize) 
			{
                Status = STATUS_SUCCESS;
                break;
            }

            try 
			{
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer 
					= SpxAllocateMemWithQuota(NonPagedPool, Rs->InSize);

            } 
			except (EXCEPTION_EXECUTE_HANDLER) 
			{
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                Status = GetExceptionCode();
            }


            if (!IrpSp->Parameters.DeviceIoControl.Type3InputBuffer) 
			{
                break;
            }

            //
            // Well the data passed was big enough.  Do the request.
            //
            // There are two reason we place it in the read queue:
            //
            // 1) We want to serialize these resize requests so that
            //    they don't contend with each other.
            //
            // 2) We want to serialize these requests with reads since
            //    we don't want reads and resizes contending over the
            //    read buffer.
            //

            return SerialStartOrQueue(	pPort, Irp, &pPort->ReadQueue, 
										&pPort->CurrentReadIrp, SerialStartRead);
                      
            break;

        }
        
	case IOCTL_SERIAL_GET_WAIT_MASK: 
		{
            SerialDump( SERDIAG3, ("SERIAL: GET_WAIT_MASK\n"));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Simple scalar read.  No reason to acquire a lock.
            //

            Irp->IoStatus.Information = sizeof(ULONG);

            *((ULONG *)Irp->AssociatedIrp.SystemBuffer)=pPort->IsrWaitMask;

            SerialDump(SERDIAG3,("SERIAL: got 0x%x\n",pPort->IsrWaitMask));
            break;

        }


        
	case IOCTL_SERIAL_SET_WAIT_MASK: 
		{
            ULONG NewMask;

            SerialDump( SERDIAG3,("SERIAL: SET_WAIT_MASK\n"));
    
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
			{

                SerialDump(SERDIAG3,("SERIAL: Invalid size fo the buffer %d\n",
                     IrpSp->Parameters.DeviceIoControl.InputBufferLength));
					 
                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            } 
			else 
			{
                NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);
            }

            SerialDump( SERDIAG3, ("SERIAL: mask 0x%x\n",NewMask));

            //
            // Make sure that the mask only contains valid waitable events.
            //

            if (NewMask & ~(SERIAL_EV_RXCHAR   |
                            SERIAL_EV_RXFLAG   |
                            SERIAL_EV_TXEMPTY  |
                            SERIAL_EV_CTS      |
                            SERIAL_EV_DSR      |
                            SERIAL_EV_RLSD     |
                            SERIAL_EV_BREAK    |
                            SERIAL_EV_ERR      |
                            SERIAL_EV_RING     |
                            SERIAL_EV_PERR     |
                            SERIAL_EV_RX80FULL |
                            SERIAL_EV_EVENT1   |
                            SERIAL_EV_EVENT2)) {

                SerialDump(SERDIAG3, ("SERIAL: Unknown mask %x\n",NewMask));
                    
                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            //
            // Either start this irp or put it on the
            // queue.
            //

            SerialDump(SERDIAG3,("SERIAL: Starting or queuing set mask irp %x\n",Irp));
                
            return SerialStartOrQueue(	pPort, Irp, &pPort->MaskQueue,
										&pPort->CurrentMaskIrp, SerialStartMask);
        }

        
	case IOCTL_SERIAL_WAIT_ON_MASK: 
		{

            SerialDump(SERDIAG3,("SERIAL: WAIT_ON_MASK\n"));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
			{
                SerialDump(SERDIAG3,("SERIAL: Invalid size fo the buffer %d\n",
                     IrpSp->Parameters.DeviceIoControl.InputBufferLength));

                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // Either start this irp or put it on the queue.
            SerialDump(SERDIAG3, ("SERIAL: Starting or queuing wait mask irp %x\n",Irp));
                
            return SerialStartOrQueue(pPort, Irp, &pPort->MaskQueue, 
										&pPort->CurrentMaskIrp, SerialStartMask);
                       
        }

        
	case IOCTL_SERIAL_IMMEDIATE_CHAR: 
		{
            BOOLEAN FailRequest;

            SerialDump( SERDIAG3, ("SERIAL: IMMEDIATE_CHAR\n"));
            
			if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            IoAcquireCancelSpinLock(&OldIrql);

            if (pPort->CurrentImmediateIrp) 
			{
                FailRequest = TRUE;
                Status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = Status;
                IoReleaseCancelSpinLock(OldIrql);
            } 
			else 
			{
                //
                // We can queue the char.  We need to set
                // a cancel routine because flow control could
                // keep the char from transmitting.  Make sure
                // that the irp hasn't already been canceled.
                //

                if (Irp->Cancel) 
				{
                    IoReleaseCancelSpinLock(OldIrql);
                    Irp->IoStatus.Status = STATUS_CANCELLED;
                    Status = STATUS_CANCELLED;
                } 
				else 
				{
                    pPort->CurrentImmediateIrp = Irp;
                    pPort->TotalCharsQueued++;
                    IoReleaseCancelSpinLock(OldIrql);
                    SerialStartImmediate(pPort);

                    return STATUS_PENDING;
                }
            }

			break;
        }

        
	case IOCTL_SERIAL_PURGE: 
		{
            ULONG Mask;

            SerialDump( SERDIAG3, ("SERIAL: PURGE\n"));

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // Check to make sure that the mask only has 0 or the other appropriate values.
            Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));

            if ((!Mask) || (Mask & (~(	SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT 
                                      | SERIAL_PURGE_TXCLEAR | SERIAL_PURGE_RXCLEAR)))) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Either start this irp or put it on the
            // queue.
            //

            return SerialStartOrQueue(pPort, Irp, &pPort->PurgeQueue,
                       &pPort->CurrentPurgeIrp, SerialStartPurge);
        }

        
	case IOCTL_SERIAL_GET_HANDFLOW: 
		{
            SerialDump( SERDIAG3, ("SERIAL: GET_HANDFLOW\n"));
            
			if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_HANDFLOW))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            *((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) = pPort->HandFlow;

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
                
            break;
        }

        
	case IOCTL_SERIAL_SET_HANDFLOW: 
		{
            SERIAL_IOCTL_SYNC S;
            PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

            SerialDump( SERDIAG3, ("SERIAL: SET_HANDFLOW\n"));
            //
            // Make sure that the hand shake and control is the
            // right size.
            //

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_HANDFLOW))
            {
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
            }

            //
            // Make sure that there are no invalid bits set in
            // the control and handshake.
            //

            if (HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID)
            {
				Status = STATUS_INVALID_PARAMETER;
				break;
            }

            if (HandFlow->FlowReplace & SERIAL_FLOW_INVALID)
            {
				Status = STATUS_INVALID_PARAMETER;
				break;
            }

            //
            // Make sure that the app hasn't set an invlid DTR mode.
            //

            if ((HandFlow->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_MASK)
            {
				Status = STATUS_INVALID_PARAMETER;
				break;
            }

            //
            // Make sure that haven't set totally invalid xon/xoff
            // limits.
            //

            if ((HandFlow->XonLimit < 0) || ((ULONG)HandFlow->XonLimit > pPort->BufferSize))
            {
				Status = STATUS_INVALID_PARAMETER;
				break;
            }

            if ((HandFlow->XoffLimit < 0) || ((ULONG)HandFlow->XoffLimit > pPort->BufferSize))
            {
				Status = STATUS_INVALID_PARAMETER;
				break;
            }

            S.pPort = pPort;
            S.Data = HandFlow;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                

            //
            // Under the protection of the lock, make sure that
            // we aren't turning on error replacement when we
            // are doing line status/modem status insertion.
            //

            if (pPort->EscapeChar)
            {
				if (HandFlow->FlowReplace & SERIAL_ERROR_CHAR)
				{
					Status = STATUS_INVALID_PARAMETER;
					KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
					break;
				}
            }

            KeSynchronizeExecution(pCard->Interrupt, SerialSetHandFlow, &S);

#ifdef WMI_SUPPORT
			UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_MODEMSTATUS: 
		{
            ULONG ModemControl;
            SERIAL_IOCTL_SYNC S;

            SerialDump( SERDIAG3, ("SERIAL: GET_MODEMSTATUS\n"));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);

            S.pPort = pPort;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            KeSynchronizeExecution(pCard->Interrupt, SerialGetModemUpdate, &S);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            ModemControl = Io8_GetModemControl(pPort);
            ModemControl &= SERIAL_DTR_STATE | SERIAL_RTS_STATE;
            *(PULONG)Irp->AssociatedIrp.SystemBuffer |= ModemControl;

            break;
        }

        
	case IOCTL_SERIAL_GET_DTRRTS: 
		{
            ULONG ModemControl;
            SerialDump( SERDIAG3, ("SERIAL: GET_DTRRTS\n"));
            
			if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Reading this hardware has no effect on the device.
            //

            ModemControl = Io8_GetModemControl(pPort);

            ModemControl &= SERIAL_DTR_STATE | SERIAL_RTS_STATE;

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = ModemControl;

            break;

        }

        
	case IOCTL_SERIAL_GET_COMMSTATUS: 
		{
            SERIAL_IOCTL_SYNC S;

            SerialDump( SERDIAG3, ("SERIAL: GET_COMMSTATUS\n"));
            
			if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_STATUS))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

            S.pPort = pPort;
            S.Data =  Irp->AssociatedIrp.SystemBuffer;

            //
            // Acquire the cancel spin lock so nothing much
            // changes while were getting the state.
            //

            IoAcquireCancelSpinLock(&OldIrql);

            KeSynchronizeExecution(pCard->Interrupt, SerialGetCommStatus, &S);
                
            IoReleaseCancelSpinLock(OldIrql);

            break;
        }

        
	case IOCTL_SERIAL_GET_PROPERTIES: 
		{
            SerialDump( SERDIAG3, ("SERIAL: GET_PROPERTIES\n"));
            
			if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_COMMPROP))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // No synchronization is required since this information
            // is "static".
            //

            SerialGetProperties(pPort, Irp->AssociatedIrp.SystemBuffer);

            Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            break;
        }

        
	case IOCTL_SERIAL_XOFF_COUNTER: 
		{
			/*
            PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

            SerialDump( SERDIAG3, ("SERIAL: XOFF_COUNTER\n"));
            
			if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_XOFF_COUNTER)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if (Xc->Counter <= 0) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // So far so good.  Put the irp onto the write queue.
            //

            return SerialStartOrQueue(	pPort, Irp, &pPort->WriteQueue, 
										&pPort->CurrentWriteIrp, SerialStartWrite);

			*/

			Status = STATUS_NOT_IMPLEMENTED;
			break;
        }

        
	case IOCTL_SERIAL_LSRMST_INSERT: 
		{
            PUCHAR escapeChar = Irp->AssociatedIrp.SystemBuffer;

            //
            // Make sure we get a byte.
            //

            SerialDump( SERDIAG3, ("SERIAL: LSRMST_INSERT\n"));
            
			if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
               

            if (*escapeChar) 
			{
                //
                // We've got some escape work to do.  We will make sure that
                // the character is not the same as the Xon or Xoff character,
                // or that we are already doing error replacement.
                //

                if ((*escapeChar == pPort->SpecialChars.XoffChar) 
					|| (*escapeChar == pPort->SpecialChars.XonChar) 
					|| (pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)) 
				{
                    Status = STATUS_INVALID_PARAMETER;

                    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
                        
                    break;
                }
            }

            KeSynchronizeExecution(pCard->Interrupt, SerialSetEscapeChar, Irp);
                

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

        
	case IOCTL_SERIAL_GET_STATS: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
			Irp->IoStatus.Status = STATUS_SUCCESS;

			KeSynchronizeExecution(pCard->Interrupt, SerialGetStats, Irp);
			break;
		}

    case IOCTL_SERIAL_CLEAR_STATS: 
		{
			KeSynchronizeExecution(pCard->Interrupt, SerialClearStats, pPort);
			break;
		}


    default: 
		{

			Status = STATUS_INVALID_PARAMETER;
			break;
		}
    }

DoneWithIoctl:;

    Irp->IoStatus.Status = Status;
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;
}                         


VOID
SerialGetProperties(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_COMMPROP Properties)
/*++

Routine Description:

    This function returns the capabilities of this particular
    serial device.

Arguments:

    pPort - The serial device extension.

    Properties - The structure used to return the properties

Return Value:

    None.

--*/
{

	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	SerialDump( SERDIAG1,( "IO8+: SerialGetProperties for %x, Channel %d.\n",
				pCard->Controller, pPort->ChannelNumber ) );

    RtlZeroMemory(Properties, sizeof(SERIAL_COMMPROP));
        
    Properties->PacketLength		= sizeof(SERIAL_COMMPROP);
    Properties->PacketVersion		= 2;
    Properties->ServiceMask			= SERIAL_SP_SERIALCOMM;
    Properties->MaxTxQueue			= 0;
    Properties->MaxRxQueue			= 0;

    Properties->MaxBaud				= SERIAL_BAUD_USER;
    Properties->SettableBaud		= pPort->SupportedBauds;

    Properties->ProvSubType			= SERIAL_SP_RS232;

    Properties->ProvCapabilities	= SERIAL_PCF_DTRDSR 
									| SERIAL_PCF_RTSCTS 
									| SERIAL_PCF_CD     
									| SERIAL_PCF_PARITY_CHECK 
									| SERIAL_PCF_XONXOFF 
									| SERIAL_PCF_SETXCHAR 
									| SERIAL_PCF_TOTALTIMEOUTS
									| SERIAL_PCF_INTTIMEOUTS;

    Properties->SettableParams		= SERIAL_SP_PARITY 
									| SERIAL_SP_BAUD 
									| SERIAL_SP_DATABITS
									| SERIAL_SP_STOPBITS 
									| SERIAL_SP_HANDSHAKING 
									| SERIAL_SP_PARITY_CHECK 
									| SERIAL_SP_CARRIER_DETECT;


    Properties->SettableData		= SERIAL_DATABITS_5 
									| SERIAL_DATABITS_6 
									| SERIAL_DATABITS_7 
									| SERIAL_DATABITS_8;

    Properties->SettableStopParity	= SERIAL_STOPBITS_10 
									| SERIAL_STOPBITS_15 
									| SERIAL_STOPBITS_20 
									| SERIAL_PARITY_NONE 
									| SERIAL_PARITY_ODD  
									| SERIAL_PARITY_EVEN 
									| SERIAL_PARITY_MARK 
									| SERIAL_PARITY_SPACE;

    Properties->CurrentTxQueue = 0;
    Properties->CurrentRxQueue = pPort->BufferSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\io8_powr.c ===
#include "precomp.h"

// Paging 
#pragma alloc_text (PAGE, XXX_CardPowerDown)
#pragma alloc_text (PAGE, XXX_CardPowerUp)
#pragma alloc_text (PAGE, XXX_PortQueryPowerDown)
#pragma alloc_text (PAGE, XXX_PortPowerDown)
#pragma alloc_text (PAGE, XXX_PortPowerUp)
// End paging

////////////////////////////////////////////////////////////////////////
// XXX_CardPowerDown - Restores the state of the hardware & starts card.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	Io8_SwitchCardInterrupt(pCard);		// Stop Card from interrupting

	return status;
}


//////////////////////////////////////////////////////////////////////
// XXX_CardPowerUp - Saves the state of the hardware & stops card. 
//////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	Io8_ResetBoard(pCard);	// Reset card and allow it to interrupt again.

	return status;
}



////////////////////////////////////////////////////////////////////////
// XXX_PortPowerDown - Decides whether it is safe to power down a port.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;


	return status;
}


////////////////////////////////////////////////////////////////////////
// XXX_PortPowerDown - Restores the state of the hardware & starts port.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	if(pPort->DeviceIsOpen)			// Is the port open? 
	{
		// Save the current modem signals... 
		pPort->SavedModemControl = Io8_GetModemControl(pPort);
	}


	return status;
}

//////////////////////////////////////////////////////////////////////
// XXX_PortPowerUp - Saves the state of the hardware & stops port. 
//////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	if(pPort->DeviceIsOpen)			// Was port open before? 
	{
		Io8_EnableAllInterrupts(pPort);	// Yes, re-open 
		
		Io8_ResetChannel(pPort);

		if(pPort->SavedModemControl & SERIAL_MCR_DTR)	// DTR active? 
			Io8_SetDTR(pPort);		// Yes 
		else
			Io8_ClearDTR(pPort);	// No 
	}
	else
	{
		Io8_ResetChannel(pPort);		
		Io8_ClearDTR(pPort);
	}


	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\openclos.c ===
#include "precomp.h"			
/***************************************************************************\
*                                                                           *
*     OPENCLOS.C    -   IO8+ Intelligent I/O Board driver                   *
*                                                                           *
*     Copyright (c) 1992-1993 Ring Zero Systems, Inc.                       *
*     All Rights Reserved.                                                  *
*                                                                           *
\***************************************************************************/

/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module contains the code that is very specific to
    opening, closing, and cleaning up in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


BOOLEAN
SerialMarkOpen(
    IN PVOID Context
    );

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    );

BOOLEAN SerialCheckOpen(
    IN PVOID Context );

typedef struct _SERIAL_CHECK_OPEN {
    PPORT_DEVICE_EXTENSION pPort;
    NTSTATUS *StatusOfOpen;
    } SERIAL_CHECK_OPEN,*PSERIAL_CHECK_OPEN;

//
// Just a bogus little routine to make sure that we
// can synch with the ISR.
//
BOOLEAN
SerialNullSynch(
    IN PVOID Context
    ) {

    UNREFERENCED_PARAMETER(Context);
    return FALSE;
}

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We connect up to the interrupt for the create/open and initialize
    the structures needed to maintain an open for a device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
    SERIAL_CHECK_OPEN checkOpen;

    NTSTATUS localStatus;

	NTSTATUS status;   //john added for making compiler happy

    SerialDump(SERDIAG3, ("SERIAL: In SerialCreateOpen\n") );
   
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

	if(DeviceObject->DeviceType != FILE_DEVICE_SERIAL_PORT)	
	{
	    Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

		return(STATUS_NO_SUCH_DEVICE);
	}

    //
    // Before we do anything, let's make sure they aren't trying
    // to create a directory.  This is a silly, but what's a driver to do!?
    //
    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options & FILE_DIRECTORY_FILE)
	{
        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NOT_A_DIRECTORY;
    }

  	if(pPort->DeviceIsOpen)					// Is port already open? 
	{
		status = STATUS_ACCESS_DENIED;		// Yes, deny access 
		Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);
		IoCompleteRequest(Irp,IO_NO_INCREMENT);
		return(status);
	}


	ASSERT(pPort->DeviceIsOpen == FALSE);
	

	//
    // Create a buffer for the RX data when no reads are outstanding.
    //

    pPort->InterruptReadBuffer = NULL;
    pPort->BufferSize = 0;

    switch (MmQuerySystemSize()) 
	{

	case MmLargeSystem: 
		{
            pPort->BufferSize = 4096;
            pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);

            if(pPort->InterruptReadBuffer) 
			{
                break;
            }

        }

	case MmMediumSystem: 
		{
            pPort->BufferSize = 1024;
            pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);

            if(pPort->InterruptReadBuffer) 
			{
                break;
            }

        }

	case MmSmallSystem: 
		{
            pPort->BufferSize = 128;
            pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
        }
    }

    if(!pPort->InterruptReadBuffer) 
	{		
        pPort->BufferSize = 0;
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

	// Clear out the statistics.
    //
    KeSynchronizeExecution(pCard->Interrupt, SpxClearAllPortStats, pPort);
       

    //
    // On a new open we "flush" the read queue by initializing the
    // count of characters.
    //

    pPort->CharsInInterruptBuffer = 0;
    pPort->LastCharSlot = pPort->InterruptReadBuffer + (pPort->BufferSize - 1);
                              

    pPort->ReadBufferBase = pPort->InterruptReadBuffer;
    pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
    pPort->FirstReadableChar = pPort->InterruptReadBuffer;

    pPort->TotalCharsQueued = 0;

    //
    // We set up the default xon/xoff limits.
    //

    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));
                                   

    pPort->IrpMaskLocation = NULL;
    pPort->HistoryMask = 0;
    pPort->IsrWaitMask = 0;

    pPort->SendXonChar = FALSE;
    pPort->SendXoffChar = FALSE;

    //
    // The escape char replacement must be reset upon every open.
    //

    pPort->EscapeChar = 0;


/* ------------------------------------------- VIV  7/21/1993 10:30  begin */
// VIV - Check for MCA

#if 0   // VIV

#if !defined(SERIAL_CRAZY_INTERRUPTS)

    if (!pPort->InterruptShareable) {

        checkOpen.pPort = pPort;
        checkOpen.StatusOfOpen = &Irp->IoStatus.Status;

        KeSynchronizeExecution(
            pCard->Interrupt,
            SerialCheckOpen,
            &checkOpen
            );

    } else {

        KeSynchronizeExecution(
            pCard->Interrupt,
            SerialMarkOpen,
            pPort
            );

        Irp->IoStatus.Status = STATUS_SUCCESS;

    }
#else

    //
    // Synchronize with the ISR and let it know that the device
    // has been successfully opened.
    //

    KeSynchronizeExecution(
        pCard->Interrupt,
        SerialMarkOpen,
        pPort
        );

    Irp->IoStatus.Status = STATUS_SUCCESS;
#endif

#endif  // VIV


    checkOpen.pPort = pPort;
    checkOpen.StatusOfOpen = &Irp->IoStatus.Status;

    KeSynchronizeExecution(pCard->Interrupt,SerialCheckOpen,&checkOpen);
        
/* ------------------------------------------- VIV  7/21/1993 10:30  end   */

    localStatus = Irp->IoStatus.Status;
    Irp->IoStatus.Information = 0L;
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return localStatus;
}

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We simpley disconnect the interrupt for now.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    //
    // This "timer value" is used to wait 10 character times
    // after the hardware is empty before we actually "run down"
    // all of the flow control/break junk.
    //
    LARGE_INTEGER tenCharDelay;

    //
    // Holds a character time.
    //
    LARGE_INTEGER charTime;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    SerialDump(SERDIAG3,("SERIAL: In SerialClose\n"));

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    charTime = RtlLargeIntegerNegate(SerialGetCharTime(pPort));

    //
    // Synchronize with the ISR to let it know that interrupts are
    // no longer important.
    //

    KeSynchronizeExecution(
        pCard->Interrupt,
        SerialMarkClose,
        pPort
        );

    //
    // Synchronize with the isr to turn off break if it
    // is already on.
    //

#if 0   //VIVTEMP
    KeSynchronizeExecution(
        pCard->Interrupt,
        SerialTurnOffBreak,
        pPort
        );
#endif
    //
    // If the driver has automatically transmitted an Xoff in
    // the context of automatic receive flow control then we
    // should transmit an Xon.
    //

    if (pPort->RXHolding & SERIAL_RX_XOFF)
    {
        //
        // Loop until the holding register is empty.
        //


        Io8_SendXon(pPort);

#if 0   //VIVTEMP
        while (!(READ_LINE_STATUS(pPort->Controller) &
                 SERIAL_LSR_THRE))
        {

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &charTime
                );
        }

        WRITE_TRANSMIT_HOLDING(
            pPort->Controller,
            pPort->SpecialChars.XonChar
            );
#endif
    }

    //
    // Wait until all characters have been emptied out of the hardware.
    //

#if 0   //VIVTEMP
    while ((READ_LINE_STATUS(pPort->Controller) &
            (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) !=
            (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) {

        KeDelayExecutionThread(
            KernelMode,
            FALSE,
            &charTime
            );
    }
#endif

    //
    // The hardware is empty.  Delay 10 character times before
    // shut down all the flow control.
    //

    tenCharDelay = RtlExtendedIntegerMultiply(
                       charTime,
                       10
                       );

    KeDelayExecutionThread(
        KernelMode,
        TRUE,
        &tenCharDelay
        );

    SerialClrDTR(pPort);

    //
    // We have to be very careful how we clear the RTS line.
    // Transmit toggling might have been on at some point.
    //
    // We know that there is nothing left that could start
    // out the "polling"  execution path.  We need to
    // check the counter that indicates that the execution
    // path is active.  If it is then we loop delaying one
    // character time.  After each delay we check to see if
    // the counter has gone to zero.  When it has we know that
    // the execution path should be just about finished.  We
    // make sure that we still aren't in the routine that
    // synchronized execution with the ISR by synchronizing
    // ourselve with the ISR.
    //
#if 0   //VIVTEMP
    if (pPort->CountOfTryingToLowerRTS) {

        do {

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &charTime
                );

        } while (pPort->CountOfTryingToLowerRTS);

        KeSynchronizeExecution(
            pCard->Interrupt,
            SerialNullSynch,
            NULL
            );

        //
        // The execution path should no longer exist that
        // is trying to push down the RTS.  Well just
        // make sure it's down by falling through to
        // code that forces it down.
        //

    }
#endif

    SerialClrRTS(pPort);

    //
    // Clean out the holding reasons (since we are closed).
    //

    pPort->RXHolding = 0;
    pPort->TXHolding = 0;

    //
    // All is done.  The port has been disabled from interrupting
    // so there is no point in keeping the memory around.
    //

    pPort->BufferSize = 0;
    SpxFreeMem(pPort->InterruptReadBuffer);
    pPort->InterruptReadBuffer = NULL;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

BOOLEAN SerialCheckOpen(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine will traverse the circular doubly linked list
    of devices that are using the same interrupt object.  It will look
    for other devices that are open.  If it doesn't find any
    it will indicate that it is ok to open this device.

    If it finds another device open we have two cases:

        1) The device we are trying to open is on a multiport card.

           If the already open device is part of a multiport device
           this code will indicate it is ok to open.  We do this on the
           theory that the multiport devices are daisy chained
           and the cards can correctly arbitrate the interrupt
           line.  Note this assumption could be wrong.  Somebody
           could put two non-daisychained multiports on the
           same interrupt.  However, only a total clod would do
           such a thing, and in my opinion deserves everthing they
           get.

        2) The device we are trying to open is not on a multiport card.

            We indicate that it is not ok to open.

Arguments:

    Context - This is a structure that contains a pointer to the
              extension of the device we are trying to open, and
              a pointer to an NTSTATUS that will indicate whether
              the device was opened or not.

Return Value:

    This routine always returns FALSE.

--*/

{
  PPORT_DEVICE_EXTENSION extensionToOpen =
      ((PSERIAL_CHECK_OPEN)Context)->pPort;
  NTSTATUS *status = ((PSERIAL_CHECK_OPEN)Context)->StatusOfOpen;

  *status = STATUS_SUCCESS;
  SerialMarkOpen(extensionToOpen);
  return FALSE;

#if 0 // VIV

  PLIST_ENTRY firstEntry = &extensionToOpen->CommonInterruptObject;
  PLIST_ENTRY currentEntry = firstEntry;
  PPORT_DEVICE_EXTENSION currentExtension;

  do
  {
    currentExtension = CONTAINING_RECORD(
                           currentEntry,
                           PORT_DEVICE_EXTENSION,
                           CommonInterruptObject
                           );

    if (currentExtension->DeviceIsOpened)
    {
      break;
    }

    currentEntry = currentExtension->CommonInterruptObject.Flink;

  } while (currentEntry != firstEntry);

  if (currentEntry == firstEntry)
  {
    //
    // We searched the whole list and found no other opens
    // mark the status as successful and call the regular
    // opening routine.
    //

    *status = STATUS_SUCCESS;
    SerialMarkOpen(extensionToOpen);
  }
  else
  {
    if (!extensionToOpen->PortOnAMultiportCard)
    {
      *status = STATUS_SHARED_IRQ_BUSY;

    }
    else
    {
      if (!currentExtension->PortOnAMultiportCard)
      {
          *status = STATUS_SHARED_IRQ_BUSY;
      }
      else
      {
        *status = STATUS_SUCCESS;
        SerialMarkOpen(extensionToOpen);
      }
    }
  }
  return FALSE;
#endif  // VIV
}

BOOLEAN
SerialMarkOpen(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine merely sets a boolean to true to mark the fact that
    somebody opened the device and its worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

// --------------------------------------------------- VIV  7/16/1993 begin
//    SerialReset(pPort);

    // Configure Channel.
    Io8_ResetChannel(pPort);

    // Enable interrupts.
    Io8_EnableAllInterrupts(pPort);
// --------------------------------------------------- VIV  7/16/1993 end

    //
    // Prepare for the opening by re-enabling interrupts.
    //
    // We do this my raising the OUT2 line in the modem control.
    // In PC's this bit is "anded" with the interrupt line.
    //

#if 0   //VIVTEMP
    WRITE_MODEM_CONTROL(
        pPort->Controller,
        (UCHAR)(READ_MODEM_CONTROL(pPort->Controller) | SERIAL_MCR_OUT2)
        );
#endif  //VIV


    pPort->DeviceIsOpen = TRUE;
    pPort->ErrorWord = 0;

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
	pPort->WmiCommData.IsBusy = TRUE;
#endif

    return FALSE;

}

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine merely sets a boolean to false to mark the fact that
    somebody closed the device and it's no longer worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // Prepare for the closing by stopping interrupts.
    //
    // We do this my lowering  the OUT2 line in the modem control.
    // In PC's this bit is "anded" with the interrupt line.
    //

//---------------------------------------------------- VIV  7/26/1993 begin 
#if 0   //VIV
    WRITE_MODEM_CONTROL(
        pPort->Controller,
        (UCHAR)(READ_MODEM_CONTROL(pPort->Controller) & ~SERIAL_MCR_OUT2)
        );
#endif

    Io8_DisableAllInterrupts(pPort);
//---------------------------------------------------- VIV  7/26/1993 end   

    pPort->DeviceIsOpen			= FALSE;

#ifdef WMI_SUPPORT
	pPort->WmiCommData.IsBusy	= FALSE;
#endif

    return FALSE;

}

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is used to kill all longstanding IO operations.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    KIRQL oldIrql;

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    //
    // First kill all the reads and writes.
    //
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);
        

    //
    // Now get rid a pending wait mask irp.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CurrentWaitIrp) 
	{
        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = pPort->CurrentWaitIrp->CancelRoutine;
        pPort->CurrentWaitIrp->Cancel = TRUE;

        if(cancelRoutine) 
		{
            pPort->CurrentWaitIrp->CancelIrql = oldIrql;
            pPort->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(DeviceObject, pPort->CurrentWaitIrp);
        }
    } 
	else 
	{
        IoReleaseCancelSpinLock(oldIrql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
        
    return STATUS_SUCCESS;

}

LARGE_INTEGER
SerialGetCharTime(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This function will return the number of 100 nanosecond intervals
    there are in one character time (based on the present form
    of flow control.

Arguments:

    pPort - Just what it says.

Return Value:

    100 nanosecond intervals in a character time.

--*/

{

    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;


    if((pPort->LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA) 
	{
        dataSize = 5;
    } 
	else if((pPort->LineControl & SERIAL_DATA_MASK) == SERIAL_6_DATA) 
	{
        dataSize = 6;
    } 
	else if((pPort->LineControl & SERIAL_DATA_MASK) == SERIAL_7_DATA) 
	{
        dataSize = 7;
    } 
	else if((pPort->LineControl & SERIAL_DATA_MASK) == SERIAL_8_DATA) 
	{
        dataSize = 8;
    }

    paritySize = 1;

    if((pPort->LineControl & SERIAL_PARITY_MASK) == SERIAL_NONE_PARITY) 
	{
        paritySize = 0;
    }

    
	if (pPort->LineControl & SERIAL_2_STOP) 
	{
        // Even if it is 1.5, for sanities sake were going to say 2.
        stopSize = 2;
    } 
	else 
	{
        stopSize = 1;
    }

    //
    // First we calculate the number of 100 nanosecond intervals
    // are in a single bit time (Approximately).
    //

    bitTime = (10000000+(pPort->CurrentBaud-1))/pPort->CurrentBaud;
    charTime = bitTime + ((dataSize+paritySize+stopSize)*bitTime);

    return RtlConvertUlongToLargeInteger(charTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\modmflow.c ===
#include "precomp.h"			
/***************************************************************************\
*                                                                           *
*     MODMFLOW.C    -   IO8+ Intelligent I/O Board driver                   *
*                                                                           *
*     Copyright (c) 1992-1993 Ring Zero Systems, Inc.                       *
*     All Rights Reserved.                                                  *
*                                                                           *
\***************************************************************************/

/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    modmflow.c

Abstract:

    This module contains *MOST* of the code used to manipulate
    the modem control and status registers.  The vast majority
    of the remainder of flow control is concentrated in the
    Interrupt service routine.  A very small amount resides
    in the read code that pull characters out of the interrupt
    buffer.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

BOOLEAN
SerialDecrementRTSCounter(
    IN PVOID Context
    );


BOOLEAN
SerialSetDTR(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    Io8_SetDTR(Context);
    return FALSE;

#if 0   //VIV
    PPORT_DEVICE_EXTENSION pPort = Context;
    UCHAR ModemControl;

    ModemControl = READ_MODEM_CONTROL(pCard->Controller);

    ModemControl |= SERIAL_MCR_DTR;

    SerialDump(
        SERFLOW,
        ("SERIAL: Setting DTR for %x\n",
         pCard->Controller)
        );
    WRITE_MODEM_CONTROL(
        pCard->Controller,
        ModemControl
        );

    return FALSE;
#endif
}

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    Io8_ClearDTR(Context);
    return FALSE;

#if 0   //VIV
    PPORT_DEVICE_EXTENSION pPort = Context;

    UCHAR ModemControl;

    ModemControl = READ_MODEM_CONTROL(pCard->Controller);

    ModemControl &= ~SERIAL_MCR_DTR;

    SerialDump(
        SERFLOW,
        ("SERIAL: Clearing DTR for %x\n",
         pCard->Controller)
        );
    WRITE_MODEM_CONTROL(
        pCard->Controller,
        ModemControl
        );

    return FALSE;
#endif
}

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    SerialDump(SERFLOW,("SERIAL: Setting Rts\n",0));
    Io8_SetDTR(Context);
    return FALSE;

#if 0   //VIV
    PPORT_DEVICE_EXTENSION pPort = Context;
    UCHAR ModemControl;

    ModemControl = READ_MODEM_CONTROL(pCard->Controller);

    ModemControl |= SERIAL_MCR_RTS;

    SerialDump(
        SERFLOW,
        ("SERIAL: Setting Rts for %x\n",
         pCard->Controller)
        );
    WRITE_MODEM_CONTROL(
        pCard->Controller,
        ModemControl
        );

    return FALSE;
#endif
}

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    SerialDump(SERFLOW,("SERIAL: Clearing Rts\n",0));
    Io8_ClearDTR(Context);
    return FALSE;

#if 0   //VIV
    PPORT_DEVICE_EXTENSION pPort = Context;
    UCHAR ModemControl;

    ModemControl = READ_MODEM_CONTROL(pCard->Controller);

    ModemControl &= ~SERIAL_MCR_RTS;

    SerialDump(
        SERFLOW,
        ("SERIAL: Clearing Rts for %x\n",
         pCard->Controller)
        );
    WRITE_MODEM_CONTROL(
        pCard->Controller,
        ModemControl
        );

    return FALSE;
#endif
}

BOOLEAN
SerialSetupNewHandFlow(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_HANDFLOW NewHandFlow
    )

/*++

Routine Description:

    This routine adjusts the flow control based on new
    control flow.

Arguments:

    pPort - A pointer to the serial device extension.

    NewHandFlow - A pointer to a serial handflow structure
                  that is to become the new setup for flow
                  control.

Return Value:

    This routine always returns FALSE.

--*/

//VIV - Io8p
{
  SERIAL_HANDFLOW New = *NewHandFlow;
  PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

  //
  // If the pPort->DeviceIsOpen is FALSE that means
  // we are entering this routine in response to an open request.
  // If that is so, then we always proceed with the work regardless
  // of whether things have changed.
  //

  //
  // First we take care of the DTR flow control.  We only
  // do work if something has changed.
  //


#if 0   //VIVTEMP

  if ((!pPort->DeviceIsOpen) ||
      ((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) !=
       (New.ControlHandShake & SERIAL_DTR_MASK)))
  {
    SerialDump(
        SERFLOW,
        ("SERIAL: Processing DTR flow for %x\n",
         pCard->Controller)
        );

    if (New.ControlHandShake & SERIAL_DTR_MASK)
    {
      //
      // Well we might want to set DTR.
      //
      // Before we do, we need to check whether we are doing
      // dtr flow control.  If we are then we need to check
      // if then number of characters in the interrupt buffer
      // exceeds the XoffLimit.  If it does then we don't
      // enable DTR AND we set the RXHolding to record that
      // we are holding because of the dtr.
      //

      if ((New.ControlHandShake & SERIAL_DTR_MASK)
          == SERIAL_DTR_HANDSHAKE)
      {
        if ((pPort->BufferSize - New.XoffLimit) >
            pPort->CharsInInterruptBuffer)
        {
          //
          // However if we are already holding we don't want
          // to turn it back on unless we exceed the Xon
          // limit.
          //
          if (pPort->RXHolding & SERIAL_RX_DTR)
          {
            //
            // We can assume that its DTR line is already low.
            //
            if (pPort->CharsInInterruptBuffer >
                (ULONG)New.XonLimit)
            {
              SerialDump(
                  SERFLOW,
                  ("SERIAL: Removing DTR block on reception for %x\n",
                   pCard->Controller)
                  );
              pPort->RXHolding &= ~SERIAL_RX_DTR;
              SerialSetDTR(pPort);
            }
          }
          else
          {
            SerialSetDTR(pPort);
          }
        }
        else
        {

          SerialDump(
              SERFLOW,
              ("SERIAL: Setting DTR block on reception for %x\n",
               pCard->Controller)
              );
          pPort->RXHolding |= SERIAL_RX_DTR;
          SerialClrDTR(pPort);

        }
      }
      else
      {
        //
        // Note that if we aren't currently doing dtr flow control then
        // we MIGHT have been.  So even if we aren't currently doing
        // DTR flow control, we should still check if RX is holding
        // because of DTR.  If it is, then we should clear the holding
        // of this bit.
        //

        if (pPort->RXHolding & SERIAL_RX_DTR)
        {
            SerialDump(
                SERFLOW,
                ("SERIAL: Removing dtr block of reception for %x\n",
                pCard->Controller)
                );
            pPort->RXHolding &= ~SERIAL_RX_DTR;
        }
        SerialSetDTR(pPort);
      }
    }
    else
    {
      //
      // The end result here will be that DTR is cleared.
      //
      // We first need to check whether reception is being held
      // up because of previous DTR flow control.  If it is then
      // we should clear that reason in the RXHolding mask.
      //

      if (pPort->RXHolding & SERIAL_RX_DTR)
      {
        SerialDump(
            SERFLOW,
            ("SERIAL: removing dtr block of reception for %x\n",
            pCard->Controller)
            );
        pPort->RXHolding &= ~SERIAL_RX_DTR;
      }
      SerialClrDTR(pPort);
    }
  }
#endif

  //
  // Time to take care of the RTS Flow control.
  //
  // First we only do work if something has changed.
  //

  if ((!pPort->DeviceIsOpen) ||
      ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) !=
       (New.FlowReplace & SERIAL_RTS_MASK))) {

      SerialDump(
          SERFLOW,
          ("SERIAL: Processing RTS flow\n",
           pCard->Controller)
          );

      if ((New.FlowReplace & SERIAL_RTS_MASK) ==
          SERIAL_RTS_HANDSHAKE) {

          //
          // Well we might want to set RTS.
          //
          // Before we do, we need to check whether we are doing
          // rts flow control.  If we are then we need to check
          // if then number of characters in the interrupt buffer
          // exceeds the XoffLimit.  If it does then we don't
          // enable RTS AND we set the RXHolding to record that
          // we are holding because of the rts.
          //

          if ((pPort->BufferSize - New.XoffLimit) >
              pPort->CharsInInterruptBuffer) {

              //
              // However if we are already holding we don't want
              // to turn it back on unless we exceed the Xon
              // limit.
              //

              if (pPort->RXHolding & SERIAL_RX_RTS) {

                  //
                  // We can assume that its RTS line is already low.
                  //

                  if (pPort->CharsInInterruptBuffer >
                      (ULONG)New.XonLimit) {

                     SerialDump(
                         SERFLOW,
                         ("SERIAL: Removing rts block of reception for %x\n",
                         pCard->Controller)
                         );
                      pPort->RXHolding &= ~SERIAL_RX_RTS;
                      SerialSetRTS(pPort);

                  }

              } else {

                  SerialSetRTS(pPort);

              }

          } else {

              SerialDump(
                  SERFLOW,
                  ("SERIAL: Setting rts block of reception for %x\n",
                  pCard->Controller)
                  );
              pPort->RXHolding |= SERIAL_RX_RTS;
              SerialClrRTS(pPort);

          }

      } else if ((New.FlowReplace & SERIAL_RTS_MASK) ==
                 SERIAL_RTS_CONTROL ||
                 (New.FlowReplace & SERIAL_RTS_MASK) ==
                 SERIAL_TRANSMIT_TOGGLE) {

          //
          // Note that if we aren't currently doing rts flow control then
          // we MIGHT have been.  So even if we aren't currently doing
          // RTS flow control, we should still check if RX is holding
          // because of RTS.  If it is, then we should clear the holding
          // of this bit.
          //

          if (pPort->RXHolding & SERIAL_RX_RTS) {

              SerialDump(
                  SERFLOW,
                  ("SERIAL: Clearing rts block of reception for %x\n",
                  pCard->Controller)
                  );
              pPort->RXHolding &= ~SERIAL_RX_RTS;

          }

          SerialSetRTS(pPort);
#if 0
      } else if ((New.FlowReplace & SERIAL_RTS_MASK) ==
                 SERIAL_TRANSMIT_TOGGLE) {

          //
          // We first need to check whether reception is being held
          // up because of previous RTS flow control.  If it is then
          // we should clear that reason in the RXHolding mask.
          //

          if (pPort->RXHolding & SERIAL_RX_RTS) {

              SerialDump(
                  SERFLOW,
                  ("SERIAL: TOGGLE Clearing rts block of reception for %x\n",
                  pCard->Controller)
                  );
              pPort->RXHolding &= ~SERIAL_RX_RTS;

          }

          //
          // We have to place the rts value into the pPort
          // now so that the code that tests whether the
          // rts line should be lowered will find that we
          // are "still" doing transmit toggling.  The code
          // for lowering can be invoked later by a timer so
          // it has to test whether it still needs to do its
          // work.
          //

          pPort->HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
          pPort->HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;

          //
          // The order of the tests is very important below.
          //
          // If there is a break then we should turn on the RTS.
          //
          // If there isn't a break but there are characters in
          // the hardware, then turn on the RTS.
          //
          // If there are writes pending that aren't being held
          // up, then turn on the RTS.
          //

          if ((pPort->TXHolding & SERIAL_TX_BREAK) ||
              ((SerialProcessLSR(pPort) & (SERIAL_LSR_THRE |
                                               SERIAL_LSR_TEMT)) !=
                                              (SERIAL_LSR_THRE |
                                               SERIAL_LSR_TEMT)) ||
              (pPort->CurrentWriteIrp || pPort->TransmitImmediate ||
               (!IsListEmpty(&pPort->WriteQueue)) &&
               (!pPort->TXHolding))) {

              SerialSetRTS(pPort);

          } else {

              //
              // This routine will check to see if it is time
              // to lower the RTS because of transmit toggle
              // being on.  If it is ok to lower it, it will,
              // if it isn't ok, it will schedule things so
              // that it will get lowered later.
              //

              pPort->CountOfTryingToLowerRTS++;
              SerialPerhapsLowerRTS(pPort);

          }
#endif

      } else {

          //
          // The end result here will be that RTS is cleared.
          //
          // We first need to check whether reception is being held
          // up because of previous RTS flow control.  If it is then
          // we should clear that reason in the RXHolding mask.
          //

          if (pPort->RXHolding & SERIAL_RX_RTS) {

              SerialDump(
                  SERFLOW,
                  ("SERIAL: Clearing rts block of reception for %x\n",
                  pCard->Controller)
                  );
              pPort->RXHolding &= ~SERIAL_RX_RTS;

          }

          SerialClrRTS(pPort);

      }

  }

  //
  // We now take care of automatic receive flow control.
  // We only do work if things have changed.
  //

  if ((!pPort->DeviceIsOpen) ||
      ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
       (New.FlowReplace & SERIAL_AUTO_RECEIVE))) {

      if (New.FlowReplace & SERIAL_AUTO_RECEIVE) {

          //
          // We wouldn't be here if it had been on before.
          //
          // We should check to see whether we exceed the turn
          // off limits.
          //
          // Note that since we are following the OS/2 flow
          // control rules we will never send an xon if
          // when enabling xon/xoff flow control we discover that
          // we could receive characters but we are held up do
          // to a previous Xoff.
          //

          if ((pPort->BufferSize - New.XoffLimit) <=
              pPort->CharsInInterruptBuffer) {

              //
              // Cause the Xoff to be sent.
              //

              pPort->RXHolding |= SERIAL_RX_XOFF;

              SerialProdXonXoff(
                  pPort,
                  FALSE
                  );

          }

      } else {

          //
          // The app has disabled automatic receive flow control.
          //
          // If transmission was being held up because of
          // an automatic receive Xoff, then we should
          // cause an Xon to be sent.
          //

          if (pPort->RXHolding & SERIAL_RX_XOFF) {

              pPort->RXHolding &= ~SERIAL_RX_XOFF;

              //
              // Cause the Xon to be sent.
              //

              SerialProdXonXoff(
                  pPort,
                  TRUE
                  );

          }

      }

  }

  //
  // We now take care of automatic transmit flow control.
  // We only do work if things have changed.
  //

  if ((!pPort->DeviceIsOpen) ||
      ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) !=
       (New.FlowReplace & SERIAL_AUTO_TRANSMIT))) {

      if (New.FlowReplace & SERIAL_AUTO_TRANSMIT) {

          //
          // We wouldn't be here if it had been on before.
          //
          // BUG BUG ??? There is some belief that if autotransmit
          // was just enabled, I should go look in what we
          // already received, and if we find the xoff character
          // then we should stop transmitting.  I think this
          // is an application bug.  For now we just care about
          // what we see in the future.
          //

          ;

      } else {

          //
          // The app has disabled automatic transmit flow control.
          //
          // If transmission was being held up because of
          // an automatic transmit Xoff, then we should
          // cause an Xon to be sent.
          //

          if (pPort->TXHolding & SERIAL_TX_XOFF) {

              pPort->TXHolding &= ~SERIAL_TX_XOFF;

              SerialDump(SERDIAG1,("IO8+: SerialSetupNewHandFlow. TXHolding = %d\n",
                        pPort->TXHolding));


              //
              // Cause the Xon to be sent.
              //

              SerialProdXonXoff(
                  pPort,
                  TRUE
                  );

          }

      }

  }

  //
  // At this point we can simply make sure that entire
  // handflow structure in the extension is updated.
  //

  pPort->HandFlow = New;
  Io8_SetFlowControl(pPort);

  return FALSE;

}

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the handshake and control
    flow in the device extension.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a handflow
              structure..

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_IOCTL_SYNC S = Context;
    PPORT_DEVICE_EXTENSION pPort = S->pPort;
    PSERIAL_HANDFLOW HandFlow = S->Data;

    SerialSetupNewHandFlow(
        pPort,
        HandFlow
        );

    SerialHandleModemUpdate(
        pPort,
        FALSE
        );

    return FALSE;

}

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will turn on break in the hardware and
    record the fact the break is on, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

// VIV    UCHAR OldLineControl;

#if 0
    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialSetRTS(pPort);

    }
#endif

#if 0 // VIV
    OldLineControl = READ_LINE_CONTROL(pCard->Controller);

    OldLineControl |= SERIAL_LCR_BREAK;

    WRITE_LINE_CONTROL(
        pCard->Controller,
        OldLineControl
        );
#endif
//---------------------------------------------------- VIV  8/5/1993 begin 
    Io8_TurnOnBreak( pPort );
//---------------------------------------------------- VIV  8/5/1993 end   

    pPort->TXHolding |= SERIAL_TX_BREAK;

    return FALSE;

}

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will turn off break in the hardware and
    record the fact the break is off, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

// VIV    UCHAR OldLineControl;

    if (pPort->TXHolding & SERIAL_TX_BREAK) {

        //
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.

#if 0 // VIV
        OldLineControl = READ_LINE_CONTROL(pCard->Controller);

        OldLineControl &= ~SERIAL_LCR_BREAK;

        WRITE_LINE_CONTROL(
            pCard->Controller,
            OldLineControl
            );
#endif

//---------------------------------------------------- VIV  8/5/1993 begin 
        Io8_TurnOffBreak( pPort );
//---------------------------------------------------- VIV  8/5/1993 end   

        pPort->TXHolding &= ~SERIAL_TX_BREAK;

        if (!pPort->TXHolding &&
            (pPort->TransmitImmediate ||
             pPort->WriteLength) &&
             pPort->HoldingEmpty) {

//---------------------------------------------------- VIV  8/5/1993 begin 
//            DISABLE_ALL_INTERRUPTS(pCard->Controller);
//            ENABLE_ALL_INTERRUPTS(pCard->Controller);
              Io8_EnableTxInterrupts( pPort );
//---------------------------------------------------- VIV  8/5/1993 end   
#if 0
        } else {

            //
            // The following routine will lower the rts if we
            // are doing transmit toggleing and there is no
            // reason to keep it up.
            //

            pPort->CountOfTryingToLowerRTS++;
            SerialPerhapsLowerRTS(pPort);
#endif

        }

    }

    return FALSE;

}

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xoff was received.  Even if the
    driver does not have automatic Xoff/Xon flowcontrol - This
    still will stop the transmission.  This is the OS/2 behavior
    and is not well specified for Windows.  Therefore we adopt
    the OS/2 behavior.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TXHolding |= SERIAL_TX_XOFF;
    SerialDump(SERDIAG1,("IO8+: SerialPretendXoff. TXHolding = %d\n",
                          pPort->TXHolding));

#if 0
    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        KeInsertQueueDpc(
            &pPort->StartTimerLowerRTSDpc,
            NULL,
            NULL
            )?pPort->CountOfTryingToLowerRTS++:0;

    }
#endif

    return FALSE;

}

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xon was received.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/
//VIV - Io8
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->TXHolding) {

        //
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.


        if ( (pPort->TXHolding & SERIAL_TX_XOFF) &&
             ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) ||
              (pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT)) )
        {
          // Automatic Xon/Xoff transmit is enabled. Simulate Xoff received.
          Io8_Simulate_Xon(pPort);
        }

        pPort->TXHolding &= ~SERIAL_TX_XOFF;
        SerialDump(SERDIAG1,("IO8+: SerialPretendXon. TXHolding = %d\n",
                        pPort->TXHolding));

        if (!pPort->TXHolding &&
            (pPort->TransmitImmediate ||
             pPort->WriteLength) &&
             pPort->HoldingEmpty) {

//            DISABLE_ALL_INTERRUPTS(pCard->Controller);
//            ENABLE_ALL_INTERRUPTS(pCard->Controller);
              Io8_EnableTxInterrupts(pPort);
        }

    }

    return FALSE;

}

VOID
SerialHandleReducedIntBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is called to handle a reduction in the number
    of characters in the interrupt (typeahead) buffer.  It
    will check the current output flow control and re-enable transmission
    as needed.

    NOTE: This routine assumes that it is working at interrupt level.

Arguments:

    pPort - A pointer to the device extension.

Return Value:

    None.

--*/
// VIV - Io8
{
  PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

  //
  // If we are doing receive side flow control and we are
  // currently "holding" then because we've emptied out
  // some characters from the interrupt buffer we need to
  // see if we can "re-enable" reception.
  //

  if (pPort->RXHolding)
  {
    if (pPort->CharsInInterruptBuffer <=
        (ULONG)pPort->HandFlow.XonLimit)
    {
      //
      // VIV: We have not an Automatic Rx Hardware Flow Control.
      //

      if (pPort->RXHolding & SERIAL_RX_DTR)
      {
        pPort->RXHolding &= ~SERIAL_RX_DTR;
        SerialDump( SERDIAG1,( "IO8+: SerialHandleReducedIntBuffer() RX_DTR for %x, Channel %d. "
            "RXHolding = %d, TXHolding = %d\n",
            pCard->Controller, pPort->ChannelNumber,
            pPort->RXHolding, pPort->TXHolding ) );

        Io8_EnableRxInterrupts( pPort );
//        SerialSetDTR(pPort);
      }

      if (pPort->RXHolding & SERIAL_RX_RTS)
      {
        pPort->RXHolding &= ~SERIAL_RX_RTS;
        SerialDump( SERDIAG1,( "IO8+: SerialHandleReducedIntBuffer() RX_RTS for %x, Channel %d. "
            "RXHolding = %d, TXHolding = %d\n",
            pCard->Controller, pPort->ChannelNumber,
            pPort->RXHolding, pPort->TXHolding ) );
        Io8_EnableRxInterrupts( pPort );
//        SerialSetRTS(pPort);
      }

      if (pPort->RXHolding & SERIAL_RX_XOFF)
      {
        //
        // Prod the transmit code to send xon.
        //
        SerialProdXonXoff(
            pPort,
            TRUE
            );
        SerialDump( SERDIAG1,( "IO8+: SerialHandleReducedIntBuffer() RX_XOFF for %x, Channel %d. "
            "RXHolding = %d, TXHolding = %d\n",
            pCard->Controller, pPort->ChannelNumber,
            pPort->RXHolding, pPort->TXHolding ) );
      }
//---------------------------------------------------- VIV  8/2/1993 begin 

      //
      // Special case for Io8 if Rx queue was full.
      //
      if (pPort->RXHolding & SERIAL_RX_FULL)
      {
        pPort->RXHolding &= ~SERIAL_RX_FULL;
        Io8_EnableRxInterrupts( pPort );

        SerialDump( SERDIAG1,( "IO8+: SerialHandleReducedIntBuffer() RX_FULL for %x, Channel %d. "
            "RXHolding = %d, TXHolding = %d\n",
            pCard->Controller, pPort->ChannelNumber,
            pPort->RXHolding, pPort->TXHolding ) );
      }
//---------------------------------------------------- VIV  8/2/1993 end   
    }
  }
}

VOID
SerialProdXonXoff(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN BOOLEAN SendXon
    )

/*++

Routine Description:

    This routine will set up the SendXxxxChar variables if
    necessary and determine if we are going to be interrupting
    because of current transmission state.  It will cause an
    interrupt to occur if neccessary, to send the xon/xoff char.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    pPort - A pointer to the serial device extension.

    SendXon - If a character is to be send, this indicates whether
              it should be an Xon or an Xoff.

Return Value:

    None.

--*/
//VIV - Io8p
{
  //
  // We assume that if the prodding is called more than
  // once that the last prod has set things up appropriately.
  //
  // We could get called before the character is sent out
  // because the send of the character was blocked because
  // of hardware flow control (or break).
  //


//  if (SendXon)
//    Io8_SendXon( pPort );
//  else
//    Io8_SendXoff( pPort );
//  return;

//#if 0 //VIV
  if (!pPort->SendXonChar && !pPort->SendXoffChar
      && pPort->HoldingEmpty)
  {
//    DISABLE_ALL_INTERRUPTS(pCard->Controller);
//    ENABLE_ALL_INTERRUPTS(pCard->Controller);
    Io8_EnableTxInterrupts( pPort );
  }

  if (SendXon)
  {
    pPort->SendXonChar = TRUE;
    pPort->SendXoffChar = FALSE;
  }
  else
  {
    pPort->SendXonChar = FALSE;
    pPort->SendXoffChar = TRUE;
  }

//#endif
}

ULONG
SerialHandleModemUpdate(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN BOOLEAN DoingTX
    )

/*++

Routine Description:

    This routine will be to check on the modem status, and
    handle any appropriate event notification as well as
    any flow control appropriate to modem status lines.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    pPort - A pointer to the serial device extension.

    DoingTX - This boolean is used to indicate that this call
              came from the transmit processing code.  If this
              is true then there is no need to cause a new interrupt
              since the code will be trying to send the next
              character as soon as this call finishes.

Return Value:

    This returns the old value of the modem status register
    (extended into a ULONG).

--*/
//VIV - Io8
{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;


    //
    // We keep this local so that after we are done
    // examining the modem status and we've updated
    // the transmission holding value, we know whether
    // we've changed from needing to hold up transmission
    // to transmission being able to proceed.
    //
//VIV    ULONG OldTXHolding = pPort->TXHolding;

    //
    // Holds the value in the mode status register.
    //
    UCHAR ModemStatus;

/* ------------------------------------------- VIV  7/21/1993 16:40  begin */
//VIV    ModemStatus =
//        READ_MODEM_STATUS(pCard->Controller);

    ModemStatus = Io8_GetModemStatus(pPort);
/* ------------------------------------------- VIV  7/21/1993 16:40  end   */


    //
    // If we are placeing the modem status into the data stream
    // on every change, we should do it now.
    //

    if (pPort->EscapeChar) {

        if (ModemStatus & (SERIAL_MSR_DCTS |
                           SERIAL_MSR_DDSR |
                           SERIAL_MSR_TERI |
                           SERIAL_MSR_DDCD)) {

            SerialPutChar(
                pPort,
                pPort->EscapeChar
                );
            SerialPutChar(
                pPort,
                SERIAL_LSRMST_MST
                );
            SerialPutChar(
                pPort,
                ModemStatus
                );

        }

    }


//#if 0   //VIV: We have an automatic Hardware Flow Control
    //
    // Take care of input flow control based on sensitivity
    // to the DSR.  This is done so that the application won't
    // see spurious data generated by odd devices.
    //
    // Basically, if we are doing dsr sensitivity then the
    // driver should only accept data when the dsr bit is
    // set.
    //

    if (pPort->HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) {

        if (ModemStatus & SERIAL_MSR_DSR) {

            //
            // The line is high.  Simply make sure that
            // RXHolding does't have the DSR bit.
            //

            pPort->RXHolding &= ~SERIAL_RX_DSR;

        } else {

            pPort->RXHolding |= SERIAL_RX_DSR;

        }

    } else {

        //
        // We don't have sensitivity due to DSR.  Make sure we
        // arn't holding. (We might have been, but the app just
        // asked that we don't hold for this reason any more.)
        //

        pPort->RXHolding &= ~SERIAL_RX_DSR;

    }

//#endif  //VIV


    //
    // Check to see if we have a wait
    // pending on the modem status events.  If we
    // do then we schedule a dpc to satisfy
    // that wait.
    //

    if (pPort->IsrWaitMask) {

        if ((pPort->IsrWaitMask & SERIAL_EV_CTS) &&
            (ModemStatus & SERIAL_MSR_DCTS)) {

            pPort->HistoryMask |= SERIAL_EV_CTS;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_DSR) &&
            (ModemStatus & SERIAL_MSR_DDSR)) {

            pPort->HistoryMask |= SERIAL_EV_DSR;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_RING) &&
            (ModemStatus & SERIAL_MSR_TERI)) {

            pPort->HistoryMask |= SERIAL_EV_RING;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_RLSD) &&
            (ModemStatus & SERIAL_MSR_DDCD)) {

            pPort->HistoryMask |= SERIAL_EV_RLSD;

        }

        if (pPort->IrpMaskLocation &&
            pPort->HistoryMask) {

            *pPort->IrpMaskLocation =
             pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->
                IoStatus.Information = sizeof(ULONG);
            KeInsertQueueDpc(
                &pPort->CommWaitDpc,
                NULL,
                NULL
                );

        }

    }



// VIV: We have an automatic Hardware Flow Control but we still need
// to update flags for GetCommStatus().

    //
    // If the app has modem line flow control then
    // we check to see if we have to hold up transmission.
    //

    if (pPort->HandFlow.ControlHandShake &
        SERIAL_OUT_HANDSHAKEMASK) {

        if (pPort->HandFlow.ControlHandShake &
            SERIAL_CTS_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_CTS) {

                pPort->TXHolding &= ~SERIAL_TX_CTS;

            } else {

                pPort->TXHolding |= SERIAL_TX_CTS;

            }

        } else {

            pPort->TXHolding &= ~SERIAL_TX_CTS;

        }

        if (pPort->HandFlow.ControlHandShake &
            SERIAL_DSR_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_DSR) {

                pPort->TXHolding &= ~SERIAL_TX_DSR;

            } else {

                pPort->TXHolding |= SERIAL_TX_DSR;

            }

        } else {

            pPort->TXHolding &= ~SERIAL_TX_DSR;

        }

        if (pPort->HandFlow.ControlHandShake &
            SERIAL_DCD_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_DCD) {

                pPort->TXHolding &= ~SERIAL_TX_DCD;

            } else {

                pPort->TXHolding |= SERIAL_TX_DCD;

            }

        } else {

            pPort->TXHolding &= ~SERIAL_TX_DCD;

        }

  #if 0 //VIV
        //
        // If we hadn't been holding, and now we are then
        // queue off a dpc that will lower the RTS line
        // if we are doing transmit toggling.
        //

        if (!OldTXHolding && pPort->TXHolding  &&
            ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
              SERIAL_TRANSMIT_TOGGLE)) {

            KeInsertQueueDpc(
                &pPort->StartTimerLowerRTSDpc,
                NULL,
                NULL
                )?pPort->CountOfTryingToLowerRTS++:0;

        }

        //
        // We've done any adjusting that needed to be
        // done to the holding mask given updates
        // to the modem status.  If the Holding mask
        // is clear (and it wasn't clear to start)
        // and we have "write" work to do set things
        // up so that the transmission code gets invoked.
        //

        if (!DoingTX && OldTXHolding && !pPort->TXHolding) {

            if (!pPort->TXHolding &&
                (pPort->TransmitImmediate ||
                 pPort->WriteLength) &&
                 pPort->HoldingEmpty) {

                DISABLE_ALL_INTERRUPTS(pCard->Controller);
                ENABLE_ALL_INTERRUPTS(pCard->Controller);

            }

        }
  #endif  //VIV

    } else {

        //
        // We need to check if transmission is holding
        // up because of modem status lines.  What
        // could have occured is that for some strange
        // reason, the app has asked that we no longer
        // stop doing output flow control based on
        // the modem status lines.  If however, we
        // *had* been held up because of the status lines
        // then we need to clear up those reasons.
        //

        if (pPort->TXHolding & (SERIAL_TX_DCD |
                                    SERIAL_TX_DSR |
                                    SERIAL_TX_CTS)) {

            pPort->TXHolding &= ~(SERIAL_TX_DCD |
                                      SERIAL_TX_DSR |
                                      SERIAL_TX_CTS);


  #if 0 //VIV
            if (!DoingTX && OldTXHolding && !pPort->TXHolding) {

                if (!pPort->TXHolding &&
                    (pPort->TransmitImmediate ||
                     pPort->WriteLength) &&
                     pPort->HoldingEmpty) {
                    DISABLE_ALL_INTERRUPTS(pCard->Controller);
                    ENABLE_ALL_INTERRUPTS(pCard->Controller);

                }

            }
  #endif  //VIV
        }

    }

//---------------------------------------------------- VIV  7/30/1993 begin 
    SerialDump( SERDIAG1,( "IO8+: SerialHandleModemUpdate for %x, Channel %d. "
                "RXHolding = %d, TXHolding = %d\n",
                pCard->Controller, pPort->ChannelNumber,
                pPort->RXHolding, pPort->TXHolding ) );
//---------------------------------------------------- VIV  7/30/1993 end   

    return ((ULONG)ModemStatus);
}

#if 0
BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;


    //
    // We first need to test if we are actually still doing
    // transmit toggle flow control.  If we aren't then
    // we have no reason to try be here.
    //

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        //
        // The order of the tests is very important below.
        //
        // If there is a break then we should leave on the RTS,
        // because when the break is turned off, it will submit
        // the code to shut down the RTS.
        //
        // If there are writes pending that aren't being held
        // up, then leave on the RTS, because the end of the write
        // code will cause this code to be reinvoked.  If the writes
        // are being held up, its ok to lower the RTS because the
        // upon trying to write the first character after transmission
        // is restarted, we will raise the RTS line.
        //

        if ((pPort->TXHolding & SERIAL_TX_BREAK) ||
            (pPort->CurrentWriteIrp || pPort->TransmitImmediate ||
             (!IsListEmpty(&pPort->WriteQueue)) &&
             (!pPort->TXHolding))) {

            NOTHING;

        } else {

            //
            // Looks good so far.  Call the line status check and processing
            // code, it will return the "current" line status value.  If
            // the holding and shift register are clear, lower the RTS line,
            // if they aren't clear, queue of a dpc that will cause a timer
            // to reinvoke us later.  We do this code here because no one
            // but this routine cares about the characters in the hardware,
            // so no routine by this routine will bother invoking to test
            // if the hardware is empty.
            //

#if 0 //VIVTEMP Probably all function is not needed.
            if ((SerialProcessLSR(pPort) &
                 (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) !=
                 (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) {

                //
                // Well it's not empty, try again later.
                //

                KeInsertQueueDpc(
                    &pPort->StartTimerLowerRTSDpc,
                    NULL,
                    NULL
                    )?pPort->CountOfTryingToLowerRTS++:0;


            } else {

                //
                // Nothing in the hardware, Lower the RTS.
                //

                SerialClrRTS(pPort);


            }
#endif
        }

    }

    //
    // We decement the counter to indicate that we've reached
    // the end of the execution path that is trying to push
    // down the RTS line.
    //

    pPort->CountOfTryingToLowerRTS--;

    return FALSE;
}

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine starts a timer that when it expires will start
    a dpc that will check if it can lower the rts line because
    there are no characters in the hardware.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
    LARGE_INTEGER CharTime;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    //
    // Take out the lock to prevent the line control
    // from changing out from under us while we calculate
    // a character time.
    //

    KeAcquireSpinLock(
        &pPort->ControlLock,
        &OldIrql
        );

    CharTime = SerialGetCharTime(pPort);

    KeReleaseSpinLock(
        &pPort->ControlLock,
        OldIrql
        );

    CharTime = RtlLargeIntegerNegate(CharTime);

    if (KeSetTimer(
            &pPort->LowerRTSTimer,
            CharTime,
            &pPort->PerhapsLowerRTSDpc
            )) {

        //
        // The timer was already in the timer queue.  This implies
        // that one path of execution that was trying to lower
        // the RTS has "died".  Synchronize with the ISR so that
        // we can lower the count.
        //

        KeSynchronizeExecution(
            pCard->Interrupt,
            SerialDecrementRTSCounter,
            pPort
            );

    }

}

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This dpc routine exists solely to call the code that
    tests if the rts line should be lowered when TRANSMIT
    TOGGLE flow control is being used.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    KeSynchronizeExecution(
        pCard->Interrupt,
        SerialPerhapsLowerRTS,
        pPort
        );

}

BOOLEAN
SerialDecrementRTSCounter(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->CountOfTryingToLowerRTS--;

    return FALSE;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\io8_w2k.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			IO8_W2K.C															*
*																						*
*	Creation:		14th April 1999														*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Functions specific to I/O8+ and Windows 2000						*
*																						*
****************************************************************************************/

// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, SpxGetNtCardType)
#endif


#define FILE_ID		IO8_W2K_C		// File ID for Event Logging see IO8_DEFS.H for values.


/*****************************************************************************
****************************                      ****************************
****************************   SpxGetNtCardType   ****************************
****************************                      ****************************
******************************************************************************

prototype:		ULONG	SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
	
description:	Return the NT defined card type for the specified card
				device object.

parameters:		pDevObject points to the NT device object for the card

returns:		NT defined card type,
				or -1 if not identified
*/

ULONG	SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard	= pDevObject->DeviceExtension;
	ULONG					NtCardType = -1;
	PVOID					pPropertyBuffer = NULL;
	ULONG					ResultLength = 0; 
	NTSTATUS				status = STATUS_SUCCESS;
	ULONG					BufferLength = 1;	// Initial size.

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);	// Allocate the buffer

	if(pPropertyBuffer == NULL)									// SpxAllocateMem failed.
		return -1;

	// Try to get HardwareID
	status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
									pPropertyBuffer, &ResultLength);

	if(!SPX_SUCCESS(status))					// IoGetDeviceProperty failed.
	{
		if(status == STATUS_BUFFER_TOO_SMALL)	// Buffer was too small.
		{
			SpxFreeMem(pPropertyBuffer);			// Free old buffer that was not big enough.
			BufferLength = ResultLength + 1;		// Set BufferLength to size required.

			pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);	// Allocate a bigger buffer.

			if(pPropertyBuffer == NULL)			// SpxAllocateMem failed.
				return -1;

			// Try again.
			status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
											pPropertyBuffer, &ResultLength);

			if(!SPX_SUCCESS(status))			// IoGetDeviceProperty failed a second time.
			{
				SpxFreeMem(pPropertyBuffer);	// Free buffer.
				return -1;
			}
		}
		else
		{
			SpxFreeMem(pPropertyBuffer);			// Free buffer.
			return -1;
		}
	}



	// If we get to here then there is something in the PropertyBuffer.

	_wcsupr(pPropertyBuffer);		// Convert HardwareID to uppercase


	// I/O8+
	if(wcsstr(pPropertyBuffer, IO8_ISA_HWID) != NULL)
		NtCardType = Io8Isa;

	if(wcsstr(pPropertyBuffer, IO8_PCI_HWID) != NULL)
		NtCardType = Io8Pci;
	

	SpxFreeMem(pPropertyBuffer);			// Free buffer.

	return(NtCardType);

} // SpxGetNtCardType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//	Precompiled Header
/////////////////////////////////////////////////////////////////////////////

#include <ntddk.h>
#include <ntddser.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#define WMI_SUPPORT	// Include WMI Support code
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>


// Definitions and Macros.
#include "esils.h"		// Esils
#include "io8_ver.h"	// Dirver Version Information
#include "spx_defs.h"	// Spx Generic Definitions
#include "io8_defs.h"	// I/O8+ Specific Definitions
#include "io8_nt.h"		//


//Structures  
#include "spx_card.h"	// Common Card Info
#include "io8_card.h"	// I/O8+ card device structure
#include "spx_misc.h"	// Misc 
#include "serialp.h"	// Serial prototypes and macros

// Common PnP function prototypes.
#include "spx.h"		// Common PnP header


// IO8 specific function prototypes
#include "io8_proto.h"	// Exportable Function Prototypes

#if defined(i386)
#include "io8_log.h"	// I/O8+ Specific Error Log Messages
#endif // i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\purge.c ===
#include "precomp.h"			
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    purge.c

Abstract:

    This module contains the code that is very specific to purge
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/



NTSTATUS
SerialStartPurge(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.

Arguments:

    pPort - Pointer to the device extension.

Return Value:

    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.

--*/

{

    PIRP NewIrp;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    do 
	{
        ULONG Mask;

        Mask = *((ULONG *) (pPort->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));

        if(Mask & SERIAL_PURGE_TXABORT) 
		{
            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);
            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->WriteQueue, &pPort->CurrentXoffIrp);
        }

        if(Mask & SERIAL_PURGE_RXABORT) 
            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);

        if(Mask & SERIAL_PURGE_RXCLEAR) 
		{
            KIRQL OldIrql;

            //
            // Clean out the interrupt buffer.
            //
            // Note that we do this under protection of the
            // the drivers control lock so that we don't hose
            // the pointers if there is currently a read that
            // is reading out of the buffer.
            //

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
            KeSynchronizeExecution(pCard->Interrupt, SerialPurgeInterruptBuff, pPort);
            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
        }

        pPort->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
        pPort->CurrentPurgeIrp->IoStatus.Information = 0;

        SerialGetNextIrp(pPort, &pPort->CurrentPurgeIrp, &pPort->PurgeQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return STATUS_SUCCESS;
}

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply resets the interrupt (typeahead) buffer.

    NOTE: This routine is being called from KeSynchronizeExecution.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The typeahead buffer is by definition empty if there
    // currently is a read owned by the isr.
    //

    if(pPort->ReadBufferBase == pPort->InterruptReadBuffer) 
	{

        pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
        pPort->FirstReadableChar = pPort->InterruptReadBuffer;
        pPort->LastCharSlot = pPort->InterruptReadBuffer + (pPort->BufferSize - 1);
                                      
        pPort->CharsInInterruptBuffer = 0;

        SerialHandleReducedIntBuffer(pPort);
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\qsfile.c ===
#include "precomp.h"				
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    qsfile.c

Abstract:

    This module contains the code that is very specific to query/set file
    operations in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/



NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    if(IrpSp->Parameters.QueryFile.FileInformationClass == FileStandardInformation) 
	{
        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize = RtlConvertUlongToLargeInteger(0ul);
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } 
	else
	{
		if(IrpSp->Parameters.QueryFile.FileInformationClass == FilePositionInformation) 
		{
			((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->CurrentByteOffset = RtlConvertUlongToLargeInteger(0ul);
			Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
		} 
		else 
		{
			Status = STATUS_INVALID_PARAMETER;
		}
	}

	Irp->IoStatus.Status = Status;
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);
        
    return Status;

}

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.


    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    if((IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation) 
         ||(IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileAllocationInformation))
	{
        Status = STATUS_SUCCESS;
    } 
	else 
	{
        Status = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = Status;
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,0);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\spxutils.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_UTILS.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Utility functions.													*
*																						*
****************************************************************************************/

#define FILE_ID	SPX_UTILS_C		// File ID for Event Logging see SPX_DEFS.H for values.

// Paging...  
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_InitMultiString)
#pragma alloc_text (PAGE, Spx_GetRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_PutRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_LogMessage)
#pragma alloc_text (PAGE, Spx_LogError)
#pragma alloc_text (PAGE, Spx_MemCompare)
#endif


/////////////////////////////////////////////////////////////////////////////////////////
//	
//	Description:
//
//		This routine will take a null terminated list of ascii strings and combine
//		them together to generate a unicode multi-string block
//
//	Arguments:
//
//		Multi		- TRUE if a MULTI_SZ list is required, FALSE for a simple UNICODE
//
//		MultiString - a unicode structure in which a multi-string will be built
//		...         - a null terminated list of narrow strings which will be
//			       combined together. This list must contain at least a trailing NULL
//
//	Return Value:
//
//		NTSTATUS
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...)
{

	ANSI_STRING ansiString;
	NTSTATUS status;
	PCSTR rawString;
	PWSTR unicodeLocation;
	ULONG multiLength = 0;
	UNICODE_STRING unicodeString;
	va_list ap;
	ULONG i;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	va_start(ap,MultiString);
  
	// Make sure that we won't leak memory
	ASSERT(MultiString->Buffer == NULL);

	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{
		RtlInitAnsiString(&ansiString, rawString);
		multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
		rawString = va_arg(ap, PCSTR);
	}

	va_end( ap );

	if (multiLength == 0) 
	{
		// Done
		RtlInitUnicodeString(MultiString, NULL);
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (1)\n", PRODUCT_NAME));

		return STATUS_SUCCESS;
	}

	

	if(multi)
		multiLength += sizeof(WCHAR);	// We need an extra null if we want a MULTI_SZ list


	MultiString->MaximumLength = (USHORT)multiLength;
	MultiString->Buffer = SpxAllocateMem(PagedPool, multiLength);
	MultiString->Length = 0;

	if (MultiString->Buffer == NULL) 
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (2) - FAILURE\n", PRODUCT_NAME));

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	SpxDbgMsg(SPX_MISC_DBG, ("%s: Allocated %lu bytes for buffer\n", PRODUCT_NAME, multiLength));

#if DBG
	RtlFillMemory(MultiString->Buffer, multiLength, 0xff);
#endif

	unicodeString.Buffer = MultiString->Buffer;
	unicodeString.MaximumLength = (USHORT) multiLength;

	va_start(ap, MultiString);
	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{

		RtlInitAnsiString(&ansiString,rawString);
		status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);

		// We don't allocate memory, so if something goes wrong here,
		// its the function that's at fault
		ASSERT(SPX_SUCCESS(status));

		// Check for any commas and replace them with NULLs
		ASSERT(unicodeString.Length % sizeof(WCHAR) == 0);

		for (i = 0; i < (unicodeString.Length / sizeof(WCHAR)); i++) 
		{
			if (unicodeString.Buffer[i] == L'\x2C' || unicodeString.Buffer[i] == L'\x0C' ) 
			{
				unicodeString.Buffer[i] = L'\0'; 
			}
		}


		SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer: %ws\n", PRODUCT_NAME, unicodeString.Buffer));

		// Move the buffers along
		unicodeString.Buffer += ((unicodeString.Length / sizeof(WCHAR)) + 1);
		unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
		unicodeString.Length = 0;

		// Next
		rawString = va_arg(ap, PCSTR);

	} // while

	va_end(ap);

	if(multi)
	{
		ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));
	}
	else
	{
		ASSERT(unicodeString.MaximumLength == 0);
	}


	// Stick the final null there
 	SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer last addr: 0x%X\n", PRODUCT_NAME, unicodeString.Buffer));

	if(multi)
		unicodeString.Buffer[0] = L'\0'; 		// We need an extra null if we want a MULTI_SZ list


	MultiString->Length = (USHORT)multiLength - sizeof(WCHAR);
	MultiString->MaximumLength = (USHORT)multiLength;

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (3) - SUCCESS\n", PRODUCT_NAME));

	return STATUS_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:	
//		Reads a registry key value from an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		KeyNameString       ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//
//		Data                Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	)

{

	UNICODE_STRING              keyName;
	ULONG                       length;
	PKEY_VALUE_FULL_INFORMATION fullInfo;

	NTSTATUS                    status = STATUS_INSUFFICIENT_RESOURCES;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Enter Spx_GetRegistryKeyValue\n", PRODUCT_NAME));


	RtlInitUnicodeString (&keyName, KeyNameString);

	length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength + DataLength;
	fullInfo = SpxAllocateMem(PagedPool, length); 

	if(fullInfo) 
	{
		status = ZwQueryValueKey(	Handle,
									&keyName,
									KeyValueFullInformation,
									fullInfo,
									length,
									&length);

		if(SPX_SUCCESS(status)) 
		{
			// If there is enough room in the data buffer, copy the output
			if(DataLength >= fullInfo->DataLength) 
				RtlCopyMemory (Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, fullInfo->DataLength);
		}

		SpxFreeMem(fullInfo);
	}

	return status;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//
//		Writes a registry key value to an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		PKeyNameString      ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//    
//		Dtype				REG_XYZ value type
//
//		PData               Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	)
{

	NTSTATUS status;
	UNICODE_STRING keyname;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Enter Spx_PutRegistryKeyValue\n", PRODUCT_NAME));

	RtlInitUnicodeString(&keyname, NULL);
	keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
	keyname.Buffer = SpxAllocateMem(PagedPool, keyname.MaximumLength);

	if(keyname.Buffer == NULL) 
		  return STATUS_INSUFFICIENT_RESOURCES;

	RtlAppendUnicodeToString(&keyname, PKeyNameString);

	status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

	SpxFreeMem(keyname.Buffer);

	return status;
}




VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp)	// Limited to 51 characters + 1 null
{
	
	UNICODE_STRING ErrorMsg;

	ErrorMsg.Length = 0;
	ErrorMsg.Buffer = 0;
	Spx_InitMultiString(FALSE, &ErrorMsg, szTemp, NULL);


	switch(MessageSeverity)
	{
	case STATUS_SEVERITY_SUCCESS:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_SUCCESS,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;
	
	case STATUS_SEVERITY_INFORMATIONAL:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_INFORMATIONAL,			// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_WARNING:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_WARNING,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_ERROR:
	default:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_ERROR,					// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	}

	if(ErrorMsg.Buffer != NULL)
		SpxFreeMem(ErrorMsg.Buffer);

}

/////////////////////////////////////////////////////////////////////////////////////////
//																
//	Spx_LogError														
//															
/////////////////////////////////////////////////////////////////////////////////////////
/*
	Routine Description:

		This routine allocates an error log entry, copies the supplied data
		to it, and requests that it be written to the error log file.

	Arguments:

		DriverObject - A pointer to the driver object for the device.

		DeviceObject - A pointer to the device object associated with the
		device that had the error, early in initialization, one may not
		yet exist.

		P1,P2 - If phyical addresses for the controller ports involved
		with the error are available, put them through as dump data.

		SequenceNumber - A ulong value that is unique to an IRP over the
		life of the irp in this driver - 0 generally means an error not
		associated with an irp.

		MajorFunctionCode - If there is an error associated with the irp,
		this is the major function code of that irp.

		RetryCount - The number of times a particular operation has been retried.

		UniqueErrorValue - A unique long word that identifies the particular
		call to this function.

		FinalStatus - The final status given to the irp that was associated
		with this error.  If this log entry is being made during one of
		the retries this value will be STATUS_SUCCESS.

		SpecificIOStatus - The IO status for a particular error.

		LengthOfInsert1 - The length in bytes (including the terminating NULL)
						  of the first insertion string.

		Insert1 - The first insertion string.

		LengthOfInsert2 - The length in bytes (including the terminating NULL)
						  of the second insertion string.  NOTE, there must
						  be a first insertion string for their to be
						  a second insertion string.

		Insert2 - The second insertion string.

	Return Value:	None.
*/


VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	)
{

	PIO_ERROR_LOG_PACKET ErrorLogEntry;

	PVOID objectToUse;
	SHORT dumpToAllocate = 0;
	PUCHAR ptrToFirstInsert;
	PUCHAR ptrToSecondInsert;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(Insert1 == NULL) 
		LengthOfInsert1 = 0;

	if(Insert2 == NULL) 
		LengthOfInsert2 = 0;


	if(ARGUMENT_PRESENT(DeviceObject)) 
		objectToUse = DeviceObject;
	else 
		objectToUse = DriverObject;


	if(Spx_MemCompare(P1, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	if(Spx_MemCompare(P2, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	ErrorLogEntry = IoAllocateErrorLogEntry(objectToUse,
											(UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + dumpToAllocate 
											+ LengthOfInsert1 + LengthOfInsert2)	
											);

	if(ErrorLogEntry != NULL) 
	{
		ErrorLogEntry->ErrorCode			= SpecificIOStatus;
		ErrorLogEntry->SequenceNumber		= SequenceNumber;
		ErrorLogEntry->MajorFunctionCode	= MajorFunctionCode;
		ErrorLogEntry->RetryCount			= RetryCount;
		ErrorLogEntry->UniqueErrorValue		= UniqueErrorValue;
		ErrorLogEntry->FinalStatus			= FinalStatus;
		ErrorLogEntry->DumpDataSize			= dumpToAllocate;

		
		if(dumpToAllocate) 
		{
			RtlCopyMemory(&ErrorLogEntry->DumpData[0], &P1,	sizeof(PHYSICAL_ADDRESS));

			if(dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) 
			{
				RtlCopyMemory(	((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS),
								&P2,
								sizeof(PHYSICAL_ADDRESS)
								);

				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + (2*sizeof(PHYSICAL_ADDRESS));

			} 
			else 
			{
				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS);
			}

		} 
		else 
		{
			ptrToFirstInsert = (PUCHAR)&ErrorLogEntry->DumpData[0];
		}

		ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

		if(LengthOfInsert1) 
		{
			ErrorLogEntry->NumberOfStrings	= 1;
			ErrorLogEntry->StringOffset		= (USHORT)(ptrToFirstInsert - (PUCHAR)ErrorLogEntry);

			RtlCopyMemory(ptrToFirstInsert, Insert1, LengthOfInsert1);

			if(LengthOfInsert2) 
			{
				ErrorLogEntry->NumberOfStrings = 2;
				RtlCopyMemory(ptrToSecondInsert, Insert2, LengthOfInsert2);
			}
		}


		IoWriteErrorLogEntry(ErrorLogEntry);

	}

}



SPX_MEM_COMPARES
Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB)
/*++
Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.
--*/
{
	LARGE_INTEGER a;
	LARGE_INTEGER b;

	LARGE_INTEGER lower;
	ULONG lowerSpan;
	LARGE_INTEGER higher;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	a = A;
	b = B;

	if(a.QuadPart == b.QuadPart) 
	  return AddressesAreEqual;


	if(a.QuadPart > b.QuadPart) 
	{
		higher = a;
		lower = b;
		lowerSpan = SpanOfB;
	} 
	else 
	{
		higher = b;
		lower = a;
		lowerSpan = SpanOfA;
	}

	if((higher.QuadPart - lower.QuadPart) >= lowerSpan)
      return AddressesAreDisjoint;


	return AddressesOverlap;
}


NTSTATUS
PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard)
{
	/******************************************************** 
	* Setting bit 17 in the CNTRL register of the PLX 9050	* 
	* chip forces a retry on writes while a read is pending.*
	* This is to prevent the card locking up on Intel Xeon  *
	* multiprocessor systems with the NX chipset.			*
	********************************************************/

	#define CNTRL_REG_OFFSET	0x14	// DWORD Offset (BYTE Offset 0x50) 
	
	NTSTATUS	status = STATUS_SUCCESS;
	PULONG		pPCIConfigRegisters = NULL;			// Pointer to PCI Config Registers.
	CHAR		szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering PLX_9050_CNTRL_REG_FIX for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	pPCIConfigRegisters = MmMapIoSpace(pCard->PCIConfigRegisters, pCard->SpanOfPCIConfigRegisters, FALSE);

	if(pPCIConfigRegisters != NULL)
	{
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */

		if(pPCIConfigRegisters[CNTRL_REG_OFFSET] == 0)	// If bit 7 is set Config Registers are zero (unreadable) 
		{
			// We have to blindly write the value to the register.
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;	// Set bits 17 & 21 of PLX CNTRL register 
		}
		else
		{	
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 1] &= ~0x40;		// Clear bit 14 of PLX CNTRL register
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;		// Set bits 17 & 21 of PLX CNTRL register
		}

		MmUnmapIoSpace(pPCIConfigRegisters, pCard->SpanOfPCIConfigRegisters);
	}
	else
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Insufficient resources available for Card %d.\n", 
			PRODUCT_NAME, pCard->CardNumber));
	
		sprintf(szErrorMsg, "Card at %08X%08X: Insufficient resources.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	return status;
}


//
// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	

	if(Set) 
		pDevExt->PnpPowerFlags |= Value;			
	else 
		pDevExt->PnpPowerFlags &= ~Value;	

	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->StalledIrpLock, &oldIrql);	

	pDevExt->UnstallingFlag = Set;			

	KeReleaseSpinLock(&pDevExt->StalledIrpLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
BOOLEAN
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll)
{
	KIRQL oldIrql;
	BOOLEAN bRet = FALSE; 

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	
	
	if(bAll)
	{
		// If all the requested SetFlags are set
		// and if all of the requested ClearedFlags are cleared then return true.
		if(((ulSetFlags & pDevExt->PnpPowerFlags) == ulSetFlags) && !(ulClearedFlags & pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}
	else
	{
		// If any of the requested SetFlags are set 
		// or if any of the requested ClearedFlags are cleared then return true.
		if((ulSetFlags & pDevExt->PnpPowerFlags) || (ulClearedFlags & ~pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}


	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);
	
	return bRet;
}




PVOID 
SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 

	pRet = ExAllocatePoolWithTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


PVOID 
SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 
	
	pRet = ExAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


#ifndef BUILD_SPXMINIPORT
void
SpxFreeMem(PVOID pMem)
{
	ASSERT(pMem != NULL);	// Assert if the pointer is NULL.

	ExFreePool(pMem);
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////
// Must be called just before an IoCompleteRequest if IrpCondition == IRP_SUBMITTED
//
///////////////////////////////////////////////////////////////////////////////////////////
VOID
SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition)
{
	PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	switch(pIrpStack->MajorFunction)		// Don't filter Plug and Play IRPs 
	{

	case IRP_MJ_FLUSH_BUFFERS:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.FlushIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.FlushIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.FlushIrpsQueued);
				pPort->PerfStats.FlushIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.FlushIrpsQueued);
				if(pPort->PerfStats.FlushIrpsQueued) 
					pPort->PerfStats.FlushIrpsQueued--;		// Decrement counter for performance stats.

				break;


			default:
				break;
			}

			break;
		}


	case IRP_MJ_WRITE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.WriteIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.WriteIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.WriteIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.WriteIrpsQueued);
				pPort->PerfStats.WriteIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.WriteIrpsQueued);
				if(pPort->PerfStats.WriteIrpsQueued) 
					pPort->PerfStats.WriteIrpsQueued--;		// Decrement counter for performance stats.

				break;

			default:
				break;
			}

			break;
		}

	case IRP_MJ_READ:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.ReadIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.ReadIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.ReadIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.ReadIrpsQueued);
				pPort->PerfStats.ReadIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.ReadIrpsQueued);
				if(pPort->PerfStats.ReadIrpsQueued) 
					pPort->PerfStats.ReadIrpsQueued--;		// Decrement counter for performance stats.
				
				break;


			default:
				break;
			}

			break;
		}

	case IRP_MJ_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.IoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.IoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_INTERNAL_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InternalIoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InternalIoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}


	case IRP_MJ_CREATE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CreateIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CreateIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLOSE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CloseIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CloseIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLEANUP:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CleanUpIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CleanUpIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_QUERY_INFORMATION:
	case IRP_MJ_SET_INFORMATION:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InfoIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InfoIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}
	
	default:
		break;

	}
}


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    clear the perf stats.
//
// Arguments:
//    pPort - Pointer to a the Port Device Extension.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
{
    RtlZeroMemory(&pPort->PerfStats, sizeof(PORT_PERFORMANCE_STATS));

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\spx_init.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_INIT.C															*
*																						*
*	Creation:		27th September 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	This module contains the code that load the driver.					*
*																						*
****************************************************************************************/


#define FILE_ID	SPX_INIT_C		// File ID for Event Logging see SPX_DEFS.H for values.


// Function Prototypes 
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
// End function prototypes.

// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnload)
#endif

// Gloabal Driver Data
UNICODE_STRING	SavedRegistryPath;

#if DBG
ULONG SpxDebugLevel = 0;		// Debug level for checked build
#endif


//////////////////////////////////////////////////////////////////////////////////////////
//	DriverEntry - Load first and initialises entry points.								//
//////////////////////////////////////////////////////////////////////////////////////////
/*
Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    RegistryPath - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS 
*/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	// Holds status information return by various OS and driver initialization routines.
	NTSTATUS status;

	// We use this to query into the registry as to whether we should break at driver entry.
	RTL_QUERY_REGISTRY_TABLE paramTable[3];
	ULONG zero			= 0;
	ULONG debugLevel	= 0;
	ULONG shouldBreak	= 0;		
	PWCHAR path			= NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	#if DBG
		DbgPrint( "%s: In DriverEntry\n", PRODUCT_NAME);
	#endif


	// Store Registry Path
	SavedRegistryPath.MaximumLength	= RegistryPath->MaximumLength;
	SavedRegistryPath.Length		= RegistryPath->Length;
	SavedRegistryPath.Buffer		= SpxAllocateMem(PagedPool, SavedRegistryPath.MaximumLength);

	if(SavedRegistryPath.Buffer)
	{
		RtlMoveMemory(SavedRegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length);
	
		RtlZeroMemory(&paramTable[0], sizeof(paramTable));
		paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[0].Name = L"BreakOnEntry";
		paramTable[0].EntryContext = &shouldBreak;
		paramTable[0].DefaultType = REG_DWORD;
		paramTable[0].DefaultData = &zero;
		paramTable[0].DefaultLength = sizeof(ULONG);
		paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[1].Name = L"DebugLevel";
		paramTable[1].EntryContext = &debugLevel;
		paramTable[1].DefaultType = REG_DWORD;
		paramTable[1].DefaultData = &zero;
		paramTable[1].DefaultLength = sizeof(ULONG);

		if(!SPX_SUCCESS(status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
														RegistryPath->Buffer, &paramTable[0], 
														NULL, NULL)))
		{
			shouldBreak = 0;
			debugLevel	= 0;
		}

	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;


 	#if DBG
		SpxDebugLevel = debugLevel;	
	//	SpxDebugLevel = (ULONG)-1;			// Prints all debug messages

	//	shouldBreak = 1;	// HARD CODED BREAKPOINT WITH CHECKED BUILD !!!
	#endif


	if(shouldBreak)
	{
		DbgBreakPoint();	// Break Debugger.
	}


	if(SPX_SUCCESS(status))
	{
		// Initialize the Driver Object with driver's entry points
		DriverObject->DriverUnload									= DriverUnload;
		DriverObject->DriverExtension->AddDevice					= Spx_AddDevice;
		DriverObject->MajorFunction[IRP_MJ_PNP]						= Spx_DispatchPnp;
		DriverObject->MajorFunction[IRP_MJ_POWER]					= Spx_DispatchPower;
		DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]			= Spx_Flush;
		DriverObject->MajorFunction[IRP_MJ_WRITE]					= Spx_Write;
		DriverObject->MajorFunction[IRP_MJ_READ]					= Spx_Read;
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]			= Spx_IoControl;
		DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]	= Spx_InternalIoControl;
		DriverObject->MajorFunction[IRP_MJ_CREATE]					= Spx_CreateOpen;
		DriverObject->MajorFunction[IRP_MJ_CLOSE]					= Spx_Close;
		DriverObject->MajorFunction[IRP_MJ_CLEANUP]					= Spx_Cleanup;
		DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]		= Spx_QueryInformationFile;
		DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]			= Spx_SetInformationFile;
#ifdef WMI_SUPPORT
		DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]			= Spx_DispatchSystemControl;
#endif
		
	}
	else
	{
		// Free
		if(SavedRegistryPath.Buffer)
		{
			SpxFreeMem(SavedRegistryPath.Buffer);
			SavedRegistryPath.Buffer = NULL;
		}
	}


	return(status);

}	// DriverEntry 




//////////////////////////////////////////////////////////////////////////////////////////
//	DriverUnload - Called as driver unloads.											
//////////////////////////////////////////////////////////////////////////////////////////
VOID 
DriverUnload(IN PDRIVER_OBJECT pDriverObject)
/*++

Routine Description:

    This routine cleans up all of the resources allocated in DriverEntry.

Arguments:

    pDriverObject - Pointer to the driver object controling all of the
					devices.

Return Value:

    None.

--*/
{
	PAGED_CODE();
	
	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering DriverUnload\n", PRODUCT_NAME));

	// All Device Objects must have been deleted by now.
    ASSERT (pDriverObject->DeviceObject == NULL);

	// Free
	if(SavedRegistryPath.Buffer)
	{
		SpxFreeMem(SavedRegistryPath.Buffer);
		SavedRegistryPath.Buffer = NULL;
	}


	return;
}


// End of SPX_INIT.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\read.c ===
#include "precomp.h"			
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code that is very specific to read
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabReadFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialUpdateReadByIsr(
    IN PVOID Context
    );

ULONG
SerialGetCharsFromIntBuffer(
    PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    );

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    );

NTSTATUS
SerialResizeBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    );

ULONG
SerialMoveToNewIntBuffer(
    PPORT_DEVICE_EXTENSION pPort,
    PUCHAR NewBuffer
    );

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    );


NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the dispatch routine for reading.  It validates the parameters
    for the read request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;


    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length read.  If it is zero length
    // then we are already done!
    //
    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length) 
	{
        //
        // Well it looks like we actually have to do some
        // work.  Put the read on the queue so that we can
        // process it when our previous reads are done.
        //
        return SerialStartOrQueue(pPort, Irp, &pPort->ReadQueue, &pPort->CurrentReadIrp, SerialStartRead);
    } 
	else 
	{
        Irp->IoStatus.Status = STATUS_SUCCESS;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, 0);

        return STATUS_SUCCESS;
    }

}

#ifdef SERENUM_FIX

NTSTATUS
SerialStartRead(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.

Arguments:

    pPort - Simply a pointer to the serial device extension.

Return Value:

    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.

--*/

{

    SERIAL_UPDATE_CHAR updateChar;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;


    updateChar.pPort = pPort;

	do 
	{

        //
        // Check to see if this is a resize request.  If it is
        // then go to a routine that specializes in that.
        //

        if (IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->MajorFunction != IRP_MJ_READ) 
		{

            NTSTATUS localStatus = SerialResizeBuffer(pPort);

            if (!setFirstStatus) 
			{
                firstStatus = localStatus;
                setFirstStatus = TRUE;
            }

        } 
		else 
		{

            pPort->NumberNeededForRead = IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length;

            //
            // Calculate the timeout value needed for the
            // request.  Note that the values stored in the
            // timeout record are in milliseconds.
            //

            useTotalTimer = FALSE;
            returnWithWhatsPresent = FALSE;
            os2ssreturn = FALSE;
            crunchDownToOne = FALSE;
            useIntervalTimer = FALSE;


            //
            // Always initialize the timer objects so that the
            // completion code can tell when it attempts to
            // cancel the timers whether the timers had ever
            // been set.
            //

            KeInitializeTimer(&pPort->ReadRequestTotalTimer);
            KeInitializeTimer(&pPort->ReadRequestIntervalTimer);

            //
            // We get the *current* timeout values to use for timing
            // this read.
            //

            KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

            timeoutsForIrp = pPort->Timeouts;

            KeReleaseSpinLock(&pPort->ControlLock, controlIrql);

            //
            // Calculate the interval timeout for the read.
            //

            if (timeoutsForIrp.ReadIntervalTimeout && (timeoutsForIrp.ReadIntervalTimeout != MAXULONG)) 
			{

                useIntervalTimer = TRUE;

                pPort->IntervalTime = RtlEnlargedUnsignedMultiply(timeoutsForIrp.ReadIntervalTimeout, 10000);

                if (RtlLargeIntegerGreaterThanOrEqualTo(pPort->IntervalTime, pPort->CutOverAmount)) 
                    pPort->IntervalTimeToUse = &pPort->LongIntervalAmount;
				else 
                    pPort->IntervalTimeToUse = &pPort->ShortIntervalAmount;
            }

            if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) 
			{

                //
                // We need to do special return quickly stuff here.
                //
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                //
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                //
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.
                //

                if (!timeoutsForIrp.ReadTotalTimeoutConstant && !timeoutsForIrp.ReadTotalTimeoutMultiplier) 
				{
                    returnWithWhatsPresent = TRUE;
                } 
				else
				{
					if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG) && (timeoutsForIrp.ReadTotalTimeoutMultiplier != MAXULONG))
	                {

						useTotalTimer = TRUE;
						os2ssreturn = TRUE;
						multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
						constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

					} 
					else
					{
						if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG) && (timeoutsForIrp.ReadTotalTimeoutMultiplier == MAXULONG)) 
						{
							useTotalTimer = TRUE;
							os2ssreturn = TRUE;
							crunchDownToOne = TRUE;
							multiplierVal = 0;
							constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
						}
					}
				}

			} 
			else 
			{
                //
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.
                //
                if (timeoutsForIrp.ReadTotalTimeoutMultiplier || timeoutsForIrp.ReadTotalTimeoutConstant)
                {
                    //
                    // We have some timer values to calculate.
                    //
                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
				}
            }


            if (useTotalTimer) 
			{
                totalTime = RtlEnlargedUnsignedMultiply(pPort->NumberNeededForRead, multiplierVal);

                totalTime = RtlLargeIntegerAdd(totalTime, RtlConvertUlongToLargeInteger(constantVal));

                totalTime = RtlExtendedIntegerMultiply(totalTime, -10000);
            }


            //
            // We do this copy in the hope of getting most (if not
            // all) of the characters out of the interrupt buffer.
            //
            // Note that we need to protect this operation with a
            // spinlock since we don't want a purge to hose us.
            //

            KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

            updateChar.CharsCopied = SerialGetCharsFromIntBuffer(pPort);

            //
            // See if we have any cause to return immediately.
            //
            if	(returnWithWhatsPresent || (!pPort->NumberNeededForRead) || 
				(os2ssreturn &&pPort->CurrentReadIrp->IoStatus.Information))
			{

                //
                // We got all we needed for this read.
                // Update the number of characters in the
                // interrupt read buffer.
                //
				KeSynchronizeExecution(pCard->Interrupt, SerialUpdateInterruptBuffer, &updateChar);

//		Slxos_SyncExec(pPort,SerialUpdateInterruptBuffer,&updateChar,0x18);

                KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                    
                pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

                if (!setFirstStatus) 
				{
                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;
                }

			} 
			else 
			{

                //
                // The irp might go under control of the isr.  It
                // won't hurt to initialize the reference count
                // right now.
                //

                SERIAL_INIT_REFERENCE(pPort->CurrentReadIrp);

                IoAcquireCancelSpinLock(&oldIrql);

                //
                // We need to see if this irp should be cancelled.
                //

                if (pPort->CurrentReadIrp->Cancel) 
				{
                    IoReleaseCancelSpinLock(oldIrql);
                    
					KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                       
                    pPort->CurrentReadIrp->IoStatus.Status = STATUS_CANCELLED;
                        
                    pPort->CurrentReadIrp->IoStatus.Information = 0;

                    if (!setFirstStatus) 
					{
                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;
                    }

                } 
				else 
				{

                    //
                    // If we are supposed to crunch the read down to
                    // one character, then update the read length
                    // in the irp and truncate the number needed for
                    // read down to one. Note that if we are doing
                    // this crunching, then the information must be
                    // zero (or we would have completed above) and
                    // the number needed for the read must still be
                    // equal to the read length.
                    //

                    if (crunchDownToOne) 
					{
                        ASSERT((!pPort->CurrentReadIrp->IoStatus.Information) &&
                            (pPort->NumberNeededForRead == IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)
							->Parameters.Read.Length));

                        pPort->NumberNeededForRead = 1;

                        IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length = 1;
                    }

                    //
                    // We still need to get more characters for this read.
                    // Synchronize with the isr so that we can update the
                    // number of characters and if necessary it will have the
                    // isr switch to copying into the user's buffer.
                    //

//			Slxos_SyncExec(pPort,SerialUpdateAndSwitchToUser,&updateChar,0x19);

					KeSynchronizeExecution(pCard->Interrupt, SerialUpdateAndSwitchToUser, &updateChar);
                        

					if (!updateChar.Completed) 
					{
                        //
                        // The irp still isn't complete.  The
                        // completion routines will end up reinvoking
                        // this routine.  So we simply leave.
                        //
                        // First though we should start off the total
                        // timer for the read and increment the reference
                        // count that the total timer has on the current
                        // irp.  Note that this is safe, because even if
                        // the io has been satisfied by the isr it can't
                        // complete yet because we still own the cancel
                        // spinlock.
                        //

                        if (useTotalTimer) 
						{
                            SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

                            KeSetTimer(&pPort->ReadRequestTotalTimer, totalTime, &pPort->TotalReadTimeoutDpc);
						}


                        if (useIntervalTimer) 
						{
                            SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

                            KeQuerySystemTime(&pPort->LastReadTime);
                                
                            KeSetTimer(&pPort->ReadRequestIntervalTimer, 
								*pPort->IntervalTimeToUse, 
								&pPort->IntervalReadTimeoutDpc);
                        }

                        IoMarkIrpPending(pPort->CurrentReadIrp);
                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                            
                        if (!setFirstStatus) 
                            firstStatus = STATUS_PENDING;

                        return firstStatus;

                    } 
					else 
					{

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(&pPort->ControlLock, controlIrql);

                        pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

                        if(!setFirstStatus) 
						{
                            firstStatus = STATUS_SUCCESS;
                            setFirstStatus = TRUE;
                        }

                    }

                }

			}

        }

        //
        // Well the operation is complete.
        //
        SerialGetNextIrp(pPort, &pPort->CurrentReadIrp, &pPort->ReadQueue, &newIrp, TRUE);

		
    } while (newIrp);

    return firstStatus;

}

#else
NTSTATUS
SerialStartRead(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.

Arguments:

    pPort - Simply a pointer to the serial device extension.

Return Value:

    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.

--*/

{

    SERIAL_UPDATE_CHAR updateChar;

    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    LARGE_INTEGER totalTime;
    LARGE_INTEGER intervalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;


    updateChar.pPort = pPort;

    do 
	{
        //
        // Check to see if this is a resize request.  If it is
        // then go to a routine that specializes in that.
        //

        if(IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->MajorFunction != IRP_MJ_READ) 
		{
            NTSTATUS localStatus = SerialResizeBuffer(pPort);

            if(!setFirstStatus) 
			{
                firstStatus = localStatus;
                setFirstStatus = TRUE;
            }

        } 
		else 
		{
            pPort->NumberNeededForRead 
				= IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)
				->Parameters.Read.Length;

            //
            // Calculate the timeout value needed for the
            // request.  Note that the values stored in the
            // timeout record are in milliseconds.
            //

            useTotalTimer = FALSE;
            returnWithWhatsPresent = FALSE;
            useIntervalTimer = FALSE;

            //
            // Always initialize the timer objects so that the
            // completion code can tell when it attempts to
            // cancel the timers whether the timers had ever
            // been Set.
            //

            KeInitializeTimer(&pPort->ReadRequestTotalTimer);
            KeInitializeTimer(&pPort->ReadRequestIntervalTimer);

            //
            // We get the *current* timeout values to use for timing
            // this read.
            //

            KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);
                
            timeoutsForIrp = pPort->Timeouts;

            KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                

            //
            // Calculate the interval timeout for the read.
            //

            if(timeoutsForIrp.ReadIntervalTimeout 
				&& (timeoutsForIrp.ReadIntervalTimeout != MAXULONG)) 
			{
                useIntervalTimer = TRUE;

                intervalTime = RtlEnlargedUnsignedMultiply(
                                   timeoutsForIrp.ReadIntervalTimeout,
                                   10000
                                   );

                pPort->IntervalTime = RtlLargeIntegerNegate(intervalTime);
            }


            if(!timeoutsForIrp.ReadTotalTimeoutConstant 
				&& !timeoutsForIrp.ReadTotalTimeoutMultiplier) 
			{
                //
                // Note that UseTotalTimeout is already false
                // from above so we don't need to set it.
                //

                //
                // Now we check to see if the the interval timer
                // is the max ulong.  If this is so then we
                // simply return with whatever is in the interrupt
                // buffer.
                //

                if(timeoutsForIrp.ReadIntervalTimeout == MAXULONG) 
				{
                    returnWithWhatsPresent = TRUE;
                }

            } 
			else 
			{
                //
                // We have some timer values to calculate.
                //

                useTotalTimer = TRUE;

                totalTime = RtlEnlargedUnsignedMultiply(
                                pPort->NumberNeededForRead,
                                timeoutsForIrp.ReadTotalTimeoutMultiplier
                                );

                totalTime = RtlLargeIntegerAdd(
                                totalTime,
                                RtlConvertUlongToLargeInteger(
                                    timeoutsForIrp.ReadTotalTimeoutConstant
                                    )
                                );

                totalTime = RtlExtendedIntegerMultiply(
                                totalTime,
                                -10000
                                );

            }

            //
            // We do this copy in the hope of getting most (if not
            // all) of the characters out of the interrupt buffer.
            //
            // Note that we need to protect this operation with a
            // spinlock since we don't want a purge to hose us.
            //

            KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

            updateChar.CharsCopied = SerialGetCharsFromIntBuffer(pPort);

            if(returnWithWhatsPresent || (!pPort->NumberNeededForRead)) 
			{

                //
                // We got all we needed for this read.
                // Update the number of characters in the
                // interrupt read buffer.
                //

                KeSynchronizeExecution(
                    pCard->Interrupt,
                    SerialUpdateInterruptBuffer,
                    &updateChar
                    );

                KeReleaseSpinLock(
                    &pPort->ControlLock,
                    controlIrql
                    );

                pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                
				if(!setFirstStatus) 
				{
                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;
                }
            } 
			else 
			{
                //
                // The irp might go under control of the isr.  It
                // won't hurt to initialize the reference count
                // right now.
                //

                SERIAL_INIT_REFERENCE(pPort->CurrentReadIrp);

                IoAcquireCancelSpinLock(&oldIrql);

                //
                // We need to see if this irp should be canceled.
                //

                if(pPort->CurrentReadIrp->Cancel) 
				{
                    IoReleaseCancelSpinLock(oldIrql);

                    KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                        
                    pPort->CurrentReadIrp->IoStatus.Status = STATUS_CANCELLED;
                        
                    pPort->CurrentReadIrp->IoStatus.Information = 0;

                    if (!setFirstStatus) 
					{
                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;
                    }
                } 
				else 
				{
                    //
                    // We still need to get more characters for this read.
                    // synchronize with the isr so that we can update the
                    // number of characters and if necessary it will have the
                    // isr switch to copying into the users buffer.
                    //

                    KeSynchronizeExecution(
                        pCard->Interrupt,
                        SerialUpdateAndSwitchToUser,
                        &updateChar
                        );

                    if(!updateChar.Completed) 
					{
                        //
                        // The irp still isn't complete.  The
                        // completion routines will end up reinvoking
                        // this routine.  So we simply leave.
                        //
                        // First thought we should start off the total
                        // timer for the read and increment the reference
                        // count that the total timer has on the current
                        // irp.  Note that this is safe, because even if
                        // the io has been satisfied by the isr it can't
                        // complete yet because we still own the cancel
                        // spinlock.
                        //

                        if(useTotalTimer) 
						{
                            SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

                            KeSetTimer(
                                &pPort->ReadRequestTotalTimer,
                                totalTime,
                                &pPort->TotalReadTimeoutDpc
                                );

                        }

                        if(useIntervalTimer) 
						{
                            SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

                            KeSetTimer(
                                &pPort->ReadRequestIntervalTimer,
                                pPort->IntervalTime,
                                &pPort->IntervalReadTimeoutDpc
                                );
                        }

                        IoMarkIrpPending(pPort->CurrentReadIrp);
                        IoReleaseCancelSpinLock(oldIrql);
                        
						KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                           
						if(!setFirstStatus) 
						{
                            firstStatus = STATUS_PENDING;
                        }

                        return firstStatus;

                    } 
					else 
					{

                        IoReleaseCancelSpinLock(oldIrql);
                        
						KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                            
                        pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                           

                        if(!setFirstStatus) 
						{
                            firstStatus = STATUS_SUCCESS;
                            setFirstStatus = TRUE;
                        }

                    }

                }

            }

        }

        //
        // Well the operation is complete.
        //
        SerialGetNextIrp(pPort, &pPort->CurrentReadIrp, &pPort->ReadQueue, &newIrp, TRUE);

    } while (newIrp);

    return firstStatus;

}



#endif



VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any read that
    ended up being used by the Isr.  It assumes that the
    status and the information fields of the irp are already
    correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabReadFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

BOOLEAN
SerialGrabReadFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    isr.  If it finds that the isr still owns the irp it grabs
    the ipr away (updating the number of characters copied into the
    users buffer).  If it grabs it away it also decrements the
    reference count on the irp since it no longer belongs to the
    isr (and the dpc that would complete it).

    NOTE: This routine assumes that if the current buffer that the
          ISR is copying characters into is the interrupt buffer then
          the dpc has already been queued.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->ReadBufferBase !=
        pPort->InterruptReadBuffer) {

        //
        // We need to set the information to the number of characters
        // that the read wanted minus the number of characters that
        // didn't get read into the interrupt buffer.
        //

        pPort->CurrentReadIrp->IoStatus.Information =
            IoGetCurrentIrpStackLocation(
                pPort->CurrentReadIrp
                )->Parameters.Read.Length -
            ((pPort->LastCharSlot - pPort->CurrentCharSlot) + 1);

        //
        // Switch back to the interrupt buffer.
        //

        pPort->ReadBufferBase = pPort->InterruptReadBuffer;
        pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
        pPort->FirstReadableChar = pPort->InterruptReadBuffer;
        pPort->LastCharSlot = pPort->InterruptReadBuffer +
                                      (pPort->BufferSize - 1);
        pPort->CharsInInterruptBuffer = 0;

        SERIAL_DEC_REFERENCE(pPort->CurrentReadIrp);

    }

    return FALSE;

}

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabReadFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

BOOLEAN
SerialUpdateReadByIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the count of characters read
    by the isr since the last interval timer experation.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->CountOnLastRead = pPort->ReadByIsr;
    pPort->ReadByIsr = 0;

    return FALSE;

}

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{


    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) 
	{

        //
        // This value is only set by the total
        // timer to indicate that it has fired.
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } 
	else if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) 
	{
        //
        // This value is only set by the regular
        // completion routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_SUCCESS,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } 
	else if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) 
	{
        //
        // This value is only set by the cancel
        // read routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } 
	else if(pPort->CountOnLastRead || pPort->ReadByIsr) 
	{
        //
        // Something has happened since we last came here.  We
        // check to see if the ISR has read in any more characters.
        // If it did then we should update the isr's read count
        // and resubmit the timer.
        //

        if(pPort->ReadByIsr) 
		{

            KeSynchronizeExecution(pCard->Interrupt, SerialUpdateReadByIsr, pPort);
         

#ifdef HYPERTERMINAL_FIX
            //
            // Save off the "last" time something was read.
            // As we come back to this routine we will compare
            // the current time to the "last" time.  If the
            // difference is ever larger then the interval
            // requested by the user, then time out the request.
            //

            KeQuerySystemTime(&pPort->LastReadTime);
            

            KeSetTimer(
                &pPort->ReadRequestIntervalTimer,
                *pPort->IntervalTimeToUse,
                &pPort->IntervalReadTimeoutDpc
                );
#else

            KeSetTimer(
                &pPort->ReadRequestIntervalTimer,
                pPort->IntervalTime,
                &pPort->IntervalReadTimeoutDpc
                );
#endif

            IoReleaseCancelSpinLock(oldIrql);

        } 
		else 
		{

#ifdef HYPERTERMINAL_FIX
            // Take the difference between the current time
            // and the last time we had characters and
            // see if it is greater then the interval time.
            // if it is, then time out the request.  Otherwise
            // go away again for a while.
            //

            //
            // No characters read in the interval time.  Kill
            // this read.
            //

            LARGE_INTEGER currentTime;

            KeQuerySystemTime(&currentTime);
                
                

            if (RtlLargeIntegerGreaterThanOrEqualTo(RtlLargeIntegerSubtract(currentTime, pPort->LastReadTime),
                    pPort->IntervalTime)) 
            {            
                        
                SerialTryToCompleteCurrent(
                    pPort,
                    SerialGrabReadFromIsr,
                    oldIrql,
                    STATUS_TIMEOUT,
                    &pPort->CurrentReadIrp,
                    &pPort->ReadQueue,
                    &pPort->ReadRequestIntervalTimer,
                    &pPort->ReadRequestTotalTimer,
                    SerialStartRead,
                    SerialGetNextIrp
                    );

            } 
			else 
			{

                KeSetTimer(
                    &pPort->ReadRequestIntervalTimer,
                    *pPort->IntervalTimeToUse,
                    &pPort->IntervalReadTimeoutDpc
                    );

                IoReleaseCancelSpinLock(oldIrql);

            }
#else
            //
            // No characters read in the interval time.  Kill
            // this read.
            //

            SerialTryToCompleteCurrent(
                pPort,
                SerialGrabReadFromIsr,
                oldIrql,
                STATUS_TIMEOUT,
                &pPort->CurrentReadIrp,
                &pPort->ReadQueue,
                &pPort->ReadRequestIntervalTimer,
                &pPort->ReadRequestTotalTimer,
                SerialStartRead,
                SerialGetNextIrp
                );
#endif

        }

    } 
	else 
	{
        //
        // Timer doesn't really start until the first character.
        // So we should simply resubmit ourselves.
        //

#ifdef HYPERTERMINAL_FIX
        KeSetTimer(
            &pPort->ReadRequestIntervalTimer,
            *pPort->IntervalTimeToUse,
            &pPort->IntervalReadTimeoutDpc
            );
#else
        KeSetTimer(
            &pPort->ReadRequestIntervalTimer,
            pPort->IntervalTime,
            &pPort->IntervalReadTimeoutDpc
            );
#endif
        IoReleaseCancelSpinLock(oldIrql);

    }


}

ULONG
SerialGetCharsFromIntBuffer(
    PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the users buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    pPort - A pointer to the device extension.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    //
    // This value will be the number of characters that this
    // routine returns.  It will be the minimum of the number
    // of characters currently in the buffer or the number of
    // characters required for the read.
    //
    ULONG numberOfCharsToGet;

    //
    // This holds the number of characters between the first
    // readable character and - the last character we will read or
    // the real physical end of the buffer (not the last readable
    // character).
    //
    ULONG firstTryNumberToGet;


    //
    // The minimum of the number of characters we need and
    // the number of characters available
    //

    numberOfCharsToGet = pPort->CharsInInterruptBuffer;

    if(numberOfCharsToGet > pPort->NumberNeededForRead) 
	{
        numberOfCharsToGet = pPort->NumberNeededForRead;
    }

    if(numberOfCharsToGet) 
	{

        //
        // This will hold the number of characters between the
        // first available character and the end of the buffer.
        // Note that the buffer could wrap around but for the
        // purposes of the first copy we don't care about that.
        //

        firstTryNumberToGet = (pPort->LastCharSlot -
                               pPort->FirstReadableChar) + 1;

        if(firstTryNumberToGet > numberOfCharsToGet) 
		{

            //
            // The characters don't wrap. Actually they may wrap but
            // we don't care for the purposes of this read since the
            // characters we need are available before the wrap.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->FirstReadableChar,
                numberOfCharsToGet
                );

            pPort->NumberNeededForRead -= numberOfCharsToGet;

            //
            // We now will move the pointer to the first character after
            // what we just copied into the users buffer.
            //
            // We need to check if the stream of readable characters
            // is wrapping around to the beginning of the buffer.
            //
            // Note that we may have just taken the last characters
            // at the end of the buffer.
            //

            if((pPort->FirstReadableChar + (numberOfCharsToGet - 1)) 
				== pPort->LastCharSlot) 
			{
                pPort->FirstReadableChar = pPort->InterruptReadBuffer;
            } 
			else 
			{
                pPort->FirstReadableChar += numberOfCharsToGet;
            }
        } 
		else 
		{
            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->FirstReadableChar,
                firstTryNumberToGet
                );

            pPort->NumberNeededForRead -= firstTryNumberToGet;

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->InterruptReadBuffer,
                numberOfCharsToGet - firstTryNumberToGet
                );

            pPort->FirstReadableChar = pPort->InterruptReadBuffer +
                                           (numberOfCharsToGet -
                                            firstTryNumberToGet);

            pPort->NumberNeededForRead -= (numberOfCharsToGet -
                                               firstTryNumberToGet);

        }

    }

    pPort->CurrentReadIrp->IoStatus.Information += numberOfCharsToGet;

    return numberOfCharsToGet;

}

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the number of characters that
    remain in the interrupt buffer.  We need to use this routine
    since the count could be updated during the update by execution
    of the ISR.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension and count of the number of characters
              that we previously copied into the users buffer.  The
              structure actually has a third field that we don't
              use in this routine.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR update = Context;
    PPORT_DEVICE_EXTENSION pPort = update->pPort;

    ASSERT(pPort->CharsInInterruptBuffer >= update->CharsCopied);
    pPort->CharsInInterruptBuffer -= update->CharsCopied;

    //
    // Deal with flow control if necessary.
    //

    SerialHandleReducedIntBuffer(pPort);


    return FALSE;

}

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.  If we still don't have enough characters
    to satisfy the read it will then we set things up so that the
    ISR uses the user buffer copy into.

    This routine is also used to update a count that is maintained
    by the ISR to keep track of the number of characters in its buffer.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a count of the number of characters
              that we previously copied into the users buffer, and
              a boolean that we will set that defines whether we
              switched the ISR to copy into the users buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR updateChar = Context;
    PPORT_DEVICE_EXTENSION pPort = updateChar->pPort;

    SerialUpdateInterruptBuffer(Context);

    //
    // There are more characters to get to satisfy this read.
    // Copy any characters that have arrived since we got
    // the last batch.
    //

    updateChar->CharsCopied = SerialGetCharsFromIntBuffer(pPort);

    SerialUpdateInterruptBuffer(Context);

    //
    // No more new characters will be "received" until we exit
    // this routine.  We again check to make sure that we
    // haven't satisfied this read, and if we haven't we set things
    // up so that the ISR copies into the user buffer.
    //

    if(pPort->NumberNeededForRead) 
	{

        //
        // We shouldn't be switching unless there are no
        // characters left.
        //

        ASSERT(!pPort->CharsInInterruptBuffer);

        //
        // We use the following to values to do inteval timing.
        //
        // CountOnLastRead is mostly used to simply prevent
        // the interval timer from timing out before any characters
        // are read. (Interval timing should only be effective
        // after the first character is read.)
        //
        // After the first time the interval timer fires and
        // characters have be read we will simply update with
        // the value of ReadByIsr and then set ReadByIsr to zero.
        // (We do that in a synchronization routine.
        //
        // If the interval timer dpc routine ever encounters
        // ReadByIsr == 0 when CountOnLastRead is non-zero it
        // will timeout the read.
        //
        // (Note that we have a special case of CountOnLastRead
        // < 0.  This is done by the read completion routines other
        // than the total timeout dpc to indicate that the total
        // timeout has expired.)
        //

        pPort->CountOnLastRead = pPort->CurrentReadIrp->IoStatus.Information;

        pPort->ReadByIsr = 0;

        //
        // By compareing the read buffer base address to the
        // the base address of the interrupt buffer the ISR
        // can determine whether we are using the interrupt
        // buffer or the user buffer.
        //

        pPort->ReadBufferBase = pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer;

        //
        // The current char slot is after the last copied in
        // character.  We know there is always room since we
        // we wouldn't have gotten here if there wasn't.
        //

        pPort->CurrentCharSlot = pPort->ReadBufferBase +
            pPort->CurrentReadIrp->IoStatus.Information;

        //
        // The last position that a character can go is on the
        // last byte of user buffer.  While the actual allocated
        // buffer space may be bigger, we know that there is at
        // least as much as the read length.
        //

        pPort->LastCharSlot = pPort->ReadBufferBase +
                                      (IoGetCurrentIrpStackLocation(
                                          pPort->CurrentReadIrp
                                          )->Parameters.Read.Length
                                       - 1);

        //
        // Mark the irp as being in a cancelable state.
        //

        IoSetCancelRoutine(pPort->CurrentReadIrp, SerialCancelCurrentRead);
            
            

        //
        // Increment the reference count twice.
        //
        // Once for the Isr owning the irp and once
        // because the cancel routine has a reference
        // to it.
        //

        SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);
        SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

        updateChar->Completed = FALSE;

    } 
	else 
	{
        updateChar->Completed = TRUE;

    }

    return FALSE;

}
//
// We use this structure only to communicate to the synchronization
// routine when we are switching to the resized buffer.
//
typedef struct _SERIAL_RESIZE_PARAMS 
{
    PPORT_DEVICE_EXTENSION pPort;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;
    ULONG NewBufferSize;
    ULONG NumberMoved;

} SERIAL_RESIZE_PARAMS,*PSERIAL_RESIZE_PARAMS;


NTSTATUS
SerialResizeBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will process the resize buffer request.
    If size requested for the RX buffer is smaller than
    the current buffer then we will simply return
    STATUS_SUCCESS.  (We don't want to make buffers smaller.
    If we did that then we all of a sudden have "overrun"
    problems to deal with as well as flow control to deal
    with - very painful.)  We ignore the TX buffer size
    request since we don't use a TX buffer.

Arguments:

    pPort - Pointer to the device extension for the port.

Return Value:

    STATUS_SUCCESS if everything worked out ok.
    STATUS_INSUFFICIENT_RESOURCES if we couldn't allocate the
    memory for the buffer.

--*/

{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
    PSERIAL_QUEUE_SIZE rs = pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer;

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp);
                                   
    PVOID newBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    pPort->CurrentReadIrp->IoStatus.Information = 0L;
    pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

    if (rs->InSize <= pPort->BufferSize) 
	{
        //
        // Nothing to do.  We don't make buffers smaller.  Just
        // agree with the user.  We must deallocate the memory
        // that was already allocated in the ioctl dispatch routine.
        //

        SpxFreeMem(newBuffer);
    } 
	else 
	{

        SERIAL_RESIZE_PARAMS rp;
        KIRQL controlIrql;

        //
        // Hmmm, looks like we actually have to go
        // through with this.  We need to move all the
        // data that is in the current buffer into this
        // new buffer.  We'll do this in two steps.
        //
        // First we go up to dispatch level and try to
        // move as much as we can without stopping the
        // ISR from running.  We go up to dispatch level
        // by acquiring the control lock.  We do it at
        // dispatch using the control lock so that:
        //
        //    1) We can't be context switched in the middle
        //       of the move.  Our pointers into the buffer
        //       could be *VERY* stale by the time we got back.
        //
        //    2) We use the control lock since we don't want
        //       some pesky purge irp to come along while
        //       we are trying to move.
        //
        // After the move, but while we still hold the control
        // lock, we synch with the ISR and get those last
        // (hopefully) few characters that have come in since
        // we started the copy.  We switch all of our pointers,
        // counters, and such to point to this new buffer.  NOTE:
        // we need to be careful.  If the buffer we were using
        // was not the default one created when we initialized
        // the device (i.e. it was created via a previous IRP of
        // this type), we should deallocate it.
        //

        rp.pPort = pPort;
        rp.OldBuffer = pPort->InterruptReadBuffer;
        rp.NewBuffer = newBuffer;
        rp.NewBufferSize = rs->InSize;

        KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

        rp.NumberMoved = SerialMoveToNewIntBuffer(pPort, newBuffer);
                             

        KeSynchronizeExecution(
            pCard->Interrupt,
            SerialUpdateAndSwitchToNew,
            &rp
            );

        KeReleaseSpinLock(
            &pPort->ControlLock,
            controlIrql
            );

        //
        // Free up the memory that the old buffer consumed.
        //

        SpxFreeMem(rp.OldBuffer);

    }

    return STATUS_SUCCESS;

}

ULONG
SerialMoveToNewIntBuffer(
    PPORT_DEVICE_EXTENSION pPort,
    PUCHAR NewBuffer
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the "new" buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    pPort - A pointer to the device extension.
    NewBuffer - Where the characters are to be move to.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    ULONG numberOfCharsMoved = pPort->CharsInInterruptBuffer;

    if(numberOfCharsMoved) 
	{

        //
        // This holds the number of characters between the first
        // readable character and the last character we will read or
        // the real physical end of the buffer (not the last readable
        // character).
        //
        ULONG firstTryNumberToGet = (pPort->LastCharSlot -
                                     pPort->FirstReadableChar) + 1;

        if(firstTryNumberToGet >= numberOfCharsMoved) 
		{
            //
            // The characters don't wrap.
            //

            RtlMoveMemory(
                NewBuffer,
                pPort->FirstReadableChar,
                numberOfCharsMoved
                );

            if((pPort->FirstReadableChar+(numberOfCharsMoved-1)) 
				== pPort->LastCharSlot) 
			{
                pPort->FirstReadableChar = pPort->InterruptReadBuffer;
            } 
			else 
			{
                pPort->FirstReadableChar += numberOfCharsMoved;
            }
        } 
		else 
		{
            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(NewBuffer, pPort->FirstReadableChar, firstTryNumberToGet);
                
               

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                NewBuffer+firstTryNumberToGet,
                pPort->InterruptReadBuffer,
                numberOfCharsMoved - firstTryNumberToGet
                );

            pPort->FirstReadableChar = pPort->InterruptReadBuffer +
                                   numberOfCharsMoved - firstTryNumberToGet;

        }

    }

    return numberOfCharsMoved;

}

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a pointer to the buffer we are moving
              to, and a count of the number of characters
              that we previously copied into the new buffer, and the
              actual size of the new buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_RESIZE_PARAMS params = Context;
    PPORT_DEVICE_EXTENSION pPort = params->pPort;
    ULONG tempCharsInInterruptBuffer = pPort->CharsInInterruptBuffer;

    ASSERT(pPort->CharsInInterruptBuffer >= params->NumberMoved);

    //
    // We temporarily reduce the chars in interrupt buffer to
    // "fool" the move routine.  We will restore it after the
    // move.
    //

    pPort->CharsInInterruptBuffer -= params->NumberMoved;

    if(pPort->CharsInInterruptBuffer) 
	{
        SerialMoveToNewIntBuffer(
            pPort,
            params->NewBuffer + params->NumberMoved
            );

    }

    pPort->CharsInInterruptBuffer = tempCharsInInterruptBuffer;


    pPort->LastCharSlot = params->NewBuffer + (params->NewBufferSize - 1);
    pPort->FirstReadableChar = params->NewBuffer;
    pPort->ReadBufferBase = params->NewBuffer;
    pPort->InterruptReadBuffer = params->NewBuffer;
    pPort->BufferSize = params->NewBufferSize;

    //
    // We *KNOW* that the new interrupt buffer is larger than the
    // old buffer.  We don't need to worry about it being full.
    //

    pPort->CurrentCharSlot = pPort->InterruptReadBuffer + pPort->CharsInInterruptBuffer;

    //
    // We set up the default xon/xoff limits.
    //

    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif                                 

    //
    // Since we (essentially) reduced the percentage of the interrupt
    // buffer being full, we need to handle any flow control.
    //

    SerialHandleReducedIntBuffer(pPort);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\spx_disp.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Specialix Generic Dispatch Functions.				*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	29th September 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Dispatch entry points are routed here				*/
/*					for PnP/Power filtering before being				*/
/*					passed to the main functions:						*/
/*						Spx_Flush										*/
/*						Spx_Write										*/
/*						Spx_Read										*/
/*						Spx_IoControl									*/
/*						Spx_InternalIoControl							*/
/*						Spx_CreateOpen									*/
/*						Spx_Close										*/
/*						Spx_Cleanup										*/
/*						Spx_QueryInformationFile						*/
/*						Spx_SetInformationFile							*/
/*																		*/
/*						Spx_UnstallIRPs									*/
/*						Spx_KillStalledIRPs								*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	29/09/98 NPV	Creation.

*/

#define FILE_ID	SPX_DISP_C		// File ID for Event Logging see SPX_DEFS.H for values.

/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp);



/*****************************************************************************
********************************   Spx_Flush   *******************************
*****************************************************************************/

NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialFlush(pDevObject,pIrp);

	return(status);

} // End Spx_Flush 

/*****************************************************************************
********************************   Spx_Write   *******************************
*****************************************************************************/

NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialWrite(pDevObject,pIrp);

	return(status);

} // End Spx_Write 

/*****************************************************************************
********************************   Spx_Read   ********************************
*****************************************************************************/

NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialRead(pDevObject,pIrp);

	return(status);

} // End Spx_Read 

/*****************************************************************************
******************************   Spx_IoControl   *****************************
*****************************************************************************/

NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialIoControl(pDevObject,pIrp);

	return(status);

} // End Spx_IoControl 

/*****************************************************************************
**************************   Spx_InternalIoControl   *************************
*****************************************************************************/

NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = Spx_SerialInternalIoControl(pDevObject,pIrp);

	return(status);

} // Spx_InternalIoControl 

/*****************************************************************************
*****************************   Spx_CreateOpen   *****************************
*****************************************************************************/

NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;


	if(pDevObject->DeviceType != FILE_DEVICE_SERIAL_PORT)	
	{
	    pIrp->IoStatus.Status = STATUS_ACCESS_DENIED;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return(STATUS_ACCESS_DENIED);
	}


	// Lock out state Query stop and Query remove IRPs from changing the state 
	// of the port part way through openening the port.
	ExAcquireFastMutex(&pPort->OpenMutex);
	
	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		if(pPort->DeviceIsOpen)					// Is port already open? 
		{
			status = STATUS_ACCESS_DENIED;		// Yes, deny access 
			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
		}
		else
			status = SerialCreateOpen(pDevObject,pIrp);

	}

	ExReleaseFastMutex(&pPort->OpenMutex);

	return(status);

} // End Spx_CreateOpen 

/*****************************************************************************
********************************   Spx_Close   *******************************
*****************************************************************************/

NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)		// Successful close if device is removed 
		{
			pPort->BufferSize = 0;
			SpxFreeMem(pPort->InterruptReadBuffer);
			pPort->InterruptReadBuffer = NULL;
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialClose(pDevObject,pIrp);

	return(status);

} // End Spx_Close 

/*****************************************************************************
*******************************   Spx_Cleanup   ******************************
*****************************************************************************/

NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)
		{
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		Spx_KillStalledIRPs(pDevObject);
		status = SerialCleanup(pDevObject,pIrp);
	}

	return(status);

} // End Spx_Cleanup 

/*****************************************************************************
************************   Spx_QueryInformationFile   ************************
*****************************************************************************/

NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	status = SerialQueryInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_QueryInformationFile 

/*****************************************************************************
*************************   Spx_SetInformationFile   *************************
*****************************************************************************/

NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialSetInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_SetInformationFile 

/*****************************************************************************
*****************************                    *****************************
*****************************   Spx_FilterIRPs   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	Filter incoming SERIAL IRPs (except PNP and POWER) to check
				the current PNP/POWER states and return an NT status code to
				just complete the IRP if device is blocked for the following reasons:

parameters:		pDevObject points to the device object for this IRP
				pIrp points to the IRP to filter

returns:		NT Status Code

*/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	KIRQL					oldIrqlFlags;
	KIRQL					StalledOldIrql;
	LARGE_INTEGER delay;

	if(pIrpStack->MajorFunction == IRP_MJ_PNP)			// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_POWER)		// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_SYSTEM_CONTROL)	// Don't filter WMI IRPs 
		return(STATUS_SUCCESS);


	if(pPort->IsFDO)									// Don't filter card IRPs	
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction != IRP_MJ_PNP)
	{
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
	}


	KeAcquireSpinLock(&pPort->PnpPowerFlagsLock, &oldIrqlFlags);

	if(pPort->PnpPowerFlags & PPF_REMOVED)				// Has this object been "removed"? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		return(STATUS_NO_SUCH_DEVICE);
	}

	if(pPort->PnpPowerFlags & PPF_REMOVE_PENDING)		// Removing the device? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_DELETE_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_DELETE_PENDING);
	}


	if((pPort->PnpPowerFlags & PPF_STOP_PENDING)		// Device stopping?
	||(!(pPort->PnpPowerFlags & PPF_POWERED))			// Device not powered?
	||(!(pPort->PnpPowerFlags & PPF_STARTED)))			// Device not started?
	{
		KIRQL	oldIrql;

		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);


		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		
		while(pPort->UnstallingFlag) // We do not wish to add any more IRPs to the queue if have started unstalling those currently queued.
		{
			KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
			
			KeDelayExecutionThread(KernelMode, FALSE, &delay);

			KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		}

		pPort->UnstallingFlag = TRUE;

		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	


		IoAcquireCancelSpinLock(&oldIrql);

		if(pIrp->Cancel)				// Has IRP been cancelled? 
		{								// Yes 
			IoReleaseCancelSpinLock(oldIrql);
			SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_CANCELLED\n",
				PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
				
			return(STATUS_CANCELLED);
		}

// Mark the IRP as pending and queue on the stalled list... 
		pIrp->IoStatus.Status = STATUS_PENDING;		// Mark IRP as pending 
		IoMarkIrpPending(pIrp);
		InsertTailList(&pPort->StalledIrpQueue,&pIrp->Tail.Overlay.ListEntry);
		IoSetCancelRoutine(pIrp,Spx_FilterCancelQueued);
		IoReleaseCancelSpinLock(oldIrql);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_PENDING);
	}

	KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

	return(STATUS_SUCCESS);

} // End Spx_FilterIRPs 

/*****************************************************************************
*****************************                     ****************************
*****************************   Spx_UnstallIRPs   ****************************
*****************************                     ****************************
******************************************************************************

prototype:		VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)

description:	Restart all IRPs stored on the temporary stalled list.

parameters:		pPort points to the device extension to unstall

returns:		None

*/

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)
{
	PLIST_ENTRY			pIrpLink;
	PIRP				pIrp;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		pDevObj;
	PDRIVER_OBJECT		pDrvObj;
	KIRQL				oldIrql;
	KIRQL				StalledOldIrql;
	LARGE_INTEGER		delay;

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Entry\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));


	KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	
	while(pPort->UnstallingFlag)	// We do not unstall any queued IRPs if some one is just about to be added to the queue.
	{
		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

		delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
		
		KeDelayExecutionThread(KernelMode, FALSE, &delay);

		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	}

	pPort->UnstallingFlag = TRUE;

	KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	





	IoAcquireCancelSpinLock(&oldIrql);
	pIrpLink = pPort->StalledIrpQueue.Flink;

// Restart each waiting IRP on the stalled list... 

	while(pIrpLink != &pPort->StalledIrpQueue)
	{
		pIrp = CONTAINING_RECORD(pIrpLink,IRP,Tail.Overlay.ListEntry);
		pIrpLink = pIrp->Tail.Overlay.ListEntry.Flink;
		RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
		pDevObj = pIrpStack->DeviceObject;
		pDrvObj = pDevObj->DriverObject;
		IoSetCancelRoutine(pIrp,NULL);
		IoReleaseCancelSpinLock(oldIrql);

		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Unstalling IRP 0x%X, Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,
			pIrp,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		pDrvObj->MajorFunction[pIrpStack->MajorFunction](pDevObj,pIrp);
		IoAcquireCancelSpinLock(&oldIrql);
	}

	IoReleaseCancelSpinLock(oldIrql);

	ClearUnstallingFlag(pPort);

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Exit\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

} // End Spx_UnstallIRPs 

/*****************************************************************************
*************************                            *************************
*************************   Spx_FilterCancelQueued   *************************
*************************                            *************************
******************************************************************************

prototype:		VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)

description:	Routine to cancel IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue
				pIrp points to the IRP to cancel

returns:		None

*/

VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PIO_STACK_LOCATION		pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pIrp->IoStatus.Status = STATUS_CANCELLED;
	pIrp->IoStatus.Information = 0;

	RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
	IoReleaseCancelSpinLock(pIrp->CancelIrql);

} // End Spx_FilterCancelQueued 


/*****************************************************************************
***************************                         **************************
***************************   Spx_KillStalledIRPs   **************************
***************************                         **************************
******************************************************************************

prototype:		VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)

description:	Kill all IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue

returns:		None

*/

VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PDRIVER_CANCEL			cancelRoutine;
	KIRQL					cancelIrql;

	IoAcquireCancelSpinLock(&cancelIrql);

// Call the cancel routine of all IRPs queued on the stalled list... 

	while(!IsListEmpty(&pPort->StalledIrpQueue))
	{
		PIRP	pIrp = CONTAINING_RECORD(pPort->StalledIrpQueue.Blink, IRP, Tail.Overlay.ListEntry);

		RemoveEntryList(pPort->StalledIrpQueue.Blink);
		cancelRoutine = pIrp->CancelRoutine;		// Get the cancel routine for this IRP 
		pIrp->CancelIrql = cancelIrql;
		pIrp->CancelRoutine = NULL;
		pIrp->Cancel = TRUE;

		cancelRoutine(pDevObj,pIrp);				// Call the cancel routine 

		IoAcquireCancelSpinLock(&cancelIrql);
	}

	IoReleaseCancelSpinLock(cancelIrql);

} // End Spx_KillStalledIRPs 

// End of SPX_DISP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\spx_iioc.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Dispatch Entry for INTERNAL IOCTLs					*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Internal IOCTLs support the SERENUM					*/
/*					attached serial device enumerator:					*/
/*					IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS				*/
/*					IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS				*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#define FILE_ID	SPX_IIOC_C		// File ID for Event Logging see SPX_DEFS.H for values.



/*****************************************************************************
**********************                                 ***********************
**********************   Spx_SerialInternalIoControl   ***********************
**********************                                 ***********************
******************************************************************************
	
prototype:		NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)

description:	Internal IOCTL dipatch routine.
				These IOCTLs are only issued from know trusted system components such as
				the SERENUM.SYS attached serial device enumerator and the mouse driver:

parameters:		pDevObj points to the device object structure
				pIrp points to the IOCTL Irp packet

returns:		STATUS_SUCCESS

*/

NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
	NTSTATUS				status;
	PIO_STACK_LOCATION		pIrpStack;
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	KIRQL					OldIrql;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Entry\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	if(SerialCompleteIfError(pDevObj, pIrp) != STATUS_SUCCESS)
		return(STATUS_CANCELLED);

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0L;
	status = STATUS_SUCCESS;

	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
	case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
	case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS:
		{
			SERIAL_BASIC_SETTINGS	Basic;
			PSERIAL_BASIC_SETTINGS	pBasic;
			SERIAL_IOCTL_SYNC	S;

			if (pIrpStack->Parameters.DeviceIoControl.IoControlCode 
				== IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS)
			{
          
/* Check the buffer size... */

				if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength 
					< sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

/* Everything is 0 -- timeouts and flow control. */
/* If we add additional features, this zero memory method may not work. */

				RtlZeroMemory(&Basic,sizeof(SERIAL_BASIC_SETTINGS));
				pIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;

/* Save off the old settings... */

				RtlCopyMemory(&pBasic->Timeouts, &pPort->Timeouts, sizeof(SERIAL_TIMEOUTS));
				RtlCopyMemory(&pBasic->HandFlow, &pPort->HandFlow, sizeof(SERIAL_HANDFLOW));

/* Point to our new settings... */

				pBasic = &Basic;
			}
			else
			{
				if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;
			}

			KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);

/* Set the timeouts...	*/

			RtlCopyMemory(&pPort->Timeouts, &pBasic->Timeouts, sizeof(SERIAL_TIMEOUTS));

/* Set flowcontrol... */

			S.pPort = pPort;
			S.Data = &pBasic->HandFlow;
			XXX_SetHandFlow(pPort, &S);		/* Set the handflow for specific hardware */

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

	default:
		status = STATUS_INVALID_PARAMETER;
		break;
	}

	pIrp->IoStatus.Status = status;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Complete\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	IoCompleteRequest(pIrp,0);

	return(status);

} /* Spx_SerialInternalIoControl */
                                                        
/* End of SPX_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\spx_powr.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_POWER.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Handle all Power IRPS.												*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/
#define FILE_ID	SPX_POWR_C		// File ID for Event Logging see SPX_DEFS.H for values.

BOOLEAN	BREAK_ON_POWER_UP = FALSE;

// Prototypes
NTSTATUS Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp);
NTSTATUS Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp);
NTSTATUS Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp);
// End of prototypes


// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchPower)

#pragma alloc_text(PAGE, Spx_Card_FDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_CardSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_CardSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD3)

#pragma alloc_text(PAGE, Spx_Port_PDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_PortQuerySystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD3)

#endif // ALLOC_PRAGMA


//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	Routine Description:
//		The power dispatch routine determine if the IRP is for a card or a port and 
//		then call the correct dispatch routine.
//
//	Arguments:
//		pDevObject	- pointer to a device object.
//		pIrp		- pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		CommonData	= (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(CommonData->IsFDO) 
        status = Spx_Card_FDO_DispatchPower(pDevObject, pIrp);
	else 
        status = Spx_Port_PDO_DispatchPower(pDevObject, pIrp);

    return status;
}	// Spx_DispatchPower


	
//////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//		The power dispatch routine to handle power IRPs for card devices.
//
//	Arguments:
//		pFDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pFDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:	// Driver MUST never fail this IRP.
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetSystemPowerState(pFDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetDevicePowerState(pFDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break; 
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
			
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			status = STATUS_NOT_SUPPORTED;
			break;

	}

	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_Card_FDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetSystemPowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetSystemPowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetSystemPowerState


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetDevicePowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetDevicePowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D0.\n", 
			PRODUCT_NAME, pCard->CardNumber));
		
		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D0.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D1.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D2.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D3.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D3.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}


	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetDevicePowerState




//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD0 -  Sets power state D0 for Card - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD0 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	status = Spx_PowerWaitForDriverBelow(pCard->LowerDeviceObject, pIrp);

	
#if DBG
	if(BREAK_ON_POWER_UP)
	{
		BREAK_ON_POWER_UP = FALSE;
	    KdPrint(("%s: Breaking debugger whilst powering up Card %d to debug after a hibernate\n", PRODUCT_NAME, pCard->CardNumber)); 
		DbgBreakPoint();
	}
#endif

	SetPnpPowerFlags(pCard, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_CardPowerUp(pCard)))		// RESTORE HARDWARE STATE HERE & START CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD0;	// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_SetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD3 -  Sets power state D3 for Card - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD3 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	ClearPnpPowerFlags(pCard, PPF_POWERED);		

	if(SPX_SUCCESS(pIrp->IoStatus.Status	= XXX_CardPowerDown(pCard))) // SAVE HARDWARE STATE HERE & STOP CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);						// Ready for next power IRP.
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);	// Pass IRP on down.

	return status;
}	// Spx_SetPowerStateD3







	
//////////////////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//	The power dispatch routine to handle power IRPs for port devices.
//
//	Arguments:
//		pPDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pPDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetSystemPowerState(pPDO, pIrp);
				
			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetDevicePowerState(pPDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
				
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortQuerySystemPowerState(pPDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));

				switch(pIrpStack->Parameters.Power.State.DeviceState)
				{
				case PowerDeviceD0:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to power state D0.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = STATUS_SUCCESS;
					break;

				case PowerDeviceD1:
				case PowerDeviceD2:
				case PowerDeviceD3:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to low power state D1, D2 or D3.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = XXX_PortQueryPowerDown(pPort);
					break;

				default:
					status = STATUS_SUCCESS;
					break;
					
				}

				break;
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));
				break;
			}

			pIrp->IoStatus.Status = status;
			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_SUPPORTED;
			break;
	}

	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_Port_PDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortSetSystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetSystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetSystemPowerState

//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortQuerySystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortQuerySystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortQuerySystemPowerState



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetDevicePowerState 
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetDevicePowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D0.\n", 
			PRODUCT_NAME, pPort->PortNumber));
		
		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D0.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D1.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D2.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D3.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D3.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetDevicePowerState 


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD0 -  Sets power state D0 for Port - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD0 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	SetPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerUp(pPort)))		// RESTORE HARDWARE STATE HERE & START PORT
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pPort->DeviceState = PowerDeviceD0;	// Store new power state.
		Spx_UnstallIrps(pPort);				// Restart any queued IRPs (from a previous start)  
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD3 -  Sets power state D3 for Port - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD3 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	ClearPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerDown(pPort)))	// SAVE HARDWARE STATE HERE & STOP PORT
	{   
		// Inform Power Manager the of the new power state. 
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);
		pPort->DeviceState  = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD3



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PowerWaitForDriverBelow -  Waits for lower driver.
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp)
{
	KEVENT		EventWaitLowerDrivers;
	NTSTATUS	status;

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCopyCurrentIrpStackLocationToNext(pIrp);								// Copy parameters to the stack below 
	KeInitializeEvent(&EventWaitLowerDrivers, SynchronizationEvent, FALSE);	// Initialise event if need to wait 
	IoSetCompletionRoutine(pIrp, Spx_DispatchPnpPowerComplete, &EventWaitLowerDrivers, TRUE, TRUE, TRUE);

	if((status = PoCallDriver(pLowerDevObj, pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&EventWaitLowerDrivers, Executive, KernelMode, FALSE, NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} // Spx_PowerWaitForDriverBelow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\utils.c ===
#include "precomp.h"			
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains code that perform queueing and completion
    manipulation on requests.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer
    );


VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )

/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    DeviceObject - A pointer to the serial device object.

    QueueToClean - A pointer to the queue which we're going to clean out.

    CurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{
    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We acquire the cancel spin lock.  This will prevent the irps from moving around.
    //
    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Clean the list from back to front.
    //
    while(!IsListEmpty(QueueToClean)) 
	{
        PIRP currentLastIrp = CONTAINING_RECORD(QueueToClean->Blink, IRP, Tail.Overlay.ListEntry);
                                  
        RemoveEntryList(QueueToClean->Blink);
		SpxIRPCounter(pPort, currentLastIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine(DeviceObject, currentLastIrp);
            
        IoAcquireCancelSpinLock(&cancelIrql);
    }

    //
    // The queue is clean.  Now go after the current if it's there.
    //
    if(*CurrentOpIrp) 
	{
        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //
        if(cancelRoutine) 
		{
            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancelable state.  We simply
            // mark it as canceled and call the cancel routine for it.
            //
            cancelRoutine(DeviceObject, *CurrentOpIrp);

        } 
		else 
		{
            IoReleaseCancelSpinLock(cancelIrql);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(cancelIrql);
    }

}

VOID
SerialGetNextIrp(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

Return Value:

    None.

--*/

{

    PIRP oldIrp;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    oldIrp = *CurrentOpIrp;

    if(CompleteCurrent) 
        ASSERT(!oldIrp->CancelRoutine);

    //
    // Check to see if there is a new irp to start up.
    //
    if(!IsListEmpty(QueueToProcess)) 
	{
        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(headOfList, IRP, Tail.Overlay.ListEntry);
		SpxIRPCounter(pPort, *CurrentOpIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    } 
	else 
	{
        *CurrentOpIrp = NULL;
    }

    *NextIrp = *CurrentOpIrp;
    IoReleaseCancelSpinLock(oldIrql);

    if(CompleteCurrent)
	{
		SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);
	}
}

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    pPort - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //
    SERIAL_DEC_REFERENCE(*CurrentOpIrp);

    if(SynchRoutine) 
        KeSynchronizeExecution(pCard->Interrupt, SynchRoutine, pPort);


    //
    // Try to run down all other references to this irp.
    //
    SerialRundownIrpRefs(CurrentOpIrp, IntervalTimer, TotalTimer);

    //
    // See if the ref count is zero after trying to kill everybody else.
    //
    if(!SERIAL_REFERENCE_COUNT(*CurrentOpIrp)) 
	{
        PIRP newIrp;

        IoReleaseCancelSpinLock(IrqlForRelease);

        //
        // The ref count was zero so we should complete this
        // request.
        //
        // The following call will also cause the current irp to be
        // completed.
        //

        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if(StatusToUse == STATUS_CANCELLED) 
            (*CurrentOpIrp)->IoStatus.Information = 0;


        if(GetNextIrp) 
		{
            GetNextIrp(pPort, CurrentOpIrp, QueueToProcess, &newIrp, TRUE);
               
            if(newIrp) 
                Starter(pPort);

        } 
		else 
		{
            PIRP oldIrp = *CurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //
            *CurrentOpIrp = NULL;

			SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(IrqlForRelease);
    }

}

VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL
    )

/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

Return Value:

    None.

--*/


{

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if((*CurrentOpIrp)->CancelRoutine) 
	{
        SERIAL_DEC_REFERENCE(*CurrentOpIrp);

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    }

    if(IntervalTimer) 
	{

        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(IntervalTimer)) 
            SERIAL_DEC_REFERENCE(*CurrentOpIrp);
    }

    if(TotalTimer) 
	{

        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(TotalTimer)) 
            SERIAL_DEC_REFERENCE(*CurrentOpIrp);

    }

}

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    )

/*++

Routine Description:

    This routine is used to either start or queue any requst
    that can be queued in the driver.

Arguments:

    pPort - Points to the serial device extension.

    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.

    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.

    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.

    Starter - The routine to call if the queue is empty.

Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).


--*/

{
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    //

    if(IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_WRITE)
	{
        pPort->TotalCharsQueued += IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length;
    } 
	else
	{
		if((IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_DEVICE_CONTROL)
			&& ((IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
            || (IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))) 
		{
			pPort->TotalCharsQueued++;
		}
	}

    if((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp))
    {
        //
        // There were no current operation.  Mark this one as current and start it up.
        //
        *CurrentOpIrp = Irp;

        IoReleaseCancelSpinLock(oldIrql);

        return Starter(pPort);
	} 
	else 
	{
        //
        // We don't know how long the irp will be in the queue.  So we need to handle cancel.
        //
        if(Irp->Cancel) 
		{
            IoReleaseCancelSpinLock(oldIrql);

            Irp->IoStatus.Status = STATUS_CANCELLED;

			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp, 0);
            
			return STATUS_CANCELLED;

        } 
		else 
		{
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            InsertTailList(QueueToExamine, &Irp->Tail.Overlay.ListEntry);
                
            IoSetCancelRoutine(Irp, SerialCancelQueued);
                
			SpxIRPCounter(pPort, Irp, IRP_QUEUED);	// Increment counter for performance stats.

            IoReleaseCancelSpinLock(oldIrql);

            return STATUS_PENDING;
        }
    }

}

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel Irps that currently reside on
    a queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

	SpxIRPCounter(pPort, Irp, IRP_DEQUEUED);	// Decrement counter for performance stats.

    //
    // If this is a write irp then take the amount of characters
    // to write and subtract it from the count of characters to write.
    //

    if(irpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->TotalCharsQueued -= irpSp->Parameters.Write.Length;
    } 
	else
	{
		if(irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
		{
			//
			// If it's an immediate then we need to decrement the
			// count of chars queued.  If it's a resize then we
			// need to deallocate the pool that we're passing on
			// to the "resizing" routine.
			//

			if((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
				|| (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)) 
			{
				pPort->TotalCharsQueued--;
			} 
			else 
			{
				if(irpSp->Parameters.DeviceIoControl.IoControlCode ==IOCTL_SERIAL_SET_QUEUE_SIZE) 
				{
					//
					// We shoved the pointer to the memory into the
					// the type 3 buffer pointer which we KNOW we
					// never use.
					//

					ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

					SpxFreeMem(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

					irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
				}
			}

		}
	}

    IoReleaseCancelSpinLock(Irp->CancelIrql);

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_SERIAL_INCREMENT);
  
}

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to test.

Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    if((pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pPort->ErrorWord) 
	{
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.
        //
        if( (irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL)
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode != IOCTL_SERIAL_GET_COMMSTATUS) ) 
		{
            status = STATUS_CANCELLED;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

	       	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp, 0);
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\spx_pnp.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_PNP.C															*
*																						*
*	Creation:		27th September 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Generic Plug and Play Functions	to handle PnP IRPS.					*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/

#define FILE_ID		SPX_PNP_C		// File ID for Event Logging see SPX_DEFS.H for values.

 
/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp);
NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard);
NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp);
NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort);
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject);


// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_AddDevice)
#pragma alloc_text (PAGE, Spx_DispatchPnp)

#pragma alloc_text (PAGE, Spx_Card_FDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Card_StartDevice)
#pragma alloc_text (PAGE, Spx_Card_StopDevice)
#pragma alloc_text (PAGE, Spx_Card_RemoveDevice)

#pragma alloc_text (PAGE, Spx_CallDriverBelow)

#pragma alloc_text (PAGE, Spx_Port_PDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Port_StartDevice)
#pragma alloc_text (PAGE, Spx_Port_StopDevice)
#pragma alloc_text (PAGE, Spx_Port_RemoveDevice)

#pragma alloc_text (PAGE, Spx_EnumPorts)
#pragma alloc_text (PAGE, Spx_DoExternalNaming)
#pragma alloc_text (PAGE, Spx_GetExternalName)
#pragma alloc_text (PAGE, Spx_RemoveExternalNaming)
#pragma alloc_text (PAGE, Spx_CreatePortInstanceID)
#endif


#include <initguid.h>
#include <ntddser.h>


/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_AddDevice   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)

description:	Create a functional device object (FDO) for the specified card physical device object.

parameters:		pDriver point to the driver object
				pPDO points to a card physical device object (PDO)

returns:		STATUS_SUCCESS
				STATUS_NO_MORE_ENTRIES
*/

NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)
{
	NTSTATUS				status = STATUS_SUCCESS;
	PDEVICE_OBJECT			pDevObject = NULL;
	PCARD_DEVICE_EXTENSION	pCard = NULL;
	PDEVICE_OBJECT			pLowerDevObject = NULL;
	static ULONG			CardNumber = 0;
	ULONG					i = 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_AddDevice.\n", PRODUCT_NAME));

	if(pPDO == NULL)
	{
		SpxDbgMsg(SPX_MISC_DBG, ("%s: In Spx_AddDevice - No more entries.\n", PRODUCT_NAME));
		return(STATUS_NO_MORE_ENTRIES);
	}

/* Create the device object... */

	status = IoCreateDevice(pDriverObject,
							sizeof(CARD_DEVICE_EXTENSION),
							NULL, 							// Doesn't need a name.
							FILE_DEVICE_CONTROLLER, 
							FILE_DEVICE_SECURE_OPEN, 
							TRUE, 
							&pDevObject);

	if(!SPX_SUCCESS(status))
	{
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed for card %d. CardExt at 0x%X.\n",
			PRODUCT_NAME,CardNumber++,&pDevObject));

		sprintf(szErrorMsg, "Card %d: Failed IoCreateDevice.", CardNumber++);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pDriverObject,					// Driver Object
						NULL,							// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		if(pDevObject)					// Clean up Device Object
			IoDeleteDevice(pDevObject);

		SpxDbgMsg(SPX_ERRORS, ("%s: Leaving Spx_AddDevice - FAILURE.\n", PRODUCT_NAME));
		return(status);
	}


	ASSERT(pDevObject != NULL);

/* Initialise the device extension... */

	pCard = pDevObject->DeviceExtension;							/* Point to card extension */
	RtlZeroMemory(pCard,sizeof(CARD_DEVICE_EXTENSION));				/* Zero extension structure */

	pDevObject->Flags |= DO_POWER_PAGABLE;				// Get power IRPs at IRQL PASSIVE_LEVEL 
	pDevObject->Flags &= ~DO_DEVICE_INITIALIZING;
	pLowerDevObject = IoAttachDeviceToDeviceStack(pDevObject,pPDO);	/* Attach to device stack */
	ASSERT(pLowerDevObject != NULL);

	KeInitializeSpinLock(&pCard->PnpPowerFlagsLock);	/* Initialise the PNP flags lock */
	ClearPnpPowerFlags(pCard,PPF_STARTED);				/* Not started yet */
	ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);			/* Not pending a stop */
	ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);		/* Not pending a remove */

	pCard->IsFDO = TRUE;								/* Card Object is a Functional Device Object (FDO) */
	pCard->CardNumber = CardNumber++;					/* Enumerate card devices */
	pCard->DeviceObject = pDevObject;					/* Back pointer to device object */
	pCard->LowerDeviceObject= pLowerDevObject;			/* Pointer to device below in device stack */
	pCard->DriverObject = pDriverObject;				/* Pointer to driver object */
	pCard->PDO = pPDO;									/* Pointer to card physical device object (PDO) */
    pCard->DeviceState = PowerDeviceD0;					/* Initial power state */
	pCard->SystemState = PowerSystemWorking;			/* System in full power State */
	pCard->NumPDOs = 0;									/* Initialise attached port PDO pointers */

	for(i=0; i<PRODUCT_MAX_PORTS; i++)
		pCard->AttachedPDO[i] = NULL;

	SetPnpPowerFlags(pCard,PPF_POWERED);				/* Initially assumed we are powered */

	XXX_CardInit(pCard);								/* Initialise non-hardware extension fields */

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Leaving Spx_AddDevice - SUCCESS.\n",PRODUCT_NAME));

	return(status);

} /* Spx_AddDevice */

/*****************************************************************************
****************************                     *****************************
****************************   Spx_DispatchPnp   *****************************
****************************                     *****************************
******************************************************************************

prototype:		NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	The plug and play dispatch routine.
				Determines whether IRP is for a card or a port and calls other functions to handle it. 

parameters:		pDevObject points to a device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PCOMMON_OBJECT_DATA		CommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
	NTSTATUS				status = STATUS_SUCCESS;
	
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(CommonData->IsFDO)									/* Functional Device Object ? */
		status = Spx_Card_FDO_DispatchPnp(pDevObject,pIrp);	/* Yes, must be card device */
	else	
		status = Spx_Port_PDO_DispatchPnp(pDevObject,pIrp);	/* No, must be port device */

	return(status);

} /* Spx_DispatchPnp */

/*****************************************************************************
************************                              ************************
************************   Spx_Card_FDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)

description:	The plug and play dispatch routine to handle IRPs for card devices.

parameters:		pDevObject points to a card device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION		pCard = pFDO->DeviceExtension;
	PDEVICE_OBJECT				pLowerDevObj = pCard->LowerDeviceObject;
	NTSTATUS					status;
	PDEVICE_CAPABILITIES		pDevCaps = NULL;
	PIO_STACK_LOCATION			pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	PDEVICE_RELATIONS			pRelations = NULL;
	ULONG						length = 0;
	ULONG						i = 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 


	switch(pIrpStack->MinorFunction)
	{	

/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
	
	case	IRP_MN_START_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

/* If successful, then start the card... */

			if(NT_SUCCESS(status))		// Must use NT_SUCCESS() here!!
				status = Spx_Card_StartDevice(pFDO,pIrp);	/* Start the card */

			pIrp->IoStatus.Status = status;
			pIrp->IoStatus.Information = 0;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_RELATIONS:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			
			if(pIrpStack->Parameters.QueryDeviceRelations.Type != BusRelations)	/* Only handle BusRelations */
			{
				SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: IRP_MN_QUERY_DEVICE_RELATIONS for Card - Non bus.\n",PRODUCT_NAME));
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
				break;
			}

/* Enumerate devices on the card... */

			Spx_EnumPorts(pFDO);								/* Enumerate and create port device objects */

/* Tell the Plug and Play Manager any found ports... */

			i = 0;
			if(pIrp->IoStatus.Information)						/* Get current device object count */
				i = ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Count;

			length = sizeof(DEVICE_RELATIONS)+((pCard->NumPDOs+i)*sizeof(PDEVICE_OBJECT));
			if(pRelations = SpxAllocateMem(NonPagedPool, length))/* Allocate new structure */
			{

/* Copy in the device objects so far... */

				if(i)
					RtlCopyMemory
					(
						pRelations->Objects,
						((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Objects,
						i * sizeof (PDEVICE_OBJECT)
					);

				pRelations->Count = i;								/* Update device count */

/* Add specialix ports to the device relations... */

				if(pCard->NumPDOs)
				{
					for(i=0; i<PRODUCT_MAX_PORTS; i++)
					{
						if(pCard->AttachedPDO[i])					/* If object exists */
						{											/* add to table */
							pRelations->Objects[pRelations->Count++] = pCard->AttachedPDO[i];
							ObReferenceObject(pCard->AttachedPDO[i]);
						}
					}
				}

				if(pIrp->IoStatus.Information != 0)					/* If previous structure */
					SpxFreeMem((PVOID)pIrp->IoStatus.Information);	/* then free */

				pIrp->IoStatus.Information = (ULONG_PTR)pRelations;	/* Set new structure */

			}
			else
			{
				CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

				sprintf(szErrorMsg, "Card at %08X%08X: Insufficient resources.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
				
				Spx_LogMessage(	STATUS_SEVERITY_ERROR,
								pCard->DriverObject,			// Driver Object
								pCard->DeviceObject,			// Device Object (Optional)
								PhysicalZero,					// Physical Address 1
								PhysicalZero,					// Physical Address 2
								0,								// SequenceNumber
								pIrpStack->MajorFunction,		// Major Function Code
								0,								// RetryCount
								FILE_ID | __LINE__,				// UniqueErrorValue
								STATUS_SUCCESS,					// FinalStatus
								szErrorMsg);					// Error Message
			}

			pIrp->IoStatus.Status = STATUS_SUCCESS;
			IoSkipCurrentIrpStackLocation(pIrp);				/* Copy parameters to next stack */
			status = IoCallDriver(pLowerDevObj,pIrp);			/* Call driver below */
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_PNP_DEVICE_STATE   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_PNP_DEVICE_STATE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_PNP_DEVICE_STATE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_CAPABILITIES:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

	case	IRP_MN_QUERY_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

			status = STATUS_SUCCESS;
			SetPnpPowerFlags(pCard,PPF_STOP_PENDING);	// We must now expect a STOP IRP

			if(SPX_SUCCESS(status))						// If we can stop, pass IRP on down
			{
				pIrp->IoStatus.Status = status;
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
			}
			else										// If we can't then complete
			{
				pIrp->IoStatus.Status = status;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			}
			break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_CANCEL_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

			if(NT_SUCCESS(status))
			{
				// we return the device to its working state here.
				ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);	// We are no longer expecting a STOP IRP.
				status = STATUS_SUCCESS;
			}

			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			break;

/*****************************************************************************
****************************   IRP_MN_STOP_DEVICE   **************************
*****************************************************************************/

	case	IRP_MN_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_STOP_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			Spx_Card_StopDevice(pCard);				/* Stop the card hardware */

			pIrp->IoStatus.Status = STATUS_SUCCESS;	/* Cannot fail this request */
			IoSkipCurrentIrpStackLocation(pIrp);		
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_REMOVE_DEVICE   **********************
*****************************************************************************/
				
	case	IRP_MN_QUERY_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = STATUS_SUCCESS;

			if(SPX_SUCCESS(status))					// If we can stop, pass IRP on down
			{
				SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are now ready to remove the card
				pIrp->IoStatus.Status	= status;
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
			}
			else									// If we can't then complete
			{
				pIrp->IoStatus.Status = status;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			}

			break;

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

	case	IRP_MN_CANCEL_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

			if(NT_SUCCESS(status))
			{
				ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are no longer expecting to remove the device.
			}

			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			break;

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

	case	IRP_MN_SURPRISE_REMOVAL:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = Spx_Card_StopDevice(pCard);	// Lets stop the port ready for the REMOVE IRP if we are not already.

			SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are now ready to remove the card
			pIrp->IoStatus.Status = status;
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

	case IRP_MN_REMOVE_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = Spx_Card_RemoveDevice(pFDO);

			pIrp->IoStatus.Status = status;
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

	default:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Card %d.\n",
				PRODUCT_NAME,pIrpStack->MinorFunction,pCard->CardNumber));
			
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

	}

	return(status);

} /* Spx_Card_FDO_DispatchPnp */

/*****************************************************************************
**************************                         ***************************
**************************   Spx_CallDriverBelow   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)

description:	Pass the IRP to the driver below this first and wait for it to complete.

parameters:		pLowerDevObj points to a device object for the device below
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)
{
	KEVENT		eventWaitLowerDrivers;
	NTSTATUS	status;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	IoCopyCurrentIrpStackLocationToNext(pIrp);								/* Copy parameters to the stack below */
	KeInitializeEvent(&eventWaitLowerDrivers,SynchronizationEvent,FALSE);	/* Initialise event if need to wait */
	IoSetCompletionRoutine(pIrp,Spx_DispatchPnpPowerComplete,&eventWaitLowerDrivers,TRUE,TRUE,TRUE);

	if((status = IoCallDriver(pLowerDevObj,pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&eventWaitLowerDrivers,Executive,KernelMode,FALSE,NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} /* Spx_CallDriverBelow */

/************************************************************************************
************************									*************************
************************   Spx_DispatchPnpPowerComplete		*************************
************************									*************************
*************************************************************************************

prototype:		NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)

description:	The PnP IRP was completed by the lower-level drivers.
				Signal this to whoever registered us.

parameters:		pDevObject point to the device completing the IRP
				pIrp points to the Plug and Play I/O Request (IRP) to be completed
				Context was set when the lower driver was called (actually event)

returns:		NT Status Code

*/

NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)
{

	PIO_STACK_LOCATION	stack = NULL;
	PKEVENT				event = (PKEVENT) Context;
	NTSTATUS			status;

	
	UNREFERENCED_PARAMETER(pDevObject);

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering DispatchPnpComplete.\n",PRODUCT_NAME));

	status = STATUS_SUCCESS;
	stack = IoGetCurrentIrpStackLocation(pIrp);

    switch(stack->MajorFunction) 
	{
		case IRP_MJ_PNP:

			switch(stack->MinorFunction) 
			{
				case IRP_MN_START_DEVICE:		// Codes which need processing after lower drivers 
				case IRP_MN_QUERY_CAPABILITIES:
				case IRP_MN_CANCEL_STOP_DEVICE:
				case IRP_MN_CANCEL_REMOVE_DEVICE:
					KeSetEvent(event,0,FALSE);		// Wake up waiting process //
					return(STATUS_MORE_PROCESSING_REQUIRED);

				default:
					break;
			}
			break;

		case IRP_MJ_POWER:
				KeSetEvent(event, 0, FALSE);		// Wake up waiting process 
				return(STATUS_MORE_PROCESSING_REQUIRED);

		default:
			break;

	}

    return(status);

} /* Spx_DispatchPnpPowerComplete */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Card_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	Start the card device:
					Process resources (interrupt, I/O, memory)
					Initialise and start the hardware

parameters:		pDevObject point to the card device to start
				pIrp points to the start I/O Request (IRP)

returns:		NT Status Code

*/

NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StartDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

/* Translate the card resources... */

	status = XXX_CardGetResources(	pDevObject,
									pIrpStack->Parameters.StartDevice.AllocatedResources,
									pIrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
	
	if(!SPX_SUCCESS(status))
		return(status);


/* Start the hardware... */

	if(!SPX_SUCCESS(status = XXX_CardStart(pCard)))
		return(status);

	SetPnpPowerFlags(pCard,PPF_STARTED);	/* Card has been started */

	return(status);

} /* Spx_Card_StartDevice */

/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_EnumPorts   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)

description:	Enumerate port devices found on the card device:

parameters:		pDevObject point to the card device to enumerate

returns:		NT Status Code

*/

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PPORT_DEVICE_EXTENSION	pPort = NULL;

	NTSTATUS				status = STATUS_SUCCESS;
	PDEVICE_OBJECT			PortPDO = NULL;

	UNICODE_STRING			PortPDOName;
	static ULONG			CurrentInstance = 0;

	UNICODE_STRING			InstanceStr;
	WCHAR					InstanceNumberBuffer[10];
	POWER_STATE				PowerState;
	USHORT					PortNumber	= 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_EnumPorts for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

// Name and create device objects for each port on the card... 
	
	for(PortNumber=0;PortNumber<pCard->NumberOfPorts;PortNumber++)
	{

		if(pCard->AttachedPDO[PortNumber] == NULL)			// Only create if not already present 
		{

// Create the base port name ("XxPort")... 
		
			RtlZeroMemory(&PortPDOName, sizeof(UNICODE_STRING));
			PortPDOName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
			PortPDOName.Buffer = SpxAllocateMem(PagedPool, PortPDOName.MaximumLength+sizeof(WCHAR));
			if(PortPDOName.Buffer == NULL) continue;
			RtlZeroMemory(PortPDOName.Buffer, PortPDOName.MaximumLength+sizeof(WCHAR));
			RtlAppendUnicodeToString(&PortPDOName, PORT_PDO_NAME_BASE);

// Create the instance ("0")... 

			RtlInitUnicodeString(&InstanceStr,NULL);
			InstanceStr.MaximumLength = sizeof(InstanceNumberBuffer);
			InstanceStr.Buffer = InstanceNumberBuffer;
			RtlIntegerToUnicodeString(CurrentInstance++, 10, &InstanceStr);

// Append instance to the device name ("XxPort0")... 

			RtlAppendUnicodeStringToString(&PortPDOName, &InstanceStr);

// Create the port device object with this name... 

			status = IoCreateDevice(pDevObject->DriverObject, 
									sizeof(PORT_DEVICE_EXTENSION),
									&PortPDOName,  				// Object Name 
									FILE_DEVICE_SERIAL_PORT, 
									FILE_DEVICE_SECURE_OPEN, 
									TRUE, 
									&PortPDO);

 			if(!SPX_SUCCESS(status))
			{
				SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed = %wZ\n",PRODUCT_NAME,&PortPDOName));
				SpxFreeMem(PortPDOName.Buffer);
				continue;
			}

			ASSERT(PortPDO != NULL);

// Increment the pdo's stacksize so that it can pass irps through... 

			PortPDO->StackSize += pDevObject->StackSize;

// Keep a pointer to the device in the card structure... 

			pCard->NumPDOs++;
			pCard->AttachedPDO[PortNumber] = PortPDO;
			ObReferenceObject(PortPDO);

// Initialise port device object and extension... 

			pPort = PortPDO->DeviceExtension;
			RtlZeroMemory(pPort,sizeof(PORT_DEVICE_EXTENSION));		// Clear the device extension 

			pPort->DeviceName = PortPDOName;

			KeInitializeSpinLock(&pPort->PnpPowerFlagsLock);		// Initialise the PNP flags lock 
			ClearPnpPowerFlags(pPort,PPF_STARTED);					// Not started yet 
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);				// Not pending a stop 
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);			// Not pending a remove 
			ClearPnpPowerFlags(pPort,PPF_REMOVED);					// Not removed 
			SetPnpPowerFlags(pPort,PPF_POWERED);					// Initially powered up 

			InitializeListHead(&pPort->StalledIrpQueue);			// Initialise the stalled IRP list 
			KeInitializeSpinLock(&pPort->StalledIrpLock);			// Initialise the StalledIrpLock flags lock 
			pPort->UnstallingFlag = FALSE;							// Initialise UnstallingIrps Flag.

			pPort->IsFDO = FALSE;
			pPort->PortNumber = PortNumber;							// system port number 
			pPort->UniqueInstanceID = FALSE;						// Instance ID not unique by default.
			pPort->DeviceIsOpen = FALSE;							// Port is closed to start with 
			pPort->DeviceObject = PortPDO;							// Backpointer to device object 
			pPort->DeviceState = PowerDeviceD0;						// Port device in full power state 
			pPort->SystemState = PowerSystemWorking;				// System in full power State 
			pPort->pParentCardExt = pCard;							// Point to the parent card extension 
			ExInitializeFastMutex(&pPort->OpenMutex);

			if(!SPX_SUCCESS(status = XXX_PortInit(pPort)))			// Initialise hardware 
				continue;

			// Inform Power Manager the of the new power state.
			PowerState.DeviceState = pPort->DeviceState;
			PoSetPowerState(pPort->DeviceObject, DevicePowerState, PowerState);

			PortPDO->Flags &= ~DO_DEVICE_INITIALIZING;				// Finished Initialising 
			PortPDO->Flags |= DO_BUFFERED_IO;						// Do Buffered IO 
			PortPDO->Flags |= DO_BUS_ENUMERATED_DEVICE;				// Bus enumerated 
			PortPDO->Flags |= DO_POWER_PAGABLE;						// Get power IRPs at IRQL PASSIVE_LEVEL 

		}
		else
		{
			PortPDO = pCard->AttachedPDO[PortNumber];
			pPort = PortPDO->DeviceExtension;

			if(pPort->PnpPowerFlags & PPF_REMOVED)
				ClearPnpPowerFlags(pPort,PPF_REMOVED);
		}
	}

	return(status);

} // End Spx_EnumPorts 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Card_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)

description:	Stop the card device:
					Stop the hardware
					Deinitialise card resources (interrupt, I/O, memory)

parameters:		pCard points to the card device to stop

returns:		NT Status Code

*/

NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StopDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

	if(pCard->PnpPowerFlags & PPF_STARTED)		/* If card is running */
	{
		XXX_CardStop(pCard);					/* Stop the card */
	}

	ClearPnpPowerFlags(pCard,PPF_STARTED);		/* Indicate card is stopped */
	ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);	/* Clear stop pending flag */

	return(status);

} /* Spx_Card_StopDevice */

/*****************************************************************************
*************************                           **************************
*************************   Spx_Card_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:	Remove the card device:
					Deallocate any resources
					Delete device object

parameters:		pDevObject points to the card device object to remove

returns:		NT Status Code

*/


NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PDEVICE_OBJECT			pPortPdo;
	PPORT_DEVICE_EXTENSION	pPort;
	NTSTATUS				status = STATUS_SUCCESS;
	int						loop;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_Card_RemoveDevice for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

/* First remove all "removed" port device objects... */

	for(loop=0; loop<PRODUCT_MAX_PORTS; loop++)
	{
		if(pPortPdo = pCard->AttachedPDO[loop])			/* Enumerated port PDO ? */
		{
			pPort = pPortPdo->DeviceExtension;			/* Get the device extension */
			XXX_PortDeInit(pPort);						/* Deinitialise port structure */
			if(pPort->DeviceName.Buffer)
			{
				SpxFreeMem(pPort->DeviceName.Buffer);	/* Free device name buffer */
				pPort->DeviceName.Buffer = NULL;
			}
			pCard->AttachedPDO[loop] = NULL;			/* Remove the port PDO pointer */
			pCard->NumPDOs--;							/* One less port attached */
			IoDeleteDevice(pPortPdo);					/* Delete the port device object */
			ObDereferenceObject(pPortPdo);				/* Dereference the object */
		}
	}

/* Now, remove the card device object... */

	Spx_Card_StopDevice(pCard);							/* Stop the card and release resources */
	XXX_CardDeInit(pCard);								/* Deinitialise non-hardware fields */
	IoDetachDevice(pCard->LowerDeviceObject);			/* Detach card device from the device stack. */
	IoDeleteDevice(pDevObject);							/* Delete Card FDO from system. */

	return(status);

} /* Spx_Card_RemoveDevice */



/*****************************************************************************
************************                              ************************
************************   Spx_Port_PDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)

description:	The plug and play dispatch routine to handle IRPs for port devices.

parameters:		pDevObject points to a port device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pPDO->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	NTSTATUS				status;
	PWCHAR					ReturnBuffer = NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	status = pIrp->IoStatus.Status;

	switch (pIrpStack->MinorFunction) 
	{
   
/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
	
	case	IRP_MN_START_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Port %d.\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_UNSUCCESSFUL;

			if(SPX_SUCCESS(status = Spx_Port_StartDevice(pPDO)))
				Spx_UnstallIrps(pPort);					// Restart any queued IRPs (from a previous start) 

			break;

/*****************************************************************************
*****************************   IRP_MN_QUERY_ID   ****************************
*****************************************************************************/
	
	case	IRP_MN_QUERY_ID:
	{
		PUNICODE_STRING pId	= NULL;
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		switch(pIrpStack->Parameters.QueryId.IdType)
		{
		case	BusQueryCompatibleIDs:
		case	BusQueryDeviceID:
		case	BusQueryInstanceID:
		case	BusQueryHardwareIDs:
			{
				status = STATUS_SUCCESS;

				switch(pIrpStack->Parameters.QueryId.IdType)
				{
				case	BusQueryDeviceID:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryDeviceID Irp for Port %d.\n",
							PRODUCT_NAME,pPort->PortNumber));
						SpxDbgMsg(SPX_MISC_DBG,("%s: Device ID %wZ.\n", PRODUCT_NAME,&pPort->DeviceID));
						pId = &pPort->DeviceID;
						break;

				case	BusQueryInstanceID:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryInstanceID Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						SpxDbgMsg(SPX_MISC_DBG,("%s: Instance ID %wZ.\n",PRODUCT_NAME,&pPort->InstanceID));
						pId = &pPort->InstanceID;
						break;

				case	BusQueryCompatibleIDs:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryCompatibleIDs Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						pId = &pPort->CompatibleIDs;
						break;

				case	BusQueryHardwareIDs:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryHardwareIDs Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						pId = &pPort->HardwareIDs;
						break;
				
				default:
					break;
				}

				if(pId)
				{
					if(pId->Buffer)
					{
						if(ReturnBuffer = SpxAllocateMem(PagedPool, pId->Length + sizeof(WCHAR)))
								RtlCopyMemory(ReturnBuffer, pId->Buffer, pId->Length + sizeof(WCHAR));
						else	
						{
							sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
									pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

							Spx_LogMessage(	STATUS_SEVERITY_ERROR,
											pPort->DriverObject,			// Driver Object
											pPort->DeviceObject,			// Device Object (Optional)
											PhysicalZero,					// Physical Address 1
											PhysicalZero,					// Physical Address 2
											0,								// SequenceNumber
											pIrpStack->MajorFunction,		// Major Function Code
											0,								// RetryCount
											FILE_ID | __LINE__,				// UniqueErrorValue
											STATUS_SUCCESS,					// FinalStatus
											szErrorMsg);					// Error Message

							status = STATUS_INSUFFICIENT_RESOURCES;
						}
					}

					pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
				}
				break;
			}
		
		default:
			break;
		}
		break;

	}

/*****************************************************************************
*************************   IRP_MN_QUERY_DEVICE_TEXT   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_TEXT:
	{
		PUNICODE_STRING	pText = NULL;
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_TEXT Irp for Port %d.\n",
				PRODUCT_NAME,pPort->PortNumber));

			if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription)
				pText = &pPort->DevDesc;

			if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation)
				pText = &pPort->DevLocation;

			if((pText == NULL)||(pText->Buffer == NULL))
				break;

			if(!(ReturnBuffer = SpxAllocateMem(PagedPool, pText->Length + sizeof(WCHAR))))
			{
				sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
						pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

				Spx_LogMessage(	STATUS_SEVERITY_ERROR,
								pPort->DriverObject,			// Driver Object
								pPort->DeviceObject,			// Device Object (Optional)
								PhysicalZero,					// Physical Address 1
								PhysicalZero,					// Physical Address 2
								0,								// SequenceNumber
								pIrpStack->MajorFunction,		// Major Function Code
								0,								// RetryCount
								FILE_ID | __LINE__,				// UniqueErrorValue
								STATUS_SUCCESS,					// FinalStatus
								szErrorMsg);					// Error Message

				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			status = STATUS_SUCCESS;
			RtlCopyMemory(ReturnBuffer, pText->Buffer, pText->Length + sizeof(WCHAR));
			pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
			break;
	}

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_CAPABILITIES:
	{
			PDEVICE_CAPABILITIES	pDevCaps = NULL;

			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));
			
			// Get the packet
			pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

			// Set the capabilities.
			pDevCaps->Version = 1;
			pDevCaps->Size = sizeof(DEVICE_CAPABILITIES);

			// We cannot wake the system.
			pDevCaps->SystemWake = PowerSystemUnspecified;
			pDevCaps->DeviceWake = PowerSystemUnspecified;

			// Set device state mapping...

			pDevCaps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
			pDevCaps->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

			// We have no latencies.
			pDevCaps->D1Latency = 0;
			pDevCaps->D2Latency = 0;
			pDevCaps->D3Latency = 0;

			// No locking or ejection.
			pDevCaps->LockSupported = FALSE;
			pDevCaps->EjectSupported = FALSE;

			// Removable
			pDevCaps->Removable = FALSE;

			// Not a Docking device.
			pDevCaps->DockDevice = FALSE;

			// System wide unique ID.
			pDevCaps->UniqueID = pPort->UniqueInstanceID;

			//UINumber
			pDevCaps->UINumber = pPort->PortNumber+1;

			// Raw capable
			pDevCaps->RawDeviceOK = TRUE;

			// Silent Install
			pDevCaps->SilentInstall = FALSE;

			// Surprise Removal
			pDevCaps->SurpriseRemovalOK = FALSE;

			status = STATUS_SUCCESS;
			break;
	}

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

	case	IRP_MN_QUERY_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_UNSUCCESSFUL;

			if(pPort->PnpPowerFlags & PPF_STARTED)
			{
				ExAcquireFastMutex(&pPort->OpenMutex);

				if(pPort->DeviceIsOpen) 
				{
					ExReleaseFastMutex(&pPort->OpenMutex);
					status = STATUS_DEVICE_BUSY;

					SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
						PRODUCT_NAME, pPort->PortNumber));
				}
				else
				{
					SetPnpPowerFlags(pPort,PPF_STOP_PENDING);
					status = STATUS_SUCCESS;
					ExReleaseFastMutex(&pPort->OpenMutex);
				}
			}
			break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_CANCEL_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);	// Clear the stop pending flag 
			Spx_UnstallIrps(pPort);						// Restart any queued IRPs 
			break;

/*****************************************************************************
***************************   IRP_MN_STOP_DEVICE   ***************************
*****************************************************************************/

	case	IRP_MN_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_STOP_DEVICE Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			status = Spx_Port_StopDevice(pPort);
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);	// Clear the stop pending flag 
			break;

/*****************************************************************************
***********************   IRP_MN_QUERY_REMOVE_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_REMOVE_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			ExAcquireFastMutex(&pPort->OpenMutex);

			if(pPort->DeviceIsOpen) 
			{
				ExReleaseFastMutex(&pPort->OpenMutex);
				status = STATUS_DEVICE_BUSY;

				SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
					PRODUCT_NAME, pPort->PortNumber));
			}
			else
			{
				SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are now ready to remove the port
				status = STATUS_SUCCESS;
				ExReleaseFastMutex(&pPort->OpenMutex);
			}

			break; 

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

	case	IRP_MN_CANCEL_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_SUCCESS;
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are no longer expecting to remove the device.
			break; 

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

	case	IRP_MN_SURPRISE_REMOVAL:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			status = Spx_Port_StopDevice(pPort);
			SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are now ready to remove the port
			break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

	case	IRP_MN_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_REMOVE_DEVICE Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			Spx_KillStalledIRPs(pPDO);		// Kill off any waiting IRPS on the stalled list 
			status = Spx_Port_RemoveDevice(pPDO);
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// Clear the pending flag 
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_RELATIONS:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			switch(pIrpStack->Parameters.QueryDeviceRelations.Type)
			{
			case TargetDeviceRelation:
				{
					PDEVICE_RELATIONS pDevRel = NULL;

					if(pIrp->IoStatus.Information != 0)
						break;

					if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
					{
						CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

						sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
								pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

						Spx_LogMessage(	STATUS_SEVERITY_ERROR,
										pPort->DriverObject,			// Driver Object
										pPort->DeviceObject,			// Device Object (Optional)
										PhysicalZero,					// Physical Address 1
										PhysicalZero,					// Physical Address 2
										0,								// SequenceNumber
										pIrpStack->MajorFunction,		// Major Function Code
										0,								// RetryCount
										FILE_ID | __LINE__,				// UniqueErrorValue
										STATUS_SUCCESS,					// FinalStatus
										szErrorMsg);					// Error Message

						status = STATUS_INSUFFICIENT_RESOURCES;
						break;
					}

					pDevRel->Count = 1;
					pDevRel->Objects[0] = pPDO;
					ObReferenceObject(pPDO);

					status = STATUS_SUCCESS;
					pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
					break;
				}

			case BusRelations:
				{
					PDEVICE_RELATIONS pDevRel = NULL;

					if(pIrp->IoStatus.Information != 0)
						break;

					if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
					{
						CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

						sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
								pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
						
						Spx_LogMessage(	STATUS_SEVERITY_ERROR,
										pPort->DriverObject,			// Driver Object
										pPort->DeviceObject,			// Device Object (Optional)
										PhysicalZero,					// Physical Address 1
										PhysicalZero,					// Physical Address 2
										0,								// SequenceNumber
										pIrpStack->MajorFunction,		// Major Function Code
										0,								// RetryCount
										FILE_ID | __LINE__,				// UniqueErrorValue
										STATUS_SUCCESS,					// FinalStatus
										szErrorMsg);					// Error Message

						status = STATUS_INSUFFICIENT_RESOURCES;
						break;
					}

					pDevRel->Count = 0;
					status = STATUS_SUCCESS;
					pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
					break;

				}

			default:
				break;
			}
			break;


	default:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Port %d.\n", 
				PRODUCT_NAME,pIrpStack->MinorFunction, pPort->PortNumber));
			break;
	}

	pIrp->IoStatus.Status = status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return(status);

} /* Spx_Port_PDO_DispatchPnp */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Port_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)

description:	Start the port device:
					Setup external naming
					Initialise and start the hardware

parameters:		pDevObject point to the card device to start
				pIrp points to the start I/O Request (IRP)

returns:		NT Status Code

*/

NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)
{

	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;	
	NTSTATUS				status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StartDevice for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	if(!pPort->CreatedSymbolicLink)
	{
		if(!SPX_SUCCESS(status = Spx_DoExternalNaming(pDevObject)))		// Set up external name for device 
			return(status);
	}

	if(!SPX_SUCCESS(status = XXX_PortStart(pPort)))				// Start hardware. 
	{
		Spx_RemoveExternalNaming(pDevObject);					// Remove external naming.
		return(status);
	}

	SetPnpPowerFlags(pPort,PPF_STARTED);						// Port has been started.
	ClearPnpPowerFlags(pPort,PPF_REMOVED);						// Port is not removed...yet. 
	ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);					// Not pending a stop. 
	ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);				// Not pending a remove. 

	return(status);

} // Spx_Port_StartDevice 


/*****************************************************************************
**************************                          **************************
**************************   Spx_GetExternalName   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)

description:	Setup external naming for a port:
					get Dos Name for port 
					form symbolic link name

parameters:		pDevObject points to the device object for the port to be named

returns:		NT Status Code

*/
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	HANDLE					PnPKeyHandle;
	UNICODE_STRING			TmpLinkName;
	WCHAR					*pRegName = NULL;
	ULONG					BuffLen = 0;
	CHAR					szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
		
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_GetExternalName for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	status = IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle);

	if(!SPX_SUCCESS(status))
		return(status);

// Get the device name allocated by the PNP manager from the registry... 
	if(pRegName = SpxAllocateMem(PagedPool,SYMBOLIC_NAME_LENGTH * sizeof(WCHAR) + sizeof(WCHAR)))
	{
		status = Spx_GetRegistryKeyValue(	PnPKeyHandle,
											L"PortName",
											wcslen(L"PortName") * sizeof(WCHAR),
											pRegName,
											SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));
	}
	else
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
	}

	ZwClose(PnPKeyHandle);

	if(!SPX_SUCCESS(status))
	{
		if(pRegName != NULL) 
			SpxFreeMem(pRegName);

		return(STATUS_SUCCESS);			// Port has not been given a name yet but we must not fail.
	}

	RtlZeroMemory(&TmpLinkName, sizeof(UNICODE_STRING));

	if(!SPX_SUCCESS(status))
		goto NamingError;
	
	TmpLinkName.MaximumLength	= SYMBOLIC_NAME_LENGTH * sizeof(WCHAR);
	TmpLinkName.Buffer			= SpxAllocateMem(PagedPool, TmpLinkName.MaximumLength + sizeof(WCHAR));
	
	if(!TmpLinkName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	RtlZeroMemory(TmpLinkName.Buffer, TmpLinkName.MaximumLength + sizeof(WCHAR));

	// Create the "\\DosDevices\\<SymbolicName>" string.
	RtlAppendUnicodeToString(&TmpLinkName, L"\\");
	RtlAppendUnicodeToString(&TmpLinkName, DEFAULT_DIRECTORY);
	RtlAppendUnicodeToString(&TmpLinkName, L"\\");
	RtlAppendUnicodeToString(&TmpLinkName, pRegName);

	pPort->SymbolicLinkName.Length			= 0;
	pPort->SymbolicLinkName.MaximumLength	= TmpLinkName.Length + sizeof(WCHAR);
	pPort->SymbolicLinkName.Buffer			= SpxAllocateMem(PagedPool, pPort->SymbolicLinkName.MaximumLength);
	
	if(!pPort->SymbolicLinkName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	RtlZeroMemory(pPort->SymbolicLinkName.Buffer, pPort->SymbolicLinkName.MaximumLength);
	RtlAppendUnicodeStringToString(&pPort->SymbolicLinkName, &TmpLinkName);


	pPort->DosName.Buffer = SpxAllocateMem(PagedPool, 64 + sizeof(WCHAR));

	if(!pPort->DosName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X:: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	pPort->DosName.MaximumLength = 64 + sizeof(WCHAR);

	pPort->DosName.Length = 0;
	RtlZeroMemory(pPort->DosName.Buffer, pPort->DosName.MaximumLength);
	RtlAppendUnicodeToString(&pPort->DosName, pRegName);
	RtlZeroMemory(((PUCHAR) (&pPort->DosName.Buffer[0])) + pPort->DosName.Length, sizeof(WCHAR));

	SpxDbgMsg(SPX_MISC_DBG, ("%s: DeviceName is %wZ\n", PRODUCT_NAME, &pPort->DeviceName));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: DosName is %wZ\n", PRODUCT_NAME, &pPort->DosName));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: SymbolicName is %wZ\n", PRODUCT_NAME, &pPort->SymbolicLinkName));

	if(pRegName != NULL)
		SpxFreeMem(pRegName);	// Free pRegName

	if(TmpLinkName.Buffer != NULL)
		SpxFreeMem(TmpLinkName.Buffer);	// Free TmpLinkName

	return(status);


NamingError:;

	if(TmpLinkName.Buffer != NULL)
		SpxFreeMem(TmpLinkName.Buffer);

	if(pRegName != NULL)
		SpxFreeMem(pRegName);

	return(status);
}

/*****************************************************************************
**************************                          **************************
**************************   Spx_DoExternalNaming   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:	Setup external naming for a port:
					create symbolic link
					add to registry
					register and enable interface

parameters:		pDevObject points to the device object for the port to be named

returns:		NT Status Code

*/
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	CHAR					szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
		
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DoExternalNaming for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

// Get external name...
	if( !SPX_SUCCESS(status = Spx_GetExternalName(pDevObject)) || (pPort->DosName.Buffer == NULL))
		return(status);


	status = IoCreateSymbolicLink(&pPort->SymbolicLinkName, &pPort->DeviceName);  // Create the symbolic link... 

	if(!SPX_SUCCESS(status))
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X:: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		goto ExternalNamingError;
	}

// Add mapping to "SERIALCOMM" section of registry... 
	pPort->CreatedSymbolicLink = TRUE;
	
	status = RtlWriteRegistryValue(	RTL_REGISTRY_DEVICEMAP,
									L"SERIALCOMM",
									pPort->DeviceName.Buffer,
									REG_SZ,
									pPort->DosName.Buffer,
									pPort->DosName.Length + sizeof(WCHAR));

	if(!SPX_SUCCESS(status))
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Registry error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		goto ExternalNamingError;
	}

	status = IoRegisterDeviceInterface(	pDevObject, (LPGUID)&GUID_CLASS_COMPORT,
										NULL, &pPort->DeviceClassSymbolicName);

	if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Interface error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		pPort->DeviceClassSymbolicName.Buffer = NULL;
		
		goto ExternalNamingError;
	}

	// Enable the device interface.
	status = IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, TRUE);

	if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Interface error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		
		goto ExternalNamingError;
	}



	pPort->CreatedSerialCommEntry = TRUE;				// Set flag.

	return(status);


ExternalNamingError:;

	if(!SPX_SUCCESS(status))
		Spx_RemoveExternalNaming(pDevObject);			// Remove and tidy up any allocations 


	return(status);

} // End Spx_DoExternalNaming 

/*****************************************************************************
************************                              ************************
************************   Spx_RemoveExternalNaming   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:	Remove external naming:
					remove symbolic link
					remove from registry
					stop interface

parameters:		pDevObject points to the device object for the port to be named.

returns:		NT Status Code

*/
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(pPort->CreatedSymbolicLink)
	{
		if(pPort->DosName.Buffer)
		{
			SpxFreeMem(pPort->DosName.Buffer);						// Free DOS name buffer. 
			pPort->DosName.Buffer = NULL;
		}

		if(pPort->SymbolicLinkName.Buffer)
		{
			SpxFreeMem(pPort->SymbolicLinkName.Buffer);				// Free symbolic link name buffer. 
			pPort->SymbolicLinkName.Buffer = NULL;
		}

		Spx_GetExternalName(pDevObject);	// Get external name..

		if(pPort->SymbolicLinkName.Buffer)
			status = IoDeleteSymbolicLink(&pPort->SymbolicLinkName);	// Delete Symbolic Link. 

		if(pPort->DeviceClassSymbolicName.Buffer)	// Device Interface name
			IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, FALSE);	// Disable Device Interface.


		pPort->CreatedSymbolicLink = FALSE;												// Reset created flag. 
	}

	if(pPort->DosName.Buffer)
	{
		SpxFreeMem(pPort->DosName.Buffer);					// Free DOS name buffer. 
		pPort->DosName.Buffer = NULL;
	}

	if(pPort->SymbolicLinkName.Buffer)
	{
		SpxFreeMem(pPort->SymbolicLinkName.Buffer);			// Free symbolic link name buffer. 
		pPort->SymbolicLinkName.Buffer = NULL;
	}

	if(pPort->CreatedSerialCommEntry && pPort->DeviceName.Buffer)
	{
		RtlDeleteRegistryValue(	RTL_REGISTRY_DEVICEMAP,		// Delete SERIALCOMM registry entry. 
								SERIAL_DEVICE_MAP,
								pPort->DeviceName.Buffer);

		pPort->CreatedSerialCommEntry = FALSE;				// Reset created flag.
	}

	if(pPort->DeviceClassSymbolicName.Buffer)	// Device Interface name
	{			
		SpxFreeMem(pPort->DeviceClassSymbolicName.Buffer);					// Free Device Interface Name.
		pPort->DeviceClassSymbolicName.Buffer = NULL;
	}

	return(STATUS_SUCCESS);

} // End Spx_RemoveExternalNaming 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Port_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)

description:	Stop the port device:
					Stop the hardware
					Remove external naming

parameters:		pPort points to the port device extension to be stopped

returns:		NT Status Code

*/

NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS	status	= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StopDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

	if(pPort->PnpPowerFlags & PPF_STARTED)
		XXX_PortStop(pPort);									// Stop the port hardware. 

	ClearPnpPowerFlags(pPort,PPF_STARTED);						// Indicate card is stopped. 
	ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);					// Clear stop pending flag.

	return(status);

} // End Spx_Port_StopDevice

/*****************************************************************************
*************************                           **************************
*************************   Spx_Port_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:	Remove the port device object:
					Remove PDO pointer from card structure
					Deinitialise port hardware
					Delete the device object

parameters:		pDevObject points to the port device object to be stopped

returns:		NT Status Code

*/
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort	= pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard	= pPort->pParentCardExt;
	NTSTATUS				status	= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_RemoveDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

	if(pPort->PnpPowerFlags & PPF_REMOVED)					// Has device been removed already?
		return(STATUS_SUCCESS);

	Spx_Port_StopDevice(pPort);								// Stop the hardware.
	ClearPnpPowerFlags(pPort,PPF_STARTED);					// Mark the PDO as stopped.

	Spx_RemoveExternalNaming(pDevObject);					// Remove external naming. 


// Mark the port device as "removed", but don't delete the PDO until the card device is removed...
	SetPnpPowerFlags(pPort,PPF_REMOVED);					// Mark the PDO as "removed".

	return(status);

} // End Spx_Port_RemoveDevice 




/////////////////////////////////////////////////////////////////////////////////////////////
// Create an Instance ID for the port and try to make it globally unique if possible.
//
NTSTATUS
Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	CHAR					szTemp[100];		// Space to hold string 
	int						szTempPos = 0;
	HANDLE					PnPKeyHandle;
	BOOLEAN					UseBusWideInstanceID = FALSE;  // Try to create system wide unique instance IDs

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_CreatePortInstanceID for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	status = IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_READ, &PnPKeyHandle);

	if(SPX_SUCCESS(status))
	{
		ULONG Data = 0;

		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, L"UseBusWideInstanceID", 
							wcslen(L"UseBusWideInstanceID") * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if(Data > 0)
				UseBusWideInstanceID = TRUE;  // Installer has told us to use a bus wide instance ID 
											  // because child devices already exist with that type of ID.
		}
		

		ZwClose(PnPKeyHandle);
	}

	if(UseBusWideInstanceID)
	{
		pPort->UniqueInstanceID = FALSE;	// ID created is not unique system wide.
		status = STATUS_SUCCESS;
	}
	else
	{
		switch(pCard->InterfaceType)
		{
		case Isa:
			// Start Instance ID with ISA address
			szTempPos += sprintf(szTemp,"ISA&%08X%08X&", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
			pPort->UniqueInstanceID = TRUE;	// ID created is unique system wide.
			status = STATUS_SUCCESS;
			break;

		case PCIBus:
			{
				ULONG PCI_BusNumber = 0;
				ULONG PCI_DeviceFunction = 0;
				ULONG ResultLength;

				// Try to get DevicePropertyBusNumber
				if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyBusNumber, 
											sizeof(PCI_BusNumber), &PCI_BusNumber, &ResultLength)))
					break;


				// Start Instance ID with PCI bus number
				szTempPos += sprintf(szTemp,"PCI&%04X&", PCI_BusNumber);

				// Try to get DevicePropertyAddress
				if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyAddress, 
											sizeof(PCI_DeviceFunction),	&PCI_DeviceFunction, &ResultLength)))
					break;
				

				// Add on PCI Device and Function IDs
				szTempPos += sprintf(szTemp + szTempPos,"%08X&", PCI_DeviceFunction);
				pPort->UniqueInstanceID = TRUE;	// ID created is unique system wide.

				status = STATUS_SUCCESS;
				break;
			}
		
		default:
			pPort->UniqueInstanceID = FALSE;	// ID created is not unique system wide.
			status = STATUS_SUCCESS;
			break;

		}

	}

	// Finish off the InstanceID with the port number on the card.
	sprintf(szTemp + szTempPos,"%04X", pPort->PortNumber);

	status = Spx_InitMultiString(FALSE, &pPort->InstanceID, szTemp, NULL);


	return status;
}



// End of SPX_PNP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\spx_wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes

NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING pMofResourceName,
						OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer);

// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchSystemControl)
#pragma alloc_text(PAGE, SpxPort_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpxPort_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpxPort_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataItem)
#endif




/********************************************************************************
********************								*****************************
********************	Spx_SystemControlDispatch	*****************************
********************								*****************************
********************************************************************************/
NTSTATUS
Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		pCommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    SYSCTL_IRP_DISPOSITION	IrpDisposition;
	PDEVICE_OBJECT			pLowerDevObj = pCommonData->LowerDeviceObject;
    NTSTATUS				status = pIrp->IoStatus.Status;

    PAGED_CODE();

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DispatchSystemControl.\n", PRODUCT_NAME));

    status = WmiSystemControl(&pCommonData->WmiLibInfo, pDevObject, pIrp, &IrpDisposition);
                                 
    switch(IrpDisposition)
    {
        case IrpProcessed:
        {
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            // This irp has not been completed, but has been fully processed, we will complete it now.
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            // This irp is either not a WMI irp or is a WMI irp targetted at a device lower in the stack.

			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }
                                    
        default:
        {
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
			
			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }        
    }
    
	return(status);
}







// End of prototypes.


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4

GUID StdSerialPortNameGuid				= SERIAL_PORT_WMI_NAME_GUID;			// Standard Serial WMI
GUID StdSerialPortCommGuid				= SERIAL_PORT_WMI_COMM_GUID;			// Standard Serial WMI
GUID StdSerialPortHWGuid				= SERIAL_PORT_WMI_HW_GUID;				// Standard Serial WMI
GUID StdSerialPortPerfGuid				= SERIAL_PORT_WMI_PERF_GUID;			// Standard Serial WMI
GUID StdSerialPortPropertiesGuid		= SERIAL_PORT_WMI_PROPERTIES_GUID;		// Standard Serial WMI

WMIGUIDREGINFO SpxPort_WmiGuidList[] =
{
    { &StdSerialPortNameGuid, 1, 0 },
    { &StdSerialPortCommGuid, 1, 0 },
    { &StdSerialPortHWGuid, 1, 0 },
    { &StdSerialPortPerfGuid, 1, 0 },
    { &StdSerialPortPropertiesGuid, 1, 0}
};


#define SpxPort_WmiGuidCount (sizeof(SpxPort_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpxPort_WmiGuidCount;
    WmilibContext->GuidList				= SpxPort_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpxPort_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpxPort_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpxPort_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpxPort_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	
    WmilibContext->WmiFunctionControl	= NULL;	

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING MofResourceName,
						OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pDevObject;  // Port device object is a PDO.


	return(status);
}





NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
    case WMI_SERIAL_PORT_NAME_INFORMATION:
		{
			size = pPort->DosName.Length;

			if(OutBufferSize < (size + sizeof(USHORT))) 
			{
				size += sizeof(USHORT);
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(pPort->DosName.Buffer == NULL) 
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// First, copy the string over containing our identifier
			*(USHORT *)pBuffer = (USHORT)size;
			(UCHAR *)pBuffer += sizeof(USHORT);

			RtlCopyMemory(pBuffer, pPort->DosName.Buffer, size);

			// Increment total size to include the WORD containing our len
			size += sizeof(USHORT);
			*pInstanceLengthArray = size;
                
			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_COMM_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_COMM_DATA)pBuffer = pPort->WmiCommData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_HW_INFORMATION:
		{
			size = sizeof(SERIAL_WMI_HW_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_HW_DATA)pBuffer = pPort->WmiHwData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_PERF_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_PERF_DATA)pBuffer = pPort->WmiPerfData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PROPERTIES: 
		{
			size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			SerialGetProperties(pPort, (PSERIAL_COMMPROP)pBuffer);
       
			*((PULONG)(((PSERIAL_COMMPROP)pBuffer)->ProvChar)) = 0;

			status = STATUS_SUCCESS;

			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\esils.h ===
/************************************************************************/
/*																		*/
/*	Title:		Engineering Services Incident Log (ESIL)				*/
/*																		*/
/*	Author:		P.B Smith												*/
/*																		*/
/*	Version:	1.0.0 (I/O8+ NT Driver Version)							*/
/*																		*/
/*	Creation:	27th September 1998										*/
/*																		*/
/*	Description:	Contains descriptions and definitions of all		*/
/*					ESIL reports and modifications applied to the		*/
/*					I/O8+ NT Driver.									*/
/*																		*/
/************************************************************************/
#ifndef ESILS_H
#define ESILS_H

/* ESIL Log...
	
	ESIL		Date	 Author		Description
	====		====	 ======		=========== */





/* Temp fixes to be made into an ESIL */
#define SERENUM_FIX		
#define HYPERTERMINAL_FIX




#endif	// End of ESILS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\io8_defs.h ===
#ifndef	IO8_DEFS_H
#define IO8_DEFS_H


// File IDs for Event Logging (top 8 bits only).
#define IO8_PNP_C		((ULONG)0x010000)
#define IO8_W2K_C		((ULONG)0x020000)

#define PRODUCT_MAX_PORTS		8

// Port Types.
#define IO8_RJ12				1

// Port device object name.
#define PORT_PDO_NAME_BASE		L"\\Device\\IO8Port"

// Tag used for memory allocations (must be 4 bytes in reverse).
#define MEMORY_TAG				'+8OI'

// Old debug stuff
#if DBG
#define SERDIAG1              ((ULONG)0x00000001)
#define SERDIAG2              ((ULONG)0x00000002)
#define SERDIAG3              ((ULONG)0x00000004)
#define SERDIAG4              ((ULONG)0x00000008)
#define SERDIAG5              ((ULONG)0x00000010)
#define SERFLOW               ((ULONG)0x20000000)
#define SERERRORS             ((ULONG)0x40000000)
#define SERBUGCHECK           ((ULONG)0x80000000)
extern ULONG SpxDebugLevel;

#define SerialDump(LEVEL,STRING)			\
        do {								\
            if (SpxDebugLevel & LEVEL) {	\
                DbgPrint STRING;			\
            }								\
            if (LEVEL == SERBUGCHECK) {		\
                ASSERT(FALSE);				\
            }								\
        } while (0)
#else
#define SerialDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif


// I/O8+ HardwareIDs
#define IO8_ISA_HWID	L"SPX_IO8001"								// I/O8+ ISA card.
#define IO8_PCI_HWID	L"PCI\\VEN_11CB&DEV_2000&SUBSYS_B00811CB"	// I/O8+ PCI card.

//I/O8+ CardTypes
#define Io8Isa		0
#define Io8Pci		1


// Bus Types
#define BUSTYPE_ISA		0x00000001
#define	BUSTYPE_MCA		0x00000002
#define	BUSTYPE_EISA	0x00000004
#define	BUSTYPE_PCI		0x00000008		

/*****************************************************************************
***********************************   PCI   **********************************
*****************************************************************************/
// General definitions... 

#define		PLX_VENDOR_ID		0x10B5			// PLX test board vendor ID
#define		PLX_DEVICE_ID		0x9050			// PLX test board device ID 

#define		SPX_VENDOR_ID		0x11CB			// Assigned by the PCI SIG 
#define		SPX_PLXDEVICE_ID	0x2000			// PLX 9050 Bridge 

#define		SPX_SUB_VENDOR_ID	SPX_VENDOR_ID	// Same as vendor id 
#define		IO8_SUB_SYS_ID		0xB008			// Phase 2 (Z280) board



#endif	// End of IO8_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\waitmask.c ===
#include "precomp.h"				
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    waitmask.c

Abstract:

    This module contains the code that is very specific to get/set/wait
    on event mask operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    );


NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to process the set mask and wait
    mask ioctls.  Calls to this routine are serialized by
    placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/
{
    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SerialDump(SERDIAG3, ("SERIAL: In SerialStartMask\n"));
        
    ASSERT(pPort->CurrentMaskIrp);

    do 
	{
        SerialDump(SERDIAG4, ("SERIAL: STARMASK - CurrentMaskIrp: %x\n",pPort->CurrentMaskIrp));
            
        IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK) 
			|| (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK));

        if(IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK)
		{
            SerialDump(SERDIAG4, ("SERIAL - %x is a SETMASK irp\n",pPort->CurrentMaskIrp));

            //
            // Complete the old wait if there is one.
            //

            KeSynchronizeExecution(pCard->Interrupt, SerialFinishOldWait, pPort);

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!pPort->IrpMaskLocation);

            pPort->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if(!SetFirstStatus) 
			{

                SerialDump(
                    SERDIAG4,
                    ("SERIAL: %x was the first irp processed by this\n"
                     "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                    );

                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;
            }

            //
            // The following call will also cause the current
            // call to be completed.
            //

            SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                
            SerialDump(
                SERDIAG4,
                ("SERIAL: Perhaps another mask irp was found in the queue\n"
                 "------- %x/%x <- values should be the same\n",
                 pPort->CurrentMaskIrp,NewIrp)
                );


        } 
		else 
		{

            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be statisfied so it makes no sense to start it.
            //

            if((!pPort->IsrWaitMask) || (pPort->CurrentWaitIrp)) 
			{
                SerialDump(
                    SERDIAG4,
                    ("SERIAL: WaitIrp is invalid\n"
                     "------- IsrWaitMask: %x\n"
                     "------- CurrentWaitIrp: %x\n",
                     pPort->IsrWaitMask,
                     pPort->CurrentWaitIrp)
                    );

                pPort->CurrentMaskIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                if(!SetFirstStatus) 
				{
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x was the first irp processed by this\n"
                         "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                        );
                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;
                }

                SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                    
                SerialDump(
                    SERDIAG4,
                    ("SERIAL: Perhaps another mask irp was found in the queue\n"
                     "------- %x/%x <- values should be the same\n",
                     pPort->CurrentMaskIrp,NewIrp)
                    );
			} 
			else 
			{
                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be canceled
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if(pPort->CurrentMaskIrp->Cancel) 
				{
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x irp was already marked as cancelled\n",
                         pPort->CurrentMaskIrp)
                        );

                    IoReleaseCancelSpinLock(OldIrql);
                    pPort->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if(!SetFirstStatus) 
					{
                        SerialDump(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                            );

                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;
                    }

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                      
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         pPort->CurrentMaskIrp,NewIrp)
                        );

                } 
				else 
				{

                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x will become the current wait irp\n",
                         pPort->CurrentMaskIrp)
                        );
                    
					if(!SetFirstStatus) 
					{
                        SerialDump(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                            );

                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(pPort->CurrentMaskIrp);
                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!pPort->IrpMaskLocation);
                    ASSERT(!pPort->CurrentWaitIrp);

                    pPort->CurrentWaitIrp = pPort->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(pPort->CurrentWaitIrp);
                    IoSetCancelRoutine(pPort->CurrentWaitIrp, SerialCancelWait);
                     

                    //
                    // Since the cancel routine has a reference to
                    // the irp we need to update the reference count.
                    //

                    SERIAL_INC_REFERENCE(pPort->CurrentWaitIrp);

                    KeSynchronizeExecution(pCard->Interrupt, SerialGiveWaitToIsr, pPort);
                        
                    IoReleaseCancelSpinLock(OldIrql);

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, FALSE);
                       
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         pPort->CurrentMaskIrp,NewIrp)
                        );

                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3, ("SERIAL: In SerialGrabWaitFromIsr\n"));
        
    if(pPort->IrpMaskLocation) 
	{
        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

        //
        // The isr still "owns" the irp.
        //

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentWaitIrp);
    }

    return FALSE;
}


BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialGiveWaitToIsr\n")
        );
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!pPort->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentWaitIrp);

    if(!pPort->HistoryMask) 
	{
        SerialDump(
            SERDIAG4,
            ("SERIAL: No events occured prior to the wait call\n")
            );

        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        pPort->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        pPort->IrpMaskLocation = pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
           
        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

    } 
	else 
	{
        SerialDump(
            SERDIAG4,
            ("SERIAL: %x occurred prior to the wait - starting the\n"
             "------- completion code for %x\n",
             pPort->HistoryMask,pPort->CurrentWaitIrp)
            );

        *((ULONG *)pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer) 
			= pPort->HistoryMask;

        pPort->HistoryMask = 0;
        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        pPort->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

        KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
    
    }

    return FALSE;
}


BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3, ("SERIAL: In SerialFinishOldWait\n"));
    
	if(pPort->IrpMaskLocation) 
	{

        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );
        //
        // The isr still "owns" the irp.
        //

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

        KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
           
    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    pPort->HistoryMask &= *((ULONG *)pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer);

    pPort->IsrWaitMask = *((ULONG *)pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer);
                                            
    SerialDump(
        SERDIAG4,
        ("SERIAL: Set mask location of %x, in irp %x, with system buffer of %x\n",
         pPort->IrpMaskLocation,
         pPort->CurrentMaskIrp,pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer)
        );

    return FALSE;
}


VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERDIAG3, ("SERIAL: In SerialCancelWait\n"));

    SerialDump(
        SERDIAG4,
        ("SERIAL: Canceling wait for irp %x\n",pPort->CurrentWaitIrp)
        );

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWaitFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

}

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    SerialDump(SERDIAG3, ("SERIAL: In SerialCompleteWait\n"));

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialDump(
        SERDIAG4,
        ("SERIAL: Completing wait for irp %x\n",pPort->CurrentWaitIrp)
        );

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\write.c ===
#include "precomp.h"			
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to write
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/


BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    );



NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;


    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //
    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) 
	{
        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //
        return SerialStartOrQueue(pPort, Irp, &pPort->WriteQueue, &pPort->CurrentWriteIrp, SerialStartWrite);
    } 
	else 
	{
        Irp->IoStatus.Status = STATUS_SUCCESS;
       	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, 0);
        return STATUS_SUCCESS;
    }

}

NTSTATUS
SerialStartWrite(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.

Arguments:

    pPort - Points to the serial device extension

Return Value:

    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.

--*/

{

    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    do 
	{
        //
        // If there is an xoff counter then complete it.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        //
        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.
        //

        if(pPort->CurrentXoffIrp) 
		{
            InsertHeadList(&pPort->WriteQueue,&pPort->CurrentWriteIrp->Tail.Overlay.ListEntry);
			SpxIRPCounter(pPort, pPort->CurrentWriteIrp, IRP_QUEUED);

            if(!SetFirstStatus) 
			{
                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            if(SERIAL_REFERENCE_COUNT(pPort->CurrentXoffIrp)) 
			{
                //
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.
                //

                SERIAL_INC_REFERENCE(pPort->CurrentXoffIrp);

                pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

                //
                // The following call will actually release the cancel spin lock.
                //
                SerialTryToCompleteCurrent(	pPort,
											SerialGrabXoffFromIsr,
											OldIrql,
											STATUS_SERIAL_MORE_WRITES,
											&pPort->CurrentWriteIrp,
											&pPort->WriteQueue,
											NULL,
											&pPort->XoffCountTimer,
											SerialStartWrite,
											SerialGetNextWrite);
											
                return FirstStatus;

            } 
			else 
			{
                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

                return FirstStatus;
            }

        } 
		else 
		{
            IoReleaseCancelSpinLock(OldIrql);
        }

        UseATimer = FALSE;

        //
        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.
        //

        KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

        Timeouts = pPort->Timeouts;

        KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

        if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier) 
		{
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);
                                           
            UseATimer = TRUE;

            //
            // We have some timer values to calculate.
            //
            // Take care, we might have an xoff counter masquerading as a write.
            //
            TotalTime = RtlEnlargedUnsignedMultiply((IrpSp->MajorFunction == IRP_MJ_WRITE)?(IrpSp->Parameters.Write.Length):(1),
													Timeouts.WriteTotalTimeoutMultiplier);

            TotalTime = RtlLargeIntegerAdd(TotalTime, RtlConvertUlongToLargeInteger(Timeouts.WriteTotalTimeoutConstant));
            TotalTime = RtlExtendedIntegerMultiply(TotalTime, -10000);
        }

        //
        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.
        //

        SERIAL_INIT_REFERENCE(pPort->CurrentWriteIrp);

        //
        // We need to see if this irp should be canceled.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        if(pPort->CurrentWriteIrp->Cancel) 
		{
            IoReleaseCancelSpinLock(OldIrql);
            pPort->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if(!SetFirstStatus) 
			{
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }

        } 
		else 
		{
            if(!SetFirstStatus) 
			{

                //
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.
                //

                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            //
            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.
            //

            IoSetCancelRoutine(pPort->CurrentWriteIrp, SerialCancelCurrentWrite);
                
            SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);

            if(UseATimer) 
			{

                KeSetTimer(&pPort->WriteRequestTotalTimer, TotalTime, &pPort->TotalWriteTimeoutDpc);

                //
                // This timer now has a reference to the irp.
                //

                SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);
            }

            KeSynchronizeExecution(pCard->Interrupt, SerialGiveWriteToIsr, pPort);
            IoReleaseCancelSpinLock(OldIrql);
            break;

        }

        //
        // Well the write was canceled before we could start it up.
        // Try to get another.
        //

        SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return FirstStatus;
}

VOID
SerialGetNextWrite(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

--*/

{
	PCARD_DEVICE_EXTENSION pCard = NULL;

    pPort = CONTAINING_RECORD(QueueToProcess, PORT_DEVICE_EXTENSION, WriteQueue);
	pCard = pPort->pParentCardExt;

    do 
	{
        //
        // We could be completing a flush.
        //
        if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_WRITE)
		{
            KIRQL OldIrql;

            ASSERT(pPort->TotalCharsQueued >= (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length));
                   
            IoAcquireCancelSpinLock(&OldIrql);
            pPort->TotalCharsQueued -= IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length;
            IoReleaseCancelSpinLock(OldIrql);
        } 
		else
		{
			if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
			{

				KIRQL OldIrql;

				IoAcquireCancelSpinLock(&OldIrql);

				//
				// If CurrentXoffIrp is not equal to null, this
				// implies that this is the "second" time around
				// for this irp, which implies that we should really
				// be completing it this time.
				//

				if (pPort->CurrentXoffIrp) 
				{
					pPort->CurrentXoffIrp = NULL;
					IoReleaseCancelSpinLock(OldIrql);
				} 
				else 
				{
					PIRP Irp = *CurrentOpIrp;

					PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

					//
					// We absolutely shouldn't have a cancel routine
					// at this point.
					//

					ASSERT(!Irp->CancelRoutine);

					//
					// This could only be a xoff counter masquerading as
					// a write irp.
					//

					pPort->TotalCharsQueued--;

					//
					// Check to see of the xoff irp has been set with success.
					// This means that the write completed normally.  If that
					// is the case, and it hasn't been set to cancel in the
					// meanwhile, then go on and make it the CurrentXoffIrp.
					//

					if(Irp->IoStatus.Status != STATUS_SUCCESS) 
					{

						//
						// Oh well, we can just finish it off.
						//
						NOTHING;

					} 
					else
					{
						if(Irp->Cancel) 
						{
							Irp->IoStatus.Status = STATUS_CANCELLED;
						} 
						else 
						{

							//
							// Give it a new cancel routine, and increment the
							// reference count because the cancel routine has
							// a reference to it.
							//

							IoSetCancelRoutine(Irp, SerialCancelCurrentXoff);

							SERIAL_INC_REFERENCE(Irp);

							//
							// We don't want to complete the current irp now.  This
							// will now get completed by the Xoff counter code.
							//
							CompleteCurrent = FALSE;

							//
							// Give the counter to the isr.
							//
							pPort->CurrentXoffIrp = Irp;
							KeSynchronizeExecution(pCard->Interrupt, SerialGiveXoffToIsr, pPort);                     
                        

							//
							// Start the timer for the counter and increment
							// the reference count since the timer has a
							// reference to the irp.
							//

							if(Xc->Timeout) 
							{
								KeSetTimer(&pPort->XoffCountTimer,
											RtlLargeIntegerNegate(RtlEnlargedUnsignedMultiply(10000,Xc->Timeout)),
											&pPort->XoffCountTimeoutDpc);

								SERIAL_INC_REFERENCE(Irp);
							}

						}
					}
				
					IoReleaseCancelSpinLock(OldIrql);

				}

			}
		}

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(pPort, CurrentOpIrp, QueueToProcess, NewIrp, CompleteCurrent);
           
        if(!*NewIrp) 
		{
            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            KeSynchronizeExecution(pCard->Interrupt, SerialProcessEmptyTransmit, pPort);
            IoReleaseCancelSpinLock(OldIrql);
            break;

        } 
		else
		{
			if(IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction == IRP_MJ_FLUSH_BUFFERS)
			{

				//
				// If we encounter a flush request we just want to get
				// the next irp and complete the flush.
				//
				// Note that if NewIrp is non-null then it is also
				// equal to CurrentWriteIrp.
				//

				ASSERT((*NewIrp) == (*CurrentOpIrp));
				(*NewIrp)->IoStatus.Status = STATUS_SUCCESS;
			} 
			else 
			{
				break;
			}
		}

    } while (TRUE);

}

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->IsrWaitMask && (pPort->IsrWaitMask & SERIAL_EV_TXEMPTY)
//	&& pPort->EmptiedTransmit
	&& (!pPort->TransmitImmediate) &&
        (!pPort->CurrentWriteIrp) && IsListEmpty(&pPort->WriteQueue)) {

        pPort->HistoryMask |= SERIAL_EV_TXEMPTY;
        if (pPort->IrpMaskLocation) {

            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            KeInsertQueueDpc(
                &pPort->CommWaitDpc,
                NULL,
                NULL
                );

        }

#if 0
        pPort->CountOfTryingToLowerRTS++;
        SerialPerhapsLowerRTS(pPort);
#endif
    }

    return FALSE;

}

BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);

    //
    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) {

        pPort->WriteLength = IrpSp->Parameters.Write.Length;
        pPort->WriteCurrentChar =
            pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer;

    } else {

        pPort->WriteLength = 1;
        pPort->WriteCurrentChar =
            ((PUCHAR)pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer) +
            FIELD_OFFSET(
                SERIAL_XOFF_COUNTER,
                XoffChar
                );

    }

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);

    //
    // Check first to see if an immediate char is transmitting.
    // If it is then we'll just slip in behind it when its
    // done.
    //

    if (!pPort->TransmitImmediate) {

        //
        // If there is no immediate char transmitting then we
        // will "re-enable" the transmit holding register empty
        // interrupt.  The 8250 family of devices will always
        // signal a transmit holding register empty interrupt
        // *ANY* time this bit is set to one.  By doing things
        // this way we can simply use the normal interrupt code
        // to start off this write.
        //
        // We've been keeping track of whether the transmit holding
        // register is empty so it we only need to do this
        // if the register is empty.
        //

// --------------------------------------------------- VIV  7/16/1993 begin
        if (pPort->HoldingEmpty) {
//            DISABLE_ALL_INTERRUPTS(pPort->Controller);
//            ENABLE_ALL_INTERRUPTS(pPort->Controller);
          Io8_EnableTxInterrupts(pPort);
        }
// --------------------------------------------------- VIV  7/16/1993 end
    }

#if 0
    //
    // The rts line may already be up from previous writes,
    // however, it won't take much additional time to turn
    // on the RTS line if we are doing transmit toggling.
    //

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialSetRTS(pPort);

    }
#endif

    return FALSE;

}

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWriteFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    //

    if (pPort->WriteLength) {

        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if (IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)
            ->MajorFunction == IRP_MJ_WRITE) {

            pPort->CurrentWriteIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    pPort->CurrentWriteIrp
                    )->Parameters.Write.Length -
                pPort->WriteLength;

        } else {

            pPort->CurrentWriteIrp->IoStatus.Information = 0;

        }

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentWriteIrp);

        pPort->WriteLength = 0;

    }

    return FALSE;

}

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->CountSinceXoff) {

        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        pPort->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentXoffIrp);

    }

    return FALSE;

}

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabXoffFromIsr,
        OldIrql,
        STATUS_SERIAL_COUNTER_TIMEOUT,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PSERIAL_XOFF_COUNTER Xc =
        pPort->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    pPort->CountSinceXoff = Xc->Counter;

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentXoffIrp);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\io8_card.h ===
#ifndef IO8_CARD_H
#define IO8_CARD_H	





//////////////////////////////////////////////////////////////////////////////////////////
// I/O8+ Card Device Extenstion.
// Information specific to I/O8+ card.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CARD_DEVICE_EXTENSION 
{

	COMMON_CARD_DEVICE_EXTENSION;	// Common Card Device Extension 
	
	ULONG CrystalFrequency;			// Frequency of onboard crystal

	PHYSICAL_ADDRESS	PCIConfigRegisters;
	ULONG				SpanOfPCIConfigRegisters;

} CARD_DEVICE_EXTENSION, *PCARD_DEVICE_EXTENSION;



//////////////////////////////////////////////////////////////////////////////////////////
// I/O8+ Port Device Extenstion.
// Information specific to I/O8+ Ports.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _PORT_DEVICE_EXTENSION 
{

	COMMON_PORT_DEVICE_EXTENSION;		// Common Card Device Extension 
	ULONG			SysPortNumber;		// System port number 
	
///////////////////////////////////////////////////////////////////
	UCHAR	ChannelNumber;

// THE ABOVE SHOULD NOT BE NEEDED - SHOULD USE PortNumber INSTEAD
///////////////////////////////////////////////////////////////////

#ifdef	CrystalFreqTest
	#define	CRYSTALFREQTEST_TX	1				// Begin transmit part of test 
	#define	CRYSTALFREQTEST_RX	2				// Begin receive part of test

    USHORT			CrystalFreqTest;			// Flag to indicate crystal frequency test 
    USHORT			CrystalFreqTestChars;		// Number of characters to test with 
    USHORT			CrystalFreqTestRxCount;		// Count of received characters 
    LARGE_INTEGER	CrystalFreqTestStartTime;	// Timestamp for beginning of test 
    LARGE_INTEGER	CrystalFreqTestStopTime;	// Timestamp for end of test 
#endif

	// Timing variables... 
    LARGE_INTEGER		IntervalTime;			// Read interval time 
	LARGE_INTEGER		ShortIntervalAmount;	// Short tread interval time 
	LARGE_INTEGER		LongIntervalAmount;		// Long read interval time 
	LARGE_INTEGER		CutOverAmount;			// Used to determine short/long interval time 
	LARGE_INTEGER		LastReadTime;			// System time of last read 
	PLARGE_INTEGER		IntervalTimeToUse;		// Interval timing delta time delay 


	// Queued IRP lists... 
	LIST_ENTRY		ReadQueue;		// Head of read IRP list, protected by cancel spinlock 
	LIST_ENTRY		WriteQueue;		// Head of write IRP list, protected by cancel spinlock 
	LIST_ENTRY		MaskQueue;		// Head of set/wait mask IRP list, protected by cancel spinlock 
	LIST_ENTRY		PurgeQueue;		// Head of purge IRP list, protected by cancel spinlock 


	// Current IRPs... 
	PIRP			CurrentReadIrp;			// Pointer to current read IRP 
	PIRP			CurrentWriteIrp;		// Pointer to current write IRP 
	PIRP			CurrentMaskIrp;			// Pointer to current mask IRP 
	PIRP			CurrentPurgeIrp;		// Pointer to current purge IRP 
	PIRP			CurrentWaitIrp;			// Pointer to current wait IRP 
	PIRP			CurrentImmediateIrp;	// Pointer to current send immediate IRP 
	PIRP			CurrentXoffIrp;			// Pointer to current XOFF_COUNTER IRP 

	// Write IRP variables... 
	ULONG			WriteLength;			// Write character count in current write IRP 
	PUCHAR			WriteCurrentChar;		// Pointer to write character in current write IRP 

	// Read IRP variables... 
	PUCHAR			InterruptReadBuffer;	// Read buffer current pointer in current read IRP 
	PUCHAR			ReadBufferBase;			// Read buffer base pointer in current read IRP 
	ULONG			CharsInInterruptBuffer;	// Characters read into read buffer 
//	KSPIN_LOCK		BufferLock;				// Spinlock protecting "CharsInInterruptBuffer" 
	PUCHAR			CurrentCharSlot;		// Pointer at space to store new read data 
	PUCHAR			LastCharSlot;			// Last valid position in read buffer 
	PUCHAR			FirstReadableChar;		// First read character in read buffer 
	ULONG			BufferSize;				// Read buffer size 
	ULONG			BufferSizePt8;			// 80% read buffer size 
	ULONG			NumberNeededForRead;	// Number of characters requested in current read IRP 


	// Mask IRP variables... 
	ULONG			IsrWaitMask;		// Wait mask in current wait IRP 
	ULONG			HistoryMask;		// History of masked events 
	ULONG			*IrpMaskLocation;	// Pointer to mask location 


	// Serial port configuration...
	ULONG				CurrentBaud;		// Current baud rate 
	ULONG				SupportedBauds;		// Bitmask defining supported baud rates 
	SERIAL_HANDFLOW		HandFlow;			// Current handshaking and flow control settings 
	UCHAR				LineControl;		// Current parity,databits,stopbits 
	SERIAL_CHARS		SpecialChars;		// Current Special error/replacement characters 
	SERIAL_TIMEOUTS		Timeouts;			// Read and write timeouts 
	UCHAR				ValidDataMask;		// Read data mask 
	UCHAR				EscapeChar;			// Escape character used with line/modem status strings 
	BOOLEAN				InsertEscChar;		// Indicates of EscapeChar should be inserted 


	// Serial port status... 
	LONG			CountSinceXoff;			// Nun chars read since XOFF counter started 
	ULONG			CountOfTryingToLowerRTS;// Count of processes trying to lower RTS 
	BOOLEAN			TransmitImmediate;		// Indicates of transmit immediate is pending 
	BOOLEAN			EmptiedTransmit;		// Indicates transmit empty 
	UCHAR			ImmediateChar;			// Character to be transmitted immediately 
	ULONG			TXHolding;				// Reasons for transmit blocked 
	ULONG			RXHolding;				// Reasons for receive blocked 
	ULONG			ErrorWord;				// Error conditions 
	ULONG			TotalCharsQueued;		// Total number of queued characters in all write IRPs 
	LONG			CountOnLastRead;		// Number of chars read last time interval timer DPC ran 
	ULONG			ReadByIsr;				// Number of characters read during ISR 

	KSPIN_LOCK		ControlLock;			// Used to protect certain fields 


	// Deferred procedure calls... 
	KDPC		CompleteWriteDpc;			// DPC used to complete write IRPs 
	KDPC		CompleteReadDpc;			// DPC used to complete read IRPs 
	KDPC		TotalReadTimeoutDpc;		// DPC used to handle read total timeout 
	KDPC		IntervalReadTimeoutDpc;		// DPC used to handle read interval timeout 
	KDPC		TotalWriteTimeoutDpc;		// DPC used to handle write total timeout 
	KDPC		CommErrorDpc;				// DPC used to handle cancel on error 
	KDPC		CommWaitDpc;				// DPC used to handle waking IRPs waiting on an event 
	KDPC		CompleteImmediateDpc;		// DPC used to handle transmitting an immediate character 
	KDPC		TotalImmediateTimeoutDpc;	// DPC used to handle immediate char timeout 
	KDPC		XoffCountTimeoutDpc;		// DPC used to handle XOFF_COUNT timeout 
	KDPC		XoffCountCompleteDpc;		// DPC used to complete XOFF_COUNT IRP 
	KDPC		StartTimerLowerRTSDpc;		// DPC used to check for RTS lowering 
	KDPC		PerhapsLowerRTSDpc;			// DPC used to check for RTS lowering 

	// Timers... 
	KTIMER		ReadRequestTotalTimer;		// Timer used to handle total read request timeout 
	KTIMER		ReadRequestIntervalTimer;	// Timer used to handle interval read timeout 
	KTIMER		WriteRequestTotalTimer;		// Timer used to handle total write request timeout 
	KTIMER		ImmediateTotalTimer;		// Timer used to handle send immediate timeout 
	KTIMER		XoffCountTimer;				// Timer used to handle XOFF_COUNT timeout 
	KTIMER		LowerRTSTimer;				// Timer used to handle lower RTS timing 




    // Set at intialization to indicate that on the current
    // architecture we need to unmap the base register address
    // when we unload the driver.
    BOOLEAN UnMapRegisters;

    // Set at intialization to indicate that on the current
    // architecture we need to unmap the interrupt status address
    // when we unload the driver.
    BOOLEAN UnMapStatus;


    // This is only accessed at interrupt level.  It keeps track
    // of whether the holding register is empty.
    // Really it keeps track whether Tx interrupts were Disabled or not.
    BOOLEAN HoldingEmpty;


#define BREAK_START 1
#define BREAK_END   2

    BOOLEAN DoBreak;

    // This simply indicates that the port associated with this
    // extension is part of a multiport card.
    BOOLEAN PortOnAMultiportCard;

    // These two booleans are used to indicate to the isr transmit
    // code that it should send the xon or xoff character.  They are
    // only accessed at open and at interrupt level.
    BOOLEAN SendXonChar;
    BOOLEAN SendXoffChar;

    // This boolean will be true if a 16550 is present *and* enabled.
    BOOLEAN FifoPresent;


} PORT_DEVICE_EXTENSION, *PPORT_DEVICE_EXTENSION;











// PORT_DEVICE_EXTENSION.CountOnLastRead definitions... 
#define		SERIAL_COMPLETE_READ_CANCEL		((LONG)-1)
#define		SERIAL_COMPLETE_READ_TOTAL		((LONG)-2)
#define		SERIAL_COMPLETE_READ_COMPLETE	((LONG)-3)

// PORT_DEVICE_EXTENSION.LineControl definitions... 
#define		SERIAL_5_DATA		((UCHAR)0x00)
#define		SERIAL_6_DATA		((UCHAR)0x01)
#define		SERIAL_7_DATA		((UCHAR)0x02)
#define		SERIAL_8_DATA		((UCHAR)0x03)
#define		SERIAL_DATA_MASK	((UCHAR)0x03)

#define		SERIAL_1_STOP		((UCHAR)0x00)
#define		SERIAL_1_5_STOP		((UCHAR)0x04) // Only valid for 5 data bits
#define		SERIAL_2_STOP		((UCHAR)0x04) // Not valid for 5 data bits
#define		SERIAL_STOP_MASK	((UCHAR)0x04)

#define		SERIAL_NONE_PARITY	((UCHAR)0x00)
#define		SERIAL_ODD_PARITY	((UCHAR)0x08)
#define		SERIAL_EVEN_PARITY	((UCHAR)0x18)
#define		SERIAL_MARK_PARITY	((UCHAR)0x28)
#define		SERIAL_SPACE_PARITY	((UCHAR)0x38)
#define		SERIAL_PARITY_MASK	((UCHAR)0x38)
#define		SERIAL_LCR_BREAK	0x40


// PORT_DEVICE_EXTENSION.SpecialChars default xon/xoff characters... 
#define		SERIAL_DEF_XON		0x11
#define		SERIAL_DEF_XOFF		0x13

// PORT_DEVICE_EXTENSION.TXHolding definitions... 
#define		SERIAL_TX_CTS		((ULONG)0x01)
#define		SERIAL_TX_DSR		((ULONG)0x02)
#define		SERIAL_TX_DCD		((ULONG)0x04)
#define		SERIAL_TX_XOFF		((ULONG)0x08)
#define		SERIAL_TX_BREAK		((ULONG)0x10)

// PORT_DEVICE_EXTENSION.RXHolding definitions...
#define		SERIAL_RX_DTR		((ULONG)0x01)
#define		SERIAL_RX_XOFF		((ULONG)0x02)
#define		SERIAL_RX_RTS		((ULONG)0x04)
#define		SERIAL_RX_DSR		((ULONG)0x08)	
#define		SERIAL_RX_FULL      ((ULONG)0x10)   // VIV: If Io8 Rx queue is full.

// PORT_DEVICE_EXTENSION.LastStatus definitions... 
#define		SERIAL_LSR_DR       0x01
#define		SERIAL_LSR_OE		0x02
#define		SERIAL_LSR_PE		0x04
#define		SERIAL_LSR_FE		0x08
#define		SERIAL_LSR_BI		0x10

// 16550 Modem Control Register definitions... 
#define		SERIAL_MCR_DTR		0x01
#define		SERIAL_MCR_RTS		0x02

// 16550 Modem Status Register definitions... 
#define		SERIAL_MSR_DCTS		0x01
#define		SERIAL_MSR_DDSR		0x02
#define		SERIAL_MSR_TERI		0x04
#define		SERIAL_MSR_DDCD		0x08
#define		SERIAL_MSR_CTS		0x10
#define		SERIAL_MSR_DSR		0x20
#define		SERIAL_MSR_RI		0x40
#define		SERIAL_MSR_DCD		0x80



// These masks define the interrupts that can be enabled or disabled.
//
// This interrupt is used to notify that there is new incomming
// data available.  The SERIAL_RDA interrupt is enabled by this bit.
#define SERIAL_IER_RDA   0x01


// This interrupt is used to notify that there is space available
// in the transmitter for another character.  The SERIAL_THR
// interrupt is enabled by this bit.
#define SERIAL_IER_THR   0x02

// This interrupt is used to notify that some sort of error occured
// with the incomming data.  The SERIAL_RLS interrupt is enabled by
// this bit.
#define SERIAL_IER_RLS   0x04

// This interrupt is used to notify that some sort of change has
// taken place in the modem control line.  The SERIAL_MS interrupt is
// enabled by this bit.
#define SERIAL_IER_MS    0x08


// These masks define the values of the interrupt identification
// register.  The low bit must be clear in the interrupt identification
// register for any of these interrupts to be valid.  The interrupts
// are defined in priority order, with the highest value being most
// important.  See above for a description of what each interrupt
// implies.
#define SERIAL_IIR_RLS      0x06
#define SERIAL_IIR_RDA      0x04
#define SERIAL_IIR_CTI      0x0c
#define SERIAL_IIR_THR      0x02
#define SERIAL_IIR_MS       0x00


// This bit mask get the value of the high two bits of the
// interrupt id register.  If this is a 16550 class chip
// these bits will be a one if the fifo's are enbled, otherwise
// they will always be zero.
#define SERIAL_IIR_FIFOS_ENABLED 0xc0

// If the low bit is logic one in the interrupt identification register
// this implies that *NO* interrupts are pending on the device.
#define SERIAL_IIR_NO_INTERRUPT_PENDING 0x01




// These masks define access to the fifo control register.

// Enabling this bit in the fifo control register will turn
// on the fifos.  If the fifos are enabled then the high two
// bits of the interrupt id register will be set to one.  Note
// that this only occurs on a 16550 class chip.  If the high
// two bits in the interrupt id register are not one then
// we know we have a lower model chip.
#define SERIAL_FCR_ENABLE     0x01
#define SERIAL_FCR_RCVR_RESET 0x02
#define SERIAL_FCR_TXMT_RESET 0x04


// This set of values define the high water marks (when the
// interrupts trip) for the receive fifo.
#define SERIAL_1_BYTE_HIGH_WATER   0x00
#define SERIAL_4_BYTE_HIGH_WATER   0x40
#define SERIAL_8_BYTE_HIGH_WATER   0x80
#define SERIAL_14_BYTE_HIGH_WATER  0xc0


// This defines the bit used to control the definition of the "first"
// two registers for the 8250.  These registers are the input/output
// register and the interrupt enable register.  When the DLAB bit is
// enabled these registers become the least significant and most
// significant bytes of the divisor value.
#define SERIAL_LCR_DLAB     0x80


// This bit is used for general purpose output.
#define SERIAL_MCR_OUT1     0x04

// This bit is used for general purpose output.
#define SERIAL_MCR_OUT2     0x08

// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
#define SERIAL_MCR_LOOP     0x10


// This is the transmit holding register empty indicator.  It is set
// to indicate that the hardware is ready to accept another character
// for transmission.  This bit is cleared whenever a character is
// written to the transmit holding register.
#define SERIAL_LSR_THRE     0x20


// This bit is the transmitter empty indicator.  It is set whenever the
// transmit holding buffer is empty and the transmit shift register
// (a non-software accessable register that is used to actually put
// the data out on the wire) is empty.  Basically this means that all
// data has been sent.  It is cleared whenever the transmit holding or
// the shift registers contain data.
#define SERIAL_LSR_TEMT     0x40


// This bit indicates that there is at least one error in the fifo.
// The bit will not be turned off until there are no more errors
// in the fifo.
#define SERIAL_LSR_FIFOERR  0x80


//
// This should be more than enough space to hold then
// numeric suffix of the device name.
//
#define DEVICE_NAME_DELTA 20


//
// Up to 16 Ports Per card.  However for sixteen
// port cards the interrupt status register must be
// the indexing kind rather then the bitmask kind.
//
#define SERIAL_MAX_PORTS_INDEXED      (16)
#define SERIAL_MAX_PORTS_NONINDEXED   (8)
















//---------------------------------------------------- VIV  8/5/1993 begin 
#if 0

//
// Sets the divisor latch register.  The divisor latch register
// is used to control the baud rate of the 8250.
//
// As with all of these routines it is assumed that it is called
// at a safe point to access the hardware registers.  In addition
// it also assumes that the data is correct.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// DesiredDivisor - The value to which the divisor latch register should
//                  be set.
//
#define WRITE_DIVISOR_LATCH(BaseAddress,DesiredDivisor)           \
do                                                                \
{                                                                 \
    PUCHAR Address = BaseAddress;                                 \
    SHORT Divisor = DesiredDivisor;                               \
    UCHAR LineControl;                                            \
    LineControl = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER); \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)                    \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+DIVISOR_LATCH_LSB,                                \
        (UCHAR)(Divisor & 0xff)                                   \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+DIVISOR_LATCH_MSB,                                \
        (UCHAR)((Divisor & 0xff00) >> 8)                          \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        LineControl                                               \
        );                                                        \
} while (0)

//
// Reads the divisor latch register.  The divisor latch register
// is used to control the baud rate of the 8250.
//
// As with all of these routines it is assumed that it is called
// at a safe point to access the hardware registers.  In addition
// it also assumes that the data is correct.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// DesiredDivisor - A pointer to the 2 byte word which will contain
//                  the value of the divisor.
//
#define READ_DIVISOR_LATCH(BaseAddress,PDesiredDivisor)           \
do                                                                \
{                                                                 \
    PUCHAR Address = BaseAddress;                                 \
    PSHORT PDivisor = PDesiredDivisor;                            \
    UCHAR LineControl;                                            \
    UCHAR Lsb;                                                    \
    UCHAR Msb;                                                    \
    LineControl = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER); \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)                    \
        );                                                        \
    Lsb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_LSB);             \
    Msb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_MSB);             \
    *PDivisor = Lsb;                                              \
    *PDivisor = *PDivisor | (((USHORT)Msb) << 8);                 \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        LineControl                                               \
        );                                                        \
} while (0)

//
// This macro reads the interrupt enable register.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
#define READ_INTERRUPT_ENABLE(BaseAddress)                     \
    (READ_PORT_UCHAR((BaseAddress)+INTERRUPT_ENABLE_REGISTER))

//
// This macro writes the interrupt enable register.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// Values - The values to write to the interrupt enable register.
//
#define WRITE_INTERRUPT_ENABLE(BaseAddress,Values)                \
do                                                                \
{                                                                 \
    WRITE_PORT_UCHAR(                                             \
        BaseAddress+INTERRUPT_ENABLE_REGISTER,                    \
        Values                                                    \
        );                                                        \
} while (0)

//
// This macro disables all interrupts on the hardware.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define DISABLE_ALL_INTERRUPTS(BaseAddress)       \
do                                                \
{                                                 \
    WRITE_INTERRUPT_ENABLE(BaseAddress,0);        \
} while (0)

//
// This macro enables all interrupts on the hardware.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define ENABLE_ALL_INTERRUPTS(BaseAddress)        \
do                                                \
{                                                 \
                                                  \
    WRITE_INTERRUPT_ENABLE(                       \
        (BaseAddress),                            \
        (UCHAR)(SERIAL_IER_RDA | SERIAL_IER_THR | \
                SERIAL_IER_RLS | SERIAL_IER_MS)   \
        );                                        \
                                                  \
} while (0)

//
// This macro reads the interrupt identification register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// Note that this routine potententially quites a transmitter
// empty interrupt.  This is because one way that the transmitter
// empty interrupt is cleared is to simply read the interrupt id
// register.
//
//
#define READ_INTERRUPT_ID_REG(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+INTERRUPT_IDENT_REGISTER))

//
// This macro reads the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_MODEM_CONTROL(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+MODEM_CONTROL_REGISTER))

//
// This macro reads the modem status register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_MODEM_STATUS(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+MODEM_STATUS_REGISTER))

//
// This macro reads a value out of the receive buffer
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_RECEIVE_BUFFER(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+RECEIVE_BUFFER_REGISTER))

//
// This macro reads the line status register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_LINE_STATUS(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+LINE_STATUS_REGISTER))

//
// This macro writes the line control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define WRITE_LINE_CONTROL(BaseAddress,NewLineControl)           \
do                                                               \
{                                                                \
    WRITE_PORT_UCHAR(                                            \
        (BaseAddress)+LINE_CONTROL_REGISTER,                     \
        (NewLineControl)                                         \
        );                                                       \
} while (0)

//
// This macro reads the line control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_LINE_CONTROL(BaseAddress)           \
    (READ_PORT_UCHAR((BaseAddress)+LINE_CONTROL_REGISTER))


//
// This macro writes to the transmit register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// TransmitChar - The character to send down the wire.
//
//
#define WRITE_TRANSMIT_HOLDING(BaseAddress,TransmitChar)       \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+TRANSMIT_HOLDING_REGISTER,               \
        (TransmitChar)                                         \
        );                                                     \
} while (0)

//
// This macro writes to the control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// ControlValue - The value to set the fifo control register too.
//
//
#define WRITE_FIFO_CONTROL(BaseAddress,ControlValue)           \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+FIFO_CONTROL_REGISTER,                   \
        (ControlValue)                                         \
        );                                                     \
} while (0)

//
// This macro writes to the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// ModemControl - The control bits to send to the modem control.
//
//
#define WRITE_MODEM_CONTROL(BaseAddress,ModemControl)          \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+MODEM_CONTROL_REGISTER,                  \
        (ModemControl)                                         \
        );                                                     \
} while (0)

#endif
//---------------------------------------------------- VIV  8/5/1993 end



#endif // End of IO8_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\io8_nt.h ===
/***************************************************************************\
*                                                                           *
*     IO8_NT.H    -   IO8+ Intelligent I/O Board driver                     *
*                                                                           *
*     Copyright (c) 1992-1993 Ring Zero Systems, Inc.                       *
*     All Rights Reserved.                                                  *
*                                                                           *
\***************************************************************************/
#ifndef IO8_NT_H
#define IO8_NT_H


/*
** Numbers of this and that in system
*/
#define	MAX_HOSTS		4
#define PORTS_PER_HOST	8
#define	MAX_PORTS		(MAX_HOSTS*PORTS_PER_HOST)

/*
** Ident byte. This is splattered across the DSR lines
** at all times.
*/
#define	IDENT		0x4D
#define	IDENTPCI	0xB2

/*
** Idle state of Global Service Vector
*/
#define	GSV_IDLE	0xFF

/*
** To enable/disable interrupts, write these values to the
** ADDRESS register.
*/
#define	INTENB		0x80
#define	INTDIS		0x00

/*
** CD1864 register stuff
*/
#define	GLOBAL		0x80
#define	CHANNEL		0x00

#define	SENDBREAK	0x81
#define	SENDDELAY	0x82
#define	STOPBREAK	0x83

/*
**  Definitions of all the registers that can appear on
**  the card. These are the CD1864 registers. High bit is set
**  to enable interrupts
*/
#define CCR			0x81	// Channel Command Register 
#define SRER		0x82	// Service Request Enable Register 
#define COR1		0x83	// Channel Option Register 1 
#define COR2		0x84	// Channel Option Register 2 
#define COR3		0x85	// Channel Option Register 3 
#define CCSR		0x86	// Channel Control Status Register 
#define RDCR		0x87	// Receive Data Count Register 
#define SCHR1		0x89	// Special Character Register 1 
#define SCHR2		0x8a	// Special Character Register 2 
#define SCHR3		0x8b	// Special Character Register 3 
#define SCHR4		0x8c	// Special Character Register 4 
#define MCOR1		0x90	// Modem Change Option Register 1 
#define MCOR2		0x91	// Modem Change Option Register 2 
#define MDCR		0x92	// Modem Change Register 
#define RTPR		0x98	// Receive Timeout Period Register 
#define MSVR		0xA8	// Modem Signal Value Register 
#define MSVRTS		0xA9	// Modem Signal Value-Request to Send 
#define MSVDTR		0xAa	// Modem Signal Value-Data Terminal Ready 
#define RBPRH		0xB1	// Receive Bit Rate Period Register High 
#define RBPRL		0xB2	// Receive Bit Rate Period Register Low 
#define RBR			0xB3	// Receiver Bit Register 
#define TBPRH		0xB9	// Transmit Bit Rate Period Register High 
#define TBPRL		0xBa	// Transmit Bit Rate Period Register Low 
#define GSVR		0xC0	// Global Service Vector Register 
#define GSCR1		0xC1	// Global Service Channel Register 1 
#define GSCR2		0xC2	// Global Service Channel Register 2 
#define GSCR3		0xC3	// Global Service Channel Register 3 
#define MSMR		0xE1	// Modem Service Match Register 
#define TSMR		0xE2	// Transmit Service Match Register 
#define RSMR		0xE3	// Receive Service Match Register 
#define CAR			0xE4	// Channel Access Register 
#define SRSR		0xE5	// Service Request Status Register 
#define SRCR		0xE6	// Service Request Configuration Register 
#define GFRCR		0xEb	// Global Firmware Revision Code Register 
#define PPRH		0xF0	// Prescaler Period Register High 
#define PPRL		0xF1	// Prescaler Period Register Low 
#define MRAR		0xF5	// Modem Request Acknowledge Register 
#define TRAR		0xF6	// Transmit Request Acknowledge Register 
#define RRAR		0xF7	// Receive Request Acknowledge Register 
#define RDR			0xF8	// Receiver Data Register 
#define RCSR		0xFa	// Receiver Character Status Register 
#define TDR			0xFb	// Transmit Data Register 
#define EOSRR		0xFf	// End of Service Request Register 

/* commands */
#define CHIP_RESET			0x81
#define CHAN_RESET			0x80
#define COR1_CHANGED		0x42
#define COR2_CHANGED		0x44
#define COR3_CHANGED		0x48
#define TXMTR_ENABLE		0x18
#define TXMTR_DISABLE		0x14
#define RCVR_ENABLE			0x12
#define RCVR_DISABLE		0x11
#define LLM_MODE			0x10	// Local Loopback Mode 
#define NO_LOOPBACK			0x00

/* register values */
#define	MSVR_DSR			0x80
#define	MSVR_CD				0x40
#define	MSVR_CTS			0x20
#define	MSVR_DTR			0x02
#define	MSVR_RTS			0x01
	
#define SRER_CONFIG			0xF9

#define	SRER_DSR			0x80
#define	SRER_CD				0x40
#define	SRER_CTS			0x20
#define	SRER_RXDATA			0x10
#define	SRER_RXSC			0x08
#define	SRER_TXRDY			0x04
#define	SRER_TXMPTY			0x02
#define	SRER_NNDT			0x01

#define	CCR_RESET_SOFT		0x80
#define	CCR_RESET_HARD		0x81
#define	CCR_CHANGE_COR1		0x42
#define	CCR_CHANGE_COR2		0x44
#define	CCR_CHANGE_COR3		0x48
#define	CCR_SEND_SC1		0x21
#define	CCR_SEND_SC2		0x22
#define	CCR_SEND_SC3		0x23
#define	CCR_SEND_SC4		0x24
#define	CCR_CTRL_RXDIS		0x11
#define	CCR_CTRL_RXEN		0x12
#define	CCR_CTRL_TXDIS		0x14
#define	CCR_CTRL_TXEN		0x18

#define	SRCR_REG_ACK_EN		0x40
#define	SRCR_REG_ACK_DIS	0x00

#define	COR1_NO_PARITY		0x00		// 000 
#define	COR1_ODD_PARITY		0xC0		// 110 
#define	COR1_EVEN_PARITY	0x40		// 010 
#define	COR1_IGN_PARITY		0x10
#define	COR1_MARK_PARITY	0xA0		// 101XXXXX 
#define	COR1_SPACE_PARITY	0x20		// 001XXXXX 
#define	COR1_1_STOP			0x00
#define	COR1_1_HALF_STOP	0x04
#define	COR1_2_STOP			0x08
#define	COR1_2_HALF_STOP	0x0C
#define	COR1_5_BIT			0x00
#define	COR1_6_BIT			0x01
#define	COR1_7_BIT			0x02
#define	COR1_8_BIT			0x03

#define	COR2_IXM			0x80
#define	COR2_TXIBE			0x40
#define	COR2_ETC			0x20
#define	COR2_LLM			0x10
#define	COR2_RLM			0x08
#define	COR2_RTSAO			0x04
#define	COR2_CTSAE			0x02
#define	COR2_DSRAE			0x01

#define	COR3_XONCD			0x80
#define	COR3_XOFFCD			0x40
#define	COR3_FCTM			0x20
#define	COR3_SCDE			0x10
#define	COR3_RXFIFO1		0x01
#define	COR3_RXFIFO2		0x02
#define	COR3_RXFIFO3		0x03
#define	COR3_RXFIFO4		0x04
#define	COR3_RXFIFO5		0x05
#define	COR3_RXFIFO6		0x06
#define	COR3_RXFIFO7		0x07
#define	COR3_RXFIFO8		0x08

#define	MCOR1_DSRZD			0x80
#define	MCOR1_CDZD			0x40
#define	MCOR1_CTSZD			0x20
#define MCOR1_NO_DTR		0x00
#define	MCOR1_DTR_THR_1		0x01
#define	MCOR1_DTR_THR_2		0x02
#define	MCOR1_DTR_THR_3		0x03
#define	MCOR1_DTR_THR_4		0x04
#define	MCOR1_DTR_THR_5		0x05
#define	MCOR1_DTR_THR_6		0x06
#define	MCOR1_DTR_THR_7		0x07
#define	MCOR1_DTR_THR_8		0x08

#define	MCOR2_DSROD			0x80
#define	MCOR2_CDOD			0x40
#define	MCOR2_CTSOD			0x20

#define	RCSR_TIMEOUT		0x80
#define	RCSR_SCD_MASK		0x70
#define	RCSR_SCD1			0x10
#define	RCSR_SCD2			0x20
#define RCSR_SCD3			0x30
#define RCSR_SCD4			0x40
#define	RCSR_BREAK			0x08
#define	RCSR_PARITY			0x04
#define	RCSR_FRAME			0x02
#define	RCSR_OVERRUN		0x01

#define	SRSR_ILVL_NONE		0x00
#define	SRSR_ILVL_RECV		0xC0
#define	SRSR_ILVL_TXMT		0x80
#define SRSR_ILVL_MODEM		0x40
#define	SRSR_IREQ3_MASK		0x30
#define	SRSR_IREQ3_EXT		0x20
#define	SRSR_IREQ3_INT		0x10
#define	SRSR_IREQ2_MASK		0x0C
#define	SRSR_IREQ2_EXT		0x08
#define	SRSR_IREQ2_INT		0x04
#define	SRSR_IREQ1_MASK		0x03
#define	SRSR_IREQ1_EXT		0x02
#define	SRSR_IREQ1_INT		0x01

//---------------------------------------------------- VIV  7/21/1993 begin
#define	MDCR_DDSR			0x80
#define	MDCR_DDCD			0x40
#define	MDCR_DCTS			0x20
//---------------------------------------------------- VIV  7/21/1993 end

typedef	unsigned char BYTE;
typedef	unsigned short WORD;
typedef	unsigned int DWORD;

typedef struct Io8Host
{
	int Address;	    // base address of card 
	int Interrupt;
	BYTE CurrentReg;	// last used register 
} Io8Host;


typedef struct Io8Port
{
	int	RxThreshold;	// how many characters to Rx before interrupt 
	int	RxTimeout;		// timeout(ms) before we timeout the read fifo
	int	IxAny;		    // is IxAny enabled? 
	char open_state;	// indicates if modem or local device open 
	char break_state;	// no break/ about to send break/ sent break 
} Io8Port;


#define IO8_LOCAL		0x01
#define IO8_MODEM		0x02

#define NO_BREAK		0x00
#define SEND_BREAK		0x01
#define BREAK_STARTED	0x02

extern	struct	tty io8__ttys[];

/*
** debug print macro
*/
#define DEBUG(x)	if (io8_debug>=x) printf

#ifndef TIOC
#define TIOC ('T'<<8)
#endif

#define	TCIO8DEBUG	(TIOC + 96)	
#define TCIO8PORTS	(TIOC + 107)
#define	TCIO8IXANY	(TIOC + 108)
#define	TCIO8GIXANY	(TIOC + 109)

/*   
** macros to get card number/ channel number from device
*/
#define GET_CARD(x) (((x) & 0x18)>>3)
#define GET_CHANNEL(x) ((x) & 0x7)

/*
** receive buffer threshold - interrupt when this is reached.
*/
#define RX_THRESHOLD	5

/*
** direct write defines - BUFF_MASK must be 1 less than BUFF_SIZE
*/
#define BUFF_SIZE		1024	
#define BUFF_MASK		1023
#define LOW_WATER		256
#define OP_DIRECT		1
#define OP_ONLCR_DIRECT	2

struct direct_buffer
{
	unsigned char	direct_possible,
	dir_in_progress;
	int		buff_in,
	buff_out;
	char io8_buff[BUFF_SIZE];
};


/*
** card details structure - this defines the structure which is patched at
** install time
*/
struct io8
{
	short vect;
	short addr;
};




#endif	// End of IO8_NT.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\io8_ver.h ===
/*****************************************************************************
*****************************                     ****************************
*****************************   Current Version   ****************************
*****************************                     ****************************
*****************************************************************************/

#ifndef IO8_VER_H
#define IO8_VER_H

/* The following definitions are used to define the driver "properties" */

#define	VER_MAJOR			01
#define	VER_MINOR			00
#define	VER_REVISION		01

#define VER_BUILD			0028
#define VER_BUILDSTR		"0028"

#define	VERSION_NUMBER		VER_MAJOR,VER_MINOR,VER_REVISION,VER_BUILD
#define VERSION_NUMBER_STR	"1.0.1." VER_BUILDSTR

#define COMPANY_NAME		"Perle Systems Ltd. " 
#define COPYRIGHT_YEARS		"2002 "
#define COPYRIGHT_SYMBOL	" "

#define PRODUCT_NAME		"I/O8+"

#define SOFTWARE_NAME		" Serial Device Driver "
#define DRIVER_FILENAME 	"IO8.SYS"


#endif	// End of IO8_VER.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\io8_proto.h ===
//////////////////////////////////////////////////////////////////
// Prototypes and macros that are used throughout the driver. 
//////////////////////////////////////////////////////////////////
#ifndef IO8_PROTO_H
#define IO8_PROTO_H


VOID DriverUnload(IN PDRIVER_OBJECT pDriverObject);

BOOLEAN Io8_Present(IN PVOID Context);
BOOLEAN Io8_ResetBoard(IN PVOID Context);
BOOLEAN Io8_ResetChannel(IN PVOID Context);
VOID    Io8_EnableAllInterrupts(IN PVOID Context);

BOOLEAN Io8_SetDTR(IN PVOID Context);
BOOLEAN Io8_ClearDTR(IN PVOID Context);

BOOLEAN Io8_Interrupt(IN PVOID Context);

BOOLEAN Io8_SwitchCardInterrupt(IN PVOID Context);

BOOLEAN	Io8_TestCrystal(IN PVOID Context);

BOOLEAN Io8_SetBaud(IN PVOID Context);
BOOLEAN Io8_SetLineControl(IN PVOID Context);
BOOLEAN Io8_SendXon(IN PVOID Context);
BOOLEAN Io8_SetFlowControl(IN PVOID Context);
VOID    Io8_SetChars(IN PVOID Context);

VOID    Io8_EnableTxInterrupts(IN PVOID Context);
VOID    Io8_EnableRxInterrupts(IN PVOID Context);
VOID    Io8_DisableRxInterrupts(IN PVOID Context);
VOID    Io8_DisableRxInterruptsNoChannel(IN PVOID Context);
VOID    Io8_DisableAllInterrupts(IN PVOID Context);

BOOLEAN Io8_TurnOnBreak(IN PVOID Context);
BOOLEAN Io8_TurnOffBreak(IN PVOID Context);

UCHAR   Io8_GetModemStatus(IN PVOID Context);
ULONG   Io8_GetModemControl(IN PVOID Context);

VOID    Io8_Simulate_Xon(IN PVOID Context);

typedef	struct	_SETBAUD
{
	PPORT_DEVICE_EXTENSION	pPort;
	ULONG					Baudrate;
	BOOLEAN					Result;

} SETBAUD, *PSETBAUD;



#endif	// End of IO8_PROTO.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\spx_defs.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_DEFS.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	Definitions for all the common PnP and power code.						*
*																						*
****************************************************************************************/

#if	!defined(SPX_DEFS_H)
#define SPX_DEFS_H	

static const PHYSICAL_ADDRESS PhysicalZero = {0};

#define DEVICE_OBJECT_NAME_LENGTH       128
#define SYMBOLIC_NAME_LENGTH            128

#define SERIAL_DEVICE_MAP               L"SERIALCOMM"


// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY		L"DosDevices"

#define MAX_ERROR_LOG_INSERT	52


// File IDs for Event Logging (top 8 bits only).
#define SPX_INIT_C		((ULONG)0x01000000)
#define SPX_PNP_C		((ULONG)0x02000000)
#define SPX_POWR_C		((ULONG)0x03000000)
#define SPX_DISP_C		((ULONG)0x04000000)
#define SPX_UTILS_C		((ULONG)0x05000000)
#define SPX_IIOC_C		((ULONG)0x06000000)




// COMMON_OBJECT_DATA.PnpPowerFlags definitions... 
#define	PPF_STARTED			0x00000001		// Device has been started 
#define	PPF_STOP_PENDING	0x00000002		// Device stop is pending 
#define	PPF_REMOVE_PENDING	0x00000004		// Device remove is pending 
#define	PPF_REMOVED			0x00000008		// Device has been removed 
#define	PPF_POWERED			0x00000010		// Device has been powered up 
			
typedef enum _SPX_MEM_COMPARES 
{
	AddressesAreEqual,
	AddressesOverlap,
	AddressesAreDisjoint

}SPX_MEM_COMPARES, *PSPX_MEM_COMPARES;

// IRP Counters
#define IRP_SUBMITTED		0x00000001	
#define IRP_COMPLETED		0x00000002
#define IRP_QUEUED			0x00000003
#define IRP_DEQUEUED		0x00000004


extern UNICODE_STRING SavedRegistryPath;	// Driver Registry Path.


#endif	// End of SPX_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\spx_card.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//  Card and Port device extension structures.
// 
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_CARD_H
#define SPX_CARD_H	

typedef	struct _CARD_DEVICE_EXTENSION *PCARD_DEV_EXT;
typedef	struct _PORT_DEVICE_EXTENSION *PPORT_DEV_EXT;

//////////////////////////////////////////////////////////////////////////////////////////
// Common header for all the device extensions 
// Common to all the PDOs and FDOs (cards and ports).
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_OBJECT_DATA
{
    PDEVICE_OBJECT	DeviceObject;			// A backpointer to the device object that contains this device extension.
    PDRIVER_OBJECT	DriverObject;			// Pointer to Driver Object
    BOOLEAN         IsFDO;					// A boolean to distringuish between PDO and FDO.
	PDEVICE_OBJECT	LowerDeviceObject;		// This is a pointer to the next lower device in the IRP stack.

    ULONG           DebugLevel;

	ULONG			PnpPowerFlags;			// Plug & Play / Power flags
	KSPIN_LOCK		PnpPowerFlagsLock;		// Lock for protecting the flags
	BOOLEAN         PowerQueryLock;			// Are we currently in a query power state? 
    LIST_ENTRY		StalledIrpQueue;		// List of stalled IRPs
	KSPIN_LOCK		StalledIrpLock;			// Lock for protecting stalled IRPs
	BOOLEAN			UnstallingFlag;			// Flag set if we are unstalling IRPs currently queued.

#ifndef	BUILD_SPXMINIPORT
	SYSTEM_POWER_STATE  SystemState;		// Current System Power State
    DEVICE_POWER_STATE  DeviceState;		// Current Device Power State
#endif

#ifdef WMI_SUPPORT
    WMILIB_CONTEXT		WmiLibInfo;			// WMI Information
#endif

} COMMON_OBJECT_DATA, *PCOMMON_OBJECT_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Configuration Data.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CONFIG_DATA 
{
	PHYSICAL_ADDRESS	RawPhysAddr;		// Raw physical address of card 
    PHYSICAL_ADDRESS    PhysAddr;			// Translated Physical address of card.
	PUCHAR				Controller;			// Virtual mapped sddress of card.
    ULONG               SpanOfController;	// Size of memory used by Cord.
    INTERFACE_TYPE      InterfaceType;		// Type of card (Isa or Pci)
    ULONG               BusNumber;			// Bus number card is using.
	ULONG				SlotNumber;			// Slot number on bus.		
    ULONG               AddressSpace;		// Flag used by SX
    ULONG               OriginalVector;		// Original Vector (bus relative)
    ULONG               OriginalIrql;		// Original Irql (bus relative)
    ULONG               TrVector;			// Translated Vector (system relative).
    KIRQL               TrIrql;				// Translated Irql (system relative).
    KINTERRUPT_MODE     InterruptMode;		// Interrupt mode (LevelSensitive or Latched)
	BOOLEAN				InterruptShareable;	// Interrupt shareable flag.
    KAFFINITY           ProcessorAffinity;	// Processor affintity.
	PKSERVICE_ROUTINE	OurIsr;				// Points to interrupt service routine.
    PVOID				OurIsrContext;		// Points to card device extension.
    PKINTERRUPT			Interrupt;			// Points to the interrupt object used by the card.
    ULONG               ClockRate;			// ClockRate.
} CONFIG_DATA,*PCONFIG_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_CARD_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	CONFIG_DATA;									// Card Config Data
	PDEVICE_OBJECT PDO;								// Pointer to Physical Device Object 

	UNICODE_STRING	DeviceName;						// Device name.
	ULONG			CardNumber;
	ULONG			NumberOfPorts;					// Number of ports attached to card.
	ULONG			NumPDOs;						// The PDOs currently enumerated.
	ULONG			CardType;						// Defines the type of host card.

	PDEVICE_OBJECT  AttachedPDO[PRODUCT_MAX_PORTS];	// Array of pointers to PDOs for ports attached to card.

} COMMON_CARD_DEVICE_EXTENSION, *PCOMMON_CARD_DEVICE_EXTENSION;



typedef struct _PORT_PERFORMANCE_STATS
{
    SERIALPERF_STATS;

	// IRPs with a Major Function of IRP_MJ_WRITE
	ULONG WriteIrpsSubmitted;
	ULONG WriteIrpsCompleted;
	ULONG WriteIrpsCancelled;
	ULONG WriteIrpsTimedOut;
	ULONG WriteIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_READ
	ULONG ReadIrpsSubmitted;
	ULONG ReadIrpsCompleted;
	ULONG ReadIrpsCancelled;
	ULONG ReadIrpsTimedOut;
	ULONG ReadIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_FLUSH_BUFFERS
	ULONG FlushIrpsSubmitted;
	ULONG FlushIrpsCompleted;
	ULONG FlushIrpsCancelled;
	ULONG FlushIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_DEVICE_CONTROL
	ULONG IoctlIrpsSubmitted;
	ULONG IoctlIrpsCompleted;
	ULONG IoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_INTERNAL_DEVICE_CONTROL
	ULONG InternalIoctlIrpsSubmitted;
	ULONG InternalIoctlIrpsCompleted;
	ULONG InternalIoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CREATE
	ULONG CreateIrpsSubmitted;
	ULONG CreateIrpsCompleted;
	ULONG CreateIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLOSE
	ULONG CloseIrpsSubmitted;
	ULONG CloseIrpsCompleted;
	ULONG CloseIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLEANUP
	ULONG CleanUpIrpsSubmitted;
	ULONG CleanUpIrpsCompleted;
	ULONG CleanUpIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION 
	ULONG InfoIrpsSubmitted;
	ULONG InfoIrpsCompleted;
	ULONG InfoIrpsCancelled;

} PORT_PERFORMANCE_STATS, *PPORT_PERFORMANCE_STATS;

//////////////////////////////////////////////////////////////////////////////////////////
// Common Port Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_PORT_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	PDEVICE_OBJECT		ParentFDO;					// A back pointer to the bus FDO  (this will be the LowerDeviceObject) 
	PCARD_DEV_EXT		pParentCardExt;				// Pointer to parent card device structure
	UNICODE_STRING		DeviceName;					// Device name eg. "\Device\PortName#".
	UNICODE_STRING		DeviceClassSymbolicName;	// Device Interface Name
	UNICODE_STRING		SerialCommEntry;			// Device name in SERIALCOMM Reg key eg. "PortName#".
	ULONG				PortNumber;					// Port number.
	UNICODE_STRING		DeviceID;					// Format: bus\device (must be most specific HardwareID)
	UNICODE_STRING		InstanceID;					// Instance ID 
	BOOLEAN				UniqueInstanceID;			// TRUE if InstanceID is gloablly unique, FALSE otherwise.
    UNICODE_STRING		HardwareIDs;				// Format bus\device or *PNPXXXX - meaning root enumerated
    UNICODE_STRING		CompatibleIDs;				// Compatible IDs to the Hardware ID
    UNICODE_STRING		DevDesc;					// Text describing device
    UNICODE_STRING		DevLocation;				// Text describing device location
	UNICODE_STRING		DosName;					// Dos device name "COM#" 
	UNICODE_STRING		SymbolicLinkName;			// External Device Name eg."\DosDevices\COM#".
	BOOLEAN				CreatedSymbolicLink;		// Flag to indicate that a symbolic link has been created.
	BOOLEAN				CreatedSerialCommEntry;		// Flag to indicate that a reg entry has been created in "SERIALCOMM"
	BOOLEAN				DeviceIsOpen;				// Flag to indicate when the port is open	
	ULONG				SavedModemControl;			// DTR/RTS signal states saved during power down
    FAST_MUTEX			OpenMutex;					// Mutex on open status

	    
#ifdef WMI_SUPPORT
	SERIAL_WMI_COMM_DATA	WmiCommData;			// WMI Comm Data
    SERIAL_WMI_HW_DATA		WmiHwData;				// WMI HW Data
	SERIAL_WMI_PERF_DATA	WmiPerfData;			// WMI Performance Data
#endif

    //
    // Holds performance statistics that applications can query.
    // Reset on each open.  Only set at device level.
    //
	PORT_PERFORMANCE_STATS PerfStats;

} COMMON_PORT_DEVICE_EXTENSION, *PCOMMON_PORT_DEVICE_EXTENSION;


#endif	// End of SPX_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\download.c ===
/* Download programs for Z280 and T225 based SI/XIO/SX cards... */

#include "precomp.h"			/* Precompiled Headers */
#include "si2_z280.c"			/* Z280 download code image */
#include "si3_t225.c"			/* T225 download code image */
#include "si4_cf.c"			/* ColdFire download code image */

/* End of DOWNLOAD.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\flush.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module contains the code that is very specific to flush
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


ULONG
Slxos_GetCharsInTxBuffer(
    IN PVOID Context
    );

NTSTATUS
SerialStartFlush(
    IN PPORT_DEVICE_EXTENSION pPort
    );


NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialFlush dispatch entry for: %x\n",Irp));

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    Irp->IoStatus.Information = 0L;

    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;


    return SerialStartOrQueue(
               pPort,
               Irp,
               &pPort->WriteQueue,
               &pPort->CurrentWriteIrp,
               SerialStartFlush
               );

}

NTSTATUS
SerialStartFlush(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.

Arguments:

    pPort - Points to the serial device extension

Return Value:

    This will always return STATUS_SUCCESS.

--*/

{
    LARGE_INTEGER delay;
    PIRP NewIrp;
    ULONG limit = (102400/pPort->CurrentBaud);

    pPort->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    //
    // The following call will actually complete the flush.
    //

    SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);

    if(NewIrp) 
	{
        ASSERT(NewIrp == pPort->CurrentWriteIrp);
        SerialStartWrite(pPort);
    }

    //
    // flushes on NT are supposed to transmit all characters remaining in the
    // output buffer. The function should not return until all characters 
    // have gone
    //
    delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));

    while (limit)
	{
	KeDelayExecutionThread(KernelMode,FALSE,&delay);
	if (Slxos_GetCharsInTxBuffer(pPort)==0)
		break;
	limit--;
	}


    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\spx.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	File: SPX.H 
//
//	Contains:	Prototypes of functions to be supplied by a specific  
//				driver to integrate into NT generic PnP code.
//
//	Note:	All generic NT PnP code is prefixed by Spx_.
//			All funcions that are required to integrate into the generic 
//			code are prefixed by XXX_.
//
//
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_H
#define SPX_H	


// Purpose:		Interpret resources given to card by PnP Manager.
//
// Must:		Store resource details in card extension.
NTSTATUS
XXX_CardGetResources(	
	IN PDEVICE_OBJECT pDevObject, 
	IN PCM_RESOURCE_LIST PResList,
	IN PCM_RESOURCE_LIST PTrResList
	);

// Purpose:		Initialise card.
//				Find out how many ports are attached.
// 
// Must:		Fill in NumberOfPorts field in card extension.
NTSTATUS
XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Start up the card.
//
// Must:		Connect up any interrupts.
NTSTATUS
XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Stop the card.
//
// Must:		Stop Card from interrupting.
NTSTATUS
XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Deinitialise the card.
//
// Must:		Disconnect any interrupts.
NTSTATUS
XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Initialise the port extension.
//
// Must:		Store DeviceID, HardwareIDs, DevDesc into the port extension.
//					
NTSTATUS
XXX_PortInit(PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Start up the port.
//
// Must:		Get port ready to receive read and write commands.
NTSTATUS
XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort);


// Purpose:		Stop the port.
//
// Must:		Disconnect any resources and stop DPCs.
//				Do not delete the device object or symbolic link.
NTSTATUS
XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Deinitialise the port.
//
// Must:		Delete the device object & symbolic link.
NTSTATUS
XXX_PortDeInit(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Save the state of the card hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Restore the state of the card hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Save the state of the port hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Restore the state of the port hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Queries whether it is safe for the port to power down.
//
// Must:		Return STATUS_SUCCESS if OK to power down.			
NTSTATUS
XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Set hand shaking and flow control on a port.
VOID 
XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_IOCTL_SYNC pS);

// Paging 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, XXX_CardGetResources)
#pragma alloc_text (PAGE, XXX_CardInit)
#pragma alloc_text (PAGE, XXX_CardDeInit)
#pragma alloc_text (PAGE, XXX_CardStart)
#pragma alloc_text (PAGE, XXX_CardStop)
#pragma alloc_text (PAGE, XXX_PortInit)
#pragma alloc_text (PAGE, XXX_PortDeInit)
#pragma alloc_text (PAGE, XXX_PortStart)
#pragma alloc_text (PAGE, XXX_PortStop)
#endif  


#endif	// End of SPX.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\serialp.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 Microsoft Corporation

Module Name :
	
    serialp.h

Abstract:

    Prototypes and macros that are used throughout the driver.

Author:

    Anthony V. Ercolano                  September 26, 1991

Revision History:
--*/

#ifndef SERIALP_H
#define SERIALP_H

typedef
NTSTATUS
(*PSERIAL_START_ROUTINE) (
    IN PPORT_DEVICE_EXTENSION
    );

typedef
VOID
(*PSERIAL_GET_NEXT_ROUTINE) (
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

BOOLEAN SerialGetStats(IN PVOID Context);		// Get Stats
BOOLEAN SerialClearStats(IN PVOID Context);		// Clear Stats (Called during open)

NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartRead(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartWrite(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialGetNextWrite(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    );

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialSetDTR(
    IN PVOID Context
    );

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    );

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    );

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    );

BOOLEAN
SerialSetChars(
    IN PVOID Context
    );

BOOLEAN
SerialSetBaud(
    IN PVOID Context
    );

BOOLEAN
SerialSetLineControl(
    IN PVOID Context
    );

BOOLEAN
SerialSetupNewHandFlow(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_HANDFLOW NewHandFlow
    );

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    );

VOID
SerialHandleReducedIntBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialProdXonXoff(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN BOOLEAN SendXon
    );

NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialStartImmediate(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialStartPurge(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    );

NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
SerialGetNextIrp(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PSERIAL_START_ROUTINE Starter,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp
    );

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

ULONG
SerialHandleModemUpdate(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN BOOLEAN DoingTX
    );

BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialDispatchISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

NTSTATUS
SerialGetDivisorFromBaud(
    IN ULONG ClockRate,
    IN LONG DesiredBaud,
    OUT PSHORT AppropriateDivisor
    );

VOID
SerialUnload(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
SerialReset(
    IN PVOID Context
    );

BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    );

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCleanupDevice(
    IN PPORT_DEVICE_EXTENSION pPort
    );

UCHAR
SerialProcessLSR(
    IN PPORT_DEVICE_EXTENSION pPort, UCHAR LineStatus
    );

LARGE_INTEGER
SerialGetCharTime(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialSharerIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialIndexedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialBitMappedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

VOID
SerialPutChar(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN UCHAR CharToPut
    );

VOID SerialGetProperties(
	IN PPORT_DEVICE_EXTENSION pPort, 
	IN PSERIAL_COMMPROP Properties
	);


typedef struct _SERIAL_UPDATE_CHAR {
    PPORT_DEVICE_EXTENSION pPort;
    ULONG CharsCopied;
    BOOLEAN Completed;
    } SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _SERIAL_IOCTL_SYNC {
    PPORT_DEVICE_EXTENSION pPort;
    PVOID Data;
    } SERIAL_IOCTL_SYNC,*PSERIAL_IOCTL_SYNC;

//
// The following three macros are used to initialize, increment
// and decrement reference counts in IRPs that are used by
// this driver.  The reference count is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(LONG) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_INC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))++)

#define SERIAL_DEC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))--)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((LONG)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))


#endif // End of SERIALP.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\io8\incl\spx_misc.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_MISC.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	All Macros and function prototypes for the common PnP and power code.	*
*																						*
****************************************************************************************/

#if	!defined(SPX_MISC_H)
#define SPX_MISC_H	


// Prototypes for common PnP code.
NTSTATUS
Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPDO);

NTSTATUS
Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP	pIrp);

NTSTATUS 
Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp, IN PVOID Context);

NTSTATUS 
Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp);

NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...);

NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	);

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	);

VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp);

VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	);

ULONG	SpxGetNtCardType(PDEVICE_OBJECT pNtDevObj);
NTSTATUS Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort);

SPX_MEM_COMPARES Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB);

NTSTATUS PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard);

VOID SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set);
VOID SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set);

BOOLEAN 
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll);


PVOID SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);
PVOID SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);

#ifndef BUILD_SPXMINIPORT
void SpxFreeMem(PVOID pMem);
#endif
						   
VOID SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition);
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort);


// Filtered dispatch entry points... 
NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 
NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);	// SPX_DISP.C 
NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort);							// SPX_DISP.C 
VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj);							// SPX_DISP.C 


// End of prototypes for common PnP code.


#ifdef WMI_SUPPORT

NTSTATUS Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);

#define UPDATE_WMI_LINE_CONTROL(WmiCommData, LineControl)						\
do																				\
{																				\
																				\
	WmiCommData.BitsPerByte			= (LineControl & SERIAL_DATA_MASK) + 5;		\
	WmiCommData.ParityCheckEnable	= (LineControl & 0x08) ? TRUE : FALSE;		\
																				\
	switch(LineControl & SERIAL_PARITY_MASK)									\
	{																			\
	case SERIAL_ODD_PARITY:														\
		WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;								\
		break;																	\
																				\
	case SERIAL_EVEN_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;							\
		break;																	\
																				\
	case SERIAL_MARK_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;							\
		break;																	\
																				\
	case SERIAL_SPACE_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;							\
		break;																	\
																				\
	case SERIAL_NONE_PARITY:													\
	default:																	\
		WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;							\
		break;																	\
	}																			\
																				\
																				\
	if(LineControl & SERIAL_STOP_MASK)											\
	{																			\
		if((LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA)					\
			WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;							\
		else																	\
			WmiCommData.StopBits = SERIAL_WMI_STOP_2;							\
	}																			\
	else																		\
		WmiCommData.StopBits = SERIAL_WMI_STOP_1;								\
																				\
} while (0)


#define UPDATE_WMI_XON_XOFF_CHARS(WmiCommData, SpecialChars)					\
do																				\
{																				\
	WmiCommData.XoffCharacter	= SpecialChars.XoffChar;						\
	WmiCommData.XonCharacter	= SpecialChars.XonChar;							\
																				\
} while (0)


#define UPDATE_WMI_XMIT_THRESHOLDS(WmiCommData, HandFlow)						\
do																				\
{																				\
	WmiCommData.XoffXmitThreshold	= HandFlow.XoffLimit;						\
	WmiCommData.XonXmitThreshold	= HandFlow.XonLimit;						\
																				\
} while (0)

#endif



// Macros 

// Debug Messages
#if DBG
#define SPX_TRACE_CALLS			((ULONG)0x00000001)
#define SPX_TRACE_PNP_IRPS		((ULONG)0x00000002)
#define SPX_ERRORS				((ULONG)0x00000004)
#define SPX_MISC_DBG			((ULONG)0x00000008)
#define SPX_TRACE_POWER_IRPS	((ULONG)0x00000010)
#define	SPX_TRACE_IRP_PATH		((ULONG)0x00000020)
#define	SPX_TRACE_FILTER_IRPS	((ULONG)0x00000040)
//#define SERFLOW				((ULONG)0x00000080)
//#define SERERRORS				((ULONG)0x00000100)
//#define SERBUGCHECK			((ULONG)0x00000200)

extern ULONG SpxDebugLevel;		// Global Debug Level 

#define SpxDbgMsg(LEVEL, STRING)			\
        do{									\
            if(SpxDebugLevel & (LEVEL))		\
			{								\
                DbgPrint STRING;			\
            }								\
            if((LEVEL) == SERBUGCHECK)		\
			{								\
                ASSERT(FALSE);				\
            }								\
        }while (0)
#else
#define SpxDbgMsg(LEVEL, STRING) do {NOTHING;} while (0)
#endif




#define	SetPnpPowerFlags(pDevExt,Value)		\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), TRUE);		

#define	ClearPnpPowerFlags(pDevExt,Value)	\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), FALSE);	

#define SPX_SUCCESS(Status) ((NTSTATUS)(Status) == 0)

#define	SetUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), TRUE);		

#define	ClearUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), FALSE);	

// End of macros.

#endif	// End of SPX_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\error.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the code that is very specific to error
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device object.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialKillAllReadsOrWrites(
        pPort->DeviceObject,
        &pPort->WriteQueue,
        &pPort->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        pPort->DeviceObject,
        &pPort->ReadQueue,
        &pPort->CurrentReadIrp
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\ioctl.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module contains the ioctl dispatcher as well as a couple
    of routines that are generally just called in response to
    ioctl calls.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

// Prototypes
BOOLEAN SerialGetModemUpdate(IN PVOID Context);
BOOLEAN SerialGetCommStatus(IN PVOID Context);
VOID	SerialGetProperties(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_COMMPROP Properties);
BOOLEAN SerialSetEscapeChar(IN PVOID Context);
// End of Prototypes.    
    


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SerialGetStats(IN PVOID Context) 
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    return the perf stats to the caller.
//
// Arguments:
//    Context - Pointer to a the irp.
//
// Return Value:
//    This routine always returns FALSE.
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
SerialGetStats(IN PVOID Context)
{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation((PIRP)Context);
    PPORT_DEVICE_EXTENSION pPort = irpSp->DeviceObject->DeviceExtension;
    PSERIALPERF_STATS sp = ((PIRP)Context)->AssociatedIrp.SystemBuffer;

	*sp = *((PSERIALPERF_STATS) &pPort->PerfStats);
  
	return FALSE;
}


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SerialClearStats(IN PVOID Context) 
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    clear the perf stats.
//
// Arguments:
//    Context - Pointer to a the extension.
//
// Return Value:
//    This routine always returns FALSE.
////////////////////////////////////////////////////////////////////////////////

BOOLEAN
SerialClearStats(IN PVOID Context)
{
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)Context;

    RtlZeroMemory(&pPort->PerfStats, sizeof(SERIALPERF_STATS));

#ifdef WMI_SUPPORT
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));	
#endif

    return FALSE;
}


BOOLEAN
SerialSetChars(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the special characters for the
    driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a special characters
              structure.

Return Value:

    This routine always returns FALSE.

--*/
{

    ((PSERIAL_IOCTL_SYNC)Context)->pPort->SpecialChars =
        *((PSERIAL_CHARS)(((PSERIAL_IOCTL_SYNC)Context)->Data));

    Slxos_SetChars(((PSERIAL_IOCTL_SYNC)Context)->pPort);

    return FALSE;
}

BOOLEAN
SerialGetModemUpdate(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is simply used to call the interrupt level routine
    that handles modem status update.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

    *Result = SerialHandleModemUpdate(pPort);

    return FALSE;

}

BOOLEAN
SerialGetCommStatus(
    IN PVOID Context
    )

/*++

Routine Description:

    This is used to get the current state of the serial driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a serial status
              record.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    PSERIAL_STATUS Stat = ((PSERIAL_IOCTL_SYNC)Context)->Data;

    Stat->Errors = pPort->ErrorWord;
    pPort->ErrorWord = 0;

    //
    // BUG BUG We need to do something about eof (binary mode).
    //
    Stat->EofReceived = FALSE;

    Stat->AmountInInQueue = pPort->CharsInInterruptBuffer;

	// Get total amount of data queued, bytes in the IRP buffers and the card's circular buffer.
#if USE_NEW_TX_BUFFER_EMPTY_DETECT
    Stat->AmountInOutQueue = pPort->TotalCharsQueued + Slxos_GetCharsInTxBuffer(pPort) + ((PCHAN)pPort->pChannel)->tx_fifo_count;
#else
    Stat->AmountInOutQueue = pPort->TotalCharsQueued;
#endif

    if(pPort->WriteLength) 
	{
        //
        // By definition if we have a writelength the we have
        // a current write irp.
        //

        ASSERT(pPort->CurrentWriteIrp);
        ASSERT(Stat->AmountInOutQueue >= pPort->WriteLength);
        ASSERT((IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->
                Parameters.Write.Length) >=
                pPort->WriteLength);

        Stat->AmountInOutQueue -=
            IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)
            ->Parameters.Write.Length - (pPort->WriteLength);

    }

    Stat->WaitForImmediate = pPort->TransmitImmediate;

    Stat->HoldReasons = 0;
    
	if(pPort->TXHolding) 
	{
        if(pPort->TXHolding & SERIAL_TX_DSR) 
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;

        if(pPort->TXHolding & SERIAL_TX_DCD) 
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;

        if(pPort->TXHolding & SERIAL_TX_XOFF)
            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;

        if(pPort->TXHolding & SERIAL_TX_BREAK) 
            Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;
    }

    if(pPort->RXHolding & SERIAL_RX_DSR)
        Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;

    if(pPort->RXHolding & SERIAL_RX_XOFF)
        Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;


    SpxDbgMsg( SERDIAG1,("%s: Err 0x%x HR 0x%x inq 0x%x outq 0x%x\n", PRODUCT_NAME,
    	Stat->Errors,Stat->HoldReasons,Stat->AmountInInQueue,
		Stat->AmountInOutQueue));

    return FALSE;

}

BOOLEAN
SerialSetEscapeChar(
    IN PVOID Context
    )

/*++

Routine Description:

    This is used to set the character that will be used to escape
    line status and modem status information when the application
    has set up that line status and modem status should be passed
    back in the data stream.

Arguments:

    Context - Pointer to the irp that is specify the escape character.
              Implicitly - An escape character of 0 means no escaping
              will occur.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort 
		= IoGetCurrentIrpStackLocation((PIRP)Context)->DeviceObject->DeviceExtension;

    pPort->EscapeChar = *(PUCHAR)((PIRP)Context)->AssociatedIrp.SystemBuffer;
       

    return FALSE;

}

NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine provides the initial processing for all of the
    Ioctls for the serial device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    //
    KIRQL OldIrql;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialIOControl dispatch entry for: %x\n",Irp));

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;


    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) 
	{
	case IOCTL_SERIAL_SET_BAUD_RATE: 
		{
            ULONG BaudRate;
            //
            // Will hold the value of the appropriate divisor for
            // the requested baud rate.  If the baudrate is invalid
            // (because the device won't support that baud rate) then
            // this value is undefined.
            //

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_BAUD_RATE\n", PRODUCT_NAME));
                
            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BAUD_RATE)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            } 
			else 
			{
                BaudRate = ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;
            }

			if(!Slxos_CheckBaud(pPort,BaudRate))	// Check for valid rate 
			{
	    		Status = STATUS_INVALID_PARAMETER;
	    		break;
			}
#ifdef WMI_SUPPORT
			else
			{
				pPort->WmiCommData.BaudRate = BaudRate;
			}
#endif

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            if(NT_SUCCESS(Status)) 
			{
                pPort->CurrentBaud = BaudRate;
				Slxos_SyncExec(pPort, Slxos_SetBaud, pPort, 0x05);
            }

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

	case IOCTL_SERIAL_GET_BAUD_RATE: 
		{
            PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_BAUD_RATE\n", PRODUCT_NAME));
                
            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_BAUD_RATE)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            Br->BaudRate = pPort->CurrentBaud;

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);
            break;

        }

	case IOCTL_SERIAL_SET_LINE_CONTROL: 
		{
            //
            // Points to the line control record in the Irp.
            //
            PSERIAL_LINE_CONTROL Lc = ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

            UCHAR LData;
            UCHAR LStop;
            UCHAR LParity;
            UCHAR Mask = 0xff;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_LINE_CONTROL\n", PRODUCT_NAME));
            
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_LINE_CONTROL)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            switch (Lc->WordLength) 
			{
            case 5: 
				{
                    LData = SERIAL_5_DATA;
                    Mask = 0x1f;
					break;
                }

			case 6: 
				{
                    LData = SERIAL_6_DATA;
                    Mask = 0x3f;
                    break;
                }
 
			case 7: 
				{
                    LData = SERIAL_7_DATA;
                    Mask = 0x7f;
                    break;
                }

			case 8: 
				{
                    LData = SERIAL_8_DATA;
                    break;
                }
 			default: 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
				}
            }

            switch (Lc->Parity) 
			{
			case NO_PARITY: 
				{
                    LParity = SERIAL_NONE_PARITY;
                    break;
                }

			case EVEN_PARITY: 
				{
                    LParity = SERIAL_EVEN_PARITY;
                    break;
                }

			case ODD_PARITY: 
				{
                    LParity = SERIAL_ODD_PARITY;
                    break;
                }
               
			case SPACE_PARITY: 
				{
                    LParity = SERIAL_SPACE_PARITY;
                    break;
                }
 
			case MARK_PARITY: 
				{
                    LParity = SERIAL_MARK_PARITY;
                    break;
                }

			default: 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
                    break;
                }

            }

            switch (Lc->StopBits) 
			{
			case STOP_BIT_1: 
				{
                    LStop = SERIAL_1_STOP;
                    break;
                }

			case STOP_BITS_1_5: 
				{
                    if (LData != SERIAL_5_DATA) 
					{
                        Status = STATUS_INVALID_PARAMETER;
                        goto DoneWithIoctl;
                    }

                    LStop = SERIAL_1_5_STOP;
                    break;
                }


			case STOP_BITS_2: 
				{
                    if (LData == SERIAL_5_DATA) 
					{
                        Status = STATUS_INVALID_PARAMETER;
                        goto DoneWithIoctl;
                    }

                    LStop = SERIAL_2_STOP;
                    break;
                }
 
			default: 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
                }
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            pPort->LineControl = (UCHAR)((pPort->LineControl & SERIAL_LCR_BREAK) | (LData | LParity | LStop));
            pPort->ValidDataMask = Mask;

			Slxos_SyncExec(pPort,Slxos_SetLineControl,pPort,0x06);

#ifdef WMI_SUPPORT
			UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
#endif

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            break;
        }
        
	case IOCTL_SERIAL_GET_LINE_CONTROL: 
		{
            PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_LINE_CONTROL\n", PRODUCT_NAME));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_LINE_CONTROL)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
               
                

            switch (pPort->LineControl & SERIAL_DATA_MASK) 
			{
			case SERIAL_5_DATA: 
				{
                    Lc->WordLength = 5;
                    break;
                }

			case SERIAL_6_DATA: 
				{
                    Lc->WordLength = 6;
                    break;
                }

			case SERIAL_7_DATA: 
				{
                    Lc->WordLength = 7;
                    break;
                }

			case SERIAL_8_DATA: 
				{
                    Lc->WordLength = 8;
                    break;
                }
            }

            switch (pPort->LineControl & SERIAL_PARITY_MASK) 
			{
            case SERIAL_NONE_PARITY: 
				{
                    Lc->Parity = NO_PARITY;
                    break;
                }
                
			case SERIAL_ODD_PARITY: 
				{
                    Lc->Parity = ODD_PARITY;
                    break;
                }

			case SERIAL_EVEN_PARITY: 
				{
                    Lc->Parity = EVEN_PARITY;
                    break;
                }

			case SERIAL_MARK_PARITY: 
				{
                    Lc->Parity = MARK_PARITY;
                    break;
                }

			case SERIAL_SPACE_PARITY: 
				{
                    Lc->Parity = SPACE_PARITY;
                    break;
                }
            }

            if (pPort->LineControl & SERIAL_2_STOP) 
			{
                if(Lc->WordLength == 5) 
					Lc->StopBits = STOP_BITS_1_5;
                else 
				    Lc->StopBits = STOP_BITS_2;
			} 
			else 
			{
                Lc->StopBits = STOP_BIT_1;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_SET_TIMEOUTS: 
		{
            PSERIAL_TIMEOUTS NewTimeouts = ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));

            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_SET_TIMEOUTS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_TIMEOUTS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if((NewTimeouts->ReadIntervalTimeout == MAXULONG) 
				&& (NewTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) 
				&& (NewTimeouts->ReadTotalTimeoutConstant == MAXULONG)) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);

            pPort->Timeouts.ReadIntervalTimeout			= NewTimeouts->ReadIntervalTimeout;
            pPort->Timeouts.ReadTotalTimeoutMultiplier	= NewTimeouts->ReadTotalTimeoutMultiplier;
            pPort->Timeouts.ReadTotalTimeoutConstant	= NewTimeouts->ReadTotalTimeoutConstant;
            pPort->Timeouts.WriteTotalTimeoutMultiplier = NewTimeouts->WriteTotalTimeoutMultiplier;
            pPort->Timeouts.WriteTotalTimeoutConstant	= NewTimeouts->WriteTotalTimeoutConstant;

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_TIMEOUTS: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_TIMEOUTS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_TIMEOUTS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
               
            *((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) = pPort->Timeouts;
            Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_SET_CHARS: 
		{
            SERIAL_IOCTL_SYNC S;
            PSERIAL_CHARS NewChars = ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));
                
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_CHARS\n",PRODUCT_NAME));
            
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_CHARS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // The only thing that can be wrong with the chars
            // is that the xon and xoff characters are the
            // same.
            //

            if(NewChars->XonChar == NewChars->XoffChar) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // We acquire the control lock so that only
            // one request can GET or SET the characters
            // at a time.  The sets could be synchronized
            // by the interrupt spinlock, but that wouldn't
            // prevent multiple gets at the same time.
            //

            S.pPort = pPort;
            S.Data = NewChars;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            //
            // Under the protection of the lock, make sure that
            // the xon and xoff characters aren't the same as
            // the escape character.
            //

            if(pPort->EscapeChar) 
			{
                if ((pPort->EscapeChar == NewChars->XonChar) || (pPort->EscapeChar == NewChars->XoffChar)) 
				{

                    Status = STATUS_INVALID_PARAMETER;
                    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
                        
                    break;
                }
            }

			Slxos_SyncExec(pPort,SerialSetChars,&S,0x07);

#ifdef WMI_SUPPORT
			UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
#endif

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_CHARS: 
		{
            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_GET_CHARS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_CHARS)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            *((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) = pPort->SpecialChars;
            Irp->IoStatus.Information = sizeof(SERIAL_CHARS);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

	case IOCTL_SERIAL_SET_DTR:
	case IOCTL_SERIAL_CLR_DTR: 
		{

            //
            // We acquire the lock so that we can check whether
            // automatic DTR flow control is enabled.  If it is
            // then we return an error since the app is not allowed
            // to touch this if it is automatic.
            //
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET/CLR_DTR\n",PRODUCT_NAME));

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            if((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
			{
	            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            } 
			else 
			{
// NCG				LARGE_INTEGER L = RtlConvertLongToLargeInteger(-100000);

				if(IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_DTR)
					Slxos_SyncExec(pPort,SerialSetDTR,pPort,0x08);
				else    
					Slxos_SyncExec(pPort,SerialClrDTR,pPort,0x04);

				KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

				//
				// Wait 10 msecs for SLXOS card to respond.
				//				
// NCG				KeDelayExecutionThread(KernelMode, FALSE, &L);
            }

            break;
        }
        
	case IOCTL_SERIAL_RESET_DEVICE: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_RESET_DEVICE\n",PRODUCT_NAME));
            break;
        }
        
	case IOCTL_SERIAL_SET_RTS:
	case IOCTL_SERIAL_CLR_RTS: 
		{
            //
            // We acquire the lock so that we can check whether
            // automatic RTS flow control or transmit toggling
            // is enabled.  If it is then we return an error since
            // the app is not allowed to touch this if it is automatic
            // or toggling.
            //

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET/CLR_RTS\n",PRODUCT_NAME));

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            if(((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE)
				|| ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK)) == SERIAL_TRANSMIT_TOGGLE) 
			{
	            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            } 
			else 
			{
// NCG				LARGE_INTEGER L = RtlConvertLongToLargeInteger(-100000);

			if(IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_RTS)
				Slxos_SyncExec(pPort, SerialSetRTS, pPort, 0x09);
			else    
				Slxos_SyncExec(pPort, SerialClrRTS, pPort, 0x03);

	            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

				//
				// Wait 10 msecs for SLXOS card to respond.
				//				
// NCG				KeDelayExecutionThread(KernelMode, FALSE, &L);
            }

            break;

        }
        
	case IOCTL_SERIAL_SET_XOFF: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_XOFF\n",PRODUCT_NAME));
                
			Slxos_SyncExec(pPort,SerialPretendXoff,pPort,0x0A);
            break;
        }
        
	case IOCTL_SERIAL_SET_XON: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_XON\n", PRODUCT_NAME));
                
			Slxos_SyncExec(pPort,SerialPretendXon,pPort,0x0B);
            break;
        }
        
	case IOCTL_SERIAL_SET_BREAK_ON: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_BREAK_ON\n",PRODUCT_NAME));
                
			Slxos_SyncExec(pPort,SerialTurnOnBreak,pPort,0x0C);
            break;
        }
        
	case IOCTL_SERIAL_SET_BREAK_OFF: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_BREAK_OFF\n"PRODUCT_NAME));
                
		    Slxos_SyncExec(pPort,SerialTurnOffBreak,pPort,0x0D);
            break;
        }
        
	case IOCTL_SERIAL_SET_QUEUE_SIZE: 
		{
            //
            // Type ahead buffer is fixed, so we just validate
            // the the user's request is not bigger than our
            // own internal buffer size.
            //

            PSERIAL_QUEUE_SIZE Rs = ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_QUEUE_SIZE\n",PRODUCT_NAME));
                
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_QUEUE_SIZE)) 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // We have to allocate the memory for the new
            // buffer while we're still in the context of the
            // caller.  We don't even try to protect this
            // with a lock because the value could be stale
            // as soon as we release the lock - the only time
            // we will know for sure is when we actually try
            // to do the resize.
            //

            if (Rs->InSize <= pPort->BufferSize) 
			{
                Status = STATUS_SUCCESS;
                break;
            }

            try 
			{
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer 
					= SpxAllocateMemWithQuota(NonPagedPool, Rs->InSize);
            } 
			except(EXCEPTION_EXECUTE_HANDLER) 
			{
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                Status = GetExceptionCode();
            }

            if (!IrpSp->Parameters.DeviceIoControl.Type3InputBuffer) 
			{
                break;
            }

            //
            // Well the data passed was big enough.  Do the request.
            //
            // There are two reason we place it in the read queue:
            //
            // 1) We want to serialize these resize requests so that
            //    they don't contend with each other.
            //
            // 2) We want to serialize these requests with reads since
            //    we don't want reads and resizes contending over the
            //    read buffer.
            //

            return SerialStartOrQueue(
                       pPort,
                       Irp,
                       &pPort->ReadQueue,
                       &pPort->CurrentReadIrp,
                       SerialStartRead
                       );

            break;

        }
        
	case IOCTL_SERIAL_GET_WAIT_MASK: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_WAIT_MASK\n",PRODUCT_NAME));

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Simple scalar read.  No reason to acquire a lock.
            //

            Irp->IoStatus.Information = sizeof(ULONG);

            *((ULONG *)Irp->AssociatedIrp.SystemBuffer) = pPort->IsrWaitMask;

            break;
        }

	case IOCTL_SERIAL_SET_WAIT_MASK: 
		{
            ULONG NewMask;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_WAIT_MASK\n",PRODUCT_NAME));

            SpxDbgMsg(SERDIAG3 | SERIRPPATH, ("SERIAL: In Ioctl processing for set mask\n"));
                
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
			{
                SpxDbgMsg(SERDIAG3,("SERIAL: Invalid size for the buffer %d\n",
                     IrpSp->Parameters.DeviceIoControl.InputBufferLength));
                   
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            } 
			else 
			{
                NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);
            }

            //
            // Make sure that the mask only contains valid
            // waitable events.
            //

            if (NewMask & ~(SERIAL_EV_RXCHAR   |
                            SERIAL_EV_RXFLAG   |
                            SERIAL_EV_TXEMPTY  |
                            SERIAL_EV_CTS      |
                            SERIAL_EV_DSR      |
                            SERIAL_EV_RLSD     |
                            SERIAL_EV_BREAK    |
                            SERIAL_EV_ERR      |
                            SERIAL_EV_RING     |
                            SERIAL_EV_PERR     |
                            SERIAL_EV_RX80FULL |
                            SERIAL_EV_EVENT1   |
                            SERIAL_EV_EVENT2)) 
			{
                SpxDbgMsg(SERDIAG3, ("SERIAL: Unknown mask %x\n",NewMask));

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Either start this irp or put it on the
            // queue.
            //
            SpxDbgMsg(SERDIAG3 | SERIRPPATH, ("SERIAL: Starting or queuing set mask irp %x\n",Irp));
                
            return SerialStartOrQueue(
                       pPort,
                       Irp,
                       &pPort->MaskQueue,
                       &pPort->CurrentMaskIrp,
                       SerialStartMask
                       );
        }
        
	case IOCTL_SERIAL_WAIT_ON_MASK: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_WAIT_ON_MASK\n",PRODUCT_NAME));

            SpxDbgMsg(SERDIAG3 | SERIRPPATH,("SERIAL: In Ioctl processing for wait mask\n"));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
                SpxDbgMsg(SERDIAG3,("SERIAL: Invalid size for the buffer %d\n",
                     IrpSp->Parameters.DeviceIoControl.InputBufferLength));
                    
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Either start this irp or put it on the
            // queue.
            //
            SpxDbgMsg(SERDIAG3 | SERIRPPATH, ("SERIAL: Starting or queuing wait mask irp %x\n",Irp));
                
            return SerialStartOrQueue(
                       pPort,
                       Irp,
                       &pPort->MaskQueue,
                       &pPort->CurrentMaskIrp,
                       SerialStartMask
                       );
        }
        
	case IOCTL_SERIAL_IMMEDIATE_CHAR: 
		{
            BOOLEAN FailRequest;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_IMMEDIATE_CHAR\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            IoAcquireCancelSpinLock(&OldIrql);
            
			if(pPort->CurrentImmediateIrp) 
			{
                FailRequest = TRUE;
                Status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = Status;
                IoReleaseCancelSpinLock(OldIrql);
            } 
			else 
			{
                //
                // We can queue the char.  We need to set
                // a cancel routine because flow control could
                // keep the char from transmitting.  Make sure
                // that the irp hasn't already been cancelled.
                //

                if(Irp->Cancel) 
				{
                    IoReleaseCancelSpinLock(OldIrql);
                    Irp->IoStatus.Status = STATUS_CANCELLED;
                    Status = STATUS_CANCELLED;
                } 
				else 
				{
                    pPort->CurrentImmediateIrp = Irp;
                    pPort->TotalCharsQueued++;
                    IoReleaseCancelSpinLock(OldIrql);

                    SerialStartImmediate(pPort);	// Start IRP

                    return STATUS_PENDING;
                }
            }

            break;
        }
        
	case IOCTL_SERIAL_PURGE: 
		{
            ULONG Mask;

            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_PURGE\n",PRODUCT_NAME));
             
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Check to make sure that the mask only has
            // 0 or the other appropriate values.
            //

            Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));

            if ((!Mask) || (Mask & (~(SERIAL_PURGE_TXABORT |
                                      SERIAL_PURGE_RXABORT |
                                      SERIAL_PURGE_TXCLEAR |
                                      SERIAL_PURGE_RXCLEAR))))
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            // Either start this irp or put it on the queue.
            return SerialStartOrQueue(pPort,Irp, &pPort->PurgeQueue, 
						&pPort->CurrentPurgeIrp, SerialStartPurge);
        }
        
	case IOCTL_SERIAL_GET_HANDFLOW: 
		{
            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_GET_HANDFLOW\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_HANDFLOW)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            *((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) = pPort->HandFlow;

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_SET_HANDFLOW: 
		{
            SERIAL_IOCTL_SYNC S;
            PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_SET_HANDFLOW\n",PRODUCT_NAME));
               
            //
            // Make sure that the hand shake and control is the
            // right size.
            //
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_HANDFLOW))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Make sure that there are no invalid bits set in
            // the control and handshake.
            //

            if(HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if(HandFlow->FlowReplace & SERIAL_FLOW_INVALID) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Make sure that the app hasn't set an invalid DTR mode.
            //

            if((HandFlow->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_MASK) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Make sure that haven't set totally invalid xon/xoff
            // limits.
            //

            if((HandFlow->XonLimit < 0) || ((ULONG)HandFlow->XonLimit > pPort->BufferSize))
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if((HandFlow->XoffLimit < 0) || ((ULONG)HandFlow->XoffLimit > pPort->BufferSize))
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            S.pPort = pPort;
            S.Data = HandFlow;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            //
            // Under the protection of the lock, make sure that
            // we aren't turning on error replacement when we
            // are doing line status/modem status insertion.
            //

            if(pPort->EscapeChar) 
			{
                if(HandFlow->FlowReplace & SERIAL_ERROR_CHAR) 
				{
                    Status = STATUS_INVALID_PARAMETER;
                    
					KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

                    break;
                }
            }

			Slxos_SyncExec(pPort,SerialSetHandFlow,&S,0x0E);

#ifdef WMI_SUPPORT
			UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_MODEMSTATUS: 
		{
            ULONG ModemControl;
            SERIAL_IOCTL_SYNC S;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_MODEMSTATUS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);

            S.pPort = pPort;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			Slxos_SyncExec(pPort,SerialGetModemUpdate,&S,0x0F);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            break;

        }
        
	case IOCTL_SERIAL_GET_DTRRTS: 
		{
            ULONG ModemControl;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_DTRRTS\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Reading this hardware has no effect on the device.
            //

            ModemControl = Slxos_GetModemControl(pPort);

            ModemControl &= SERIAL_DTR_STATE | SERIAL_RTS_STATE;

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = ModemControl;

            break;
        }
        
	case IOCTL_SERIAL_GET_COMMSTATUS: 
		{
            SERIAL_IOCTL_SYNC S;

            SpxDbgMsg( SERDIAG1, ("%s: IOCTL_SERIAL_GET_COMMSTATUS\n",PRODUCT_NAME));
               

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_STATUS))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

            S.pPort = pPort;
            S.Data =  Irp->AssociatedIrp.SystemBuffer;

            //
            // Acquire the cancel spin lock so nothing much
            // changes while we're getting the state.
            //

            IoAcquireCancelSpinLock(&OldIrql);

			Slxos_SyncExec(pPort,SerialGetCommStatus,&S,0x10);

            IoReleaseCancelSpinLock(OldIrql);

            break;
        }
        
	case IOCTL_SERIAL_GET_PROPERTIES: 
		{
            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_GET_PROPERTIES\n",PRODUCT_NAME));

            if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_COMMPROP)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // No synchronization is required since this information is "static".
            SerialGetProperties(pPort, Irp->AssociatedIrp.SystemBuffer);

            Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            break;
        }
        
	case IOCTL_SERIAL_XOFF_COUNTER: 
		{
			PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1,("%s: IOCTL_SERIAL_XOFF_COUNTER\n",PRODUCT_NAME));
            
            Status = STATUS_NOT_IMPLEMENTED;

			/* 
            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_XOFF_COUNTER)) 
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if(Xc->Counter <= 0) 
			{
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // So far so good.  Put the irp onto the write queue.
            //

            return SerialStartOrQueue(
                       pPort,
                       Irp,
                       &pPort->WriteQueue,
                       &pPort->CurrentWriteIrp,
                       SerialStartWrite
                       );
			*/

			break;
        }
        
	case IOCTL_SERIAL_LSRMST_INSERT: 
		{
            PUCHAR escapeChar = Irp->AssociatedIrp.SystemBuffer;

            SpxDbgMsg(SERDIAG1, ("%s: IOCTL_SERIAL_LSRMST_INSERT\n",PRODUCT_NAME));
               
            //
            // Make sure we get a byte.
            //

            if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR))
			{
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

            if(*escapeChar) 
			{
                //
                // We've got some escape work to do.  We will make sure that
                // the character is not the same as the Xon or Xoff character,
                // or that we are already doing error replacement.
                //

                if((*escapeChar == pPort->SpecialChars.XoffChar) 
					|| (*escapeChar == pPort->SpecialChars.XonChar) 
					|| (pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)) 
				{
                    Status = STATUS_INVALID_PARAMETER;

                    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
                        
                    break;
                }
            }

			Slxos_SyncExec(pPort,SerialSetEscapeChar,Irp,0x11);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

            break;
        }

        
	case IOCTL_SERIAL_GET_STATS: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
			Irp->IoStatus.Status = STATUS_SUCCESS;

			Slxos_SyncExec(pPort, SerialGetStats, Irp, 0x22);
			break;
		}

    case IOCTL_SERIAL_CLEAR_STATS: 
		{
			Slxos_SyncExec(pPort, SerialClearStats, pPort, 0x23);
			break;
		}


    default: 
		{
			Status = STATUS_INVALID_PARAMETER;
			break;
		}
    }

DoneWithIoctl:;

    Irp->IoStatus.Status = Status;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,3);
#endif

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;

}

VOID
SerialGetProperties(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_COMMPROP Properties
    )

/*++

Routine Description:

    This function returns the capabilities of this particular
    serial device.

Arguments:

    pPort - The serial device extension.

    Properties - The structure used to return the properties

Return Value:

    None.

--*/

{
    SpxDbgMsg(
        SERDIAG1,
        ("%s: SerialGetProperties for %x.\n",
        PRODUCT_NAME,
        pPort->pChannel)
        );

    RtlZeroMemory(
        Properties,
        sizeof(SERIAL_COMMPROP)
        );

    Properties->PacketLength = sizeof(SERIAL_COMMPROP);
    Properties->PacketVersion = 2;
    Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
    Properties->MaxTxQueue = 0;
    Properties->MaxRxQueue = 0;

    Properties->MaxBaud = SERIAL_BAUD_USER;
    Properties->SettableBaud = pPort->SupportedBauds;
    if(((PCHAN)pPort->pChannel)->type == SXDC)
    {
	Properties->SettableBaud |= SERIAL_BAUD_134_5;
	Properties->SettableBaud |= SERIAL_BAUD_7200;
	Properties->SettableBaud |= SERIAL_BAUD_14400;
	Properties->SettableBaud |= SERIAL_BAUD_56K;
	Properties->SettableBaud |= SERIAL_BAUD_128K;
    }

    Properties->ProvSubType = SERIAL_SP_RS232;
    Properties->ProvCapabilities = SERIAL_PCF_DTRDSR |
                                   SERIAL_PCF_RTSCTS |
                                   SERIAL_PCF_CD     |
                                   SERIAL_PCF_PARITY_CHECK |
                                   SERIAL_PCF_XONXOFF |
                                   SERIAL_PCF_SETXCHAR |
                                   SERIAL_PCF_TOTALTIMEOUTS |
                                   SERIAL_PCF_INTTIMEOUTS;
    Properties->SettableParams = SERIAL_SP_PARITY |
                                 SERIAL_SP_BAUD |
                                 SERIAL_SP_DATABITS |
                                 SERIAL_SP_STOPBITS |
                                 SERIAL_SP_HANDSHAKING |
                                 SERIAL_SP_PARITY_CHECK |
                                 SERIAL_SP_CARRIER_DETECT;


    Properties->SettableData = SERIAL_DATABITS_5 |
                               SERIAL_DATABITS_6 |
                               SERIAL_DATABITS_7 |
                               SERIAL_DATABITS_8;
    Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                     SERIAL_STOPBITS_15 |
                                     SERIAL_STOPBITS_20 |
                                     SERIAL_PARITY_NONE |
                                     SERIAL_PARITY_ODD  |
                                     SERIAL_PARITY_EVEN |
                                     SERIAL_PARITY_MARK |
                                     SERIAL_PARITY_SPACE;

    Properties->CurrentTxQueue = 0;
    Properties->CurrentRxQueue = pPort->BufferSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\immediat.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    immediat.c

Abstract:

    This module contains the code that is very specific to transmit
    immediate character operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

VOID
SerialGetNextImmediate(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    );



VOID
SerialStartImmediate(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will calculate the timeouts needed for the
    write.  It will then hand the irp off to the isr.  It
    will need to be careful in case the irp has been cancelled.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;


    UseATimer = FALSE;
    pPort->CurrentImmediateIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pPort->CurrentImmediateIrp);

    //
    // Calculate the timeout value needed for the request.  Note that the
    // values stored in the timeout record are in milliseconds. Note that
    // if the timeout values are zero then we won't start the timer.
    //

    KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);
        

    Timeouts = pPort->Timeouts;

    KeReleaseSpinLock(&pPort->ControlLock,OldIrql);
        

    if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier) 
	{

        UseATimer = TRUE;

        //
        // We have some timer values to calculate.
        //

        TotalTime = RtlEnlargedUnsignedMultiply(1,Timeouts.WriteTotalTimeoutMultiplier);

        TotalTime = RtlLargeIntegerAdd(TotalTime,RtlConvertUlongToLargeInteger(Timeouts.WriteTotalTimeoutConstant));

        TotalTime = RtlExtendedIntegerMultiply(TotalTime,-10000);

    }

    //
    // As the irp might be going to the isr, this is a good time
    // to initialize the reference count.
    //

    SERIAL_INIT_REFERENCE(pPort->CurrentImmediateIrp);

    //
    // We need to see if this irp should be cancelled.
    //

    IoAcquireCancelSpinLock(&OldIrql);

    if(pPort->CurrentImmediateIrp->Cancel) 
	{
        PIRP OldIrp = pPort->CurrentImmediateIrp;

        pPort->CurrentImmediateIrp = NULL;
        IoReleaseCancelSpinLock(OldIrql);

        OldIrp->IoStatus.Status = STATUS_CANCELLED;
        OldIrp->IoStatus.Information = 0;

        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",OldIrp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(OldIrp,1);
#endif
		SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(OldIrp, 0);
    } 
	else 
	{

        //
        // We give the irp to to the isr to write out.  We set a cancel
        // routine that knows how to grab the current write away from the isr.
        //

        IoSetCancelRoutine(pPort->CurrentImmediateIrp, SerialCancelImmediate);
            

        //
        // Since the cancel routine knows about the irp we
        // increment the reference count.
        //

        SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);

        if(UseATimer) 
		{
            KeSetTimer(&pPort->ImmediateTotalTimer, TotalTime, &pPort->TotalImmediateTimeoutDpc);
                
            //
            // Since the timer knows about the irp we increment
            // the reference count.
            //

            SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);
        }

		Slxos_SyncExec(pPort,SerialGiveImmediateToIsr,pPort,0x00);

        IoReleaseCancelSpinLock(OldIrql);

    }

}

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabImmediateFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

VOID
SerialGetNextImmediate(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This routine is used to complete the current immediate
    irp.  Even though the current immediate will always be
    completed and there is no queue associated with it, we
    use this routine so that we can try to satisfy a wait
    for transmit queue empty event. 

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.  This should point
                   to CurrentImmediateIrp.

    QueueToProcess - Always NULL.

    NewIrp - Always NULL on exit to this routine.

    CompleteCurrent - Should always be true for this routine.


Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PIRP OldIrp;

    UNREFERENCED_PARAMETER(QueueToProcess);
    UNREFERENCED_PARAMETER(CompleteCurrent);

    pPort = CONTAINING_RECORD(CurrentOpIrp, PORT_DEVICE_EXTENSION, CurrentImmediateIrp);
	OldIrp = *CurrentOpIrp;

    IoAcquireCancelSpinLock(&OldIrql);

    ASSERT(pPort->TotalCharsQueued >= 1);
    pPort->TotalCharsQueued--;

    *CurrentOpIrp = NULL;
    *NewIrp = NULL;

    Slxos_SyncExec(pPort,SerialProcessEmptyTransmit,pPort,0x01);

    IoReleaseCancelSpinLock(OldIrql);

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",OldIrp));
        
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(OldIrp,2);
#endif

	SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(OldIrp, IO_SERIAL_INCREMENT);

}

VOID
SerialCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel an irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabImmediateFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentImmediateIrp,
        NULL,
        NULL,
        &pPort->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate
        );

}

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TransmitImmediate = TRUE;
    pPort->ImmediateChar = *((UCHAR *) (pPort->CurrentImmediateIrp->AssociatedIrp.SystemBuffer));
       

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentImmediateIrp);

    //
    // Check first to see if a write is going on.  If
    // there is then we'll just slip in during the write.
    //

    if(!pPort->WriteLength) 
	{
        //
        // If there is no normal write transmitting then we will poll the
        // board (which we can do at any time).  Otherwise, we know the board
        // will interrupt us in due course.
        //

        Slxos_PollForInterrupt(pPort->pParentCardExt,FALSE);
    }

    return FALSE;

}

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or cancelling, from the ISR.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->TransmitImmediate) 
	{

        pPort->TransmitImmediate = FALSE;

        //
        // Since the isr no longer references this irp, we can
        // decrement its reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentImmediateIrp);
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\modmflow.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    modmflow.c

Abstract:

    This module contains *MOST* of the code used to manipulate
    the modem control and status registers.  The vast majority
    of the remainder of flow control is concentrated in the
    Interrupt service routine.  A very small amount resides
    in the read code that pull characters out of the interrupt
    buffer.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

BOOLEAN
SerialDecrementRTSCounter(
    IN PVOID Context
    );


BOOLEAN
SerialSetDTR(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    Slxos_SetDTR (Context);

    return FALSE;

}

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    Slxos_ClearDTR (Context);

    return FALSE;

}

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    Slxos_SetRTS (pPort);

    return FALSE;

}

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    Slxos_ClearRTS(pPort);

    return FALSE;

}

BOOLEAN
SerialSetupNewHandFlow(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_HANDFLOW NewHandFlow
    )

/*++

Routine Description:

    This routine adjusts the flow control based on new
    control flow.

Arguments:

    pPort - A pointer to the serial device extension.

    NewHandFlow - A pointer to a serial handflow structure
                  that is to become the new setup for flow
                  control.

Return Value:

    This routine always returns FALSE.

--*/

{

    SERIAL_HANDFLOW New = *NewHandFlow;

    //
    // If the pPort->DeviceIsOpen is FALSE that means
    // we are entering this routine in response to an open request.
    // If that is so, then we always proceed with the work regardless
    // of whether things have changed.
    //

    //
    // First we take care of the DTR flow control.  We only
    // do work if something has changed.
    //

    if ((!pPort->DeviceIsOpen) ||
        ((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) !=
         (New.ControlHandShake & SERIAL_DTR_MASK))) {

        SpxDbgMsg(
            SERFLOW,
            ("SERIAL: Processing DTR flow for %x.\n",
            pPort->pChannel)
            );

        if (New.ControlHandShake & SERIAL_DTR_MASK) {

            //
            // Well we might want to set DTR.
            //
            // Before we do, we need to check whether we are doing
            // DTR flow control.  If we are then we need to check
            // if then number of characters in the interrupt buffer
            // exceeds the XoffLimit.  If it does then we don't
            // enable DTR AND we set the RXHolding to record that
            // we are holding because of the DTR.
            //

            if ((New.ControlHandShake & SERIAL_DTR_MASK)
                == SERIAL_DTR_HANDSHAKE) {

                if ((pPort->BufferSize - New.XoffLimit) >
                    pPort->CharsInInterruptBuffer) {

                    //
                    // However if we are already holding we don't want
                    // to turn it back on unless we exceed the Xon
                    // limit.
                    //

                    if (pPort->RXHolding & SERIAL_RX_DTR) {

                        //
                        // We can assume that its DTR line is already low.
                        //

                        if (pPort->CharsInInterruptBuffer >
                            (ULONG)New.XonLimit) {

                            SpxDbgMsg(
                                SERFLOW,
                                ("SERIAL: Removing DTR block on reception for %x\n",
                                 pPort->pChannel)
                                );
                            pPort->RXHolding &= ~SERIAL_RX_DTR;
                            SerialSetDTR(pPort);

                        }

                    } else {

                        SerialSetDTR(pPort);

                    }

                } else {

                    SpxDbgMsg(
                        SERFLOW,
                        ("SERIAL: Setting DTR block on reception for %x\n",
                         pPort->pChannel)
                        );
                    pPort->RXHolding |= SERIAL_RX_DTR;
                    SerialClrDTR(pPort);

                }

            } else {

                //
                // Note that if we aren't currently doing DTR flow control then
                // we MIGHT have been.  So even if we aren't currently doing
                // DTR flow control, we should still check if RX is holding
                // because of DTR.  If it is, then we should clear the holding
                // of this bit.
                //

                if (pPort->RXHolding & SERIAL_RX_DTR) {

                    SpxDbgMsg(
                        SERFLOW,
                        ("SERIAL: Removing dtr block of reception for %x\n",
                        pPort->pChannel)
                        );
                    pPort->RXHolding &= ~SERIAL_RX_DTR;

                }

                SerialSetDTR(pPort);

            }

        } else {

            //
            // The end result here will be that DTR is cleared.
            //
            // We first need to check whether reception is being held
            // up because of previous DTR flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (pPort->RXHolding & SERIAL_RX_DTR) {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: removing dtr block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding &= ~SERIAL_RX_DTR;

            }

            SerialClrDTR(pPort);

        }

    }

    //
    // Time to take care of the RTS Flow control.
    //
    // First we only do work if something has changed.
    //

    if ((!pPort->DeviceIsOpen) ||
        ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) !=
         (New.FlowReplace & SERIAL_RTS_MASK))) {

        SpxDbgMsg(
            SERFLOW,
            ("SERIAL: Processing RTS flow for %x.\n",
            pPort->pChannel)
            );

        if ((New.FlowReplace & SERIAL_RTS_MASK) ==
            SERIAL_RTS_HANDSHAKE) {

            //
            // Well we might want to set RTS.
            //
            // Before we do, we need to check whether we are doing
            // RTS flow control.  If we are then we need to check
            // if then number of characters in the interrupt buffer
            // exceeds the XoffLimit.  If it does then we don't
            // enable RTS AND we set the RXHolding to record that
            // we are holding because of the RTS.
            //

            if ((pPort->BufferSize - New.XoffLimit) >
                pPort->CharsInInterruptBuffer) {

                //
                // However if we are already holding we don't want
                // to turn it back on unless we exceed the Xon
                // limit.
                //

                if (pPort->RXHolding & SERIAL_RX_RTS) {

                    //
                    // We can assume that its RTS line is already low.
                    //

                    if (pPort->CharsInInterruptBuffer >
                        (ULONG)New.XonLimit) {

                       SpxDbgMsg(
                           SERFLOW,
                           ("SERIAL: Removing rts block of reception for %x\n",
                           pPort->pChannel)
                           );
                        pPort->RXHolding &= ~SERIAL_RX_RTS;
                        SerialSetRTS(pPort);

                    }

                } else {

                    SerialSetRTS(pPort);

                }

            } else {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: Setting RTS block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding |= SERIAL_RX_RTS;
                SerialClrRTS(pPort);

            }

        } else if ((New.FlowReplace & SERIAL_RTS_MASK) ==
                   SERIAL_RTS_CONTROL) {

            //
            // Note that if we aren't currently doing RTS flow control then
            // we MIGHT have been.  So even if we aren't currently doing
            // RTS flow control, we should still check if RX is holding
            // because of RTS.  If it is, then we should clear the holding
            // of this bit.
            //

            if (pPort->RXHolding & SERIAL_RX_RTS) {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: Clearing RTS block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding &= ~SERIAL_RX_RTS;

            }

            SerialSetRTS(pPort);

        } else if ((New.FlowReplace & SERIAL_RTS_MASK) ==
                   SERIAL_TRANSMIT_TOGGLE) {

            //
            // We first need to check whether reception is being held
            // up because of previous RTS flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (pPort->RXHolding & SERIAL_RX_RTS) {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: TOGGLE Clearing RTS block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding &= ~SERIAL_RX_RTS;

            }

            //
            // We have to place the RTS value into the Extension
            // now so that the code that tests whether the
            // RTS line should be lowered will find that we
            // are "still" doing transmit toggling.  The code
            // for lowering can be invoked later by a timer so
            // it has to test whether it still needs to do its
            // work.
            //

            pPort->HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
            pPort->HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;

            //
            // The order of the tests is very important below.
            //
            // If there is a break then we should turn on the RTS.
            //
            // If there isn't a break but there are characters in
            // the hardware, then turn on the RTS.
            //
            // If there are writes pending that aren't being held
            // up, then turn on the RTS.
            //

            if ((pPort->TXHolding & SERIAL_TX_BREAK) ||
                Slxos_GetCharsInTxBuffer(pPort) != 0 ||
                (pPort->CurrentWriteIrp || pPort->TransmitImmediate ||
                 (!IsListEmpty(&pPort->WriteQueue)) &&
                 (!pPort->TXHolding))) {

                SerialSetRTS(pPort);

            } else {

                //
                // This routine will check to see if it is time
                // to lower the RTS because of transmit toggle
                // being on.  If it is ok to lower it, it will,
                // if it isn't ok, it will schedule things so
                // that it will get lowered later.
                //

                pPort->CountOfTryingToLowerRTS++;
                SerialPerhapsLowerRTS(pPort);

            }

        } else {

            //
            // The end result here will be that RTS is cleared.
            //
            // We first need to check whether reception is being held
            // up because of previous RTS flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (pPort->RXHolding & SERIAL_RX_RTS) {

                SpxDbgMsg(
                    SERFLOW,
                    ("SERIAL: Clearing RTS block of reception for %x\n",
                    pPort->pChannel)
                    );
                pPort->RXHolding &= ~SERIAL_RX_RTS;

            }

            SerialClrRTS(pPort);

        }

    }

    //
    // We now take care of automatic receive flow control.
    // We only do work if things have changed.
    //

    if ((!pPort->DeviceIsOpen) ||
        ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
         (New.FlowReplace & SERIAL_AUTO_RECEIVE))) {

        if (New.FlowReplace & SERIAL_AUTO_RECEIVE) {

            //
            // We wouldn't be here if it had been on before.
            //
            // We should check to see whether we exceed the turn
            // off limits.
            //
            // Note that since we are following the OS/2 flow
            // control rules we will never send an xon if
            // when enabling xon/xoff flow control we discover that
            // we could receive characters but we are held up due
            // to a previous Xoff.
            //

            if ((pPort->BufferSize - New.XoffLimit) <=
                pPort->CharsInInterruptBuffer) {

                //
                // Set the XOFF flag.  This will cause the driver to avoid
                // reading characters out of the hardware, and the hardware
                // will eventually send an XOFF itself.
                //
                pPort->RXHolding |= SERIAL_RX_XOFF;

            }

        } else {

            //
            // The app has disabled automatic receive flow control.
            //
            // If transmission was being held up because of
            // an automatic receive Xoff, then we should
            // cause an Xon to be sent.  Simply clearing the flag
            // will do the trick.
            //

            pPort->RXHolding &= ~SERIAL_RX_XOFF;

        }

    }

    //
    // We now take care of automatic transmit flow control.
    // We only do work if things have changed.
    //

    if ((!pPort->DeviceIsOpen) ||
        ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) !=
         (New.FlowReplace & SERIAL_AUTO_TRANSMIT))) {

        if (New.FlowReplace & SERIAL_AUTO_TRANSMIT) {

            //
            // We wouldn't be here if it had been on before.
            //
            // BUG BUG ??? There is some belief that if autotransmit
            // was just enabled, I should go look in what we
            // already received, and if we find the xoff character
            // then we should stop transmitting.  I think this
            // is an application bug.  For now we just care about
            // what we see in the future.
            //

            ;

        } else {

            //
            // The app has disabled automatic transmit flow control.
            //

            if (pPort->TXHolding & SERIAL_TX_XOFF) {

                pPort->TXHolding &= ~SERIAL_TX_XOFF;

                SpxDbgMsg(
                    SERDIAG1,
                    ("%s: SerialSetupNewHandFlow. TXHolding = %d\n",
                    PRODUCT_NAME,
                    pPort->TXHolding)
                    );
            }

        }

    }

    //
    // At this point we can simply make sure that entire
    // handflow structure in the extension is updated.
    // This will cause an interrupt, and that will deal with
    // automatic flow control.
    //

    pPort->HandFlow = New;
    Slxos_SetFlowControl(pPort);

    return FALSE;

}

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the handshake and control
    flow in the device extension.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a handflow
              structure..

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_IOCTL_SYNC S = Context;
    PPORT_DEVICE_EXTENSION pPort = S->pPort;
    PSERIAL_HANDFLOW HandFlow = S->Data;

    SerialSetupNewHandFlow(
        pPort,
        HandFlow
        );

    SerialHandleModemUpdate(pPort);

    return FALSE;

}

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will turn on break in the hardware and
    record the fact the break is on, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialSetRTS(pPort);

    }
    pPort->TXHolding |= SERIAL_TX_BREAK;
    Slxos_TurnOnBreak(pPort);

    return FALSE;

}

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will turn off break in the hardware and
    record the fact the break is off, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->TXHolding & SERIAL_TX_BREAK) {

        Slxos_TurnOffBreak(pPort);

        pPort->TXHolding &= ~SERIAL_TX_BREAK;

        if (!pPort->TXHolding &&
            (pPort->TransmitImmediate ||
             pPort->WriteLength)) {
	
            Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

        } else {

            //
            // The following routine will lower the rts if we
            // are doing transmit toggling and there is no
            // reason to keep it up.
            //

            pPort->CountOfTryingToLowerRTS++;
            SerialPerhapsLowerRTS(pPort);

        }

    }

    return FALSE;

}

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xoff was received.  Even if the
    driver does not have automatic Xoff/Xon flowcontrol - This
    still will stop the transmission.  This is the OS/2 behavior
    and is not well specified for Windows.  Therefore we adopt
    the OS/2 behavior.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TXHolding |= SERIAL_TX_XOFF;

    SpxDbgMsg(
        SERDIAG1,
        ("%s: SerialPretendXoff. TXHolding = %d\n",
        PRODUCT_NAME,
        pPort->TXHolding)
        );
        
    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

		if (KeInsertQueueDpc(
		        &pPort->StartTimerLowerRTSDpc,
		        NULL,
		        NULL
		        ))

		    pPort->CountOfTryingToLowerRTS++;

    }

    return FALSE;

}

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xon was received.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->TXHolding) {

        //
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.


        if ((pPort->TXHolding & SERIAL_TX_XOFF) &&
            ((pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) ||
             (pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT))) {

            // Automatic Xon/Xoff transmit is enabled. Simulate Xon received.
            Slxos_Resume(pPort);

        }
        pPort->TXHolding &= ~SERIAL_TX_XOFF;

        SpxDbgMsg(
            SERDIAG1,
            ("%s: SerialPretendXon. TXHolding = %d\n",
            PRODUCT_NAME,
            pPort->TXHolding)
            );

        if (!pPort->TXHolding &&
            (pPort->TransmitImmediate ||
             pPort->WriteLength)) {

           Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

        }

    }

    return FALSE;

}

VOID
SerialHandleReducedIntBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is called to handle a reduction in the number
    of characters in the interrupt (typeahead) buffer.  It
    will check the current output flow control and re-enable transmission
    as needed.

    NOTE: This routine assumes that it is working at interrupt level.

Arguments:

    pPort - A pointer to the device extension.

Return Value:

    None.

--*/

{


    //
    // If we are doing receive side flow control and we are
    // currently "holding" then because we've emptied out
    // some characters from the interrupt buffer we need to
    // see if we can "re-enable" reception.
    //

    if (pPort->RXHolding) {

        if (pPort->CharsInInterruptBuffer <=
            (ULONG)pPort->HandFlow.XonLimit) {

            if (pPort->RXHolding & SERIAL_RX_DTR) {

                pPort->RXHolding &= ~SERIAL_RX_DTR;

                SpxDbgMsg(
                    SERDIAG1,
                    ("%s: SerialHandleReducedIntBuffer() RX_DTR for %x. "
                    "RXHolding = %d, TXHolding = %d\n",
                    PRODUCT_NAME,
                    pPort->pChannel,
                    pPort->RXHolding, pPort->TXHolding)
                    );
                    
                SerialSetDTR(pPort);
            }

            if (pPort->RXHolding & SERIAL_RX_RTS) {

                pPort->RXHolding &= ~SERIAL_RX_RTS;
                Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

                SpxDbgMsg(
                    SERDIAG1,
                    ("%s: SerialHandleReducedIntBuffer() RX_RTS for %x. "
                    "RXHolding = %d, TXHolding = %d\n",
                    PRODUCT_NAME,
                    pPort->pChannel,
                    pPort->RXHolding,
                    pPort->TXHolding)
                    );

                SerialSetRTS(pPort);
            }

            if (pPort->RXHolding & SERIAL_RX_XOFF) {

                //
                // Clear the holding flag.  This may cause the receive
                // logic to empty the hardware receive buffers enough
                // to cause it to send an XON.
                //
                pPort->RXHolding &= ~SERIAL_RX_XOFF;
                Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

                SpxDbgMsg(
                    SERDIAG1,
                    ("%s: SerialHandleReducedIntBuffer() RX_XOFF for %x. "
                    "RXHolding = %d, TXHolding = %d\n",
                    PRODUCT_NAME,
                    pPort->pChannel,
                    pPort->RXHolding,
                    pPort->TXHolding)
                    );
            }

        }

    }

}

ULONG
SerialHandleModemUpdate(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will be to check on the modem status, and
    handle any appropriate event notification as well as
    any flow control appropriate to modem status lines.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    This returns the old value of the modem status register
    (extended into a ULONG).

--*/
{

    //
    // We keep this local so that after we are done
    // examining the modem status and we've updated
    // the transmission holding value, we know whether
    // we've changed from needing to hold up transmission
    // to transmission being able to proceed.
    //
    ULONG OldTXHolding = pPort->TXHolding;

    //
    // Holds the value in the mode status register.
    //
    UCHAR ModemStatus;

    ModemStatus = Slxos_GetModemStatus(pPort);

    //
    // If we are placing the modem status into the data stream
    // on every change, we should do it now.
    //

    if (pPort->EscapeChar) {

        if (ModemStatus & (SERIAL_MSR_DCTS |
                           SERIAL_MSR_DDSR |
                           SERIAL_MSR_TERI |
                           SERIAL_MSR_DDCD)) {

	    UCHAR	EscapeString[3] = {pPort->EscapeChar,SERIAL_LSRMST_MST,ModemStatus};

	    SerialPutBlock(pPort,EscapeString,3,FALSE);
        }

    }


    //
    // Take care of input flow control based on sensitivity
    // to the DSR.  This is done so that the application won't
    // see spurious data generated by odd devices.
    //
    // Basically, if we are doing dsr sensitivity then the
    // driver should only accept data when the dsr bit is
    // set.
    //

    if (pPort->HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) {

        if (ModemStatus & SERIAL_MSR_DSR) {

            //
            // The line is high.  Simply make sure that
            // RXHolding does't have the DSR bit.
            //

            pPort->RXHolding &= ~SERIAL_RX_DSR;

        } else {

            pPort->RXHolding |= SERIAL_RX_DSR;

        }

    } else {

        //
        // We don't have sensitivity due to DSR.  Make sure we
        // aren't holding. (We might have been, but the app just
        // asked that we don't hold for this reason any more.)
        //

        pPort->RXHolding &= ~SERIAL_RX_DSR;

    }

        //
        // Check to see if we have a wait
        // pending on the modem status events.  If we
        // do then we schedule a dpc to satisfy
        // that wait.
        //

    if (pPort->IsrWaitMask) {

        if ((pPort->IsrWaitMask & SERIAL_EV_CTS) &&
            (ModemStatus & SERIAL_MSR_DCTS)) {

            pPort->HistoryMask |= SERIAL_EV_CTS;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_DSR) &&
            (ModemStatus & SERIAL_MSR_DDSR)) {

            pPort->HistoryMask |= SERIAL_EV_DSR;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_RING) &&
            (ModemStatus & SERIAL_MSR_TERI)) {

            pPort->HistoryMask |= SERIAL_EV_RING;

        }

        if ((pPort->IsrWaitMask & SERIAL_EV_RLSD) &&
            (ModemStatus & SERIAL_MSR_DDCD)) {

            pPort->HistoryMask |= SERIAL_EV_RLSD;

        }

        if (pPort->IrpMaskLocation &&
            pPort->HistoryMask) {

            *pPort->IrpMaskLocation =
             pPort->HistoryMask;

            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->
                IoStatus.Information = sizeof(ULONG);

            KeInsertQueueDpc(
                &pPort->CommWaitDpc,
                NULL,
                NULL
                );
        }

    }

    //
    // We have an automatic Hardware Flow Control but we still need
    // to update flags for GetCommStatus().
    //
    // If the app has modem line flow control then
    // we check to see if we have to hold up transmission.
    //

    if (pPort->HandFlow.ControlHandShake &
        SERIAL_OUT_HANDSHAKEMASK) {

        if (pPort->HandFlow.ControlHandShake &
            SERIAL_DSR_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_DSR) {

                pPort->TXHolding &= ~SERIAL_TX_DSR;

            } else {

                pPort->TXHolding |= SERIAL_TX_DSR;

            }

        } else {

            pPort->TXHolding &= ~SERIAL_TX_DSR;

        }

        if (pPort->HandFlow.ControlHandShake &
            SERIAL_DCD_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_DCD) {

                pPort->TXHolding &= ~SERIAL_TX_DCD;

            } else {

                pPort->TXHolding |= SERIAL_TX_DCD;

            }

        } else {

            pPort->TXHolding &= ~SERIAL_TX_DCD;

        }

        //
        // If we hadn't been holding, and now we are then
        // queue off a dpc that will lower the RTS line
        // if we are doing transmit toggling.
        //

        if (!OldTXHolding && pPort->TXHolding &&
            (pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
                SERIAL_TRANSMIT_TOGGLE) {

            if (KeInsertQueueDpc(
                    &pPort->StartTimerLowerRTSDpc,
                    NULL,
                    NULL
                    ))
                pPort->CountOfTryingToLowerRTS++;
        }

        //
        // We've done any adjusting that needed to be
        // done to the holding mask given updates
        // to the modem status.  If the Holding mask
        // is clear (and it wasn't clear to start)
        // and we have "write" work to do set things
        // up so that the transmission code gets invoked.
        //

        if (OldTXHolding && !pPort->TXHolding &&
            (pPort->TransmitImmediate || pPort->WriteLength)) {

            Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

        }

    } else {

        //
        // We need to check if transmission is holding
        // up because of modem status lines.  What
        // could have occurred is that for some strange
        // reason, the app has asked that we no longer
        // stop doing output flow control based on
        // the modem status lines.  If however, we
        // *had* been held up because of the status lines
        // then we need to clear up those reasons.
        //

        if (pPort->TXHolding & (SERIAL_TX_DCD | SERIAL_TX_DSR)) {

            pPort->TXHolding &= ~(SERIAL_TX_DCD | SERIAL_TX_DSR);

            if (OldTXHolding && !pPort->TXHolding &&
                (pPort->TransmitImmediate || pPort->WriteLength)) {

                Slxos_PollForInterrupt(pPort->pParentCardExt, FALSE);

            }

        }

    }

    SpxDbgMsg(
        SERDIAG1,
        ("%s: SerialHandleModemUpdate for %x. "
        "RXHolding = %d, TXHolding = %d\n",
        PRODUCT_NAME,
        pPort->pChannel,
        pPort->RXHolding,
        pPort->TXHolding)
        );
        
    return ((ULONG)ModemStatus);
}

BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;


    //
    // We first need to test if we are actually still doing
    // transmit toggle flow control.  If we aren't then
    // we have no reason to try be here.
    //

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        //
        // The order of the tests is very important below.
        //
        // If there is a break then we should leave on the RTS,
        // because when the break is turned off, it will submit
        // the code to shut down the RTS.
        //
        // If there are writes pending that aren't being held
        // up, then leave on the RTS, because the end of the write
        // code will cause this code to be reinvoked.  If the writes
        // are being held up, its ok to lower the RTS because the
        // upon trying to write the first character after transmission
        // is restarted, we will raise the RTS line.
        //

        if ((pPort->TXHolding & SERIAL_TX_BREAK) ||
            (pPort->CurrentWriteIrp || pPort->TransmitImmediate ||
             (!IsListEmpty(&pPort->WriteQueue)) &&
             (!pPort->TXHolding))) {

            NOTHING;

        } else {

            //
            // Looks good so far.  Call the line status check and processing
            // code, it will return the "current" line status value.  If
            // the holding and shift register are clear, lower the RTS line,
            // if they aren't clear, queue of a dpc that will cause a timer
            // to reinvoke us later.  We do this code here because no one
            // but this routine cares about the characters in the hardware,
            // so no routine by this routine will bother invoking to test
            // if the hardware is empty.
            //
            if (Slxos_GetCharsInTxBuffer(pPort) != 0) {

                //
                // Well it's not empty, try again later.
                //

                if (KeInsertQueueDpc(
                        &pPort->StartTimerLowerRTSDpc,
                        NULL,
                        NULL
                        ))
                    pPort->CountOfTryingToLowerRTS++;

            } else {

                //
                // Nothing in the hardware, lower the RTS.
                //

                SerialClrRTS(pPort);

            }

        }

    }

    //
    // We decrement the counter to indicate that we've reached
    // the end of the execution path that is trying to push
    // down the RTS line.
    //

    pPort->CountOfTryingToLowerRTS--;

    return FALSE;
}

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine starts a timer that when it expires will start
    a dpc that will check if it can lower the rts line because
    there are no characters in the hardware.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    LARGE_INTEGER CharTime;
    KIRQL OldIrql;
    ULONG nChars;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    //
    // Take out the lock to prevent the line control
    // from changing out from under us while we calculate
    // a character time.
    //

    KeAcquireSpinLock(
        &pPort->ControlLock,
        &OldIrql
        );

    CharTime = SerialGetCharTime(pPort);
    nChars = Slxos_GetCharsInTxBuffer(pPort);

    KeReleaseSpinLock(
        &pPort->ControlLock,
        OldIrql
        );

    CharTime = RtlExtendedIntegerMultiply(
                   CharTime,
                   nChars
                   );
    CharTime = RtlLargeIntegerNegate(CharTime);

    if (KeSetTimer(
            &pPort->LowerRTSTimer,
            CharTime,
            &pPort->PerhapsLowerRTSDpc
            )) {

        //
        // The timer was already in the timer queue.  This implies
        // that one path of execution that was trying to lower
        // the RTS has "died".  Synchronize with the ISR so that
        // we can lower the count.
        //

	Slxos_SyncExec(pPort,SerialDecrementRTSCounter,pPort,0x12);

    }

}

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This dpc routine exists solely to call the code that
    tests if the rts line should be lowered when TRANSMIT
    TOGGLE flow control is being used.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    Slxos_SyncExec(pPort,SerialPerhapsLowerRTS,pPort,0x13);

}

BOOLEAN
SerialDecrementRTSCounter(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine decrements the count of threads that are trying
    to lower RTS.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->CountOfTryingToLowerRTS--;

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\openclos.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module contains the code that is very specific to
    opening, closing, and cleaning up in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

BOOLEAN
SerialMarkOpen(
    IN PVOID Context
    );

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    );

//
// Just a bogus little routine to make sure that we
// can synch with the ISR.
//
BOOLEAN
SerialNullSynch(
    IN PVOID Context
    ) {

    UNREFERENCED_PARAMETER(Context);
    return FALSE;
}

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We connect up to the interrupt for the create/open and initialize
    the structures needed to maintain an open for a device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialCreateOpen dispatch entry for: %x\n",Irp));
    SpxDbgMsg(SERDIAG3,("SERIAL: In SerialCreateOpen\n"));

	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

	if(DeviceObject->DeviceType != FILE_DEVICE_SERIAL_PORT)	
	{
	    Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
		return(STATUS_ACCESS_DENIED);
	}

    //
    // Before we do anything, let's make sure they aren't trying
    // to create a directory.  This is a silly, but what's a driver to do!?
    //

    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options & FILE_DIRECTORY_FILE)
	{
        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;

        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,4);
#endif
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return STATUS_NOT_A_DIRECTORY;
    }

  	if(pPort->DeviceIsOpen)					// Is port already open? 
	{
		Irp->IoStatus.Status = STATUS_ACCESS_DENIED;// Yes, deny access 
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);
		IoCompleteRequest(Irp,IO_NO_INCREMENT);

		return(STATUS_ACCESS_DENIED);
	}

    //
    // Create a buffer for the RX data when no reads are outstanding.
    //

    pPort->InterruptReadBuffer = NULL;
    pPort->BufferSize = 0;

    switch (MmQuerySystemSize()) 
	{
        case MmLargeSystem: 
			{
				pPort->BufferSize = 4096;
				pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
                                                 
				if(pPort->InterruptReadBuffer) 
				{
					break;
				}
			}

        case MmMediumSystem: 
			{
				pPort->BufferSize = 1024;
				pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
                                                
				if(pPort->InterruptReadBuffer) 
				{
					break;
				}

			}

        case MmSmallSystem: 
			{
				pPort->BufferSize = 128;
				pPort->InterruptReadBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
			}

    }

    if (!pPort->InterruptReadBuffer) 
	{
        pPort->BufferSize = 0;
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;

        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,5);
#endif
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
            
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // On a new open we "flush" the read queue by initializing the
    // count of characters.
    //

    {
    	KIRQL	OldIrql;
		KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
		pPort->CharsInInterruptBuffer = 0;
		KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

    pPort->LastCharSlot = pPort->InterruptReadBuffer + (pPort->BufferSize - 1);
                              

    pPort->ReadBufferBase = pPort->InterruptReadBuffer;
    pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
    pPort->FirstReadableChar = pPort->InterruptReadBuffer;
    pPort->TotalCharsQueued = 0;

	Slxos_SyncExec(pPort,SpxClearAllPortStats,pPort,0x24);

    //
    // We set up the default xon/xoff limits.
    //

    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));
                                   

    pPort->IrpMaskLocation = NULL;
    pPort->HistoryMask = 0;
    pPort->IsrWaitMask = 0;

    //
    // The escape char replacement must be reset upon every open.
    //

    pPort->EscapeChar = 0;
    pPort->InsertEscChar = FALSE;

    Irp->IoStatus.Status = STATUS_SUCCESS;

    Slxos_SyncExec(pPort,SerialMarkOpen,pPort,0x14);

    Irp->IoStatus.Information = 0L;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,6);
#endif
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

VOID
SerialWaitForTxToDrain(
    IN PPORT_DEVICE_EXTENSION pPort
    )
/*++

Routine Description:

    Wait (via KeDelayExecutionThread) for the transmit buffer to drain.

Arguments:

    pPort - The device extension

Return Value:

    None.

--*/
{
    //
    // This "timer value" is used to wait until the hardware is
    // empty.
    //
    LARGE_INTEGER nCharDelay;

    //
    // Holds a character time.
    //
    LARGE_INTEGER charTime;

    //
    // Used to hold the number of characters in the transmit hardware.
    //
    ULONG nChars;

    charTime = RtlLargeIntegerNegate(SerialGetCharTime(pPort));

/* Calculate the number of characters still to transmit... */

	nChars = Slxos_GetCharsInTxBuffer(pPort);	/* Number of characters waiting  */
	nChars += 10;					/* Plus a bit */

/* Wait for the time it would take the characters to drain... */

	while(Slxos_GetCharsInTxBuffer(pPort))	/* While chars in tx buffer */
	{
		KeDelayExecutionThread(KernelMode,FALSE,&charTime);	/* Wait one char time */
		
		if(nChars-- == 0)					/* Timeout */
			break;
	}

/* ESIL_0925 08/11/99 */
	Slxos_SyncExec(pPort,Slxos_FlushTxBuff,pPort,0x25);		/* Flush buffer */
/* ESIL_0925 08/11/99 */

}

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We simply disconnect the interrupt for now.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // This "timer value" is used to wait 10 character times before
    // we actually "run down" all of the flow control/break junk.
    //
    LARGE_INTEGER nCharDelay;

    //
    // Holds a character time.
    //
    LARGE_INTEGER charTime;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialClose dispatch entry for: %x\n",Irp));
    SpxDbgMsg(SERDIAG3,("SERIAL: In SerialClose\n"));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    charTime = RtlLargeIntegerNegate(SerialGetCharTime(pPort));

    //
    // Synchronize with the ISR to let it know that interrupts are
    // no longer important.
    //

    Slxos_SyncExec(pPort,SerialMarkClose,pPort,0x15);

    //
    // Synchronize with the isr to turn off break if it
    // is already on.
    //

    Slxos_SyncExec(pPort,SerialTurnOffBreak,pPort,0x0D);

    //
    // If the driver has automatically transmitted an Xoff in
    // the context of automatic receive flow control then we
    // should transmit an Xon.
    //

    if(pPort->RXHolding & SERIAL_RX_XOFF) 
        Slxos_SendXon(pPort);

    //
    // Wait until all characters have been emptied out of the hardware.
    //
    SerialWaitForTxToDrain(pPort);

    //
    // The hardware is empty.  Delay 10 character times before
    // shut down all the flow control.
    //
    nCharDelay = RtlExtendedIntegerMultiply(charTime,10);

    KeDelayExecutionThread(KernelMode, TRUE, &nCharDelay);
        
    SerialClrDTR(pPort);
    SerialClrRTS(pPort);

    //
    // Tell the hardware the device is closed.
    //

    Slxos_DisableAllInterrupts(pPort);


    //
    // Clean out the holding reasons (since we are closed).
    //

    pPort->RXHolding = 0;
    pPort->TXHolding = 0;

    //
    // All is done.  The port has been disabled from interrupting
    // so there is no point in keeping the memory around.
    //

    pPort->BufferSize = 0;
    SpxFreeMem(pPort->InterruptReadBuffer);
    pPort->InterruptReadBuffer = NULL;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,7);
#endif

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

BOOLEAN
SerialMarkOpen(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine sets a boolean to true to mark the fact that somebody
    opened the device and it's worthwhile to pay attention to
    interrupts.  It also tells the hardware that the device is open.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

	pPort->DataInTxBuffer = FALSE;		// Reset flag to show that buffer is empty.

    // Open the board
    Slxos_EnableAllInterrupts(pPort);

    // Configure Channel.
    Slxos_ResetChannel(pPort);

    pPort->DeviceIsOpen = TRUE;
    pPort->ErrorWord = 0;


#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
	pPort->WmiCommData.IsBusy = TRUE;
#endif

    return FALSE;

}

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine merely sets a boolean to false to mark the fact that
    somebody closed the device and it's no longer worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->DeviceIsOpen = FALSE;

#ifdef WMI_SUPPORT
	pPort->WmiCommData.IsBusy	= FALSE;
#endif

    return FALSE;

}

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is used to kill all longstanding IO operations.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    KIRQL oldIrql;

    SpxDbgMsg(SERIRPPATH, ("SERIAL: SerialCleanup dispatch entry for: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
        

    //
    // First kill all the reads and writes.
    //

    SerialKillAllReadsOrWrites(DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);
        
    //
    // Next get rid of purges.
    //

    SerialKillAllReadsOrWrites(DeviceObject, &pPort->PurgeQueue, &pPort->CurrentPurgeIrp);
        

    //
    // Get rid of any mask operations.
    //

    SerialKillAllReadsOrWrites(DeviceObject, &pPort->MaskQueue, &pPort->CurrentMaskIrp);

    //
    // Now get rid a pending wait mask irp.
    //

    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CurrentWaitIrp) 
	{
        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = pPort->CurrentWaitIrp->CancelRoutine;
        pPort->CurrentWaitIrp->Cancel = TRUE;

        if(cancelRoutine) 
		{
            pPort->CurrentWaitIrp->CancelIrql = oldIrql;
            pPort->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(DeviceObject, pPort->CurrentWaitIrp);
        }
    } 
	else 
	{
        IoReleaseCancelSpinLock(oldIrql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,8);
#endif


	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

LARGE_INTEGER
SerialGetCharTime(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This function will return the number of 100 nanosecond intervals
    there are in one character time (based on the present form
    of flow control.

Arguments:

    pPort - Just what it says.

Return Value:

    100 nanosecond intervals in a character time.

--*/

{

    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;

    switch (pPort->LineControl & SERIAL_DATA_MASK) 
	{
        case SERIAL_5_DATA:
            dataSize = 5;
            break;

        case SERIAL_6_DATA:
            dataSize = 6;
            break;

        case SERIAL_7_DATA:
            dataSize = 7;
            break;

        case SERIAL_8_DATA:
            dataSize = 8;
            break;
    }

    paritySize = 1;

    if((pPort->LineControl & SERIAL_PARITY_MASK) == SERIAL_NONE_PARITY)
        paritySize = 0;


    if (pPort->LineControl & SERIAL_2_STOP) 
	{
        // Even if it is 1.5, for sanity's sake we're going to say 2.
        stopSize = 2;
    } 
	else 
	{
        stopSize = 1;
    }

    //
    // First we calculate the number of 100 nanosecond intervals which
    // are in a single bit time (approximately).  Then multiply by the
    // number of bits in a character (start, data, parity, and stop bits).
    //

    bitTime = (10000000+(pPort->CurrentBaud-1))/pPort->CurrentBaud;
    charTime = (1 + dataSize + paritySize + stopSize) * bitTime;

    return RtlConvertUlongToLargeInteger(charTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\qsfile.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    qsfile.c

Abstract:

    This module contains the code that is very specific to query/set file
    operations in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is returned with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialQueryInformationFile dispatch entry for: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
        
        
    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;


    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    if(IrpSp->Parameters.QueryFile.FileInformationClass == FileStandardInformation)
	{

        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize = RtlConvertUlongToLargeInteger(0ul);
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } 
	else
	{
		if(IrpSp->Parameters.QueryFile.FileInformationClass == FilePositionInformation)
		{
			((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->CurrentByteOffset 
				= RtlConvertUlongToLargeInteger(0ul);

			Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

		} 
		else 
		{
			Status = STATUS_INVALID_PARAMETER;
		}
	}

	Irp->IoStatus.Status = Status;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,9);
#endif

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;
}

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened serial port.  Any other file information request
    is returned with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialSetInformationFile dispatch entry for: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
    
        
    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    if((IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation) 
		|| (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileAllocationInformation)) 
	{
        Status = STATUS_SUCCESS;
    } 
	else 
	{
        Status = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = Status;

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,10);
#endif

	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\purge.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    purge.c

Abstract:

    This module contains the code that is very specific to purge
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


NTSTATUS
SerialStartPurge(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.

Arguments:

    pPort - Pointer to the device extension.

Return Value:

    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.

--*/

{

    PIRP NewIrp;

    do {

        ULONG Mask;

        Mask = *((ULONG *)
                 (pPort->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));

        if (Mask & SERIAL_PURGE_TXABORT) {

            SerialKillAllReadsOrWrites(
                pPort->DeviceObject,
                &pPort->WriteQueue,
                &pPort->CurrentWriteIrp
                );

            SerialKillAllReadsOrWrites(
                pPort->DeviceObject,
                &pPort->WriteQueue,
                &pPort->CurrentXoffIrp
                );

        }

        if (Mask & SERIAL_PURGE_RXABORT) {

            SerialKillAllReadsOrWrites(
                pPort->DeviceObject,
                &pPort->ReadQueue,
                &pPort->CurrentReadIrp
                );

        }

        if (Mask & SERIAL_PURGE_RXCLEAR) {

            KIRQL OldIrql;

            //
            // Clean out the interrupt buffer.
            //
            // Note that we do this under protection of the
            // the driver's control lock so that we don't hose
            // the pointers if there is currently a read that
            // is reading out of the buffer.
            //

            KeAcquireSpinLock(
                &pPort->ControlLock,
                &OldIrql
                );

	    Slxos_SyncExec(pPort,SerialPurgeInterruptBuff,pPort,0x16);

            KeReleaseSpinLock(
                &pPort->ControlLock,
                OldIrql
                );

        }

        if(Mask&SERIAL_PURGE_TXCLEAR)
        {
		KIRQL OldIrql;

		KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);
		Slxos_SyncExec(pPort,Slxos_FlushTxBuff,pPort,0x17);
		KeReleaseSpinLock(&pPort->ControlLock,OldIrql);
        }

        pPort->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
        pPort->CurrentPurgeIrp->IoStatus.Information = 0;

        SerialGetNextIrp(pPort, &pPort->CurrentPurgeIrp, &pPort->PurgeQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return STATUS_SUCCESS;

}

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply resets the interrupt (typeahead) buffer.

    NOTE: This routine is being called from KeSynchronizeExecution.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The typeahead buffer is by definition empty if there
    // currently is a read owned by the isr.
    //


    if (pPort->ReadBufferBase == pPort->InterruptReadBuffer) {

        pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
        pPort->FirstReadableChar = pPort->InterruptReadBuffer;
        pPort->LastCharSlot = pPort->InterruptReadBuffer +
                                      (pPort->BufferSize - 1);
    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
        pPort->CharsInInterruptBuffer = 0;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

        SerialHandleReducedIntBuffer(pPort);

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//	Precompiled Header
/////////////////////////////////////////////////////////////////////////////

#include <ntddk.h>
#include <ntddser.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#define USE_NEW_TX_BUFFER_EMPTY_DETECT	1

#define WMI_SUPPORT	// Include WMI Support code
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>


// Structures and definitions.
#include "sx_ver.h"	// Dirver Version Information
#include "spx_defs.h"	// Definitions
#include "sx_defs.h"	// SX Specific Definitions
#include "spx_card.h"	// Common Card Info
#include "sx_card.h"	// SX card and port device extension structures
#include "spx_misc.h"	// Misc 

// SX specific function prototypes
#include "serialp.h"	// Exportable Function Prototypes
#include "slxosexp.h"	// SI/XIO/SX Exported Function Prototypes
#include "slxos_nt.h"	// SI/XIO/SX Family Card Definitions

// Common PnP function prototypes.
#include "spx.h"	// Common PnP header

#if defined(i386)
#include "sx_log.h"	// Error Log Messages
#endif // i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\isr.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    isr.c

Abstract:

    This module contains the interrupt service routine for the
    serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */


BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the serial port driver.
    It will determine whether the serial port is the source of this
    interrupt.  If it is, then this routine will do the minimum of
    processing to quiet the interrupt.  It will store any information
    necessary for later processing.

Arguments:

    InterruptObject - Points to the interrupt object declared for this
    device.  We *do not* use this parameter.

    Context - This is really a pointer to the multiport dispatch object
    for this device.

Return Value:

    This function will return TRUE if the serial port is the source
    of this interrupt, FALSE otherwise.

--*/
{
    //
    // Holds the information specific to handling this device.
    //
    PCARD_DEVICE_EXTENSION pCard = Context;

    //
    // Will hold whether we've serviced any interrupt causes in this
    // routine.
    //
    BOOLEAN ServicedAnInterrupt;

    UNREFERENCED_PARAMETER(InterruptObject);

    ServicedAnInterrupt = Slxos_Interrupt(pCard);

    return ServicedAnInterrupt;

}

/*****************************************************************************
*****************************                    *****************************
*****************************   SerialPutBlock   *****************************
*****************************                    *****************************
******************************************************************************

Prototype:	UCHAR	SerialPutBlock(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pBlock,IN UCHAR BlockLen,BOOLEAN Filter)

Description:	Places a block of characters in the user/interrupt buffer and performs flow control
				checks and filtering as necessary.

Parameters:		pPort points to the extension for the current channel
				pBlock points to a contiguous block of bytes
				BlockLen is the length of the block
				Filter indicates if character filtering is to be performed.

Returns:		The number of characters actually queued

NOTE:			This routine is only called at device level.

*/

UCHAR	SerialPutBlock(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pBlock,IN UCHAR BlockLen,BOOLEAN Filter)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	UCHAR					OriginalBlockLen = BlockLen;
    KIRQL					OldIrql;
	ULONG					TransferLen;

/* Skip DSR input sensitivity, as by the time data reaches this routine it is almost certainly */
/* out of synchronization with the data.  This task should be performed by the device itself. */

/* Check to see if the data really needs byte-by-byte filtering... */

	if((Filter)							/* IF Filter is specified */
	&&((pPort->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING)==0)		/* AND NO NULL stripping */
	&&((pPort->IsrWaitMask & (SERIAL_EV_RXCHAR | SERIAL_EV_RXFLAG))==0)	/* AND NO receive any/specific data events */
	&&(pPort->EscapeChar == 0))				/* AND NO Escape character */
		Filter = FALSE;						/* THEN Switch off filtering */

/* Copy as much data as possible into the user buffer... */

	if(pPort->ReadBufferBase != pPort->InterruptReadBuffer)		/* User buffer ? */
	{								/* Yes, must be room for at least one char (by definition) */
		pPort->ReadByIsr++;			/* Increment to inform interval timer read has occurred */

		if(Filter)						/* Filtered transfer */
		{
			while((BlockLen) && (pPort->CurrentCharSlot <= pPort->LastCharSlot))
			{
				TransferLen = SerialTransferReadChar(pPort,pBlock,pPort->CurrentCharSlot);
				pPort->CurrentCharSlot += TransferLen&0xFF;	/* Update buffer pointer */
				pBlock += (TransferLen>>8)&0xFF;			/* Update block pointer */
				BlockLen -= (UCHAR)(TransferLen>>8)&0xFF;	/* Update block length */
			}
		}
		else							/* Non-filtered, optimised transfer */
		{
			TransferLen = pPort->LastCharSlot + 1 - pPort->CurrentCharSlot;/* Calculate available space */
			
			if(TransferLen > BlockLen) 
				TransferLen = BlockLen;	/* Trim to available data */
			
			if(pCard->CardType == SiPCI)
				SpxCopyBytes(pPort->CurrentCharSlot,pBlock,TransferLen);	/* Byte-by-Byte Transfer */
			else	
				RtlMoveMemory(pPort->CurrentCharSlot,pBlock,TransferLen);	/* Optimised Transfer */
			
			pPort->CurrentCharSlot += TransferLen;		/* Update buffer pointer */
			pBlock += TransferLen;						/* Update block pointer */
			BlockLen -= (UCHAR)TransferLen;				/* Update block length */
		}

		if(pPort->CurrentCharSlot > pPort->LastCharSlot)		/* User buffer full */
		{							/* Switch to ISR buffer and complete read */
			pPort->ReadBufferBase		= pPort->InterruptReadBuffer;
			pPort->CurrentCharSlot		= pPort->InterruptReadBuffer;
			pPort->FirstReadableChar	= pPort->InterruptReadBuffer;
			pPort->LastCharSlot			= pPort->InterruptReadBuffer + (pPort->BufferSize - 1);

			KeAcquireSpinLock(&pPort->BufferLock, &OldIrql);
			pPort->CharsInInterruptBuffer = 0;
			KeReleaseSpinLock(&pPort->BufferLock, OldIrql);

			pPort->CurrentReadIrp->IoStatus.Information 
				= IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length;
			
			KeInsertQueueDpc(&pPort->CompleteReadDpc, NULL, NULL);
		}
	}

/* Now, check interrupt buffer and flow off if remaining buffer space is less or equal to user specified limit... */

    if((pPort->BufferSize - pPort->HandFlow.XoffLimit) <= (pPort->CharsInInterruptBuffer + BlockLen))
    {
		if((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
			pPort->RXHolding |= SERIAL_RX_DTR;		/* DTR flow off */

		if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE)
			pPort->RXHolding |= SERIAL_RX_RTS;		/* RTS flow off */

		if(pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)
			pPort->RXHolding |= SERIAL_RX_XOFF;		/* XOFF flow off */
	}

/* Enqueue characters in the interrupt buffer... */

	if(BlockLen)
	{
		ULONG	CharsInInterruptBufferWas = pPort->CharsInInterruptBuffer;

		if(Filter)
		{
			while((BlockLen) && (pPort->CharsInInterruptBuffer < pPort->BufferSize))
			{
				TransferLen = SerialTransferReadChar(pPort,pBlock,pPort->CurrentCharSlot);
				pPort->CurrentCharSlot += TransferLen&0xFF;	/* Update buffer pointer */

				if(pPort->CurrentCharSlot > pPort->LastCharSlot)	/* Check for buffer wrap */
					pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
				
				KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
				pPort->CharsInInterruptBuffer += TransferLen&0xFF;/* Update buffer count */
				KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
				
				pBlock += (TransferLen>>8)&0xFF;			/* Update block pointer */
				BlockLen -= (UCHAR)(TransferLen>>8)&0xFF;	/* Update block length */
			}
		}
		else							/* Non-filtered, optimised transfer */
		{
			while(BlockLen)
			{
				TransferLen = pPort->BufferSize - pPort->CharsInInterruptBuffer;	/* Calculate available space */
				
				if(TransferLen == 0) 
					break;					/* No space left */
				
				if(TransferLen > (ULONG)(pPort->LastCharSlot + 1 - pPort->CurrentCharSlot)) /* Does space wrap ? */
					TransferLen = pPort->LastCharSlot + 1 - pPort->CurrentCharSlot;	/* Yes */
				
				if(TransferLen > BlockLen) 
					TransferLen = BlockLen;		/* Trim to available data */
				
				if(pCard->CardType == SiPCI)
					SpxCopyBytes(pPort->CurrentCharSlot,pBlock,TransferLen);	/* Byte-by-Byte Transfer */
				else	
					RtlMoveMemory(pPort->CurrentCharSlot,pBlock,TransferLen);/* Optimised Transfer */
				
				pPort->CurrentCharSlot += TransferLen;				/* Update buffer pointer */
				
				if(pPort->CurrentCharSlot > pPort->LastCharSlot)			/* Check for buffer wrap */
					pPort->CurrentCharSlot = pPort->InterruptReadBuffer;

				KeAcquireSpinLock(&pPort->BufferLock, &OldIrql);
				pPort->CharsInInterruptBuffer += TransferLen;			/* Update buffer count */
				KeReleaseSpinLock(&pPort->BufferLock, OldIrql);
				
				pBlock += TransferLen;						/* Update block pointer */
				BlockLen -= (UCHAR)TransferLen;					/* Update block length */
			}
		}

/* Check for 80% full... */

		if((CharsInInterruptBufferWas < pPort->BufferSizePt8)		/* If buffer WAS < 80% */
		&&(pPort->CharsInInterruptBuffer >= pPort->BufferSizePt8)	/* AND is now >= 80% */
		&&(pPort->IsrWaitMask & SERIAL_EV_RX80FULL))				/* AND someone is waiting for this */
		{
			pPort->HistoryMask |= SERIAL_EV_RX80FULL;

			if(pPort->IrpMaskLocation)
			{
				*pPort->IrpMaskLocation = pPort->HistoryMask;
				pPort->IrpMaskLocation = NULL;
				pPort->HistoryMask = 0;
				pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
				KeInsertQueueDpc(&pPort->CommWaitDpc,NULL,NULL);
			}
		}

/* Check for and handle buffer full... */

		if((pPort->CharsInInterruptBuffer >= pPort->BufferSize)			/* If no more room */
		&&(BlockLen)													/* AND more data to queue */
		&&((pPort->RXHolding & (SERIAL_RX_DTR | SERIAL_RX_RTS | SERIAL_RX_XOFF)) == 0))	/* AND NOT flowed off */
		{
			pBlock += BlockLen;				/* Discard remaining data */
			BlockLen = 0;					/* Update block length */
			pPort->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;
			pPort->PerfStats.BufferOverrunErrorCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
			pPort->WmiPerfData.BufferOverrunErrorCount++;
#endif

			if(pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
			{						/* Store error char in last buffer position */
				if(pPort->CurrentCharSlot == pPort->InterruptReadBuffer)
					pPort->InterruptReadBuffer[pPort->BufferSize-1] = pPort->SpecialChars.ErrorChar;
				else	
					pPort->CurrentCharSlot[-1] = pPort->SpecialChars.ErrorChar;
			}

			if(pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) /* Queue error Dpc */
				KeInsertQueueDpc(&pPort->CommErrorDpc, NULL, NULL);
		}

	} /* if(BlockLen) */

/* If the xoff counter is non-zero then decrement it and if zero, complete that irp... */

	if(pPort->CountSinceXoff)
	{
		if(pPort->CountSinceXoff <= (long)(OriginalBlockLen - BlockLen))
		{
			pPort->CurrentXoffIrp->IoStatus.Status = STATUS_SUCCESS;
			pPort->CurrentXoffIrp->IoStatus.Information = 0;
			KeInsertQueueDpc(&pPort->XoffCountCompleteDpc, NULL, NULL);
		}
		else
		{
			pPort->CountSinceXoff -= (OriginalBlockLen - BlockLen);
		}
	}

	pPort->PerfStats.ReceivedCount += (OriginalBlockLen - BlockLen);	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
	pPort->WmiPerfData.ReceivedCount += (OriginalBlockLen - BlockLen);
#endif

	return(OriginalBlockLen - BlockLen);				/* Return amount of data transferred */

} /* SerialPutBlock */

/*****************************************************************************
*************************                            *************************
*************************   SerialTransferReadChar   *************************
*************************                            *************************
******************************************************************************

Prototype:	USHORT	SerialTransferReadChar(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pFrom,IN PUCHAR pTo)

Description:	Copies a character from pFrom to pTo after filtering with:
				Data mask
				NULL stripping
				Wait for any character
				Wait for specific character
				ESCape character

Parameters:		pPort points to the extension for the current channel
				pFrom points to buffer to copy from
				pTo points to buffer to copy to

Returns:		Top byte = amount to adjust "From" buffer
				Bottom byte = amount to adjust "To" buffer

NOTE:	This routine is only called at device level.

*/

USHORT	SerialTransferReadChar(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pFrom,IN PUCHAR pTo)
{
	UCHAR	ReadChar;

/* Check for escape character insertion... */

	if(pPort->InsertEscChar)
	{
		*pTo = SERIAL_LSRMST_ESCAPE;			/* Insert extra escape character */
		pPort->InsertEscChar = FALSE;			/* Reset flag */
		return(0x0001);					/* Update "To" buffer only */
	}

	ReadChar = *pFrom;					/* Get read character */

/* Check for null stripping... */

	if(!ReadChar && (pPort->HandFlow.FlowReplace & SERIAL_NULL_STRIPPING))
		return(0x0100);					/* Update "From" buffer only */

/* Check for waiting events... */

	if(pPort->IsrWaitMask)
	{
		if(pPort->IsrWaitMask & SERIAL_EV_RXCHAR)	/* Wait for any character */
			pPort->HistoryMask |= SERIAL_EV_RXCHAR;

		if((pPort->IsrWaitMask & SERIAL_EV_RXFLAG)	/* Wait for specific character */
		&&(pPort->SpecialChars.EventChar == ReadChar))
			pPort->HistoryMask |= SERIAL_EV_RXFLAG;

		if(pPort->IrpMaskLocation && pPort->HistoryMask)	/* Wake up waiting IRP */
		{
			*pPort->IrpMaskLocation = pPort->HistoryMask;
			pPort->IrpMaskLocation = NULL;
			pPort->HistoryMask = 0;
			pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
			KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
		}
	}

/* Check for escape character in normal data... */

	if(pPort->EscapeChar&&(pPort->EscapeChar==ReadChar))
		pPort->InsertEscChar = TRUE;		/* Set flag to insert extra escape character */

/* Store character... */

	*pTo = ReadChar;					/* Store character */
	return(0x0101);						/* Update both "To" and "From" buffers */

} /* SerialTransferReadChar */


UCHAR
SerialProcessLSR(
    IN PPORT_DEVICE_EXTENSION pPort, UCHAR LineStatus
    )

/*++

Routine Description:

    This routine, which only runs at device level, totally
    processes everything that might have changed in the
    line status register.

Arguments:

    pPort - The serial device extension.

    LineStatus - The line status register.

Return Value:

    The value of the line status register.

--*/

{
    SpxDbgMsg(
        SERDIAG1,
        ("%s: In SerialProcessLSR() for %x. "
        "LineStatus = %x.\n",
		PRODUCT_NAME,
        pPort->pChannel,
        LineStatus)
        );
        
    //
    // We have some sort of data problem in the receive.  For any of these
    // errors we may abort all current reads and writes.
    //
    //
    // If we are inserting the value of the line status into the data stream
    // then we should put the escape character in now.
    //

    if(pPort->EscapeChar) 
	{
		UCHAR EscapeString[3] = {pPort->EscapeChar, SERIAL_LSRMST_LSR_NODATA, LineStatus};

		SerialPutBlock(pPort,EscapeString,3,FALSE);
    }

    if(LineStatus & SERIAL_LSR_OE)		// Hardware Overrun Error? 
	{
		pPort->ErrorWord |= SERIAL_ERROR_OVERRUN;	// Yes 
		pPort->PerfStats.SerialOverrunErrorCount++;	// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
		pPort->WmiPerfData.SerialOverrunErrorCount++;
#endif
	}

    if(LineStatus & SERIAL_LSR_BI) 
	{
        pPort->ErrorWord |= SERIAL_ERROR_BREAK;

        if(pPort->HandFlow.FlowReplace & SERIAL_BREAK_CHAR) 
		    SerialPutBlock(pPort,&pPort->SpecialChars.BreakChar,1,FALSE);
    }
    else
    {
		if(LineStatus & SERIAL_LSR_PE)	// Parity Error ? 
		{
			pPort->ErrorWord |= SERIAL_ERROR_PARITY;	// Yes 
			pPort->PerfStats.ParityErrorCount++;		// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
			pPort->WmiPerfData.ParityErrorCount++;
#endif
		}

		if(LineStatus & SERIAL_LSR_FE)	// Framing Error ? 
		{
			pPort->ErrorWord |= SERIAL_ERROR_FRAMING;	// Yes 
			pPort->PerfStats.FrameErrorCount++;			// Increment counter for performance stats.
#ifdef WMI_SUPPORT 
			pPort->WmiPerfData.FrameErrorCount++;
#endif
		}
    }

    //
    // If the application has requested it, abort all the reads and writes
    // on an error.
    //

    if(pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) 
	{
        KeInsertQueueDpc(&pPort->CommErrorDpc, NULL, NULL);
    }

    //
    // Check to see if we have a wait pending on the comm error events.  If
    // we do then we schedule a DPC to satisfy that wait.
    //

    if(pPort->IsrWaitMask) 
	{
		if((pPort->IsrWaitMask & SERIAL_EV_ERR)
		&&(LineStatus & (SERIAL_LSR_OE | SERIAL_LSR_PE | SERIAL_LSR_FE)))
		{
			pPort->HistoryMask |= SERIAL_EV_ERR;
		}

        if((pPort->IsrWaitMask & SERIAL_EV_BREAK) && (LineStatus & SERIAL_LSR_BI)) 
		{
            pPort->HistoryMask |= SERIAL_EV_BREAK;
        }

        if (pPort->IrpMaskLocation && pPort->HistoryMask) 
		{
            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
 
        }
    }

    return LineStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\spx_iioc.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Dispatch Entry for INTERNAL IOCTLs					*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Internal IOCTLs support the SERENUM					*/
/*					attached serial device enumerator:					*/
/*					IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS				*/
/*					IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS				*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#define FILE_ID	SPX_IIOC_C		// File ID for Event Logging see SPX_DEFS.H for values.



/*****************************************************************************
**********************                                 ***********************
**********************   Spx_SerialInternalIoControl   ***********************
**********************                                 ***********************
******************************************************************************
	
prototype:		NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)

description:	Internal IOCTL dipatch routine.
				These IOCTLs are only issued from know trusted system components such as
				the SERENUM.SYS attached serial device enumerator and the mouse driver:

parameters:		pDevObj points to the device object structure
				pIrp points to the IOCTL Irp packet

returns:		STATUS_SUCCESS

*/

NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
	NTSTATUS				status;
	PIO_STACK_LOCATION		pIrpStack;
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	KIRQL					OldIrql;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Entry\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	if(SerialCompleteIfError(pDevObj, pIrp) != STATUS_SUCCESS)
		return(STATUS_CANCELLED);

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0L;
	status = STATUS_SUCCESS;

	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
	case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
	case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS:
		{
			SERIAL_BASIC_SETTINGS	Basic;
			PSERIAL_BASIC_SETTINGS	pBasic;
			SERIAL_IOCTL_SYNC	S;

			if (pIrpStack->Parameters.DeviceIoControl.IoControlCode 
				== IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS)
			{
          
/* Check the buffer size... */

				if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength 
					< sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

/* Everything is 0 -- timeouts and flow control. */
/* If we add additional features, this zero memory method may not work. */

				RtlZeroMemory(&Basic,sizeof(SERIAL_BASIC_SETTINGS));
				pIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;

/* Save off the old settings... */

				RtlCopyMemory(&pBasic->Timeouts, &pPort->Timeouts, sizeof(SERIAL_TIMEOUTS));
				RtlCopyMemory(&pBasic->HandFlow, &pPort->HandFlow, sizeof(SERIAL_HANDFLOW));

/* Point to our new settings... */

				pBasic = &Basic;
			}
			else
			{
				if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;
			}

			KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);

/* Set the timeouts...	*/

			RtlCopyMemory(&pPort->Timeouts, &pBasic->Timeouts, sizeof(SERIAL_TIMEOUTS));

/* Set flowcontrol... */

			S.pPort = pPort;
			S.Data = &pBasic->HandFlow;
			XXX_SetHandFlow(pPort, &S);		/* Set the handflow for specific hardware */

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

	default:
		status = STATUS_INVALID_PARAMETER;
		break;
	}

	pIrp->IoStatus.Status = status;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Complete\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	IoCompleteRequest(pIrp,0);

	return(status);

} /* Spx_SerialInternalIoControl */
                                                        
/* End of SPX_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\spx_init.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_INIT.C															*
*																						*
*	Creation:		27th September 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	This module contains the code that load the driver.					*
*																						*
****************************************************************************************/


#define FILE_ID	SPX_INIT_C		// File ID for Event Logging see SPX_DEFS.H for values.


// Function Prototypes 
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
// End function prototypes.

// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnload)
#endif

// Gloabal Driver Data
UNICODE_STRING	SavedRegistryPath;

#if DBG
ULONG SpxDebugLevel = 0;		// Debug level for checked build
#endif


//////////////////////////////////////////////////////////////////////////////////////////
//	DriverEntry - Load first and initialises entry points.								//
//////////////////////////////////////////////////////////////////////////////////////////
/*
Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    RegistryPath - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS 
*/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	// Holds status information return by various OS and driver initialization routines.
	NTSTATUS status;

	// We use this to query into the registry as to whether we should break at driver entry.
	RTL_QUERY_REGISTRY_TABLE paramTable[3];
	ULONG zero			= 0;
	ULONG debugLevel	= 0;
	ULONG shouldBreak	= 0;		
	PWCHAR path			= NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	#if DBG
		DbgPrint( "%s: In DriverEntry\n", PRODUCT_NAME);
	#endif


	// Store Registry Path
	SavedRegistryPath.MaximumLength	= RegistryPath->MaximumLength;
	SavedRegistryPath.Length		= RegistryPath->Length;
	SavedRegistryPath.Buffer		= SpxAllocateMem(PagedPool, SavedRegistryPath.MaximumLength);

	if(SavedRegistryPath.Buffer)
	{
		RtlMoveMemory(SavedRegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length);
	
		RtlZeroMemory(&paramTable[0], sizeof(paramTable));
		paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[0].Name = L"BreakOnEntry";
		paramTable[0].EntryContext = &shouldBreak;
		paramTable[0].DefaultType = REG_DWORD;
		paramTable[0].DefaultData = &zero;
		paramTable[0].DefaultLength = sizeof(ULONG);
		paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[1].Name = L"DebugLevel";
		paramTable[1].EntryContext = &debugLevel;
		paramTable[1].DefaultType = REG_DWORD;
		paramTable[1].DefaultData = &zero;
		paramTable[1].DefaultLength = sizeof(ULONG);

		if(!SPX_SUCCESS(status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
														RegistryPath->Buffer, &paramTable[0], 
														NULL, NULL)))
		{
			shouldBreak = 0;
			debugLevel	= 0;
		}

	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;


 	#if DBG
		SpxDebugLevel = debugLevel;	
	//	SpxDebugLevel = (ULONG)-1;			// Prints all debug messages

	//	shouldBreak = 1;	// HARD CODED BREAKPOINT WITH CHECKED BUILD !!!
	#endif


	if(shouldBreak)
	{
		DbgBreakPoint();	// Break Debugger.
	}


	if(SPX_SUCCESS(status))
	{
		// Initialize the Driver Object with driver's entry points
		DriverObject->DriverUnload									= DriverUnload;
		DriverObject->DriverExtension->AddDevice					= Spx_AddDevice;
		DriverObject->MajorFunction[IRP_MJ_PNP]						= Spx_DispatchPnp;
		DriverObject->MajorFunction[IRP_MJ_POWER]					= Spx_DispatchPower;
		DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]			= Spx_Flush;
		DriverObject->MajorFunction[IRP_MJ_WRITE]					= Spx_Write;
		DriverObject->MajorFunction[IRP_MJ_READ]					= Spx_Read;
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]			= Spx_IoControl;
		DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]	= Spx_InternalIoControl;
		DriverObject->MajorFunction[IRP_MJ_CREATE]					= Spx_CreateOpen;
		DriverObject->MajorFunction[IRP_MJ_CLOSE]					= Spx_Close;
		DriverObject->MajorFunction[IRP_MJ_CLEANUP]					= Spx_Cleanup;
		DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]		= Spx_QueryInformationFile;
		DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]			= Spx_SetInformationFile;
#ifdef WMI_SUPPORT
		DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]			= Spx_DispatchSystemControl;
#endif
		
	}
	else
	{
		// Free
		if(SavedRegistryPath.Buffer)
		{
			SpxFreeMem(SavedRegistryPath.Buffer);
			SavedRegistryPath.Buffer = NULL;
		}
	}


	return(status);

}	// DriverEntry 




//////////////////////////////////////////////////////////////////////////////////////////
//	DriverUnload - Called as driver unloads.											
//////////////////////////////////////////////////////////////////////////////////////////
VOID 
DriverUnload(IN PDRIVER_OBJECT pDriverObject)
/*++

Routine Description:

    This routine cleans up all of the resources allocated in DriverEntry.

Arguments:

    pDriverObject - Pointer to the driver object controling all of the
					devices.

Return Value:

    None.

--*/
{
	PAGED_CODE();
	
	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering DriverUnload\n", PRODUCT_NAME));

	// All Device Objects must have been deleted by now.
    ASSERT (pDriverObject->DeviceObject == NULL);

	// Free
	if(SavedRegistryPath.Buffer)
	{
		SpxFreeMem(SavedRegistryPath.Buffer);
		SavedRegistryPath.Buffer = NULL;
	}


	return;
}


// End of SPX_INIT.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\si2_z280.c ===
/* SI2_Z280.C Version, Bootstrap and Download Code Arrays... */

char *si2_z280_ident = "%W%";

/* SI2_Z280 embedded version... 

	Copyright (c) Specialix Research Ltd 1988-1998
	Z280 Download Code Version 1.43
	

*/

unsigned char si2_z280_download[] =
{
	0x00,0xC3,0x86,0x00,0x02,0x00,0x08,0x01,	/* 0000: ...... */
	0x00,0x00,0x88,0x18,0x00,0x00,0x8C,0x18,	/* 0008: ...... */
	0x00,0x00,0xF6,0x1A,0x00,0x00,0xC5,0x04,	/* 0010: ...... */
	0x02,0x00,0x08,0x01,0x02,0x00,0x08,0x01,	/* 0018: ........ */
	0x02,0x00,0x08,0x01,0x02,0x00,0x08,0x01,	/* 0020: ........ */
	0x02,0x00,0x08,0x01,0x00,0x00,0xED,0x0F,	/* 0028: ....... */
	0x00,0x00,0x0C,0x10,0x02,0x00,0x08,0x01,	/* 0030: ........ */
	0x02,0x00,0x08,0x01,0x00,0x00,0x00,0x00,	/* 0038: ........ */
	0x20,0x00,0x00,0x01,0x00,0x3C,0x00,0x00,	/* 0040:  ....<.. */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0048: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0050: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0058: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0060: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0068: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0070: ........ */
	0x00,0x3A,0x47,0x00,0xFE,0x00,0xC2,0x08,	/* 0078: .:G... */
	0x01,0xDD,0x3E,0x48,0x00,0x01,0x31,0xBF,	/* 0080: .>H..1 */
	0x00,0xC3,0x2A,0x13,0xFF,0xFF,0xFF,0xFF,	/* 0088: .*. */
	0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xCC,	/* 0090: ...... */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,	/* 0098:  */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,	/* 00A0:  */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,	/* 00A8:  */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,	/* 00B0:  */
	0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x3A,	/* 00B8: : */
	0x41,0x00,0xFE,0x00,0xC2,0x2A,0x13,0x21,	/* 00C0: A..*.! */
	0x00,0x08,0x0E,0xF0,0xED,0xBF,0x00,0x00,	/* 00C8: ..... */
	0x00,0x21,0x40,0x00,0x0E,0x12,0xED,0x6E,	/* 00D0: .!@...n */
	0x3A,0x92,0x00,0xFE,0x01,0x20,0x05,0x21,	/* 00D8: :.. .! */
	0xC2,0x05,0x18,0x03,0x21,0x8C,0x18,0x7D,	/* 00E0: ...!.} */
	0xE6,0xF0,0x6F,0x3E,0x00,0x46,0x23,0x3D,	/* 00E8: o>.F#= */
	0xFE,0x00,0x20,0xF9,0x21,0x80,0x00,0x0E,	/* 00F0: . !.. */
	0x12,0xED,0x6E,0xDD,0x3E,0x47,0x00,0x01,	/* 00F8: .n>G.. */
	0xCD,0x15,0x01,0x00,0x18,0xFE,0x00,0x00,	/* 0100: ...... */
	0xDD,0xD1,0x06,0x01,0xED,0x55,0xDD,0x3E,	/* 0108: ..U> */
	0x00,0x00,0xFE,0x76,0xC9,0xCD,0xF9,0x01,	/* 0110: ..v. */
	0xFE,0x01,0x20,0x03,0xCD,0x89,0x04,0xC9,	/* 0118: . .. */
	0xE0,0x81,0x80,0x80,0x00,0x00,0x00,0x00,	/* 0120: .... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0128: ........ */
	0x8C,0x00,0xF0,0xD0,0x00,0xF0,0x00,0xC0,	/* 0130: ... */
	0x00,0x00,0xF0,0xD0,0x00,0xF0,0x00,0xC0,	/* 0138: .... */
	0x00,0x00,0x21,0x0D,0x00,0x0E,0xFF,0xED,	/* 0140: ..!... */
	0x6E,0x21,0xF8,0x2F,0x11,0x0E,0x80,0x01,	/* 0148: n!.... */
	0x08,0x00,0xED,0xB0,0x2A,0x43,0x00,0x0E,	/* 0150: ..*C.. */
	0xFF,0xED,0x6E,0xDD,0x3E,0x16,0x80,0x00,	/* 0158: n>.. */
	0xC9,0x79,0xFE,0x00,0x28,0x2A,0xED,0x2D,	/* 0160: y.(*- */
	0xA0,0xFF,0xED,0x2A,0x00,0x00,0x3A,0x2F,	/* 0168: *..:. */
	0x01,0xFE,0x40,0x20,0x07,0xFD,0xED,0xF6,	/* 0170: .@ . */
	0xA0,0x18,0x18,0x05,0xFD,0xED,0xF6,0xA0,	/* 0178: ... */
	0x02,0xDD,0x2A,0x24,0x01,0xED,0x2D,0x00,	/* 0180: .*$.-. */
	0x00,0xE5,0xDD,0xE1,0xDD,0x22,0x24,0x01,	/* 0188: ."$. */
	0x78,0x32,0x2F,0x01,0xED,0x2A,0x00,0x00,	/* 0190: x2..*.. */
	0xDD,0x01,0x00,0x00,0xDD,0x73,0x08,0xDD,	/* 0198: ...s. */
	0x36,0x1C,0x00,0xDD,0x36,0x1D,0x00,0x7B,	/* 01A0: 6..6..{ */
	0xE6,0x0F,0xDD,0x77,0x02,0xDD,0x71,0x03,	/* 01A8: .w.q. */
	0xFD,0xED,0x2D,0x06,0x00,0x7B,0xE6,0xE0,	/* 01B0: -..{ */
	0xFE,0x00,0x20,0x08,0xDD,0x36,0x04,0x00,	/* 01B8: . .6.. */
	0xFD,0x36,0x40,0xFF,0xDD,0xE5,0xFD,0x7E,	/* 01C0: 6@~ */
	0x7F,0xDD,0x77,0x1E,0x3E,0x08,0xED,0x2A,	/* 01C8: w.>.* */
	0x0A,0x00,0xDD,0xED,0x2A,0x60,0x01,0xDD,	/* 01D0: ..*`. */
	0xE5,0xDD,0xC1,0x3D,0x28,0x0C,0xDD,0xED,	/* 01D8: =(. */
	0x2A,0x00,0x03,0xFD,0xED,0xF6,0x02,0x00,	/* 01E0: *.... */
	0x18,0xED,0xDD,0xE1,0xED,0x2A,0x00,0x00,	/* 01E8: .*.. */
	0xFD,0xED,0xF6,0x60,0x01,0xE5,0xDD,0xE1,	/* 01F0: `. */
	0xC9,0x21,0x40,0x00,0x5E,0xDD,0x11,0x02,	/* 01F8: !@.^.. */
	0x80,0xFF,0xFF,0xDD,0x3E,0x06,0x80,0x01,	/* 0200: >.. */
	0xDD,0x3E,0x82,0x80,0x00,0xDD,0x21,0x80,	/* 0208: >.! */
	0x80,0xDD,0x22,0x24,0x01,0xFD,0x21,0x00,	/* 0210: "$.!. */
	0x70,0xFD,0x22,0x28,0x01,0x0E,0x00,0x16,	/* 0218: p"(.... */
	0x01,0xE5,0x2A,0x30,0x01,0x7E,0xDD,0x13,	/* 0220: .*0.~. */
	0x30,0x01,0xE1,0xFE,0xFF,0xCA,0x76,0x03,	/* 0228: 0.v. */
	0x5F,0xFE,0x04,0x28,0x10,0xFE,0x24,0x28,	/* 0230: _.(.$( */
	0x0C,0x06,0x08,0xDD,0x3E,0x2E,0x01,0x08,	/* 0238: ...>... */
	0xCD,0x61,0x01,0x18,0x0C,0x06,0x04,0xDD,	/* 0240: a..... */
	0x3E,0x2E,0x01,0x04,0xCD,0x61,0x01,0x18,	/* 0248: >...a.. */
	0x00,0x21,0xA0,0x02,0xDD,0x0E,0x00,0x2B,	/* 0250: .!...+ */
	0xFD,0xED,0xF7,0xA0,0xFF,0x20,0xF5,0xFD,	/* 0258:   */
	0xED,0x2D,0xA2,0xFF,0xDD,0x36,0xC2,0xFF,	/* 0260: -6 */
	0x7B,0xE6,0xE0,0xDD,0x77,0xC4,0xFE,0x00,	/* 0268: {w. */
	0x20,0x2A,0xED,0x32,0x00,0x00,0xCB,0x9D,	/* 0270:  *2.. */
	0xFD,0x36,0x02,0x0A,0xFD,0x1E,0x04,0x00,	/* 0278: 6..... */
	0xE0,0xFD,0x1E,0x05,0x00,0x00,0xCD,0xD6,	/* 0280: .... */
	0x1D,0xFD,0x7B,0x0E,0x00,0xFD,0x1E,0x0D,	/* 0288: .{.... */
	0x00,0x00,0xFD,0x36,0x02,0x90,0xDD,0x36,	/* 0290: ..6.6 */
	0xA6,0x01,0x18,0x00,0xDD,0x36,0xAE,0x10,	/* 0298: ...6. */
	0xDD,0x36,0xBF,0x01,0xDD,0x72,0xAF,0x2A,	/* 02A0: 6.r* */
	0x24,0x01,0xED,0x2D,0xA4,0xFF,0x3A,0x2E,	/* 02A8: $.-:. */
	0x01,0x90,0xDD,0x77,0xA7,0xFE,0x04,0xFA,	/* 02B0: .w. */
	0xC9,0x02,0xFD,0x7E,0x7F,0xE6,0xF0,0xCB,	/* 02B8: .~ */
	0x3F,0xCB,0x3F,0xCB,0x3F,0xCB,0x3F,0x18,	/* 02C0: ????. */
	0x05,0xFD,0x7E,0x7F,0xE6,0x0F,0xDD,0x77,	/* 02C8: .~.w */
	0xC4,0x21,0x32,0x01,0xC5,0x4F,0xE6,0x07,	/* 02D0: !2.O. */
	0xFE,0x05,0x20,0x17,0x78,0xFE,0x08,0x28,	/* 02D8: . .x.( */
	0x04,0xFE,0x04,0x20,0x0E,0xDD,0x36,0xC7,	/* 02E0: .. .6 */
	0x01,0x3E,0x08,0x90,0xFD,0x77,0x7F,0xFD,	/* 02E8: .>.w */
	0x36,0x4B,0x80,0x06,0x00,0xED,0xC6,0x7E,	/* 02F0: 6K..~ */
	0xDD,0x77,0xC6,0xC1,0x05,0x20,0x23,0x2A,	/* 02F8: w. #* */
	0x28,0x01,0xFD,0xED,0xF6,0x80,0x00,0x22,	/* 0300: (.." */
	0x28,0x01,0xFD,0x2A,0x28,0x01,0x2A,0x20,	/* 0308: (.*(.*  */
	0x01,0xED,0x2D,0xA0,0xFF,0xED,0x2A,0x00,	/* 0310: .-*. */
	0x00,0xFD,0xED,0xF6,0x00,0x04,0x0C,0xC3,	/* 0318: .... */
	0x1F,0x02,0xED,0x2A,0x00,0x00,0xFD,0xED,	/* 0320: ..*.. */
	0xF6,0x00,0x03,0xED,0x2D,0xA0,0xFF,0xE5,	/* 0328: ..- */
	0xDD,0xE1,0xED,0x32,0x00,0x00,0x3A,0x2E,	/* 0330: 2..:. */
	0x01,0xFE,0x08,0x20,0x14,0x7B,0xFE,0x28,	/* 0338: .. .{( */
	0xCA,0x51,0x02,0xFE,0x48,0xCA,0x51,0x02,	/* 0340: Q.HQ. */
	0xFD,0xED,0xF6,0x08,0x00,0xCB,0x02,0x18,	/* 0348: .... */
	0x1F,0x7B,0xFE,0x24,0xCA,0x51,0x02,0x78,	/* 0350: .{$Q.x */
	0xFE,0x02,0x20,0x09,0xFD,0xED,0xF6,0x08,	/* 0358: . .. */
	0x00,0xCB,0x02,0x18,0x0B,0xFD,0xED,0xF6,	/* 0360: .... */
	0x18,0x00,0xCB,0x02,0xCB,0x02,0xCB,0x02,	/* 0368: ..... */
	0xE5,0xFD,0xE1,0xC3,0x51,0x02,0xCD,0x42,	/* 0370: Q.B */
	0x01,0xDD,0x11,0x04,0x80,0x42,0x01,0xDD,	/* 0378: ...B. */
	0x3E,0x00,0x80,0x01,0x3E,0x01,0xC9,0xFD,	/* 0380: >..>. */
	0xED,0x2C,0xA2,0xFF,0xCD,0x8D,0x0E,0x18,	/* 0388: ,.. */
	0x05,0xFD,0xED,0x2C,0xA2,0xFF,0xCD,0xE4,	/* 0390: ., */
	0x0D,0x26,0x00,0xC3,0xF1,0x05,0xFD,0xED,	/* 0398: .&.. */
	0x2C,0xA2,0xFF,0xCD,0x8D,0x0E,0x26,0x00,	/* 03A0: ,.&. */
	0xC3,0xF1,0x05,0xFD,0xED,0x2C,0xA2,0xFF,	/* 03A8: ., */
	0xCD,0x11,0x0E,0x26,0x00,0xC3,0xF1,0x05,	/* 03B0: ..&.. */
	0xFD,0xED,0x2C,0xA2,0xFF,0xCD,0x2E,0x0E,	/* 03B8: ,.. */
	0x26,0x00,0xC3,0xF1,0x05,0xFD,0xED,0x2C,	/* 03C0: &.., */
	0xA2,0xFF,0xFD,0x36,0x02,0x60,0xDD,0x36,	/* 03C8: 6.`6 */
	0xAE,0x12,0xDD,0x3E,0xC3,0x05,0x01,0x26,	/* 03D0: .>..& */
	0x00,0xC3,0xF1,0x05,0xFD,0xED,0x2C,0xA2,	/* 03D8: .., */
	0xFF,0xFD,0x36,0x02,0x75,0xDD,0x36,0xAE,	/* 03E0: 6.u6 */
	0x00,0xDD,0x3E,0xC3,0x05,0x01,0x26,0x00,	/* 03E8: .>..&. */
	0xC3,0xF1,0x05,0x26,0x00,0xC3,0xF1,0x05,	/* 03F0: .&.. */
	0xFD,0xED,0x2C,0xA2,0xFF,0xDD,0x7E,0xAD,	/* 03F8: ,~ */
	0xDD,0x77,0xAC,0xDD,0x7E,0xB5,0xE6,0x10,	/* 0400: w~. */
	0x28,0x25,0xED,0x32,0x00,0x00,0xCB,0x5D,	/* 0408: (%2..] */
	0x28,0x0A,0xCB,0x9D,0xFD,0x7B,0x0D,0x00,	/* 0410: (.{.. */
	0xCB,0x2F,0x18,0x06,0xFD,0x7B,0x0D,0x00,	/* 0418: ...{.. */
	0xCB,0x27,0x2F,0xE6,0x02,0x20,0x08,0xFD,	/* 0420: '.. . */
	0x36,0x02,0x30,0xFD,0x36,0x02,0x04,0xDD,	/* 0428: 6.06.. */
	0x7E,0xA8,0xE6,0x06,0xFE,0x06,0x20,0x0E,	/* 0430: ~.. . */
	0xDD,0xCB,0xA8,0x96,0xDD,0xCB,0xA9,0x4E,	/* 0438: N */
	0x20,0x04,0xDD,0xCB,0xA3,0xA6,0xDD,0x36,	/* 0440:  .6 */
	0xAE,0x00,0xDD,0x3E,0xC3,0x05,0x01,0x26,	/* 0448: .>..& */
	0x00,0xC3,0xF1,0x05,0xFD,0xED,0x2C,0xA2,	/* 0450: .., */
	0xFF,0xDD,0x7E,0xAB,0xDD,0x77,0xAA,0xDD,	/* 0458: ~w */
	0x36,0xAE,0x00,0xDD,0x3E,0xC3,0x05,0x01,	/* 0460: 6.>.. */
	0x26,0x00,0xC3,0xF1,0x05,0xDD,0xCB,0xA8,	/* 0468: &.. */
	0x4E,0x28,0x08,0xDD,0xCB,0xA8,0xD6,0xDD,	/* 0470: N(. */
	0xCB,0xA3,0xE6,0xDD,0x36,0xAE,0x00,0xDD,	/* 0478: 6. */
	0x3E,0xC3,0x05,0x01,0x26,0x00,0xC3,0xF1,	/* 0480: >..&. */
	0x05,0xDD,0x2A,0x20,0x01,0x21,0xFE,0x00,	/* 0488: .* .!. */
	0x0E,0x08,0xED,0x6E,0x3E,0x28,0xD3,0xE0,	/* 0490: ..n>( */
	0x2A,0x02,0x80,0x01,0xE2,0x00,0xED,0xBF,	/* 0498: *... */
	0x3E,0xE0,0xD3,0xE1,0x3A,0x06,0x80,0x32,	/* 04A0: >:.2 */
	0xC2,0x04,0x21,0xFF,0x00,0x0E,0x08,0xED,	/* 04A8: .!... */
	0x6E,0x26,0x00,0x3A,0x93,0x00,0xFE,0x01,	/* 04B0: n&.:.. */
	0xC2,0xF6,0x05,0xD9,0x26,0x00,0xD9,0xC3,	/* 04B8: .&. */
	0x12,0x0D,0x00,0x00,0x00,0xDD,0xD1,0xC3,	/* 04C0: ..... */
	0x04,0xF5,0xC5,0xE5,0xDD,0xE5,0xFD,0xE5,	/* 04C8: . */
	0x3A,0x16,0x80,0xFE,0x01,0x20,0x08,0xCD,	/* 04D0: :.. . */
	0x42,0x01,0xDD,0x3E,0xC3,0x05,0x01,0x3A,	/* 04D8: B.>..: */
	0x93,0x00,0xFE,0x01,0x28,0x2C,0xDD,0x21,	/* 04E0: ..(,! */
	0xE0,0x81,0x18,0x10,0xDD,0xED,0x2C,0xA0,	/* 04E8: .., */
	0xFF,0xED,0x2A,0x00,0x00,0xFD,0xED,0xF7,	/* 04F0: *.. */
	0xE0,0x81,0x28,0x16,0xDD,0x7E,0xAE,0xFE,	/* 04F8: (.~ */
	0x00,0x20,0xE9,0xFD,0xED,0x2C,0xA2,0xFF,	/* 0500: . , */
	0xDD,0x46,0xA9,0xCB,0x68,0x28,0xDD,0xC3,	/* 0508: Fh( */
	0x72,0x08,0x21,0xFE,0x00,0x0E,0x08,0xED,	/* 0510: r.!... */
	0x6E,0x2A,0x02,0x80,0x01,0xE2,0x00,0xED,	/* 0518: n*... */
	0xBF,0x3E,0x00,0xD3,0xE1,0x3E,0xE0,0xD3,	/* 0520: >.> */
	0xE1,0x3A,0x93,0x00,0xFE,0x01,0x28,0x03,	/* 0528: :..(. */
	0xED,0x7F,0x01,0xDD,0x13,0x0A,0x80,0xDD,	/* 0530: ... */
	0x3C,0x0C,0x80,0x3A,0xC3,0x05,0xFE,0x00,	/* 0538: <.:.. */
	0x20,0x0E,0x3A,0xC2,0x05,0xFE,0x00,0x28,	/* 0540:  .:..( */
	0x27,0x3A,0xC2,0x04,0xFE,0x00,0x20,0x20,	/* 0548: ':..   */
	0xDD,0x3E,0x01,0xF0,0x01,0xDD,0x3E,0xC2,	/* 0550: >..> */
	0x05,0x00,0x3A,0x08,0x80,0xFE,0x01,0x28,	/* 0558: ..:..( */
	0x0A,0xDD,0x3E,0x0C,0x80,0x00,0xDD,0x3E,	/* 0560: .>..> */
	0x08,0x80,0x01,0xDD,0x3E,0xC3,0x05,0x00,	/* 0568: ..>.. */
	0xF3,0x3A,0xC2,0x04,0xFE,0x00,0x20,0x06,	/* 0570: :.. . */
	0x3A,0x06,0x80,0x32,0xC2,0x04,0xDD,0x3D,	/* 0578: :.2.= */
	0xC2,0x04,0x21,0xFF,0x00,0x0E,0x08,0xED,	/* 0580: .!... */
	0x6E,0xFD,0xE1,0xDD,0xE1,0xE1,0xC1,0xF1,	/* 0588: n */
	0xED,0x55,0xC4,0x05,0x9E,0x03,0x87,0x03,	/* 0590: U... */
	0x91,0x03,0x9E,0x03,0xAB,0x03,0xC5,0x03,	/* 0598: .... */
	0xDC,0x03,0xF3,0x03,0xF3,0x03,0xB8,0x03,	/* 05A0: .... */
	0x2F,0x04,0xF8,0x03,0x54,0x04,0x6D,0x04,	/* 05A8: ...T.m. */
	0xF3,0x03,0xF3,0x03,0xF3,0x03,0x29,0x10,	/* 05B0: ...). */
	0xFD,0x10,0xF3,0x03,0xF3,0x03,0xC7,0x11,	/* 05B8: .... */
	0x29,0x10,0x00,0x00,0xFD,0xED,0x2C,0xA2,	/* 05C0: )..., */
	0xFF,0xFD,0x4C,0xFD,0x5E,0x01,0xCB,0x61,	/* 05C8: L^.a */
	0x20,0x38,0xCB,0x53,0x28,0x17,0xDD,0x6E,	/* 05D0:  8S(.n */
	0xAC,0xDD,0x7E,0xAD,0x95,0x28,0x0E,0xE6,	/* 05D8: ~(. */
	0x3F,0xCA,0x27,0x07,0xDD,0x79,0xFD,0x77,	/* 05E0: ?'.yw */
	0x03,0x2C,0xDD,0x75,0xAC,0xCB,0x43,0x20,	/* 05E8: .,uC  */
	0x52,0xDD,0x7E,0xA1,0xDD,0x67,0xDD,0x7E,	/* 05F0: R~g~ */
	0xAE,0xFE,0x00,0x28,0xC7,0xFE,0x10,0x28,	/* 05F8: .(.( */
	0xF0,0x6F,0xFD,0xED,0xF6,0x92,0x05,0xED,	/* 0600: o. */
	0x26,0xE9,0xDD,0x4E,0xA8,0xDD,0x46,0xA9,	/* 0608: &NF */
	0xCB,0x53,0x28,0x25,0xCB,0x71,0xC2,0xDC,	/* 0610: S(%q */
	0x06,0xCB,0x51,0x20,0x1C,0xDD,0x6E,0xAC,	/* 0618: .Q .n */
	0xDD,0x7E,0xAD,0x95,0x28,0x13,0xE6,0x3F,	/* 0620: ~(.? */
	0xCA,0x00,0x07,0xDD,0x79,0xFE,0x0A,0xCA,	/* 0628: ..y. */
	0xE3,0x06,0xFD,0x77,0x03,0x2C,0xDD,0x75,	/* 0630: .w.,u */
	0xAC,0xCB,0x43,0x20,0x0C,0xCB,0x61,0x20,	/* 0638: C .a  */
	0x6A,0x18,0xAE,0xDD,0x4E,0xA8,0xDD,0x46,	/* 0640: j.NF */
	0xA9,0xFD,0x36,0x02,0x40,0xFD,0x7E,0x03,	/* 0648: 6.@~. */
	0xDD,0xA6,0xC3,0xFE,0x00,0xCA,0x10,0x08,	/* 0650: ... */
	0xCB,0x49,0x20,0x34,0x08,0xDD,0x6E,0xAA,	/* 0658: I 4.n */
	0x7D,0x3C,0xDD,0x96,0xAB,0xCB,0x7F,0x28,	/* 0660: }<( */
	0x05,0xFE,0xFE,0xF2,0xED,0x08,0x08,0x26,	/* 0668: ...& */
	0x01,0xCB,0x78,0xC2,0x2F,0x08,0xED,0x0B,	/* 0670: .x... */
	0x26,0x00,0x2C,0xDD,0x75,0xAA,0xDD,0x3E,	/* 0678: &.,u> */
	0xC2,0x05,0x01,0xCB,0x59,0xCA,0xED,0x08,	/* 0680: ..Y. */
	0x08,0xFE,0xC0,0xCA,0x96,0x07,0x18,0x23,	/* 0688: ...# */
	0xCB,0x41,0xCA,0xE6,0x07,0xCB,0x51,0xC2,	/* 0690: A.Q */
	0xEC,0x07,0xDD,0xBE,0xB1,0x20,0xBD,0xCB,	/* 0698: .  */
	0xD1,0xDD,0xCB,0xA3,0xE6,0xDD,0x71,0xA8,	/* 06A0: q */
	0xC3,0xED,0x08,0xDD,0x6E,0xAA,0x7D,0x3C,	/* 06A8: .n}< */
	0xDD,0x96,0xAB,0xCB,0x7F,0xC2,0xED,0x08,	/* 06B0: . */
	0xFE,0x40,0xF2,0xED,0x08,0xCB,0x79,0xC2,	/* 06B8: @.y */
	0xC2,0x07,0xCB,0x69,0xCA,0xED,0x08,0xCB,	/* 06C0: .i. */
	0xA1,0xCB,0xF1,0xDD,0x71,0xA8,0xDD,0xCB,	/* 06C8: q */
	0xB4,0x7E,0xCA,0xED,0x08,0xFD,0x36,0x02,	/* 06D0: ~.6. */
	0x80,0xC3,0xED,0x08,0xCB,0x79,0xC2,0x7E,	/* 06D8: .y~ */
	0x07,0x18,0x6B,0xCB,0x50,0xCA,0x32,0x06,	/* 06E0: ..kP2. */
	0xCB,0x40,0x20,0x0C,0xFD,0x36,0x03,0x0D,	/* 06E8: @ .6.. */
	0xCB,0xC0,0xDD,0x70,0xA9,0xC3,0x39,0x06,	/* 06F0: p9. */
	0xCB,0x80,0xDD,0x70,0xA9,0xC3,0x32,0x06,	/* 06F8: p2. */
	0xDD,0x7E,0xAD,0x95,0xFE,0x40,0x20,0x12,	/* 0700: ~@ . */
	0xCB,0x58,0xCA,0x2B,0x06,0xCB,0x98,0xDD,	/* 0708: X+. */
	0x70,0xA9,0xDD,0x3E,0xC3,0x05,0x01,0xC3,	/* 0710: p>.. */
	0x2B,0x06,0xFE,0xC0,0xC2,0x2B,0x06,0xCB,	/* 0718: +.+. */
	0xD8,0xDD,0x70,0xA9,0xC3,0x2B,0x06,0xDD,	/* 0720: p+. */
	0x7E,0xAD,0x95,0xFE,0x40,0x20,0x13,0xDD,	/* 0728: ~@ . */
	0xCB,0xA9,0x5E,0xCA,0xE4,0x05,0xDD,0xCB,	/* 0730: ^. */
	0xA9,0x9E,0xDD,0x3E,0xC3,0x05,0x01,0xC3,	/* 0738: >.. */
	0xE4,0x05,0xFE,0xC0,0xC2,0xE4,0x05,0xDD,	/* 0740: .. */
	0xCB,0xA9,0xDE,0xC3,0xE4,0x05,0xDD,0xCB,	/* 0748: . */
	0xBA,0x5E,0x28,0x06,0xDD,0x56,0xB2,0xFD,	/* 0750: ^(.V */
	0x72,0x03,0xDD,0xCB,0xB4,0x7E,0x28,0x04,	/* 0758: r.~(. */
	0xFD,0x36,0x02,0x80,0xCB,0xB1,0xCB,0xA9,	/* 0760: 6. */
	0xCB,0xA1,0xDD,0x71,0xA8,0xCB,0x48,0xC2,	/* 0768: qH */
	0x39,0x06,0xCB,0x51,0xC2,0x39,0x06,0xDD,	/* 0770: 9.Q9. */
	0xCB,0xA3,0xA6,0xC3,0x39,0x06,0xDD,0xCB,	/* 0778: 9. */
	0xBA,0x5E,0x28,0x06,0xDD,0x56,0xB3,0xFD,	/* 0780: ^(.V */
	0x72,0x03,0xCB,0xE9,0xCB,0xB9,0xCB,0xB1,	/* 0788: r. */
	0xDD,0x71,0xA8,0xC3,0x39,0x06,0xCB,0x69,	/* 0790: q9.i */
	0x20,0x0F,0xCB,0xF9,0xCB,0xF1,0xCB,0xE1,	/* 0798:  . */
	0xDD,0xCB,0xA3,0xE6,0xDD,0x71,0xA8,0x18,	/* 07A0: q. */
	0x02,0xCB,0xB1,0xDD,0xCB,0xB4,0x7E,0xCA,	/* 07A8: .~ */
	0xED,0x08,0xFD,0x36,0x02,0x90,0xCB,0xE1,	/* 07B0: .6. */
	0xDD,0xCB,0xA3,0xE6,0xDD,0x71,0xA8,0xC3,	/* 07B8: q */
	0xED,0x08,0xCB,0xB9,0xCB,0xB1,0xCB,0xA1,	/* 07C0: . */
	0xDD,0x71,0xA8,0xDD,0xCB,0xB4,0x7E,0x28,	/* 07C8: q~( */
	0x04,0xFD,0x36,0x02,0x80,0xCB,0x48,0xC2,	/* 07D0: .6.H */
	0xED,0x08,0xCB,0x51,0xC2,0xED,0x08,0xDD,	/* 07D8: .Q. */
	0xCB,0xA3,0xA6,0xC3,0xED,0x08,0xDD,0xBE,	/* 07E0: . */
	0xB0,0xC2,0x9A,0x06,0xCB,0x91,0xCB,0x48,	/* 07E8: .H */
	0x20,0x0C,0xCB,0x61,0x20,0x08,0xCB,0x71,	/* 07F0:  .a .q */
	0x20,0x04,0xDD,0xCB,0xA3,0xA6,0xDD,0x71,	/* 07F8:  .q */
	0xA8,0xDD,0xBE,0xB0,0xCA,0xED,0x08,0xDD,	/* 0800: . */
	0xBE,0xB1,0xCA,0xED,0x08,0xC3,0x5C,0x06,	/* 0808: .\. */
	0xCB,0x7B,0xCA,0x58,0x06,0xDD,0xCB,0xC1,	/* 0810: {X. */
	0x46,0xC2,0xED,0x08,0xDD,0xCB,0xC1,0x4E,	/* 0818: F.N */
	0xCA,0x58,0x06,0xDD,0xCB,0xB9,0xC6,0xDD,	/* 0820: X. */
	0x3E,0xC3,0x05,0x01,0xC3,0xED,0x08,0x57,	/* 0828: >...W */
	0x7B,0xE6,0x70,0x7A,0x20,0x0E,0xDD,0xCB,	/* 0830: {pz . */
	0xC1,0x56,0xCA,0x76,0x06,0xFE,0xFF,0x28,	/* 0838: Vv.( */
	0x27,0xC3,0x76,0x06,0xDD,0xCB,0xC1,0x5E,	/* 0840: 'v.^ */
	0x28,0x05,0x26,0x00,0xC3,0xED,0x08,0xDD,	/* 0848: (.&.. */
	0xCB,0xC1,0x56,0x20,0x06,0xDD,0x0E,0x00,	/* 0850: V ... */
	0xC3,0x78,0x06,0xDD,0x0E,0xFF,0x2C,0xDD,	/* 0858: x.., */
	0x0E,0x00,0x2C,0xED,0x0B,0xC3,0x78,0x06,	/* 0860: ..,.x. */
	0xDD,0x0E,0xFF,0x2C,0xDD,0x0E,0xFF,0xC3,	/* 0868: .,. */
	0x78,0x06,0xED,0x32,0x00,0x00,0xCB,0x5D,	/* 0870: x.2..] */
	0x28,0x0A,0xCB,0x9D,0xFD,0x7B,0x0D,0x00,	/* 0878: (.{.. */
	0xCB,0x2F,0x18,0x06,0xFD,0x7B,0x0D,0x00,	/* 0880: ...{.. */
	0xCB,0x27,0x26,0x00,0x2F,0xCB,0x60,0x20,	/* 0888: '&..`  */
	0x04,0xE6,0x26,0x18,0x02,0xE6,0x24,0xDD,	/* 0890: .&..$ */
	0xBE,0xB8,0xCA,0xEC,0x04,0xF5,0xDD,0xAE,	/* 0898: . */
	0xB8,0xE6,0x04,0x20,0x10,0xF1,0xDD,0x77,	/* 08A0: . .w */
	0xB8,0xDD,0xCB,0xB9,0xCE,0xDD,0x3E,0xC3,	/* 08A8: > */
	0x05,0x01,0xC3,0xEC,0x04,0xDD,0xCB,0xB5,	/* 08B0: ... */
	0x66,0x28,0xEA,0xF1,0xF5,0xFD,0x36,0x02,	/* 08B8: f(6. */
	0x10,0xFD,0x36,0x02,0x30,0xFD,0x36,0x02,	/* 08C0: .6.06. */
	0x20,0xCB,0x57,0x28,0x0F,0xFD,0x7E,0x00,	/* 08C8:  W(.~. */
	0xDD,0x7E,0xB5,0xFD,0x77,0x00,0xFD,0x36,	/* 08D0: ~w.6 */
	0x02,0x05,0x18,0xC9,0xFD,0x7E,0x00,0xDD,	/* 08D8: ...~. */
	0x7E,0xB5,0xE6,0xEF,0xFD,0x77,0x00,0xFD,	/* 08E0: ~w. */
	0x36,0x02,0x05,0x18,0xB8,0xFD,0x5E,0x01,	/* 08E8: 6...^. */
	0xC3,0xED,0x05,0xFD,0xED,0x2C,0xA2,0xFF,	/* 08F0: ., */
	0xDD,0x7E,0xA7,0xFD,0x77,0x7F,0xE6,0x03,	/* 08F8: ~w. */
	0xFD,0x77,0x68,0xC9,0xF5,0xC5,0xDD,0x7E,	/* 0900: wh~ */
	0xC6,0xFD,0x46,0x6C,0xA0,0x47,0x0E,0x00,	/* 0908: FlG.. */
	0xCB,0x78,0x28,0x02,0xCB,0xD1,0xFD,0x7E,	/* 0910: x(.~ */
	0x09,0xDD,0xCB,0xB5,0x66,0x28,0x04,0xF6,	/* 0918: .f(. */
	0x02,0x18,0x02,0xE6,0xFD,0xFD,0x77,0x09,	/* 0920: ...w. */
	0xCB,0x68,0x28,0x02,0xCB,0xF1,0xCB,0x60,	/* 0928: h(.` */
	0x28,0x02,0xCB,0xE9,0xCB,0x70,0x28,0x02,	/* 0930: (.p(. */
	0xCB,0xC9,0xDD,0x71,0xB8,0xC1,0xF1,0xC9,	/* 0938: q */
	0xCD,0xF3,0x08,0xDD,0x7E,0xBF,0xFE,0x01,	/* 0940: .~. */
	0x20,0x22,0xED,0x2C,0xA4,0xFF,0xDD,0x7E,	/* 0948:  ",~ */
	0xA7,0xFE,0x04,0xF2,0x61,0x09,0xFD,0x1C,	/* 0950: .a.. */
	0x1C,0x00,0xF6,0x08,0xFD,0x77,0x7F,0x18,	/* 0958: ...w. */
	0x2D,0xFD,0x1C,0x1D,0x00,0xF6,0x20,0xFD,	/* 0960: -...  */
	0x77,0x7F,0x18,0x22,0xDD,0x7E,0xC5,0xFE,	/* 0968: w."~ */
	0x01,0x28,0x1B,0xDD,0xCB,0xA9,0x4E,0x20,	/* 0970: .(.N  */
	0x15,0xDD,0xCB,0xA9,0xC6,0xDD,0x7E,0xC7,	/* 0978: .~ */
	0xFE,0x01,0x28,0x05,0xFD,0x36,0x06,0x92,	/* 0980: .(.6. */
	0xC9,0xFD,0x36,0x06,0x94,0xC9,0xDD,0x36,	/* 0988: 6.6 */
	0xBF,0x00,0xFD,0x7E,0x05,0xFE,0x00,0xC0,	/* 0990: .~.. */
	0xDD,0x7E,0xC5,0xFE,0x01,0xCA,0x62,0x0B,	/* 0998: ~.b. */
	0xDD,0x7E,0xC7,0xFE,0x01,0x20,0x19,0xFD,	/* 09A0: ~. . */
	0x7E,0x40,0xFE,0x42,0x28,0x07,0xFD,0x36,	/* 09A8: ~@B(.6 */
	0x72,0x31,0xC3,0xD9,0x0A,0xFD,0x36,0x76,	/* 09B0: r1.6v */
	0x00,0xFD,0x36,0x72,0x42,0xC3,0xD9,0x0A,	/* 09B8: .6rB. */
	0xDD,0x7E,0xB6,0xE6,0x0F,0xCB,0x27,0x4F,	/* 09C0: ~.'O */
	0x06,0x00,0xFD,0x7E,0x40,0xFE,0x42,0x28,	/* 09C8: ..~@B( */
	0x05,0x21,0x68,0x18,0x18,0x03,0x21,0x4C,	/* 09D0: .!h...!L */
	0x18,0xED,0xC6,0x46,0xFD,0x70,0x72,0x23,	/* 09D8: .Fpr# */
	0x46,0xFD,0x70,0x76,0xDD,0x7E,0xB6,0xE6,	/* 09E0: Fpv~ */
	0xF0,0xCB,0x3F,0xCB,0x3F,0xCB,0x3F,0x4F,	/* 09E8: ???O */
	0x06,0x00,0xFD,0x7E,0x40,0xFE,0x42,0x28,	/* 09F0: ..~@B( */
	0x05,0x21,0x68,0x18,0x18,0x03,0x21,0x4C,	/* 09F8: .!h...!L */
	0x18,0xED,0xC6,0x46,0xFD,0x70,0x78,0x23,	/* 0A00: .Fpx# */
	0x46,0xFD,0x70,0x7C,0xDD,0x7E,0xBB,0xFD,	/* 0A08: Fp|~ */
	0x77,0x1A,0xDD,0x7E,0xBC,0xFD,0x77,0x1B,	/* 0A10: w.~w. */
	0xDD,0x7E,0xBD,0xFD,0x77,0x1C,0xDD,0x7E,	/* 0A18: ~w.~ */
	0xBE,0xFD,0x77,0x1D,0xDD,0x36,0xB9,0x00,	/* 0A20: w.6. */
	0xDD,0x7E,0xB4,0xE6,0x03,0x47,0xDD,0x7E,	/* 0A28: ~.G~ */
	0xB4,0xE6,0x14,0xFE,0x10,0x28,0x0C,0xFE,	/* 0A30: ..(. */
	0x04,0x28,0x04,0x3E,0x40,0x18,0x06,0x3E,	/* 0A38: .(.>@..> */
	0xC0,0x18,0x02,0x3E,0x00,0xB0,0x47,0xDD,	/* 0A40: ..>.G */
	0x7E,0xBA,0xE6,0x80,0x20,0x04,0x78,0xF6,	/* 0A48: ~ .x */
	0x10,0x47,0xDD,0x7E,0xB5,0xE6,0x0F,0xFE,	/* 0A50: .G~. */
	0x07,0x78,0x20,0x04,0xF6,0x00,0x18,0x02,	/* 0A58: .x .... */
	0xF6,0x08,0xFD,0x77,0x08,0xDD,0x7E,0xB5,	/* 0A60: .w.~ */
	0xE6,0x10,0x28,0x04,0x06,0x02,0x18,0x02,	/* 0A68: .(..... */
	0x06,0x00,0xDD,0x7E,0xB5,0xE6,0x80,0x28,	/* 0A70: ..~( */
	0x04,0x3E,0x10,0xB0,0x47,0xDD,0x7E,0xBA,	/* 0A78: .>.G~ */
	0xE6,0x02,0x28,0x11,0xDD,0x7E,0xBA,0xE6,	/* 0A80: .(.~ */
	0x01,0x28,0x06,0x3E,0xC0,0xB0,0x47,0x18,	/* 0A88: .(.>G. */
	0x04,0x3E,0x40,0xB0,0x47,0xFD,0x70,0x09,	/* 0A90: .>@Gp. */
	0xDD,0x7E,0xBA,0xE6,0x02,0x28,0x06,0xFD,	/* 0A98: ~.(. */
	0x36,0x0A,0x36,0x18,0x04,0xFD,0x36,0x0A,	/* 0AA0: 6.6..6. */
	0x06,0xDD,0xCB,0xC0,0x5E,0x28,0x04,0x06,	/* 0AA8: .^(.. */
	0x02,0x18,0x0C,0xDD,0xCB,0xC0,0x56,0x28,	/* 0AB0: ...V( */
	0x04,0x06,0x04,0x18,0x02,0x06,0x03,0xDD,	/* 0AB8: ....... */
	0xCB,0xC0,0x46,0x28,0x04,0x3E,0x18,0x18,	/* 0AC0: F(.>.. */
	0x0C,0xDD,0xCB,0xC0,0x4E,0x28,0x04,0x3E,	/* 0AC8: .N(.> */
	0x00,0x18,0x02,0x3E,0x08,0xB0,0xFD,0x77,	/* 0AD0: ...>.w */
	0x1E,0xDD,0x7E,0xBA,0xE6,0x04,0x28,0x16,	/* 0AD8: .~.(. */
	0xDD,0x7E,0xC7,0xFE,0x01,0x20,0x07,0xFD,	/* 0AE0: ~. . */
	0x7E,0x40,0xFE,0x42,0x28,0x08,0x06,0x02,	/* 0AE8: ~@B(... */
	0xDD,0xCB,0xA9,0x96,0x18,0x02,0x06,0x00,	/* 0AF0: .... */
	0xDD,0x7E,0xC2,0xFE,0xFF,0x28,0x04,0x3E,	/* 0AF8: ~(.> */
	0x80,0xB0,0x47,0xFD,0x70,0x1F,0xDD,0x7E,	/* 0B00: Gp.~ */
	0xBA,0xDD,0xCB,0xB4,0x7E,0x20,0x06,0xDD,	/* 0B08: ~ . */
	0xCB,0xBA,0x76,0x28,0x02,0xF6,0x08,0x4F,	/* 0B10: v(..O */
	0xDD,0xAE,0xA8,0xE6,0x9B,0x47,0xDD,0x7E,	/* 0B18: G~ */
	0xA8,0xA8,0xCB,0x5F,0x28,0x02,0xE6,0x0F,	/* 0B20: _(.. */
	0x47,0xDD,0x70,0xA8,0x79,0xE6,0xFB,0xDD,	/* 0B28: Gpy */
	0xAE,0xA9,0xE6,0xA4,0x47,0xDD,0x7E,0xA9,	/* 0B30: G~ */
	0xA8,0xDD,0x77,0xA9,0xDD,0x7E,0xC7,0xFE,	/* 0B38: w~ */
	0x01,0x20,0x12,0xFD,0x7E,0x40,0xFE,0x42,	/* 0B40: . .~@B */
	0x20,0x0B,0xDD,0x7E,0xBA,0xE6,0x04,0x28,	/* 0B48:  .~.( */
	0x04,0xDD,0xCB,0xA9,0xD6,0xFD,0x36,0x21,	/* 0B50: .6! */
	0x02,0xFD,0x36,0x05,0x4E,0xDD,0x36,0xC5,	/* 0B58: .6.N6 */
	0x01,0xC9,0xDD,0x36,0xC5,0x00,0xDD,0xCB,	/* 0B60: .6. */
	0xA8,0x86,0xDD,0x7E,0xC7,0xFE,0x01,0xCA,	/* 0B68: ~. */
	0x1D,0x0C,0xFD,0x36,0x05,0x1A,0xDD,0xCB,	/* 0B70: ..6.. */
	0xB7,0x46,0x20,0x06,0xDD,0xCB,0xB4,0x7E,	/* 0B78: F .~ */
	0x28,0x13,0xDD,0x7E,0xC4,0xE6,0x08,0x20,	/* 0B80: (.~.  */
	0x06,0xFD,0x36,0x6C,0x01,0x18,0x17,0xFD,	/* 0B88: .6l... */
	0x36,0x6D,0x02,0x18,0x11,0xDD,0x7E,0xC4,	/* 0B90: 6m...~ */
	0xE6,0x08,0x20,0x06,0xFD,0x36,0x6C,0x00,	/* 0B98: . .6l. */
	0x18,0x04,0xFD,0x36,0x6D,0x00,0xDD,0xCB,	/* 0BA0: ..6m. */
	0xB7,0x4E,0x20,0x06,0xDD,0xCB,0xBA,0x76,	/* 0BA8: N .v */
	0x28,0x13,0xDD,0x7E,0xC4,0xE6,0x08,0x20,	/* 0BB0: (.~.  */
	0x06,0xFD,0x36,0x6D,0x02,0x18,0x17,0xFD,	/* 0BB8: .6m... */
	0x36,0x6C,0x01,0x18,0x11,0xDD,0x7E,0xC4,	/* 0BC0: 6l...~ */
	0xE6,0x08,0x20,0x06,0xFD,0x36,0x6D,0x00,	/* 0BC8: . .6m. */
	0x18,0x04,0xFD,0x36,0x6C,0x00,0xDD,0xCB,	/* 0BD0: ..6l. */
	0xBA,0x6E,0x28,0x15,0xCD,0x04,0x09,0xDD,	/* 0BD8: n(... */
	0x7E,0xB5,0xE6,0x10,0x28,0x04,0x3E,0xB0,	/* 0BE0: ~.(.> */
	0x18,0x02,0x3E,0xF0,0xDD,0xA6,0xC6,0x18,	/* 0BE8: ..>. */
	0x06,0x3E,0x00,0xDD,0x36,0xB8,0x24,0xFD,	/* 0BF0: .>.6$ */
	0x77,0x16,0xDD,0xCB,0xBA,0x76,0x28,0x0A,	/* 0BF8: w.v(. */
	0xDD,0xCB,0xC4,0x5E,0x20,0x04,0xF6,0x08,	/* 0C00: ^ .. */
	0x18,0x0E,0xDD,0xCB,0xB4,0x7E,0x28,0x08,	/* 0C08: ..~(. */
	0xDD,0xCB,0xC4,0x5E,0x28,0x02,0xF6,0x08,	/* 0C10: ^(.. */
	0xFD,0x77,0x15,0x18,0x0C,0xFD,0x36,0x15,	/* 0C18: w...6. */
	0x00,0xFD,0x36,0x16,0x00,0xFD,0x36,0x05,	/* 0C20: .6..6. */
	0x18,0xFD,0x36,0x06,0x90,0xDD,0x36,0xAE,	/* 0C28: .6.6 */
	0x00,0xDD,0x3E,0xC3,0x05,0x01,0xC9,0xCD,	/* 0C30: .>.. */
	0xF3,0x08,0xFD,0x7E,0x6C,0xE6,0x80,0x28,	/* 0C38: .~l( */
	0x0A,0xDD,0x36,0xAE,0x00,0xDD,0x3E,0xC3,	/* 0C40: .6.> */
	0x05,0x01,0xC9,0xDD,0x36,0xAE,0x06,0xC9,	/* 0C48: ..6. */
	0xCD,0x40,0x09,0x18,0x05,0xFD,0xED,0x2C,	/* 0C50: @..., */
	0xA2,0xFF,0xCD,0x37,0x0C,0x26,0x00,0xC3,	/* 0C58: 7.&. */
	0x12,0x0D,0xCD,0x40,0x09,0x26,0x00,0xC3,	/* 0C60: ..@.&. */
	0x12,0x0D,0xCD,0xFC,0x1C,0x26,0x00,0xC3,	/* 0C68: ...&. */
	0x12,0x0D,0xCD,0x1A,0x1D,0x26,0x00,0xC3,	/* 0C70: ....&. */
	0x12,0x0D,0x26,0x00,0xC3,0x12,0x0D,0xCD,	/* 0C78: ..&... */
	0xF3,0x08,0xFD,0x7E,0x05,0xFE,0x00,0x28,	/* 0C80: .~..( */
	0x05,0x26,0x00,0xC3,0x12,0x0D,0xDD,0x7E,	/* 0C88: .&...~ */
	0xAD,0xDD,0x77,0xAC,0xFD,0x36,0x05,0x82,	/* 0C90: w6. */
	0xCD,0xF3,0x08,0xDD,0x7E,0xC7,0xFE,0x01,	/* 0C98: .~. */
	0x28,0x08,0xFD,0x7E,0x0B,0xE6,0xFB,0xFD,	/* 0CA0: (.~. */
	0x77,0x0B,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 0CA8: w.6.> */
	0xC3,0x05,0x01,0x26,0x00,0x18,0x5B,0xFD,	/* 0CB0: ..&..[ */
	0xED,0x2C,0xA2,0xFF,0xDD,0x7E,0xAB,0xDD,	/* 0CB8: ,~ */
	0x77,0xAA,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 0CC0: w6.> */
	0xC3,0x05,0x01,0x26,0x00,0x18,0x43,0xCD,	/* 0CC8: ..&..C */
	0xF3,0x08,0xFD,0x7E,0x0B,0xF6,0x04,0xFD,	/* 0CD0: .~.. */
	0x77,0x0B,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 0CD8: w.6.> */
	0xC3,0x05,0x01,0x26,0x00,0x18,0x2B,0xCD,	/* 0CE0: ..&..+ */
	0x84,0x1B,0x26,0x00,0x18,0x24,0x7A,0x0C,	/* 0CE8: .&..$z. */
	0x62,0x0C,0x50,0x0C,0x55,0x0C,0x62,0x0C,	/* 0CF0: b.P.U.b. */
	0x6A,0x0C,0x3F,0x1C,0x9B,0x1C,0x7A,0x0C,	/* 0CF8: j.?..z. */
	0x7A,0x0C,0x72,0x0C,0x98,0x0C,0x7F,0x0C,	/* 0D00: z.r... */
	0xB7,0x0C,0xCF,0x0C,0xE7,0x0C,0x7A,0x0C,	/* 0D08: ...z. */
	0x7A,0x0C,0xED,0x7F,0x17,0xDD,0x7E,0xA1,	/* 0D10: z..~ */
	0xDD,0x67,0xDD,0x7E,0xAE,0xFE,0x00,0xF3,	/* 0D18: g~. */
	0xC2,0xB7,0x0D,0xDD,0x46,0xA8,0xCB,0x40,	/* 0D20: .F@ */
	0xCA,0xC4,0x0D,0xCB,0x60,0x28,0xE3,0xCD,	/* 0D28: .`( */
	0xF3,0x08,0xCB,0x78,0x28,0x16,0xFD,0x7E,	/* 0D30: .x(.~ */
	0x05,0xFE,0x00,0x20,0xD5,0xFD,0x36,0x05,	/* 0D38: .. 6. */
	0x24,0xCB,0xE8,0xCB,0xB8,0xCB,0xB0,0xDD,	/* 0D40: $ */
	0x70,0xA8,0x18,0xC6,0xDD,0x6E,0xAA,0x7D,	/* 0D48: p.n} */
	0xDD,0x96,0xAB,0xCB,0x7F,0x20,0xBB,0xFE,	/* 0D50:   */
	0x40,0xF2,0x12,0x0D,0xDD,0xCB,0xBA,0x5E,	/* 0D58: @..^ */
	0x28,0x0B,0xFD,0x7E,0x05,0xFE,0x00,0x20,	/* 0D60: (.~..  */
	0xA9,0xFD,0x36,0x05,0x23,0xDD,0xCB,0xB4,	/* 0D68: 6.# */
	0x7E,0x28,0x19,0xDD,0x7E,0xC4,0xE6,0x08,	/* 0D70: ~(.~. */
	0x20,0x06,0xFD,0x36,0x6C,0x01,0x18,0x0C,	/* 0D78:  .6l... */
	0xFD,0x36,0x6D,0x02,0xFD,0x7E,0x15,0xF6,	/* 0D80: 6m.~. */
	0x08,0xFD,0x77,0x15,0xDD,0xCB,0xBA,0x76,	/* 0D88: .w.v */
	0x28,0x19,0xDD,0x7E,0xC4,0xE6,0x08,0x20,	/* 0D90: (.~.  */
	0x0E,0xFD,0x36,0x6D,0x02,0xFD,0x7E,0x15,	/* 0D98: .6m.~. */
	0xF6,0x08,0xFD,0x77,0x15,0x18,0x04,0xFD,	/* 0DA0: .w... */
	0x36,0x6C,0x01,0xCB,0xB0,0xCB,0xA8,0xCB,	/* 0DA8: 6l. */
	0xA0,0xDD,0x70,0xA8,0xC3,0x12,0x0D,0xFE,	/* 0DB0: p.. */
	0x10,0xCA,0x12,0x0D,0x6F,0xFD,0xED,0x3C,	/* 0DB8: ...o< */
	0xEE,0x0C,0xFD,0xE9,0xDD,0x6E,0xAC,0xDD,	/* 0DC0: .n */
	0x7E,0xAD,0x95,0xCA,0x2B,0x0D,0xDD,0xCB,	/* 0DC8: ~+. */
	0xA8,0xC6,0xCD,0xF3,0x08,0xFD,0x7E,0x06,	/* 0DD0: .~. */
	0xF6,0x04,0xFD,0x77,0x06,0xDD,0x36,0xC9,	/* 0DD8: .w.6 */
	0x01,0xC3,0x2B,0x0D,0xED,0x32,0x00,0x00,	/* 0DE0: .+.2.. */
	0xCB,0x5D,0x28,0x0B,0xCB,0x9D,0xFD,0x7B,	/* 0DE8: ](.{ */
	0x0D,0x00,0x2F,0xE6,0x08,0x18,0x07,0xFD,	/* 0DF0: ...... */
	0x7B,0x0D,0x00,0x2F,0xE6,0x02,0xFE,0x00,	/* 0DF8: {..... */
	0x28,0x0A,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 0E00: (.6.> */
	0xC3,0x05,0x01,0xC9,0xDD,0x36,0xAE,0x06,	/* 0E08: ..6. */
	0xC9,0x26,0x00,0xDD,0x7E,0xAC,0xDD,0x96,	/* 0E10: &.~ */
	0xAD,0x28,0x04,0xF1,0xC3,0xC4,0x05,0xDD,	/* 0E18: (.. */
	0x7E,0xBF,0xFE,0x01,0x28,0x08,0xFD,0x7E,	/* 0E20: ~.(.~ */
	0x01,0xCB,0x5F,0xC8,0x18,0x10,0xDD,0x36,	/* 0E28: ._..6 */
	0xAA,0x00,0xDD,0x36,0xAB,0x00,0xDD,0x36,	/* 0E30: .6.6 */
	0xAC,0x00,0xDD,0x36,0xAD,0x00,0xFD,0xED,	/* 0E38: .6. */
	0x2C,0xA2,0xFF,0xDD,0xCB,0xB7,0x46,0x20,	/* 0E40: ,F  */
	0x04,0xFD,0x36,0x02,0x90,0xFD,0x36,0x02,	/* 0E48: .6.6. */
	0x30,0xFD,0x36,0x02,0x20,0xDD,0x36,0xBF,	/* 0E50: 06. 6 */
	0x01,0xDD,0xCB,0xB7,0x4E,0x20,0x24,0xFD,	/* 0E58: .N $ */
	0xE5,0xED,0x32,0x00,0x00,0x7D,0xE6,0x80,	/* 0E60: 2..} */
	0x6F,0xFD,0xED,0x2C,0xA4,0xFF,0xFD,0x7E,	/* 0E68: o,~ */
	0x04,0x47,0xDD,0x7E,0xAF,0x2F,0xA0,0xFD,	/* 0E70: .G~. */
	0x77,0x04,0xE5,0xFD,0xE1,0x2F,0xFD,0x77,	/* 0E78: w..w */
	0x40,0xFD,0xE1,0xDD,0x36,0xAE,0x10,0xDD,	/* 0E80: @6. */
	0x3E,0xC3,0x05,0x01,0xC9,0xDD,0x7E,0xBF,	/* 0E88: >..~ */
	0xFE,0x01,0x28,0x06,0xFD,0x7E,0x01,0xCB,	/* 0E90: .(.~. */
	0x5F,0xC8,0xDD,0x36,0xBF,0x00,0xFD,0x36,	/* 0E98: _6.6 */
	0x02,0x18,0xDD,0x7E,0xB4,0xE6,0x7F,0xFD,	/* 0EA0: ..~ */
	0x77,0x00,0xDD,0xCB,0xB4,0x7E,0x20,0x12,	/* 0EA8: w.~ . */
	0xDD,0xCB,0xB7,0x46,0x20,0x06,0xFD,0x36,	/* 0EB0: F .6 */
	0x02,0x90,0x18,0x0A,0xFD,0x36,0x02,0x80,	/* 0EB8: ...6. */
	0x18,0x04,0xFD,0x36,0x02,0x80,0xDD,0x7E,	/* 0EC0: ..6.~ */
	0xB5,0xFD,0x77,0x00,0xCB,0x67,0x20,0x06,	/* 0EC8: w.g . */
	0xDD,0xCB,0xA9,0xA6,0x18,0x04,0xDD,0xCB,	/* 0ED0: .. */
	0xA9,0xE6,0xFD,0xE5,0xED,0x32,0x00,0x00,	/* 0ED8: 2.. */
	0x7D,0xE6,0x80,0x6F,0xFD,0xED,0x2C,0xA4,	/* 0EE0: }o, */
	0xFF,0xFD,0x7E,0x04,0xDD,0xCB,0xB7,0x4E,	/* 0EE8: ~.N */
	0x28,0x05,0xDD,0xB6,0xAF,0x18,0x06,0x47,	/* 0EF0: (...G */
	0xDD,0x7E,0xAF,0x2F,0xA0,0xFD,0x77,0x04,	/* 0EF8: ~.w. */
	0xE5,0xFD,0xE1,0x2F,0xFD,0x77,0x40,0xFD,	/* 0F00: .w@ */
	0xE1,0xDD,0x7E,0xB6,0xFD,0x77,0x01,0xDD,	/* 0F08: ~w. */
	0x36,0xB9,0x00,0xDD,0x7E,0xBB,0xDD,0x77,	/* 0F10: 6.~w */
	0xB0,0xDD,0x7E,0xBC,0xDD,0x77,0xB1,0xDD,	/* 0F18: ~w */
	0x7E,0xBD,0xDD,0x77,0xB2,0xDD,0x7E,0xBE,	/* 0F20: ~w~ */
	0xDD,0x77,0xB3,0xDD,0x36,0xB9,0x00,0xDD,	/* 0F28: w6. */
	0x7E,0xBA,0xDD,0xCB,0xB4,0x7E,0x28,0x02,	/* 0F30: ~~(. */
	0xF6,0x08,0x4F,0xDD,0xAE,0xA8,0xE6,0xDB,	/* 0F38: .O */
	0x47,0xDD,0x7E,0xA8,0xA8,0xCB,0x48,0x28,	/* 0F40: G~H( */
	0x02,0xCB,0x97,0xCB,0x5F,0x28,0x02,0xE6,	/* 0F48: ._(. */
	0x0F,0x47,0x79,0xE6,0x54,0x20,0x0A,0xDD,	/* 0F50: .GyT . */
	0xCB,0xA9,0x8E,0xDD,0xCB,0xA3,0xA6,0x18,	/* 0F58: . */
	0x08,0xDD,0xCB,0xA3,0xE6,0xDD,0xCB,0xA9,	/* 0F60: . */
	0xCE,0xDD,0x70,0xA8,0x79,0xDD,0xAE,0xA9,	/* 0F68: py */
	0xE6,0xA4,0x47,0xDD,0x7E,0xA9,0xA8,0xCB,	/* 0F70: G~ */
	0x50,0x28,0x02,0xCB,0x87,0xDD,0x77,0xA9,	/* 0F78: P(.w */
	0xCB,0x6F,0x20,0x06,0xDD,0x36,0xB8,0x24,	/* 0F80: o .6$ */
	0x18,0x39,0xED,0x32,0x00,0x00,0xCB,0x5D,	/* 0F88: .92..] */
	0x28,0x0A,0xCB,0x9D,0xFD,0x7B,0x0D,0x00,	/* 0F90: (.{.. */
	0xCB,0x2F,0x18,0x06,0xFD,0x7B,0x0D,0x00,	/* 0F98: ...{.. */
	0xCB,0x27,0x2F,0xDD,0xCB,0xA9,0x66,0x20,	/* 0FA0: '.f  */
	0x04,0xE6,0x26,0x18,0x13,0xE6,0x24,0xDD,	/* 0FA8: .&..$ */
	0x77,0xB8,0xCB,0x57,0x18,0x0D,0xDD,0x7E,	/* 0FB0: wW..~ */
	0xB5,0xE6,0xEF,0xFD,0x77,0x00,0x18,0x03,	/* 0FB8: w... */
	0xDD,0x77,0xB8,0xDD,0x7E,0xC0,0xDD,0x77,	/* 0FC0: w~w */
	0xC1,0xDD,0x7E,0xC2,0xDD,0x77,0xC3,0xFD,	/* 0FC8: ~w */
	0x36,0x02,0x05,0xDD,0x36,0xAE,0x00,0xDD,	/* 0FD0: 6..6. */
	0x3E,0xC3,0x05,0x01,0xC9,0x45,0x6E,0x64,	/* 0FD8: >..End */
	0x20,0x6F,0x66,0x20,0x74,0x61,0x20,0x63,	/* 0FE0:  of ta c */
	0x6F,0x64,0x65,0x00,0x00,0xDD,0xD1,0xEB,	/* 0FE8: ode.. */
	0x0F,0xE5,0xDD,0xE5,0xC5,0xDD,0x2A,0x2A,	/* 0FF0: .** */
	0x01,0x0E,0x15,0xED,0xB7,0x21,0x00,0x00,	/* 0FF8: ...!.. */
	0xED,0xBF,0xDD,0x36,0xAE,0x2A,0xC1,0xDD,	/* 1000: 6* */
	0xE1,0xE1,0xED,0x55,0xDD,0xD1,0xEB,0x0F,	/* 1008: U. */
	0xE5,0xDD,0xE5,0xC5,0xDD,0x2A,0x2C,0x01,	/* 1010: *,. */
	0x0E,0x1D,0x21,0x00,0x00,0xED,0xBF,0xDD,	/* 1018: ..!.. */
	0x36,0xAE,0x2A,0xC1,0xDD,0xE1,0xE1,0xED,	/* 1020: 6* */
	0x55,0xFD,0xED,0x2C,0xA2,0xFF,0xDD,0x7E,	/* 1028: U,~ */
	0xB2,0xE6,0x0C,0x20,0x25,0xDD,0x7E,0xB2,	/* 1030: . %~ */
	0xE6,0x10,0x28,0x1E,0xFD,0x36,0x00,0x0F,	/* 1038: .(.6.. */
	0xFD,0x36,0x00,0x01,0xFD,0x36,0x00,0x07,	/* 1040: 6..6.. */
	0xFD,0x36,0x00,0x03,0xDD,0x7E,0xB3,0xF6,	/* 1048: 6..~ */
	0x09,0xFD,0x36,0x00,0x05,0xFD,0x77,0x00,	/* 1050: .6..w. */
	0x18,0x0C,0xDD,0x7E,0xB3,0xF6,0x08,0xFD,	/* 1058: ..~. */
	0x36,0x00,0x05,0xFD,0x77,0x00,0xED,0x32,	/* 1060: 6..w.2 */
	0x02,0x00,0x7C,0xF6,0xF0,0x67,0xDD,0x7E,	/* 1068: ..|g~ */
	0xA7,0xFE,0x01,0x20,0x44,0x0E,0x10,0xED,	/* 1070: . D.. */
	0xBF,0x21,0x0F,0x80,0x0E,0x11,0xED,0xBF,	/* 1078: !... */
	0xED,0x2A,0x00,0x00,0x7C,0xF6,0xF0,0x67,	/* 1080: *..|g */
	0x0E,0x12,0xED,0xBF,0xDD,0x7C,0xE6,0x7F,	/* 1088: ..| */
	0xF6,0x0F,0x6F,0x26,0x00,0x0E,0x13,0xED,	/* 1090: .o&... */
	0xBF,0xED,0x2C,0xAA,0xFF,0x0E,0x14,0xED,	/* 1098: ,.. */
	0xBF,0x21,0x84,0x88,0x0E,0x15,0xED,0xBF,	/* 10A0: !.. */
	0xFD,0x36,0x00,0x01,0xFD,0x36,0x00,0xC0,	/* 10A8: 6..6. */
	0x26,0x00,0xDD,0x36,0xAE,0x28,0xC3,0xF1,	/* 10B0: &.6( */
	0x05,0x0E,0x18,0xED,0xBF,0x21,0x0F,0x80,	/* 10B8: ...!. */
	0x0E,0x19,0xED,0xBF,0xED,0x2A,0x00,0x00,	/* 10C0: ..*.. */
	0x7C,0xF6,0xF0,0x67,0x0E,0x1A,0xED,0xBF,	/* 10C8: |g.. */
	0xDD,0x7C,0xE6,0x7F,0xF6,0x0F,0x6F,0x26,	/* 10D0: |.o& */
	0x00,0x0E,0x1B,0xED,0xBF,0xED,0x2C,0xAA,	/* 10D8: ..., */
	0xFF,0x0E,0x1C,0xED,0xBF,0x21,0x84,0x88,	/* 10E0: ..! */
	0x0E,0x1D,0xED,0xBF,0xFD,0x36,0x00,0x01,	/* 10E8: ..6.. */
	0xFD,0x36,0x00,0xC0,0x26,0x00,0xDD,0x36,	/* 10F0: 6.&.6 */
	0xAE,0x28,0xC3,0xF1,0x05,0xFD,0xED,0x2C,	/* 10F8: (., */
	0xA2,0xFF,0xDD,0x7E,0xB2,0xE6,0x0C,0x20,	/* 1100: ~.  */
	0x15,0xDD,0x7E,0xB2,0xE6,0x10,0x28,0x0E,	/* 1108: .~.(. */
	0xDD,0x7E,0xB1,0xF6,0x11,0xFD,0x36,0x00,	/* 1110: ~.6. */
	0x03,0xFD,0x77,0x00,0x18,0x0C,0xDD,0x7E,	/* 1118: .w...~ */
	0xB1,0xF6,0x01,0xFD,0x36,0x00,0x03,0xFD,	/* 1120: .6.. */
	0x77,0x00,0xED,0x32,0x02,0x00,0x7C,0xF6,	/* 1128: w.2..| */
	0xF0,0x67,0xDD,0x7E,0xA7,0xFE,0x01,0x20,	/* 1130: g~.  */
	0x47,0x0E,0x12,0xED,0xBF,0x21,0x0F,0x80,	/* 1138: G..!. */
	0x0E,0x13,0xED,0xBF,0xED,0x2A,0x00,0x0C,	/* 1140: ..*.. */
	0x7C,0xF6,0xF0,0x67,0x0E,0x10,0xED,0xBF,	/* 1148: |g.. */
	0xED,0x2A,0x00,0x0C,0x7C,0xE6,0x7F,0xF6,	/* 1150: *..| */
	0x0F,0x6F,0x26,0x00,0x0E,0x11,0xED,0xBF,	/* 1158: .o&... */
	0xED,0x2C,0xAA,0xFF,0x0E,0x14,0xED,0xBF,	/* 1160: ,.. */
	0x21,0x80,0xA0,0x0E,0x15,0xED,0xBF,0xFD,	/* 1168: !.. */
	0x36,0x00,0x01,0xFD,0x36,0x00,0xE0,0x26,	/* 1170: 6..6.& */
	0x00,0xDD,0x36,0xAE,0x28,0xC3,0xF1,0x05,	/* 1178: .6(. */
	0x0E,0x1A,0xED,0xBF,0x21,0x0F,0x80,0x0E,	/* 1180: ..!.. */
	0x1B,0xED,0xBF,0xED,0x2A,0x00,0x0C,0x7C,	/* 1188: .*..| */
	0xF6,0xF0,0x67,0x0E,0x18,0xED,0xBF,0xED,	/* 1190: g.. */
	0x2A,0x00,0x0C,0x7C,0xE6,0x7F,0xF6,0x0F,	/* 1198: *..|. */
	0x6F,0x26,0x00,0x0E,0x19,0xED,0xBF,0xED,	/* 11A0: o&... */
	0x2C,0xAA,0xFF,0x0E,0x1C,0xED,0xBF,0x21,	/* 11A8: ,..! */
	0x80,0xA0,0x0E,0x1D,0xED,0xBF,0xFD,0x36,	/* 11B0: ..6 */
	0x00,0x01,0xFD,0x36,0x00,0xE0,0x26,0x00,	/* 11B8: ..6.&. */
	0xDD,0x36,0xAE,0x28,0xC3,0xF1,0x05,0xFD,	/* 11C0: 6(. */
	0xED,0x2C,0xA2,0xFF,0xDD,0x7E,0xB1,0xFD,	/* 11C8: ,~ */
	0x36,0x00,0x03,0xFD,0x77,0x00,0xDD,0x7E,	/* 11D0: 6..w.~ */
	0xB2,0xFD,0x36,0x00,0x04,0xFD,0x77,0x00,	/* 11D8: 6..w. */
	0xDD,0x7E,0xB3,0xFD,0x36,0x00,0x05,0xFD,	/* 11E0: ~6.. */
	0x77,0x00,0xDD,0x7E,0xB4,0xFD,0x36,0x00,	/* 11E8: w.~6. */
	0x06,0xFD,0x77,0x00,0xDD,0x7E,0xB5,0xFD,	/* 11F0: .w.~ */
	0x36,0x00,0x07,0xFD,0x77,0x00,0xDD,0x7E,	/* 11F8: 6..w.~ */
	0xB8,0xFD,0x36,0x00,0x0A,0xFD,0x77,0x00,	/* 1200: 6..w. */
	0xDD,0x7E,0xBA,0xFD,0x36,0x00,0x0C,0xFD,	/* 1208: ~6.. */
	0x77,0x00,0xDD,0x7E,0xBB,0xFD,0x36,0x00,	/* 1210: w.~6. */
	0x0D,0xFD,0x77,0x00,0xDD,0x36,0xAE,0x2A,	/* 1218: .w.6* */
	0xDD,0x3E,0xC3,0x05,0x01,0x26,0x00,0xC3,	/* 1220: >..&. */
	0xF1,0x05,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1228: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1230: 8.H.X.h. */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1238: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1240: 8.H.X.h. */
	0x78,0x00,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1248: x.....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1250: 8.H.X.h. */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1258: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1260: 8.H.X.h. */
	0x78,0x00,0x7A,0x00,0x6A,0x00,0xFA,0x00,	/* 1268: x.z.j.. */
	0xAA,0x00,0xBA,0x00,0xCA,0x00,0x08,0x80,	/* 1270: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1278: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1280: 8.H.X.h. */
	0x08,0x01,0x7A,0x00,0x6A,0x00,0xFA,0x00,	/* 1288: ..z.j.. */
	0xAA,0x00,0xBA,0x00,0xCA,0x00,0x08,0x80,	/* 1290: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1298: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 12A0: 8.H.X.h. */
	0x08,0x01,0x6A,0x00,0x7A,0x00,0xFA,0x00,	/* 12A8: ..j.z.. */
	0x9A,0x00,0xAA,0x00,0xBA,0x00,0x08,0x80,	/* 12B0: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 12B8: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 12C0: 8.H.X.h. */
	0x08,0x01,0x6A,0x00,0x7A,0x00,0xFA,0x00,	/* 12C8: ..j.z.. */
	0x9A,0x00,0xAA,0x00,0xBA,0x00,0x08,0x80,	/* 12D0: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 12D8: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 12E0: 8.H.X.h. */
	0x08,0x01,0x8A,0x00,0x9A,0x00,0xFA,0x00,	/* 12E8: ..... */
	0xBA,0x00,0xCA,0x00,0xDA,0x00,0x08,0x80,	/* 12F0: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 12F8: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1300: 8.H.X.h. */
	0x08,0x01,0x8A,0x00,0x9A,0x00,0xFA,0x00,	/* 1308: ..... */
	0xBA,0x00,0xCA,0x00,0xDA,0x00,0x08,0x80,	/* 1310: .... */
	0x08,0x80,0x08,0x00,0x18,0x00,0x28,0x00,	/* 1318: .....(. */
	0x38,0x00,0x48,0x00,0x58,0x00,0x68,0x00,	/* 1320: 8.H.X.h. */
	0x08,0x01,0x3A,0x41,0x00,0xFE,0x00,0x20,	/* 1328: ..:A..  */
	0xF9,0x3A,0x00,0x80,0x2F,0x47,0x32,0x00,	/* 1330: :..G2. */
	0x80,0x3A,0x00,0x80,0xB8,0x28,0x07,0xDD,	/* 1338: :.(. */
	0x3E,0x01,0x00,0x20,0x18,0x05,0xDD,0x3E,	/* 1340: >.. ..> */
	0x01,0x00,0x40,0x3A,0x42,0x00,0xFE,0x01,	/* 1348: ..@:B.. */
	0x20,0x06,0xDD,0x11,0x28,0x13,0x08,0x40,	/* 1350:  ..(..@ */
	0x2A,0x43,0x00,0x0E,0xFF,0xED,0x6E,0x2A,	/* 1358: *C..n* */
	0x45,0x00,0x0E,0x02,0xED,0x6E,0x21,0x60,	/* 1360: E...n!` */
	0x00,0x0E,0x12,0xED,0x6E,0x21,0x02,0x00,	/* 1368: ...n!.. */
	0x0E,0x00,0xED,0x6E,0x21,0xFF,0x00,0x0E,	/* 1370: ..n!.. */
	0x08,0xED,0x6E,0x21,0x00,0x00,0x0E,0x16,	/* 1378: .n!.... */
	0xED,0x6E,0x3E,0x3F,0xD3,0xE8,0x0E,0x1F,	/* 1380: n>?.. */
	0x21,0x00,0x00,0xED,0xBF,0xED,0x4E,0x3E,	/* 1388: !..N> */
	0x00,0x0E,0xF5,0xDD,0x21,0x2A,0x12,0xED,	/* 1390: ..!*. */
	0x2C,0x00,0x00,0xD3,0xF1,0xED,0xBF,0x3C,	/* 1398: ,..< */
	0xDD,0x23,0xDD,0x23,0xFE,0x20,0x20,0xEF,	/* 13A0: ##   */
	0x21,0x00,0x08,0x0E,0xF0,0xED,0xBF,0x00,	/* 13A8: !.... */
	0x00,0x00,0xDD,0x21,0x8C,0x00,0xFD,0x21,	/* 13B0: ..!.! */
	0x00,0x70,0x21,0x80,0x00,0x0E,0x00,0xFD,	/* 13B8: .p!... */
	0xE5,0x06,0x04,0xFD,0x7E,0x0D,0xE6,0xA0,	/* 13C0: ..~. */
	0xFE,0xA0,0x20,0x44,0xE5,0xED,0x32,0x00,	/* 13C8:  D2. */
	0x00,0xFD,0xED,0xF6,0x10,0x00,0xE5,0xFD,	/* 13D0: ... */
	0xE1,0xE1,0x10,0xE7,0xFD,0xE1,0xFD,0x7E,	/* 13D8: .~ */
	0x01,0xFE,0xFF,0xCA,0x92,0x14,0xDD,0x3E,	/* 13E0: ..> */
	0x92,0x00,0x01,0x3A,0x93,0x00,0xFE,0x01,	/* 13E8: ..:.. */
	0xCA,0xDA,0x14,0xFD,0x7E,0x40,0xE6,0x01,	/* 13F0: .~@. */
	0x20,0x0B,0xDD,0x36,0x00,0x08,0xFD,0xED,	/* 13F8:  .6.. */
	0xF6,0x00,0x19,0x18,0x76,0xDD,0x36,0x00,	/* 1400: ...v6. */
	0x04,0xFD,0xED,0xF6,0x00,0x0D,0x18,0x6B,	/* 1408: ....k */
	0xFD,0xE1,0xFD,0x36,0x7F,0x08,0xDD,0x3E,	/* 1410: 6.> */
	0x93,0x00,0x01,0x3A,0x92,0x00,0xFE,0x01,	/* 1418: ..:.. */
	0xCA,0xDA,0x14,0xCD,0x82,0x15,0xFD,0x36,	/* 1420: ..6 */
	0x7F,0x10,0xFD,0x7E,0x7F,0xE6,0xF0,0xFE,	/* 1428: .~ */
	0xF0,0x20,0x0B,0xDD,0x36,0x00,0x24,0xFD,	/* 1430:  .6.$ */
	0xED,0xF6,0x00,0x0D,0x18,0x3D,0xFD,0x36,	/* 1438: ...=6 */
	0x7F,0x34,0xCD,0x82,0x15,0xFD,0x36,0x7F,	/* 1440: 4.6 */
	0x40,0xFD,0x36,0x7F,0x00,0xFD,0x36,0x68,	/* 1448: @6.6h */
	0x00,0xFD,0x36,0x18,0x00,0xFD,0x36,0x7F,	/* 1450: .6..6 */
	0x04,0xFD,0x36,0x68,0x00,0xFD,0x36,0x18,	/* 1458: .6h.6. */
	0x55,0xFD,0x36,0x7F,0x00,0xFD,0x7E,0x18,	/* 1460: U6.~. */
	0xFE,0x55,0x20,0x06,0xDD,0x36,0x00,0x48,	/* 1468: U .6.H */
	0x18,0x04,0xDD,0x36,0x00,0x28,0xFD,0xED,	/* 1470: ..6.( */
	0xF6,0x00,0x19,0xDD,0x23,0xE5,0xED,0x32,	/* 1478: ..#2 */
	0x00,0x00,0xFD,0xED,0xF6,0x80,0x00,0xE5,	/* 1480: ... */
	0xFD,0xE1,0xE1,0x0C,0x79,0xFE,0x04,0xC2,	/* 1488: .y. */
	0xBF,0x13,0x79,0xFE,0x00,0x28,0x43,0xE5,	/* 1490: .y.(C */
	0x21,0xDD,0x0F,0xFD,0xED,0xF7,0x00,0x10,	/* 1498: !... */
	0xE1,0xF2,0xAB,0x14,0x3A,0x91,0x00,0xFE,	/* 14A0: .:. */
	0x01,0x20,0x05,0xDD,0x3E,0x94,0x00,0x01,	/* 14A8: . .>.. */
	0x3A,0x01,0x00,0xFE,0x40,0x28,0x39,0x22,	/* 14B0: :..@(9" */
	0x95,0x00,0x21,0x00,0x80,0x3A,0x94,0x00,	/* 14B8: .!.:. */
	0xFE,0x01,0x20,0x07,0xFD,0xED,0xFE,0x00,	/* 14C0: . .. */
	0x20,0x18,0x05,0xFD,0xED,0xFE,0x00,0x10,	/* 14C8:  .... */
	0xDD,0xED,0xDE,0x95,0x00,0xFA,0xE8,0x14,	/* 14D0: .. */
	0x18,0x16,0xDD,0x3E,0x00,0x00,0xFF,0x18,	/* 14D8: ..>... */
	0x0E,0xDD,0x3E,0x00,0x00,0x02,0x18,0x07,	/* 14E0: .>..... */
	0xDD,0x3E,0x00,0x00,0x03,0x18,0x00,0x76,	/* 14E8: >.....v */
	0x21,0x00,0x00,0x0E,0xF0,0xED,0xBF,0x00,	/* 14F0: !.... */
	0x00,0x00,0x01,0xF3,0x1D,0x21,0x00,0x00,	/* 14F8: ....!.. */
	0x3A,0x01,0x00,0xFE,0x20,0x20,0x14,0x3A,	/* 1500: :..  .: */
	0x94,0x00,0xFE,0x01,0x20,0x05,0x11,0x00,	/* 1508: .. ... */
	0x60,0x18,0x0B,0x01,0xDD,0x0F,0x11,0x00,	/* 1510: `...... */
	0x70,0x18,0x03,0x11,0x00,0x80,0xED,0xB0,	/* 1518: p.... */
	0x3A,0x01,0x00,0xFE,0x20,0x20,0x12,0x3A,	/* 1520: :..  .: */
	0x94,0x00,0xFE,0x01,0x28,0x0B,0x01,0xF3,	/* 1528: ..(.. */
	0x0D,0x11,0x00,0x60,0x21,0x00,0x10,0xED,	/* 1530: ...`!.. */
	0xB0,0x3A,0x01,0x00,0xFE,0x20,0x20,0x05,	/* 1538: :..  . */
	0x21,0x70,0x00,0x18,0x03,0x21,0x80,0x00,	/* 1540: !p...!. */
	0x0E,0x06,0xED,0x6E,0x3A,0x01,0x00,0xFE,	/* 1548: ..n:.. */
	0x20,0x20,0x13,0x3A,0x94,0x00,0xFE,0x01,	/* 1550:   .:.. */
	0x20,0x06,0xDD,0x21,0xAA,0x12,0x18,0x0A,	/* 1558:  .!... */
	0xDD,0x21,0x6A,0x12,0x18,0x04,0xDD,0x21,	/* 1560: !j...! */
	0xEA,0x12,0x3E,0x00,0x0E,0xF5,0xED,0x2C,	/* 1568: .>.., */
	0x00,0x00,0xD3,0xF1,0xED,0xBF,0x3C,0xDD,	/* 1570: ..< */
	0x23,0xDD,0x23,0xFE,0x20,0x20,0xEF,0xC3,	/* 1578: ##   */
	0xC7,0x00,0xF5,0xC5,0xE5,0xFD,0x36,0x66,	/* 1580: .6f */
	0x01,0xFD,0x36,0x68,0x03,0xFD,0x36,0x74,	/* 1588: .6h.6t */
	0x00,0xFD,0x36,0x68,0x02,0xFD,0x36,0x74,	/* 1590: .6h.6t */
	0x00,0xFD,0x36,0x68,0x01,0xFD,0x36,0x74,	/* 1598: .6h.6t */
	0x00,0xFD,0x36,0x68,0x00,0xFD,0x36,0x74,	/* 15A0: .6h.6t */
	0x00,0xFD,0x36,0x68,0x03,0xFD,0x36,0x7A,	/* 15A8: .6h.6z */
	0x00,0xFD,0x36,0x68,0x02,0xFD,0x36,0x7A,	/* 15B0: .6h.6z */
	0x00,0xFD,0x36,0x68,0x01,0xFD,0x36,0x7A,	/* 15B8: .6h.6z */
	0x00,0xFD,0x36,0x68,0x00,0xFD,0x36,0x7A,	/* 15C0: .6h.6z */
	0x00,0xFD,0x36,0x68,0x04,0xFD,0x36,0x6D,	/* 15C8: .6h.6m */
	0xA8,0xFD,0x36,0x6E,0x00,0xFD,0x36,0x6F,	/* 15D0: 6n.6o */
	0x00,0xFD,0x36,0x6C,0x01,0xFD,0x36,0x66,	/* 15D8: .6l.6f */
	0x03,0xFD,0x36,0x66,0x03,0xFD,0x36,0x66,	/* 15E0: .6f.6f */
	0x03,0xFD,0x36,0x68,0x04,0xFD,0x36,0x6D,	/* 15E8: .6h.6m */
	0xA8,0xFD,0x36,0x6E,0x20,0xFD,0x36,0x6F,	/* 15F0: 6n 6o */
	0x00,0xFD,0x36,0x66,0x03,0xFD,0x36,0x66,	/* 15F8: .6f.6f */
	0x03,0xFD,0x36,0x66,0x03,0xFD,0x36,0x6C,	/* 1600: .6f.6l */
	0x00,0x06,0x0F,0xFD,0x36,0x66,0x03,0x10,	/* 1608: ...6f.. */
	0xFA,0xFD,0x36,0x68,0x04,0xFD,0x36,0x6D,	/* 1610: 6h.6m */
	0x00,0xFD,0x36,0x6E,0x20,0xFD,0x36,0x6F,	/* 1618: .6n 6o */
	0x03,0xFD,0x36,0x6C,0x01,0xFD,0x36,0x66,	/* 1620: .6l.6f */
	0x03,0xFD,0x36,0x66,0x03,0xFD,0x36,0x66,	/* 1628: .6f.6f */
	0x03,0xFD,0x36,0x66,0x03,0xFD,0x36,0x6C,	/* 1630: .6f.6l */
	0x00,0xFD,0x36,0x66,0x00,0xFD,0x36,0x68,	/* 1638: .6f.6h */
	0x00,0x21,0xFF,0x7F,0x2B,0xFD,0xED,0xF7,	/* 1640: .!+ */
	0x00,0x00,0x20,0xF8,0xFD,0x36,0x40,0x00,	/* 1648: .. 6@. */
	0xFD,0x36,0x05,0x81,0x21,0xFF,0x7F,0xFD,	/* 1650: 6.! */
	0x7E,0x40,0xFE,0x00,0x28,0xF9,0xFD,0x36,	/* 1658: ~@.(6 */
	0x4B,0x00,0xFD,0x36,0x7E,0xC3,0x06,0x04,	/* 1660: K.6~.. */
	0x05,0xFD,0x70,0x68,0xFD,0x36,0x18,0x00,	/* 1668: .ph6.. */
	0x78,0xFE,0x00,0x20,0xF3,0xE1,0xC1,0xF1,	/* 1670: x.  */
	0xC9,0x43,0x6F,0x70,0x79,0x72,0x69,0x67,	/* 1678: Copyrig */
	0x68,0x74,0x20,0x28,0x63,0x29,0x20,0x53,	/* 1680: ht (c) S */
	0x70,0x65,0x63,0x69,0x61,0x6C,0x69,0x78,	/* 1688: pecialix */
	0x20,0x52,0x65,0x73,0x65,0x61,0x72,0x63,	/* 1690:  Researc */
	0x68,0x20,0x4C,0x74,0x64,0x20,0x31,0x39,	/* 1698: h Ltd 19 */
	0x38,0x38,0x2D,0x31,0x39,0x39,0x38,0x0D,	/* 16A0: 88-1998. */
	0x0A,0x5A,0x32,0x38,0x30,0x20,0x44,0x6F,	/* 16A8: .Z280 Do */
	0x77,0x6E,0x6C,0x6F,0x61,0x64,0x20,0x43,	/* 16B0: wnload C */
	0x6F,0x64,0x65,0x20,0x56,0x65,0x72,0x73,	/* 16B8: ode Vers */
	0x69,0x6F,0x6E,0x20,0x31,0x2E,0x34,0x33,	/* 16C0: ion 1.43 */
	0x0D,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 16F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1700: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1708: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1710: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1718: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1720: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1728: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1730: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1738: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1740: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1748: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1750: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1758: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1760: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1768: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1770: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1778: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1780: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1788: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1790: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1798: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 17F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1800: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1808: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1810: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1818: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1820: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1828: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1830: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1838: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 1840: ........ */
	0x00,0x00,0x42,0x41,0x82,0x04,0x16,0x00,	/* 1848: ..BA... */
	0x41,0x00,0x41,0x04,0x82,0x03,0x41,0x03,	/* 1850: A.A..A. */
	0x82,0x02,0x4E,0x02,0x41,0x02,0x82,0x01,	/* 1858: .N.A.. */
	0x57,0x02,0x41,0x01,0x82,0x00,0x2B,0x00,	/* 1860: W.A..+. */
	0xA3,0x04,0x1B,0x00,0x51,0x00,0x51,0x04,	/* 1868: ...Q.Q. */
	0xA3,0x03,0x51,0x03,0xA3,0x02,0x62,0x02,	/* 1870: .Q..b. */
	0x51,0x02,0xA3,0x01,0x6D,0x02,0x51,0x01,	/* 1878: Q..m.Q. */
	0xA3,0x00,0x36,0x00,0x49,0x4E,0x00,0x00,	/* 1880: .6.IN.. */
	0x1E,0x01,0x18,0x02,0x1E,0x00,0xDD,0xD1,	/* 1888: ...... */
	0x86,0x18,0xF5,0xDD,0xE5,0x21,0x80,0x80,	/* 1890: .! */
	0x54,0xFD,0x7B,0x08,0x00,0xFD,0xED,0x3C,	/* 1898: T{..< */
	0x06,0x00,0xFE,0x24,0x28,0x04,0x06,0x04,	/* 18A0: ..$(... */
	0x18,0x02,0x06,0x00,0xFD,0x70,0x7F,0xCB,	/* 18A8: ....p */
	0x43,0x20,0x05,0xFD,0x7E,0x6A,0x18,0x03,	/* 18B0: C .~j.. */
	0xFD,0x7E,0x6B,0x4F,0xCB,0x7F,0xCA,0x56,	/* 18B8: ~kOV */
	0x19,0xE6,0x03,0xFD,0x77,0x68,0xED,0x3A,	/* 18C0: ..wh: */
	0x08,0x00,0xB0,0xCB,0x27,0x85,0x6F,0xDD,	/* 18C8: ..'o */
	0xED,0x3C,0x02,0x00,0xCB,0x43,0xC2,0x88,	/* 18D0: <..C */
	0x19,0xD9,0xDD,0x6E,0xAC,0xDD,0x7E,0xAD,	/* 18D8: .n~ */
	0x95,0x4F,0xE6,0x0C,0xFE,0x0C,0x28,0x06,	/* 18E0: O..(. */
	0x79,0xE6,0x30,0xCA,0xC1,0x1A,0xDD,0x7E,	/* 18E8: y0.~ */
	0xA9,0xE6,0x05,0xC2,0x6E,0x1A,0x79,0xCB,	/* 18F0: .n.y */
	0x7F,0x20,0x05,0xFE,0x0C,0xFA,0xB2,0x1A,	/* 18F8:  ... */
	0xDD,0x79,0xFD,0x77,0x63,0x2C,0xDD,0x79,	/* 1900: ywc,y */
	0xFD,0x77,0x63,0x2C,0xDD,0x79,0xFD,0x77,	/* 1908: wc,yw */
	0x63,0x2C,0xDD,0x79,0xFD,0x77,0x63,0x2C,	/* 1910: c,ywc, */
	0xDD,0x79,0xFD,0x77,0x63,0x2C,0xDD,0x79,	/* 1918: ywc,y */
	0xFD,0x77,0x63,0x2C,0xDD,0x79,0xFD,0x77,	/* 1920: wc,yw */
	0x63,0x2C,0xDD,0x79,0xFD,0x77,0x63,0x2C,	/* 1928: c,ywc, */
	0xDD,0x79,0xFD,0x77,0x63,0x2C,0xDD,0x79,	/* 1930: ywc,y */
	0xFD,0x77,0x63,0x2C,0xDD,0x79,0xFD,0x77,	/* 1938: wc,yw */
	0x63,0x2C,0xDD,0x79,0xFD,0x77,0x63,0x2C,	/* 1940: c,ywc, */
	0xDD,0x75,0xAC,0xD9,0x79,0xE6,0x3F,0xCB,	/* 1948: uy? */
	0x43,0x20,0x30,0xFD,0x77,0x6A,0x62,0x2E,	/* 1950: C 0wjb. */
	0x80,0xCB,0x50,0x28,0x05,0x06,0x00,0xC3,	/* 1958: P(... */
	0xAC,0x18,0xDD,0xED,0x3A,0x02,0x00,0xDD,	/* 1960: .:.. */
	0x66,0xFF,0xFD,0xED,0xF7,0x80,0x00,0xC2,	/* 1968: f. */
	0x98,0x18,0xDD,0xE1,0xF1,0xED,0x55,0xFD,	/* 1970: .U */
	0x7E,0x62,0xED,0x0B,0x2C,0x10,0xF8,0x18,	/* 1978: ~b.,.. */
	0x2A,0x49,0x4E,0xFD,0x77,0x6B,0x18,0xCE,	/* 1980: *INwk. */
	0xD9,0xFD,0x7E,0x43,0xFE,0x07,0x28,0x57,	/* 1988: ~C.(W */
	0x26,0x01,0xDD,0x7E,0xAB,0xDD,0x6E,0xAA,	/* 1990: &.~n */
	0x95,0x3D,0x4F,0xFD,0x46,0x0E,0x58,0xCB,	/* 1998: =OF.X */
	0x7F,0x20,0x04,0xB8,0xFA,0xD3,0x19,0x16,	/* 19A0:  ... */
	0x00,0x18,0xCC,0xDD,0x3E,0xC2,0x05,0x01,	/* 19A8: ..>.. */
	0x7A,0xFE,0x00,0x20,0x2A,0xDD,0xCB,0xA8,	/* 19B0: z. * */
	0x5E,0x28,0x10,0x79,0xCB,0x7F,0x20,0x0B,	/* 19B8: ^(.y . */
	0xFE,0x40,0xFA,0xCB,0x19,0x93,0xFE,0x40,	/* 19C0: @.@ */
	0xFA,0xF8,0x19,0xDD,0x75,0xAA,0x26,0x00,	/* 19C8: .u&. */
	0xC3,0x4B,0x19,0xFE,0x00,0x28,0x09,0x16,	/* 19D0: K..(.. */
	0x01,0x78,0x91,0x5F,0x41,0x18,0x98,0x43,	/* 19D8: .x_A.C */
	0xFD,0x7E,0x62,0x10,0xFB,0x18,0xE4,0xDD,	/* 19E0: ~b.. */
	0xCB,0xB9,0xC6,0xDD,0x3E,0xC3,0x05,0x01,	/* 19E8: >.. */
	0xFD,0x7E,0x62,0xFD,0x7E,0x62,0x18,0xD6,	/* 19F0: ~b~b. */
	0xDD,0xCB,0xBA,0x5E,0x28,0x1F,0xDD,0xCB,	/* 19F8: ^(. */
	0xA8,0x6E,0x20,0x19,0xFD,0x7E,0x05,0xFE,	/* 1A00: n .~. */
	0x00,0x20,0x0A,0xFD,0x36,0x05,0x24,0xDD,	/* 1A08: . .6.$ */
	0xCB,0xA8,0xEE,0x18,0x08,0xDD,0xCB,0xA8,	/* 1A10: .. */
	0xFE,0xDD,0xCB,0xA8,0xF6,0xDD,0xCB,0xA8,	/* 1A18:  */
	0xE6,0xDD,0xCB,0xB4,0x7E,0x28,0x19,0xDD,	/* 1A20: ~(. */
	0x7E,0xC4,0xE6,0x08,0x20,0x06,0xFD,0x36,	/* 1A28: ~. .6 */
	0x6C,0x00,0x18,0x0C,0xFD,0x7E,0x15,0xE6,	/* 1A30: l...~. */
	0xF0,0xFD,0x77,0x15,0xFD,0x36,0x6D,0x00,	/* 1A38: w.6m. */
	0xDD,0xCB,0xBA,0x76,0x28,0x85,0xDD,0x7E,	/* 1A40: v(~ */
	0xC4,0xE6,0x08,0x20,0x0E,0xFD,0x7E,0x15,	/* 1A48: . .~. */
	0xE6,0xF0,0xFD,0x77,0x15,0xFD,0x36,0x6D,	/* 1A50: w.6m */
	0x00,0x18,0x04,0xFD,0x36,0x6C,0x00,0xDD,	/* 1A58: ...6l. */
	0xCB,0xA8,0xEE,0xDD,0xCB,0xA8,0xBE,0xDD,	/* 1A60:  */
	0xCB,0xA8,0xB6,0xC3,0xCB,0x19,0xDD,0xCB,	/* 1A68: . */
	0xA9,0x46,0x28,0x13,0xDD,0xCB,0xA9,0xCE,	/* 1A70: F(. */
	0xDD,0xCB,0xA9,0x86,0xFD,0x7E,0x06,0xE6,	/* 1A78: ~. */
	0xF9,0xFD,0x77,0x06,0xC3,0x48,0x19,0x79,	/* 1A80: w.H.y */
	0xCB,0x7F,0x20,0x0C,0xFE,0x0C,0xF2,0x98,	/* 1A88:  .. */
	0x1A,0xFE,0x00,0x28,0x52,0x47,0x18,0x02,	/* 1A90: ..(RG.. */
	0x06,0x0C,0xDD,0x79,0xFE,0x0A,0x28,0x08,	/* 1A98: ..y.(. */
	0xFD,0x77,0x63,0x2C,0x10,0xF4,0x18,0x3F,	/* 1AA0: wc,..? */
	0xFD,0x36,0x63,0x0D,0xFD,0x36,0x63,0x0A,	/* 1AA8: 6c.6c. */
	0x18,0xF1,0xFE,0x00,0x28,0x31,0x47,0xDD,	/* 1AB0: ..(1G */
	0x79,0xFD,0x77,0x63,0x2C,0x10,0xF8,0x18,	/* 1AB8: ywc,.. */
	0x26,0x79,0xE6,0xC0,0xFE,0x40,0x20,0x13,	/* 1AC0: &y@ . */
	0xDD,0xCB,0xA9,0x5E,0xCA,0xEE,0x18,0xDD,	/* 1AC8: ^. */
	0xCB,0xA9,0x9E,0xDD,0x3E,0xC3,0x05,0x01,	/* 1AD0: >.. */
	0xC3,0xEE,0x18,0xFE,0xC0,0xC2,0xEE,0x18,	/* 1AD8: .. */
	0xDD,0xCB,0xA9,0xDE,0xC3,0xEE,0x18,0xFD,	/* 1AE0: . */
	0x7E,0x06,0xE6,0xF9,0xFD,0x77,0x06,0xDD,	/* 1AE8: ~.w. */
	0xCB,0xA8,0x86,0xC3,0x48,0x19,0xDD,0xD1,	/* 1AF0: H. */
	0x86,0x18,0xF5,0xC5,0xD5,0xE5,0xFD,0xE5,	/* 1AF8: . */
	0xDD,0xE5,0x21,0x80,0x80,0x54,0xFD,0x7B,	/* 1B00: !T{ */
	0x08,0x00,0xFD,0xED,0x3C,0x06,0x00,0xFE,	/* 1B08: ..<.. */
	0x24,0x28,0x04,0x06,0x04,0x18,0x02,0x06,	/* 1B10: $(...... */
	0x00,0x78,0xED,0x3B,0x1A,0x00,0xFD,0x70,	/* 1B18: .x;..p */
	0x7F,0xFD,0x7E,0x69,0xCB,0x7F,0x28,0x2C,	/* 1B20: ~i(, */
	0xFD,0x5E,0x68,0xE6,0x03,0xFD,0x77,0x68,	/* 1B28: ^h.wh */
	0xED,0x3A,0x0A,0x00,0xB0,0xCB,0x27,0x85,	/* 1B30: :..' */
	0x6F,0xED,0x26,0xE5,0xDD,0xE1,0xC5,0xCD,	/* 1B38: o& */
	0x04,0x09,0xDD,0x3E,0xC3,0x05,0x01,0xDD,	/* 1B40: ..>.. */
	0xCB,0xB9,0xCE,0xFD,0x7E,0x69,0xE6,0x3F,	/* 1B48: ~i? */
	0xFD,0x77,0x69,0xC1,0x62,0x2E,0x80,0xCB,	/* 1B50: wib. */
	0x50,0x28,0x04,0x06,0x00,0x18,0xBA,0xE5,	/* 1B58: P(.... */
	0xDD,0xE1,0xDD,0x66,0x01,0xFD,0xED,0xF7,	/* 1B60: f. */
	0x80,0x00,0x20,0x99,0xDD,0xE1,0xFD,0xE1,	/* 1B68: .  */
	0xE1,0xD1,0xC1,0xF1,0xED,0x55,0xE5,0x21,	/* 1B70: U! */
	0xE8,0x03,0x2B,0xFD,0xED,0xF7,0x00,0x00,	/* 1B78: .+.. */
	0x20,0xF8,0xE1,0xC9,0xCD,0xF3,0x08,0xDD,	/* 1B80:  . */
	0x7E,0xC7,0xFE,0x01,0xC2,0x28,0x1C,0xFD,	/* 1B88: ~.(. */
	0x36,0x6F,0x03,0xCD,0x76,0x1B,0xFD,0x7E,	/* 1B90: 6o.v.~ */
	0x6F,0xE6,0x20,0x20,0x07,0xDD,0x36,0xC8,	/* 1B98: o  .6 */
	0x09,0xC3,0x28,0x1C,0xFD,0x36,0x6F,0x02,	/* 1BA0: .(.6o. */
	0xCD,0x76,0x1B,0xFD,0x7E,0x6F,0xE6,0x20,	/* 1BA8: v.~o  */
	0x28,0x06,0xDD,0x36,0xC8,0x0A,0x18,0x70,	/* 1BB0: (.6..p */
	0xFD,0x36,0x6F,0x06,0xCD,0x76,0x1B,0xFD,	/* 1BB8: 6o.v. */
	0x7E,0x6F,0xE6,0x10,0x20,0x06,0xDD,0x36,	/* 1BC0: ~o. .6 */
	0xC8,0x0B,0x18,0x5C,0xFD,0x36,0x6F,0x02,	/* 1BC8: ..\6o. */
	0xCD,0x76,0x1B,0xFD,0x7E,0x6F,0xE6,0x20,	/* 1BD0: v.~o  */
	0x28,0x06,0xDD,0x36,0xC8,0x0A,0x18,0x48,	/* 1BD8: (.6..H */
	0x06,0x08,0xFD,0x36,0x6F,0x02,0xCD,0x76,	/* 1BE0: ..6o.v */
	0x1B,0xFD,0x36,0x6F,0x00,0xCD,0x76,0x1B,	/* 1BE8: .6o.v. */
	0xFD,0x7E,0x6F,0xE6,0x80,0x20,0x28,0x10,	/* 1BF0: ~o (. */
	0xE9,0xFD,0x36,0x6F,0x02,0xCD,0x76,0x1B,	/* 1BF8: 6o.v. */
	0xFD,0x36,0x6F,0x00,0x21,0xE8,0x03,0xFD,	/* 1C00: 6o.!. */
	0x7E,0x6F,0xE6,0x40,0x20,0x16,0x2B,0xFD,	/* 1C08: ~o@ .+ */
	0xED,0xF7,0x00,0x00,0x20,0xF1,0xDD,0x36,	/* 1C10: .. 6 */
	0xC8,0x0D,0xDD,0x77,0xB8,0x18,0x09,0xDD,	/* 1C18: .w.. */
	0x70,0xC8,0x18,0x04,0xDD,0x36,0xC8,0x00,	/* 1C20: p..6. */
	0xCD,0x76,0x1B,0xFD,0x36,0x6F,0x02,0xCD,	/* 1C28: v.6o. */
	0x76,0x1B,0xFD,0x36,0x6F,0x00,0xFD,0x36,	/* 1C30: v.6o.6 */
	0x05,0x80,0xDD,0x36,0xAE,0x00,0xC9,0xCD,	/* 1C38: .6. */
	0xF3,0x08,0xDD,0xCB,0xA9,0x4E,0x20,0x23,	/* 1C40: .N # */
	0xDD,0xCB,0xA9,0xC6,0xDD,0x7E,0xC7,0xFE,	/* 1C48: ~ */
	0x01,0x28,0x0F,0xFD,0x7E,0x06,0xF6,0x02,	/* 1C50: .(.~.. */
	0xE6,0xFB,0xFD,0x77,0x06,0x26,0x00,0xC3,	/* 1C58: w.&. */
	0x12,0x0D,0xFD,0x36,0x06,0x84,0x26,0x00,	/* 1C60: ..6.&. */
	0xC3,0x12,0x0D,0xFD,0x7E,0x06,0xE6,0xF9,	/* 1C68: ..~. */
	0xFD,0x77,0x06,0xFD,0x7E,0x09,0xF6,0x20,	/* 1C70: w.~.  */
	0xFD,0x77,0x09,0xFD,0x7E,0x50,0xFD,0x77,	/* 1C78: w.~Pw */
	0x65,0xFD,0x36,0x63,0x00,0xFD,0x36,0x63,	/* 1C80: e6c.6c */
	0x81,0xFD,0x36,0x12,0x02,0xDD,0x36,0xAE,	/* 1C88: 6..6 */
	0x12,0xDD,0x3E,0xC3,0x05,0x01,0x26,0x00,	/* 1C90: .>..&. */
	0xC3,0x12,0x0D,0xCD,0xF3,0x08,0xDD,0x7E,	/* 1C98: ...~ */
	0xC5,0xFE,0x01,0x28,0x27,0xFD,0x7E,0x12,	/* 1CA0: .('~. */
	0xFE,0x00,0x28,0x05,0x26,0x00,0xC3,0x12,	/* 1CA8: .(.&.. */
	0x0D,0xFD,0x7E,0x50,0xFD,0x77,0x65,0xFD,	/* 1CB0: .~Pwe */
	0x36,0x63,0x00,0xFD,0x36,0x63,0x83,0xFD,	/* 1CB8: 6c.6c */
	0x36,0x12,0x02,0xDD,0x36,0xC5,0x01,0x26,	/* 1CC0: 6..6.& */
	0x00,0xC3,0x12,0x0D,0xFD,0x7E,0x12,0xFE,	/* 1CC8: ...~. */
	0x00,0x28,0x05,0x26,0x00,0xC3,0x12,0x0D,	/* 1CD0: .(.&... */
	0xFD,0x7E,0x06,0xF6,0x04,0xE6,0xFD,0xFD,	/* 1CD8: ~.. */
	0x77,0x06,0xFD,0x7E,0x09,0xE6,0xDF,0xFD,	/* 1CE0: w.~. */
	0x77,0x09,0xDD,0x36,0xAE,0x00,0xDD,0x3E,	/* 1CE8: w.6.> */
	0xC3,0x05,0x01,0xDD,0x36,0xC5,0x00,0x26,	/* 1CF0: ..6.& */
	0x00,0xC3,0x12,0x0D,0x26,0x00,0xDD,0x7E,	/* 1CF8: ...&.~ */
	0xAC,0xDD,0x96,0xAD,0x28,0x04,0xF1,0xC3,	/* 1D00: (. */
	0x23,0x0D,0xCD,0xF3,0x08,0xDD,0x7E,0xBF,	/* 1D08: #..~ */
	0xFE,0x01,0x28,0x50,0xDD,0xCB,0xA9,0x4E,	/* 1D10: .(PN */
	0x28,0x29,0xCD,0xF3,0x08,0xED,0x2C,0xA4,	/* 1D18: ()., */
	0xFF,0xDD,0x7E,0xA7,0xFE,0x04,0xF2,0x36,	/* 1D20: ~.6 */
	0x1D,0xFD,0x1D,0x1C,0x00,0x20,0x35,0xF6,	/* 1D28: .... 5 */
	0x10,0xFD,0x77,0x7F,0x18,0x2E,0xFD,0x1D,	/* 1D30: .w... */
	0x1D,0x00,0x20,0x28,0xF6,0x40,0xFD,0x77,	/* 1D38: .. (@w */
	0x7F,0x18,0x21,0xDD,0x7E,0xC9,0xFE,0x01,	/* 1D40: .!~. */
	0x20,0x10,0xDD,0xCB,0xA9,0xC6,0xDD,0x7E,	/* 1D48:  .~ */
	0xC7,0xFE,0x01,0x28,0x0A,0xFD,0x36,0x06,	/* 1D50: .(.6. */
	0x92,0xC9,0xDD,0xCB,0xA9,0xCE,0xC9,0xFD,	/* 1D58:  */
	0x36,0x06,0x94,0xC9,0xDD,0x36,0xAA,0x00,	/* 1D60: 6.6. */
	0xDD,0x36,0xAB,0x00,0xDD,0x36,0xAC,0x00,	/* 1D68: 6.6. */
	0xDD,0x36,0xAD,0x00,0xDD,0x36,0xC9,0x00,	/* 1D70: 6.6. */
	0xCD,0xF3,0x08,0xFD,0x7E,0x05,0xFE,0x00,	/* 1D78: .~.. */
	0xC0,0xDD,0xCB,0xA9,0x8E,0xDD,0x7E,0xC7,	/* 1D80: ~ */
	0xFE,0x01,0x20,0x06,0xFD,0x36,0x05,0x14,	/* 1D88: . .6.. */
	0x18,0x32,0xDD,0xCB,0xB7,0x46,0x20,0x11,	/* 1D90: .2F . */
	0xDD,0x7E,0xC4,0xE6,0x08,0x20,0x06,0xFD,	/* 1D98: ~. . */
	0x36,0x6C,0x00,0x18,0x04,0xFD,0x36,0x6D,	/* 1DA0: 6l...6m */
	0x00,0xDD,0xCB,0xB7,0x4E,0x20,0x11,0xDD,	/* 1DA8: .N . */
	0x7E,0xC4,0xE6,0x08,0x20,0x06,0xFD,0x36,	/* 1DB0: ~. .6 */
	0x6D,0x00,0x18,0x04,0xFD,0x36,0x6C,0x00,	/* 1DB8: m...6l. */
	0xFD,0x36,0x05,0x80,0xFD,0x36,0x06,0x00,	/* 1DC0: 6.6.. */
	0xDD,0x36,0xBF,0x01,0xDD,0x36,0xAE,0x10,	/* 1DC8: 6.6. */
	0xDD,0x3E,0xC3,0x05,0x01,0xC9,0x3A,0x49,	/* 1DD0: >..:I */
	0x00,0xFE,0x01,0x28,0x0B,0xFD,0x1E,0x06,	/* 1DD8: ..(... */
	0x00,0x00,0xFD,0x1E,0x07,0x00,0x02,0xC9,	/* 1DE0: ...... */
	0xFD,0x1E,0x06,0x00,0x09,0xFD,0x1E,0x07,	/* 1DE8: ...... */
	0x00,0x00,0xC9,0x02,0x44,0x02,0x44,0x02,	/* 1DF0: ...D.D. */
	0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,	/* 1DF8: @.@.@.@. */
	0x44,0x02,0x44,0x02,0x44,0x02,0x44,0x02,	/* 1E00: D.D.D.D. */
	0x44,0x02,0x40,0x02,0x40,0x02,0x44,0x02,	/* 1E08: D.@.@.D. */
	0x44,0x20,0x1E,0x44,0x03,0x44,0x02,0x44,	/* 1E10: D .D.D.D */
	0x02,0x44,0x01,0x40,0x20,0x14,0x44,0x03,	/* 1E18: .D.@ .D. */
	0x40,0x12,0x44,0x05,0x40,0x03,0x40,0x16,	/* 1E20: @.D.@.@. */
	0x44,0x02,0x40,0x07,0x44,0x0A,0x40,0x05,	/* 1E28: D.@.D.@. */
	0x40,0x11,0x40,0x20,0x03,0x40,0x18,0x44,	/* 1E30: @.@ .@.D */
	0x12,0x44,0x09,0x44,0x02,0x44,0x20,0x46,	/* 1E38: .D.D.D F */
	0x40,0x17,0x44,0x06,0x44,0x06,0x44,0x03,	/* 1E40: @.D.D.D. */
	0x44,0x04,0x44,0x0D,0x44,0x02,0x44,0x06,	/* 1E48: D.D.D.D. */
	0x44,0x02,0x44,0x20,0x18,0x40,0x1F,0x44,	/* 1E50: D.D .@.D */
	0x05,0x44,0x07,0x44,0x18,0x44,0x20,0x0C,	/* 1E58: .D.D.D . */
	0x44,0x06,0x44,0x02,0x44,0x01,0x44,0x0F,	/* 1E60: D.D.D.D. */
	0x44,0x15,0x44,0x08,0x44,0x03,0x44,0x0D,	/* 1E68: D.D.D.D. */
	0x44,0x1D,0x44,0x01,0x44,0x14,0x40,0x08,	/* 1E70: D.D.D.@. */
	0x40,0x03,0x44,0x06,0x40,0x03,0x44,0x06,	/* 1E78: @.D.@.D. */
	0x40,0x03,0x44,0x06,0x40,0x03,0x44,0x0F,	/* 1E80: @.D.@.D. */
	0x44,0x04,0x44,0x0F,0x44,0x04,0x44,0x03,	/* 1E88: D.D.D.D. */
	0x44,0x20,0x34,0x44,0x04,0x44,0x11,0x44,	/* 1E90: D 4D.D.D */
	0x04,0x44,0x14,0x44,0x04,0x44,0x02,0x40,	/* 1E98: .D.D.D.@ */
	0x1B,0x44,0x0A,0x40,0x03,0x44,0x05,0x40,	/* 1EA0: .D.@.D.@ */
	0x05,0x44,0x0F,0x40,0x02,0x44,0x02,0x40,	/* 1EA8: .D.@.D.@ */
	0x20,0x0E,0x44,0x18,0x40,0x10,0x44,0x05,	/* 1EB0:  .D.@.D. */
	0x44,0x05,0x44,0x0B,0x44,0x14,0x44,0x03,	/* 1EB8: D.D.D.D. */
	0x44,0x08,0x44,0x02,0x44,0x10,0x44,0x44,	/* 1EC0: D.D.D.DD */
	0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,	/* 1EC8: DDDDDDDD */
	0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,	/* 1ED0: DDDDDDDD */
	0x40,0x40,0x44,0x44,0x40,0x40,0x20,0x00,	/* 1ED8: @@DD@@ . */
	0x44,0x20,0x01,0x44,0x10,0x44,0x10,0x44,	/* 1EE0: D .D.D.D */
	0x05,0x44,0x20,0x04,0x44,0x14,0x44,0x06,	/* 1EE8: .D .D.D. */
	0x44,0x0A,0x44,0x04,0x44,0x04,0x44,0x05,	/* 1EF0: D.D.D.D. */
	0x44,0x03,0x44,0x0F,0x44,0x0B,0x44,0x03,	/* 1EF8: D.D.D.D. */
	0x44,0x03,0x44,0x03,0x44,0x0C,0x44,0x05,	/* 1F00: D.D.D.D. */
	0x44,0x03,0x44,0x05,0x44,0x0E,0x44,0x06,	/* 1F08: D.D.D.D. */
	0x44,0x0B,0x44,0x07,0x44,0x02,0x44,0x03,	/* 1F10: D.D.D.D. */
	0x44,0x06,0x44,0x0D,0x44,0x06,0x44,0x02,	/* 1F18: D.D.D.D. */
	0x44,0x03,0x44,0x05,0x44,0x20,0x02,0x44,	/* 1F20: D.D.D .D */
	0x03,0x44,0x05,0x44,0x16,0x44,0x1A,0x44,	/* 1F28: .D.D.D.D */
	0x0E,0x44,0x16,0x44,0x03,0x44,0x05,0x44,	/* 1F30: .D.D.D.D */
	0x04,0x44,0x19,0x44,0x04,0x44,0x01,0x44,	/* 1F38: .D.D.D.D */
	0x03,0x44,0x05,0x44,0x05,0x44,0x06,0x44,	/* 1F40: .D.D.D.D */
	0x02,0x44,0x0C,0x44,0x05,0x44,0x09,0x44,	/* 1F48: .D.D.D.D */
	0x0A,0x44,0x0B,0x44,0x08,0x44,0x20,0x09,	/* 1F50: .D.D.D . */
	0x44,0x12,0x44,0x02,0x44,0x20,0x1C,0x44,	/* 1F58: D.D.D .D */
	0x20,0x2E,0x44,0x11,0x44,0x20,0x28,0x44,	/* 1F60:  .D.D (D */
	0x13,0x44,0x09,0x44,0x12,0x40,0x03,0x40,	/* 1F68: .D.D.@.@ */
	0x20,0x01,0x40,0x03,0x40,0x21,0x4F,0x44,	/* 1F70:  .@.@!OD */
	0x20,0x4B,0x44,0x20,0x34,0x40,0x03,0x44,	/* 1F78:  KD 4@.D */
	0x0D,0x40,0x08,0x44,0x08,0x44,0x03,0x44,	/* 1F80: .@.D.D.D */
	0x01,0x44,0x03,0x44,0x01,0x40,0x03,0x44,	/* 1F88: .D.D.@.D */
	0x01,0x40,0x03,0x44,0x03,0x44,0x01,0x44,	/* 1F90: .@.D.D.D */
	0x0A,0x44,0x0B,0x44,0x15,0x40,0x16,0x40,	/* 1F98: .D.D.@.@ */
	0x06,0x44,0x0E,0x40,0x06,0x40,0x04,0x44,	/* 1FA0: .D.@.@.D */
	0x44,0x44,0x44,0x44,0x44,0x40,0x40,0x44,	/* 1FA8: DDDDD@@D */
	0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,	/* 1FB0: DDDDDDDD */
	0x44,0x0F,0x44,0x06,0x44,0x05,0x44,0x20,	/* 1FB8: D.D.D.D  */
	0x08,0x44,0x20,0x39,0x44,0x03,0x44,0x04,	/* 1FC0: .D 9D.D. */
	0x44,0x0A,0x44,0x05,0x44,0x0D,0x44,0x20,	/* 1FC8: D.D.D.D  */
	0x04,0x40,0x13,0x40,0x20,0x4A,0x40,0x21,	/* 1FD0: .@.@ J@! */
	0x2E,0x40,0x14,0x44,0x06,0x40,0x15,0x44,	/* 1FD8: .@.D.@.D */
	0x06,0x40,0x20,0x7F,0x40,0x20,0x22,0x40,	/* 1FE0: .@ @ "@ */
	0x20,0x61,0x40,0x20,0x25,0x40,0x20,0x3B,	/* 1FE8:  a@ %@ ; */
	0x40,0x04,0x40,0x20,0xE1,0x40,0x1F,0x40,	/* 1FF0: @.@ @.@ */
	0x06,0x44,0x03,0x40,0x05,0x40,0x20,0x13,	/* 1FF8: .D.@.@ . */
	0x44,0x1D,0x40,0x20,0x0E,0x44,0x02,0x40,	/* 2000: D.@ .D.@ */
	0x02,0x40,0x03,0x44,0x20,0x05,0x40,0x02,	/* 2008: .@.D .@. */
	0x40,0x03,0x44,0x01,0x44,0x1D,0x44,0x20,	/* 2010: @.D.D.D  */
	0x2B,0x44,0x07,0x40,0x07,0x44,0x01,0x40,	/* 2018: +D.@.D.@ */
	0x06,0x40,0x09,0x40,0x04,0x40,0x13,0x40,	/* 2020: .@.@.@.@ */
	0x01,0x44,0x20,0x03,0x44,0x0B,0x40,0x0A,	/* 2028: .D .D.@. */
	0x40,0x12,0x40,0x05,0x44,0x20,0x03,0x40,	/* 2030: @.@.D .@ */
	0x06,0x44,0x04,0x44,0x04,0x44,0x16,0x40,	/* 2038: .D.D.D.@ */
	0x22,0xEE,0x44,0x20,0x0D,0x44,0x16,0x44,	/* 2040: "D .D.D */
	0x13,0x44,0x06,0x44,0x08,0x44,0x20,0x40,	/* 2048: .D.D.D @ */
	0x44,0x0E,0x44,0x20,0x13,0x44,0x06,0x40,	/* 2050: D.D .D.@ */
	0x14,0x44,0x04,0x44,0x06,0x44,0x1A,0x40,	/* 2058: .D.D.D.@ */
	0x20,0x5D,0x44,0x17,0x44,0x08,0x44,0x20,	/* 2060:  ]D.D.D  */
	0x1C,0x44,0x06,0x40,0x02,0x44,0x03,0x44,	/* 2068: .D.@.D.D */
	0x05,0x44,0x0D,0x44,0x02,0x44,0x20,0x26,	/* 2070: .D.D.D & */
	0x40,0x02,0x40,0x20,0x1F,0x40,0x06,0x44,	/* 2078: @.@ .@.D */
	0x05,0x44,0x0C,0x44,0x05,0x44,0x12,0x44,	/* 2080: .D.D.D.D */
	0x12,0x44,0x14,0x44,0x05,0x44,0x0E,0x44,	/* 2088: .D.D.D.D */
	0x20,0x09,0x44,0x05,0x44,0x0E,0x40,0x1E,	/* 2090:  .D.D.@. */
	0x40,0x07,0x40,0x20,0x08,0x40,0x04,0x40,	/* 2098: @.@ .@.@ */
	0x01,0x40,0x11,0x40,0x19,0x40,0x0A,0x40,	/* 20A0: .@.@.@.@ */
	0x18,0x40,0x08,0x40,0x0C,0x40,0x01,0x40,	/* 20A8: .@.@.@.@ */
	0x0E,0x40,0x0A,0x44,0x20,0x30,0x40,0x20,	/* 20B0: .@.D 0@  */
	0x37,0x40,0x03,0x40,0x00,0x00           	/* 20B8: 7@.@..   */

};
int si2_z280_dsize = sizeof(si2_z280_download);		/* 0x20BE (8382) */

unsigned short si2_z280_downloadaddr = 0x0000;

/* End of SI2_Z280.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\read.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code that is very specific to read
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabReadFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialUpdateReadByIsr(
    IN PVOID Context
    );

ULONG
SerialGetCharsFromIntBuffer(
    PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    );

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    );

NTSTATUS
SerialResizeBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    );

ULONG
SerialMoveToNewIntBuffer(
    PPORT_DEVICE_EXTENSION pPort,
    PUCHAR NewBuffer
    );

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    );


NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for reading.  It validates the parameters
    for the read request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialRead dispatch entry for: %x\n",Irp));
 	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
       
        
    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length read.  If it is zero length
    // then we are already done!
    //

    SpxDbgMsg(SERDIAG1,("Read length: %d\n",IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length));
        
    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length) 
	{

        //
        // Well it looks like we actually have to do some
        // work.  Put the read on the queue so that we can
        // process it when our previous reads are done.
        //

        return SerialStartOrQueue(
                   pPort,
                   Irp,
                   &pPort->ReadQueue,
                   &pPort->CurrentReadIrp,
                   SerialStartRead
                   );

    } 
	else 
	{

        Irp->IoStatus.Status = STATUS_SUCCESS;
        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,11);
#endif

		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
		IoCompleteRequest(Irp, 0);

        return STATUS_SUCCESS;

    }

}

NTSTATUS
SerialStartRead(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.

Arguments:

    pPort - Simply a pointer to the serial device extension.

Return Value:

    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.

--*/

{

    SERIAL_UPDATE_CHAR updateChar;

    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;


    updateChar.pPort = pPort;

    do {

        //
        // Check to see if this is a resize request.  If it is
        // then go to a routine that specializes in that.
        //

        if (IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)
            ->MajorFunction != IRP_MJ_READ) {

            NTSTATUS localStatus = SerialResizeBuffer(pPort);

            if (!setFirstStatus) {

                firstStatus = localStatus;
                setFirstStatus = TRUE;

            }

        } else {

            pPort->NumberNeededForRead =
                IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)
                    ->Parameters.Read.Length;

            //
            // Calculate the timeout value needed for the
            // request.  Note that the values stored in the
            // timeout record are in milliseconds.
            //

            useTotalTimer = FALSE;
            returnWithWhatsPresent = FALSE;
            os2ssreturn = FALSE;
            crunchDownToOne = FALSE;
            useIntervalTimer = FALSE;


            //
            // Always initialize the timer objects so that the
            // completion code can tell when it attempts to
            // cancel the timers whether the timers had ever
            // been set.
            //

            KeInitializeTimer(&pPort->ReadRequestTotalTimer);
            KeInitializeTimer(&pPort->ReadRequestIntervalTimer);

            //
            // We get the *current* timeout values to use for timing
            // this read.
            //

            KeAcquireSpinLock(
                &pPort->ControlLock,
                &controlIrql
                );

            timeoutsForIrp = pPort->Timeouts;

            KeReleaseSpinLock(
                &pPort->ControlLock,
                controlIrql
                );

            //
            // Calculate the interval timeout for the read.
            //

            if (timeoutsForIrp.ReadIntervalTimeout &&
                (timeoutsForIrp.ReadIntervalTimeout !=
                 MAXULONG)) {

                useIntervalTimer = TRUE;

                pPort->IntervalTime = RtlEnlargedUnsignedMultiply(
                                             timeoutsForIrp.ReadIntervalTimeout,
                                             10000
                                             );


                if (RtlLargeIntegerGreaterThanOrEqualTo(
                        pPort->IntervalTime,
                        pPort->CutOverAmount
                        )) {

                    pPort->IntervalTimeToUse =
                        &pPort->LongIntervalAmount;

                } else {

                    pPort->IntervalTimeToUse =
                        &pPort->ShortIntervalAmount;

                }

            }

            if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {

                //
                // We need to do special return quickly stuff here.
                //
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                //
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                //
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.
                //

                if (!timeoutsForIrp.ReadTotalTimeoutConstant &&
                    !timeoutsForIrp.ReadTotalTimeoutMultiplier) {

                    returnWithWhatsPresent = TRUE;

                } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            != MAXULONG)) {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            == MAXULONG)) {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    crunchDownToOne = TRUE;
                    multiplierVal = 0;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }

            } else {

                //
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.
                //

                if (timeoutsForIrp.ReadTotalTimeoutMultiplier ||
                    timeoutsForIrp.ReadTotalTimeoutConstant) {

                    //
                    // We have some timer values to calculate.
                    //

                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }

            }

            if (useTotalTimer) {

                totalTime = RtlEnlargedUnsignedMultiply(
                                pPort->NumberNeededForRead,
                                multiplierVal
                                );

                totalTime = RtlLargeIntegerAdd(
                                totalTime,
                                RtlConvertUlongToLargeInteger(
                                    constantVal
                                    )
                                );

                totalTime = RtlExtendedIntegerMultiply(
                                totalTime,
                                -10000
                                );

            }


            //
            // We do this copy in the hope of getting most (if not
            // all) of the characters out of the interrupt buffer.
            //
            // Note that we need to protect this operation with a
            // spinlock since we don't want a purge to hose us.
            //

            KeAcquireSpinLock(
                &pPort->ControlLock,
                &controlIrql
                );

            updateChar.CharsCopied = SerialGetCharsFromIntBuffer(pPort);

            //
            // See if we have any cause to return immediately.
            //

            if (returnWithWhatsPresent || (!pPort->NumberNeededForRead) ||
                (os2ssreturn &&
                 pPort->CurrentReadIrp->IoStatus.Information)) {

                //
                // We got all we needed for this read.
                // Update the number of characters in the
                // interrupt read buffer.
                //

		Slxos_SyncExec(pPort,SerialUpdateInterruptBuffer,&updateChar,0x18);

                KeReleaseSpinLock(
                    &pPort->ControlLock,
                    controlIrql
                    );

                pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                if (!setFirstStatus) {

                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;

                }

            } else {

                //
                // The irp might go under control of the isr.  It
                // won't hurt to initialize the reference count
                // right now.
                //

                SERIAL_INIT_REFERENCE(pPort->CurrentReadIrp);

                IoAcquireCancelSpinLock(&oldIrql);

                //
                // We need to see if this irp should be cancelled.
                //

                if (pPort->CurrentReadIrp->Cancel) {

                    IoReleaseCancelSpinLock(oldIrql);
                    KeReleaseSpinLock(
                        &pPort->ControlLock,
                        controlIrql
                        );
                    pPort->CurrentReadIrp->IoStatus.Status =
                        STATUS_CANCELLED;
                    pPort->CurrentReadIrp->IoStatus.Information = 0;

                    if (!setFirstStatus) {

                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;

                    }

                } else {

                    //
                    // If we are supposed to crunch the read down to
                    // one character, then update the read length
                    // in the irp and truncate the number needed for
                    // read down to one. Note that if we are doing
                    // this crunching, then the information must be
                    // zero (or we would have completed above) and
                    // the number needed for the read must still be
                    // equal to the read length.
                    //

                    if (crunchDownToOne) {

                        ASSERT(
                            (!pPort->CurrentReadIrp->IoStatus.Information)
                            &&
                            (pPort->NumberNeededForRead ==
                                IoGetCurrentIrpStackLocation(
                                    pPort->CurrentReadIrp
                                    )->Parameters.Read.Length)
                            );

                        pPort->NumberNeededForRead = 1;
                        IoGetCurrentIrpStackLocation(
                            pPort->CurrentReadIrp
                            )->Parameters.Read.Length = 1;

                    }

                    //
                    // We still need to get more characters for this read.
                    // Synchronize with the isr so that we can update the
                    // number of characters and if necessary it will have the
                    // isr switch to copying into the user's buffer.
                    //

		Slxos_SyncExec(pPort,SerialUpdateAndSwitchToUser,&updateChar,0x19);

		if (!updateChar.Completed) {

                        //
                        // The irp still isn't complete.  The
                        // completion routines will end up reinvoking
                        // this routine.  So we simply leave.
                        //
                        // First though we should start off the total
                        // timer for the read and increment the reference
                        // count that the total timer has on the current
                        // irp.  Note that this is safe, because even if
                        // the io has been satisfied by the isr it can't
                        // complete yet because we still own the cancel
                        // spinlock.
                        //

                        if (useTotalTimer) {

                            SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

                            KeSetTimer(
                                &pPort->ReadRequestTotalTimer,
                                totalTime,
                                &pPort->TotalReadTimeoutDpc
                                );

                        }

                        if (useIntervalTimer) {

                            SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

                            KeQuerySystemTime(
                                &pPort->LastReadTime
                                );
                            KeSetTimer(
                                &pPort->ReadRequestIntervalTimer,
                                *pPort->IntervalTimeToUse,
                                &pPort->IntervalReadTimeoutDpc
                                );

                        }

                        IoMarkIrpPending(pPort->CurrentReadIrp);
                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(
                            &pPort->ControlLock,
                            controlIrql
                            );
                        if (!setFirstStatus) {

                            firstStatus = STATUS_PENDING;

                        }
                        return firstStatus;

                    } else {

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(
                            &pPort->ControlLock,
                            controlIrql
                            );
                        pPort->CurrentReadIrp->IoStatus.Status =
                            STATUS_SUCCESS;

                        if (!setFirstStatus) {

                            firstStatus = STATUS_SUCCESS;
                            setFirstStatus = TRUE;

                        }

                    }

                }

            }

        }

        //
        // Well the operation is complete.
        //

        SerialGetNextIrp(pPort, &pPort->CurrentReadIrp, &pPort->ReadQueue, &newIrp, TRUE);
            
    } while (newIrp);

    return firstStatus;

}

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any read that
    ended up being used by the Isr.  It assumes that the
    status and the information fields of the irp are already
    correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabReadFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

BOOLEAN
SerialGrabReadFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    isr.  If it finds that the isr still owns the irp it grabs
    the irp away (updating the number of characters copied into the
    user's buffer).  If it grabs it away it also decrements the
    reference count on the irp since it no longer belongs to the
    isr (and the dpc that would complete it).

    NOTE: This routine assumes that if the current buffer that the
          ISR is copying characters into is the interrupt buffer then
          the dpc has already been queued.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->ReadBufferBase !=
        pPort->InterruptReadBuffer) {

        //
        // We need to set the information to the number of characters
        // that the read wanted minus the number of characters that
        // didn't get read into the interrupt buffer.
        //

        pPort->CurrentReadIrp->IoStatus.Information =
            IoGetCurrentIrpStackLocation(
                pPort->CurrentReadIrp
                )->Parameters.Read.Length -
            ((pPort->LastCharSlot - pPort->CurrentCharSlot) + 1);

        //
        // Switch back to the interrupt buffer.
        //

        pPort->ReadBufferBase = pPort->InterruptReadBuffer;
        pPort->CurrentCharSlot = pPort->InterruptReadBuffer;
        pPort->FirstReadableChar = pPort->InterruptReadBuffer;
        pPort->LastCharSlot = pPort->InterruptReadBuffer +
                                      (pPort->BufferSize - 1);
    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
        pPort->CharsInInterruptBuffer = 0;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

        SERIAL_DEC_REFERENCE(pPort->CurrentReadIrp);

    }

    return FALSE;

}

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabReadFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentReadIrp,
        &pPort->ReadQueue,
        &pPort->ReadRequestIntervalTimer,
        &pPort->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp
        );

}

BOOLEAN
SerialUpdateReadByIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the count of characters read
    by the isr since the last interval timer experation.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->CountOnLastRead = pPort->ReadByIsr;
    pPort->ReadByIsr = 0;

    return FALSE;

}

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last time this routine was invoked (this dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    if (pPort->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) {

        //
        // This value is only set by the total
        // timer to indicate that it has fired.
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } else if (pPort->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) {

        //
        // This value is only set by the regular
        // completion routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_SUCCESS,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } else if (pPort->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) {

        //
        // This value is only set by the cancel
        // read routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            pPort,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &pPort->CurrentReadIrp,
            &pPort->ReadQueue,
            &pPort->ReadRequestIntervalTimer,
            &pPort->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp
            );

    } else if (pPort->CountOnLastRead || pPort->ReadByIsr) {

        //
        // Something has happened since we last came here.  We
        // check to see if the ISR has read in any more characters.
        // If it did then we should update the isr's read count
        // and resubmit the timer.
        //

        if (pPort->ReadByIsr) {

	    Slxos_SyncExec(pPort,SerialUpdateReadByIsr,pPort,0x1A);

            //
            // Save off the "last" time something was read.
            // As we come back to this routine we will compare
            // the current time to the "last" time.  If the
            // difference is ever larger then the interval
            // requested by the user, then time out the request.
            //

            KeQuerySystemTime(
                &pPort->LastReadTime
                );

            KeSetTimer(
                &pPort->ReadRequestIntervalTimer,
                *pPort->IntervalTimeToUse,
                &pPort->IntervalReadTimeoutDpc
                );

            IoReleaseCancelSpinLock(oldIrql);

        } else {

            //
            // Take the difference between the current time
            // and the last time we had characters and
            // see if it is greater then the interval time.
            // if it is, then time out the request.  Otherwise
            // go away again for a while.
            //

            //
            // No characters read in the interval time.  Kill
            // this read.
            //

            LARGE_INTEGER currentTime;

            KeQuerySystemTime(
                &currentTime
                );

            if (RtlLargeIntegerGreaterThanOrEqualTo(
                    RtlLargeIntegerSubtract(
                        currentTime,
                        pPort->LastReadTime
                        ),
                    pPort->IntervalTime
                    )) {

                SerialTryToCompleteCurrent(
                    pPort,
                    SerialGrabReadFromIsr,
                    oldIrql,
                    STATUS_TIMEOUT,
                    &pPort->CurrentReadIrp,
                    &pPort->ReadQueue,
                    &pPort->ReadRequestIntervalTimer,
                    &pPort->ReadRequestTotalTimer,
                    SerialStartRead,
                    SerialGetNextIrp
                    );

            } else {

                KeSetTimer(
                    &pPort->ReadRequestIntervalTimer,
                    *pPort->IntervalTimeToUse,
                    &pPort->IntervalReadTimeoutDpc
                    );
                IoReleaseCancelSpinLock(oldIrql);

            }


        }

    } else {

        //
        // Timer doesn't really start until the first character.
        // So we should simply resubmit ourselves.
        //

        KeSetTimer(
            &pPort->ReadRequestIntervalTimer,
            *pPort->IntervalTimeToUse,
            &pPort->IntervalReadTimeoutDpc
            );

        IoReleaseCancelSpinLock(oldIrql);

    }


}

ULONG
SerialGetCharsFromIntBuffer(
    PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the user's buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    pPort - A pointer to the device extension.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    //
    // This value will be the number of characters that this
    // routine returns.  It will be the minimum of the number
    // of characters currently in the buffer or the number of
    // characters required for the read.
    //
    ULONG numberOfCharsToGet;

    //
    // This holds the number of characters between the first
    // readable character and the last character we will read or
    // the real physical end of the buffer (not the last readable
    // character).
    //
    ULONG firstTryNumberToGet;


    //
    // The minimum of the number of characters we need and
    // the number of characters available
    //

    numberOfCharsToGet = pPort->CharsInInterruptBuffer;

    if (numberOfCharsToGet > pPort->NumberNeededForRead) {

        numberOfCharsToGet = pPort->NumberNeededForRead;

    }

    if (numberOfCharsToGet) {

        //
        // This will hold the number of characters between the
        // first available character and the end of the buffer.
        // Note that the buffer could wrap around but for the
        // purposes of the first copy we don't care about that.
        //

        firstTryNumberToGet = (pPort->LastCharSlot -
                               pPort->FirstReadableChar) + 1;

        if (firstTryNumberToGet > numberOfCharsToGet) {

            //
            // The characters don't wrap. Actually they may wrap but
            // we don't care for the purposes of this read since the
            // characters we need are available before the wrap.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->FirstReadableChar,
                numberOfCharsToGet
                );

            pPort->NumberNeededForRead -= numberOfCharsToGet;

            //
            // We now will move the pointer to the first character after
            // what we just copied into the user's buffer.
            //
            // We need to check if the stream of readable characters
            // is wrapping around to the beginning of the buffer.
            //
            // Note that we may have just taken the last characters
            // at the end of the buffer.
            //

            if ((pPort->FirstReadableChar + (numberOfCharsToGet - 1)) ==
                pPort->LastCharSlot) {

                pPort->FirstReadableChar = pPort->InterruptReadBuffer;

            } else {

                pPort->FirstReadableChar += numberOfCharsToGet;

            }

        } else {

            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->FirstReadableChar,
                firstTryNumberToGet
                );

            pPort->NumberNeededForRead -= firstTryNumberToGet;

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           pPort->CurrentReadIrp
                           )->Parameters.Read.Length
                       - pPort->NumberNeededForRead
                      ),
                pPort->InterruptReadBuffer,
                numberOfCharsToGet - firstTryNumberToGet
                );

            pPort->FirstReadableChar = pPort->InterruptReadBuffer +
                                           (numberOfCharsToGet -
                                            firstTryNumberToGet);

            pPort->NumberNeededForRead -= (numberOfCharsToGet -
                                               firstTryNumberToGet);

        }

    }

    pPort->CurrentReadIrp->IoStatus.Information += numberOfCharsToGet;
    return numberOfCharsToGet;

}

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the number of characters that
    remain in the interrupt buffer.  We need to use this routine
    since the count could be updated during the update by execution
    of the ISR.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension and count of the number of characters
              that we previously copied into the user's buffer.  The
              structure actually has a third field that we don't
              use in this routine.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR update = Context;
    PPORT_DEVICE_EXTENSION pPort = update->pPort;

    ASSERT(pPort->CharsInInterruptBuffer >= update->CharsCopied);
    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
	pPort->CharsInInterruptBuffer -= update->CharsCopied;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

    //
    // Deal with flow control if necessary.
    //

    SerialHandleReducedIntBuffer(pPort);


    return FALSE;

}

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.  If we still don't have enough characters
    to satisfy the read it will then we set things up so that the
    ISR uses the user buffer copy into.

    This routine is also used to update a count that is maintained
    by the ISR to keep track of the number of characters in its buffer.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a count of the number of characters
              that we previously copied into the user's buffer, and
              a boolean that we will set that defines whether we
              switched the ISR to copy into the user's buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR updateChar = Context;
    PPORT_DEVICE_EXTENSION pPort = updateChar->pPort;

    SerialUpdateInterruptBuffer(Context);

    //
    // There are more characters to get to satisfy this read.
    // Copy any characters that have arrived since we got
    // the last batch.
    //

    updateChar->CharsCopied = SerialGetCharsFromIntBuffer(pPort);

    SerialUpdateInterruptBuffer(Context);

    //
    // No more new characters will be "received" until we exit
    // this routine.  We again check to make sure that we
    // haven't satisfied this read, and if we haven't we set things
    // up so that the ISR copies into the user buffer.
    //

    if (pPort->NumberNeededForRead) {

        //
        // We shouldn't be switching unless there are no
        // characters left.
        //

        ASSERT(!pPort->CharsInInterruptBuffer);

        //
        // We use the following two values to do interval timing.
        //
        // CountOnLastRead is mostly used to simply prevent
        // the interval timer from timing out before any characters
        // are read.  (Interval timing should only be effective
        // after the first character is read.)
        //
        // After the first time the interval timer fires and
        // characters have be read we will simply update with
        // the value of ReadByIsr and then set ReadByIsr to zero.
        // (We do that in a synchronization routine.)
        //
        // If the interval timer dpc routine ever encounters
        // ReadByIsr == 0 when CountOnLastRead is non-zero it
        // will timeout the read.
        //
        // (Note that we have a special case of CountOnLastRead
        // < 0.  This is done by the read completion routines other
        // than the total timeout dpc to indicate that the total
        // timeout has expired.)
        //

        pPort->CountOnLastRead =
            pPort->CurrentReadIrp->IoStatus.Information;

        pPort->ReadByIsr = 0;

        //
        // By comparing the read buffer base address to the
        // the base address of the interrupt buffer the ISR
        // can determine whether we are using the interrupt
        // buffer or the user buffer.
        //

        pPort->ReadBufferBase =
            pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer;

        //
        // The current char slot is after the last copied in
        // character.  We know there is always room since we
        // we wouldn't have gotten here if there wasn't.
        //

        pPort->CurrentCharSlot = pPort->ReadBufferBase +
            pPort->CurrentReadIrp->IoStatus.Information;

        //
        // The last position that a character can go is on the
        // last byte of user buffer.  While the actual allocated
        // buffer space may be bigger, we know that there is at
        // least as much as the read length.
        //

        pPort->LastCharSlot = pPort->ReadBufferBase +
                                      (IoGetCurrentIrpStackLocation(
                                          pPort->CurrentReadIrp
                                          )->Parameters.Read.Length
                                       - 1);

        //
        // Mark the irp as being in a cancellable state.
        //

        IoSetCancelRoutine(
            pPort->CurrentReadIrp,
            SerialCancelCurrentRead
            );

        //
        // Increment the reference count twice.
        //
        // Once for the Isr owning the irp and once
        // because the cancel routine has a reference
        // to it.
        //

        SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);
        SERIAL_INC_REFERENCE(pPort->CurrentReadIrp);

        updateChar->Completed = FALSE;

    } else {

        updateChar->Completed = TRUE;

    }

    return FALSE;

}
//
// We use this structure only to communicate to the synchronization
// routine when we are switching to the resized buffer.
//
typedef struct _SERIAL_RESIZE_PARAMS {
    PPORT_DEVICE_EXTENSION pPort;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;
    ULONG NewBufferSize;
    ULONG NumberMoved;
    } SERIAL_RESIZE_PARAMS,*PSERIAL_RESIZE_PARAMS;

NTSTATUS
SerialResizeBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine will process the resize buffer request.
    If size requested for the RX buffer is smaller than
    the current buffer then we will simply return
    STATUS_SUCCESS.  (We don't want to make buffers smaller.
    If we did that then we all of a sudden have "overrun"
    problems to deal with as well as flow control to deal
    with - very painful.)  We ignore the TX buffer size
    request since we don't use a TX buffer.

Arguments:

    pPort - Pointer to the device extension for the port.

Return Value:

    STATUS_SUCCESS if everything worked out ok.
    STATUS_INSUFFICIENT_RESOURCES if we couldn't allocate the
    memory for the buffer.

--*/

{

    PSERIAL_QUEUE_SIZE rs = pPort->CurrentReadIrp->AssociatedIrp
                                                       .SystemBuffer;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(
                                   pPort->CurrentReadIrp
                                   );
    PVOID newBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    pPort->CurrentReadIrp->IoStatus.Information = 0L;
    pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

    if (rs->InSize <= pPort->BufferSize) {

        //
        // Nothing to do.  We don't make buffers smaller.  Just
        // agree with the user.  We must deallocate the memory
        // that was already allocated in the ioctl dispatch routine.
        //

        SpxFreeMem(newBuffer);

    } else {

        SERIAL_RESIZE_PARAMS rp;
        KIRQL controlIrql;

        //
        // Hmmm, looks like we actually have to go
        // through with this.  We need to move all the
        // data that is in the current buffer into this
        // new buffer.  We'll do this in two steps.
        //
        // First we go up to dispatch level and try to
        // move as much as we can without stopping the
        // ISR from running.  We go up to dispatch level
        // by acquiring the control lock.  We do it at
        // dispatch using the control lock so that:
        //
        //    1) We can't be context switched in the middle
        //       of the move.  Our pointers into the buffer
        //       could be *VERY* stale by the time we got back.
        //
        //    2) We use the control lock since we don't want
        //       some pesky purge irp to come along while
        //       we are trying to move.
        //
        // After the move, but while we still hold the control
        // lock, we synch with the ISR and get those last
        // (hopefully) few characters that have come in since
        // we started the copy.  We switch all of our pointers,
        // counters, and such to point to this new buffer.  NOTE:
        // we need to be careful.  If the buffer we were using
        // was not the default one created when we initialized
        // the device (i.e. it was created via a previous IRP of
        // this type), we should deallocate it.
        //

        rp.pPort = pPort;
        rp.OldBuffer = pPort->InterruptReadBuffer;
        rp.NewBuffer = newBuffer;
        rp.NewBufferSize = rs->InSize;

        KeAcquireSpinLock(
            &pPort->ControlLock,
            &controlIrql
            );

        rp.NumberMoved = SerialMoveToNewIntBuffer(
                             pPort,
                             newBuffer
                             );

	Slxos_SyncExec(pPort,SerialUpdateAndSwitchToNew,&rp,0x1C);

        KeReleaseSpinLock(
            &pPort->ControlLock,
            controlIrql
            );

        //
        // Free up the memory that the old buffer consumed.
        //

        SpxFreeMem(rp.OldBuffer);

    }

    return STATUS_SUCCESS;

}

ULONG
SerialMoveToNewIntBuffer(
    PPORT_DEVICE_EXTENSION pPort,
    PUCHAR NewBuffer
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the "new" buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    pPort - A pointer to the device extension.
    NewBuffer - Where the characters are to be move to.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    ULONG numberOfCharsMoved = pPort->CharsInInterruptBuffer;

    if (numberOfCharsMoved) {

        //
        // This holds the number of characters between the first
        // readable character and the last character we will read or
        // the real physical end of the buffer (not the last readable
        // character).
        //
        ULONG firstTryNumberToGet = (pPort->LastCharSlot -
                                     pPort->FirstReadableChar) + 1;

        if (firstTryNumberToGet >= numberOfCharsMoved) {

            //
            // The characters don't wrap.
            //

            RtlMoveMemory(
                NewBuffer,
                pPort->FirstReadableChar,
                numberOfCharsMoved
                );

            if ((pPort->FirstReadableChar+(numberOfCharsMoved-1)) ==
                pPort->LastCharSlot) {

                pPort->FirstReadableChar = pPort->InterruptReadBuffer;

            } else {

                pPort->FirstReadableChar += numberOfCharsMoved;

            }

        } else {

            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                NewBuffer,
                pPort->FirstReadableChar,
                firstTryNumberToGet
                );

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                NewBuffer+firstTryNumberToGet,
                pPort->InterruptReadBuffer,
                numberOfCharsMoved - firstTryNumberToGet
                );

            pPort->FirstReadableChar = pPort->InterruptReadBuffer +
                                   numberOfCharsMoved - firstTryNumberToGet;

        }

    }

    return numberOfCharsMoved;

}

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a pointer to the buffer we are moving
              to, and a count of the number of characters
              that we previously copied into the new buffer, and the
              actual size of the new buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_RESIZE_PARAMS params = Context;
    PPORT_DEVICE_EXTENSION pPort = params->pPort;
    ULONG tempCharsInInterruptBuffer = pPort->CharsInInterruptBuffer;

    ASSERT(pPort->CharsInInterruptBuffer >= params->NumberMoved);

    //
    // We temporarily reduce the chars in interrupt buffer to
    // "fool" the move routine.  We will restore it after the
    // move.
    //

    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
	pPort->CharsInInterruptBuffer -= params->NumberMoved;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

    if (pPort->CharsInInterruptBuffer) {

        SerialMoveToNewIntBuffer(
            pPort,
            params->NewBuffer + params->NumberMoved
            );

    }

    {
    	KIRQL	OldIrql;
	KeAcquireSpinLock(&pPort->BufferLock,&OldIrql);
	pPort->CharsInInterruptBuffer = tempCharsInInterruptBuffer;
	KeReleaseSpinLock(&pPort->BufferLock,OldIrql);
    }

    pPort->LastCharSlot = params->NewBuffer + (params->NewBufferSize - 1);
    pPort->FirstReadableChar = params->NewBuffer;
    pPort->ReadBufferBase = params->NewBuffer;
    pPort->InterruptReadBuffer = params->NewBuffer;
    pPort->BufferSize = params->NewBufferSize;

    //
    // We *KNOW* that the new interrupt buffer is larger than the
    // old buffer.  We don't need to worry about it being full.
    //

    pPort->CurrentCharSlot = pPort->InterruptReadBuffer +
                                 pPort->CharsInInterruptBuffer;

    //
    // We set up the default xon/xoff limits.
    //

    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2))+
                                   (pPort->BufferSize>>4));

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif                                 

    //
    // Since we (essentially) reduced the percentage of the interrupt
    // buffer being full, we need to handle any flow control.
    //

    SerialHandleReducedIntBuffer(pPort);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\si4_cf.c ===
/* SI4_CF.C Version, Bootstrap and Download Code Arrays... */

char *si4_cf_ident = "%W%";

/* SI4_CF embedded version... 

	Copyright (c) Perle Systems Ltd 1996-2000.
	JETCF.BIN Version 4.0.5 Created May 14 2001 @ 15:40:19

*/

unsigned char si4_cf_download[] =
{
	0x05,0x00,0x1F,0xFC,0x00,0x00,0x04,0x08,	/* 0000: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0008: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0010: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0018: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0020: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0028: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0030: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0038: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0040: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0048: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0050: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0058: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0060: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0068: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0070: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0078: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0080: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0088: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0090: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0098: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0100: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0108: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0110: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0118: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0120: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0128: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0130: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0138: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0140: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0148: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0150: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0158: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0160: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0168: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0170: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0178: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0180: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0188: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0190: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0198: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 01F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0200: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0208: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0210: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0218: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0220: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0228: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0230: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0238: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0240: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0248: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0250: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0258: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0260: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0268: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0270: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0278: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0280: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0288: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0290: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0298: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 02F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0300: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0308: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0310: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0318: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0320: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0328: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0330: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0338: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0340: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0348: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0350: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0358: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0360: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0368: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0370: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0378: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0380: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0388: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0390: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0398: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03A8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03B0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03B8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03C0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03C8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03D0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03D8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03E0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03E8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03F0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 03F8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0400: ........ */
	0x4E,0xF9,0x00,0x00,0x05,0xFC,0x2E,0x7C,	/* 0408: N....| */
	0x05,0x00,0x1F,0xFC,0x4E,0xB9,0x00,0x00,	/* 0410: ...N.. */
	0x04,0xAC,0x2F,0x00,0x4E,0xB9,0x00,0x00,	/* 0418: ...N.. */
	0x04,0x28,0x4E,0xB9,0x00,0x00,0x06,0x60,	/* 0420: .(N...` */
	0x2F,0x0D,0x2A,0x7C,0x05,0x00,0x00,0x00,	/* 0428: ..*|.... */
	0x20,0x7C,0x05,0x00,0x00,0x00,0xB1,0xCD,	/* 0430:  |.... */
	0x67,0x18,0x20,0x3C,0x05,0x00,0x00,0x00,	/* 0438: g. <.... */
	0x90,0x8D,0x2F,0x00,0x2F,0x0D,0x2F,0x08,	/* 0440: ...... */
	0x4E,0xB9,0x00,0x00,0x61,0x9C,0x4F,0xEF,	/* 0448: N..aO */
	0x00,0x0C,0x20,0x7C,0x00,0x00,0x62,0x90,	/* 0450: .. |..b */
	0x2A,0x7C,0x00,0x00,0x62,0x90,0xB1,0xCD,	/* 0458: *|..b */
	0x67,0x18,0x20,0x3C,0x00,0x00,0x64,0x84,	/* 0460: g. <..d */
	0x90,0x8D,0x2F,0x00,0x2F,0x08,0x2F,0x0D,	/* 0468: ...... */
	0x4E,0xB9,0x00,0x00,0x61,0x9C,0x4F,0xEF,	/* 0470: N..aO */
	0x00,0x0C,0x20,0x7C,0x00,0x00,0x64,0xA8,	/* 0478: .. |..d */
	0x2A,0x7C,0x00,0x00,0x64,0x84,0xBB,0xC8,	/* 0480: *|..d */
	0x67,0x14,0x20,0x08,0x90,0x8D,0x2F,0x00,	/* 0488: g. ... */
	0x42,0xA7,0x2F,0x0D,0x4E,0xB9,0x00,0x00,	/* 0490: B..N.. */
	0x62,0x10,0x4F,0xEF,0x00,0x0C,0x4E,0xB9,	/* 0498: b.O..N */
	0x00,0x00,0x62,0x8C,0x70,0x01,0x2A,0x5F,	/* 04A0: ..bp.*_ */
	0x4E,0x75,0x4E,0x71,0x61,0x00,0xFF,0x7A,	/* 04A8: NuNqa.z */
	0x4E,0xB9,0x00,0x00,0x06,0x60,0x4E,0x75,	/* 04B0: N...`Nu */
	0x70,0x04,0x13,0xC0,0x10,0x00,0x00,0x41,	/* 04B8: p.....A */
	0x70,0xC0,0x13,0xC0,0x10,0x00,0x00,0x03,	/* 04C0: p..... */
	0x30,0x3C,0xFF,0xFE,0x33,0xC0,0x10,0x00,	/* 04C8: 0<3.. */
	0x00,0x36,0x20,0x7C,0x10,0x00,0x00,0xCA,	/* 04D0: .6 |... */
	0x30,0xBC,0x00,0xB0,0x70,0x84,0x13,0xC0,	/* 04D8: 0.p. */
	0x10,0x00,0x00,0x14,0x72,0x88,0x13,0xC1,	/* 04E0: ....r. */
	0x10,0x00,0x00,0x15,0x70,0x8C,0x13,0xC0,	/* 04E8: ....p. */
	0x10,0x00,0x00,0x16,0x70,0x90,0x13,0xC0,	/* 04F0: ....p. */
	0x10,0x00,0x00,0x17,0x70,0x94,0x13,0xC0,	/* 04F8: ....p. */
	0x10,0x00,0x00,0x18,0x70,0x98,0x13,0xC0,	/* 0500: ....p. */
	0x10,0x00,0x00,0x19,0x70,0x9C,0x13,0xC0,	/* 0508: ....p. */
	0x10,0x00,0x00,0x1A,0x70,0x1E,0x13,0xC0,	/* 0510: ....p.. */
	0x10,0x00,0x00,0x1B,0x13,0xC1,0x10,0x00,	/* 0518: ....... */
	0x00,0x1C,0x70,0x96,0x13,0xC0,0x10,0x00,	/* 0520: ..p... */
	0x00,0x1D,0x70,0x97,0x13,0xC0,0x10,0x00,	/* 0528: ..p... */
	0x00,0x1E,0x70,0x8F,0x13,0xC0,0x10,0x00,	/* 0530: ..p... */
	0x00,0x1F,0x70,0x8E,0x13,0xC0,0x10,0x00,	/* 0538: ..p... */
	0x00,0x20,0x08,0xA8,0x00,0x06,0x00,0x01,	/* 0540: . ..... */
	0x20,0x7C,0x10,0x00,0x01,0x00,0x72,0x01,	/* 0548:  |....r. */
	0x30,0x81,0x70,0x03,0x13,0xC0,0x10,0x00,	/* 0550: 0p.... */
	0x01,0x11,0x33,0xC1,0x10,0x00,0x01,0x20,	/* 0558: ..3...  */
	0x13,0xC0,0x10,0x00,0x01,0x31,0x42,0x79,	/* 0560: ....1By */
	0x10,0x00,0x00,0x64,0x20,0x3C,0x01,0xFF,	/* 0568: ...d <. */
	0x00,0x00,0x23,0xC0,0x10,0x00,0x00,0x68,	/* 0570: ..#...h */
	0x30,0x3C,0x05,0x83,0x33,0xC0,0x10,0x00,	/* 0578: 0<.3.. */
	0x00,0x6E,0x30,0x3C,0x04,0x00,0x33,0xC0,	/* 0580: .n0<..3 */
	0x10,0x00,0x00,0x70,0x22,0x3C,0x00,0x01,	/* 0588: ...p"<.. */
	0x00,0x00,0x23,0xC1,0x10,0x00,0x00,0x74,	/* 0590: ..#...t */
	0x30,0x3C,0x00,0xA3,0x33,0xC0,0x10,0x00,	/* 0598: 0<.3.. */
	0x00,0x7A,0x30,0x3C,0x02,0x00,0x33,0xC0,	/* 05A0: .z0<..3 */
	0x10,0x00,0x00,0x7C,0x20,0x3C,0x00,0x07,	/* 05A8: ...| <.. */
	0x00,0x00,0x23,0xC0,0x10,0x00,0x00,0x80,	/* 05B0: ..#... */
	0x30,0x3C,0x19,0x43,0x33,0xC0,0x10,0x00,	/* 05B8: 0<.C3.. */
	0x00,0x86,0x30,0x3C,0x03,0x00,0x33,0xC0,	/* 05C0: .0<..3 */
	0x10,0x00,0x00,0x88,0x23,0xC1,0x10,0x00,	/* 05C8: ...#.. */
	0x00,0x8C,0x30,0x3C,0x09,0x83,0x33,0xC0,	/* 05D0: .0<.3 */
	0x10,0x00,0x00,0x92,0x42,0x79,0x10,0x00,	/* 05D8: ...By.. */
	0x00,0x94,0x42,0x79,0x10,0x00,0x00,0xA0,	/* 05E0: .By... */
	0x42,0x79,0x10,0x00,0x00,0xAC,0x42,0x79,	/* 05E8: By...By */
	0x10,0x00,0x00,0xB8,0x42,0x79,0x10,0x00,	/* 05F0: ...By.. */
	0x00,0xC6,0x4E,0x75,0x46,0xFC,0x21,0x00,	/* 05F8: .NuF!. */
	0x22,0x0F,0x2E,0x7C,0x00,0x00,0x00,0x00,	/* 0600: "..|.... */
	0x4E,0x7B,0xF8,0x01,0x2E,0x41,0x70,0x00,	/* 0608: N{..Ap. */
	0x4E,0x7B,0x00,0x04,0x4E,0x7B,0x00,0x05,	/* 0610: N{..N{.. */
	0x20,0x3C,0x05,0x00,0x00,0x01,0x4E,0x7B,	/* 0618:  <....N{ */
	0x0C,0x04,0x20,0x3C,0x10,0x00,0x00,0x01,	/* 0620: .. <.... */
	0x4E,0x7B,0x0C,0x0F,0x4E,0xB9,0x00,0x00,	/* 0628: N{..N.. */
	0x04,0xB8,0x2E,0x79,0x05,0x00,0x1F,0xFC,	/* 0630: ..y... */
	0x2C,0x78,0x00,0x00,0x20,0x3C,0x00,0x00,	/* 0638: ,x.. <.. */
	0xC0,0x00,0x4E,0x7B,0x00,0x04,0x20,0x3C,	/* 0640: .N{.. < */
	0x01,0x00,0x00,0x00,0x4E,0x7B,0x00,0x02,	/* 0648: ....N{.. */
	0x20,0x3C,0x80,0x00,0x03,0x00,0x4E,0x7B,	/* 0650:  <...N{ */
	0x00,0x02,0x4E,0xF9,0x00,0x00,0x04,0x0E,	/* 0658: ..N.... */
	0x4E,0xB9,0x00,0x00,0x06,0x6C,0x70,0x00,	/* 0660: N...lp. */
	0x4E,0x75,0x00,0x00,0x2F,0x0D,0x22,0x3C,	/* 0668: Nu...."< */
	0x01,0x01,0x80,0x00,0x2A,0x7C,0x00,0x00,	/* 0670: ...*|.. */
	0x64,0x88,0x2A,0x81,0x2F,0x0C,0x48,0x78,	/* 0678: d*..Hx */
	0x70,0x00,0x42,0xA7,0x2F,0x01,0x4E,0xB9,	/* 0680: p.B..N */
	0x00,0x00,0x62,0x10,0x28,0x55,0x72,0x00,	/* 0688: ..b.(Ur. */
	0x70,0x80,0x19,0x40,0x00,0x01,0x32,0x39,	/* 0690: p.@..29 */
	0x00,0x00,0x41,0xA4,0x58,0x8C,0x20,0x01,	/* 0698: ..AX . */
	0x18,0x81,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 06A0: ..@.. */
	0x28,0x55,0x54,0x8C,0x42,0x2C,0x00,0x01,	/* 06A8: (UTB,.. */
	0x70,0x64,0x18,0x80,0x30,0x7C,0x00,0x60,	/* 06B0: pd.0|.` */
	0x2B,0x48,0x00,0x04,0x28,0x7C,0x10,0x00,	/* 06B8: +H..(|.. */
	0x00,0x00,0x2B,0x4C,0x00,0x08,0x20,0xBC,	/* 06C0: ..+L..  */
	0x00,0x00,0x07,0x70,0x4E,0xB9,0x00,0x00,	/* 06C8: ...pN.. */
	0x07,0x74,0x20,0x55,0x10,0x80,0x4E,0xB9,	/* 06D0: .t U.N */
	0x00,0x00,0x0D,0x1C,0x30,0x7C,0x00,0x68,	/* 06D8: ....0|.h */
	0x4F,0xEF,0x00,0x0C,0x2B,0x48,0x00,0x04,	/* 06E0: O..+H.. */
	0x70,0x00,0x20,0xBC,0x00,0x00,0x0D,0xA4,	/* 06E8: p. ... */
	0x20,0x55,0x10,0x10,0x53,0x80,0x66,0x00,	/* 06F0:  U..Sf. */
	0x00,0x6A,0x10,0x39,0x01,0x01,0x80,0x88,	/* 06F8: .j.9.. */
	0xC0,0xBC,0x00,0x00,0x00,0xF0,0x4A,0x00,	/* 0700: ...J. */
	0x66,0x14,0x20,0x6D,0x00,0x08,0x30,0x3C,	/* 0708: f. m..0< */
	0xFD,0xFE,0x31,0x40,0x00,0x36,0x4E,0xB9,	/* 0710: 1@.6N */
	0x00,0x00,0x45,0x88,0x60,0x44,0x70,0x00,	/* 0718: ..E`Dp. */
	0x30,0x39,0x00,0x00,0x62,0x94,0x4A,0x80,	/* 0720: 09..bJ */
	0x6F,0x20,0x70,0x00,0x30,0x39,0x00,0x00,	/* 0728: o p.09.. */
	0x62,0x92,0x4A,0x80,0x66,0x14,0x20,0x6D,	/* 0730: bJf. m */
	0x00,0x08,0x30,0x3C,0xFD,0xFE,0x31,0x40,	/* 0738: ..0<1@ */
	0x00,0x36,0x4E,0xB9,0x00,0x00,0x3F,0xA0,	/* 0740: .6N..? */
	0x60,0x18,0x2B,0x4C,0x00,0x08,0x38,0x7C,	/* 0748: `.+L..8| */
	0x00,0x70,0x2B,0x4C,0x00,0x0C,0x28,0xBC,	/* 0750: .p+L..( */
	0x00,0x00,0x41,0x84,0x4E,0xB9,0x00,0x00,	/* 0758: ..AN.. */
	0x2D,0xB8,0x3A,0x7C,0x01,0x00,0x30,0x15,	/* 0760: -:|..0. */
	0x52,0x80,0x3A,0x80,0x60,0xF4,0x4E,0x71,	/* 0768: R:`Nq */
	0x4E,0x73,0x00,0x00,0x4E,0x56,0xFF,0xD8,	/* 0770: Ns..NV */
	0x4F,0xEF,0xFF,0xE0,0x48,0xD7,0x30,0xFC,	/* 0778: OH0 */
	0x70,0x00,0x2D,0x40,0xFF,0xD8,0x28,0x7C,	/* 0780: p.-@(| */
	0x01,0x01,0x80,0x80,0x70,0x00,0x26,0x00,	/* 0788: ..p.&. */
	0x20,0x3C,0x00,0x00,0x00,0x80,0x2D,0x40,	/* 0790:  <...-@ */
	0xFF,0xE4,0x70,0x00,0x2D,0x40,0xFF,0xE0,	/* 0798: p.-@ */
	0x22,0x2E,0xFF,0xE0,0x7A,0x00,0x78,0x00,	/* 07A0: ".z.x. */
	0x2C,0x3C,0x04,0x01,0xF0,0x1A,0xE1,0x89,	/* 07A8: ,<... */
	0x24,0x01,0x2E,0x01,0x22,0x04,0xEB,0x89,	/* 07B0: $...". */
	0xD2,0x87,0xC2,0xBC,0x00,0x00,0xFF,0xFF,	/* 07B8: .. */
	0x20,0x41,0xD1,0xC6,0x10,0x10,0xC0,0xBC,	/* 07C0:  A.. */
	0x00,0x00,0x00,0xA0,0xB0,0xBC,0x00,0x00,	/* 07C8: ..... */
	0x00,0xA0,0x67,0x14,0x70,0x01,0x26,0x00,	/* 07D0: .g.p.&. */
	0x7A,0x01,0x20,0x2E,0xFF,0xD8,0x53,0x80,	/* 07D8: z. .S */
	0x66,0x14,0x70,0xFF,0x60,0x00,0x05,0x10,	/* 07E0: f.p`... */
	0x20,0x04,0x78,0x00,0x52,0x80,0x38,0x00,	/* 07E8:  .x.R8. */
	0x70,0x04,0xB0,0x84,0x6E,0xBE,0xCA,0xBC,	/* 07F0: p.n */
	0x00,0x00,0xFF,0xFF,0x66,0x00,0x00,0x60,	/* 07F8: ..f..` */
	0xC4,0xBC,0x00,0x00,0xFF,0xFF,0x20,0x42,	/* 0800: .. B */
	0xD1,0xFC,0x04,0x01,0xF0,0x02,0x10,0x10,	/* 0808: ..... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0xB0,0xBC,	/* 0810: ... */
	0x00,0x00,0x00,0xFF,0x67,0x12,0x70,0x01,	/* 0818: ...g.p. */
	0x2D,0x40,0xFF,0xD8,0x20,0x03,0x53,0x80,	/* 0820: -@ .S */
	0x66,0x34,0x70,0xFF,0x60,0x00,0x04,0xC8,	/* 0828: f4p`.. */
	0x4A,0x83,0x66,0x0C,0x4A,0xAE,0xFF,0xD8,	/* 0830: Jf.J */
	0x66,0x06,0x70,0xFF,0x60,0x00,0x04,0xB8,	/* 0838: f.p`.. */
	0x70,0x81,0x43,0xED,0x00,0x2E,0x1B,0x40,	/* 0840: pC...@ */
	0x00,0x01,0x70,0xE0,0x1A,0x80,0x70,0x01,	/* 0848: ..p.p. */
	0x13,0x40,0x00,0x01,0x70,0x80,0x12,0x80,	/* 0850: .@..p. */
	0x70,0x01,0x60,0x00,0x04,0x9A,0x4A,0xAE,	/* 0858: p.`..J */
	0xFF,0xE0,0x67,0x40,0x20,0x2E,0xFF,0xE4,	/* 0860: g@ . */
	0x72,0x00,0x12,0x2C,0x00,0x02,0xC3,0xFC,	/* 0868: r..,.. */
	0x03,0x00,0xD0,0x81,0xD0,0xBC,0x00,0x00,	/* 0870: .... */
	0x01,0x00,0x72,0x00,0x32,0x00,0x78,0x00,	/* 0878: ..r.2.x. */
	0x2D,0x41,0xFF,0xE4,0x20,0x2E,0xFF,0xE4,	/* 0880: -A . */
	0x80,0xBC,0x00,0x00,0x80,0x00,0x38,0x00,	/* 0888: ...8. */
	0x20,0x04,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 0890:  ..@.. */
	0x18,0x84,0x28,0x6E,0xFF,0xE4,0xD9,0xFC,	/* 0898: .(n */
	0x01,0x01,0x80,0x00,0x28,0x2E,0xFF,0xE0,	/* 08A0: ...(. */
	0x42,0x2C,0x00,0x01,0x42,0x14,0x20,0x2E,	/* 08A8: B,..B. . */
	0xFF,0xE0,0x43,0xEC,0x00,0x06,0xE1,0x8C,	/* 08B0: C.. */
	0x19,0x40,0x00,0x03,0xC8,0xBC,0x00,0x00,	/* 08B8: .@.... */
	0xFF,0xFF,0x2A,0x04,0x20,0x05,0xE0,0x80,	/* 08C0: *. . */
	0x13,0x40,0x00,0x01,0x12,0x85,0x4A,0x83,	/* 08C8: .@...J */
	0x67,0x00,0x01,0x14,0x70,0x08,0x2A,0x3C,	/* 08D0: g...p.*< */
	0x04,0x01,0xF0,0xFE,0xC8,0xBC,0x00,0x00,	/* 08D8: .... */
	0xFF,0xFF,0x2E,0x3C,0x04,0x01,0xF0,0xD0,	/* 08E0: .<.. */
	0x24,0x3C,0x04,0x01,0xF0,0x30,0x19,0x40,	/* 08E8: $<..0.@ */
	0x00,0x02,0x2C,0x04,0x20,0x46,0x70,0x04,	/* 08F0: ..,. Fp. */
	0xD1,0xC5,0x42,0x10,0x20,0x46,0xD1,0xC7,	/* 08F8: B. F */
	0x42,0x10,0x20,0x46,0xD1,0xC2,0x42,0x10,	/* 0900: B. FB. */
	0x20,0x46,0xD1,0xC5,0x10,0x80,0x20,0x46,	/* 0908:  F. F */
	0x70,0x55,0xD1,0xC7,0x42,0x10,0x20,0x46,	/* 0910: pUB. F */
	0xD1,0xC2,0x10,0x80,0x20,0x46,0xD1,0xC5,	/* 0918: . F */
	0x42,0x10,0x20,0x46,0xD1,0xC2,0x10,0x10,	/* 0920: B. F.. */
	0x72,0x55,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 0928: rU... */
	0xB2,0x80,0x66,0x08,0x70,0x48,0x19,0x40,	/* 0930: f.pH.@ */
	0x00,0x08,0x60,0x06,0x70,0x28,0x19,0x40,	/* 0938: ..`.p(.@ */
	0x00,0x08,0xC8,0xBC,0x00,0x00,0xFF,0xFF,	/* 0940: .... */
	0x24,0x3C,0x04,0x01,0xF0,0x80,0x2C,0x04,	/* 0948: $<..,. */
	0x20,0x46,0xD1,0xC5,0x10,0x10,0x20,0x46,	/* 0950:  F.. F */
	0xD1,0xC2,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 0958: ... */
	0x19,0x40,0x00,0x1E,0x10,0x10,0x20,0x46,	/* 0960: .@.... F */
	0xD1,0xC5,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 0968: ... */
	0x19,0x40,0x00,0x1F,0x70,0x04,0x10,0x80,	/* 0970: .@..p.. */
	0x20,0x46,0xD1,0xC2,0x10,0x10,0xC0,0xBC,	/* 0978:  F.. */
	0x00,0x00,0x00,0xFF,0x19,0x40,0x00,0x20,	/* 0980: ....@.  */
	0x70,0x00,0x10,0x2C,0x00,0x08,0x72,0x48,	/* 0988: p..,..rH */
	0xB2,0x80,0x66,0x2E,0xC8,0xBC,0x00,0x00,	/* 0990: f... */
	0xFF,0xFF,0x22,0x7C,0x00,0x00,0x62,0x90,	/* 0998: "|..b */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0x72,	/* 09A0:  D..r */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 09A8: ...... */
	0x52,0x80,0x19,0x40,0x00,0x21,0x30,0x29,	/* 09B0: R.@.!0) */
	0x00,0x04,0x52,0x80,0x33,0x40,0x00,0x04,	/* 09B8: ..R3@.. */
	0x60,0x10,0x22,0x7C,0x00,0x00,0x62,0x90,	/* 09C0: `."|..b */
	0x30,0x29,0x00,0x02,0x52,0x80,0x33,0x40,	/* 09C8: 0)..R3@ */
	0x00,0x02,0xC8,0xBC,0x00,0x00,0xFF,0xFF,	/* 09D0: .... */
	0x2F,0x04,0x4E,0xB9,0x00,0x00,0x2C,0x64,	/* 09D8: ..N..,d */
	0x58,0x8F,0x60,0x00,0x00,0x7E,0xC8,0xBC,	/* 09E0: X`..~ */
	0x00,0x00,0xFF,0xFF,0x22,0x7C,0x00,0x00,	/* 09E8: .."|.. */
	0x62,0x90,0x20,0x44,0x30,0x11,0xD1,0xFC,	/* 09F0: b D0. */
	0x04,0x01,0xF0,0x80,0x1A,0x10,0x52,0x80,	/* 09F8: ....R */
	0x32,0x80,0xCA,0xBC,0x00,0x00,0x00,0xFF,	/* 0A00: 2... */
	0x08,0x05,0x00,0x00,0x67,0x1E,0xBA,0xBC,	/* 0A08: ....g. */
	0x00,0x00,0x00,0xAB,0x66,0x08,0x70,0x0A,	/* 0A10: ...f.p. */
	0x19,0x40,0x00,0x08,0x60,0x06,0x70,0x04,	/* 0A18: .@..`.p. */
	0x19,0x40,0x00,0x08,0x70,0x04,0x19,0x40,	/* 0A20: .@..p..@ */
	0x00,0x02,0x60,0x1C,0xBA,0xBC,0x00,0x00,	/* 0A28: ..`... */
	0x00,0xAA,0x66,0x08,0x70,0x0B,0x19,0x40,	/* 0A30: .f.p..@ */
	0x00,0x08,0x60,0x06,0x70,0x08,0x19,0x40,	/* 0A38: ..`.p..@ */
	0x00,0x08,0x70,0x08,0x19,0x40,0x00,0x02,	/* 0A40: ..p..@.. */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0xFF,0x00,	/* 0A48: 0.... */
	0x80,0xBC,0x00,0x00,0x00,0x80,0x20,0x40,	/* 0A50: ... @ */
	0xD1,0xFC,0x04,0x01,0xF0,0x00,0x70,0xFF,	/* 0A58: ...p */
	0x10,0x80,0x20,0x2E,0xFF,0xE4,0xD0,0xBC,	/* 0A60: . . */
	0x00,0x00,0x01,0x00,0x7A,0x00,0x3A,0x00,	/* 0A68: ....z.:. */
	0x4A,0xAE,0xFF,0xE0,0x67,0x2A,0x20,0x05,	/* 0A70: Jg* . */
	0x7C,0x00,0xD0,0xBC,0x00,0x00,0x00,0x60,	/* 0A78: |....` */
	0x80,0xBC,0x00,0x00,0x80,0x00,0x3C,0x00,	/* 0A80: ...<. */
	0x20,0x06,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 0A88:  ..@.. */
	0x43,0xED,0x00,0x2E,0x1A,0x86,0x20,0x05,	/* 0A90: C... . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x85,	/* 0A98: .@... */
	0x7C,0x00,0x70,0x00,0x10,0x2C,0x00,0x02,	/* 0AA0: |.p..,.. */
	0x4A,0x80,0x6F,0x00,0x02,0x18,0x20,0x2E,	/* 0AA8: Jo... . */
	0xFF,0xE4,0x80,0xBC,0x00,0x00,0x80,0x00,	/* 0AB0: ... */
	0x74,0x00,0x34,0x00,0x2A,0x45,0x43,0xF4,	/* 0AB8: t.4.*EC */
	0x6A,0x0A,0x20,0x05,0xE0,0x80,0x13,0x40,	/* 0AC0: j. ..@ */
	0x00,0x01,0xDB,0xFC,0x01,0x01,0x80,0x00,	/* 0AC8: ..... */
	0x12,0x85,0x1B,0x6C,0x00,0x08,0x00,0x06,	/* 0AD0: ..l.... */
	0x70,0x10,0x1B,0x40,0x00,0x0E,0x70,0x01,	/* 0AD8: p..@..p. */
	0x1B,0x40,0x00,0x1F,0x1B,0x46,0x00,0x07,	/* 0AE0: .@...F.. */
	0x70,0xFF,0x1B,0x40,0x00,0x22,0x4A,0x83,	/* 0AE8: p.@."J */
	0x67,0x00,0x00,0x9C,0x41,0xEE,0xFF,0xE8,	/* 0AF0: g..A */
	0x22,0x7C,0x00,0x00,0x0D,0x04,0xC8,0xBC,	/* 0AF8: "|.... */
	0x00,0x00,0xFF,0xFF,0x2E,0x04,0x20,0x07,	/* 0B00: .... . */
	0x20,0xD9,0xE0,0x80,0x20,0xD9,0x20,0xD9,	/* 0B08:     */
	0x20,0xD9,0x43,0xED,0x00,0x02,0x13,0x40,	/* 0B10:  C...@ */
	0x00,0x01,0x12,0x87,0x70,0x04,0xB0,0x86,	/* 0B18: ...p. */
	0x6E,0x1A,0xC8,0xBC,0x00,0x00,0xFF,0xFF,	/* 0B20: n... */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 0B28:  D.. */
	0x1E,0x10,0xCE,0xBC,0x00,0x00,0x00,0xFF,	/* 0B30: ..... */
	0xE8,0x87,0x60,0x16,0xC8,0xBC,0x00,0x00,	/* 0B38: `... */
	0xFF,0xFF,0x20,0x44,0xD1,0xFC,0x04,0x01,	/* 0B40:  D.. */
	0xF0,0xFE,0x1E,0x10,0xCE,0xBC,0x00,0x00,	/* 0B48: .... */
	0x00,0x0F,0x1B,0x47,0x00,0x24,0xCE,0xBC,	/* 0B50: ...G.$ */
	0x00,0x00,0x00,0xFF,0x10,0x36,0x78,0xE8,	/* 0B58: ....6x */
	0x1B,0x40,0x00,0x26,0x10,0x07,0xC0,0xBC,	/* 0B60: .@.&.. */
	0x00,0x00,0x00,0x07,0x5B,0x80,0x66,0x10,	/* 0B68: ....[f. */
	0x4A,0x86,0x67,0x06,0x70,0x04,0xB0,0x86,	/* 0B70: Jg.p. */
	0x66,0x06,0x70,0x01,0x1B,0x40,0x00,0x27,	/* 0B78: f.p..@.' */
	0x7E,0x0B,0x1B,0x47,0x00,0x36,0x1B,0x47,	/* 0B80: ~..G.6.G */
	0x00,0x37,0x60,0x00,0x00,0xE0,0x41,0xEE,	/* 0B88: .7`..A */
	0xFF,0xF8,0x22,0x7C,0x00,0x00,0x0D,0x14,	/* 0B90: "|.... */
	0x7E,0x00,0x70,0x08,0x20,0xD9,0x20,0xD9,	/* 0B98: ~.p.   */
	0x1E,0x2C,0x00,0x08,0xB0,0x87,0x67,0x06,	/* 0BA0: .,..g. */
	0x70,0x0B,0xB0,0x87,0x66,0x22,0x43,0xED,	/* 0BA8: p.f"C */
	0x00,0x02,0x20,0x06,0x7E,0x00,0xE9,0x88,	/* 0BB0: .. .~. */
	0xD0,0x84,0x3E,0x00,0x20,0x07,0xE0,0x80,	/* 0BB8: >. . */
	0x13,0x40,0x00,0x01,0x12,0x87,0x70,0x01,	/* 0BC0: .@...p. */
	0xED,0xA8,0x1B,0x40,0x00,0x0F,0x60,0x26,	/* 0BC8: .@..`& */
	0x43,0xED,0x00,0x02,0x41,0xF6,0x6A,0xF8,	/* 0BD0: C..Aj */
	0x7E,0x00,0x30,0x10,0xE9,0x88,0xD0,0x84,	/* 0BD8: ~.0. */
	0x3E,0x00,0x20,0x07,0xE0,0x80,0x13,0x40,	/* 0BE0: >. ..@ */
	0x00,0x01,0x12,0x87,0x70,0x01,0x32,0x10,	/* 0BE8: ...p.2. */
	0xE3,0xA8,0x1B,0x40,0x00,0x0F,0x20,0x06,	/* 0BF0: .@.. . */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x66,0x12,	/* 0BF8: ....f. */
	0x7E,0x00,0x1E,0x2C,0x00,0x08,0x70,0x04,	/* 0C00: ~..,..p. */
	0xB0,0x87,0x67,0x06,0x70,0x0A,0xB0,0x87,	/* 0C08: g.p. */
	0x66,0x5A,0x43,0xED,0x00,0x02,0x70,0x00,	/* 0C10: fZC..p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 0C18: .).... */
	0x72,0x00,0x32,0x00,0x2E,0x01,0x70,0xE0,	/* 0C20: r.2...p */
	0xCE,0xBC,0xFF,0xFF,0xFF,0xEF,0x20,0x47,	/* 0C28:  G */
	0xD1,0xFC,0x04,0x01,0xF0,0x08,0x10,0x80,	/* 0C30: .... */
	0x20,0x47,0x70,0x02,0xD1,0xFC,0x04,0x01,	/* 0C38:  Gp... */
	0xF0,0x0A,0x42,0x10,0x20,0x47,0xD1,0xFC,	/* 0C40: .B. G */
	0x04,0x01,0xF0,0x0C,0x42,0x10,0x20,0x47,	/* 0C48: ...B. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x0E,0x10,0x80,	/* 0C50: .... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x1C,	/* 0C58:  G... */
	0x10,0x10,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 0C60: .. G.. */
	0xF0,0x1A,0x42,0x10,0x43,0xED,0x00,0x04,	/* 0C68: .B.C.. */
	0x20,0x02,0xE0,0x80,0x13,0x40,0x00,0x01,	/* 0C70:  ..@.. */
	0x7E,0x00,0x12,0x82,0x20,0x05,0xD0,0xBC,	/* 0C78: ~.. . */
	0x00,0x00,0x03,0x00,0x7A,0x00,0x3A,0x00,	/* 0C80: ....z.:. */
	0x20,0x05,0xD0,0xBC,0x00,0x00,0x00,0x60,	/* 0C88:  ....` */
	0x80,0xBC,0x00,0x00,0x80,0x00,0x3E,0x00,	/* 0C90: ...>. */
	0x20,0x07,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 0C98:  ..@.. */
	0x43,0xED,0x00,0x2E,0x1A,0x87,0x20,0x05,	/* 0CA0: C... . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x85,	/* 0CA8: .@... */
	0x20,0x06,0x52,0x80,0x7C,0x00,0x3C,0x00,	/* 0CB0:  .R|.<. */
	0x70,0x00,0x10,0x2C,0x00,0x02,0xBC,0x80,	/* 0CB8: p..,.. */
	0x6D,0x00,0xFD,0xFA,0x20,0x2E,0xFF,0xE0,	/* 0CC0: m. . */
	0x72,0x00,0x52,0x80,0x32,0x00,0x2D,0x41,	/* 0CC8: r.R2.-A */
	0xFF,0xE0,0x20,0x2E,0xFF,0xE0,0x59,0x80,	/* 0CD0:  .Y */
	0x6D,0x00,0xFA,0xC6,0x70,0x81,0x43,0xED,	/* 0CD8: m.pC */
	0x00,0x2E,0x1B,0x40,0x00,0x01,0x70,0xE0,	/* 0CE0: ...@..p */
	0x1A,0x80,0x70,0x01,0x13,0x40,0x00,0x01,	/* 0CE8: .p..@.. */
	0x70,0x80,0x12,0x80,0x70,0x01,0x4C,0xD7,	/* 0CF0: p.p.L */
	0x30,0xFC,0x4F,0xEF,0x00,0x20,0x4E,0x5E,	/* 0CF8: 0O. N^ */
	0x4E,0x75,0x4E,0x71,0xF0,0xD0,0x00,0xF0,	/* 0D00: NuNq. */
	0x00,0xC0,0x00,0x00,0xF0,0xD0,0xF0,0xF0,	/* 0D08: ... */
	0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x03,	/* 0D10: ....... */
	0x00,0x04,0x00,0x07,0x22,0x79,0x00,0x00,	/* 0D18: ...."y.. */
	0x62,0xA4,0x30,0x11,0x80,0xBC,0x00,0x00,	/* 0D20: b0... */
	0x00,0x01,0x32,0x80,0x30,0x11,0xC0,0xBC,	/* 0D28: ..20. */
	0x00,0x00,0xFF,0xFE,0x32,0x80,0x20,0x79,	/* 0D30: ..2 y */
	0x00,0x00,0x64,0x88,0x70,0x00,0x54,0x88,	/* 0D38: ..dp.T */
	0x10,0x28,0x00,0x01,0xE1,0x88,0x10,0x10,	/* 0D40: .(.... */
	0x72,0x00,0x32,0x00,0x70,0x0A,0xB0,0x81,	/* 0D48: r.2.p. */
	0x6C,0x36,0x70,0x00,0x10,0x28,0x00,0x01,	/* 0D50: l6p..(.. */
	0xE1,0x88,0x10,0x10,0x72,0x00,0x32,0x00,	/* 0D58: ..r.2. */
	0xB2,0xBC,0x00,0x00,0x03,0xE8,0x6C,0x20,	/* 0D60: ...l  */
	0x72,0x00,0x70,0x00,0x12,0x28,0x00,0x01,	/* 0D68: r.p..(.. */
	0xE1,0x89,0x12,0x10,0x30,0x01,0x22,0x00,	/* 0D70: ..0.". */
	0x20,0x3C,0x00,0x00,0x26,0x25,0x4C,0x41,	/* 0D78:  <..&%LA */
	0x08,0x00,0x33,0x40,0x00,0x04,0x60,0x06,	/* 0D80: ..3@..`. */
	0x70,0x61,0x33,0x40,0x00,0x04,0x32,0xBC,	/* 0D88: pa3@..2 */
	0xFF,0x1C,0x42,0x69,0x00,0x0C,0x30,0x11,	/* 0D90: .Bi..0. */
	0x80,0xBC,0x00,0x00,0x00,0x01,0x32,0x80,	/* 0D98: ....2 */
	0x4E,0x75,0x4E,0x71,0x4F,0xEF,0xFF,0xEC,	/* 0DA0: NuNqO */
	0x48,0xD7,0x23,0x03,0x2A,0x79,0x00,0x00,	/* 0DA8: H#.*y.. */
	0x64,0x88,0x20,0x7C,0x00,0x00,0x62,0xA0,	/* 0DB0: d |..b */
	0x70,0x00,0x22,0x68,0x00,0x04,0x54,0x8D,	/* 0DB8: p."h..T */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 0DC0: .-.... */
	0x72,0x00,0x32,0x00,0x4A,0x81,0x67,0x00,	/* 0DC8: r.2.Jg. */
	0x00,0x76,0x70,0x00,0x10,0x2D,0x00,0x01,	/* 0DD0: .vp..-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x32,0x00,	/* 0DD8: ..r.2. */
	0x20,0x01,0x22,0x3C,0x00,0x00,0x26,0x25,	/* 0DE0:  ."<..&% */
	0x4C,0x40,0x18,0x01,0x70,0x00,0x30,0x29,	/* 0DE8: L@..p.0) */
	0x00,0x04,0xB0,0x81,0x67,0x50,0x70,0x00,	/* 0DF0: ..gPp. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 0DF8: .-.... */
	0x72,0x00,0x32,0x00,0x70,0x0A,0xB0,0x81,	/* 0E00: r.2.p. */
	0x6C,0x36,0x70,0x00,0x10,0x2D,0x00,0x01,	/* 0E08: l6p..-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x32,0x00,	/* 0E10: ..r.2. */
	0xB2,0xBC,0x00,0x00,0x03,0xE8,0x6C,0x20,	/* 0E18: ...l  */
	0x72,0x00,0x70,0x00,0x12,0x2D,0x00,0x01,	/* 0E20: r.p..-.. */
	0xE1,0x89,0x12,0x15,0x30,0x01,0x22,0x00,	/* 0E28: ..0.". */
	0x20,0x3C,0x00,0x00,0x26,0x25,0x4C,0x41,	/* 0E30:  <..&%LA */
	0x08,0x00,0x33,0x40,0x00,0x04,0x60,0x06,	/* 0E38: ..3@..`. */
	0x70,0x61,0x33,0x40,0x00,0x04,0x70,0x02,	/* 0E40: pa3@..p. */
	0x13,0x40,0x00,0x11,0x70,0x01,0x10,0x80,	/* 0E48: .@..p.. */
	0x4C,0xD7,0x23,0x03,0x4F,0xEF,0x00,0x14,	/* 0E50: L#.O.. */
	0x4E,0x73,0x4E,0x71,0x20,0x79,0x00,0x00,	/* 0E58: NsNq y.. */
	0x64,0x88,0x70,0x00,0x72,0x00,0x43,0xE8,	/* 0E60: dp.r.C */
	0x00,0x0A,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 0E68: ...).. */
	0x10,0x11,0x52,0x80,0x32,0x00,0x20,0x01,	/* 0E70: ..R2. . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x81,	/* 0E78: .@... */
	0x4E,0xB9,0x00,0x00,0x0E,0x90,0x42,0x39,	/* 0E80: N...B9 */
	0x00,0x00,0x62,0xA0,0x4E,0x75,0x00,0x00,	/* 0E88: ..bNu.. */
	0x4F,0xEF,0xFF,0xF4,0x20,0x79,0x00,0x00,	/* 0E90: O y.. */
	0x64,0x88,0x70,0x00,0x48,0xD7,0x28,0x40,	/* 0E98: dp.H(@ */
	0x43,0xE8,0x00,0x0A,0x7C,0x00,0x2A,0x7C,	/* 0EA0: C..|.*| */
	0x01,0x01,0x81,0x80,0x26,0x7C,0x00,0x00,	/* 0EA8: ..&|.. */
	0x62,0xA8,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 0EB0: b.).. */
	0x10,0x11,0x52,0x80,0x3C,0x00,0x20,0x06,	/* 0EB8: ..R<. . */
	0x12,0x86,0xE0,0x80,0x13,0x40,0x00,0x01,	/* 0EC0: ..@.. */
	0x10,0x39,0x01,0x01,0x81,0x86,0xC0,0xBC,	/* 0EC8: .9.. */
	0x00,0x00,0x00,0xF0,0x4A,0x00,0x66,0x00,	/* 0ED0: ...J.f. */
	0x00,0x7C,0x4F,0xEF,0xFF,0xF4,0x48,0xD7,	/* 0ED8: .|OH */
	0x14,0x80,0x24,0x7C,0x01,0x01,0x81,0x80,	/* 0EE0: .$|.. */
	0x2C,0x3C,0x01,0x01,0x80,0x00,0x4A,0x2D,	/* 0EE8: ,<...J- */
	0x00,0x0E,0x66,0x3E,0x43,0xED,0x00,0x08,	/* 0EF0: ..f>C.. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 0EF8: p..).. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x20,0x00,	/* 0F00: .... . */
	0x67,0x28,0x7E,0x00,0x1E,0x2D,0x00,0x18,	/* 0F08: g(~..-.. */
	0x2F,0x0D,0x4E,0xB9,0x00,0x00,0x42,0x0C,	/* 0F10: ..N..B. */
	0x58,0x8F,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 0F18: X... */
	0xBE,0x80,0x67,0x0E,0x1B,0x40,0x00,0x18,	/* 0F20: g..@.. */
	0x08,0xED,0x00,0x01,0x00,0x19,0x70,0x01,	/* 0F28: .....p. */
	0x36,0x80,0x43,0xED,0x00,0x2E,0x70,0x00,	/* 0F30: 6C..p. */
	0x72,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 0F38: r..).. */
	0x10,0x11,0x32,0x00,0x2A,0x41,0xDB,0xC6,	/* 0F40: ..2.*A */
	0xBB,0xCA,0x66,0xA2,0x4C,0xD7,0x14,0x80,	/* 0F48: fL. */
	0x4F,0xEF,0x00,0x0C,0x70,0x00,0x30,0x13,	/* 0F50: O..p.0. */
	0x4A,0x80,0x66,0x0A,0x70,0x00,0x30,0x2B,	/* 0F58: Jf.p.0+ */
	0x00,0x02,0x4A,0x80,0x67,0x2E,0x22,0x79,	/* 0F60: ..Jg."y */
	0x00,0x00,0x64,0x88,0x50,0x89,0x42,0x29,	/* 0F68: ..dPB) */
	0x00,0x01,0x70,0x01,0x12,0x80,0x30,0x13,	/* 0F70: ..p..0. */
	0x13,0xC0,0x03,0x01,0xFC,0x80,0x20,0x79,	/* 0F78: ... y */
	0x00,0x00,0x64,0x88,0x10,0x28,0x00,0x0C,	/* 0F80: ..d.(.. */
	0x52,0x80,0x11,0x40,0x00,0x0C,0x42,0x53,	/* 0F88: R.@..BS */
	0x42,0x6B,0x00,0x02,0x4C,0xD7,0x28,0x40,	/* 0F90: Bk..L(@ */
	0x4F,0xEF,0x00,0x0C,0x4E,0x75,0x00,0x00,	/* 0F98: O..Nu.. */
	0x4E,0x56,0xFF,0xF8,0x70,0x00,0x4F,0xEF,	/* 0FA0: NVp.O */
	0xFF,0xE0,0x48,0xD7,0x30,0xFC,0x2A,0x6E,	/* 0FA8: H0*n */
	0x00,0x08,0x7E,0x00,0x7C,0x00,0x49,0xED,	/* 0FB0: ..~.|.I */
	0x00,0x02,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 0FB8: ...,.. */
	0x10,0x14,0x49,0xED,0x00,0x08,0x3E,0x00,	/* 0FC0: ..I..>. */
	0x1C,0x2C,0x00,0x01,0xE1,0x8E,0x1C,0x14,	/* 0FC8: .,.... */
	0x4A,0x2D,0x00,0x45,0x66,0x06,0x70,0xFF,	/* 0FD0: J-.Ef.p */
	0x1B,0x40,0x00,0x45,0x49,0xED,0x00,0x04,	/* 0FD8: .@.EI.. */
	0x70,0x00,0x26,0x3C,0x04,0x01,0xF0,0xFE,	/* 0FE0: p.&<.. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 0FE8: .,.... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 0FF0: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 0FF8:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 1000: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xC3,	/* 1008:  G.-.. */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 1010: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 1018: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x4A,0x2D,	/* 1020: .....J- */
	0x00,0x1F,0x67,0x58,0x49,0xED,0x00,0x04,	/* 1028: ..gXI.. */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 1030: p..,.. */
	0x10,0x14,0x72,0x00,0x32,0x00,0xC2,0xBC,	/* 1038: ..r.2. */
	0xFF,0xFF,0x7F,0xFF,0x70,0x00,0x28,0x41,	/* 1040: p.(A */
	0x10,0x2D,0x00,0x07,0xD9,0xFC,0x01,0x01,	/* 1048: .-.... */
	0x80,0x00,0x59,0x80,0x6D,0x14,0x10,0x2C,	/* 1050: .Ym.., */
	0x00,0x1D,0x20,0x47,0xD1,0xC3,0x52,0x80,	/* 1058: .. GR */
	0x19,0x40,0x00,0x1D,0x70,0x24,0x10,0x80,	/* 1060: .@..p$. */
	0x60,0x12,0x10,0x2C,0x00,0x1C,0x20,0x47,	/* 1068: `..,.. G */
	0xD1,0xC3,0x52,0x80,0x19,0x40,0x00,0x1C,	/* 1070: R.@.. */
	0x70,0x08,0x10,0x80,0x42,0x2D,0x00,0x1F,	/* 1078: p..B-.. */
	0x60,0x00,0x00,0xBA,0x70,0x00,0x10,0x2D,	/* 1080: `..p..- */
	0x00,0x45,0x72,0x23,0xC2,0x80,0x67,0x00,	/* 1088: .Er#g. */
	0x00,0xAC,0x16,0x2D,0x00,0x30,0x08,0x03,	/* 1090: ..-.0.. */
	0x00,0x01,0x67,0x12,0x20,0x47,0xD1,0xFC,	/* 1098: ..g. G */
	0x04,0x01,0xF0,0x16,0x10,0x10,0x08,0x00,	/* 10A0: ....... */
	0x00,0x02,0x66,0x00,0x00,0x8A,0x08,0x2D,	/* 10A8: ..f...- */
	0x00,0x04,0x00,0x32,0x67,0x12,0x20,0x47,	/* 10B0: ...2g. G */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0x10,0x10,	/* 10B8: .... */
	0x08,0x00,0x00,0x06,0x67,0x00,0x00,0x70,	/* 10C0: ....g..p */
	0x08,0x03,0x00,0x04,0x67,0x10,0x20,0x47,	/* 10C8: ....g. G */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0x10,0x10,	/* 10D0: .... */
	0x08,0x00,0x00,0x04,0x67,0x58,0x30,0x06,	/* 10D8: ....gX0. */
	0xC0,0xBC,0x00,0x00,0x02,0x00,0x66,0x4E,	/* 10E0: ....fN */
	0x4A,0x2D,0x00,0x25,0x66,0x48,0x8C,0xBC,	/* 10E8: J-.%fH */
	0x00,0x00,0x01,0x00,0x49,0xED,0x00,0x08,	/* 10F0: ....I.. */
	0x8C,0xBC,0x00,0x00,0x00,0x01,0xCC,0xBC,	/* 10F8: .... */
	0x00,0x00,0xFF,0xFF,0x26,0x06,0x20,0x03,	/* 1100: ..&. . */
	0xE0,0x80,0x19,0x40,0x00,0x01,0x18,0x83,	/* 1108: .@... */
	0x4A,0x2D,0x00,0x27,0x67,0x0E,0x20,0x47,	/* 1110: J-.'g. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x0C,0x70,0x84,	/* 1118: ...p */
	0x10,0x80,0x60,0x0C,0x20,0x47,0xD1,0xFC,	/* 1120: .`. G */
	0x04,0x01,0xF0,0x0C,0x70,0x92,0x10,0x80,	/* 1128: ...p. */
	0x70,0x01,0x60,0x00,0x07,0xD6,0xCC,0xBC,	/* 1130: p.`.. */
	0x00,0x00,0xFD,0xFF,0x26,0x3C,0x04,0x01,	/* 1138: ..&<.. */
	0xF0,0x0A,0x20,0x47,0xD1,0xC3,0x10,0x10,	/* 1140: . G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x4A,0x00,	/* 1148: ...J. */
	0x67,0x06,0x70,0x00,0x60,0x00,0x07,0xB4,	/* 1150: g.p.`.. */
	0x4A,0x2D,0x00,0x25,0x66,0x00,0x07,0x2E,	/* 1158: J-.%f... */
	0x70,0x01,0x1B,0x40,0x00,0x25,0x4A,0x2D,	/* 1160: p..@.%J- */
	0x00,0x27,0x67,0x44,0x20,0x47,0xD1,0xFC,	/* 1168: .'gD G */
	0x04,0x01,0xF0,0x80,0x10,0x10,0x72,0x42,	/* 1170: ....rB */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0xB2,0x80,	/* 1178: ... */
	0x66,0x18,0x20,0x47,0x70,0x42,0xD1,0xFC,	/* 1180: f. GpB */
	0x04,0x01,0xF0,0xEC,0x42,0x10,0x20,0x47,	/* 1188: ..B. G */
	0xD1,0xFC,0x04,0x01,0xF0,0xE4,0x10,0x80,	/* 1190: ... */
	0x60,0x0C,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 1198: `. G.. */
	0xF0,0xE4,0x70,0x1F,0x10,0x80,0x70,0x20,	/* 11A0: p..p  */
	0x1B,0x40,0x00,0x2A,0x60,0x00,0x03,0x24,	/* 11A8: .@.*`..$ */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x80,	/* 11B0:  G.. */
	0x10,0x10,0x72,0x42,0xC0,0xBC,0x00,0x00,	/* 11B8: ..rB.. */
	0x00,0xFF,0xB2,0x80,0x66,0x08,0x28,0x7C,	/* 11C0: .f.(| */
	0x00,0x00,0x32,0xB0,0x60,0x06,0x28,0x7C,	/* 11C8: ..2`.(| */
	0x00,0x00,0x32,0xE8,0x08,0x2D,0x00,0x00,	/* 11D0: ..2.-.. */
	0x00,0x45,0x67,0x00,0x01,0x54,0x1A,0x2D,	/* 11D8: .Eg..T.- */
	0x00,0x16,0x78,0x00,0x70,0x48,0x18,0x2D,	/* 11E0: ..x.pH.- */
	0x00,0x06,0xCA,0xBC,0x00,0x00,0x00,0x0F,	/* 11E8: ...... */
	0xB0,0x84,0x66,0x2A,0xCA,0xBC,0x00,0x00,	/* 11F0: f*.. */
	0xFF,0xFF,0x70,0x0F,0xB0,0x85,0x66,0x06,	/* 11F8: p.f. */
	0x7A,0x00,0x1A,0x2D,0x00,0x33,0x70,0x48,	/* 1200: z..-.3pH */
	0xB0,0x84,0x66,0x12,0xCA,0xBC,0x00,0x00,	/* 1208: f... */
	0xFF,0xFF,0x70,0x1E,0xB0,0x85,0x63,0x12,	/* 1210: p.c. */
	0x70,0x48,0xB0,0x84,0x67,0x12,0xCA,0xBC,	/* 1218: pHg. */
	0x00,0x00,0xFF,0xFF,0x70,0x0E,0xB0,0x85,	/* 1220: ..p. */
	0x6E,0x06,0x7A,0x00,0x1A,0x2D,0x00,0x36,	/* 1228: n.z..-.6 */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x70,0x14,	/* 1230: ..p. */
	0xB0,0x85,0x65,0x16,0x20,0x7C,0x00,0x00,	/* 1238: e. |.. */
	0x33,0x60,0xCA,0xBC,0x00,0x00,0xFF,0xFF,	/* 1240: 3`.. */
	0xD1,0xC5,0x10,0x10,0x1B,0x40,0x00,0x2A,	/* 1248: ...@.* */
	0x60,0x06,0x70,0x20,0x1B,0x40,0x00,0x2A,	/* 1250: `.p .@.* */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x20,0x47,	/* 1258: .. G */
	0x43,0xF4,0x5C,0x00,0xD1,0xFC,0x04,0x01,	/* 1260: C\... */
	0xF0,0xE4,0x7A,0x00,0x30,0x11,0x10,0x80,	/* 1268: z.0.. */
	0x20,0x47,0x30,0x29,0x00,0x02,0xD1,0xFC,	/* 1270:  G0).. */
	0x04,0x01,0xF0,0xEC,0x10,0x80,0x18,0x2D,	/* 1278: ....- */
	0x00,0x16,0x10,0x2D,0x00,0x2D,0xC0,0xBC,	/* 1280: ...-.- */
	0x00,0x00,0x00,0xF0,0x12,0x04,0x1A,0x04,	/* 1288: ....... */
	0xC2,0xBC,0x00,0x00,0x00,0x0F,0xE8,0x85,	/* 1290: .... */
	0x78,0x00,0x80,0x81,0x1B,0x40,0x00,0x2D,	/* 1298: x..@.- */
	0x1B,0x6D,0x00,0x33,0x00,0x36,0x70,0x48,	/* 12A0: .m.3.6pH */
	0x18,0x2D,0x00,0x06,0xB0,0x84,0x66,0x2A,	/* 12A8: .-..f* */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x70,0x0F,	/* 12B0: ..p. */
	0xB0,0x85,0x66,0x06,0x7A,0x00,0x1A,0x2D,	/* 12B8: f.z..- */
	0x00,0x34,0x70,0x48,0xB0,0x84,0x66,0x12,	/* 12C0: .4pHf. */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x70,0x1E,	/* 12C8: ..p. */
	0xB0,0x85,0x63,0x12,0x70,0x48,0xB0,0x84,	/* 12D0: c.pH */
	0x67,0x12,0xCA,0xBC,0x00,0x00,0xFF,0xFF,	/* 12D8: g... */
	0x70,0x0E,0xB0,0x85,0x6E,0x06,0x7A,0x00,	/* 12E0: p.n.z. */
	0x1A,0x2D,0x00,0x37,0xCA,0xBC,0x00,0x00,	/* 12E8: .-.7.. */
	0xFF,0xFF,0x20,0x47,0x43,0xF4,0x5C,0x00,	/* 12F0:  GC\. */
	0xD1,0xFC,0x04,0x01,0xF0,0xF0,0x30,0x11,	/* 12F8: ..0. */
	0x10,0x80,0x20,0x47,0x30,0x29,0x00,0x02,	/* 1300: . G0).. */
	0xD1,0xFC,0x04,0x01,0xF0,0xF8,0x10,0x80,	/* 1308: ... */
	0x10,0x2D,0x00,0x2D,0x12,0x2D,0x00,0x16,	/* 1310: .-.-.-.. */
	0xC0,0xBC,0x00,0x00,0x00,0x0F,0xC2,0xBC,	/* 1318: .... */
	0x00,0x00,0x00,0xF0,0x80,0x81,0x1B,0x40,	/* 1320: ....@ */
	0x00,0x2D,0x1B,0x6D,0x00,0x34,0x00,0x37,	/* 1328: .-.m.4.7 */
	0x08,0x2D,0x00,0x01,0x00,0x45,0x67,0x00,	/* 1330: .-...Eg. */
	0x02,0x06,0x49,0xED,0x00,0x38,0x42,0x2C,	/* 1338: ..I.8B, */
	0x00,0x01,0x42,0x14,0x49,0xED,0x00,0x3A,	/* 1340: ..B.I.: */
	0x42,0x2C,0x00,0x01,0x42,0x14,0x49,0xED,	/* 1348: B,..B.I */
	0x00,0x3C,0x42,0x2C,0x00,0x01,0x42,0x14,	/* 1350: .<B,..B. */
	0x49,0xED,0x00,0x3E,0x42,0x2C,0x00,0x01,	/* 1358: I.>B,.. */
	0x70,0x00,0x42,0x14,0x10,0x2D,0x00,0x06,	/* 1360: p.B..-.. */
	0x72,0x48,0xB2,0x80,0x66,0x08,0x70,0x20,	/* 1368: rHf.p  */
	0x1B,0x40,0x00,0x42,0x60,0x06,0x70,0x0C,	/* 1370: .@.B`.p. */
	0x1B,0x40,0x00,0x42,0x42,0x2D,0x00,0x43,	/* 1378: .@.BB-.C */
	0x42,0x2D,0x00,0x44,0x20,0x47,0x10,0x2D,	/* 1380: B-.D G.- */
	0x00,0x1D,0xD1,0xFC,0x04,0x01,0xF0,0x34,	/* 1388: ....4 */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x1E,	/* 1390: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0x36,0x10,0x80,	/* 1398: ..6. */
	0x20,0x47,0x10,0x2D,0x00,0x1B,0xD1,0xFC,	/* 13A0:  G.-.. */
	0x04,0x01,0xF0,0x38,0x10,0x80,0x20,0x47,	/* 13A8: ..8. G */
	0x10,0x2D,0x00,0x1C,0xD1,0xFC,0x04,0x01,	/* 13B0: .-.... */
	0xF0,0x3A,0x10,0x80,0x7A,0x00,0x42,0x2D,	/* 13B8: :.z.B- */
	0x00,0x19,0x1A,0x2D,0x00,0x14,0x38,0x05,	/* 13C0: ...-..8. */
	0x30,0x05,0xC8,0xBC,0x00,0x00,0x00,0x03,	/* 13C8: 0..... */
	0xC0,0xBC,0x00,0x00,0x00,0x10,0x66,0x28,	/* 13D0: ....f( */
	0x30,0x05,0xC0,0xBC,0x00,0x00,0x00,0x08,	/* 13D8: 0..... */
	0x67,0x08,0x88,0xBC,0x00,0x00,0x00,0x20,	/* 13E0: g....  */
	0x60,0x06,0x88,0xBC,0x00,0x00,0x00,0x40,	/* 13E8: `....@ */
	0x30,0x05,0xC0,0xBC,0x00,0x00,0x00,0x04,	/* 13F0: 0..... */
	0x67,0x06,0x88,0xBC,0x00,0x00,0x00,0x80,	/* 13F8: g.... */
	0x08,0x2D,0x00,0x07,0x00,0x1A,0x66,0x06,	/* 1400: .-....f. */
	0x88,0xBC,0x00,0x00,0x00,0x10,0x7A,0x00,	/* 1408: ....z. */
	0x1A,0x2D,0x00,0x15,0x72,0x0F,0x30,0x05,	/* 1410: .-..r.0. */
	0xC0,0xBC,0x00,0x00,0x00,0x0F,0xB2,0x80,	/* 1418: .... */
	0x66,0x06,0x88,0xBC,0x00,0x00,0x00,0x08,	/* 1420: f..... */
	0x20,0x47,0x30,0x05,0xD1,0xFC,0x04,0x01,	/* 1428:  G0... */
	0xF0,0x10,0x10,0x84,0x78,0x00,0xC0,0xBC,	/* 1430: ..x. */
	0x00,0x00,0x00,0x80,0x67,0x02,0x78,0x10,	/* 1438: ...g.x. */
	0x20,0x47,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 1440:  Gp... */
	0xF0,0x12,0x10,0x84,0x10,0x2D,0x00,0x06,	/* 1448: ...-.. */
	0x72,0x48,0xB2,0x80,0x66,0x0E,0x20,0x47,	/* 1450: rHf. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x14,0x70,0x84,	/* 1458: ...p */
	0x10,0x80,0x60,0x0C,0x20,0x47,0xD1,0xFC,	/* 1460: .`. G */
	0x04,0x01,0xF0,0x14,0x70,0x08,0x10,0x80,	/* 1468: ...p.. */
	0x7A,0x00,0x1A,0x2D,0x00,0x20,0x1B,0x45,	/* 1470: z..-. .E */
	0x00,0x21,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 1478: .!0... */
	0x00,0x80,0x67,0x04,0x78,0x00,0x60,0x1E,	/* 1480: .g.x.`. */
	0x30,0x05,0xC0,0xBC,0x00,0x00,0x00,0x08,	/* 1488: 0..... */
	0x67,0x04,0x78,0x02,0x60,0x10,0x30,0x05,	/* 1490: g.x.`.0. */
	0xC0,0xBC,0x00,0x00,0x00,0x04,0x67,0x04,	/* 1498: ....g. */
	0x78,0x04,0x60,0x02,0x78,0x03,0x30,0x05,	/* 14A0: x.`.x.0. */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x67,0x08,	/* 14A8: ....g. */
	0x88,0xBC,0x00,0x00,0x00,0x18,0x60,0x10,	/* 14B0: ....`. */
	0x30,0x05,0xC0,0xBC,0x00,0x00,0x00,0x02,	/* 14B8: 0..... */
	0x66,0x06,0x88,0xBC,0x00,0x00,0x00,0x08,	/* 14C0: f..... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x3C,	/* 14C8:  G..< */
	0x10,0x84,0x08,0x2D,0x00,0x01,0x00,0x45,	/* 14D0: ..-...E */
	0x67,0x00,0x00,0x64,0x7A,0x00,0x08,0x2D,	/* 14D8: g..dz..- */
	0x00,0x02,0x00,0x1A,0x67,0x2E,0x4A,0x2D,	/* 14E0: ....g.J- */
	0x00,0x27,0x67,0x1E,0x20,0x47,0xD1,0xFC,	/* 14E8: .'g. G */
	0x04,0x01,0xF0,0x80,0x10,0x10,0x72,0x42,	/* 14F0: ....rB */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0xB2,0x80,	/* 14F8: ... */
	0x66,0x08,0x8C,0xBC,0x00,0x00,0x04,0x00,	/* 1500: f..... */
	0x60,0x10,0xCC,0xBC,0x00,0x00,0xFB,0xFF,	/* 1508: `... */
	0x7A,0x02,0x60,0x06,0xCC,0xBC,0x00,0x00,	/* 1510: z.`... */
	0xFB,0xFF,0x70,0x00,0x10,0x2D,0x00,0x22,	/* 1518: p..-." */
	0xB0,0xBC,0x00,0x00,0x00,0xFF,0x67,0x0C,	/* 1520: ...g. */
	0x4A,0x2D,0x00,0x27,0x66,0x06,0x8A,0xBC,	/* 1528: J-.'f. */
	0x00,0x00,0x00,0x80,0x20,0x47,0xD1,0xFC,	/* 1530: ... G */
	0x04,0x01,0xF0,0x3E,0x10,0x85,0x4A,0x2D,	/* 1538: ..>.J- */
	0x00,0x27,0x66,0x00,0x02,0x6C,0x78,0x00,	/* 1540: .'f..lx. */
	0x7A,0x00,0x70,0x00,0x3D,0x40,0xFF,0xFC,	/* 1548: z.p.=@ */
	0x70,0x00,0x3D,0x40,0xFF,0xFE,0x14,0x2D,	/* 1550: p.=@.- */
	0x00,0x1A,0x10,0x2D,0x00,0x30,0xB5,0x80,	/* 1558: ...-.0 */
	0x1D,0x40,0xFF,0xFA,0x10,0x2E,0xFF,0xFA,	/* 1560: .@.. */
	0x08,0x00,0x00,0x03,0x67,0x0E,0x38,0x3C,	/* 1568: ....g.8< */
	0x01,0x00,0x08,0x02,0x00,0x03,0x67,0x04,	/* 1570: ......g. */
	0x3A,0x3C,0x01,0x00,0x1D,0x6D,0x00,0x14,	/* 1578: :<...m.. */
	0xFF,0xFB,0x10,0x2E,0xFF,0xFB,0x12,0x2D,	/* 1580: ...- */
	0x00,0x31,0xB3,0x80,0x08,0x00,0x00,0x07,	/* 1588: .1.... */
	0x67,0x16,0x88,0xBC,0x00,0x00,0x10,0x00,	/* 1590: g..... */
	0x10,0x2E,0xFF,0xFB,0x08,0x00,0x00,0x07,	/* 1598: ...... */
	0x67,0x10,0x8A,0xBC,0x00,0x00,0x10,0x00,	/* 15A0: g..... */
	0x10,0x2E,0xFF,0xFB,0x08,0x00,0x00,0x07,	/* 15A8: ...... */
	0x66,0x18,0x30,0x3C,0x10,0x00,0x3D,0x40,	/* 15B0: f.0<..=@ */
	0xFF,0xFC,0x08,0x2D,0x00,0x00,0x00,0x17,	/* 15B8: .-.... */
	0x67,0x08,0x30,0x3C,0x10,0x00,0x3D,0x40,	/* 15C0: g.0<..=@ */
	0xFF,0xFE,0x10,0x2E,0xFF,0xFA,0x08,0x00,	/* 15C8: .... */
	0x00,0x06,0x67,0x12,0x88,0xBC,0x00,0x00,	/* 15D0: ..g... */
	0x20,0x00,0x08,0x02,0x00,0x06,0x67,0x0C,	/* 15D8:  .....g. */
	0x8A,0xBC,0x00,0x00,0x20,0x00,0x08,0x02,	/* 15E0: .. ... */
	0x00,0x06,0x66,0x24,0x30,0x2E,0xFF,0xFC,	/* 15E8: ..f$0. */
	0x80,0xBC,0x00,0x00,0x20,0x00,0x3D,0x40,	/* 15F0: .. .=@ */
	0xFF,0xFC,0x08,0x2D,0x00,0x01,0x00,0x17,	/* 15F8: .-.... */
	0x67,0x0E,0x30,0x2E,0xFF,0xFE,0x80,0xBC,	/* 1600: g.0. */
	0x00,0x00,0x20,0x00,0x3D,0x40,0xFF,0xFE,	/* 1608: .. .=@ */
	0x70,0x00,0x10,0x2E,0xFF,0xFA,0x72,0x03,	/* 1610: p...r. */
	0xC2,0x80,0x67,0x20,0x88,0xBC,0x00,0x00,	/* 1618: g .. */
	0x00,0x03,0x08,0x02,0x00,0x01,0x67,0x14,	/* 1620: ......g. */
	0x08,0x02,0x00,0x00,0x67,0x08,0x8A,0xBC,	/* 1628: ....g. */
	0x00,0x00,0x00,0x02,0x60,0x06,0x8A,0xBC,	/* 1630: ....`. */
	0x00,0x00,0x00,0x01,0x1D,0x6D,0x00,0x15,	/* 1638: .....m.. */
	0xFF,0xFB,0x10,0x2E,0xFF,0xFB,0x12,0x2D,	/* 1640: ...- */
	0x00,0x32,0xB3,0x80,0x08,0x00,0x00,0x04,	/* 1648: .2.... */
	0x67,0x16,0x88,0xBC,0x00,0x00,0x00,0x10,	/* 1650: g..... */
	0x10,0x2E,0xFF,0xFB,0x08,0x00,0x00,0x04,	/* 1658: ...... */
	0x67,0x06,0x8A,0xBC,0x00,0x00,0x00,0x10,	/* 1660: g..... */
	0x10,0x2E,0xFF,0xFA,0x08,0x00,0x00,0x04,	/* 1668: ...... */
	0x67,0x12,0x88,0xBC,0x00,0x00,0x00,0x20,	/* 1670: g....  */
	0x08,0x02,0x00,0x04,0x67,0x06,0x8A,0xBC,	/* 1678: ....g. */
	0x00,0x00,0x00,0x20,0x08,0x2D,0x00,0x05,	/* 1680: ... .-.. */
	0x00,0x45,0x67,0x1A,0xCA,0xBC,0x00,0x00,	/* 1688: .Eg... */
	0xFF,0xFF,0x2F,0x05,0xC8,0xBC,0x00,0x00,	/* 1690: .... */
	0xFF,0xFF,0x2F,0x04,0x2F,0x0D,0x61,0x00,	/* 1698: ....a. */
	0x0D,0x5C,0x4F,0xEF,0x00,0x0C,0x08,0x2D,	/* 16A0: .\O...- */
	0x00,0x04,0x00,0x45,0x67,0x1A,0x70,0x00,	/* 16A8: ...Eg.p. */
	0x30,0x2E,0xFF,0xFE,0x2F,0x00,0x70,0x00,	/* 16B0: 0...p. */
	0x30,0x2E,0xFF,0xFC,0x2F,0x00,0x2F,0x0D,	/* 16B8: 0..... */
	0x61,0x00,0x12,0x06,0x4F,0xEF,0x00,0x0C,	/* 16C0: a...O.. */
	0x08,0x2D,0x00,0x05,0x00,0x1A,0x67,0x42,	/* 16C8: .-....gB */
	0x2F,0x0D,0x61,0x00,0x14,0xD8,0x7A,0x00,	/* 16D0: ..a..z. */
	0x20,0x47,0x28,0x3C,0x04,0x01,0xF0,0x2A,	/* 16D8:  G(<..* */
	0x22,0x47,0x58,0x8F,0x1A,0x2D,0x00,0x26,	/* 16E0: "GX.-.& */
	0xD1,0xFC,0x04,0x01,0xF0,0x2C,0xD3,0xC4,	/* 16E8: .., */
	0xCA,0xBC,0x00,0x00,0x00,0xF0,0x10,0x85,	/* 16F0: .... */
	0x20,0x47,0x10,0x11,0xD1,0xC4,0x32,0x05,	/* 16F8:  G..2. */
	0xC2,0xBC,0x00,0x00,0x00,0xF0,0xC0,0xBC,	/* 1700: ... */
	0x00,0x00,0x00,0x0F,0x80,0x81,0x10,0x80,	/* 1708: ..... */
	0x60,0x28,0x70,0x24,0x20,0x47,0x2A,0x3C,	/* 1710: `(p$ G*< */
	0x04,0x01,0xF0,0x2A,0x22,0x47,0x1B,0x40,	/* 1718: ..*"G.@ */
	0x00,0x18,0xD1,0xFC,0x04,0x01,0xF0,0x2C,	/* 1720: ...., */
	0xD3,0xC5,0x42,0x10,0x10,0x11,0x20,0x47,	/* 1728: B... G */
	0xD1,0xC5,0xC0,0xBC,0x00,0x00,0x00,0x0F,	/* 1730: .... */
	0x10,0x80,0xCC,0xBC,0x00,0x00,0xDF,0xFF,	/* 1738: ... */
	0x1A,0x2D,0x00,0x1A,0x08,0x05,0x00,0x05,	/* 1740: .-...... */
	0x67,0x06,0x8C,0xBC,0x00,0x00,0x20,0x00,	/* 1748: g... . */
	0x08,0x2D,0x00,0x05,0x00,0x45,0x67,0x00,	/* 1750: .-...Eg. */
	0x00,0x7C,0xCC,0xBC,0x00,0x00,0xFF,0xF4,	/* 1758: .|.. */
	0x08,0x05,0x00,0x01,0x67,0x06,0x8C,0xBC,	/* 1760: ....g. */
	0x00,0x00,0x00,0x02,0x08,0x05,0x00,0x03,	/* 1768: ........ */
	0x67,0x06,0x8C,0xBC,0x00,0x00,0x00,0x08,	/* 1770: g..... */
	0x08,0x05,0x00,0x00,0x67,0x06,0x8C,0xBC,	/* 1778: ....g. */
	0x00,0x00,0x00,0x01,0x08,0x2D,0x00,0x07,	/* 1780: .....-.. */
	0x00,0x14,0x67,0x06,0x8C,0xBC,0x00,0x00,	/* 1788: ..g... */
	0x00,0x08,0x08,0x05,0x00,0x06,0x67,0x06,	/* 1790: ......g. */
	0x8C,0xBC,0x00,0x00,0x00,0x08,0x30,0x06,	/* 1798: ....0. */
	0xC0,0xBC,0x00,0x00,0x00,0x08,0x67,0x2C,	/* 17A0: ....g, */
	0xCC,0xBC,0x00,0x00,0xFF,0x0F,0x60,0x24,	/* 17A8: ...`$ */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x80,	/* 17B0:  G.. */
	0x10,0x10,0x72,0x42,0xC0,0xBC,0x00,0x00,	/* 17B8: ..rB.. */
	0x00,0xFF,0xB2,0x80,0x67,0x0E,0x08,0x2D,	/* 17C0: .g..- */
	0x00,0x02,0x00,0x1A,0x67,0x06,0x8C,0xBC,	/* 17C8: ....g. */
	0x00,0x00,0x04,0x00,0x1B,0x6D,0x00,0x1A,	/* 17D0: .....m.. */
	0x00,0x30,0x1B,0x6D,0x00,0x14,0x00,0x31,	/* 17D8: .0.m...1 */
	0x1B,0x6D,0x00,0x15,0x00,0x32,0x08,0x2D,	/* 17E0: .m...2.- */
	0x00,0x00,0x00,0x45,0x67,0x00,0x00,0x7A,	/* 17E8: ...Eg..z */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x80,	/* 17F0:  G.. */
	0x10,0x10,0x72,0x42,0xC0,0xBC,0x00,0x00,	/* 17F8: ..rB.. */
	0x00,0xFF,0xB2,0x80,0x66,0x08,0x28,0x7C,	/* 1800: .f.(| */
	0x00,0x00,0x62,0xAC,0x60,0x06,0x28,0x7C,	/* 1808: ..b`.(| */
	0x00,0x00,0x62,0xE4,0x78,0x00,0x7A,0x00,	/* 1810: ..bx.z. */
	0x70,0x48,0x18,0x2D,0x00,0x16,0x1A,0x2D,	/* 1818: pH.-...- */
	0x00,0x06,0xE8,0x84,0xB0,0x85,0x66,0x12,	/* 1820: ..f. */
	0xC8,0xBC,0x00,0x00,0xFF,0xFF,0x70,0x1E,	/* 1828: ..p. */
	0xB0,0x84,0x63,0x12,0x70,0x48,0xB0,0x85,	/* 1830: c.pH */
	0x67,0x1A,0xC8,0xBC,0x00,0x00,0xFF,0xFF,	/* 1838: g... */
	0x70,0x0E,0xB0,0x84,0x6E,0x0E,0x20,0x47,	/* 1840: p.n. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x42,0x70,0x08,	/* 1848: ..Bp. */
	0x10,0x80,0x60,0x14,0x20,0x47,0xD1,0xFC,	/* 1850: .`. G */
	0x04,0x01,0xF0,0x42,0xC8,0xBC,0x00,0x00,	/* 1858: ..B.. */
	0xFF,0xFF,0x20,0x34,0x4C,0x00,0x10,0x80,	/* 1860:  4L.. */
	0x20,0x47,0x70,0x4E,0x49,0xED,0x00,0x08,	/* 1868:  GpNI.. */
	0xCC,0xBC,0x00,0x00,0xFF,0xFF,0xD1,0xC3,	/* 1870: .. */
	0x2E,0x06,0x10,0x80,0x20,0x07,0xE0,0x80,	/* 1878: ... . */
	0x19,0x40,0x00,0x01,0x18,0x87,0x70,0x00,	/* 1880: .@...p. */
	0x60,0x00,0x00,0x80,0x4A,0x2D,0x00,0x27,	/* 1888: `..J-.' */
	0x67,0x1E,0x20,0x47,0x70,0x18,0xD1,0xFC,	/* 1890: g. Gp. */
	0x04,0x01,0xF0,0x2A,0x42,0x10,0x20,0x47,	/* 1898: ..*B. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x2C,0x42,0x10,	/* 18A0: ..,B. */
	0x20,0x47,0xD1,0xC3,0x10,0x80,0x60,0x08,	/* 18A8:  G.`. */
	0x20,0x47,0xD1,0xC3,0x70,0x1A,0x10,0x80,	/* 18B0:  Gp.. */
	0xCC,0xBC,0x00,0x00,0xFF,0xFE,0x49,0xED,	/* 18B8: ..I */
	0x00,0x08,0x20,0x47,0xCC,0xBC,0x00,0x00,	/* 18C0: .. G.. */
	0xFF,0xFF,0x26,0x06,0x20,0x03,0xE0,0x80,	/* 18C8: &. . */
	0x19,0x40,0x00,0x01,0xD1,0xFC,0x04,0x01,	/* 18D0: .@.... */
	0xF0,0x0C,0x18,0x83,0x70,0x90,0x10,0x80,	/* 18D8: ..p. */
	0x42,0x2D,0x00,0x25,0x70,0x00,0x10,0x2D,	/* 18E0: B-.%p..- */
	0x00,0x0E,0x59,0x80,0x66,0x0A,0x2F,0x0D,	/* 18E8: ..Yf... */
	0x61,0x00,0x18,0x36,0x58,0x8F,0x60,0x04,	/* 18F0: a..6X`. */
	0x42,0x2D,0x00,0x0E,0x70,0x01,0x33,0xC0,	/* 18F8: B-..p.3 */
	0x00,0x00,0x62,0xA8,0x42,0x2D,0x00,0x45,	/* 1900: ..bB-.E */
	0x70,0x00,0x4C,0xD7,0x30,0xFC,0x4F,0xEF,	/* 1908: p.L0O */
	0x00,0x20,0x4E,0x5E,0x4E,0x75,0x4E,0x71,	/* 1910: . N^NuNq */
	0x2F,0x0D,0x70,0x00,0x2F,0x07,0x7E,0x00,	/* 1918: ..p...~. */
	0x2A,0x6F,0x00,0x0C,0x43,0xED,0x00,0x02,	/* 1920: *o..C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1928: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 1930: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1938: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 1940: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 1948:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 1950: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 1958:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 1960: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 1968: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 1970: .... */
	0x10,0x80,0x2F,0x0D,0x61,0x00,0x03,0xE2,	/* 1978: ...a.. */
	0x58,0x8F,0x72,0x00,0x32,0x00,0x4A,0x81,	/* 1980: Xr.2.J */
	0x67,0x06,0x70,0x00,0x60,0x00,0x00,0xF8,	/* 1988: g.p.`.. */
	0x10,0x2D,0x00,0x0D,0x12,0x2D,0x00,0x0C,	/* 1990: .-...-.. */
	0x90,0x81,0x4A,0x00,0x67,0x06,0x70,0x01,	/* 1998: J.g.p. */
	0x60,0x00,0x00,0xE4,0x4A,0x2D,0x00,0x1F,	/* 19A0: `..J-.. */
	0x66,0x00,0x00,0xD4,0x4A,0x2D,0x00,0x29,	/* 19A8: f..J-.) */
	0x66,0x22,0x43,0xED,0x00,0x08,0x70,0x00,	/* 19B0: f"C..p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 19B8: .).... */
	0x72,0x00,0x80,0xBC,0x00,0x00,0x02,0x00,	/* 19C0: r..... */
	0x32,0x00,0x20,0x01,0xE0,0x80,0x13,0x40,	/* 19C8: 2. ..@ */
	0x00,0x01,0x12,0x81,0x43,0xED,0x00,0x08,	/* 19D0: ...C.. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 19D8: p..).. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x02,0x00,	/* 19E0: ...... */
	0x67,0x0E,0x2F,0x0D,0x61,0x00,0x00,0x9E,	/* 19E8: g...a.. */
	0x70,0x00,0x58,0x8F,0x60,0x00,0x00,0x90,	/* 19F0: p.X`.. */
	0x43,0xED,0x00,0x08,0x70,0x00,0x10,0x29,	/* 19F8: C..p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x72,0x00,	/* 1A00: ....r. */
	0x80,0xBC,0x00,0x00,0x01,0x00,0x32,0x00,	/* 1A08: ....2. */
	0x20,0x01,0xE0,0x80,0x13,0x40,0x00,0x01,	/* 1A10:  ..@.. */
	0x12,0x81,0x4A,0x2D,0x00,0x27,0x66,0x2E,	/* 1A18: .J-.'f. */
	0x50,0x8D,0x70,0x00,0x20,0x47,0x10,0x2D,	/* 1A20: Pp. G.- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x72,0x00,	/* 1A28: ....r. */
	0x80,0xBC,0x00,0x00,0x00,0x01,0x32,0x00,	/* 1A30: ....2. */
	0x20,0x01,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 1A38:  ..@.. */
	0xD1,0xFC,0x04,0x01,0xF0,0x0C,0x1A,0x81,	/* 1A40: .... */
	0x70,0x92,0x10,0x80,0x60,0x2C,0x50,0x8D,	/* 1A48: p.`,P */
	0x70,0x00,0x20,0x47,0x10,0x2D,0x00,0x01,	/* 1A50: p. G.-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x80,0xBC,	/* 1A58: ..r. */
	0x00,0x00,0x00,0x01,0x32,0x00,0x20,0x01,	/* 1A60: ....2. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0xD1,0xFC,	/* 1A68: .@.. */
	0x04,0x01,0xF0,0x0C,0x1A,0x81,0x70,0x84,	/* 1A70: ....p */
	0x10,0x80,0x70,0x00,0x60,0x08,0x2F,0x0D,	/* 1A78: .p.`... */
	0x61,0x0A,0x70,0x00,0x58,0x8F,0x2E,0x1F,	/* 1A80: a.p.X.. */
	0x2A,0x5F,0x4E,0x75,0x4F,0xEF,0xFF,0xF0,	/* 1A88: *_NuO */
	0x70,0x00,0x48,0xD7,0x20,0xE0,0x2A,0x6F,	/* 1A90: p.H *o */
	0x00,0x14,0x7E,0x00,0x2C,0x3C,0x04,0x01,	/* 1A98: ..~.,<.. */
	0xF0,0xFE,0x43,0xED,0x00,0x02,0x10,0x29,	/* 1AA0: C...) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x43,0xED,	/* 1AA8: ....C */
	0x00,0x04,0x3E,0x00,0x70,0x00,0x10,0x29,	/* 1AB0: ..>.p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x72,0x00,	/* 1AB8: ....r. */
	0x32,0x00,0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,	/* 1AC0: 2. */
	0x20,0x41,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 1AC8:  A.-.. */
	0x01,0x01,0x80,0x09,0x10,0x80,0x20,0x47,	/* 1AD0: .... G */
	0x10,0x2D,0x00,0x07,0xD1,0xC6,0x10,0x80,	/* 1AD8: .-... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 1AE0:  G.-.. */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 1AE8: .... */
	0x00,0x03,0x10,0x80,0x2F,0x0D,0x61,0x00,	/* 1AF0: .....a. */
	0x02,0x68,0x58,0x8F,0x72,0x00,0x32,0x00,	/* 1AF8: .hXr.2. */
	0x4A,0x81,0x67,0x06,0x70,0x00,0x60,0x00,	/* 1B00: Jg.p.`. */
	0x02,0x4E,0x2A,0x3C,0x04,0x01,0xF0,0x0A,	/* 1B08: .N*<... */
	0x20,0x47,0xD1,0xC5,0x10,0x10,0xC0,0xBC,	/* 1B10:  G.. */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x67,0x06,	/* 1B18: ...J.g. */
	0x70,0x00,0x60,0x00,0x02,0x32,0x4A,0x2D,	/* 1B20: p.`..2J- */
	0x00,0x1F,0x66,0x00,0x01,0x72,0x43,0xED,	/* 1B28: ..f..rC */
	0x00,0x04,0x70,0x00,0x10,0x29,0x00,0x01,	/* 1B30: ..p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x43,0xED,	/* 1B38: ..r.C */
	0x00,0x08,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 1B40: ..2. */
	0x7F,0xFF,0x70,0x00,0x20,0x41,0x10,0x29,	/* 1B48: p. A.) */
	0x00,0x01,0xD1,0xFC,0x01,0x01,0x80,0x00,	/* 1B50: ..... */
	0xE1,0x88,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 1B58: .... */
	0x02,0x00,0x67,0x46,0x70,0x00,0x10,0x2D,	/* 1B60: ..gFp..- */
	0x00,0x07,0x59,0x80,0x6D,0x1E,0x12,0x28,	/* 1B68: ..Ym..( */
	0x00,0x1D,0xD2,0xBC,0x00,0x00,0x00,0xFF,	/* 1B70: ..... */
	0x11,0x41,0x00,0x1D,0x66,0x00,0x01,0x20,	/* 1B78: .A..f..  */
	0x20,0x47,0xD1,0xC6,0x70,0x44,0x10,0x80,	/* 1B80:  GpD. */
	0x60,0x00,0x01,0x14,0x12,0x28,0x00,0x1C,	/* 1B88: `....(.. */
	0xD2,0xBC,0x00,0x00,0x00,0xFF,0x11,0x41,	/* 1B90: ....A */
	0x00,0x1C,0x66,0x00,0x01,0x02,0x20,0x47,	/* 1B98: ..f... G */
	0xD1,0xC6,0x70,0x10,0x10,0x80,0x60,0x00,	/* 1BA0: p..`. */
	0x00,0xF6,0x4A,0x2D,0x00,0x29,0x66,0x24,	/* 1BA8: .J-.)f$ */
	0x50,0x8D,0x70,0x00,0x7E,0x00,0x10,0x2D,	/* 1BB0: Pp.~..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x80,0xBC,	/* 1BB8: .... */
	0x00,0x00,0x02,0x00,0x3E,0x00,0x20,0x07,	/* 1BC0: ....>. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x87,	/* 1BC8: .@... */
	0x60,0x00,0x00,0xC6,0x41,0xED,0x00,0x08,	/* 1BD0: `..A.. */
	0x70,0x00,0x10,0x28,0x00,0x01,0xE1,0x88,	/* 1BD8: p..(.. */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x01,0x00,	/* 1BE0: ...... */
	0x67,0x1C,0x08,0x2D,0x00,0x00,0x00,0x40,	/* 1BE8: g..-...@ */
	0x67,0x00,0x00,0xA6,0x20,0x47,0xD1,0xC5,	/* 1BF0: g.. G */
	0x70,0x18,0x10,0x80,0x08,0xAD,0x00,0x00,	/* 1BF8: p..... */
	0x00,0x40,0x60,0x00,0x00,0x94,0x41,0xED,	/* 1C00: .@`..A */
	0x00,0x08,0x70,0x00,0x7C,0x00,0x10,0x28,	/* 1C08: ..p.|..( */
	0x00,0x01,0xE1,0x88,0x10,0x10,0x80,0xBC,	/* 1C10: .... */
	0x00,0x00,0x01,0x00,0x3C,0x00,0x20,0x06,	/* 1C18: ....<. . */
	0xE0,0x80,0x11,0x40,0x00,0x01,0x10,0x86,	/* 1C20: .@... */
	0x42,0x2D,0x00,0x0D,0x42,0x2D,0x00,0x0C,	/* 1C28: B-..B-.. */
	0x4A,0x2D,0x00,0x27,0x66,0x2E,0x50,0x8D,	/* 1C30: J-.'f.P */
	0x70,0x00,0x7C,0x00,0x20,0x47,0x10,0x2D,	/* 1C38: p.|. G.- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x80,0xBC,	/* 1C40: .... */
	0x00,0x00,0x00,0x01,0x3C,0x00,0x20,0x06,	/* 1C48: ....<. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0xD1,0xFC,	/* 1C50: .@.. */
	0x04,0x01,0xF0,0x0C,0x1A,0x86,0x70,0x92,	/* 1C58: ....p */
	0x10,0x80,0x60,0x2C,0x50,0x8D,0x70,0x00,	/* 1C60: .`,Pp. */
	0x7C,0x00,0x20,0x47,0x10,0x2D,0x00,0x01,	/* 1C68: |. G.-.. */
	0xE1,0x88,0x10,0x15,0x80,0xBC,0x00,0x00,	/* 1C70: .... */
	0x00,0x01,0x3C,0x00,0x20,0x06,0xE0,0x80,	/* 1C78: ..<. . */
	0x1B,0x40,0x00,0x01,0xD1,0xFC,0x04,0x01,	/* 1C80: .@.... */
	0xF0,0x0C,0x1A,0x86,0x70,0x84,0x10,0x80,	/* 1C88: ..p. */
	0x20,0x47,0xD1,0xC5,0x70,0x82,0x10,0x80,	/* 1C90:  Gp. */
	0x70,0x00,0x60,0x00,0x00,0xBA,0x42,0x2D,	/* 1C98: p.`..B- */
	0x00,0x0D,0x42,0x2D,0x00,0x0A,0x42,0x2D,	/* 1CA0: ..B-..B- */
	0x00,0x0C,0x42,0x2D,0x00,0x0B,0x42,0x2D,	/* 1CA8: ..B-..B- */
	0x00,0x29,0x41,0xED,0x00,0x08,0x7C,0x00,	/* 1CB0: .)A..|. */
	0x1C,0x28,0x00,0x01,0xE1,0x8E,0x1C,0x10,	/* 1CB8: .(.... */
	0xCC,0xBC,0x00,0x00,0xFD,0xFF,0x20,0x06,	/* 1CC0: .. . */
	0xE0,0x80,0x11,0x40,0x00,0x01,0x10,0x86,	/* 1CC8: .@... */
	0x4A,0x2D,0x00,0x27,0x67,0x0A,0x20,0x47,	/* 1CD0: J-.'g. G */
	0xD1,0xC5,0x70,0x14,0x10,0x80,0x60,0x38,	/* 1CD8: p..`8 */
	0x08,0x2D,0x00,0x00,0x00,0x17,0x66,0x10,	/* 1CE0: .-....f. */
	0x42,0xA7,0x48,0x78,0x10,0x00,0x2F,0x0D,	/* 1CE8: BHx.... */
	0x61,0x00,0x0B,0xD6,0x4F,0xEF,0x00,0x0C,	/* 1CF0: a..O.. */
	0x08,0x2D,0x00,0x01,0x00,0x17,0x66,0x10,	/* 1CF8: .-....f. */
	0x42,0xA7,0x48,0x78,0x20,0x00,0x2F,0x0D,	/* 1D00: BHx ... */
	0x61,0x00,0x0B,0xBE,0x4F,0xEF,0x00,0x0C,	/* 1D08: a..O.. */
	0x20,0x47,0xD1,0xC5,0x70,0x80,0x10,0x80,	/* 1D10:  Gp. */
	0x41,0xED,0x00,0x08,0x7A,0x00,0x1A,0x28,	/* 1D18: A..z..( */
	0x00,0x01,0xE1,0x8D,0x1A,0x10,0xCA,0xBC,	/* 1D20: .... */
	0x00,0x00,0xFF,0xFE,0x20,0x05,0xE0,0x80,	/* 1D28: .. . */
	0x11,0x40,0x00,0x01,0x10,0x85,0x20,0x47,	/* 1D30: .@... G */
	0xD1,0xFC,0x04,0x01,0xF0,0x0C,0x42,0x10,	/* 1D38: ...B. */
	0x70,0x01,0x1B,0x40,0x00,0x1F,0x70,0x10,	/* 1D40: p..@..p. */
	0x1B,0x40,0x00,0x0E,0x70,0x01,0x33,0xC0,	/* 1D48: .@..p.3 */
	0x00,0x00,0x62,0xA8,0x70,0x00,0x4C,0xD7,	/* 1D50: ..bp.L */
	0x20,0xE0,0x4F,0xEF,0x00,0x10,0x4E,0x75,	/* 1D58:  O..Nu */
	0x2F,0x0D,0x70,0x00,0x2F,0x07,0x7E,0x00,	/* 1D60: ..p...~. */
	0x2A,0x6F,0x00,0x0C,0x43,0xED,0x00,0x02,	/* 1D68: *o..C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1D70: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 1D78: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1D80: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 1D88: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 1D90:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 1D98: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 1DA0:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 1DA8: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 1DB0: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 1DB8: .... */
	0x10,0x80,0x70,0x00,0x10,0x2D,0x00,0x35,	/* 1DC0: .p..-.5 */
	0x4A,0x80,0x67,0x0A,0x59,0x80,0x67,0x3C,	/* 1DC8: Jg.Yg< */
	0x53,0x80,0x67,0x38,0x60,0x06,0x70,0x00,	/* 1DD0: Sg8`.p. */
	0x60,0x00,0x00,0x72,0x70,0x00,0x10,0x2D,	/* 1DD8: `..rp..- */
	0x00,0x06,0x72,0x48,0xB2,0x80,0x66,0x1E,	/* 1DE0: ..rHf. */
	0x22,0x3C,0x04,0x01,0xF0,0x0A,0x20,0x47,	/* 1DE8: "<... G */
	0xD1,0xC1,0x10,0x10,0xC0,0xBC,0x00,0x00,	/* 1DF0: .... */
	0x00,0xFF,0x4A,0x00,0x66,0x0E,0x20,0x47,	/* 1DF8: .J.f. G */
	0xD1,0xC1,0x70,0x82,0x10,0x80,0x70,0x04,	/* 1E00: p.p. */
	0x1B,0x40,0x00,0x35,0x50,0x8D,0x70,0x00,	/* 1E08: .@.5Pp. */
	0x20,0x47,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 1E10:  G.-.. */
	0x10,0x15,0x72,0x00,0x80,0xBC,0x00,0x00,	/* 1E18: ..r... */
	0x00,0x01,0x32,0x00,0x20,0x01,0xE0,0x80,	/* 1E20: ..2. . */
	0x1B,0x40,0x00,0x01,0x22,0x47,0x1A,0x81,	/* 1E28: .@.."G. */
	0x22,0x3C,0x04,0x01,0xF0,0x0C,0xD1,0xC1,	/* 1E30: "<... */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 1E38: .... */
	0x00,0xFF,0x80,0xBC,0x00,0x00,0x00,0x02,	/* 1E40: ..... */
	0x10,0x80,0x70,0x01,0x2E,0x1F,0x2A,0x5F,	/* 1E48: .p...*_ */
	0x4E,0x75,0x4E,0x71,0x2F,0x0D,0x70,0x00,	/* 1E50: NuNq..p. */
	0x2F,0x07,0x7E,0x00,0x2A,0x6F,0x00,0x0C,	/* 1E58: ..~.*o.. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 1E60: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 1E68: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 1E70: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 1E78: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 1E80:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 1E88: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 1E90: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 1E98: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 1EA0: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 1EA8: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x4A,0x2D,	/* 1EB0: .....J- */
	0x00,0x27,0x66,0x18,0x22,0x3C,0x04,0x01,	/* 1EB8: .'f."<.. */
	0xF0,0x16,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 1EC0: . G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 1EC8: .... */
	0x00,0xFB,0x10,0x80,0x42,0x2D,0x00,0x0E,	/* 1ED0: ..B-.. */
	0x70,0x01,0x2E,0x1F,0x33,0xC0,0x00,0x00,	/* 1ED8: p...3.. */
	0x62,0xA8,0x70,0x00,0x2A,0x5F,0x4E,0x75,	/* 1EE0: bp.*_Nu */
	0x2F,0x0D,0x70,0x00,0x2F,0x07,0x7E,0x00,	/* 1EE8: ..p...~. */
	0x2A,0x6F,0x00,0x0C,0x43,0xED,0x00,0x02,	/* 1EF0: *o..C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1EF8: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 1F00: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1F08: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 1F10: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 1F18:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 1F20: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 1F28:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 1F30: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 1F38: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 1F40: .... */
	0x10,0x80,0x22,0x3C,0x04,0x01,0xF0,0x0A,	/* 1F48: ."<... */
	0x20,0x47,0xD1,0xC1,0x10,0x10,0xC0,0xBC,	/* 1F50:  G.. */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x67,0x04,	/* 1F58: ...J.g. */
	0x70,0x00,0x60,0x18,0x1B,0x6D,0x00,0x0D,	/* 1F60: p.`..m.. */
	0x00,0x0C,0x20,0x47,0x70,0x82,0xD1,0xC1,	/* 1F68: .. Gp */
	0x10,0x80,0x2F,0x0D,0x61,0x00,0xFE,0xDE,	/* 1F70: ...a. */
	0x70,0x00,0x58,0x8F,0x2E,0x1F,0x2A,0x5F,	/* 1F78: p.X..*_ */
	0x4E,0x75,0x4E,0x71,0x20,0x6F,0x00,0x04,	/* 1F80: NuNq o.. */
	0x11,0x68,0x00,0x0B,0x00,0x0A,0x70,0x01,	/* 1F88: .h....p. */
	0x33,0xC0,0x00,0x00,0x62,0xA8,0x70,0x00,	/* 1F90: 3..bp. */
	0x42,0x28,0x00,0x0E,0x4E,0x75,0x4E,0x71,	/* 1F98: B(..NuNq */
	0x2F,0x0D,0x70,0x00,0x2F,0x07,0x7E,0x00,	/* 1FA0: ..p...~. */
	0x2A,0x6F,0x00,0x0C,0x43,0xED,0x00,0x02,	/* 1FA8: *o..C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1FB0: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 1FB8: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 1FC0: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 1FC8: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 1FD0:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 1FD8: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 1FE0:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 1FE8: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 1FF0: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 1FF8: .... */
	0x10,0x80,0x4A,0x2D,0x00,0x27,0x66,0x1E,	/* 2000: .J-.'f. */
	0x22,0x3C,0x04,0x01,0xF0,0x16,0x20,0x47,	/* 2008: "<... G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 2010: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x80,0xBC,	/* 2018: ... */
	0x00,0x00,0x00,0x04,0x10,0x80,0x70,0x01,	/* 2020: .....p. */
	0x33,0xC0,0x00,0x00,0x62,0xA8,0x42,0x2D,	/* 2028: 3..bB- */
	0x00,0x0E,0x70,0x00,0x2E,0x1F,0x2A,0x5F,	/* 2030: ..p...*_ */
	0x4E,0x75,0x4E,0x71,0x4F,0xEF,0xFF,0xF0,	/* 2038: NuNqO */
	0x48,0xD7,0x20,0xE0,0x22,0x6F,0x00,0x14,	/* 2040: H "o.. */
	0x2C,0x2F,0x00,0x1C,0x2A,0x2F,0x00,0x20,	/* 2048: ,...*..  */
	0x4B,0xE9,0x00,0x02,0x70,0x00,0x10,0x2D,	/* 2050: K..p..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x7E,0x00,	/* 2058: ....~. */
	0x3E,0x00,0x4B,0xE9,0x00,0x04,0x70,0x00,	/* 2060: >.K..p. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 2068: .-.... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 2070: r.2. */
	0x7F,0xFF,0x20,0x41,0xD1,0xFC,0x01,0x01,	/* 2078:  A.. */
	0x80,0x09,0x10,0x29,0x00,0x07,0x10,0x80,	/* 2080: ..)... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 2088:  G.. */
	0x10,0x29,0x00,0x07,0x10,0x80,0x20,0x47,	/* 2090: .)... G */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0x10,0x29,	/* 2098: ...) */
	0x00,0x07,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 20A0: ...... */
	0x10,0x80,0x22,0x3C,0x04,0x01,0xF0,0xDE,	/* 20A8: ."<.. */
	0x20,0x47,0xD1,0xC1,0x20,0x2F,0x00,0x18,	/* 20B0:  G ... */
	0x10,0x80,0x20,0x47,0xD1,0xC1,0x10,0x10,	/* 20B8: . G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0xC0,0x86,	/* 20C0: ... */
	0x66,0x04,0x20,0x05,0x60,0x1E,0x20,0x47,	/* 20C8: f. .`. G */
	0xD1,0xC1,0x42,0x10,0x20,0x47,0xD1,0xC1,	/* 20D0: B. G */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 20D8: ..... */
	0xC0,0x86,0x67,0x06,0x20,0x05,0x52,0x80,	/* 20E0: g. .R */
	0x60,0x02,0x70,0x00,0x4C,0xD7,0x20,0xE0,	/* 20E8: `.p.L  */
	0x4F,0xEF,0x00,0x10,0x4E,0x75,0x4E,0x71,	/* 20F0: O..NuNq */
	0x4F,0xEF,0xFF,0xF0,0x70,0x00,0x48,0xD7,	/* 20F8: Op.H */
	0x20,0xD0,0x2A,0x6F,0x00,0x14,0x7E,0x00,	/* 2100:  *o..~. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 2108: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 2110: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 2118: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 2120: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 2128:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 2130: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 2138: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 2140: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 2148: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 2150: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x4A,0x2D,	/* 2158: .....J- */
	0x00,0x27,0x66,0x04,0x78,0x0E,0x60,0x32,	/* 2160: .'f.x.`2 */
	0x48,0x78,0x00,0x09,0x48,0x78,0x00,0x20,	/* 2168: Hx..Hx.  */
	0x48,0x78,0x00,0x01,0x2F,0x0D,0x61,0x00,	/* 2170: Hx....a. */
	0xFE,0xC4,0x4F,0xEF,0x00,0x10,0x28,0x00,	/* 2178: O..(. */
	0x66,0x18,0x48,0x78,0x00,0x0B,0x48,0x78,	/* 2180: f.Hx..Hx */
	0x00,0x10,0x48,0x78,0x00,0x04,0x2F,0x0D,	/* 2188: ..Hx.... */
	0x61,0x00,0xFE,0xAA,0x28,0x00,0x4F,0xEF,	/* 2190: a.(.O */
	0x00,0x10,0x22,0x7C,0x04,0x01,0xF0,0xDE,	/* 2198: .."|.. */
	0x20,0x47,0xD1,0xC9,0x1C,0x10,0xCC,0xBC,	/* 21A0:  G.. */
	0x00,0x00,0x00,0x80,0x66,0x06,0x78,0x0E,	/* 21A8: ...f.x. */
	0x1B,0x46,0x00,0x18,0x4A,0x84,0x66,0x00,	/* 21B0: .F..Jf. */
	0x00,0x6E,0x2F,0x05,0x72,0x08,0x70,0x02,	/* 21B8: .n..r.p. */
	0x2A,0x09,0x20,0x47,0xD1,0xC5,0x10,0x80,	/* 21C0: *. G. */
	0x20,0x47,0xD1,0xC5,0x42,0x10,0x20,0x47,	/* 21C8:  GB. G */
	0xD1,0xC5,0x1C,0x10,0xCC,0xBC,0x00,0x00,	/* 21D0: .... */
	0x00,0x80,0x67,0x0A,0x4A,0x84,0x66,0x02,	/* 21D8: .g.Jf. */
	0x28,0x01,0x1B,0x46,0x00,0x18,0x53,0x81,	/* 21E0: (..F..S */
	0x66,0xD8,0x4A,0x84,0x66,0x36,0x20,0x47,	/* 21E8: fJf6 G */
	0x70,0x02,0xD1,0xC9,0x10,0x80,0x20,0x47,	/* 21F0: p.. G */
	0xD1,0xC9,0x42,0x10,0x22,0x3C,0x00,0x00,	/* 21F8: B."<.. */
	0x27,0x10,0x2A,0x09,0x20,0x47,0xD1,0xC5,	/* 2200: '.*. G */
	0x1C,0x10,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 2208: ..... */
	0x08,0x06,0x00,0x06,0x66,0x04,0x53,0x81,	/* 2210: ....f.S */
	0x66,0xEA,0x4A,0x81,0x66,0x06,0x1B,0x46,	/* 2218: fJf..F */
	0x00,0x18,0x78,0x0D,0x2A,0x1F,0x20,0x47,	/* 2220: ..x.*. G */
	0x70,0x02,0xD1,0xC9,0x10,0x80,0x20,0x47,	/* 2228: p.. G */
	0x70,0x82,0xD1,0xC9,0x42,0x10,0x20,0x47,	/* 2230: pB. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x0A,0x10,0x80,	/* 2238: .... */
	0x1B,0x44,0x00,0x28,0x4A,0x84,0x67,0x08,	/* 2240: .D.(Jg. */
	0x20,0x47,0xD1,0xC9,0x70,0x05,0x10,0x80,	/* 2248:  Gp.. */
	0x42,0x2D,0x00,0x0E,0x70,0x00,0x4C,0xD7,	/* 2250: B-..p.L */
	0x20,0xD0,0x4F,0xEF,0x00,0x10,0x4E,0x75,	/* 2258:  O..Nu */
	0x20,0x6F,0x00,0x04,0x48,0x78,0x00,0x10,	/* 2260:  o..Hx.. */
	0x2F,0x08,0x61,0x24,0x50,0x8F,0x4E,0x75,	/* 2268: ..a$PNu */
	0x20,0x6F,0x00,0x04,0x48,0x78,0x00,0x02,	/* 2270:  o..Hx.. */
	0x2F,0x08,0x61,0x14,0x50,0x8F,0x4E,0x75,	/* 2278: ..a.PNu */
	0x20,0x6F,0x00,0x04,0x48,0x78,0x00,0x80,	/* 2280:  o..Hx. */
	0x2F,0x08,0x61,0x04,0x50,0x8F,0x4E,0x75,	/* 2288: ..a.PNu */
	0x4F,0xEF,0xFF,0xF4,0x70,0x00,0x48,0xD7,	/* 2290: Op.H */
	0x20,0xC0,0x2A,0x6F,0x00,0x10,0x1C,0x2F,	/* 2298:  *o.... */
	0x00,0x17,0x7E,0x00,0x43,0xED,0x00,0x02,	/* 22A0: ..~.C.. */
	0xCC,0xBC,0x00,0x00,0x00,0xFF,0x10,0x29,	/* 22A8: ....) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x43,0xED,	/* 22B0: ....C */
	0x00,0x04,0x3E,0x00,0x70,0x00,0x10,0x29,	/* 22B8: ..>.p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x72,0x00,	/* 22C0: ....r. */
	0x32,0x00,0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,	/* 22C8: 2. */
	0x20,0x41,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 22D0:  A.-.. */
	0x01,0x01,0x80,0x09,0x10,0x80,0x20,0x47,	/* 22D8: .... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 22E0: .-.... */
	0xF0,0xFE,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 22E8: . G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 22F0: .... */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0x10,0x80,	/* 22F8: ..... */
	0x70,0x06,0xC0,0x86,0x67,0x22,0x43,0xED,	/* 2300: p.g"C */
	0x00,0x08,0x70,0x00,0x10,0x29,0x00,0x01,	/* 2308: ..p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x80,0xBC,	/* 2310: ..r. */
	0x00,0x00,0x00,0x01,0x32,0x00,0x20,0x01,	/* 2318: ....2. . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x81,	/* 2320: .@... */
	0x22,0x3C,0x04,0x01,0xF0,0x0C,0x20,0x47,	/* 2328: "<... G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 2330: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x80,0x86,	/* 2338: ... */
	0x10,0x80,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 2340: .p.3.. */
	0x62,0xA8,0x42,0x2D,0x00,0x0E,0x70,0x00,	/* 2348: bB-..p. */
	0x4C,0xD7,0x20,0xC0,0x4F,0xEF,0x00,0x0C,	/* 2350: L O.. */
	0x4E,0x75,0x4E,0x71,0x2F,0x0D,0x2F,0x07,	/* 2358: NuNq.... */
	0x22,0x6F,0x00,0x0C,0x4B,0xE9,0x00,0x02,	/* 2360: "o..K.. */
	0x70,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 2368: p..-.. */
	0x10,0x15,0x7E,0x00,0x3E,0x00,0x4B,0xE9,	/* 2370: ..~.>.K */
	0x00,0x04,0x70,0x00,0x10,0x2D,0x00,0x01,	/* 2378: ..p..-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x32,0x00,	/* 2380: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 2388:  A */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x29,	/* 2390: ....) */
	0x00,0x07,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 2398: ... G */
	0x04,0x01,0xF0,0xFE,0x10,0x29,0x00,0x07,	/* 23A0: ...).. */
	0x10,0x80,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 23A8: . G.. */
	0xF0,0xD0,0x10,0x29,0x00,0x07,0xC0,0xBC,	/* 23B0: .).. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x4B,0xE9,	/* 23B8: .....K */
	0x00,0x08,0x72,0x00,0x12,0x2D,0x00,0x01,	/* 23C0: ..r..-.. */
	0xE1,0x89,0x12,0x15,0xC2,0xBC,0x00,0x00,	/* 23C8: .... */
	0xFF,0xFE,0x20,0x01,0xE0,0x80,0x1B,0x40,	/* 23D0:  ..@ */
	0x00,0x01,0x1A,0x81,0x20,0x47,0xD1,0xFC,	/* 23D8: ... G */
	0x04,0x01,0xF0,0x0C,0x42,0x10,0x70,0x01,	/* 23E0: ...B.p. */
	0x33,0xC0,0x00,0x00,0x62,0xA8,0x42,0x29,	/* 23E8: 3..bB) */
	0x00,0x0E,0x70,0x00,0x2E,0x1F,0x2A,0x5F,	/* 23F0: ..p...*_ */
	0x4E,0x75,0x4E,0x71,0x4F,0xEF,0xFF,0xF0,	/* 23F8: NuNqO */
	0x70,0x00,0x48,0xD7,0x20,0xE0,0x2A,0x6F,	/* 2400: p.H *o */
	0x00,0x14,0x3A,0x2F,0x00,0x1A,0x3C,0x2F,	/* 2408: ..:...<. */
	0x00,0x1E,0x7E,0x00,0x43,0xED,0x00,0x02,	/* 2410: ..~.C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 2418: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 2420: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 2428: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 2430: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 2438:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 2440: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 2448:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 2450: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 2458: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 2460: .... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 2468: .0... */
	0x00,0x01,0x67,0x00,0x00,0x7A,0x30,0x06,	/* 2470: ..g..z0. */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x67,0x3E,	/* 2478: ....g> */
	0x22,0x3C,0x04,0x01,0xF0,0x12,0x20,0x47,	/* 2480: "<... G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 2488: "G.. */
	0x22,0x47,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 2490: "G... */
	0x80,0xBC,0x00,0x00,0x00,0x40,0x10,0x80,	/* 2498: ...@. */
	0x22,0x3C,0x04,0x01,0xF0,0x14,0x20,0x47,	/* 24A0: "<... G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 24A8: .. */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 24B0: ..... */
	0x00,0x30,0x10,0x80,0x60,0x30,0x22,0x3C,	/* 24B8: .0.`0"< */
	0x04,0x01,0xF0,0x12,0x20,0x47,0x22,0x47,	/* 24C0: ... G"G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0x22,0x47,	/* 24C8: .."G */
	0xC0,0xBC,0x00,0x00,0x00,0xBF,0x10,0x80,	/* 24D0: .... */
	0x22,0x3C,0x04,0x01,0xF0,0x14,0x20,0x47,	/* 24D8: "<... G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 24E0: .. */
	0x00,0x00,0x00,0xCF,0x10,0x80,0x30,0x05,	/* 24E8: ....0. */
	0xC0,0xBC,0x00,0x00,0x00,0x02,0x67,0x42,	/* 24F0: ....gB */
	0x30,0x06,0xC0,0xBC,0x00,0x00,0x00,0x02,	/* 24F8: 0..... */
	0x67,0x20,0x22,0x3C,0x04,0x01,0xF0,0x12,	/* 2500: g "<... */
	0x20,0x47,0x22,0x47,0xD1,0xC1,0xD3,0xC1,	/* 2508:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 2510: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x80,0x10,0x80,	/* 2518: .... */
	0x60,0x18,0x22,0x3C,0x04,0x01,0xF0,0x12,	/* 2520: `."<... */
	0x20,0x47,0x22,0x47,0xD1,0xC1,0xD3,0xC1,	/* 2528:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0x7F,	/* 2530: ..... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 2538: .0... */
	0x00,0x10,0x67,0x42,0x30,0x06,0xC0,0xBC,	/* 2540: ..gB0. */
	0x00,0x00,0x00,0x10,0x67,0x20,0x22,0x3C,	/* 2548: ....g "< */
	0x04,0x01,0xF0,0x12,0x20,0x47,0x22,0x47,	/* 2550: ... G"G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 2558: .. */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 2560: ..... */
	0x00,0x02,0x10,0x80,0x60,0x18,0x22,0x3C,	/* 2568: ...`."< */
	0x04,0x01,0xF0,0x12,0x20,0x47,0x22,0x47,	/* 2570: ... G"G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 2578: .. */
	0x00,0x00,0x00,0xFD,0x10,0x80,0x30,0x05,	/* 2580: ....0. */
	0xC0,0xBC,0x00,0x00,0x00,0x20,0x67,0x06,	/* 2588: ... g. */
	0x08,0xED,0x00,0x04,0x00,0x40,0x70,0x00,	/* 2590: ....@p. */
	0x10,0x2D,0x00,0x06,0x72,0x48,0xB2,0x80,	/* 2598: .-..rH */
	0x66,0x00,0x02,0x04,0x22,0x3C,0x04,0x01,	/* 25A0: f..."<.. */
	0xF0,0x2A,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 25A8: * G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 25B0: .... */
	0x00,0xF0,0x80,0xBC,0x00,0x00,0x00,0x0F,	/* 25B8: ..... */
	0x10,0x80,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 25C0: .0... */
	0x01,0x00,0x67,0x42,0x30,0x06,0xC0,0xBC,	/* 25C8: ..gB0. */
	0x00,0x00,0x01,0x00,0x67,0x20,0x22,0x3C,	/* 25D0: ....g "< */
	0x04,0x01,0xF0,0x3E,0x20,0x47,0x22,0x47,	/* 25D8: ..> G"G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 25E0: .. */
	0x00,0x00,0x00,0xFF,0x80,0xBC,0x00,0x00,	/* 25E8: ..... */
	0x00,0x08,0x10,0x80,0x60,0x18,0x22,0x3C,	/* 25F0: ...`."< */
	0x04,0x01,0xF0,0x3E,0x20,0x47,0x22,0x47,	/* 25F8: ..> G"G */
	0xD1,0xC1,0xD3,0xC1,0x10,0x11,0xC0,0xBC,	/* 2600: .. */
	0x00,0x00,0x00,0xF7,0x10,0x80,0x30,0x05,	/* 2608: ....0. */
	0xC0,0xBC,0x00,0x00,0x10,0x00,0x67,0x00,	/* 2610: ....g. */
	0x00,0xBE,0x08,0x2D,0x00,0x03,0x00,0x24,	/* 2618: ..-...$ */
	0x67,0x5C,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 2620: g\0... */
	0x10,0x00,0x67,0x28,0x22,0x3C,0x04,0x01,	/* 2628: ..g("<.. */
	0xF0,0x3E,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 2630: > G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 2638: .... */
	0x00,0xFB,0x10,0x80,0x20,0x47,0x70,0x02,	/* 2640: .. Gp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xDA,0x10,0x80,	/* 2648: ... */
	0x60,0x00,0x00,0x84,0x22,0x3C,0x04,0x01,	/* 2650: `.."<.. */
	0xF0,0x3E,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 2658: > G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 2660: .... */
	0x00,0xFF,0x80,0xBC,0x00,0x00,0x00,0x04,	/* 2668: ..... */
	0x10,0x80,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 2670: . G.. */
	0xF0,0xDA,0x42,0x10,0x60,0x58,0x30,0x06,	/* 2678: B.`X0. */
	0xC0,0xBC,0x00,0x00,0x10,0x00,0x67,0x2C,	/* 2680: ....g, */
	0x22,0x3C,0x04,0x01,0xF0,0x12,0x20,0x47,	/* 2688: "<... G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 2690: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x80,0xBC,	/* 2698: ... */
	0x00,0x00,0x00,0x04,0x10,0x80,0x20,0x47,	/* 26A0: ..... G */
	0x70,0x01,0xD1,0xFC,0x04,0x01,0xF0,0xD8,	/* 26A8: p... */
	0x10,0x80,0x60,0x22,0x22,0x3C,0x04,0x01,	/* 26B0: .`""<.. */
	0xF0,0x12,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 26B8: . G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 26C0: .... */
	0x00,0xFB,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 26C8: .. G */
	0x04,0x01,0xF0,0xD8,0x42,0x10,0x30,0x05,	/* 26D0: ..B.0. */
	0xC0,0xBC,0x00,0x00,0x20,0x00,0x67,0x00,	/* 26D8: .. .g. */
	0x01,0xDE,0x08,0x2D,0x00,0x03,0x00,0x24,	/* 26E0: ..-...$ */
	0x67,0x5E,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 26E8: g^0... */
	0x20,0x00,0x67,0x2E,0x2C,0x3C,0x04,0x01,	/* 26F0:  .g.,<.. */
	0xF0,0x12,0x20,0x47,0x22,0x47,0xD1,0xC6,	/* 26F8: . G"G */
	0xD3,0xC6,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 2700: .... */
	0x00,0xFF,0x80,0xBC,0x00,0x00,0x00,0x04,	/* 2708: ..... */
	0x10,0x80,0x20,0x47,0x70,0x01,0xD1,0xFC,	/* 2710: . Gp. */
	0x04,0x01,0xF0,0xD8,0x10,0x80,0x60,0x00,	/* 2718: ...`. */
	0x01,0x9E,0x2C,0x3C,0x04,0x01,0xF0,0x12,	/* 2720: .,<... */
	0x20,0x47,0x22,0x47,0xD1,0xC6,0xD3,0xC6,	/* 2728:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFB,	/* 2730: ..... */
	0x10,0x80,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 2738: . G.. */
	0xF0,0xD8,0x42,0x10,0x60,0x00,0x01,0x78,	/* 2740: B.`..x */
	0x30,0x06,0xC0,0xBC,0x00,0x00,0x20,0x00,	/* 2748: 0... . */
	0x67,0x28,0x2C,0x3C,0x04,0x01,0xF0,0x3E,	/* 2750: g(,<..> */
	0x20,0x47,0x22,0x47,0xD1,0xC6,0xD3,0xC6,	/* 2758:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFB,	/* 2760: ..... */
	0x10,0x80,0x20,0x47,0x70,0x02,0xD1,0xFC,	/* 2768: . Gp. */
	0x04,0x01,0xF0,0xDA,0x10,0x80,0x60,0x00,	/* 2770: ...`. */
	0x01,0x46,0x2C,0x3C,0x04,0x01,0xF0,0x3E,	/* 2778: .F,<..> */
	0x20,0x47,0x22,0x47,0xD1,0xC6,0xD3,0xC6,	/* 2780:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 2788: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x04,0x10,0x80,	/* 2790: ..... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 2798:  G.. */
	0x42,0x10,0x60,0x00,0x01,0x1A,0x30,0x05,	/* 27A0: B.`...0. */
	0xC0,0xBC,0x00,0x00,0x10,0x00,0x67,0x00,	/* 27A8: ....g. */
	0x00,0x7E,0x08,0x2D,0x00,0x03,0x00,0x24,	/* 27B0: .~.-...$ */
	0x67,0x5A,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 27B8: gZ0... */
	0x10,0x00,0x67,0x2C,0x22,0x3C,0x04,0x01,	/* 27C0: ..g,"<.. */
	0xF0,0x2A,0x20,0x47,0x22,0x47,0xD1,0xC1,	/* 27C8: * G"G */
	0xD3,0xC1,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 27D0: .... */
	0x00,0xF0,0x80,0xBC,0x00,0x00,0x00,0x09,	/* 27D8: ..... */
	0x10,0x80,0x20,0x47,0x70,0x02,0xD1,0xFC,	/* 27E0: . Gp. */
	0x04,0x01,0xF0,0xDA,0x10,0x80,0x60,0x3E,	/* 27E8: ...`> */
	0x22,0x3C,0x04,0x01,0xF0,0x2A,0x20,0x47,	/* 27F0: "<..* G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 27F8: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xF0,0x10,0x80,	/* 2800: .... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 2808:  G.. */
	0x42,0x10,0x60,0x1A,0x20,0x47,0x30,0x06,	/* 2810: B.`. G0. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0xC0,0xBC,	/* 2818: .. */
	0x00,0x00,0x10,0x00,0x56,0xC0,0xC0,0xBC,	/* 2820: ....V */
	0x00,0x00,0x00,0x01,0x10,0x80,0x30,0x05,	/* 2828: .....0. */
	0xC0,0xBC,0x00,0x00,0x20,0x00,0x67,0x00,	/* 2830: .. .g. */
	0x00,0x86,0x08,0x2D,0x00,0x03,0x00,0x24,	/* 2838: ..-...$ */
	0x67,0x24,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 2840: g$0... */
	0x20,0x00,0x67,0x0E,0x20,0x47,0xD1,0xFC,	/* 2848:  .g. G */
	0x04,0x01,0xF0,0xD8,0x70,0x01,0x10,0x80,	/* 2850: ..p.. */
	0x60,0x64,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 2858: `d G.. */
	0xF0,0xD8,0x42,0x10,0x60,0x58,0x30,0x06,	/* 2860: B.`X0. */
	0xC0,0xBC,0x00,0x00,0x20,0x00,0x67,0x2C,	/* 2868: .. .g, */
	0x2C,0x3C,0x04,0x01,0xF0,0x2A,0x20,0x47,	/* 2870: ,<..* G */
	0x22,0x47,0xD1,0xC6,0xD3,0xC6,0x10,0x11,	/* 2878: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xF0,0x80,0xBC,	/* 2880: ... */
	0x00,0x00,0x00,0x09,0x10,0x80,0x20,0x47,	/* 2888: ..... G */
	0x70,0x02,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 2890: p... */
	0x10,0x80,0x60,0x22,0x2C,0x3C,0x04,0x01,	/* 2898: .`",<.. */
	0xF0,0x2A,0x20,0x47,0x22,0x47,0xD1,0xC6,	/* 28A0: * G"G */
	0xD3,0xC6,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 28A8: .... */
	0x00,0xF0,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 28B0: .. G */
	0x04,0x01,0xF0,0xDA,0x42,0x10,0x4C,0xD7,	/* 28B8: ..B.L */
	0x20,0xE0,0x4F,0xEF,0x00,0x10,0x4E,0x75,	/* 28C0:  O..Nu */
	0x4F,0xEF,0xFF,0xF0,0x70,0x00,0x48,0xD7,	/* 28C8: Op.H */
	0x20,0xE0,0x2A,0x6F,0x00,0x14,0x3A,0x2F,	/* 28D0:  *o..:. */
	0x00,0x1A,0x3C,0x2F,0x00,0x1E,0x7E,0x00,	/* 28D8: ..<...~. */
	0x43,0xED,0x00,0x02,0x10,0x29,0x00,0x01,	/* 28E0: C...).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x04,	/* 28E8: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 28F0: >.p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 28F8: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x20,0x41,	/* 2900:  A */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x01,0x01,	/* 2908: .-.... */
	0x80,0x09,0x10,0x80,0x20,0x47,0x10,0x2D,	/* 2910: .. G.- */
	0x00,0x07,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 2918: .... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 2920: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 2928: .. */
	0x00,0x00,0x00,0x03,0x10,0x80,0x30,0x05,	/* 2930: .....0. */
	0xC0,0xBC,0x00,0x00,0x10,0x00,0x67,0x46,	/* 2938: ....gF */
	0x08,0x2D,0x00,0x03,0x00,0x24,0x67,0x24,	/* 2940: .-...$g$ */
	0x30,0x06,0xC0,0xBC,0x00,0x00,0x10,0x00,	/* 2948: 0..... */
	0x67,0x0E,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 2950: g. G.. */
	0xF0,0xDA,0x70,0x02,0x10,0x80,0x60,0x26,	/* 2958: p..`& */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 2960:  G.. */
	0x42,0x10,0x60,0x1A,0x20,0x47,0x30,0x06,	/* 2968: B.`. G0. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0xC0,0xBC,	/* 2970: .. */
	0x00,0x00,0x10,0x00,0x56,0xC0,0xC0,0xBC,	/* 2978: ....V */
	0x00,0x00,0x00,0x01,0x10,0x80,0x30,0x05,	/* 2980: .....0. */
	0xC0,0xBC,0x00,0x00,0x20,0x00,0x67,0x4E,	/* 2988: .. .gN */
	0x08,0x2D,0x00,0x03,0x00,0x24,0x67,0x24,	/* 2990: .-...$g$ */
	0x30,0x06,0xC0,0xBC,0x00,0x00,0x20,0x00,	/* 2998: 0... . */
	0x67,0x0E,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 29A0: g. G.. */
	0xF0,0xD8,0x70,0x01,0x10,0x80,0x60,0x2E,	/* 29A8: p..`. */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xD8,	/* 29B0:  G.. */
	0x42,0x10,0x60,0x22,0x30,0x06,0xC0,0xBC,	/* 29B8: B.`"0. */
	0x00,0x00,0x20,0x00,0x67,0x0E,0x20,0x47,	/* 29C0: .. .g. G */
	0xD1,0xFC,0x04,0x01,0xF0,0xDA,0x70,0x02,	/* 29C8: ..p. */
	0x10,0x80,0x60,0x0A,0x20,0x47,0xD1,0xFC,	/* 29D0: .`. G */
	0x04,0x01,0xF0,0xDA,0x42,0x10,0x4C,0xD7,	/* 29D8: ..B.L */
	0x20,0xE0,0x4F,0xEF,0x00,0x10,0x4E,0x75,	/* 29E0:  O..Nu */
	0x2F,0x07,0x7E,0x00,0x20,0x3C,0x00,0x00,	/* 29E8: ..~. <.. */
	0x4E,0x20,0x22,0x3C,0x00,0x00,0x4A,0x38,	/* 29F0: N "<..J8 */
	0x52,0x87,0xBE,0x81,0x67,0x04,0xBE,0x80,	/* 29F8: Rg. */
	0x6D,0xF6,0x2E,0x1F,0x4E,0x75,0x4E,0x71,	/* 2A00: m..NuNq */
	0x4E,0x56,0xFF,0xF8,0x4F,0xEF,0xFF,0xDC,	/* 2A08: NVO */
	0x48,0xD7,0x38,0xFC,0x34,0x2E,0x00,0x0A,	/* 2A10: H84... */
	0x7C,0x01,0x26,0x3C,0x04,0x01,0xF0,0xCC,	/* 2A18: |.&<.. */
	0x7E,0x00,0x3E,0x02,0x20,0x47,0xD1,0xC3,	/* 2A20: ~.>. G */
	0x10,0x86,0x78,0x03,0x2A,0x7C,0x04,0x01,	/* 2A28: .x.*|.. */
	0xF0,0xD0,0x20,0x47,0xD1,0xCD,0x10,0x84,	/* 2A30:  G. */
	0x22,0x3C,0x04,0x01,0xF0,0xE8,0x20,0x47,	/* 2A38: "<.. G */
	0xD1,0xC1,0x42,0x10,0x20,0x47,0xD1,0xCD,	/* 2A40: B. G */
	0x70,0x02,0x10,0x80,0x20,0x47,0xD1,0xC1,	/* 2A48: p.. G */
	0x42,0x10,0x20,0x47,0xD1,0xCD,0x10,0x86,	/* 2A50: B. G. */
	0x20,0x47,0xD1,0xC1,0x42,0x10,0x20,0x47,	/* 2A58:  GB. G */
	0xD1,0xCD,0x42,0x10,0x20,0x47,0xD1,0xC1,	/* 2A60: B. G */
	0x42,0x10,0x20,0x47,0xD1,0xCD,0x10,0x84,	/* 2A68: B. G. */
	0x22,0x3C,0x04,0x01,0xF0,0xF4,0x20,0x47,	/* 2A70: "<.. G */
	0xD1,0xC1,0x42,0x10,0x20,0x47,0xD1,0xCD,	/* 2A78: B. G */
	0x70,0x02,0x10,0x80,0x20,0x47,0xD1,0xC1,	/* 2A80: p.. G */
	0x42,0x10,0x20,0x47,0xD1,0xCD,0x10,0x86,	/* 2A88: B. G. */
	0x20,0x47,0xD1,0xC1,0x42,0x10,0x20,0x47,	/* 2A90:  GB. G */
	0xD1,0xCD,0x42,0x10,0x20,0x47,0xD1,0xC1,	/* 2A98: B. G */
	0x42,0x10,0x7A,0x04,0x20,0x47,0xD1,0xCD,	/* 2AA0: B.z. G */
	0x10,0x85,0x26,0x7C,0x04,0x01,0xF0,0xDA,	/* 2AA8: .&|.. */
	0x20,0x47,0xD1,0xCB,0x70,0xA8,0x10,0x80,	/* 2AB0:  Gp. */
	0x22,0x7C,0x04,0x01,0xF0,0xDC,0x20,0x47,	/* 2AB8: "|.. G */
	0xD1,0xC9,0x42,0x10,0x22,0x3C,0x04,0x01,	/* 2AC0: B."<.. */
	0xF0,0xDE,0x20,0x47,0xD1,0xC1,0x42,0x10,	/* 2AC8:  GB. */
	0x28,0x7C,0x04,0x01,0xF0,0xD8,0x20,0x47,	/* 2AD0: (|.. G */
	0xD1,0xCC,0x10,0x86,0x20,0x47,0xD1,0xC3,	/* 2AD8: . G */
	0x10,0x84,0x20,0x47,0xD1,0xC3,0x10,0x84,	/* 2AE0: . G. */
	0x20,0x47,0xD1,0xC3,0x10,0x84,0x20,0x47,	/* 2AE8:  G. G */
	0xD1,0xCD,0x10,0x85,0x20,0x47,0xD1,0xCB,	/* 2AF0: . G */
	0x70,0xA8,0x10,0x80,0x20,0x47,0xD1,0xC9,	/* 2AF8: p. G */
	0x70,0x20,0x10,0x80,0x20,0x47,0xD1,0xC1,	/* 2B00: p . G */
	0x42,0x10,0x20,0x47,0xD1,0xC3,0x10,0x84,	/* 2B08: B. G. */
	0x20,0x47,0xD1,0xC3,0x10,0x84,0x20,0x47,	/* 2B10:  G. G */
	0xD1,0xC3,0x10,0x84,0x20,0x47,0xD1,0xCC,	/* 2B18: . G */
	0x42,0x10,0x78,0x10,0x7A,0x03,0x2C,0x03,	/* 2B20: B.x.z.,. */
	0xE2,0x8C,0x20,0x47,0xD1,0xC6,0x10,0x85,	/* 2B28:  G. */
	0x20,0x47,0xD1,0xC6,0x10,0x85,0x53,0x84,	/* 2B30:  G.S */
	0x66,0xF0,0x7E,0x00,0x3E,0x02,0x20,0x47,	/* 2B38: f~.>. G */
	0xD1,0xCD,0x70,0x04,0x10,0x80,0x20,0x47,	/* 2B40: p.. G */
	0xD1,0xCB,0x42,0x10,0x20,0x47,0xD1,0xC9,	/* 2B48: B. G */
	0x70,0x20,0x10,0x80,0x20,0x47,0xD1,0xC1,	/* 2B50: p . G */
	0x70,0x03,0x10,0x80,0x20,0x47,0xD1,0xCC,	/* 2B58: p.. G */
	0x70,0x01,0x10,0x80,0x20,0x47,0xD1,0xC3,	/* 2B60: p.. G */
	0x70,0x03,0x10,0x80,0x20,0x47,0xD1,0xC3,	/* 2B68: p.. G */
	0x70,0x03,0x10,0x80,0x20,0x47,0xD1,0xC3,	/* 2B70: p.. G */
	0x70,0x03,0x10,0x80,0x20,0x47,0xD1,0xC3,	/* 2B78: p.. G */
	0x70,0x03,0x10,0x80,0x20,0x47,0xD1,0xCC,	/* 2B80: p.. G */
	0x42,0x10,0x20,0x47,0xD1,0xC3,0x42,0x10,	/* 2B88: B. GB. */
	0x20,0x47,0xD1,0xCD,0x42,0x10,0x48,0x78,	/* 2B90:  GB.Hx */
	0x00,0x64,0x61,0x00,0xFE,0x4C,0x58,0x8F,	/* 2B98: .da.LX */
	0x4C,0xD7,0x38,0xFC,0x4F,0xEF,0x00,0x24,	/* 2BA0: L8O.$ */
	0x4E,0x5E,0x4E,0x75,0x4F,0xEF,0xFF,0xF4,	/* 2BA8: N^NuO */
	0x70,0x00,0x48,0xD7,0x20,0xC0,0x2A,0x6F,	/* 2BB0: p.H *o */
	0x00,0x10,0x7E,0x00,0x7C,0x00,0x43,0xED,	/* 2BB8: ..~.|.C */
	0x00,0x02,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 2BC0: ...).. */
	0x10,0x11,0x43,0xED,0x00,0x04,0x3E,0x00,	/* 2BC8: ..C..>. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 2BD0: p..).. */
	0x10,0x11,0x72,0x00,0x32,0x00,0xC2,0xBC,	/* 2BD8: ..r.2. */
	0xFF,0xFF,0x7F,0xFF,0x20,0x41,0x10,0x2D,	/* 2BE0:  A.- */
	0x00,0x07,0xD1,0xFC,0x01,0x01,0x80,0x09,	/* 2BE8: ..... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 2BF0: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xFE,0x10,0x80,	/* 2BF8: ... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 2C00:  G.-.. */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 2C08: .... */
	0x00,0x03,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 2C10: ... G */
	0x04,0x01,0xF0,0xD8,0x1E,0x10,0x12,0x2D,	/* 2C18: .....- */
	0x00,0x26,0xCE,0x81,0xCE,0xBC,0x00,0x00,	/* 2C20: .&.. */
	0x00,0xFF,0x4A,0x07,0x6A,0x02,0x7C,0x04,	/* 2C28: .J.j.|. */
	0x08,0x07,0x00,0x05,0x67,0x06,0x8C,0xBC,	/* 2C30: ....g. */
	0x00,0x00,0x00,0x40,0x08,0x07,0x00,0x04,	/* 2C38: ...@.... */
	0x67,0x06,0x8C,0xBC,0x00,0x00,0x00,0x20,	/* 2C40: g....  */
	0x08,0x07,0x00,0x06,0x67,0x06,0x8C,0xBC,	/* 2C48: ....g. */
	0x00,0x00,0x00,0x02,0x1B,0x46,0x00,0x18,	/* 2C50: .....F.. */
	0x4C,0xD7,0x20,0xC0,0x4F,0xEF,0x00,0x0C,	/* 2C58: L O.. */
	0x4E,0x75,0x4E,0x71,0x4E,0x56,0x00,0x00,	/* 2C60: NuNqNV.. */
	0x4F,0xEF,0xFF,0xE8,0x48,0xD7,0x00,0xFC,	/* 2C68: OH. */
	0x78,0x00,0x2E,0x3C,0x04,0x01,0xF0,0xFE,	/* 2C70: x..<.. */
	0x70,0x00,0x30,0x2E,0x00,0x0A,0x20,0x40,	/* 2C78: p.0... @ */
	0xD1,0xC7,0x20,0x04,0xE5,0x88,0x10,0x80,	/* 2C80:  .. */
	0x30,0x2E,0x00,0x0A,0x2F,0x00,0x61,0x00,	/* 2C88: 0.....a. */
	0xFD,0x78,0x58,0x8F,0x4A,0x84,0x66,0x1A,	/* 2C90: xXJf. */
	0x7C,0x00,0x3C,0x2E,0x00,0x0A,0x20,0x46,	/* 2C98: |.<... F */
	0xD1,0xC7,0x1A,0x10,0x20,0x46,0xD1,0xC7,	/* 2CA0: .. F */
	0xCA,0xBC,0x00,0x00,0x00,0x07,0x10,0x10,	/* 2CA8: ...... */
	0x60,0x1A,0x7C,0x00,0x3C,0x2E,0x00,0x0A,	/* 2CB0: `.|.<... */
	0x20,0x46,0xD1,0xC7,0x1A,0x10,0x20,0x46,	/* 2CB8:  F.. F */
	0xD1,0xC7,0xCA,0xBC,0x00,0x00,0x00,0xFF,	/* 2CC0: ... */
	0xE8,0x85,0x10,0x10,0x30,0x05,0x48,0xC0,	/* 2CC8: ..0.H */
	0x5B,0x80,0x66,0x14,0x70,0x00,0x30,0x2E,	/* 2CD0: [f.p.0. */
	0x00,0x0A,0x20,0x40,0xD1,0xFC,0x04,0x01,	/* 2CD8: .. @.. */
	0xF0,0x96,0x70,0x80,0x10,0x80,0x60,0x10,	/* 2CE0: p.`. */
	0x70,0x00,0x30,0x2E,0x00,0x0A,0x20,0x40,	/* 2CE8: p.0... @ */
	0xD1,0xFC,0x04,0x01,0xF0,0x96,0x42,0x10,	/* 2CF0: ..B. */
	0x7C,0x00,0x70,0x27,0x7E,0x00,0x74,0x04,	/* 2CF8: |.p'~.t. */
	0x3C,0x2E,0x00,0x0A,0x20,0x46,0xD1,0xFC,	/* 2D00: <... F */
	0x04,0x01,0xF0,0xFC,0x10,0x80,0x26,0x3C,	/* 2D08: ...&< */
	0x04,0x01,0xF0,0xD0,0x20,0x46,0xD1,0xC3,	/* 2D10: .. F */
	0x10,0x87,0x4A,0x87,0x66,0x42,0x30,0x05,	/* 2D18: .JfB0. */
	0x48,0xC0,0x5B,0x80,0x66,0x3A,0x20,0x46,	/* 2D20: H[f: F */
	0xD1,0xFC,0x04,0x01,0xF0,0xEC,0x42,0x10,	/* 2D28: ..B. */
	0x20,0x46,0xD1,0xFC,0x04,0x01,0xF0,0x80,	/* 2D30:  F.. */
	0x10,0x10,0x72,0x44,0xC0,0xBC,0x00,0x00,	/* 2D38: ..rD.. */
	0x00,0xFF,0xB2,0x80,0x6F,0x0E,0x20,0x46,	/* 2D40: .o. F */
	0xD1,0xFC,0x04,0x01,0xF0,0xE4,0x70,0x42,	/* 2D48: ..pB */
	0x10,0x80,0x60,0x0C,0x20,0x46,0xD1,0xFC,	/* 2D50: .`. F */
	0x04,0x01,0xF0,0xE4,0x70,0x1F,0x10,0x80,	/* 2D58: ..p.. */
	0x52,0x87,0xBE,0x82,0x6D,0xAE,0x7A,0x00,	/* 2D60: Rmz. */
	0x3A,0x2E,0x00,0x0A,0x20,0x45,0xD1,0xFC,	/* 2D68: :... E */
	0x04,0x01,0xF0,0x30,0x42,0x10,0x20,0x45,	/* 2D70: ..0B. E */
	0xD1,0xFC,0x04,0x01,0xF0,0xD8,0x42,0x10,	/* 2D78: ..B. */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0xDA,	/* 2D80:  E.. */
	0x42,0x10,0x2E,0x3C,0x04,0x01,0xF0,0x0A,	/* 2D88: B..<... */
	0x20,0x45,0xD1,0xC7,0x10,0x10,0xC0,0xBC,	/* 2D90:  E.. */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x66,0xF0,	/* 2D98: ...J.f */
	0x52,0x84,0x70,0x02,0xB0,0x84,0x6E,0x00,	/* 2DA0: Rp.n. */
	0xFE,0xCA,0x4C,0xD7,0x00,0xFC,0x4F,0xEF,	/* 2DA8: L.O */
	0x00,0x18,0x4E,0x5E,0x4E,0x75,0x4E,0x71,	/* 2DB0: ..N^NuNq */
	0x4E,0x56,0xFF,0xF8,0x70,0x01,0x13,0xC0,	/* 2DB8: NVp.. */
	0x03,0x01,0xF8,0x80,0x4F,0xEF,0xFF,0xDC,	/* 2DC0: ..O */
	0x20,0x3C,0x00,0x00,0x64,0x98,0x48,0xD7,	/* 2DC8:  <..dH */
	0x3C,0xF8,0x2A,0x7C,0x01,0x01,0x81,0x80,	/* 2DD0: <*|.. */
	0x2D,0x40,0xFF,0xFC,0x20,0x6E,0xFF,0xFC,	/* 2DD8: -@ n */
	0x20,0xBC,0x10,0x00,0x00,0x00,0x38,0x3C,	/* 2DE0:  ....8< */
	0xFF,0xFE,0x2C,0x3C,0x01,0x01,0x80,0x00,	/* 2DE8: ,<... */
	0x3A,0x3C,0xFD,0xEE,0x26,0x3C,0x00,0x00,	/* 2DF0: :<&<.. */
	0x63,0x5C,0x24,0x7C,0x00,0x00,0x62,0xA0,	/* 2DF8: c\$|..b */
	0x4A,0x12,0x67,0x06,0x4E,0xB9,0x00,0x00,	/* 2E00: J.g.N.. */
	0x0E,0x5C,0x20,0x79,0x00,0x00,0x64,0x88,	/* 2E08: .\ y..d */
	0x49,0xED,0x00,0x2E,0x10,0x28,0x00,0x07,	/* 2E10: I...(.. */
	0x52,0x80,0x11,0x40,0x00,0x07,0x20,0x6E,	/* 2E18: R.@.. n */
	0xFF,0xFC,0x70,0x00,0x22,0x50,0x33,0x45,	/* 2E20: p."P3E */
	0x00,0x36,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 2E28: .6.,.. */
	0x10,0x14,0x72,0x00,0x28,0x49,0x32,0x00,	/* 2E30: ..r.(I2. */
	0x2A,0x41,0xDB,0xC6,0x70,0x00,0x30,0x2C,	/* 2E38: *Ap.0, */
	0x00,0x3A,0x4A,0x80,0x66,0xF6,0x33,0x44,	/* 2E40: .:Jf3D */
	0x00,0x36,0x70,0x00,0x7E,0x00,0x10,0x2D,	/* 2E48: .6p.~..- */
	0x00,0x0E,0x3E,0x00,0x4A,0x87,0x67,0x14,	/* 2E50: ..>.Jg. */
	0x20,0x43,0x20,0x70,0x7C,0x00,0x2F,0x0D,	/* 2E58:  C p|... */
	0x4E,0x90,0x58,0x8F,0x72,0x00,0x32,0x00,	/* 2E60: NXr.2. */
	0x4A,0x81,0x67,0x94,0x49,0xED,0x00,0x02,	/* 2E68: JgI.. */
	0x70,0x00,0x7A,0x00,0x7C,0x00,0x10,0x2C,	/* 2E70: p.z.|.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x49,0xED,	/* 2E78: ....I */
	0x00,0x08,0x3A,0x00,0x1C,0x2C,0x00,0x01,	/* 2E80: ..:..,.. */
	0xE1,0x8E,0x1C,0x14,0x4A,0x87,0x66,0x00,	/* 2E88: ..Jf. */
	0x00,0xA6,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 2E90: .0... */
	0x00,0x01,0x66,0x00,0x00,0x9A,0x10,0x2D,	/* 2E98: ..f...- */
	0x00,0x0D,0x12,0x2D,0x00,0x0C,0x90,0x81,	/* 2EA0: ...-.. */
	0x4A,0x00,0x67,0x00,0x00,0x8A,0x8C,0xBC,	/* 2EA8: J.g.. */
	0x00,0x00,0x00,0x01,0x49,0xED,0x00,0x08,	/* 2EB0: ....I.. */
	0xCC,0xBC,0x00,0x00,0xFF,0xFF,0x2E,0x06,	/* 2EB8: .... */
	0x20,0x07,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 2EC0:  ..@.. */
	0x18,0x87,0x49,0xED,0x00,0x04,0x70,0x00,	/* 2EC8: .I..p. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 2ED0: .,.... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 2ED8: r.2. */
	0x7F,0xFF,0x20,0x41,0xD1,0xFC,0x01,0x01,	/* 2EE0:  A.. */
	0x80,0x09,0x10,0x2D,0x00,0x07,0x10,0x80,	/* 2EE8: ..-... */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0xFE,	/* 2EF0:  E.. */
	0x10,0x2D,0x00,0x07,0x10,0x80,0x20,0x45,	/* 2EF8: .-... E */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0x10,0x2D,	/* 2F00: ...- */
	0x00,0x07,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 2F08: ...... */
	0x10,0x80,0x2E,0x3C,0x04,0x01,0xF0,0x0C,	/* 2F10: ..<... */
	0x20,0x45,0xD1,0xC7,0x22,0x45,0xD3,0xC7,	/* 2F18:  E"E */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 2F20: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x04,0x10,0x80,	/* 2F28: ..... */
	0x70,0x01,0x1B,0x40,0x00,0x29,0x30,0x06,	/* 2F30: p..@.)0. */
	0xC0,0xBC,0x00,0x00,0x00,0x10,0x67,0x00,	/* 2F38: ....g. */
	0x01,0x88,0x30,0x06,0xC0,0xBC,0x00,0x00,	/* 2F40: .0... */
	0x00,0x80,0x67,0x00,0x00,0x8A,0x49,0xED,	/* 2F48: .g..I */
	0x00,0x04,0x70,0x00,0x2E,0x3C,0x04,0x01,	/* 2F50: ..p..<.. */
	0xF0,0x0A,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 2F58: ..,.. */
	0x10,0x14,0x72,0x00,0x32,0x00,0xC2,0xBC,	/* 2F60: ..r.2. */
	0xFF,0xFF,0x7F,0xFF,0x20,0x41,0x10,0x2D,	/* 2F68:  A.- */
	0x00,0x07,0xD1,0xFC,0x01,0x01,0x80,0x09,	/* 2F70: ..... */
	0x10,0x80,0x20,0x45,0x10,0x2D,0x00,0x07,	/* 2F78: . E.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xFE,0x10,0x80,	/* 2F80: ... */
	0x20,0x45,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 2F88:  E.-.. */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 2F90: .... */
	0x00,0x03,0x10,0x80,0x20,0x45,0xD1,0xC7,	/* 2F98: ... E */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 2FA0: ..... */
	0x4A,0x00,0x66,0x00,0x01,0x08,0x42,0xA7,	/* 2FA8: J.f...B */
	0x48,0x78,0x01,0x00,0x2F,0x0D,0x61,0x00,	/* 2FB0: Hx....a. */
	0xF4,0x44,0x20,0x45,0x70,0x22,0x8C,0xBC,	/* 2FB8: D Ep" */
	0x00,0x00,0x00,0x20,0x4F,0xEF,0x00,0x0C,	/* 2FC0: ... O.. */
	0xD1,0xC7,0x10,0x80,0xCC,0xBC,0x00,0x00,	/* 2FC8: ... */
	0xFF,0x3F,0x60,0x00,0x00,0xE0,0x10,0x2D,	/* 2FD0: ?`...- */
	0x00,0x0A,0x12,0x2D,0x00,0x0B,0x90,0x81,	/* 2FD8: ...-.. */
	0x72,0x00,0x12,0x00,0x70,0x40,0xB0,0x81,	/* 2FE0: r...p@ */
	0x6F,0x00,0x00,0xCA,0x49,0xED,0x00,0x04,	/* 2FE8: o..I.. */
	0x70,0x00,0x2E,0x3C,0x04,0x01,0xF0,0x0A,	/* 2FF0: p..<... */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 2FF8: .,.... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 3000: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 3008:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 3010: .... */
	0x20,0x45,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 3018:  E.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x45,	/* 3020: ... E */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 3028: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 3030: .... */
	0x10,0x80,0x20,0x45,0xD1,0xC7,0x10,0x10,	/* 3038: . E.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x4A,0x00,	/* 3040: ...J. */
	0x66,0x00,0x00,0x6A,0x08,0x2D,0x00,0x03,	/* 3048: f..j.-.. */
	0x00,0x30,0x67,0x22,0x28,0x3C,0x00,0x00,	/* 3050: .0g"(<.. */
	0x01,0x00,0x2F,0x04,0x2F,0x04,0x2F,0x0D,	/* 3058: ........ */
	0x61,0x00,0xF3,0x9A,0x20,0x45,0x70,0x21,	/* 3060: a. Ep! */
	0x4F,0xEF,0x00,0x0C,0xD1,0xC7,0x10,0x80,	/* 3068: O... */
	0xCC,0xBC,0x00,0x00,0xFF,0x9F,0x08,0x2D,	/* 3070: ...- */
	0x00,0x07,0x00,0x31,0x67,0x14,0x2E,0x3C,	/* 3078: ...1g..< */
	0x00,0x00,0x10,0x00,0x2F,0x07,0x2F,0x07,	/* 3080: ........ */
	0x2F,0x0D,0x61,0x00,0xF3,0x70,0x4F,0xEF,	/* 3088: ..a.pO */
	0x00,0x0C,0x08,0x2D,0x00,0x06,0x00,0x30,	/* 3090: ...-...0 */
	0x67,0x14,0x2E,0x3C,0x00,0x00,0x20,0x00,	/* 3098: g..<.. . */
	0x2F,0x07,0x2F,0x07,0x2F,0x0D,0x61,0x00,	/* 30A0: ......a. */
	0xF3,0x54,0x4F,0xEF,0x00,0x0C,0xCC,0xBC,	/* 30A8: TO.. */
	0x00,0x00,0xFF,0xEF,0x49,0xED,0x00,0x08,	/* 30B0: ..I.. */
	0xCC,0xBC,0x00,0x00,0xFF,0xFF,0x20,0x06,	/* 30B8: .. . */
	0xE0,0x80,0x19,0x40,0x00,0x01,0x18,0x86,	/* 30C0: .@... */
	0x08,0x2D,0x00,0x04,0x00,0x40,0x67,0x00,	/* 30C8: .-...@g. */
	0xFD,0x16,0x49,0xED,0x00,0x04,0x70,0x00,	/* 30D0: .I..p. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 30D8: .,.... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 30E0: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 30E8:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 30F0: .... */
	0x20,0x45,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 30F8:  E.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x45,	/* 3100: ... E */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 3108: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 3110: .... */
	0x10,0x80,0x2F,0x0D,0x4E,0xB9,0x00,0x00,	/* 3118: ...N.. */
	0x50,0x58,0x58,0x8F,0x60,0x00,0xFC,0xC0,	/* 3120: PXX`. */
	0x2F,0x0D,0x70,0x00,0x2F,0x07,0x7E,0x00,	/* 3128: ..p...~. */
	0x2A,0x6F,0x00,0x0C,0x43,0xED,0x00,0x02,	/* 3130: *o..C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 3138: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 3140: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 3148: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 3150: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 3158:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 3160: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 3168:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 3170: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 3178: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 3180: .... */
	0x10,0x80,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 3188: . G.. */
	0xF0,0xD8,0x10,0x10,0x08,0x00,0x00,0x07,	/* 3190: ...... */
	0x67,0x0C,0x42,0x2D,0x00,0x0E,0x70,0x01,	/* 3198: g.B-..p. */
	0x33,0xC0,0x00,0x00,0x62,0xA8,0x70,0x00,	/* 31A0: 3..bp. */
	0x2E,0x1F,0x2A,0x5F,0x4E,0x75,0x4E,0x71,	/* 31A8: ..*_NuNq */
	0x2F,0x0D,0x70,0x00,0x2F,0x07,0x7E,0x00,	/* 31B0: ..p...~. */
	0x2A,0x6F,0x00,0x0C,0x43,0xED,0x00,0x02,	/* 31B8: *o..C.. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 31C0: .).... */
	0x43,0xED,0x00,0x04,0x3E,0x00,0x70,0x00,	/* 31C8: C..>.p. */
	0x10,0x29,0x00,0x01,0xE1,0x88,0x10,0x11,	/* 31D0: .).... */
	0x72,0x00,0x32,0x00,0xC2,0xBC,0xFF,0xFF,	/* 31D8: r.2. */
	0x7F,0xFF,0x20,0x41,0x10,0x2D,0x00,0x07,	/* 31E0:  A.-.. */
	0xD1,0xFC,0x01,0x01,0x80,0x09,0x10,0x80,	/* 31E8: .... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 31F0:  G.-.. */
	0x04,0x01,0xF0,0xFE,0x10,0x80,0x20,0x47,	/* 31F8: ... G */
	0x10,0x2D,0x00,0x07,0xD1,0xFC,0x04,0x01,	/* 3200: .-.... */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 3208: .... */
	0x10,0x80,0x70,0x00,0x10,0x2D,0x00,0x35,	/* 3210: .p..-.5 */
	0x53,0x80,0x67,0x26,0x53,0x80,0x67,0x22,	/* 3218: Sg&Sg" */
	0x53,0x80,0x67,0x02,0x60,0x16,0x70,0x00,	/* 3220: Sg.`.p. */
	0x10,0x2D,0x00,0x0E,0x72,0x0C,0xB2,0x80,	/* 3228: .-..r. */
	0x66,0x06,0x70,0x12,0x1B,0x40,0x00,0x0E,	/* 3230: f.p..@.. */
	0x70,0x00,0x60,0x46,0x70,0x01,0x1B,0x40,	/* 3238: p.`Fp..@ */
	0x00,0x35,0x50,0x8D,0x70,0x00,0x20,0x47,	/* 3240: .5Pp. G */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 3248: .-.... */
	0x72,0x00,0x80,0xBC,0x00,0x00,0x00,0x01,	/* 3250: r..... */
	0x32,0x00,0x20,0x01,0xE0,0x80,0x1B,0x40,	/* 3258: 2. ..@ */
	0x00,0x01,0x22,0x47,0x1A,0x81,0x22,0x3C,	/* 3260: .."G."< */
	0x04,0x01,0xF0,0x0C,0xD1,0xC1,0xD3,0xC1,	/* 3268: ... */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 3270: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x02,0x10,0x80,	/* 3278: ..... */
	0x70,0x00,0x2E,0x1F,0x2A,0x5F,0x4E,0x75,	/* 3280: p...*_Nu */
	0x2F,0x0D,0x2A,0x6F,0x00,0x08,0x2F,0x0D,	/* 3288: ..*o.... */
	0x61,0x00,0xEA,0xCE,0x58,0x8F,0x72,0x00,	/* 3290: a.Xr. */
	0x32,0x00,0x4A,0x81,0x66,0x04,0x42,0x2D,	/* 3298: 2.Jf.B- */
	0x00,0x0E,0x70,0x00,0x2A,0x5F,0x4E,0x75,	/* 32A0: ..p.*_Nu */
	0x70,0x00,0x4E,0x75,0x70,0x01,0x4E,0x75,	/* 32A8: p.Nup.Nu */
	0x00,0x82,0x00,0x04,0x00,0x16,0x00,0x00,	/* 32B0: ....... */
	0x00,0x41,0x00,0x00,0x00,0x41,0x00,0x04,	/* 32B8: .A...A.. */
	0x00,0x82,0x00,0x03,0x00,0x41,0x00,0x03,	/* 32C0: ....A.. */
	0x00,0x82,0x00,0x02,0x00,0x4E,0x00,0x02,	/* 32C8: ....N.. */
	0x00,0x41,0x00,0x02,0x00,0x82,0x00,0x01,	/* 32D0: .A..... */
	0x00,0x57,0x00,0x02,0x00,0x41,0x00,0x01,	/* 32D8: .W...A.. */
	0x00,0x82,0x00,0x00,0x00,0x2B,0x00,0x00,	/* 32E0: ....+.. */
	0x00,0xA3,0x00,0x04,0x00,0x1B,0x00,0x00,	/* 32E8: ....... */
	0x00,0x51,0x00,0x00,0x00,0x51,0x00,0x04,	/* 32F0: .Q...Q.. */
	0x00,0xA3,0x00,0x03,0x00,0x51,0x00,0x03,	/* 32F8: ....Q.. */
	0x00,0xA3,0x00,0x02,0x00,0x62,0x00,0x02,	/* 3300: ....b.. */
	0x00,0x51,0x00,0x02,0x00,0xA3,0x00,0x01,	/* 3308: .Q..... */
	0x00,0x6D,0x00,0x02,0x00,0x51,0x00,0x01,	/* 3310: .m...Q.. */
	0x00,0xA3,0x00,0x00,0x00,0x36,0x00,0x00,	/* 3318: ....6.. */
	0x00,0x36,0x00,0x05,0x00,0x1B,0x00,0x05,	/* 3320: .6...... */
	0x00,0x0D,0x00,0x05,0x00,0xF4,0x00,0x04,	/* 3328: ....... */
	0x00,0x6F,0x00,0x04,0x00,0x5B,0x00,0x04,	/* 3330: .o...[.. */
	0x00,0xF4,0x00,0x03,0x00,0x6D,0x00,0x01,	/* 3338: ....m.. */
	0x00,0x38,0x00,0x00,0x00,0x31,0x00,0x00,	/* 3340: .8...1.. */
	0x00,0x29,0x00,0x00,0x00,0x62,0x00,0x05,	/* 3348: .)...b.. */
	0x00,0x53,0x00,0x05,0x00,0xD9,0x00,0x00,	/* 3350: .S..... */
	0x00,0x30,0x00,0x05,0x00,0x6D,0x00,0x00,	/* 3358: .0...m.. */
	0x0C,0x20,0x20,0x0C,0x0C,0x20,0x20,0x20,	/* 3360: .  ..    */
	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,	/* 3368:          */
	0x20,0x0C,0x0C,0x0C,0x0C,0x00,0x00,0x00,	/* 3370:  ....... */
	0x4E,0x56,0xFF,0xF0,0x70,0x00,0x4F,0xEF,	/* 3378: NVp.O */
	0xFF,0xD8,0x48,0xD7,0x3C,0xFC,0x26,0x7C,	/* 3380: H<&| */
	0x00,0x00,0x63,0xF8,0x24,0x6B,0x00,0x08,	/* 3388: ..c$k.. */
	0x10,0x13,0x2D,0x40,0xFF,0xF4,0x4B,0xEA,	/* 3390: ..-@K */
	0x00,0x06,0x70,0x00,0x7A,0x00,0x10,0x2D,	/* 3398: ..p.z..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x3A,0x00,	/* 33A0: ....:. */
	0x20,0x45,0x20,0x2E,0xFF,0xF4,0xD1,0xFC,	/* 33A8:  E . */
	0x04,0x01,0xF0,0xFE,0xE5,0x88,0x10,0x80,	/* 33B0: ... */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0xCE,	/* 33B8:  E.. */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 33C0: ..... */
	0x1D,0x40,0xFF,0xFA,0x10,0x2E,0xFF,0xFA,	/* 33C8: .@.. */
	0x08,0x00,0x00,0x00,0x67,0x00,0x05,0xB2,	/* 33D0: ....g.. */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0xD6,	/* 33D8:  E.. */
	0x10,0x10,0x20,0x45,0xD1,0xFC,0x04,0x01,	/* 33E0: .. E.. */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 33E8: ... */
	0x1D,0x40,0xFF,0xFB,0x10,0x2E,0xFF,0xFB,	/* 33F0: .@.. */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0x10,0x80,	/* 33F8: ..... */
	0x10,0x2E,0xFF,0xFB,0x20,0x45,0x22,0x2E,	/* 3400: .. E". */
	0xFF,0xF4,0xD1,0xFC,0x04,0x01,0xF0,0x86,	/* 3408: .. */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0xE5,0x89,	/* 3410: .... */
	0xD0,0x81,0x4B,0xF2,0x0A,0x0A,0x70,0x00,	/* 3418: K..p. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 3420: .-.... */
	0x72,0x00,0x32,0x00,0x28,0x41,0x10,0x10,	/* 3428: r.2.(A.. */
	0xD9,0xFC,0x01,0x01,0x80,0x00,0xC0,0xBC,	/* 3430: ... */
	0x00,0x00,0x00,0x07,0x57,0x80,0x66,0x00,	/* 3438: ....Wf. */
	0x03,0xBC,0x4B,0xEC,0x00,0x08,0x70,0x00,	/* 3440: .K..p. */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 3448: .-.... */
	0xC0,0xBC,0x00,0x00,0x00,0x10,0x66,0x00,	/* 3450: ....f. */
	0x03,0x84,0x4A,0x2C,0x00,0x27,0x66,0x06,	/* 3458: .J,.'f. */
	0x08,0xEC,0x00,0x00,0x00,0x28,0x1C,0x2C,	/* 3460: ....(., */
	0x00,0x0A,0x1E,0x2C,0x00,0x0B,0x74,0x00,	/* 3468: ...,..t. */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0x1C,	/* 3470:  E... */
	0x10,0x07,0x12,0x06,0x52,0x81,0x90,0x81,	/* 3478: ....R */
	0x18,0x10,0x14,0x00,0xC8,0xBC,0x00,0x00,	/* 3480: ...... */
	0x00,0xFF,0xC8,0xBC,0x00,0x00,0x00,0xFF,	/* 3488: .... */
	0xB4,0x84,0x6F,0x04,0x26,0x04,0x60,0x02,	/* 3490: o.&.`. */
	0x26,0x02,0x98,0x83,0x2A,0x45,0xC6,0xBC,	/* 3498: &.*E */
	0x00,0x00,0x00,0xFF,0xDB,0xFC,0x04,0x01,	/* 34A0: ..... */
	0xF0,0xC4,0x20,0x03,0x27,0x4D,0x00,0x04,	/* 34A8:  .'M.. */
	0xB0,0xBC,0x00,0x00,0x00,0x20,0x62,0x00,	/* 34B0: ... b. */
	0x02,0x8C,0x20,0x7B,0x0C,0x04,0x4E,0xD0,	/* 34B8: . {..N */
	0x00,0x00,0x37,0x44,0x00,0x00,0x37,0x34,	/* 34C0: ..7D..74 */
	0x00,0x00,0x37,0x24,0x00,0x00,0x37,0x14,	/* 34C8: ..7$..7. */
	0x00,0x00,0x37,0x04,0x00,0x00,0x36,0xF4,	/* 34D0: ..7...6 */
	0x00,0x00,0x36,0xE4,0x00,0x00,0x36,0xD4,	/* 34D8: ..6..6 */
	0x00,0x00,0x36,0xC4,0x00,0x00,0x36,0xB4,	/* 34E0: ..6..6 */
	0x00,0x00,0x36,0xA4,0x00,0x00,0x36,0x94,	/* 34E8: ..6..6 */
	0x00,0x00,0x36,0x84,0x00,0x00,0x36,0x74,	/* 34F0: ..6..6t */
	0x00,0x00,0x36,0x64,0x00,0x00,0x36,0x54,	/* 34F8: ..6d..6T */
	0x00,0x00,0x36,0x44,0x00,0x00,0x36,0x34,	/* 3500: ..6D..64 */
	0x00,0x00,0x36,0x24,0x00,0x00,0x36,0x14,	/* 3508: ..6$..6. */
	0x00,0x00,0x36,0x04,0x00,0x00,0x35,0xF4,	/* 3510: ..6...5 */
	0x00,0x00,0x35,0xE4,0x00,0x00,0x35,0xD4,	/* 3518: ..5..5 */
	0x00,0x00,0x35,0xC4,0x00,0x00,0x35,0xB4,	/* 3520: ..5..5 */
	0x00,0x00,0x35,0xA4,0x00,0x00,0x35,0x94,	/* 3528: ..5..5 */
	0x00,0x00,0x35,0x84,0x00,0x00,0x35,0x74,	/* 3530: ..5..5t */
	0x00,0x00,0x35,0x64,0x00,0x00,0x35,0x54,	/* 3538: ..5d..5T */
	0x00,0x00,0x35,0x44,0x20,0x4C,0xCC,0xBC,	/* 3540: ..5D L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3548: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3550: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3558: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3560: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3568: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3570: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3578: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3580: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3588: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3590: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3598: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 35A0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 35A8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 35B0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 35B8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 35C0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 35C8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 35D0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 35D8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 35E0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 35E8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 35F0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 35F8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3600: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3608: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3610: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3618: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3620: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3628: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3630: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3638: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3640: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3648: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3650: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3658: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3660: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3668: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3670: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3678: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3680: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3688: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3690: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3698: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 36A0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 36A8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 36B0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 36B8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 36C0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 36C8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 36D0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 36D8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 36E0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 36E8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 36F0: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 36F8: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3700: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3708: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3710: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3718: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3720: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3728: ....U */
	0x01,0x60,0x52,0x86,0x20,0x4C,0xCC,0xBC,	/* 3730: .`R L */
	0x00,0x00,0x00,0xFF,0xD1,0xC6,0x11,0x55,	/* 3738: ....U */
	0x01,0x60,0x52,0x86,0x19,0x46,0x00,0x0A,	/* 3740: .`R.F.. */
	0x4B,0xEC,0x00,0x3E,0x70,0x00,0xC8,0xBC,	/* 3748: K.>p. */
	0x00,0x00,0x00,0xFF,0x76,0x00,0x10,0x2D,	/* 3750: ...v..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0xD0,0x84,	/* 3758: .... */
	0x36,0x00,0x20,0x03,0xE0,0x80,0x1B,0x40,	/* 3760: 6. ..@ */
	0x00,0x01,0x1A,0x83,0x4A,0x04,0x67,0x16,	/* 3768: ...J.g. */
	0x26,0x3C,0x04,0x01,0xF0,0xC4,0xD8,0xBC,	/* 3770: &<.. */
	0x00,0x00,0x00,0xFF,0x20,0x45,0xD1,0xC3,	/* 3778: ... E */
	0x10,0x10,0x4A,0x04,0x66,0xF0,0xD8,0xBC,	/* 3780: ..J.f */
	0x00,0x00,0x00,0xFF,0x12,0x06,0x4B,0xEC,	/* 3788: .....K */
	0x00,0x08,0x70,0x00,0x52,0x81,0x9E,0x81,	/* 3790: ..p.R */
	0x10,0x2D,0x00,0x01,0xE1,0x88,0x10,0x15,	/* 3798: .-.... */
	0xC0,0xBC,0x00,0x00,0x00,0x08,0x67,0x34,	/* 37A0: ....g4 */
	0x70,0x20,0xB0,0x82,0x6E,0x2E,0xCE,0xBC,	/* 37A8: p n. */
	0x00,0x00,0x00,0xFF,0x70,0x20,0xB0,0x87,	/* 37B0: ...p  */
	0x6F,0x22,0x4B,0xEC,0x00,0x08,0x70,0x00,	/* 37B8: o"K..p. */
	0x7E,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 37C0: ~..-.. */
	0x10,0x15,0x80,0xBC,0x00,0x00,0x00,0x10,	/* 37C8: ...... */
	0x3E,0x00,0x20,0x07,0xE0,0x80,0x1B,0x40,	/* 37D0: >. ..@ */
	0x00,0x01,0x1A,0x87,0x70,0x01,0x20,0x45,	/* 37D8: ...p. E */
	0x33,0xC0,0x00,0x00,0x62,0xAA,0xD1,0xFC,	/* 37E0: 3..b */
	0x04,0x01,0xF0,0xD6,0x10,0x2E,0xFF,0xFB,	/* 37E8: .... */
	0xC0,0xBC,0x00,0x00,0x00,0x3F,0x10,0x80,	/* 37F0: ...?. */
	0x60,0x00,0x01,0x8E,0x7C,0x00,0x2E,0x3C,	/* 37F8: `..|..< */
	0x04,0x01,0xF0,0xC4,0x20,0x45,0xD1,0xC7,	/* 3800: .. E */
	0x14,0x10,0x20,0x45,0xD1,0xC7,0xC4,0xBC,	/* 3808: .. E */
	0x00,0x00,0x00,0xFF,0x1E,0x10,0xCE,0xBC,	/* 3810: ..... */
	0x00,0x00,0x00,0xFF,0x08,0x02,0x00,0x03,	/* 3818: ....... */
	0x67,0x0E,0x08,0xEC,0x00,0x00,0x00,0x19,	/* 3820: g...... */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x62,0xA8,	/* 3828: p.3..b */
	0xC4,0xBC,0x00,0x00,0x00,0xFF,0x70,0x07,	/* 3830: ...p. */
	0xC0,0x82,0x67,0x10,0x08,0x2C,0x00,0x07,	/* 3838: g..,.. */
	0x00,0x20,0x67,0x08,0x70,0x01,0x33,0xC0,	/* 3840: . g.p.3 */
	0x00,0x00,0x62,0xA8,0x08,0x02,0x00,0x00,	/* 3848: ..b.... */
	0x67,0x1E,0x4B,0xEC,0x00,0x3C,0x70,0x00,	/* 3850: g.K.<p. */
	0x76,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 3858: v..-.. */
	0x10,0x15,0x52,0x80,0x36,0x00,0x20,0x03,	/* 3860: ..R6. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x83,	/* 3868: .@... */
	0x08,0x02,0x00,0x01,0x67,0x20,0x4B,0xEC,	/* 3870: ....g K */
	0x00,0x38,0x70,0x00,0x7C,0x00,0x10,0x2D,	/* 3878: .8p.|..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0x52,0x80,	/* 3880: ....R */
	0x3C,0x00,0x20,0x06,0xE0,0x80,0x1B,0x40,	/* 3888: <. ..@ */
	0x00,0x01,0x1A,0x86,0x7C,0x01,0x08,0x02,	/* 3890: ...|... */
	0x00,0x02,0x67,0x20,0x4B,0xEC,0x00,0x3A,	/* 3898: ..g K.: */
	0x70,0x00,0x74,0x00,0x10,0x2D,0x00,0x01,	/* 38A0: p.t..-.. */
	0xE1,0x88,0x10,0x15,0x52,0x80,0x34,0x00,	/* 38A8: ..R4. */
	0x20,0x02,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 38B0:  ..@.. */
	0x1A,0x82,0x7C,0x01,0x4A,0x86,0x67,0x00,	/* 38B8: .|.Jg. */
	0x00,0xB4,0x08,0x2C,0x00,0x06,0x00,0x20,	/* 38C0: ..,...  */
	0x67,0x04,0x1E,0x2C,0x00,0x2B,0x1C,0x2C,	/* 38C8: g..,.+., */
	0x00,0x0A,0x16,0x2C,0x00,0x0B,0x74,0x00,	/* 38D0: ...,..t. */
	0x10,0x03,0x12,0x06,0x52,0x81,0x90,0x81,	/* 38D8: ....R */
	0x14,0x00,0x4A,0x82,0x67,0x00,0x00,0x6A,	/* 38E0: ..Jg..j */
	0x20,0x4C,0xCC,0xBC,0x00,0x00,0x00,0xFF,	/* 38E8:  L... */
	0x4B,0xEC,0x00,0x08,0x70,0x00,0xD1,0xC6,	/* 38F0: K..p. */
	0x11,0x47,0x01,0x60,0x52,0x86,0x19,0x46,	/* 38F8: .G.`R.F */
	0x00,0x0A,0x1E,0x03,0x12,0x06,0x52,0x81,	/* 3900: ......R */
	0x10,0x2D,0x00,0x01,0x9E,0x81,0xE1,0x88,	/* 3908: .-.. */
	0x10,0x15,0xC0,0xBC,0x00,0x00,0x00,0x08,	/* 3910: ...... */
	0x67,0x5A,0x70,0x20,0xB0,0x82,0x6E,0x54,	/* 3918: gZp nT */
	0xCE,0xBC,0x00,0x00,0x00,0xFF,0x70,0x20,	/* 3920: ...p  */
	0xB0,0x87,0x6F,0x48,0x4B,0xEC,0x00,0x08,	/* 3928: oHK.. */
	0x70,0x00,0x7E,0x00,0x10,0x2D,0x00,0x01,	/* 3930: p.~..-.. */
	0xE1,0x88,0x10,0x15,0x80,0xBC,0x00,0x00,	/* 3938: .... */
	0x00,0x10,0x3E,0x00,0x20,0x07,0xE0,0x80,	/* 3940: ..>. . */
	0x1B,0x40,0x00,0x01,0x1A,0x87,0x60,0x24,	/* 3948: .@...`$ */
	0x4B,0xEC,0x00,0x3E,0x70,0x00,0xC8,0xBC,	/* 3950: K.>p. */
	0x00,0x00,0x00,0xFF,0x7E,0x00,0x10,0x2D,	/* 3958: ...~..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0xD0,0x84,	/* 3960: .... */
	0x3E,0x00,0x20,0x07,0xE0,0x80,0x1B,0x40,	/* 3968: >. ..@ */
	0x00,0x01,0x1A,0x87,0x20,0x45,0xD1,0xFC,	/* 3970: ... E */
	0x04,0x01,0xF0,0xD6,0x10,0x2E,0xFF,0xFB,	/* 3978: .... */
	0xC0,0xBC,0x00,0x00,0x00,0x3F,0x10,0x80,	/* 3980: ...?. */
	0x10,0x2E,0xFF,0xFA,0x08,0x00,0x00,0x01,	/* 3988: ...... */
	0x67,0x00,0x04,0xFA,0x20,0x45,0xD1,0xFC,	/* 3990: g.. E */
	0x04,0x01,0xF0,0xD4,0x10,0x10,0x20,0x45,	/* 3998: .... E */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 39A0: .. */
	0x00,0x00,0x00,0xFF,0x1D,0x40,0xFF,0xFB,	/* 39A8: ....@ */
	0x10,0x2E,0xFF,0xFB,0xC0,0xBC,0x00,0x00,	/* 39B0: .... */
	0x00,0x03,0x10,0x80,0x10,0x2E,0xFF,0xFB,	/* 39B8: ..... */
	0x22,0x2E,0xFF,0xF4,0xC0,0xBC,0x00,0x00,	/* 39C0: "... */
	0x00,0x03,0xE5,0x89,0xD0,0x81,0x4B,0xF2,	/* 39C8: ..K */
	0x0A,0x0A,0x70,0x00,0x10,0x2D,0x00,0x01,	/* 39D0: ..p..-.. */
	0xE1,0x88,0x10,0x15,0x72,0x00,0x32,0x00,	/* 39D8: ..r.2. */
	0x28,0x41,0xD9,0xFC,0x01,0x01,0x80,0x00,	/* 39E0: (A... */
	0x4A,0x2C,0x00,0x27,0x66,0x06,0x08,0xEC,	/* 39E8: J,.'f.. */
	0x00,0x01,0x00,0x28,0x4A,0x2C,0x00,0x35,	/* 39F0: ...(J,.5 */
	0x67,0x0E,0x2F,0x0C,0x4E,0xB9,0x00,0x00,	/* 39F8: g...N.. */
	0x4E,0xA0,0x58,0x8F,0x60,0x00,0x04,0x72,	/* 3A00: NX`..r */
	0x14,0x2C,0x00,0x0D,0x1E,0x2C,0x00,0x0C,	/* 3A08: .,...,.. */
	0x4B,0xEC,0x00,0x08,0x70,0x00,0x10,0x2D,	/* 3A10: K..p..- */
	0x00,0x01,0xE1,0x88,0x10,0x15,0xC0,0xBC,	/* 3A18: .... */
	0x00,0x00,0x01,0x00,0x67,0x6E,0x4B,0xEC,	/* 3A20: ....gnK */
	0x00,0x08,0x7C,0x00,0x1C,0x2D,0x00,0x01,	/* 3A28: ..|..-.. */
	0xE1,0x8E,0x1C,0x15,0xCC,0xBC,0x00,0x00,	/* 3A30: .... */
	0xFE,0xFF,0x20,0x06,0xE0,0x80,0x1B,0x40,	/* 3A38:  ..@ */
	0x00,0x01,0x1A,0x86,0x70,0x00,0x10,0x2D,	/* 3A40: ...p..- */
	0x00,0x01,0x7C,0x00,0xE1,0x88,0x10,0x15,	/* 3A48: ..|... */
	0x80,0xBC,0x00,0x00,0x02,0x00,0x3C,0x00,	/* 3A50: ....<. */
	0x20,0x06,0xE0,0x80,0x1B,0x40,0x00,0x01,	/* 3A58:  ..@.. */
	0x20,0x45,0x1A,0x86,0x7C,0x00,0x1C,0x2D,	/* 3A60:  E.|..- */
	0x00,0x01,0xE1,0x8E,0x1C,0x15,0xCC,0xBC,	/* 3A68: .... */
	0x00,0x00,0xFF,0xFE,0x20,0x06,0xE0,0x80,	/* 3A70: .. . */
	0x1B,0x40,0x00,0x01,0x22,0x45,0x1A,0x86,	/* 3A78: .@.."E. */
	0x2C,0x3C,0x04,0x01,0xF0,0x0C,0xD1,0xC6,	/* 3A80: ,<... */
	0xD3,0xC6,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 3A88: .... */
	0x00,0xF9,0x10,0x80,0x10,0x02,0x7C,0x00,	/* 3A90: ....|. */
	0x76,0x00,0x90,0x87,0x16,0x2C,0x00,0x2A,	/* 3A98: v..,.* */
	0x1C,0x00,0xBC,0x83,0x6F,0x02,0x60,0x04,	/* 3AA0: ..o.`. */
	0x76,0x00,0x16,0x06,0x4A,0x83,0x66,0x18,	/* 3AA8: v...Jf. */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0x0C,	/* 3AB0:  E... */
	0x10,0x10,0x08,0x00,0x00,0x02,0x67,0x08,	/* 3AB8: ......g. */
	0x70,0x02,0x19,0x40,0x00,0x44,0x60,0x04,	/* 3AC0: p..@.D`. */
	0x19,0x43,0x00,0x44,0x2A,0x45,0xDB,0xFC,	/* 3AC8: .C.D*E */
	0x04,0x01,0xF0,0xC6,0x27,0x4D,0x00,0x04,	/* 3AD0: ..'M.. */
	0x20,0x03,0xB0,0xBC,0x00,0x00,0x00,0x20,	/* 3AD8:  ....  */
	0x62,0x00,0x02,0x88,0x20,0x7B,0x0C,0x04,	/* 3AE0: b.. {.. */
	0x4E,0xD0,0x00,0x00,0x3D,0x6A,0x00,0x00,	/* 3AE8: N..=j.. */
	0x3D,0x5A,0x00,0x00,0x3D,0x4A,0x00,0x00,	/* 3AF0: =Z..=J.. */
	0x3D,0x3A,0x00,0x00,0x3D,0x2A,0x00,0x00,	/* 3AF8: =:..=*.. */
	0x3D,0x1A,0x00,0x00,0x3D,0x0A,0x00,0x00,	/* 3B00: =...=... */
	0x3C,0xFA,0x00,0x00,0x3C,0xEA,0x00,0x00,	/* 3B08: <..<.. */
	0x3C,0xDA,0x00,0x00,0x3C,0xCA,0x00,0x00,	/* 3B10: <..<.. */
	0x3C,0xBA,0x00,0x00,0x3C,0xAA,0x00,0x00,	/* 3B18: <..<.. */
	0x3C,0x9A,0x00,0x00,0x3C,0x8A,0x00,0x00,	/* 3B20: <..<.. */
	0x3C,0x7A,0x00,0x00,0x3C,0x6A,0x00,0x00,	/* 3B28: <z..<j.. */
	0x3C,0x5A,0x00,0x00,0x3C,0x4A,0x00,0x00,	/* 3B30: <Z..<J.. */
	0x3C,0x3A,0x00,0x00,0x3C,0x2A,0x00,0x00,	/* 3B38: <:..<*.. */
	0x3C,0x1A,0x00,0x00,0x3C,0x0A,0x00,0x00,	/* 3B40: <...<... */
	0x3B,0xFA,0x00,0x00,0x3B,0xEA,0x00,0x00,	/* 3B48: ;..;.. */
	0x3B,0xDA,0x00,0x00,0x3B,0xCA,0x00,0x00,	/* 3B50: ;..;.. */
	0x3B,0xBA,0x00,0x00,0x3B,0xAA,0x00,0x00,	/* 3B58: ;..;.. */
	0x3B,0x9A,0x00,0x00,0x3B,0x8A,0x00,0x00,	/* 3B60: ;..;.. */
	0x3B,0x7A,0x00,0x00,0x3B,0x6E,0xCE,0xBC,	/* 3B68: ;z..;n */
	0x00,0x00,0x00,0xFF,0x1A,0xB4,0x78,0x60,	/* 3B70: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3B78: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3B80: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3B88: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3B90: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3B98: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3BA0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3BA8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3BB0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3BB8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3BC0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3BC8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3BD0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3BD8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3BE0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3BE8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3BF0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3BF8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C00: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C08: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C10: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C18: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C20: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C28: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C30: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C38: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C40: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C48: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C50: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C58: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C60: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C68: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C70: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C78: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C80: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C88: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3C90: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3C98: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3CA0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3CA8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3CB0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3CB8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3CC0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3CC8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3CD0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3CD8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3CE0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3CE8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3CF0: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3CF8: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3D00: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3D08: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3D10: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3D18: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3D20: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3D28: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3D30: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3D38: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3D40: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3D48: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3D50: ....x` */
	0x52,0x87,0x20,0x6B,0x00,0x04,0xCE,0xBC,	/* 3D58: R k.. */
	0x00,0x00,0x00,0xFF,0x10,0xB4,0x78,0x60,	/* 3D60: ....x` */
	0x52,0x87,0x10,0x02,0x74,0x00,0x19,0x47,	/* 3D68: R..t..G */
	0x00,0x0C,0x90,0x87,0x14,0x00,0x2E,0x3C,	/* 3D70: .....< */
	0x00,0x00,0x00,0xC0,0xBC,0x87,0x6F,0x28,	/* 3D78: ...o( */
	0xB4,0x87,0x6E,0x2A,0x4B,0xEC,0x00,0x08,	/* 3D80: n*K.. */
	0x70,0x00,0x7E,0x00,0x10,0x2D,0x00,0x01,	/* 3D88: p.~..-.. */
	0xE1,0x88,0x10,0x15,0x80,0xBC,0x00,0x00,	/* 3D90: .... */
	0x08,0x00,0x3E,0x00,0x20,0x07,0xE0,0x80,	/* 3D98: ..>. . */
	0x1B,0x40,0x00,0x01,0x1A,0x87,0x60,0x48,	/* 3DA0: .@...`H */
	0x70,0x40,0xB0,0x86,0x6C,0x42,0x70,0x40,	/* 3DA8: p@lBp@ */
	0xB0,0x82,0x6D,0x3C,0x4B,0xEC,0x00,0x08,	/* 3DB0: m<K.. */
	0x70,0x00,0x10,0x2D,0x00,0x01,0xE1,0x88,	/* 3DB8: p..-.. */
	0x10,0x15,0xC0,0xBC,0x00,0x00,0x08,0x00,	/* 3DC0: ...... */
	0x67,0x26,0x4B,0xEC,0x00,0x08,0x7E,0x00,	/* 3DC8: g&K..~. */
	0x1E,0x2D,0x00,0x01,0xE1,0x8F,0x1E,0x15,	/* 3DD0: .-.... */
	0xCE,0xBC,0x00,0x00,0xF7,0xFF,0x20,0x07,	/* 3DD8: .. . */
	0xE0,0x80,0x1B,0x40,0x00,0x01,0x1A,0x87,	/* 3DE0: .@... */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x62,0xA8,	/* 3DE8: p.3..b */
	0x4A,0x82,0x66,0x00,0x00,0x7E,0x24,0x3C,	/* 3DF0: Jf..~$< */
	0x04,0x01,0xF0,0x0C,0x20,0x45,0xD1,0xC2,	/* 3DF8: ... E */
	0x10,0x10,0x08,0x00,0x00,0x02,0x67,0x1A,	/* 3E00: ......g. */
	0x20,0x45,0x22,0x45,0xD1,0xC2,0xD3,0xC2,	/* 3E08:  E"E */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFB,	/* 3E10: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x02,0x10,0x80,	/* 3E18: ..... */
	0x60,0x56,0x4B,0xEC,0x00,0x08,0x7E,0x00,	/* 3E20: `VK..~. */
	0x20,0x45,0x22,0x45,0xD1,0xC2,0x1E,0x2D,	/* 3E28:  E"E.- */
	0x00,0x01,0xE1,0x8F,0x1E,0x15,0xCE,0xBC,	/* 3E30: .... */
	0x00,0x00,0xFF,0xFE,0x20,0x07,0xE0,0x80,	/* 3E38: .. . */
	0x1B,0x40,0x00,0x01,0xD3,0xC2,0x1A,0x87,	/* 3E40: .@... */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xF9,	/* 3E48: ..... */
	0x10,0x80,0x1E,0x2C,0x00,0x41,0x08,0x07,	/* 3E50: ..,.A.. */
	0x00,0x00,0x67,0x1C,0x70,0x01,0x33,0xC0,	/* 3E58: ..g.p.3 */
	0x00,0x00,0x62,0xA8,0x10,0x07,0xC0,0xBC,	/* 3E60: ..b.. */
	0x00,0x00,0x00,0xFE,0x19,0x40,0x00,0x41,	/* 3E68: ....@.A */
	0x60,0x06,0x08,0xEC,0x00,0x00,0x00,0x41,	/* 3E70: `.....A */
	0x20,0x45,0xD1,0xFC,0x04,0x01,0xF0,0xD4,	/* 3E78:  E.. */
	0x10,0x2E,0xFF,0xFB,0xC0,0xBC,0x00,0x00,	/* 3E80: .... */
	0x00,0x3F,0x10,0x80,0x10,0x2E,0xFF,0xFA,	/* 3E88: .?... */
	0x08,0x00,0x00,0x02,0x67,0x00,0x00,0x94,	/* 3E90: ....g.. */
	0x2A,0x7C,0x04,0x01,0xF0,0xD2,0x20,0x45,	/* 3E98: *|.. E */
	0xD1,0xCD,0x10,0x10,0x20,0x45,0xD1,0xFC,	/* 3EA0: .. E */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 3EA8: .... */
	0x00,0xFF,0x1D,0x40,0xFF,0xFB,0x10,0x2E,	/* 3EB0: ..@.. */
	0xFF,0xFB,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 3EB8: .... */
	0x10,0x80,0x10,0x2E,0xFF,0xFB,0x22,0x2E,	/* 3EC0: ...". */
	0xFF,0xF4,0xC0,0xBC,0x00,0x00,0x00,0x03,	/* 3EC8: .... */
	0xE5,0x89,0xD0,0x81,0x49,0xF2,0x0A,0x0A,	/* 3ED0: I.. */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 3ED8: p..,.. */
	0x10,0x14,0x72,0x00,0x32,0x00,0x28,0x41,	/* 3EE0: ..r.2.(A */
	0xD9,0xFC,0x01,0x01,0x80,0x00,0x2F,0x0C,	/* 3EE8: ..... */
	0x4E,0xB9,0x00,0x00,0x50,0x58,0x2F,0x0C,	/* 3EF0: N..PX.. */
	0x4E,0xB9,0x00,0x00,0x2B,0xAC,0x50,0x8F,	/* 3EF8: N..+P */
	0x4A,0x2C,0x00,0x27,0x66,0x06,0x08,0xEC,	/* 3F00: J,.'f.. */
	0x00,0x02,0x00,0x28,0x70,0x01,0x20,0x45,	/* 3F08: ...(p. E */
	0x33,0xC0,0x00,0x00,0x62,0xA8,0xD1,0xCD,	/* 3F10: 3..b */
	0x08,0xEC,0x00,0x01,0x00,0x19,0x10,0x2E,	/* 3F18: ....... */
	0xFF,0xFB,0xC0,0xBC,0x00,0x00,0x00,0x3F,	/* 3F20: ...? */
	0x10,0x80,0x20,0x2E,0xFF,0xF4,0x72,0x00,	/* 3F28: . .r. */
	0x52,0x80,0x12,0x00,0x2D,0x41,0xFF,0xF4,	/* 3F30: R..-A */
	0x20,0x2E,0xFF,0xF4,0x55,0x80,0x6D,0x30,	/* 3F38:  .Um0 */
	0x70,0x00,0x7A,0x00,0x2D,0x40,0xFF,0xF4,	/* 3F40: p.z.-@ */
	0x70,0x00,0x10,0x2A,0x00,0x01,0xE1,0x88,	/* 3F48: p..*.. */
	0x10,0x12,0x3A,0x00,0x4A,0x85,0x67,0x12,	/* 3F50: ..:.Jg. */
	0x20,0x3C,0xFF,0xFF,0x7F,0xFF,0xC0,0x85,	/* 3F58:  < */
	0x24,0x40,0xD5,0xFC,0x01,0x01,0x80,0x00,	/* 3F60: $@... */
	0x60,0x06,0x24,0x7C,0x01,0x01,0x80,0x80,	/* 3F68: `.$|.. */
	0x4A,0x2E,0xFF,0xFA,0x66,0x14,0xB5,0xEB,	/* 3F70: J.f. */
	0x00,0x08,0x66,0x00,0xF4,0x1A,0x70,0x00,	/* 3F78: ..f..p. */
	0x10,0x13,0xB0,0xAE,0xFF,0xF4,0x66,0x00,	/* 3F80: ..f. */
	0xF4,0x0E,0x27,0x4A,0x00,0x08,0x20,0x2E,	/* 3F88: .'J.. . */
	0xFF,0xF4,0x16,0x80,0x4C,0xD7,0x3C,0xFC,	/* 3F90: .L< */
	0x4F,0xEF,0x00,0x28,0x4E,0x5E,0x4E,0x75,	/* 3F98: O.(N^Nu */
	0x4F,0xEF,0xFF,0xF0,0x48,0xD7,0x38,0x80,	/* 3FA0: OH8 */
	0x2A,0x7C,0x01,0x01,0x81,0x80,0x26,0x7C,	/* 3FA8: *|..&| */
	0x00,0x00,0x64,0x88,0x28,0x7C,0x00,0x00,	/* 3FB0: ..d(|.. */
	0x62,0xA0,0x4A,0x14,0x67,0x06,0x4E,0xB9,	/* 3FB8: bJ.g.N */
	0x00,0x00,0x0E,0x5C,0x20,0x53,0x10,0x28,	/* 3FC0: ...\ S.( */
	0x00,0x07,0x52,0x80,0x11,0x40,0x00,0x07,	/* 3FC8: ..R.@.. */
	0x61,0x00,0xF3,0xA6,0x70,0x00,0x10,0x2D,	/* 3FD0: a.p..- */
	0x00,0x0E,0x7E,0x00,0x3E,0x00,0x4A,0x87,	/* 3FD8: ..~.>.J */
	0x67,0x1A,0x20,0x7C,0x00,0x00,0x63,0x5C,	/* 3FE0: g. |..c\ */
	0x20,0x70,0x7C,0x00,0x2F,0x0D,0x4E,0x90,	/* 3FE8:  p|...N */
	0x58,0x8F,0x72,0x00,0x32,0x00,0x4A,0x81,	/* 3FF0: Xr.2.J */
	0x67,0x00,0x01,0x6C,0x43,0xED,0x00,0x02,	/* 3FF8: g..lC.. */
	0x70,0x00,0x7E,0x00,0x10,0x29,0x00,0x01,	/* 4000: p.~..).. */
	0xE1,0x88,0x10,0x11,0x43,0xED,0x00,0x08,	/* 4008: ..C.. */
	0x3E,0x00,0x70,0x00,0x10,0x29,0x00,0x01,	/* 4010: >.p..).. */
	0xE1,0x88,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 4018: .... */
	0x00,0x01,0x66,0x00,0x00,0xA0,0x10,0x2D,	/* 4020: ..f...- */
	0x00,0x0D,0x12,0x2D,0x00,0x0C,0x90,0x81,	/* 4028: ...-.. */
	0x4A,0x00,0x67,0x00,0x00,0x90,0x43,0xED,	/* 4030: J.g..C */
	0x00,0x08,0x70,0x00,0x10,0x29,0x00,0x01,	/* 4038: ..p..).. */
	0xE1,0x88,0x10,0x11,0x80,0xBC,0x00,0x00,	/* 4040: .... */
	0x00,0x01,0x72,0x00,0x32,0x00,0x20,0x01,	/* 4048: ..r.2. . */
	0xE0,0x80,0x13,0x40,0x00,0x01,0x12,0x81,	/* 4050: .@... */
	0x43,0xED,0x00,0x04,0x70,0x00,0x10,0x29,	/* 4058: C..p..) */
	0x00,0x01,0xE1,0x88,0x10,0x11,0x72,0x00,	/* 4060: ....r. */
	0x32,0x00,0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,	/* 4068: 2. */
	0x20,0x41,0xD1,0xFC,0x01,0x01,0x80,0x09,	/* 4070:  A... */
	0x10,0x2D,0x00,0x07,0x10,0x80,0x20,0x47,	/* 4078: .-... G */
	0xD1,0xFC,0x04,0x01,0xF0,0xFE,0x10,0x2D,	/* 4080: ...- */
	0x00,0x07,0x10,0x80,0x20,0x47,0xD1,0xFC,	/* 4088: ... G */
	0x04,0x01,0xF0,0xD0,0x10,0x2D,0x00,0x07,	/* 4090: ...-.. */
	0xC0,0xBC,0x00,0x00,0x00,0x03,0x10,0x80,	/* 4098: ..... */
	0x22,0x3C,0x04,0x01,0xF0,0x0C,0x20,0x47,	/* 40A0: "<... G */
	0xD1,0xC1,0x22,0x47,0xD3,0xC1,0x10,0x11,	/* 40A8: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x80,0xBC,	/* 40B0: ... */
	0x00,0x00,0x00,0x04,0x10,0x80,0x70,0x01,	/* 40B8: .....p. */
	0x1B,0x40,0x00,0x29,0x43,0xED,0x00,0x08,	/* 40C0: .@.)C.. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 40C8: p..).. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0x10,	/* 40D0: ...... */
	0x67,0x32,0x10,0x2D,0x00,0x0A,0x12,0x2D,	/* 40D8: g2.-...- */
	0x00,0x0B,0x90,0x81,0x72,0x00,0x12,0x00,	/* 40E0: ..r... */
	0x70,0x20,0xB0,0x81,0x6F,0x1E,0x43,0xED,	/* 40E8: p o.C */
	0x00,0x08,0x72,0x00,0x12,0x29,0x00,0x01,	/* 40F0: ..r..).. */
	0xE1,0x89,0x12,0x11,0xC2,0xBC,0x00,0x00,	/* 40F8: .... */
	0xFF,0xEF,0x20,0x01,0xE0,0x80,0x13,0x40,	/* 4100:  ..@ */
	0x00,0x01,0x12,0x81,0x08,0x2D,0x00,0x04,	/* 4108: ....-.. */
	0x00,0x40,0x67,0x52,0x43,0xED,0x00,0x04,	/* 4110: .@gRC.. */
	0x70,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 4118: p..).. */
	0x10,0x11,0x72,0x00,0x32,0x00,0xC2,0xBC,	/* 4120: ..r.2. */
	0xFF,0xFF,0x7F,0xFF,0x20,0x41,0x10,0x2D,	/* 4128:  A.- */
	0x00,0x07,0xD1,0xFC,0x01,0x01,0x80,0x09,	/* 4130: ..... */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x07,	/* 4138: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0xFE,0x10,0x80,	/* 4140: ... */
	0x20,0x47,0x10,0x2D,0x00,0x07,0xD1,0xFC,	/* 4148:  G.-.. */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 4150: .... */
	0x00,0x03,0x10,0x80,0x2F,0x0D,0x4E,0xB9,	/* 4158: .....N */
	0x00,0x00,0x50,0x58,0x58,0x8F,0x43,0xED,	/* 4160: ..PXXC */
	0x00,0x2E,0x70,0x00,0x10,0x29,0x00,0x01,	/* 4168: ..p..).. */
	0xE1,0x88,0x10,0x11,0x72,0x00,0x32,0x00,	/* 4170: ..r.2. */
	0x2A,0x41,0xDB,0xFC,0x01,0x01,0x80,0x00,	/* 4178: *A... */
	0x60,0x00,0xFE,0x38,0x4F,0xEF,0xFF,0xF0,	/* 4180: `.8O */
	0x48,0xD7,0x03,0x03,0x4E,0xB9,0x00,0x00,	/* 4188: H..N.. */
	0x51,0x04,0x42,0x39,0x03,0x01,0xF8,0x00,	/* 4190: Q.B9... */
	0x4C,0xD7,0x03,0x03,0x4F,0xEF,0x00,0x10,	/* 4198: L..O.. */
	0x4E,0x73,0x00,0x00,0x30,0x45,0x4E,0x71,	/* 41A0: Ns..0ENq */
	0x43,0x6F,0x70,0x79,0x72,0x69,0x67,0x68,	/* 41A8: Copyrigh */
	0x74,0x20,0x28,0x63,0x29,0x20,0x50,0x65,	/* 41B0: t (c) Pe */
	0x72,0x6C,0x65,0x20,0x53,0x79,0x73,0x74,	/* 41B8: rle Syst */
	0x65,0x6D,0x73,0x20,0x4C,0x74,0x64,0x20,	/* 41C0: ems Ltd  */
	0x31,0x39,0x39,0x36,0x2D,0x32,0x30,0x30,	/* 41C8: 1996-200 */
	0x30,0x2E,0x0D,0x0A,0x4A,0x45,0x54,0x43,	/* 41D0: 0...JETC */
	0x46,0x2E,0x42,0x49,0x4E,0x20,0x56,0x65,	/* 41D8: F.BIN Ve */
	0x72,0x73,0x69,0x6F,0x6E,0x20,0x34,0x2E,	/* 41E0: rsion 4. */
	0x30,0x2E,0x35,0x20,0x43,0x72,0x65,0x61,	/* 41E8: 0.5 Crea */
	0x74,0x65,0x64,0x20,0x4D,0x61,0x79,0x20,	/* 41F0: ted May  */
	0x31,0x34,0x20,0x32,0x30,0x30,0x31,0x20,	/* 41F8: 14 2001  */
	0x40,0x20,0x31,0x35,0x3A,0x34,0x30,0x3A,	/* 4200: @ 15:40: */
	0x31,0x39,0x00,0x00,0x20,0x6F,0x00,0x04,	/* 4208: 19.. o.. */
	0x70,0x00,0x54,0x88,0x10,0x28,0x00,0x01,	/* 4210: p.T.(.. */
	0xE1,0x88,0x10,0x10,0x72,0x00,0x32,0x00,	/* 4218: ..r.2. */
	0x20,0x01,0xC0,0xBC,0x00,0x00,0x00,0x10,	/* 4220:  ..... */
	0x67,0x1E,0x20,0x01,0xC0,0xBC,0xFF,0xFF,	/* 4228: g. . */
	0xFF,0xEF,0x20,0x40,0xD1,0xFC,0x04,0x01,	/* 4230:  @.. */
	0xF0,0x1A,0x10,0x10,0xC0,0xBC,0x00,0x00,	/* 4238: ..... */
	0x00,0xFF,0x46,0x80,0xE2,0x80,0x4E,0x75,	/* 4240: .FNu */
	0x20,0x01,0xC0,0xBC,0xFF,0xFF,0xFF,0xEF,	/* 4248:  . */
	0x20,0x40,0xD1,0xFC,0x04,0x01,0xF0,0x1A,	/* 4250:  @... */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 4258: ..... */
	0x46,0x80,0xD0,0x80,0x4E,0x75,0x4E,0x71,	/* 4260: FNuNq */
	0x2F,0x07,0x7E,0x00,0x70,0x00,0x72,0x00,	/* 4268: ..~.p.r. */
	0x20,0x6F,0x00,0x08,0x43,0xE8,0x00,0x02,	/* 4270:  o..C.. */
	0x1E,0x29,0x00,0x01,0xE1,0x8F,0x1E,0x11,	/* 4278: .).... */
	0x43,0xE8,0x00,0x04,0x10,0x29,0x00,0x01,	/* 4280: C...).. */
	0xE1,0x88,0x10,0x11,0x32,0x00,0xC2,0xBC,	/* 4288: ..2. */
	0xFF,0xFF,0x7F,0xFF,0x70,0x00,0x22,0x41,	/* 4290: p."A */
	0x30,0x2F,0x00,0x0E,0xD3,0xFC,0x01,0x01,	/* 4298: 0..... */
	0x80,0x00,0x53,0x80,0x66,0x10,0x10,0x28,	/* 42A0: .Sf..( */
	0x00,0x0F,0x12,0x29,0x00,0x04,0x82,0x80,	/* 42A8: ...).. */
	0x13,0x41,0x00,0x04,0x60,0x10,0x10,0x28,	/* 42B0: .A..`..( */
	0x00,0x0F,0x46,0x80,0x12,0x29,0x00,0x04,	/* 42B8: ..F.).. */
	0xC2,0x80,0x13,0x41,0x00,0x04,0x30,0x07,	/* 42C0: .A..0. */
	0x2E,0x1F,0xC0,0xBC,0x00,0x00,0xFF,0x00,	/* 42C8: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x80,0x20,0x40,	/* 42D0: ... @ */
	0xD1,0xFC,0x04,0x01,0xF0,0x00,0x10,0x29,	/* 42D8: ....) */
	0x00,0x04,0x46,0x80,0x10,0x80,0x4E,0x75,	/* 42E0: ..F.Nu */
	0x4E,0x56,0xFF,0xF0,0x70,0x00,0x4F,0xEF,	/* 42E8: NVp.O */
	0xFF,0xDC,0x48,0xD7,0x38,0xFC,0x2A,0x6E,	/* 42F0: H8*n */
	0x00,0x08,0x36,0x2E,0x00,0x0E,0x26,0x6E,	/* 42F8: ..6...&n */
	0x00,0x10,0x7E,0x00,0x74,0x00,0x49,0xED,	/* 4300: ..~.t.I */
	0x00,0x02,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 4308: ...,.. */
	0x10,0x14,0x72,0x00,0x32,0x00,0x22,0x41,	/* 4310: ..r.2."A */
	0x1E,0x2D,0x00,0x0A,0x1D,0x6D,0x00,0x0B,	/* 4318: .-...m.. */
	0xFF,0xF6,0x12,0x2E,0xFF,0xF6,0x20,0x07,	/* 4320: .. . */
	0x90,0x81,0x1D,0x40,0xFF,0xF7,0x38,0x13,	/* 4328: .@8. */
	0x14,0x2D,0x00,0x21,0x7C,0x00,0x28,0x7C,	/* 4330: .-.!|.(| */
	0x04,0x01,0xF0,0x04,0x20,0x49,0x70,0x40,	/* 4338: ... Ip@ */
	0x7A,0x00,0xD1,0xCC,0x10,0x80,0x20,0x49,	/* 4340: z.. I */
	0xD1,0xFC,0x04,0x01,0xF0,0x06,0x10,0x10,	/* 4348: ..... */
	0x12,0x2D,0x00,0x23,0xC0,0x81,0xC0,0xBC,	/* 4350: .-.# */
	0x00,0x00,0x00,0xFF,0x3A,0x00,0x4A,0x85,	/* 4358: ...:.J */
	0x66,0x46,0x30,0x03,0xC0,0xBC,0x00,0x00,	/* 4360: fF0... */
	0x00,0x80,0x67,0x3C,0x30,0x02,0xC0,0xBC,	/* 4368: .g<0. */
	0x00,0x00,0x00,0x01,0x67,0x04,0x7C,0x01,	/* 4370: ....g.|. */
	0x60,0x2E,0x30,0x02,0xC0,0xBC,0x00,0x00,	/* 4378: `.0... */
	0x00,0x02,0x67,0x12,0x08,0xED,0x00,0x00,	/* 4380: ..g.... */
	0x00,0x19,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 4388: ..p.3.. */
	0x62,0xA8,0x7C,0x01,0x60,0x12,0x20,0x4D,	/* 4390: b|.`. M */
	0x20,0x07,0xD1,0xC7,0x52,0x80,0x42,0x28,	/* 4398:  .RB( */
	0x01,0x60,0x7E,0x00,0x1E,0x00,0x7C,0x01,	/* 43A0: .`~...|. */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0x00,0x02,	/* 43A8: 0..... */
	0x67,0x00,0x00,0x6C,0x1D,0x6D,0x00,0x11,	/* 43B0: g..l.m.. */
	0xFF,0xFF,0x70,0x00,0x10,0x2E,0xFF,0xFF,	/* 43B8: p... */
	0x22,0x00,0x30,0x04,0xC0,0xBC,0x00,0x00,	/* 43C0: ".0... */
	0x00,0x04,0x67,0x2C,0x30,0x04,0xC0,0xBC,	/* 43C8: ..g,0. */
	0x00,0x00,0x00,0x01,0x66,0x0A,0x70,0x00,	/* 43D0: ....f.p. */
	0x10,0x2D,0x00,0x10,0xBA,0x80,0x66,0x2E,	/* 43D8: .-..f. */
	0xC8,0xBC,0x00,0x00,0xFF,0xFB,0x70,0x00,	/* 43E0: ..p. */
	0x10,0x2D,0x00,0x10,0xBA,0x80,0x67,0x04,	/* 43E8: .-..g. */
	0xBA,0x81,0x66,0x1A,0x7C,0x01,0x60,0x16,	/* 43F0: f.|.`. */
	0x70,0x00,0x10,0x2D,0x00,0x10,0xBA,0x80,	/* 43F8: p..-.. */
	0x66,0x0C,0x70,0x00,0x10,0x2E,0xFF,0xFF,	/* 4400: f.p... */
	0xBA,0x80,0x67,0x02,0x7C,0x01,0xBA,0x81,	/* 4408: g.|. */
	0x66,0x0C,0x4A,0x86,0x66,0x08,0x88,0xBC,	/* 4410: f.Jf. */
	0x00,0x00,0x00,0x04,0x7C,0x01,0xC6,0xBC,	/* 4418: ....|. */
	0x00,0x00,0xFF,0xFF,0x70,0x70,0xC0,0x83,	/* 4420: ..pp */
	0x67,0x00,0x00,0x6A,0x4A,0x86,0x66,0x00,	/* 4428: g..jJf. */
	0x00,0x64,0x30,0x04,0xC0,0xBC,0x00,0x00,	/* 4430: .d0... */
	0x80,0x00,0x67,0x58,0x30,0x02,0xC0,0xBC,	/* 4438: .gX0. */
	0x00,0x00,0x00,0x08,0x67,0x04,0x60,0x00,	/* 4440: ....g.`. */
	0x00,0xB2,0x30,0x02,0xC0,0xBC,0x00,0x00,	/* 4448: .0... */
	0x00,0x04,0x67,0x36,0x20,0x4D,0x70,0xFF,	/* 4450: ..g6 Mp */
	0xD1,0xC7,0x11,0x40,0x01,0x60,0x20,0x07,	/* 4458: .@.` . */
	0x20,0x4D,0x52,0x80,0x7E,0x00,0x1E,0x00,	/* 4460:  MR~... */
	0xD1,0xC7,0x20,0x07,0x42,0x28,0x01,0x60,	/* 4468:  .B(.` */
	0x52,0x80,0x7E,0x00,0x1E,0x00,0x20,0x4D,	/* 4470: R~... M */
	0xD1,0xC7,0x20,0x07,0x11,0x45,0x01,0x60,	/* 4478:  ..E.` */
	0x52,0x80,0x7E,0x00,0x1E,0x00,0x60,0x00,	/* 4480: R~...`. */
	0x00,0x72,0x20,0x4D,0xD1,0xC7,0x42,0x28,	/* 4488: .r MB( */
	0x01,0x60,0x60,0x2C,0xBA,0xBC,0x00,0x00,	/* 4490: .``,.. */
	0x00,0xFF,0x66,0x2E,0x30,0x02,0xC0,0xBC,	/* 4498: .f.0. */
	0x00,0x00,0x00,0x04,0x67,0x24,0x76,0xFF,	/* 44A0: ....g$v */
	0x20,0x4D,0x20,0x07,0xD1,0xC7,0x52,0x80,	/* 44A8:  M .R */
	0x11,0x43,0x01,0x60,0x7E,0x00,0x1E,0x00,	/* 44B0: .C.`~... */
	0x20,0x4D,0xD1,0xC7,0x11,0x43,0x01,0x60,	/* 44B8:  M.C.` */
	0x20,0x07,0x52,0x80,0x7E,0x00,0x1E,0x00,	/* 44C0:  .R~... */
	0x7C,0x01,0x4A,0x86,0x66,0x2C,0x20,0x07,	/* 44C8: |.Jf, . */
	0x12,0x2E,0xFF,0xF6,0x90,0x81,0x72,0x00,	/* 44D0: ..r. */
	0x12,0x00,0xB2,0xBC,0x00,0x00,0x00,0xFE,	/* 44D8: ..... */
	0x6C,0x18,0x20,0x4D,0x20,0x07,0xD1,0xC7,	/* 44E0: l. M . */
	0x52,0x80,0x11,0x45,0x01,0x60,0x7E,0x00,	/* 44E8: R.E.`~. */
	0x1E,0x00,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 44F0: ..p.3.. */
	0x62,0xAA,0x20,0x49,0xD1,0xFC,0x04,0x01,	/* 44F8: b I.. */
	0xF0,0x02,0x16,0x10,0xC6,0xBC,0x00,0x00,	/* 4500: ..... */
	0x00,0xFF,0x30,0x03,0xC0,0xBC,0x00,0x00,	/* 4508: .0... */
	0x00,0x01,0x66,0x00,0xFE,0x20,0x70,0x00,	/* 4510: ..f. p. */
	0x10,0x2E,0xFF,0xF7,0xB0,0xBC,0x00,0x00,	/* 4518: .... */
	0x00,0xC0,0x6C,0x52,0x20,0x07,0x12,0x2E,	/* 4520: .lR ... */
	0xFF,0xF6,0x90,0x81,0x72,0x00,0x12,0x00,	/* 4528: r... */
	0xB2,0xBC,0x00,0x00,0x00,0xC0,0x6D,0x3E,	/* 4530: ...m> */
	0x30,0x04,0xC0,0xBC,0x00,0x00,0x00,0x08,	/* 4538: 0..... */
	0x67,0x34,0x08,0x2D,0x00,0x03,0x00,0x30,	/* 4540: g4.-...0 */
	0x67,0x18,0x30,0x04,0xC0,0xBC,0x00,0x00,	/* 4548: g.0... */
	0x00,0x20,0x66,0x08,0x88,0xBC,0x00,0x00,	/* 4550: . f... */
	0x00,0xD0,0x60,0x06,0xC8,0xBC,0x00,0x00,	/* 4558: .`... */
	0xFF,0xBF,0x08,0x2D,0x00,0x07,0x00,0x31,	/* 4560: .-...1 */
	0x67,0x0C,0xD3,0xCC,0x70,0x90,0x12,0x80,	/* 4568: g.p. */
	0x88,0xBC,0x00,0x00,0x00,0x10,0x1B,0x47,	/* 4570: .....G */
	0x00,0x0A,0x36,0x84,0x4C,0xD7,0x38,0xFC,	/* 4578: ..6L8 */
	0x4F,0xEF,0x00,0x24,0x4E,0x5E,0x4E,0x75,	/* 4580: O.$N^Nu */
	0x4E,0x56,0xFF,0xF8,0x4F,0xEF,0xFF,0xDC,	/* 4588: NVO */
	0x48,0xD7,0x3C,0xF8,0x2A,0x7C,0x01,0x01,	/* 4590: H<*|.. */
	0x81,0x80,0x2C,0x3C,0x01,0x01,0x80,0x00,	/* 4598: ,<... */
	0x24,0x7C,0x00,0x00,0x64,0x08,0x26,0x7C,	/* 45A0: $|..d.&| */
	0x00,0x00,0x62,0xA0,0x4A,0x13,0x67,0x06,	/* 45A8: ..bJ.g. */
	0x4E,0xB9,0x00,0x00,0x0E,0x5C,0x49,0xED,	/* 45B0: N...\I */
	0x00,0x2E,0x70,0x00,0x7E,0x00,0x10,0x2C,	/* 45B8: ..p.~.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 45C0: ....r. */
	0x32,0x00,0x2A,0x41,0x70,0x00,0xDB,0xC6,	/* 45C8: 2.*Ap. */
	0x10,0x2D,0x00,0x0E,0x3E,0x00,0x4A,0x87,	/* 45D0: .-..>.J */
	0x67,0x12,0x20,0x72,0x7C,0x00,0x2F,0x0D,	/* 45D8: g. r|... */
	0x4E,0x90,0x58,0x8F,0x72,0x00,0x32,0x00,	/* 45E0: NXr.2. */
	0x4A,0x81,0x67,0xC0,0x49,0xED,0x00,0x02,	/* 45E8: JgI.. */
	0x70,0x00,0x7C,0x00,0x10,0x2C,0x00,0x01,	/* 45F0: p.|..,.. */
	0xE1,0x88,0x10,0x14,0x3C,0x00,0x20,0x06,	/* 45F8: ..<. . */
	0xC0,0xBC,0x00,0x00,0x10,0x00,0x67,0x00,	/* 4600: ....g. */
	0x01,0x2E,0x20,0x46,0xD1,0xFC,0x04,0x01,	/* 4608: .. F.. */
	0xF0,0x02,0x1E,0x10,0xCE,0xBC,0x00,0x00,	/* 4610: ..... */
	0x00,0xFF,0x30,0x07,0xC0,0xBC,0x00,0x00,	/* 4618: .0... */
	0x00,0x04,0x67,0x00,0x00,0xD0,0x18,0x2D,	/* 4620: ..g...- */
	0x00,0x0D,0x1A,0x2D,0x00,0x0C,0x72,0x00,	/* 4628: ...-..r. */
	0x10,0x04,0x90,0x85,0x12,0x00,0x4A,0x81,	/* 4630: ....J */
	0x67,0x00,0x00,0x98,0x20,0x46,0xCA,0xBC,	/* 4638: g.. F */
	0x00,0x00,0x00,0xFF,0x49,0xED,0x00,0x08,	/* 4640: ...I.. */
	0xD1,0xFC,0x04,0x01,0xF0,0x06,0x10,0x35,	/* 4648: ....5 */
	0x58,0x60,0x10,0x80,0x70,0x01,0x1B,0x40,	/* 4650: X`.p..@ */
	0x00,0x44,0x52,0x85,0x1B,0x45,0x00,0x0C,	/* 4658: .DR.E.. */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 4660: p..,.. */
	0x10,0x14,0xC0,0xBC,0x00,0x00,0x08,0x00,	/* 4668: ...... */
	0x67,0x2E,0x70,0x40,0xB0,0x81,0x6D,0x52,	/* 4670: g.p@mR */
	0x49,0xED,0x00,0x08,0x7C,0x00,0x1C,0x2C,	/* 4678: I..|.., */
	0x00,0x01,0xE1,0x8E,0x1C,0x14,0xCC,0xBC,	/* 4680: .... */
	0x00,0x00,0xF7,0xFF,0x20,0x06,0xE0,0x80,	/* 4688: .. . */
	0x19,0x40,0x00,0x01,0x18,0x86,0x70,0x01,	/* 4690: .@...p. */
	0x33,0xC0,0x00,0x00,0x62,0xA8,0x60,0x2A,	/* 4698: 3..b`* */
	0xB2,0xBC,0x00,0x00,0x00,0xC0,0x6D,0x22,	/* 46A0: ...m" */
	0x49,0xED,0x00,0x08,0x70,0x00,0x7C,0x00,	/* 46A8: I..p.|. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 46B0: .,.... */
	0x80,0xBC,0x00,0x00,0x08,0x00,0x3C,0x00,	/* 46B8: ....<. */
	0x20,0x06,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 46C0:  ..@.. */
	0x18,0x86,0x08,0xED,0x00,0x00,0x00,0x41,	/* 46C8: .....A */
	0x60,0x22,0x1C,0x2D,0x00,0x41,0x08,0x06,	/* 46D0: `".-.A.. */
	0x00,0x00,0x67,0x14,0x70,0x01,0x33,0xC0,	/* 46D8: ..g.p.3 */
	0x00,0x00,0x62,0xA8,0x10,0x06,0xC0,0xBC,	/* 46E0: ..b.. */
	0x00,0x00,0x00,0xFE,0x1B,0x40,0x00,0x41,	/* 46E8: ....@.A */
	0x42,0x2D,0x00,0x44,0x30,0x07,0xC0,0xBC,	/* 46F0: B-.D0. */
	0x00,0x00,0x00,0x01,0x67,0x00,0xFE,0x9C,	/* 46F8: ....g. */
	0x49,0xED,0x00,0x08,0x70,0x00,0x10,0x2C,	/* 4700: I..p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x3D,0x40,	/* 4708: ....=@ */
	0xFF,0xFC,0x48,0x6E,0xFF,0xFC,0x2F,0x07,	/* 4710: Hn.. */
	0x2F,0x0D,0x61,0x00,0xFB,0xCC,0x7C,0x00,	/* 4718: ..a.|. */
	0x3C,0x2E,0xFF,0xFC,0x20,0x06,0xE0,0x80,	/* 4720: <. . */
	0x19,0x40,0x00,0x01,0x4F,0xEF,0x00,0x0C,	/* 4728: .@..O.. */
	0x18,0x86,0x60,0x00,0xFE,0x66,0x49,0xED,	/* 4730: .`.fI */
	0x00,0x08,0x7E,0x00,0x20,0x46,0xD1,0xFC,	/* 4738: ..~. F */
	0x04,0x01,0xF0,0x02,0x1E,0x2C,0x00,0x01,	/* 4740: ....,.. */
	0xE1,0x8F,0x1E,0x14,0x12,0x10,0xC2,0xBC,	/* 4748: .... */
	0x00,0x00,0x00,0xFF,0x30,0x01,0xC0,0xBC,	/* 4750: ...0. */
	0x00,0x00,0x00,0x04,0x67,0x00,0x01,0x82,	/* 4758: ....g.. */
	0x30,0x07,0xC0,0xBC,0x00,0x00,0x00,0x40,	/* 4760: 0....@ */
	0x67,0x4C,0x30,0x07,0xC0,0xBC,0x00,0x00,	/* 4768: gL0... */
	0x00,0x80,0x67,0x24,0x20,0x46,0x10,0x2D,	/* 4770: .g$ F.- */
	0x00,0x13,0x8E,0xBC,0x00,0x00,0x00,0x20,	/* 4778: .....  */
	0xD1,0xFC,0x04,0x01,0xF0,0x06,0x10,0x80,	/* 4780: .... */
	0x70,0x01,0x1B,0x40,0x00,0x44,0xCE,0xBC,	/* 4788: p..@.D */
	0x00,0x00,0xFF,0x3F,0x60,0x00,0x01,0x4A,	/* 4790: ..?`..J */
	0x20,0x46,0x10,0x2D,0x00,0x12,0xD1,0xFC,	/* 4798:  F.-.. */
	0x04,0x01,0xF0,0x06,0x10,0x80,0x70,0x01,	/* 47A0: ....p. */
	0x1B,0x40,0x00,0x44,0xCE,0xBC,0x00,0x00,	/* 47A8: .@.D.. */
	0xFF,0x8F,0x60,0x00,0x01,0x2C,0x30,0x07,	/* 47B0: `..,0. */
	0xC0,0xBC,0x00,0x00,0x00,0x04,0x66,0x00,	/* 47B8: ....f. */
	0x01,0x20,0x16,0x2D,0x00,0x0D,0x1A,0x2D,	/* 47C0: . .-...- */
	0x00,0x0C,0x78,0x00,0x10,0x03,0x90,0x85,	/* 47C8: ..x... */
	0x18,0x00,0x4A,0x84,0x67,0x00,0x00,0xE8,	/* 47D0: ..Jg.. */
	0xCA,0xBC,0x00,0x00,0x00,0xFF,0x76,0x00,	/* 47D8: ...v. */
	0x16,0x35,0x58,0x60,0x70,0x0A,0xB0,0x83,	/* 47E0: .5X`p. */
	0x66,0x48,0x30,0x07,0xC0,0xBC,0x00,0x00,	/* 47E8: fH0... */
	0x04,0x00,0x67,0x3E,0x30,0x07,0xC0,0xBC,	/* 47F0: ..g>0. */
	0x00,0x00,0x01,0x00,0x67,0x1A,0x20,0x46,	/* 47F8: ....g. F */
	0x70,0x01,0xD1,0xFC,0x04,0x01,0xF0,0x06,	/* 4800: p.... */
	0x10,0x83,0xCE,0xBC,0x00,0x00,0xFE,0xFF,	/* 4808: ... */
	0x1B,0x40,0x00,0x44,0x52,0x85,0x60,0x2C,	/* 4810: .@.DR`, */
	0x20,0x46,0x70,0x0D,0xD1,0xFC,0x04,0x01,	/* 4818:  Fp... */
	0xF0,0x06,0x10,0x80,0x70,0x01,0x1B,0x40,	/* 4820: ..p..@ */
	0x00,0x44,0x8E,0xBC,0x00,0x00,0x01,0x00,	/* 4828: .D.... */
	0x60,0x12,0x20,0x46,0xD1,0xFC,0x04,0x01,	/* 4830: `. F.. */
	0xF0,0x06,0x10,0x83,0x70,0x01,0x1B,0x40,	/* 4838: ..p..@ */
	0x00,0x44,0x52,0x85,0x1B,0x45,0x00,0x0C,	/* 4840: .DR.E.. */
	0x49,0xED,0x00,0x08,0x70,0x00,0x10,0x2C,	/* 4848: I..p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0xC0,0xBC,	/* 4850: .... */
	0x00,0x00,0x08,0x00,0x67,0x2E,0x70,0x40,	/* 4858: ....g.p@ */
	0xB0,0x84,0x6D,0x52,0x49,0xED,0x00,0x08,	/* 4860: mRI.. */
	0x78,0x00,0x18,0x2C,0x00,0x01,0xE1,0x8C,	/* 4868: x..,.. */
	0x18,0x14,0xC8,0xBC,0x00,0x00,0xF7,0xFF,	/* 4870: .... */
	0x20,0x04,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 4878:  ..@.. */
	0x18,0x84,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 4880: .p.3.. */
	0x62,0xA8,0x60,0x2A,0xB8,0xBC,0x00,0x00,	/* 4888: b`*.. */
	0x00,0xC0,0x6D,0x22,0x49,0xED,0x00,0x08,	/* 4890: .m"I.. */
	0x70,0x00,0x78,0x00,0x10,0x2C,0x00,0x01,	/* 4898: p.x..,.. */
	0xE1,0x88,0x10,0x14,0x80,0xBC,0x00,0x00,	/* 48A0: .... */
	0x08,0x00,0x38,0x00,0x20,0x04,0xE0,0x80,	/* 48A8: ..8. . */
	0x19,0x40,0x00,0x01,0x18,0x84,0x08,0xED,	/* 48B0: .@.... */
	0x00,0x00,0x00,0x41,0x60,0x22,0x18,0x2D,	/* 48B8: ...A`".- */
	0x00,0x41,0x08,0x04,0x00,0x00,0x67,0x14,	/* 48C0: .A....g. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x62,0xA8,	/* 48C8: p.3..b */
	0x10,0x04,0xC0,0xBC,0x00,0x00,0x00,0xFE,	/* 48D0: ..... */
	0x1B,0x40,0x00,0x41,0x42,0x2D,0x00,0x44,	/* 48D8: .@.AB-.D */
	0x30,0x01,0xC0,0xBC,0x00,0x00,0x00,0x01,	/* 48E0: 0..... */
	0x67,0x18,0x3D,0x47,0xFF,0xFE,0x48,0x6E,	/* 48E8: g.=GHn */
	0xFF,0xFE,0x2F,0x01,0x2F,0x0D,0x61,0x00,	/* 48F0: ....a. */
	0xF9,0xF0,0x3E,0x2E,0xFF,0xFE,0x4F,0xEF,	/* 48F8: >.O */
	0x00,0x0C,0x30,0x07,0xC0,0xBC,0x00,0x00,	/* 4900: ..0... */
	0x00,0x10,0x67,0x4E,0x10,0x2D,0x00,0x0A,	/* 4908: ..gN.-.. */
	0x12,0x2D,0x00,0x0B,0x90,0x81,0x72,0x00,	/* 4910: .-..r. */
	0x12,0x00,0x70,0x40,0xB0,0x81,0x6F,0x3A,	/* 4918: ..p@o: */
	0x30,0x07,0xC0,0xBC,0x00,0x00,0x00,0x80,	/* 4920: 0.... */
	0x67,0x06,0xCE,0xBC,0x00,0x00,0xFF,0x3F,	/* 4928: g...? */
	0x30,0x07,0xC0,0xBC,0x00,0x00,0x00,0x20,	/* 4930: 0....  */
	0x67,0x06,0x8E,0xBC,0x00,0x00,0x00,0x40,	/* 4938: g....@ */
	0x08,0x2D,0x00,0x07,0x00,0x31,0x67,0x0C,	/* 4940: .-...1g. */
	0x20,0x46,0xD1,0xFC,0x04,0x01,0xF0,0x04,	/* 4948:  F... */
	0x70,0x80,0x10,0x80,0xCE,0xBC,0x00,0x00,	/* 4950: p... */
	0xFF,0xEF,0x49,0xED,0x00,0x08,0xCE,0xBC,	/* 4958: I.. */
	0x00,0x00,0xFF,0xFF,0x2C,0x07,0x20,0x06,	/* 4960: ..,. . */
	0xE0,0x80,0x19,0x40,0x00,0x01,0x18,0x86,	/* 4968: .@... */
	0x60,0x00,0xFC,0x28,0x22,0x6F,0x00,0x04,	/* 4970: `.("o.. */
	0x2F,0x09,0x61,0x00,0xF8,0x90,0x58,0x8F,	/* 4978: ..a.X */
	0xC0,0xBC,0x00,0x00,0x00,0x04,0x67,0x0E,	/* 4980: ....g. */
	0x42,0x29,0x00,0x0E,0x70,0x01,0x33,0xC0,	/* 4988: B)..p.3 */
	0x00,0x00,0x62,0xA8,0x60,0x06,0x70,0x06,	/* 4990: ..b`.p. */
	0x13,0x40,0x00,0x0E,0x70,0x00,0x4E,0x75,	/* 4998: .@..p.Nu */
	0x4F,0xEF,0xFF,0xF0,0x70,0x00,0x48,0xD7,	/* 49A0: Op.H */
	0x20,0xE0,0x2A,0x6F,0x00,0x14,0x7E,0x00,	/* 49A8:  *o..~. */
	0x7A,0x00,0x41,0xED,0x00,0x02,0x10,0x28,	/* 49B0: z.A...( */
	0x00,0x01,0xE1,0x88,0x10,0x10,0x41,0xED,	/* 49B8: ....A */
	0x00,0x08,0x3E,0x00,0x1A,0x28,0x00,0x01,	/* 49C0: ..>..(.. */
	0xE1,0x8D,0x1A,0x10,0x4A,0x2D,0x00,0x1F,	/* 49C8: ..J-.. */
	0x67,0x04,0x42,0x2D,0x00,0x1F,0x70,0x00,	/* 49D0: g.B-..p. */
	0x10,0x2D,0x00,0x0E,0x51,0x80,0x66,0x2A,	/* 49D8: .-..Qf* */
	0x10,0x2D,0x00,0x14,0x12,0x2D,0x00,0x31,	/* 49E0: .-...-.1 */
	0x90,0x81,0x4A,0x00,0x66,0x1C,0x10,0x2D,	/* 49E8: J.f..- */
	0x00,0x15,0x12,0x2D,0x00,0x32,0x90,0x81,	/* 49F0: ...-.2 */
	0x4A,0x00,0x66,0x0E,0x10,0x2D,0x00,0x16,	/* 49F8: J.f..-.. */
	0x12,0x2D,0x00,0x2D,0x90,0x81,0x4A,0x00,	/* 4A00: .-.-J. */
	0x67,0x50,0x2C,0x3C,0x04,0x01,0xF0,0x04,	/* 4A08: gP,<... */
	0x20,0x47,0x70,0x1A,0xD1,0xC6,0x10,0x80,	/* 4A10:  Gp.. */
	0x22,0x3C,0x04,0x01,0xF0,0x00,0x20,0x47,	/* 4A18: "<... G */
	0xD1,0xC1,0x10,0x2D,0x00,0x14,0x10,0x80,	/* 4A20: .-... */
	0x20,0x47,0x10,0x2D,0x00,0x15,0xD1,0xC1,	/* 4A28:  G.-.. */
	0x10,0x80,0x20,0x47,0x10,0x2D,0x00,0x16,	/* 4A30: . G.-.. */
	0xD1,0xFC,0x04,0x01,0xF0,0x02,0x10,0x80,	/* 4A38: .... */
	0x1B,0x6D,0x00,0x14,0x00,0x31,0x20,0x47,	/* 4A40: .m...1 G */
	0x70,0x05,0x1B,0x6D,0x00,0x15,0x00,0x32,	/* 4A48: p..m...2 */
	0x1B,0x6D,0x00,0x16,0x00,0x2D,0xD1,0xC6,	/* 4A50: .m...- */
	0x10,0x80,0x08,0x2D,0x00,0x00,0x00,0x17,	/* 4A58: ..-.... */
	0x67,0x16,0x08,0x2D,0x00,0x07,0x00,0x14,	/* 4A60: g..-.... */
	0x66,0x0E,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 4A68: f. G.. */
	0xF0,0x04,0x70,0x80,0x10,0x80,0x60,0x0C,	/* 4A70: .p.`. */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x04,	/* 4A78:  G... */
	0x70,0x90,0x10,0x80,0x08,0x2D,0x00,0x01,	/* 4A80: p..-.. */
	0x00,0x17,0x67,0x0E,0x48,0x78,0x00,0x01,	/* 4A88: ..g.Hx.. */
	0x2F,0x0D,0x61,0x00,0xF7,0xD4,0x50,0x8F,	/* 4A90: ..a.P */
	0x60,0x0A,0x42,0xA7,0x2F,0x0D,0x61,0x00,	/* 4A98: `.B..a. */
	0xF7,0xC8,0x50,0x8F,0x42,0x2D,0x00,0x19,	/* 4AA0: PB-.. */
	0x1B,0x6D,0x00,0x1B,0x00,0x10,0x1B,0x6D,	/* 4AA8: .m.....m */
	0x00,0x1D,0x00,0x12,0x1B,0x6D,0x00,0x1C,	/* 4AB0: .....m.. */
	0x00,0x11,0x1B,0x6D,0x00,0x1E,0x00,0x13,	/* 4AB8: ...m.... */
	0x1B,0x6D,0x00,0x20,0x00,0x21,0x1B,0x6D,	/* 4AC0: .m. .!.m */
	0x00,0x22,0x00,0x23,0x1C,0x2D,0x00,0x1A,	/* 4AC8: .".#.-.. */
	0x1B,0x46,0x00,0x30,0x70,0x01,0x1B,0x40,	/* 4AD0: .F.0p..@ */
	0x00,0x42,0x3E,0x05,0x42,0x2D,0x00,0x43,	/* 4AD8: .B>.B-.C */
	0xCE,0xBC,0x00,0x00,0xFF,0xF4,0x42,0x2D,	/* 4AE0: ..B- */
	0x00,0x44,0x08,0x06,0x00,0x01,0x67,0x06,	/* 4AE8: .D....g. */
	0x8E,0xBC,0x00,0x00,0x00,0x02,0x08,0x06,	/* 4AF0: ...... */
	0x00,0x03,0x67,0x06,0x8E,0xBC,0x00,0x00,	/* 4AF8: ..g... */
	0x00,0x08,0x08,0x06,0x00,0x00,0x67,0x06,	/* 4B00: ......g. */
	0x8E,0xBC,0x00,0x00,0x00,0x01,0xCE,0xBC,	/* 4B08: .... */
	0x00,0x00,0x5B,0xFF,0x08,0x06,0x00,0x02,	/* 4B10: ..[.... */
	0x67,0x06,0x8E,0xBC,0x00,0x00,0x04,0x00,	/* 4B18: g..... */
	0x08,0x06,0x00,0x05,0x67,0x06,0x8E,0xBC,	/* 4B20: ....g. */
	0x00,0x00,0x20,0x00,0x08,0x06,0x00,0x07,	/* 4B28: .. ..... */
	0x67,0x06,0x8E,0xBC,0x00,0x00,0x80,0x00,	/* 4B30: g.... */
	0x08,0x2D,0x00,0x07,0x00,0x14,0x67,0x06,	/* 4B38: .-....g. */
	0x8E,0xBC,0x00,0x00,0x00,0x08,0x08,0x06,	/* 4B40: ...... */
	0x00,0x06,0x67,0x06,0x8E,0xBC,0x00,0x00,	/* 4B48: ..g... */
	0x00,0x08,0x30,0x05,0xC0,0xBC,0x00,0x00,	/* 4B50: ..0... */
	0x04,0x00,0x67,0x10,0x30,0x07,0xC0,0xBC,	/* 4B58: ..g.0. */
	0x00,0x00,0x04,0x00,0x66,0x06,0xCE,0xBC,	/* 4B60: ....f. */
	0x00,0x00,0xFE,0xFF,0x30,0x05,0xC0,0xBC,	/* 4B68: ..0. */
	0x00,0x00,0x00,0x02,0x67,0x10,0x30,0x07,	/* 4B70: ....g.0. */
	0xC0,0xBC,0x00,0x00,0x00,0x02,0x66,0x06,	/* 4B78: ....f. */
	0xCE,0xBC,0x00,0x00,0xFF,0xFB,0x08,0x2D,	/* 4B80: ...- */
	0x00,0x07,0x00,0x31,0x67,0x06,0x8E,0xBC,	/* 4B88: ...1g. */
	0x00,0x00,0x00,0x08,0x30,0x07,0xC0,0xBC,	/* 4B90: ....0. */
	0x00,0x00,0x20,0x00,0x67,0x10,0x2F,0x0D,	/* 4B98: .. .g... */
	0x61,0x00,0xF6,0x6A,0x2A,0x00,0x1B,0x45,	/* 4BA0: a.j*..E */
	0x00,0x18,0x58,0x8F,0x60,0x06,0x70,0x24,	/* 4BA8: ..X`.p$ */
	0x1B,0x40,0x00,0x18,0x70,0x00,0x10,0x2D,	/* 4BB0: .@..p..- */
	0x00,0x0E,0x59,0x80,0x66,0x0A,0x2F,0x0D,	/* 4BB8: ..Yf... */
	0x61,0x00,0xFD,0xB2,0x58,0x8F,0x60,0x04,	/* 4BC0: a.X`. */
	0x42,0x2D,0x00,0x0E,0x41,0xED,0x00,0x08,	/* 4BC8: B-..A.. */
	0xCE,0xBC,0x00,0x00,0xFF,0xFF,0x2A,0x07,	/* 4BD0: ..*. */
	0x20,0x05,0xE0,0x80,0x11,0x40,0x00,0x01,	/* 4BD8:  ..@.. */
	0x10,0x85,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 4BE0: .p.3.. */
	0x62,0xA8,0x4C,0xD7,0x20,0xE0,0x70,0x00,	/* 4BE8: bL p. */
	0x4F,0xEF,0x00,0x10,0x4E,0x75,0x4E,0x71,	/* 4BF0: O..NuNq */
	0x22,0x6F,0x00,0x04,0x70,0x00,0x41,0xE9,	/* 4BF8: "o..p.A */
	0x00,0x02,0x10,0x28,0x00,0x01,0xE1,0x88,	/* 4C00: ...(.. */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0xFF,0xFF,	/* 4C08: .... */
	0x20,0x40,0xD1,0xFC,0x04,0x01,0xF0,0x04,	/* 4C10:  @... */
	0x70,0x60,0x10,0x80,0x70,0x12,0x13,0x40,	/* 4C18: p`.p..@ */
	0x00,0x0E,0x70,0x00,0x4E,0x75,0x4E,0x71,	/* 4C20: ..p.NuNq */
	0x22,0x6F,0x00,0x04,0x70,0x00,0x41,0xE9,	/* 4C28: "o..p.A */
	0x00,0x02,0x10,0x28,0x00,0x01,0xE1,0x88,	/* 4C30: ...(.. */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0xFF,0xFF,	/* 4C38: .... */
	0x20,0x40,0xD1,0xFC,0x04,0x01,0xF0,0x04,	/* 4C40:  @... */
	0x70,0x75,0x10,0x80,0x42,0x29,0x00,0x0E,	/* 4C48: pu.B).. */
	0x70,0x00,0x4E,0x75,0x70,0x00,0x4E,0x75,	/* 4C50: p.Nup.Nu */
	0x70,0x00,0x4E,0x75,0x2F,0x0D,0x70,0x00,	/* 4C58: p.Nu..p. */
	0x2F,0x07,0x2A,0x6F,0x00,0x0C,0x41,0xED,	/* 4C60: ..*o..A */
	0x00,0x02,0x10,0x28,0x00,0x01,0xE1,0x88,	/* 4C68: ...(.. */
	0x10,0x10,0x42,0x2D,0x00,0x0C,0x42,0x2D,	/* 4C70: ..B-..B- */
	0x00,0x0D,0x7E,0x00,0x42,0x2D,0x00,0x0B,	/* 4C78: ..~.B-.. */
	0x3E,0x00,0x42,0x2D,0x00,0x0A,0x08,0x2D,	/* 4C80: >.B-...- */
	0x00,0x04,0x00,0x32,0x67,0x14,0x20,0x47,	/* 4C88: ...2g. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x00,0x10,0x2D,	/* 4C90: ....- */
	0x00,0x32,0xC0,0xBC,0x00,0x00,0x00,0xEF,	/* 4C98: .2... */
	0x10,0x80,0x20,0x47,0xD1,0xFC,0x04,0x01,	/* 4CA0: . G.. */
	0xF0,0x02,0x10,0x10,0x08,0x00,0x00,0x03,	/* 4CA8: ....... */
	0x66,0x04,0x70,0x00,0x60,0x5C,0x08,0x2D,	/* 4CB0: f.p.`\.- */
	0x00,0x00,0x00,0x17,0x66,0x0C,0x20,0x47,	/* 4CB8: ....f. G */
	0xD1,0xFC,0x04,0x01,0xF0,0x04,0x70,0x90,	/* 4CC0: ...p */
	0x10,0x80,0x08,0x2D,0x00,0x01,0x00,0x17,	/* 4CC8: ..-.... */
	0x66,0x0A,0x42,0xA7,0x2F,0x0D,0x61,0x00,	/* 4CD0: f.B..a. */
	0xF5,0x90,0x50,0x8F,0x41,0xED,0x00,0x08,	/* 4CD8: PA.. */
	0x42,0x28,0x00,0x01,0x70,0x30,0x42,0x10,	/* 4CE0: B(..p0B. */
	0x22,0x3C,0x04,0x01,0xF0,0x04,0x20,0x47,	/* 4CE8: "<... G */
	0xD1,0xC1,0x10,0x80,0x20,0x47,0x70,0x20,	/* 4CF0: . Gp  */
	0xD1,0xC1,0x10,0x80,0x70,0x01,0x1B,0x40,	/* 4CF8: .p..@ */
	0x00,0x1F,0x70,0x10,0x1B,0x40,0x00,0x0E,	/* 4D00: ..p..@.. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x62,0xA8,	/* 4D08: p.3..b */
	0x70,0x00,0x2E,0x1F,0x2A,0x5F,0x4E,0x75,	/* 4D10: p...*_Nu */
	0x2F,0x07,0x7E,0x00,0x22,0x6F,0x00,0x08,	/* 4D18: ..~."o.. */
	0x41,0xE9,0x00,0x02,0x10,0x29,0x00,0x0D,	/* 4D20: A...).. */
	0x1E,0x28,0x00,0x01,0xE1,0x8F,0x1E,0x10,	/* 4D28: .(.... */
	0x12,0x29,0x00,0x0C,0x90,0x81,0x4A,0x00,	/* 4D30: .)..J. */
	0x66,0x1A,0xCE,0xBC,0x00,0x00,0xFF,0xFF,	/* 4D38: f... */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0x00,	/* 4D40:  G... */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 4D48: ..... */
	0x4A,0x00,0x66,0x04,0x70,0x01,0x60,0x0A,	/* 4D50: J.f.p.`. */
	0x2F,0x09,0x61,0x00,0xFF,0x00,0x70,0x00,	/* 4D58: ..a..p. */
	0x58,0x8F,0x2E,0x1F,0x4E,0x75,0x4E,0x71,	/* 4D60: X..NuNq */
	0x20,0x6F,0x00,0x04,0x70,0x00,0x72,0x00,	/* 4D68:  o..p.r. */
	0x43,0xE8,0x00,0x08,0x10,0x29,0x00,0x01,	/* 4D70: C...).. */
	0xE1,0x88,0x10,0x11,0x32,0x00,0x70,0x06,	/* 4D78: ..2.p. */
	0xC0,0x81,0x5D,0x80,0x66,0x1E,0x43,0xE8,	/* 4D80: ]f.C */
	0x00,0x08,0x72,0x00,0x12,0x29,0x00,0x01,	/* 4D88: ..r..).. */
	0xE1,0x89,0x12,0x11,0xC2,0xBC,0x00,0x00,	/* 4D90: .... */
	0xFF,0xFB,0x20,0x01,0xE0,0x80,0x13,0x40,	/* 4D98:  ..@ */
	0x00,0x01,0x12,0x81,0x42,0x28,0x00,0x0E,	/* 4DA0: ...B(.. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x62,0xA8,	/* 4DA8: p.3..b */
	0x70,0x00,0x4E,0x75,0x2F,0x07,0x70,0x00,	/* 4DB0: p.Nu..p. */
	0x7E,0x00,0x22,0x6F,0x00,0x08,0x41,0xE9,	/* 4DB8: ~."o..A */
	0x00,0x02,0x10,0x28,0x00,0x01,0xE1,0x88,	/* 4DC0: ...(.. */
	0x10,0x10,0x13,0x69,0x00,0x0D,0x00,0x0C,	/* 4DC8: ...i.... */
	0x41,0xE9,0x00,0x08,0x72,0x00,0x3E,0x00,	/* 4DD0: A..r.>. */
	0x12,0x28,0x00,0x01,0xE1,0x89,0x12,0x10,	/* 4DD8: .(.... */
	0xC2,0xBC,0x00,0x00,0xF7,0xFF,0x20,0x01,	/* 4DE0: .. . */
	0xE0,0x80,0x11,0x40,0x00,0x01,0x10,0x81,	/* 4DE8: .@... */
	0x08,0x29,0x00,0x04,0x00,0x32,0x67,0x26,	/* 4DF0: .)...2g& */
	0x2F,0x09,0x61,0x00,0xF4,0x10,0x58,0x8F,	/* 4DF8: ..a..X */
	0xC0,0xBC,0x00,0x00,0x00,0x02,0x66,0x16,	/* 4E00: ....f. */
	0x22,0x3C,0x04,0x01,0xF0,0x04,0x20,0x47,	/* 4E08: "<... G */
	0x70,0x30,0xD1,0xC1,0x10,0x80,0x20,0x47,	/* 4E10: p0. G */
	0x70,0x04,0xD1,0xC1,0x10,0x80,0x2F,0x09,	/* 4E18: p.... */
	0x61,0x00,0xFF,0x46,0x70,0x00,0x58,0x8F,	/* 4E20: a.Fp.X */
	0x2E,0x1F,0x4E,0x75,0x20,0x6F,0x00,0x04,	/* 4E28: ..Nu o.. */
	0x11,0x68,0x00,0x0B,0x00,0x0A,0x42,0x28,	/* 4E30: .h....B( */
	0x00,0x0E,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 4E38: ..p.3.. */
	0x62,0xA8,0x70,0x00,0x4E,0x75,0x4E,0x71,	/* 4E40: bp.NuNq */
	0x20,0x6F,0x00,0x04,0x70,0x00,0x43,0xE8,	/* 4E48:  o..p.C */
	0x00,0x08,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 4E50: ...).. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0x02,	/* 4E58: ...... */
	0x67,0x22,0x43,0xE8,0x00,0x08,0x70,0x00,	/* 4E60: g"C..p. */
	0x72,0x00,0x10,0x29,0x00,0x01,0xE1,0x88,	/* 4E68: r..).. */
	0x10,0x11,0x80,0xBC,0x00,0x00,0x00,0x04,	/* 4E70: ...... */
	0x32,0x00,0x20,0x01,0xE0,0x80,0x13,0x40,	/* 4E78: 2. ..@ */
	0x00,0x01,0x12,0x81,0x42,0x28,0x00,0x0E,	/* 4E80: ...B(.. */
	0x70,0x01,0x33,0xC0,0x00,0x00,0x62,0xA8,	/* 4E88: p.3..b */
	0x70,0x00,0x4E,0x75,0x20,0x6F,0x00,0x04,	/* 4E90: p.Nu o.. */
	0x42,0x28,0x00,0x0E,0x70,0x00,0x4E,0x75,	/* 4E98: B(..p.Nu */
	0x4F,0xEF,0xFF,0xF4,0x70,0x00,0x48,0xD7,	/* 4EA0: Op.H */
	0x20,0xC0,0x2A,0x6F,0x00,0x10,0x7E,0x00,	/* 4EA8:  *o..~. */
	0x41,0xED,0x00,0x04,0x10,0x28,0x00,0x01,	/* 4EB0: A...(.. */
	0xE1,0x88,0x10,0x10,0x72,0x00,0x32,0x00,	/* 4EB8: ..r.2. */
	0xC2,0xBC,0xFF,0xFF,0x7F,0xFF,0x70,0x00,	/* 4EC0: p. */
	0x20,0x41,0x5C,0x88,0x10,0x28,0x00,0x01,	/* 4EC8:  A\.(.. */
	0xE1,0x88,0x10,0x10,0x3E,0x00,0x70,0x00,	/* 4ED0: ..>.p. */
	0x10,0x2D,0x00,0x35,0x53,0x80,0x67,0x14,	/* 4ED8: .-.5Sg. */
	0x53,0x80,0x67,0x60,0x55,0x80,0x67,0x00,	/* 4EE0: Sg`Ug. */
	0x00,0xC6,0x53,0x80,0x67,0x00,0x01,0x10,	/* 4EE8: .Sg... */
	0x60,0x00,0x01,0x5A,0x2C,0x3C,0x04,0x01,	/* 4EF0: `..Z,<.. */
	0xF0,0x0A,0x20,0x47,0xD1,0xC6,0x10,0x10,	/* 4EF8: . G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x4A,0x00,	/* 4F00: ...J. */
	0x66,0x00,0x01,0x42,0x22,0x3C,0x04,0x01,	/* 4F08: f..B"<.. */
	0xF0,0x12,0x20,0x47,0xD1,0xC1,0x10,0x10,	/* 4F10: . G.. */
	0x08,0x00,0x00,0x05,0x66,0x20,0x20,0x47,	/* 4F18: ....f  G */
	0x22,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 4F20: "G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x80,0xBC,	/* 4F28: ... */
	0x00,0x00,0x00,0x20,0x10,0x80,0x20,0x47,	/* 4F30: ... . G */
	0x70,0x4E,0xD1,0xC6,0x10,0x80,0x70,0x02,	/* 4F38: pN.p. */
	0x1B,0x40,0x00,0x35,0x20,0x47,0xD1,0xFC,	/* 4F40: .@.5 G */
	0x04,0x01,0xF0,0x0A,0x10,0x10,0xC0,0xBC,	/* 4F48: ..... */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x66,0x00,	/* 4F50: ...J.f. */
	0x00,0xF4,0x2C,0x3C,0x04,0x01,0xF0,0xC6,	/* 4F58: .,<.. */
	0x20,0x47,0x70,0x81,0xD1,0xC6,0x42,0x10,	/* 4F60:  GpB. */
	0x20,0x47,0xD1,0xC6,0x10,0x80,0x7C,0x00,	/* 4F68:  G.|. */
	0x41,0xED,0x00,0x08,0x1C,0x28,0x00,0x01,	/* 4F70: A...(.. */
	0xE1,0x8E,0x1C,0x10,0xCC,0xBC,0x00,0x00,	/* 4F78: .... */
	0xFF,0xFE,0x20,0x06,0xE0,0x80,0x11,0x40,	/* 4F80:  ..@ */
	0x00,0x01,0x22,0x47,0x10,0x86,0x2C,0x3C,	/* 4F88: .."G.,< */
	0x04,0x01,0xF0,0x0C,0x20,0x47,0xD1,0xC6,	/* 4F90: ... G */
	0xD3,0xC6,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 4F98: .... */
	0x00,0xF9,0x10,0x80,0x70,0x03,0x1B,0x40,	/* 4FA0: ..p..@ */
	0x00,0x35,0x60,0x00,0x00,0xA0,0x22,0x3C,	/* 4FA8: .5`.."< */
	0x04,0x01,0xF0,0x0A,0x20,0x47,0xD1,0xC1,	/* 4FB0: ... G */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 4FB8: ..... */
	0x4A,0x00,0x66,0x00,0x00,0x88,0x2C,0x3C,	/* 4FC0: J.f..,< */
	0x04,0x01,0xF0,0x12,0x20,0x47,0xD1,0xC6,	/* 4FC8: ... G */
	0x10,0x10,0x08,0x00,0x00,0x05,0x66,0x20,	/* 4FD0: ......f  */
	0x20,0x47,0x22,0x47,0xD1,0xC6,0xD3,0xC6,	/* 4FD8:  G"G */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 4FE0: ..... */
	0x80,0xBC,0x00,0x00,0x00,0x20,0x10,0x80,	/* 4FE8: ... . */
	0x20,0x47,0x70,0x4E,0xD1,0xC1,0x10,0x80,	/* 4FF0:  GpN. */
	0x70,0x05,0x1B,0x40,0x00,0x35,0x2C,0x3C,	/* 4FF8: p..@.5,< */
	0x04,0x01,0xF0,0x0A,0x20,0x47,0xD1,0xC6,	/* 5000: ... G */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5008: ..... */
	0x4A,0x00,0x66,0x38,0x22,0x3C,0x04,0x01,	/* 5010: J.f8"<.. */
	0xF0,0xC6,0x20,0x47,0x70,0x83,0x22,0x47,	/* 5018:  Gp"G */
	0xD1,0xC1,0x42,0x10,0x20,0x47,0xD1,0xC1,	/* 5020: B. G */
	0x10,0x80,0x22,0x3C,0x04,0x01,0xF0,0x12,	/* 5028: ."<... */
	0x20,0x47,0xD1,0xC1,0xD3,0xC1,0x10,0x11,	/* 5030:  G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xDF,0x10,0x80,	/* 5038: .... */
	0x20,0x47,0x70,0x4E,0xD1,0xC6,0x10,0x80,	/* 5040:  GpN. */
	0x42,0x2D,0x00,0x35,0x4C,0xD7,0x20,0xC0,	/* 5048: B-.5L  */
	0x4F,0xEF,0x00,0x0C,0x4E,0x75,0x4E,0x71,	/* 5050: O..NuNq */
	0x2F,0x07,0x70,0x00,0x7E,0x00,0x2F,0x06,	/* 5058: ..p.~... */
	0x22,0x6F,0x00,0x0C,0x41,0xE9,0x00,0x02,	/* 5060: "o..A.. */
	0x10,0x28,0x00,0x01,0xE1,0x88,0x10,0x10,	/* 5068: .(.... */
	0x22,0x3C,0x04,0x01,0xF0,0x0A,0x3E,0x00,	/* 5070: "<...>. */
	0x20,0x47,0xD1,0xC1,0x10,0x10,0xC0,0xBC,	/* 5078:  G.. */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x67,0x0A,	/* 5080: ...J.g. */
	0x08,0xE9,0x00,0x04,0x00,0x40,0x60,0x00,	/* 5088: ....@`. */
	0x00,0x6E,0x1C,0x29,0x00,0x40,0xCC,0xBC,	/* 5090: .n.).@ */
	0x00,0x00,0x00,0xEF,0x13,0x46,0x00,0x40,	/* 5098: ....F.@ */
	0x08,0x29,0x00,0x04,0x00,0x30,0x67,0x42,	/* 50A0: .)...0gB */
	0x20,0x47,0xD1,0xFC,0x04,0x01,0xF0,0xD8,	/* 50A8:  G.. */
	0x10,0x10,0x08,0x00,0x00,0x04,0x67,0x16,	/* 50B0: ......g. */
	0x08,0x06,0x00,0x00,0x67,0x40,0x20,0x47,	/* 50B8: ....g@ G */
	0xD1,0xC1,0x70,0x18,0x10,0x80,0x08,0xA9,	/* 50C0: p... */
	0x00,0x00,0x00,0x40,0x60,0x30,0x10,0x06,	/* 50C8: ...@`0.. */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x46,0x80,	/* 50D0: ....F */
	0x67,0x24,0x20,0x47,0xD1,0xC1,0x70,0x14,	/* 50D8: g$ Gp. */
	0x10,0x80,0x08,0xE9,0x00,0x00,0x00,0x40,	/* 50E0: .....@ */
	0x60,0x14,0x08,0x06,0x00,0x00,0x67,0x0E,	/* 50E8: `.....g. */
	0x20,0x47,0xD1,0xC1,0x70,0x18,0x10,0x80,	/* 50F0:  Gp.. */
	0x08,0xA9,0x00,0x00,0x00,0x40,0x2C,0x1F,	/* 50F8: ....@,. */
	0x2E,0x1F,0x4E,0x75,0x4E,0x56,0xFF,0xD8,	/* 5100: ..NuNV */
	0x70,0x00,0x20,0x79,0x00,0x00,0x64,0x88,	/* 5108: p. y..d */
	0x4F,0xEF,0xFF,0xD8,0x48,0xD7,0x3C,0xFC,	/* 5110: OH< */
	0x2A,0x7C,0x01,0x01,0x80,0x80,0x2D,0x40,	/* 5118: *|..-@ */
	0xFF,0xE0,0x26,0x4D,0x10,0x28,0x00,0x06,	/* 5120: &M.(.. */
	0x52,0x80,0x11,0x40,0x00,0x06,0x49,0xEB,	/* 5128: R.@..I */
	0x00,0x06,0x70,0x00,0x78,0x00,0x10,0x2C,	/* 5130: ..p.x.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x38,0x00,	/* 5138: ....8. */
	0x20,0x44,0x20,0x2E,0xFF,0xE0,0xD1,0xFC,	/* 5140:  D . */
	0x04,0x01,0xF0,0xFE,0xE5,0x88,0x10,0x80,	/* 5148: ... */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0xCE,	/* 5150:  D.. */
	0x10,0x10,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5158: ..... */
	0x3D,0x40,0xFF,0xDE,0x30,0x2E,0xFF,0xDE,	/* 5160: =@0. */
	0xC0,0xBC,0x00,0x00,0x00,0x01,0x67,0x00,	/* 5168: ....g. */
	0x09,0x14,0x20,0x44,0xD1,0xFC,0x04,0x01,	/* 5170: .. D.. */
	0xF0,0xD6,0x10,0x10,0x20,0x44,0xD1,0xFC,	/* 5178: .. D */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 5180: .... */
	0x00,0xFF,0x3D,0x40,0xFF,0xF0,0x10,0x10,	/* 5188: .=@.. */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 5190:  D.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x3D,0x40,	/* 5198: ...=@ */
	0xFF,0xF4,0x34,0x2E,0xFF,0xF0,0xC4,0xBC,	/* 51A0: 4. */
	0x00,0x00,0x00,0x03,0x10,0x82,0x20,0x44,	/* 51A8: ..... D */
	0xD1,0xFC,0x04,0x01,0xF0,0x86,0x1E,0x10,	/* 51B0: .... */
	0xCE,0xBC,0x00,0x00,0x00,0x07,0xCE,0xBC,	/* 51B8: .... */
	0x00,0x00,0xFF,0xFF,0x20,0x07,0x57,0x80,	/* 51C0: .. .W */
	0x67,0x0A,0x59,0x80,0x67,0x00,0x06,0x5E,	/* 51C8: g.Yg..^ */
	0x60,0x00,0x08,0xB2,0x70,0x00,0x22,0x2E,	/* 51D0: `..p.". */
	0xFF,0xE0,0x30,0x02,0xE5,0x89,0xD0,0x81,	/* 51D8: 0. */
	0x49,0xF3,0x0A,0x0A,0x70,0x00,0x10,0x2C,	/* 51E0: I..p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 51E8: ....r. */
	0x32,0x00,0x2A,0x41,0xDB,0xFC,0x01,0x01,	/* 51F0: 2.*A.. */
	0x80,0x00,0x4A,0x2D,0x00,0x27,0x66,0x06,	/* 51F8: .J-.'f. */
	0x08,0xED,0x00,0x00,0x00,0x28,0x7E,0x00,	/* 5200: ....(~. */
	0x70,0x00,0x49,0xED,0x00,0x08,0x74,0x00,	/* 5208: p.I..t. */
	0x20,0x44,0x1E,0x2D,0x00,0x0A,0x10,0x2D,	/* 5210:  D.-...- */
	0x00,0x0B,0xD1,0xFC,0x04,0x01,0xF0,0x1C,	/* 5218: ..... */
	0x3D,0x40,0xFF,0xFE,0x14,0x2C,0x00,0x01,	/* 5220: =@.,.. */
	0x30,0x2E,0xFF,0xFE,0xE1,0x8A,0x14,0x14,	/* 5228: 0... */
	0x32,0x07,0x52,0x81,0x90,0x81,0xC0,0xBC,	/* 5230: 2.R */
	0x00,0x00,0x00,0xFF,0x24,0x40,0x70,0x01,	/* 5238: ...$@p. */
	0x33,0xC0,0x00,0x00,0x62,0xAA,0x10,0x10,	/* 5240: 3..b.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x3D,0x40,	/* 5248: ...=@ */
	0xFF,0xFC,0x70,0x00,0x30,0x2E,0xFF,0xFC,	/* 5250: p.0. */
	0xB5,0xC0,0x6F,0x06,0x3C,0x2E,0xFF,0xFC,	/* 5258: o.<. */
	0x60,0x02,0x2C,0x0A,0xCC,0xBC,0x00,0x00,	/* 5260: `.,... */
	0xFF,0xFF,0x26,0x06,0x67,0x00,0x04,0x66,	/* 5268: &.g..f */
	0x30,0x2E,0xFF,0xFC,0x90,0x83,0x3D,0x40,	/* 5270: 0.=@ */
	0xFF,0xFC,0x20,0x03,0xB0,0xBC,0x00,0x00,	/* 5278:  ... */
	0x00,0x20,0x62,0x00,0x04,0x4C,0x20,0x7B,	/* 5280: . b..L { */
	0x0C,0x04,0x4E,0xD0,0x00,0x00,0x56,0xD0,	/* 5288: ..N..V */
	0x00,0x00,0x56,0xB2,0x00,0x00,0x56,0x94,	/* 5290: ..V..V */
	0x00,0x00,0x56,0x76,0x00,0x00,0x56,0x58,	/* 5298: ..Vv..VX */
	0x00,0x00,0x56,0x3A,0x00,0x00,0x56,0x1C,	/* 52A0: ..V:..V. */
	0x00,0x00,0x55,0xFE,0x00,0x00,0x55,0xE0,	/* 52A8: ..U..U */
	0x00,0x00,0x55,0xC2,0x00,0x00,0x55,0xA4,	/* 52B0: ..U..U */
	0x00,0x00,0x55,0x86,0x00,0x00,0x55,0x68,	/* 52B8: ..U..Uh */
	0x00,0x00,0x55,0x4A,0x00,0x00,0x55,0x2C,	/* 52C0: ..UJ..U, */
	0x00,0x00,0x55,0x0E,0x00,0x00,0x54,0xF0,	/* 52C8: ..U...T */
	0x00,0x00,0x54,0xD2,0x00,0x00,0x54,0xB4,	/* 52D0: ..T..T */
	0x00,0x00,0x54,0x96,0x00,0x00,0x54,0x78,	/* 52D8: ..T..Tx */
	0x00,0x00,0x54,0x5A,0x00,0x00,0x54,0x3C,	/* 52E0: ..TZ..T< */
	0x00,0x00,0x54,0x1E,0x00,0x00,0x54,0x00,	/* 52E8: ..T...T. */
	0x00,0x00,0x53,0xE2,0x00,0x00,0x53,0xC4,	/* 52F0: ..S..S */
	0x00,0x00,0x53,0xA6,0x00,0x00,0x53,0x88,	/* 52F8: ..S..S */
	0x00,0x00,0x53,0x6A,0x00,0x00,0x53,0x4C,	/* 5300: ..Sj..SL */
	0x00,0x00,0x53,0x2E,0x00,0x00,0x53,0x10,	/* 5308: ..S...S. */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5310:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5318: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5320: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5328: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5330: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5338: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5340: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 5348: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5350: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 5358: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 5360: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 5368: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 5370: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5378: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5380: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5388:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5390: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5398: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 53A0: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 53A8: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 53B0: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 53B8: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 53C0: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 53C8: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 53D0: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 53D8: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 53E0: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 53E8: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 53F0: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 53F8: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5400:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5408: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5410: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5418: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5420: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5428: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5430: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 5438: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5440: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 5448: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 5450: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 5458: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 5460: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5468: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5470: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5478:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5480: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5488: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5490: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5498: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 54A0: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 54A8: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 54B0: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 54B8: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 54C0: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 54C8: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 54D0: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 54D8: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 54E0: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 54E8: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 54F0:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 54F8: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5500: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5508: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5510: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5518: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5520: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 5528: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5530: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 5538: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 5540: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 5548: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 5550: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5558: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5560: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5568:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5570: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5578: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5580: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5588: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5590: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5598: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 55A0: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 55A8: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 55B0: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 55B8: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 55C0: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 55C8: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 55D0: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 55D8: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 55E0:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 55E8: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 55F0: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 55F8: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5600: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5608: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5610: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 5618: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5620: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 5628: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 5630: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 5638: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 5640: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 5648: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 5650: ..@.`R */
	0x20,0x4D,0x70,0x00,0x22,0x44,0x10,0x07,	/* 5658:  Mp."D.. */
	0xD3,0xFC,0x04,0x01,0xF0,0xC4,0xD1,0xC0,	/* 5660: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 5668: ..... */
	0x11,0x40,0x01,0x60,0x52,0x87,0x20,0x4D,	/* 5670: .@.`R M */
	0x70,0x00,0x22,0x44,0x10,0x07,0xD3,0xFC,	/* 5678: p."D.. */
	0x04,0x01,0xF0,0xC4,0xD1,0xC0,0x10,0x11,	/* 5680: .... */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x11,0x40,	/* 5688: ....@ */
	0x01,0x60,0x52,0x87,0x20,0x4D,0x70,0x00,	/* 5690: .`R Mp. */
	0x22,0x44,0x10,0x07,0xD3,0xFC,0x04,0x01,	/* 5698: "D.... */
	0xF0,0xC4,0xD1,0xC0,0x10,0x11,0xC0,0xBC,	/* 56A0: .. */
	0x00,0x00,0x00,0xFF,0x11,0x40,0x01,0x60,	/* 56A8: ....@.` */
	0x52,0x87,0x20,0x4D,0x70,0x00,0x22,0x44,	/* 56B0: R Mp."D */
	0x10,0x07,0xD3,0xFC,0x04,0x01,0xF0,0xC4,	/* 56B8: .... */
	0xD1,0xC0,0x10,0x11,0xC0,0xBC,0x00,0x00,	/* 56C0: .... */
	0x00,0xFF,0x11,0x40,0x01,0x60,0x52,0x87,	/* 56C8: ..@.`R */
	0x1B,0x47,0x00,0x0A,0x49,0xED,0x00,0x3E,	/* 56D0: .G..I.> */
	0x70,0x00,0x7C,0x00,0x10,0x2C,0x00,0x01,	/* 56D8: p.|..,.. */
	0xE1,0x88,0x10,0x14,0x32,0x2E,0xFF,0xFC,	/* 56E0: ..2. */
	0xD0,0x81,0x3C,0x00,0x20,0x06,0xE0,0x80,	/* 56E8: <. . */
	0x19,0x40,0x00,0x01,0x18,0x86,0x70,0x00,	/* 56F0: .@...p. */
	0x30,0x2E,0xFF,0xFC,0x4A,0x80,0x67,0x24,	/* 56F8: 0.Jg$ */
	0x2C,0x3C,0x04,0x01,0xF0,0xC4,0x30,0x2E,	/* 5700: ,<..0. */
	0xFF,0xFC,0x20,0x44,0xD1,0xC6,0xD0,0xBC,	/* 5708:  D */
	0x00,0x00,0xFF,0xFF,0x3D,0x40,0xFF,0xFC,	/* 5710: ..=@ */
	0x10,0x10,0x70,0x00,0x30,0x2E,0xFF,0xFC,	/* 5718: ..p.0. */
	0x4A,0x80,0x66,0xE2,0x30,0x2E,0xFF,0xFC,	/* 5720: Jf0. */
	0xD0,0xBC,0x00,0x00,0xFF,0xFF,0x3D,0x40,	/* 5728: ..=@ */
	0xFF,0xFC,0x3C,0x2E,0xFF,0xFE,0x30,0x02,	/* 5730: <.0. */
	0x32,0x07,0x52,0x81,0x9C,0x81,0xCC,0xBC,	/* 5738: 2.R */
	0x00,0x00,0x00,0xFF,0xC0,0xBC,0x00,0x00,	/* 5740: ..... */
	0x00,0x08,0x67,0x00,0x00,0xA2,0x70,0x40,	/* 5748: ..g..p@ */
	0xB0,0x8A,0x6E,0x00,0x00,0x9A,0xCC,0xBC,	/* 5750: n.. */
	0x00,0x00,0xFF,0xFF,0x70,0x40,0xB0,0x86,	/* 5758: ..p@ */
	0x6F,0x00,0x00,0x8C,0x84,0xBC,0x00,0x00,	/* 5760: o.... */
	0x00,0x10,0x08,0x2D,0x00,0x03,0x00,0x30,	/* 5768: ...-...0 */
	0x67,0x48,0x30,0x02,0xC0,0xBC,0x00,0x00,	/* 5770: gH0... */
	0x00,0x20,0x66,0x3E,0x2E,0x3C,0x04,0x01,	/* 5778: . f>.<.. */
	0xF0,0x0A,0x20,0x44,0xD1,0xC7,0x10,0x10,	/* 5780: . D.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x4A,0x00,	/* 5788: ...J. */
	0x66,0x22,0x42,0xA7,0x48,0x78,0x01,0x00,	/* 5790: f"BHx.. */
	0x2F,0x0D,0x4E,0xB9,0x00,0x00,0x23,0xFC,	/* 5798: ..N..# */
	0x20,0x44,0x70,0x22,0x4F,0xEF,0x00,0x0C,	/* 57A0:  Dp"O.. */
	0xD1,0xC7,0x10,0x80,0x84,0xBC,0x00,0x00,	/* 57A8: ... */
	0x00,0x20,0x60,0x06,0x84,0xBC,0x00,0x00,	/* 57B0: . `... */
	0x00,0xC0,0x08,0x2D,0x00,0x07,0x00,0x31,	/* 57B8: ..-...1 */
	0x67,0x12,0x42,0xA7,0x48,0x78,0x10,0x00,	/* 57C0: g.BHx.. */
	0x2F,0x0D,0x4E,0xB9,0x00,0x00,0x23,0xFC,	/* 57C8: ..N..# */
	0x4F,0xEF,0x00,0x0C,0x08,0x2D,0x00,0x06,	/* 57D0: O...-.. */
	0x00,0x30,0x67,0x12,0x42,0xA7,0x48,0x78,	/* 57D8: .0g.BHx */
	0x20,0x00,0x2F,0x0D,0x4E,0xB9,0x00,0x00,	/* 57E0:  ...N.. */
	0x23,0xFC,0x4F,0xEF,0x00,0x0C,0x20,0x44,	/* 57E8: #O.. D */
	0x30,0x2E,0xFF,0xF0,0x49,0xED,0x00,0x08,	/* 57F0: 0.I.. */
	0xC4,0xBC,0x00,0x00,0xFF,0xFF,0xD1,0xFC,	/* 57F8: .. */
	0x04,0x01,0xF0,0xD6,0x2A,0x42,0xC0,0xBC,	/* 5800: ..*B */
	0x00,0x00,0x00,0x3F,0x10,0x80,0x20,0x44,	/* 5808: ...?. D */
	0x30,0x2E,0xFF,0xF4,0xD1,0xFC,0x04,0x01,	/* 5810: 0... */
	0xF0,0xD0,0x10,0x80,0x20,0x0D,0xE0,0x80,	/* 5818: . . */
	0x19,0x40,0x00,0x01,0x20,0x0D,0x18,0x80,	/* 5820: .@.. .. */
	0x60,0x00,0x02,0x5A,0x7E,0x00,0x70,0x00,	/* 5828: `..Z~.p. */
	0x22,0x2E,0xFF,0xE0,0x20,0x44,0x30,0x02,	/* 5830: ". D0. */
	0x24,0x3C,0x04,0x01,0xF0,0xC4,0xE5,0x89,	/* 5838: $<.. */
	0xD1,0xC2,0xD0,0x81,0x49,0xF3,0x0A,0x0A,	/* 5840: I.. */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 5848: p..,.. */
	0x10,0x14,0x72,0x00,0x32,0x00,0x2A,0x41,	/* 5850: ..r.2.*A */
	0x10,0x10,0xDB,0xFC,0x01,0x01,0x80,0x00,	/* 5858: ..... */
	0x20,0x44,0xD1,0xC2,0xC0,0xBC,0x00,0x00,	/* 5860:  D.. */
	0x00,0xFF,0x1D,0x40,0xFF,0xFE,0x14,0x10,	/* 5868: ..@.. */
	0x10,0x2E,0xFF,0xFE,0xC4,0xBC,0x00,0x00,	/* 5870: .... */
	0x00,0xFF,0x08,0x00,0x00,0x03,0x67,0x0E,	/* 5878: .....g. */
	0x08,0xED,0x00,0x00,0x00,0x19,0x70,0x01,	/* 5880: .....p. */
	0x33,0xC0,0x00,0x00,0x62,0xA8,0x70,0x00,	/* 5888: 3..bp. */
	0x10,0x2E,0xFF,0xFE,0x72,0x07,0xC2,0x80,	/* 5890: ..r. */
	0x67,0x10,0x08,0x2D,0x00,0x07,0x00,0x20,	/* 5898: g..-...  */
	0x67,0x08,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 58A0: g.p.3.. */
	0x62,0xA8,0x10,0x2E,0xFF,0xFE,0x08,0x00,	/* 58A8: b.... */
	0x00,0x00,0x67,0x22,0x49,0xED,0x00,0x3C,	/* 58B0: ..g"I.< */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 58B8: p..,.. */
	0x10,0x14,0x72,0x00,0x52,0x80,0x32,0x00,	/* 58C0: ..r.R2. */
	0x24,0x41,0x20,0x0A,0xE0,0x80,0x19,0x40,	/* 58C8: $A ..@ */
	0x00,0x01,0x20,0x0A,0x18,0x80,0x10,0x2E,	/* 58D0: .. .... */
	0xFF,0xFE,0x08,0x00,0x00,0x01,0x67,0x20,	/* 58D8: ....g  */
	0x49,0xED,0x00,0x38,0x70,0x00,0x7E,0x00,	/* 58E0: I.8p.~. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 58E8: .,.... */
	0x52,0x80,0x3E,0x00,0x20,0x07,0xE0,0x80,	/* 58F0: R>. . */
	0x19,0x40,0x00,0x01,0x18,0x87,0x7E,0x01,	/* 58F8: .@...~. */
	0x10,0x2E,0xFF,0xFE,0x08,0x00,0x00,0x02,	/* 5900: ...... */
	0x67,0x20,0x49,0xED,0x00,0x3A,0x70,0x00,	/* 5908: g I.:p. */
	0x7E,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 5910: ~..,.. */
	0x10,0x14,0x52,0x80,0x3E,0x00,0x20,0x07,	/* 5918: ..R>. . */
	0xE0,0x80,0x19,0x40,0x00,0x01,0x18,0x87,	/* 5920: .@... */
	0x7E,0x01,0x4A,0x87,0x67,0x00,0x01,0x34,	/* 5928: ~.Jg..4 */
	0x08,0x2D,0x00,0x06,0x00,0x20,0x67,0x04,	/* 5930: .-... g. */
	0x14,0x2D,0x00,0x2B,0x7E,0x00,0x70,0x00,	/* 5938: .-.+~.p. */
	0x49,0xED,0x00,0x08,0x1E,0x2D,0x00,0x0A,	/* 5940: I...-.. */
	0x10,0x2D,0x00,0x0B,0x3D,0x40,0xFF,0xE6,	/* 5948: .-..=@ */
	0x70,0x00,0x10,0x2C,0x00,0x01,0xE1,0x88,	/* 5950: p..,.. */
	0x10,0x14,0x3D,0x40,0xFF,0xFE,0x3C,0x2E,	/* 5958: ..=@<. */
	0xFF,0xE6,0x32,0x07,0x52,0x81,0x9C,0x81,	/* 5960: 2.R */
	0xCC,0xBC,0x00,0x00,0x00,0xFF,0x67,0x00,	/* 5968: ...g. */
	0x00,0xD0,0x20,0x4D,0x70,0x00,0x10,0x07,	/* 5970: . Mp... */
	0xD1,0xC0,0x11,0x42,0x01,0x60,0x52,0x87,	/* 5978: .B.`R */
	0x1B,0x47,0x00,0x0A,0x34,0x2E,0xFF,0xE6,	/* 5980: .G..4. */
	0x32,0x07,0x52,0x81,0x94,0x81,0x30,0x2E,	/* 5988: 2.R0. */
	0xFF,0xFE,0xC4,0xBC,0x00,0x00,0x00,0xFF,	/* 5990: ... */
	0xC0,0xBC,0x00,0x00,0x00,0x08,0x67,0x00,	/* 5998: ....g. */
	0x00,0xC2,0x70,0x40,0xB0,0x86,0x6E,0x00,	/* 59A0: .p@n. */
	0x00,0xBA,0xC4,0xBC,0x00,0x00,0xFF,0xFF,	/* 59A8: ... */
	0x70,0x40,0xB0,0x82,0x6F,0x00,0x00,0xAC,	/* 59B0: p@o.. */
	0x30,0x2E,0xFF,0xFE,0x80,0xBC,0x00,0x00,	/* 59B8: 0... */
	0x00,0x10,0x3D,0x40,0xFF,0xFE,0x08,0x2D,	/* 59C0: ..=@.- */
	0x00,0x03,0x00,0x30,0x67,0x3C,0x30,0x2E,	/* 59C8: ...0g<0. */
	0xFF,0xFE,0xC0,0xBC,0x00,0x00,0x00,0x20,	/* 59D0: ...  */
	0x66,0x30,0x24,0x3C,0x04,0x01,0xF0,0x0A,	/* 59D8: f0$<... */
	0x20,0x44,0xD1,0xC2,0x10,0x10,0xC0,0xBC,	/* 59E0:  D.. */
	0x00,0x00,0x00,0xFF,0x4A,0x00,0x66,0x1A,	/* 59E8: ...J.f. */
	0x42,0xA7,0x48,0x78,0x01,0x00,0x2F,0x0D,	/* 59F0: BHx.... */
	0x4E,0xB9,0x00,0x00,0x23,0xFC,0x20,0x44,	/* 59F8: N..# D */
	0xD1,0xC2,0x70,0x22,0x10,0x80,0x4F,0xEF,	/* 5A00: p".O */
	0x00,0x0C,0x08,0x2D,0x00,0x07,0x00,0x31,	/* 5A08: ...-...1 */
	0x67,0x12,0x42,0xA7,0x48,0x78,0x10,0x00,	/* 5A10: g.BHx.. */
	0x2F,0x0D,0x4E,0xB9,0x00,0x00,0x23,0xFC,	/* 5A18: ..N..# */
	0x4F,0xEF,0x00,0x0C,0x08,0x2D,0x00,0x06,	/* 5A20: O...-.. */
	0x00,0x30,0x67,0x36,0x42,0xA7,0x48,0x78,	/* 5A28: .0g6BHx */
	0x20,0x00,0x2F,0x0D,0x4E,0xB9,0x00,0x00,	/* 5A30:  ...N.. */
	0x23,0xFC,0x4F,0xEF,0x00,0x0C,0x60,0x22,	/* 5A38: #O..`" */
	0x49,0xED,0x00,0x3E,0x70,0x00,0x74,0x00,	/* 5A40: I.>p.t. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 5A48: .,.... */
	0x32,0x2E,0xFF,0xFC,0xD0,0x81,0x34,0x00,	/* 5A50: 2.4. */
	0x20,0x02,0xE0,0x80,0x19,0x40,0x00,0x01,	/* 5A58:  ..@.. */
	0x18,0x82,0x20,0x44,0x30,0x2E,0xFF,0xF0,	/* 5A60: . D0. */
	0xD1,0xFC,0x04,0x01,0xF0,0xD6,0xC0,0xBC,	/* 5A68: .. */
	0x00,0x00,0x00,0x3F,0x10,0x80,0x20,0x44,	/* 5A70: ...?. D */
	0x30,0x2E,0xFF,0xF4,0xD1,0xFC,0x04,0x01,	/* 5A78: 0... */
	0xF0,0xD0,0x10,0x80,0x30,0x2E,0xFF,0xDE,	/* 5A80: .0. */
	0xC0,0xBC,0x00,0x00,0x00,0x02,0x67,0x00,	/* 5A88: ....g. */
	0x05,0xD2,0x20,0x44,0xD1,0xFC,0x04,0x01,	/* 5A90: . D.. */
	0xF0,0xD4,0x10,0x10,0x20,0x44,0xD1,0xFC,	/* 5A98: .. D */
	0x04,0x01,0xF0,0xD0,0xC0,0xBC,0x00,0x00,	/* 5AA0: .... */
	0x00,0xFF,0x3D,0x40,0xFF,0xF0,0x10,0x10,	/* 5AA8: .=@.. */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0xD0,	/* 5AB0:  D.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x3D,0x40,	/* 5AB8: ...=@ */
	0xFF,0xEC,0x34,0x2E,0xFF,0xF0,0x70,0x00,	/* 5AC0: 4.p. */
	0xC4,0xBC,0x00,0x00,0x00,0x03,0x10,0x82,	/* 5AC8: ..... */
	0x30,0x02,0x22,0x2E,0xFF,0xE0,0xE5,0x89,	/* 5AD0: 0.". */
	0xD0,0x81,0x49,0xF3,0x0A,0x0A,0x70,0x00,	/* 5AD8: I..p. */
	0x10,0x2C,0x00,0x01,0xE1,0x88,0x10,0x14,	/* 5AE0: .,.... */
	0x72,0x00,0x32,0x00,0x2A,0x41,0xDB,0xFC,	/* 5AE8: r.2.*A */
	0x01,0x01,0x80,0x00,0x4A,0x2D,0x00,0x27,	/* 5AF0: ...J-.' */
	0x66,0x06,0x08,0xED,0x00,0x01,0x00,0x28,	/* 5AF8: f.....( */
	0x4A,0x2D,0x00,0x35,0x67,0x1A,0x2F,0x0D,	/* 5B00: J-.5g... */
	0x61,0x00,0xF3,0x96,0x49,0xED,0x00,0x08,	/* 5B08: a.I.. */
	0x74,0x00,0x58,0x8F,0x14,0x2C,0x00,0x01,	/* 5B10: t.X.,.. */
	0xE1,0x8A,0x14,0x14,0x60,0x00,0x05,0x0A,	/* 5B18: ..`... */
	0x70,0x00,0x7E,0x00,0x49,0xED,0x00,0x08,	/* 5B20: p.~.I.. */
	0x74,0x00,0x10,0x2D,0x00,0x0D,0x3D,0x40,	/* 5B28: t..-..=@ */
	0xFF,0xFE,0x14,0x2C,0x00,0x01,0x1E,0x2D,	/* 5B30: .,...- */
	0x00,0x0C,0xE1,0x8A,0x14,0x14,0x30,0x02,	/* 5B38: ....0. */
	0xC0,0xBC,0x00,0x00,0x01,0x00,0x67,0x2A,	/* 5B40: ....g* */
	0xC4,0xBC,0x00,0x00,0xFE,0xFF,0x28,0x7C,	/* 5B48: ..(| */
	0x04,0x01,0xF0,0x0C,0x20,0x44,0x22,0x44,	/* 5B50: ... D"D */
	0x84,0xBC,0x00,0x00,0x02,0x00,0xD1,0xCC,	/* 5B58: .... */
	0xD3,0xCC,0xC4,0xBC,0x00,0x00,0xFF,0xFE,	/* 5B60: .. */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xF9,	/* 5B68: ..... */
	0x10,0x80,0x30,0x2E,0xFF,0xFE,0x90,0x87,	/* 5B70: .0. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x28,0x40,	/* 5B78: ...(@ */
	0x4A,0x8C,0x67,0x00,0x04,0x38,0x70,0x00,	/* 5B80: Jg..8p. */
	0x10,0x2D,0x00,0x06,0x72,0x48,0xB2,0x80,	/* 5B88: .-..rH */
	0x66,0x04,0x7C,0x20,0x60,0x02,0x7C,0x0C,	/* 5B90: f.| `.|. */
	0xCC,0xBC,0x00,0x00,0xFF,0xFF,0xB9,0xC6,	/* 5B98: .. */
	0x6F,0x04,0x2A,0x06,0x60,0x02,0x2A,0x0C,	/* 5BA0: o.*.`.*. */
	0x1B,0x45,0x00,0x44,0x30,0x02,0xC0,0xBC,	/* 5BA8: .E.D0. */
	0x00,0x00,0x04,0x00,0x67,0x00,0x00,0x8E,	/* 5BB0: ....g.. */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x67,0x00,	/* 5BB8: ..g. */
	0x03,0xA0,0x26,0x3C,0x04,0x01,0xF0,0xC6,	/* 5BC0: .&<.. */
	0x70,0x00,0x72,0x00,0x10,0x07,0x12,0x35,	/* 5BC8: p.r....5 */
	0x08,0x60,0x70,0x0A,0xB0,0x81,0x66,0x42,	/* 5BD0: .`p.fB */
	0x70,0x00,0x30,0x06,0x55,0x80,0x6D,0x00,	/* 5BD8: p.0.Um. */
	0x03,0x80,0x20,0x44,0x70,0x0D,0x52,0x87,	/* 5BE0: . Dp.R */
	0xDA,0xBC,0x00,0x00,0xFF,0xFF,0xDC,0xBC,	/* 5BE8: .. */
	0x00,0x00,0xFF,0xFE,0xD1,0xC3,0x10,0x80,	/* 5BF0: ... */
	0x20,0x44,0x70,0x0A,0xD1,0xC3,0x10,0x80,	/* 5BF8:  Dp.. */
	0xCA,0xBC,0x00,0x00,0xFF,0xFF,0x67,0x00,	/* 5C00: ..g. */
	0x03,0x58,0x70,0x00,0x72,0x00,0x10,0x07,	/* 5C08: .Xp.r... */
	0x12,0x35,0x08,0x60,0x70,0x0A,0xB0,0x81,	/* 5C10: .5.`p. */
	0x67,0xBE,0x20,0x44,0x70,0x00,0xDA,0xBC,	/* 5C18: g Dp. */
	0x00,0x00,0xFF,0xFF,0xDC,0xBC,0x00,0x00,	/* 5C20: .... */
	0xFF,0xFF,0xD1,0xC3,0x10,0x07,0x10,0x35,	/* 5C28: ...5 */
	0x08,0x60,0x52,0x87,0x10,0x80,0xCA,0xBC,	/* 5C30: .`R. */
	0x00,0x00,0xFF,0xFF,0x66,0x00,0xFF,0x8A,	/* 5C38: ..f. */
	0x60,0x00,0x03,0x1E,0xCA,0xBC,0x00,0x00,	/* 5C40: `..... */
	0xFF,0xFF,0x20,0x05,0xB0,0xBC,0x00,0x00,	/* 5C48:  ... */
	0x00,0x20,0x62,0x00,0x03,0x0C,0x20,0x7B,	/* 5C50: . b... { */
	0x0C,0x04,0x4E,0xD0,0x00,0x00,0x5F,0x60,	/* 5C58: ..N.._` */
	0x00,0x00,0x5F,0x4C,0x00,0x00,0x5F,0x38,	/* 5C60: .._L.._8 */
	0x00,0x00,0x5F,0x24,0x00,0x00,0x5F,0x10,	/* 5C68: .._$.._. */
	0x00,0x00,0x5E,0xFC,0x00,0x00,0x5E,0xE8,	/* 5C70: ..^..^ */
	0x00,0x00,0x5E,0xD4,0x00,0x00,0x5E,0xC0,	/* 5C78: ..^..^ */
	0x00,0x00,0x5E,0xAC,0x00,0x00,0x5E,0x98,	/* 5C80: ..^..^ */
	0x00,0x00,0x5E,0x84,0x00,0x00,0x5E,0x70,	/* 5C88: ..^..^p */
	0x00,0x00,0x5E,0x5C,0x00,0x00,0x5E,0x48,	/* 5C90: ..^\..^H */
	0x00,0x00,0x5E,0x34,0x00,0x00,0x5E,0x20,	/* 5C98: ..^4..^  */
	0x00,0x00,0x5E,0x0C,0x00,0x00,0x5D,0xF8,	/* 5CA0: ..^...] */
	0x00,0x00,0x5D,0xE4,0x00,0x00,0x5D,0xD0,	/* 5CA8: ..]..] */
	0x00,0x00,0x5D,0xBC,0x00,0x00,0x5D,0xA8,	/* 5CB0: ..]..] */
	0x00,0x00,0x5D,0x94,0x00,0x00,0x5D,0x80,	/* 5CB8: ..]..] */
	0x00,0x00,0x5D,0x6C,0x00,0x00,0x5D,0x58,	/* 5CC0: ..]l..]X */
	0x00,0x00,0x5D,0x44,0x00,0x00,0x5D,0x30,	/* 5CC8: ..]D..]0 */
	0x00,0x00,0x5D,0x1C,0x00,0x00,0x5D,0x08,	/* 5CD0: ..]...]. */
	0x00,0x00,0x5C,0xF4,0x00,0x00,0x5C,0xE0,	/* 5CD8: ..\..\ */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5CE0:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5CE8: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5CF0: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5CF8: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5D00: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5D08:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5D10: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5D18: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5D20: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5D28: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5D30:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5D38: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5D40: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5D48: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5D50: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5D58:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5D60: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5D68: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5D70: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5D78: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5D80:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5D88: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5D90: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5D98: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5DA0: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5DA8:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5DB0: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5DB8: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5DC0: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5DC8: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5DD0:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5DD8: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5DE0: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5DE8: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5DF0: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5DF8:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5E00: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5E08: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5E10: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5E18: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5E20:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5E28: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5E30: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5E38: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5E40: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5E48:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5E50: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5E58: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5E60: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5E68: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5E70:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5E78: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5E80: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5E88: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5E90: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5E98:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5EA0: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5EA8: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5EB0: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5EB8: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5EC0:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5EC8: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5ED0: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5ED8: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5EE0: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5EE8:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5EF0: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5EF8: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5F00: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5F08: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5F10:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5F18: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5F20: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5F28: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5F30: .5.`.R */
	0x20,0x44,0x70,0x00,0xD1,0xFC,0x04,0x01,	/* 5F38:  Dp... */
	0xF0,0xC6,0x10,0x07,0x10,0x35,0x08,0x60,	/* 5F40: ...5.` */
	0x10,0x80,0x52,0x87,0x20,0x44,0x70,0x00,	/* 5F48: .R Dp. */
	0xD1,0xFC,0x04,0x01,0xF0,0xC6,0x10,0x07,	/* 5F50: .... */
	0x10,0x35,0x08,0x60,0x10,0x80,0x52,0x87,	/* 5F58: .5.`.R */
	0xCE,0xBC,0x00,0x00,0x00,0xFF,0x30,0x2E,	/* 5F60: ...0. */
	0xFF,0xFE,0x1B,0x47,0x00,0x0C,0x90,0x87,	/* 5F68: .G.. */
	0xC0,0xBC,0x00,0x00,0x00,0xFF,0x2E,0x3C,	/* 5F70: ....< */
	0x00,0x00,0x00,0xC0,0x24,0x40,0xB9,0xC7,	/* 5F78: ...$@ */
	0x6F,0x0C,0xB5,0xC7,0x6E,0x0E,0x84,0xBC,	/* 5F80: o.n. */
	0x00,0x00,0x08,0x00,0x60,0x24,0x70,0x40,	/* 5F88: ....`$p@ */
	0xB0,0x8C,0x6C,0x1E,0x70,0x40,0xB0,0x8A,	/* 5F90: l.p@ */
	0x6D,0x18,0x30,0x02,0xC0,0xBC,0x00,0x00,	/* 5F98: m.0... */
	0x08,0x00,0x67,0x0E,0xC4,0xBC,0x00,0x00,	/* 5FA0: ..g... */
	0xF7,0xFF,0x70,0x01,0x33,0xC0,0x00,0x00,	/* 5FA8: p.3.. */
	0x62,0xA8,0x08,0xED,0x00,0x00,0x00,0x41,	/* 5FB0: b....A */
	0x60,0x00,0x00,0x6E,0x2E,0x3C,0x04,0x01,	/* 5FB8: `..n.<.. */
	0xF0,0x0C,0x20,0x44,0xD1,0xC7,0x10,0x10,	/* 5FC0: . D.. */
	0x08,0x00,0x00,0x02,0x67,0x20,0x70,0x02,	/* 5FC8: ....g p. */
	0x20,0x44,0x22,0x44,0x1B,0x40,0x00,0x44,	/* 5FD0:  D"D.@.D */
	0xD1,0xC7,0xD3,0xC7,0x10,0x11,0xC0,0xBC,	/* 5FD8: .. */
	0x00,0x00,0x00,0xFB,0x80,0xBC,0x00,0x00,	/* 5FE0: ..... */
	0x00,0x02,0x10,0x80,0x60,0x3A,0x42,0x2D,	/* 5FE8: ...`:B- */
	0x00,0x44,0xC4,0xBC,0x00,0x00,0xFF,0xFE,	/* 5FF0: .D.. */
	0x20,0x44,0x22,0x44,0xD1,0xC7,0xD3,0xC7,	/* 5FF8:  D"D */
	0x10,0x11,0xC0,0xBC,0x00,0x00,0x00,0xF9,	/* 6000: ..... */
	0x10,0x80,0x1E,0x2D,0x00,0x41,0x08,0x07,	/* 6008: ..-.A.. */
	0x00,0x00,0x67,0x14,0x70,0x01,0x33,0xC0,	/* 6010: ..g.p.3 */
	0x00,0x00,0x62,0xA8,0x10,0x07,0xC0,0xBC,	/* 6018: ..b.. */
	0x00,0x00,0x00,0xFE,0x1B,0x40,0x00,0x41,	/* 6020: ....@.A */
	0x20,0x44,0x30,0x2E,0xFF,0xF0,0x49,0xED,	/* 6028:  D0.I */
	0x00,0x08,0xC4,0xBC,0x00,0x00,0xFF,0xFF,	/* 6030: .... */
	0xD1,0xFC,0x04,0x01,0xF0,0xD4,0x2A,0x42,	/* 6038: ..*B */
	0xC0,0xBC,0x00,0x00,0x00,0x3F,0x10,0x80,	/* 6040: ...?. */
	0x20,0x44,0x30,0x2E,0xFF,0xEC,0xD1,0xFC,	/* 6048:  D0. */
	0x04,0x01,0xF0,0xD0,0x10,0x80,0x20,0x0D,	/* 6050: ... . */
	0xE0,0x80,0x19,0x40,0x00,0x01,0x20,0x0D,	/* 6058: .@.. . */
	0x18,0x80,0x30,0x2E,0xFF,0xDE,0xC0,0xBC,	/* 6060: .0. */
	0x00,0x00,0x00,0x04,0x67,0x00,0x00,0xB0,	/* 6068: ....g.. */
	0x20,0x44,0xD1,0xFC,0x04,0x01,0xF0,0xD2,	/* 6070:  D.. */
	0x10,0x10,0x20,0x44,0xD1,0xFC,0x04,0x01,	/* 6078: .. D.. */
	0xF0,0xD0,0xC0,0xBC,0x00,0x00,0x00,0xFF,	/* 6080: ... */
	0x3D,0x40,0xFF,0xEC,0x10,0x10,0x20,0x44,	/* 6088: =@.. D */
	0xD1,0xFC,0x04,0x01,0xF0,0xD0,0xC0,0xBC,	/* 6090: .. */
	0x00,0x00,0x00,0xFF,0x3D,0x40,0xFF,0xF4,	/* 6098: ...=@ */
	0x34,0x2E,0xFF,0xEC,0x70,0x00,0xC4,0xBC,	/* 60A0: 4.p. */
	0x00,0x00,0x00,0x03,0x10,0x82,0x30,0x02,	/* 60A8: .....0. */
	0x22,0x2E,0xFF,0xE0,0xE5,0x89,0xD0,0x81,	/* 60B0: ". */
	0x49,0xF3,0x0A,0x0A,0x70,0x00,0x10,0x2C,	/* 60B8: I..p.., */
	0x00,0x01,0xE1,0x88,0x10,0x14,0x72,0x00,	/* 60C0: ....r. */
	0x32,0x00,0x2A,0x41,0xDB,0xFC,0x01,0x01,	/* 60C8: 2.*A.. */
	0x80,0x00,0x2F,0x0D,0x61,0x00,0xEF,0x82,	/* 60D0: ...a. */
	0x2F,0x0D,0x4E,0xB9,0x00,0x00,0x2B,0xAC,	/* 60D8: ..N..+ */
	0x50,0x8F,0x4A,0x2D,0x00,0x27,0x66,0x06,	/* 60E0: PJ-.'f. */
	0x08,0xED,0x00,0x02,0x00,0x28,0x70,0x01,	/* 60E8: ....(p. */
	0x20,0x44,0x33,0xC0,0x00,0x00,0x62,0xA8,	/* 60F0:  D3..b */
	0xD1,0xFC,0x04,0x01,0xF0,0xD2,0x08,0xED,	/* 60F8: ... */
	0x00,0x01,0x00,0x19,0x30,0x2E,0xFF,0xEC,	/* 6100: ....0. */
	0xC0,0xBC,0x00,0x00,0x00,0x3F,0x10,0x80,	/* 6108: ...?. */
	0x20,0x44,0x30,0x2E,0xFF,0xF4,0xD1,0xFC,	/* 6110:  D0. */
	0x04,0x01,0xF0,0xD0,0x10,0x80,0x20,0x44,	/* 6118: ... D */
	0x10,0x2B,0x00,0x09,0xD1,0xFC,0x04,0x01,	/* 6120: .+.... */
	0xF0,0xFE,0x10,0x80,0x20,0x2E,0xFF,0xE0,	/* 6128: . . */
	0x72,0x00,0x52,0x80,0x32,0x00,0x2D,0x41,	/* 6130: r.R2.-A */
	0xFF,0xE0,0x20,0x2E,0xFF,0xE0,0x55,0x80,	/* 6138:  .U */
	0x6D,0x30,0x70,0x00,0x78,0x00,0x2D,0x40,	/* 6140: m0p.x.-@ */
	0xFF,0xE0,0x70,0x00,0x10,0x2B,0x00,0x01,	/* 6148: p..+.. */
	0xE1,0x88,0x10,0x13,0x38,0x00,0x4A,0x84,	/* 6150: ..8.J */
	0x67,0x12,0x20,0x3C,0xFF,0xFF,0x7F,0xFF,	/* 6158: g. < */
	0xC0,0x84,0x26,0x40,0xD7,0xFC,0x01,0x01,	/* 6160: &@.. */
	0x80,0x00,0x60,0x06,0x26,0x7C,0x01,0x01,	/* 6168: .`.&|.. */
	0x80,0x80,0x70,0x00,0x30,0x2E,0xFF,0xDE,	/* 6170: p.0. */
	0x4A,0x80,0x66,0x14,0x20,0x0B,0xB0,0xBC,	/* 6178: Jf. . */
	0x01,0x01,0x80,0x80,0x66,0x00,0xEF,0xA8,	/* 6180: ..f. */
	0x4A,0xAE,0xFF,0xE0,0x66,0x00,0xEF,0xA0,	/* 6188: Jf. */
	0x4C,0xD7,0x3C,0xFC,0x4F,0xEF,0x00,0x28,	/* 6190: L<O.( */
	0x4E,0x5E,0x4E,0x75,0x4F,0xEF,0xFF,0xF0,	/* 6198: N^NuO */
	0x70,0x07,0x48,0xD7,0x30,0xC0,0x2C,0x2F,	/* 61A0: p.H0,. */
	0x00,0x14,0x2A,0x6F,0x00,0x18,0x2E,0x2F,	/* 61A8: ..*o.... */
	0x00,0x1C,0x28,0x46,0xB0,0x87,0x64,0x42,	/* 61B0: ..(FdB */
	0x70,0x04,0x72,0x03,0x90,0x86,0xC2,0x80,	/* 61B8: p.r. */
	0x9E,0x81,0x4A,0x81,0x67,0x06,0x18,0xDD,	/* 61C0: Jg.. */
	0x53,0x81,0x66,0xFA,0x20,0x0D,0x72,0x03,	/* 61C8: Sf .r. */
	0xC2,0x80,0x66,0x26,0x22,0x07,0xE4,0x89,	/* 61D0: f&". */
	0xCE,0xBC,0x00,0x00,0x00,0x03,0x4A,0x81,	/* 61D8: ....J */
	0x67,0x12,0x70,0x00,0x22,0x4C,0x20,0x4D,	/* 61E0: g.p."L M */
	0xD3,0xC0,0xD1,0xC0,0x20,0x01,0x22,0xD8,	/* 61E8:  ." */
	0x53,0x80,0x66,0xFA,0xE5,0x89,0xD9,0xC1,	/* 61F0: Sf */
	0xDB,0xC1,0x4A,0x87,0x67,0x06,0x18,0xDD,	/* 61F8: Jg.. */
	0x53,0x87,0x66,0xFA,0x20,0x06,0x4C,0xD7,	/* 6200: Sf .L */
	0x30,0xC0,0x4F,0xEF,0x00,0x10,0x4E,0x75,	/* 6208: 0O..Nu */
	0x4F,0xEF,0xFF,0xF4,0x70,0x00,0x48,0xD7,	/* 6210: Op.H */
	0x20,0xA0,0x20,0x6F,0x00,0x10,0x2A,0x2F,	/* 6218:   o..*. */
	0x00,0x14,0x2E,0x2F,0x00,0x18,0x2A,0x48,	/* 6220: ......*H */
	0x10,0x05,0x2A,0x00,0x70,0x07,0xB0,0x87,	/* 6228: ..*.p. */
	0x64,0x44,0x2F,0x06,0x22,0x05,0x70,0x04,	/* 6230: dD..".p. */
	0x7C,0x03,0xE1,0x89,0x90,0x88,0x82,0x85,	/* 6238: |. */
	0xCC,0x80,0xE1,0x89,0x9E,0x86,0x82,0x85,	/* 6240:  */
	0xE1,0x89,0x82,0x85,0x4A,0x86,0x67,0x06,	/* 6248: Jg. */
	0x1A,0xC5,0x53,0x86,0x66,0xFA,0x2C,0x07,	/* 6250: .Sf,. */
	0xE4,0x8E,0xCE,0xBC,0x00,0x00,0x00,0x03,	/* 6258: .... */
	0x4A,0x86,0x67,0x0A,0x22,0x4D,0x20,0x06,	/* 6260: Jg."M . */
	0x22,0xC1,0x53,0x80,0x66,0xFA,0x20,0x06,	/* 6268: "Sf . */
	0xE5,0x88,0xDB,0xC0,0x2C,0x1F,0x4A,0x87,	/* 6270: ,.J */
	0x67,0x06,0x1A,0xC5,0x53,0x87,0x66,0xFA,	/* 6278: g..Sf */
	0x20,0x08,0x4C,0xD7,0x20,0xA0,0x4F,0xEF,	/* 6280:  .L O */
	0x00,0x0C,0x4E,0x75,0x4E,0x75,0x4E,0x75,	/* 6288: ..NuNuNu */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 6290: ........ */
	0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,	/* 6298: ........ */
	0x00,0x00,0x00,0x00,0x10,0x00,0x01,0x00,	/* 62A0: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,	/* 62A8: ....... */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 62B0: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,	/* 62B8: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,	/* 62C0: ........ */
	0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x08,	/* 62C8: ........ */
	0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x0A,	/* 62D0: ........ */
	0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,	/* 62D8: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xF0,	/* 62E0: ....... */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 62E8: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,	/* 62F0: ........ */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,	/* 62F8: ........ */
	0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x08,	/* 6300: ........ */
	0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x0A,	/* 6308: ........ */
	0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,	/* 6310: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 6318: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 6320: ........ */
	0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x0A,	/* 6328: ....... */
	0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0A,	/* 6330: ........ */
	0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x01,	/* 6338: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 6340: ........ */
	0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,	/* 6348: ........ */
	0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x01,	/* 6350: ........ */
	0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,	/* 6358: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xA0,	/* 6360: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xA0,	/* 6368: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x28,	/* 6370: ......1( */
	0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xA0,	/* 6378: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x18,	/* 6380: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x31,0xB0,	/* 6388: ......1 */
	0x00,0x00,0x00,0x00,0x00,0x00,0x32,0x88,	/* 6390: ......2 */
	0x00,0x00,0x00,0x00,0x00,0x00,0x32,0xA8,	/* 6398: ......2 */
	0x00,0x00,0x00,0x00,0x00,0x00,0x32,0xAC,	/* 63A0: ......2 */
	0x00,0x00,0x00,0x00,0x00,0x00,0x1A,0x8C,	/* 63A8: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x54,	/* 63B0: .......T */
	0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0xE8,	/* 63B8: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x84,	/* 63C0: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xA0,	/* 63C8: ....... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xF8,	/* 63D0: ......  */
	0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x60,	/* 63D8: ......"` */
	0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x70,	/* 63E0: ......"p */
	0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x80,	/* 63E8: ......" */
	0x00,0x00,0x00,0x00,0x00,0x00,0x23,0x5C,	/* 63F0: ......#\ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 63F8: ........ */
	0x01,0x01,0x80,0x80,0x00,0x00,0x41,0xA8,	/* 6400: ....A */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 6408: ........ */
	0x00,0x00,0x49,0xA0,0x00,0x00,0x00,0x00,	/* 6410: ..I.... */
	0x00,0x00,0x49,0xA0,0x00,0x00,0x00,0x00,	/* 6418: ..I.... */
	0x00,0x00,0x49,0x74,0x00,0x00,0x00,0x00,	/* 6420: ..It.... */
	0x00,0x00,0x49,0xA0,0x00,0x00,0x00,0x00,	/* 6428: ..I.... */
	0x00,0x00,0x4D,0x18,0x00,0x00,0x00,0x00,	/* 6430: ..M..... */
	0x00,0x00,0x4B,0xF8,0x00,0x00,0x00,0x00,	/* 6438: ..K.... */
	0x00,0x00,0x4C,0x28,0x00,0x00,0x00,0x00,	/* 6440: ..L(.... */
	0x00,0x00,0x4C,0x54,0x00,0x00,0x00,0x00,	/* 6448: ..LT.... */
	0x00,0x00,0x4C,0x58,0x00,0x00,0x00,0x00,	/* 6450: ..LX.... */
	0x00,0x00,0x4C,0x5C,0x00,0x00,0x00,0x00,	/* 6458: ..L\.... */
	0x00,0x00,0x4D,0x68,0x00,0x00,0x00,0x00,	/* 6460: ..Mh.... */
	0x00,0x00,0x4D,0xB4,0x00,0x00,0x00,0x00,	/* 6468: ..M.... */
	0x00,0x00,0x4E,0x2C,0x00,0x00,0x00,0x00,	/* 6470: ..N,.... */
	0x00,0x00,0x4E,0x48,0x00,0x00,0x00,0x00,	/* 6478: ..NH.... */
	0x00,0x00,0x4E,0x94                     	/* 6480: ..N     */

};
int si4_cf_dsize = sizeof(si4_cf_download);		/* 0x6484 (25732) */

unsigned short si4_cf_downloadaddr = 0x0000;

/* End of SI4_CF.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\spx_disp.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Specialix Generic Dispatch Functions.				*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	29th September 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Dispatch entry points are routed here				*/
/*					for PnP/Power filtering before being				*/
/*					passed to the main functions:						*/
/*						Spx_Flush										*/
/*						Spx_Write										*/
/*						Spx_Read										*/
/*						Spx_IoControl									*/
/*						Spx_InternalIoControl							*/
/*						Spx_CreateOpen									*/
/*						Spx_Close										*/
/*						Spx_Cleanup										*/
/*						Spx_QueryInformationFile						*/
/*						Spx_SetInformationFile							*/
/*																		*/
/*						Spx_UnstallIRPs									*/
/*						Spx_KillStalledIRPs								*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	29/09/98 NPV	Creation.

*/

#define FILE_ID	SPX_DISP_C		// File ID for Event Logging see SPX_DEFS.H for values.

/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp);



/*****************************************************************************
********************************   Spx_Flush   *******************************
*****************************************************************************/

NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialFlush(pDevObject,pIrp);

	return(status);

} // End Spx_Flush 

/*****************************************************************************
********************************   Spx_Write   *******************************
*****************************************************************************/

NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialWrite(pDevObject,pIrp);

	return(status);

} // End Spx_Write 

/*****************************************************************************
********************************   Spx_Read   ********************************
*****************************************************************************/

NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialRead(pDevObject,pIrp);

	return(status);

} // End Spx_Read 

/*****************************************************************************
******************************   Spx_IoControl   *****************************
*****************************************************************************/

NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialIoControl(pDevObject,pIrp);

	return(status);

} // End Spx_IoControl 

/*****************************************************************************
**************************   Spx_InternalIoControl   *************************
*****************************************************************************/

NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = Spx_SerialInternalIoControl(pDevObject,pIrp);

	return(status);

} // Spx_InternalIoControl 

/*****************************************************************************
*****************************   Spx_CreateOpen   *****************************
*****************************************************************************/

NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;


	if(pDevObject->DeviceType != FILE_DEVICE_SERIAL_PORT)	
	{
	    pIrp->IoStatus.Status = STATUS_ACCESS_DENIED;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return(STATUS_ACCESS_DENIED);
	}


	// Lock out state Query stop and Query remove IRPs from changing the state 
	// of the port part way through openening the port.
	ExAcquireFastMutex(&pPort->OpenMutex);
	
	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		if(pPort->DeviceIsOpen)					// Is port already open? 
		{
			status = STATUS_ACCESS_DENIED;		// Yes, deny access 
			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
		}
		else
			status = SerialCreateOpen(pDevObject,pIrp);

	}

	ExReleaseFastMutex(&pPort->OpenMutex);

	return(status);

} // End Spx_CreateOpen 

/*****************************************************************************
********************************   Spx_Close   *******************************
*****************************************************************************/

NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)		// Successful close if device is removed 
		{
			pPort->BufferSize = 0;
			SpxFreeMem(pPort->InterruptReadBuffer);
			pPort->InterruptReadBuffer = NULL;
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialClose(pDevObject,pIrp);

	return(status);

} // End Spx_Close 

/*****************************************************************************
*******************************   Spx_Cleanup   ******************************
*****************************************************************************/

NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)
		{
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		Spx_KillStalledIRPs(pDevObject);
		status = SerialCleanup(pDevObject,pIrp);
	}

	return(status);

} // End Spx_Cleanup 

/*****************************************************************************
************************   Spx_QueryInformationFile   ************************
*****************************************************************************/

NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	status = SerialQueryInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_QueryInformationFile 

/*****************************************************************************
*************************   Spx_SetInformationFile   *************************
*****************************************************************************/

NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialSetInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_SetInformationFile 

/*****************************************************************************
*****************************                    *****************************
*****************************   Spx_FilterIRPs   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	Filter incoming SERIAL IRPs (except PNP and POWER) to check
				the current PNP/POWER states and return an NT status code to
				just complete the IRP if device is blocked for the following reasons:

parameters:		pDevObject points to the device object for this IRP
				pIrp points to the IRP to filter

returns:		NT Status Code

*/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	KIRQL					oldIrqlFlags;
	KIRQL					StalledOldIrql;
	LARGE_INTEGER delay;

	if(pIrpStack->MajorFunction == IRP_MJ_PNP)			// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_POWER)		// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_SYSTEM_CONTROL)	// Don't filter WMI IRPs 
		return(STATUS_SUCCESS);


	if(pPort->IsFDO)									// Don't filter card IRPs	
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction != IRP_MJ_PNP)
	{
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
	}


	KeAcquireSpinLock(&pPort->PnpPowerFlagsLock, &oldIrqlFlags);

	if(pPort->PnpPowerFlags & PPF_REMOVED)				// Has this object been "removed"? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		return(STATUS_NO_SUCH_DEVICE);
	}

	if(pPort->PnpPowerFlags & PPF_REMOVE_PENDING)		// Removing the device? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_DELETE_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_DELETE_PENDING);
	}


	if((pPort->PnpPowerFlags & PPF_STOP_PENDING)		// Device stopping?
	||(!(pPort->PnpPowerFlags & PPF_POWERED))			// Device not powered?
	||(!(pPort->PnpPowerFlags & PPF_STARTED)))			// Device not started?
	{
		KIRQL	oldIrql;

		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);


		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		
		while(pPort->UnstallingFlag) // We do not wish to add any more IRPs to the queue if have started unstalling those currently queued.
		{
			KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
			
			KeDelayExecutionThread(KernelMode, FALSE, &delay);

			KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		}

		pPort->UnstallingFlag = TRUE;

		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	


		IoAcquireCancelSpinLock(&oldIrql);

		if(pIrp->Cancel)				// Has IRP been cancelled? 
		{								// Yes 
			IoReleaseCancelSpinLock(oldIrql);
			SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_CANCELLED\n",
				PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
				
			return(STATUS_CANCELLED);
		}

// Mark the IRP as pending and queue on the stalled list... 
		pIrp->IoStatus.Status = STATUS_PENDING;		// Mark IRP as pending 
		IoMarkIrpPending(pIrp);
		InsertTailList(&pPort->StalledIrpQueue,&pIrp->Tail.Overlay.ListEntry);
		IoSetCancelRoutine(pIrp,Spx_FilterCancelQueued);
		IoReleaseCancelSpinLock(oldIrql);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_PENDING);
	}

	KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

	return(STATUS_SUCCESS);

} // End Spx_FilterIRPs 

/*****************************************************************************
*****************************                     ****************************
*****************************   Spx_UnstallIRPs   ****************************
*****************************                     ****************************
******************************************************************************

prototype:		VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)

description:	Restart all IRPs stored on the temporary stalled list.

parameters:		pPort points to the device extension to unstall

returns:		None

*/

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)
{
	PLIST_ENTRY			pIrpLink;
	PIRP				pIrp;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		pDevObj;
	PDRIVER_OBJECT		pDrvObj;
	KIRQL				oldIrql;
	KIRQL				StalledOldIrql;
	LARGE_INTEGER		delay;

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Entry\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));


	KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	
	while(pPort->UnstallingFlag)	// We do not unstall any queued IRPs if some one is just about to be added to the queue.
	{
		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

		delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
		
		KeDelayExecutionThread(KernelMode, FALSE, &delay);

		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	}

	pPort->UnstallingFlag = TRUE;

	KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	





	IoAcquireCancelSpinLock(&oldIrql);
	pIrpLink = pPort->StalledIrpQueue.Flink;

// Restart each waiting IRP on the stalled list... 

	while(pIrpLink != &pPort->StalledIrpQueue)
	{
		pIrp = CONTAINING_RECORD(pIrpLink,IRP,Tail.Overlay.ListEntry);
		pIrpLink = pIrp->Tail.Overlay.ListEntry.Flink;
		RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
		pDevObj = pIrpStack->DeviceObject;
		pDrvObj = pDevObj->DriverObject;
		IoSetCancelRoutine(pIrp,NULL);
		IoReleaseCancelSpinLock(oldIrql);

		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Unstalling IRP 0x%X, Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,
			pIrp,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		pDrvObj->MajorFunction[pIrpStack->MajorFunction](pDevObj,pIrp);
		IoAcquireCancelSpinLock(&oldIrql);
	}

	IoReleaseCancelSpinLock(oldIrql);

	ClearUnstallingFlag(pPort);

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Exit\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

} // End Spx_UnstallIRPs 

/*****************************************************************************
*************************                            *************************
*************************   Spx_FilterCancelQueued   *************************
*************************                            *************************
******************************************************************************

prototype:		VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)

description:	Routine to cancel IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue
				pIrp points to the IRP to cancel

returns:		None

*/

VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PIO_STACK_LOCATION		pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pIrp->IoStatus.Status = STATUS_CANCELLED;
	pIrp->IoStatus.Information = 0;

	RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
	IoReleaseCancelSpinLock(pIrp->CancelIrql);

} // End Spx_FilterCancelQueued 


/*****************************************************************************
***************************                         **************************
***************************   Spx_KillStalledIRPs   **************************
***************************                         **************************
******************************************************************************

prototype:		VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)

description:	Kill all IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue

returns:		None

*/

VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PDRIVER_CANCEL			cancelRoutine;
	KIRQL					cancelIrql;

	IoAcquireCancelSpinLock(&cancelIrql);

// Call the cancel routine of all IRPs queued on the stalled list... 

	while(!IsListEmpty(&pPort->StalledIrpQueue))
	{
		PIRP	pIrp = CONTAINING_RECORD(pPort->StalledIrpQueue.Blink, IRP, Tail.Overlay.ListEntry);

		RemoveEntryList(pPort->StalledIrpQueue.Blink);
		cancelRoutine = pIrp->CancelRoutine;		// Get the cancel routine for this IRP 
		pIrp->CancelIrql = cancelIrql;
		pIrp->CancelRoutine = NULL;
		pIrp->Cancel = TRUE;

		cancelRoutine(pDevObj,pIrp);				// Call the cancel routine 

		IoAcquireCancelSpinLock(&cancelIrql);
	}

	IoReleaseCancelSpinLock(cancelIrql);

} // End Spx_KillStalledIRPs 

// End of SPX_DISP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\si3_t225.c ===
/* SI3_T225.C Version, Bootstrap and Download Code Arrays... */

char *si3_t225_ident = "%W%";

/* SI3_T225 embedded version... 

	Copyright (c) Perle Systems Ltd 1996-2000.
	JET__.BIN Version 4.0.5 Created May 14 2001 @ 15:39:18

*/

unsigned char si3_t225_bootstrap[] =
{
	0x28,0x20,0x21,0x02,0x60,0x0a
};
int si3_t225_bsize = sizeof(si3_t225_bootstrap);

unsigned short si3_t225_bootloadaddr = 0x8000 - sizeof(si3_t225_bootstrap);

unsigned char si3_t225_download[] =
{
	0x00,0x00,0xB0,0x52,0x00,0x00,0x00,0x00,	/* 0000: ..R.... */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 0008: ........ */
	0x24,0xF2,0x21,0xF8,0x24,0xF2,0x21,0xFC,	/* 0010: $!$! */
	0x22,0xF9,0x25,0xF7,0x46,0x23,0xFC,0xD4,	/* 0018: "%F# */
	0x40,0x31,0xD1,0x21,0x20,0x20,0x20,0x40,	/* 0020: @1!   @ */
	0x71,0xF4,0xD2,0x23,0x4B,0xD3,0x73,0x72,	/* 0028: q#Ksr */
	0x71,0x24,0xFA,0x74,0x23,0xFC,0x2F,0x2F,	/* 0030: q$t#.. */
	0x2F,0x4E,0xF6,0x20,0x20,0x22,0x04,0x4D,	/* 0038: .N  ".M */
	0x6F,0x6E,0x20,0x4D,0x61,0x79,0x20,0x31,	/* 0040: on May 1 */
	0x34,0x20,0x31,0x35,0x3A,0x33,0x39,0x3A,	/* 0048: 4 15:39: */
	0x33,0x31,0x20,0x32,0x30,0x30,0x31,0x0A,	/* 0050: 31 2001. */
	0x00,0x6A,0x65,0x74,0x2E,0x65,0x70,0x72,	/* 0058: .jet.epr */
	0x00,0x20,0x20,0x22,0xB0,0x21,0x12,0xDD,	/* 0060: .  "!. */
	0x24,0xF2,0x21,0xF8,0x24,0xF2,0x21,0xFC,	/* 0068: $!$! */
	0x22,0xF9,0x25,0xF8,0x40,0xDE,0x4B,0xDF,	/* 0070: "%@K */
	0x24,0xF2,0x7E,0x24,0xF2,0xFA,0xE0,0x1E,	/* 0078: $~$. */
	0x4B,0x22,0xF1,0x40,0x25,0xF4,0x22,0x46,	/* 0080: K"@%"F */
	0x21,0xFB,0xD0,0x24,0xF2,0xD1,0x24,0x4B,	/* 0088: !$$K */
	0x21,0xFB,0xD2,0x72,0x84,0x21,0xD0,0x72,	/* 0090: !r!r */
	0x30,0x21,0x70,0xF2,0x21,0xD1,0x21,0x71,	/* 0098: 0!p!!q */
	0xD2,0x1B,0xD3,0x7D,0xD4,0x40,0xD5,0x1C,	/* 00A0: .}@. */
	0xD6,0x19,0xD7,0x1A,0xD8,0x21,0x70,0xF6,	/* 00A8: ..!p */
	0x60,0xBC,0x7D,0x27,0x88,0xDD,0x22,0x40,	/* 00B0: `}'"@ */
	0x21,0xFB,0xD0,0x44,0x24,0xF2,0xFA,0xD1,	/* 00B8: !D$ */
	0x24,0xF2,0xD2,0x7B,0x83,0x60,0x4C,0x24,	/* 00C0: ${`L$ */
	0xF6,0x21,0x71,0xF2,0xD3,0x7D,0xD4,0x24,	/* 00C8: !q}$ */
	0xF2,0xD5,0x7A,0x7D,0xF2,0xD6,0x79,0x73,	/* 00D0: z}ys */
	0xF2,0xF6,0x21,0xF5,0x20,0x6E,0x03,0x00,	/* 00D8: ! n.. */
	0x00,0x20,0x61,0xBF,0x40,0xD1,0x40,0xDF,	/* 00E0: . a@@ */
	0x21,0x76,0x67,0x88,0xDE,0x40,0x21,0x74,	/* 00E8: !vg@!t */
	0xE0,0x10,0x23,0x24,0x94,0x28,0x45,0x71,	/* 00F0: .#$(Eq */
	0xF4,0x22,0x2B,0xAD,0x71,0x46,0x24,0xF0,	/* 00F8: "+qF$ */
	0x21,0xD0,0x71,0x23,0x4F,0x24,0xF6,0xD5,	/* 0100: !q#O$ */
	0x21,0x70,0xC0,0x23,0xAF,0x7F,0xA7,0x7D,	/* 0108: !p#} */
	0xD6,0x76,0x75,0xF2,0xDD,0x02,0x7E,0xD6,	/* 0110: vu.~ */
	0x75,0xA6,0x75,0x76,0x10,0x22,0x2F,0x94,	/* 0118: uuv.". */
	0x40,0xD2,0x44,0xD3,0x41,0x72,0x24,0xF1,	/* 0120: @DAr$ */
	0x74,0x24,0xF6,0x21,0xA7,0x11,0x72,0x21,	/* 0128: t$!.r! */
	0x72,0xFA,0x41,0xFB,0x75,0xAE,0x76,0x27,	/* 0130: rAuv' */
	0x88,0xD0,0x70,0x21,0x75,0xF2,0x72,0x21,	/* 0138: p!ur! */
	0x72,0xFA,0x75,0xFB,0x12,0x22,0x45,0x22,	/* 0140: ru."E" */
	0xF1,0x22,0x26,0x07,0x21,0x70,0xC2,0x22,	/* 0148: "&.!p" */
	0x25,0xA7,0x75,0xC0,0xA7,0x41,0xDF,0x40,	/* 0150: %uA@ */
	0xD4,0x22,0x24,0x0C,0x75,0xC9,0xA7,0x41,	/* 0158: "$.uA */
	0xDF,0x40,0xD4,0x22,0x24,0x02,0x75,0xC7,	/* 0160: @"$.u */
	0xA7,0x41,0xDF,0x40,0xD4,0x22,0x23,0x08,	/* 0168: A@"#. */
	0x75,0xC1,0xA7,0x40,0xDF,0x40,0xD4,0x22,	/* 0170: u@@" */
	0x22,0x0E,0x75,0xC2,0x22,0xA7,0x41,0xD0,	/* 0178: ".u"A */
	0x70,0x21,0xAF,0x10,0x22,0x2B,0x92,0x71,	/* 0180: p!."+q */
	0x28,0xC2,0xA4,0x70,0x81,0xD0,0x08,0x71,	/* 0188: (p.q */
	0x28,0xC3,0xA4,0x70,0x60,0x8F,0xD0,0x70,	/* 0190: (p`p */
	0xA7,0x11,0x7C,0x21,0x72,0xFA,0x41,0xFB,	/* 0198: .|!rA */
	0x62,0x0E,0x22,0x20,0x03,0x75,0xC4,0xAC,	/* 01A0: b." .u */
	0x1D,0x10,0x22,0x23,0x9D,0x7D,0x21,0x77,	/* 01A8: .."#}!w */
	0xE0,0x21,0x2F,0x04,0x75,0xC6,0xA9,0x21,	/* 01B0: !..u! */
	0x79,0x10,0x22,0x22,0x9D,0x21,0x2E,0x08,	/* 01B8: y.""!.. */
	0x75,0xCB,0xA9,0x21,0x78,0x10,0x22,0x22,	/* 01C0: u!x."" */
	0x91,0x21,0x2D,0x0C,0x75,0xC8,0xAC,0x1D,	/* 01C8: !-.u. */
	0x10,0x22,0x21,0x96,0x7D,0x21,0x78,0xE0,	/* 01D0: ."!}!x */
	0x21,0x2C,0x0D,0x75,0xCA,0xAC,0x1D,0x10,	/* 01D8: !,.u.. */
	0x22,0x20,0x97,0x7D,0x21,0x79,0xE0,0x21,	/* 01E0: " }!y! */
	0x2B,0x0E,0x75,0xCC,0x2C,0xAB,0x40,0xD6,	/* 01E8: +.u,@ */
	0x40,0xDA,0x40,0xD8,0x7E,0xD7,0x41,0xD6,	/* 01F0: @@~A */
	0x10,0x22,0x23,0x9D,0x23,0x4F,0x71,0xF9,	/* 01F8: ."##Oq */
	0xC0,0xD6,0x76,0x22,0xA8,0x41,0x7A,0xF2,	/* 0200: v"Az */
	0xDA,0x40,0xD2,0x44,0xD3,0x41,0x72,0x24,	/* 0208: @DAr$ */
	0xF1,0x74,0x24,0xF6,0xA7,0x11,0x72,0x21,	/* 0210: t$.r! */
	0x72,0xFA,0x41,0xFB,0x12,0x21,0x44,0x22,	/* 0218: rA.!D" */
	0xF1,0x10,0x22,0x21,0x94,0x23,0x4F,0x71,	/* 0220: ."!#Oq */
	0xF9,0xC0,0xD6,0x62,0x05,0x71,0x23,0x4F,	/* 0228: b.q#O */
	0x24,0xF6,0xD5,0x7A,0x40,0xF9,0x23,0xA3,	/* 0230: $z@# */
	0x75,0xA6,0x75,0x77,0x10,0x21,0x2D,0x94,	/* 0238: uuw.!- */
	0x40,0xD2,0x44,0xD3,0x41,0x72,0x24,0xF1,	/* 0240: @DAr$ */
	0x74,0x24,0xF6,0x21,0xA7,0x11,0x72,0x21,	/* 0248: t$!.r! */
	0x72,0xFA,0x41,0xFB,0x75,0xAE,0x77,0x27,	/* 0250: rAuw' */
	0x88,0xD0,0x70,0x21,0x75,0xF2,0x72,0x21,	/* 0258: p!ur! */
	0x72,0xFA,0x75,0xFB,0x12,0x22,0x45,0x22,	/* 0260: ru."E" */
	0xF1,0x24,0x0C,0x41,0xD6,0x76,0x21,0xAF,	/* 0268: $.Av! */
	0x75,0x77,0x10,0x21,0x29,0x9E,0x77,0x75,	/* 0270: uw.!)wu */
	0xF2,0xD7,0x78,0x75,0xF2,0xD8,0x10,0x21,	/* 0278: xu.! */
	0x2B,0x97,0x23,0x4F,0x71,0xF9,0xD6,0x71,	/* 0280: +#Oqq */
	0x23,0x4F,0x24,0xF6,0xD5,0x62,0x0E,0x40,	/* 0288: #O$b.@ */
	0xD2,0x44,0xD3,0x41,0x72,0x24,0xF1,0x74,	/* 0290: DAr$t */
	0x24,0xF6,0x21,0xA6,0x72,0x21,0x72,0xFA,	/* 0298: $!r!r */
	0x78,0xFE,0x78,0xAE,0x7E,0x27,0x88,0xD0,	/* 02A0: xx~' */
	0x70,0x21,0x75,0xF2,0x72,0x21,0x72,0xFA,	/* 02A8: p!ur!r */
	0x78,0xFB,0x12,0x22,0x44,0x22,0xF1,0x2E,	/* 02B0: x."D". */
	0x0F,0x75,0xCD,0x22,0xAC,0x40,0xD6,0x7A,	/* 02B8: .u"@z */
	0xD7,0x77,0x22,0xA1,0x10,0x21,0x27,0x91,	/* 02C0: w".!' */
	0x40,0xD2,0x44,0xD3,0x41,0x72,0x24,0xF1,	/* 02C8: @DAr$ */
	0x74,0x24,0xF6,0xA7,0x11,0x72,0x21,0x72,	/* 02D0: t$.r!r */
	0xFA,0x41,0xFB,0x12,0x21,0x44,0x22,0xF1,	/* 02D8: A.!D" */
	0x16,0x22,0x41,0x22,0xF1,0x40,0xDA,0x2B,	/* 02E0: ."A"@+ */
	0x0F,0x75,0xCE,0x2B,0xAB,0x40,0xD0,0x40,	/* 02E8: .u+@@ */
	0xD2,0x40,0xD3,0x41,0xD0,0x70,0x22,0xA7,	/* 02F0: @Ap" */
	0x73,0x72,0x46,0x23,0xF6,0xD2,0xD3,0x10,	/* 02F8: srF#. */
	0x21,0x23,0x96,0x71,0x23,0x4F,0x24,0xF6,	/* 0300: !#q#O$ */
	0x21,0xFD,0xD8,0xD9,0x40,0x72,0x78,0x23,	/* 0308: !@rx# */
	0xF7,0xD2,0x73,0x79,0x23,0xF7,0xD3,0x2C,	/* 0310: sy#, */
	0x40,0x71,0xF9,0xC0,0xD0,0x62,0x06,0x28,	/* 0318: @qb.( */
	0x20,0x40,0xD6,0x40,0xD7,0x73,0x77,0xF9,	/* 0320:  @@sw */
	0xC0,0xAB,0x73,0x77,0xF4,0xC0,0xA7,0x41,	/* 0328: swA */
	0x72,0x76,0x24,0xFF,0xF0,0xC0,0x27,0xA0,	/* 0330: rv$' */
	0x73,0x77,0xF9,0xC0,0xAB,0x73,0x77,0xF4,	/* 0338: swsw */
	0xC0,0xA7,0x41,0x72,0x76,0x24,0xFF,0xF0,	/* 0340: Arv$ */
	0xC0,0x25,0xAD,0x40,0x72,0x76,0x24,0xFF,	/* 0348: %@rv$ */
	0xD8,0x73,0x77,0x24,0xFF,0xD9,0x79,0x40,	/* 0350: sw$y@ */
	0xF9,0xC0,0xAC,0x79,0xC0,0xAA,0x41,0x78,	/* 0358: yAx */
	0x27,0x2F,0x2F,0x4F,0x24,0xFF,0xF0,0xC0,	/* 0360: '..O$ */
	0x21,0xAF,0x76,0xD0,0x2F,0x4F,0x70,0x24,	/* 0368: !v.Op$ */
	0xF2,0xF2,0x27,0x2F,0x2F,0x4F,0xF0,0x24,	/* 0370: '..O$ */
	0x94,0x40,0x76,0x27,0x2F,0x2F,0x4F,0x23,	/* 0378: @v'..O# */
	0xF7,0xD6,0x77,0x40,0x23,0xF7,0xD7,0x21,	/* 0380: w@#! */
	0x0D,0x76,0xDB,0x40,0x72,0x76,0x24,0xFF,	/* 0388: .v@rv$ */
	0xD8,0x73,0x77,0x24,0xFF,0xD9,0x78,0xD0,	/* 0390: sw$x */
	0x2F,0x4F,0x7B,0x24,0xF2,0xF2,0x70,0xF0,	/* 0398: .O{$p */
	0x21,0x9B,0x72,0xD6,0x73,0xD7,0x66,0x00,	/* 03A0: !rsf. */
	0x0A,0x75,0xDC,0x41,0x7C,0x24,0xF1,0x74,	/* 03A8: .uA|$t */
	0x24,0xFB,0xD4,0x10,0x28,0x93,0x62,0x23,	/* 03B0: $.(b# */
	0x0C,0x21,0xB1,0x22,0xF0,0x60,0xBE,0x41,	/* 03B8: .!"`A */
	0xD0,0x70,0xD1,0x75,0x73,0x23,0xFB,0x74,	/* 03C0: pus#t */
	0x71,0xF9,0x21,0xAB,0x70,0x74,0x71,0xF4,	/* 03C8: q!ptq */
	0xF9,0xA4,0x74,0x71,0xF4,0xD0,0x73,0x71,	/* 03D0: tqsq */
	0x73,0xF2,0x70,0x24,0xFA,0x71,0x70,0xF2,	/* 03D8: sp$qp */
	0xD1,0x70,0x70,0xF2,0xD0,0x61,0x00,0xB2,	/* 03E0: ppa. */
	0x22,0xF0,0x40,0xD3,0x40,0x72,0xE0,0x41,	/* 03E8: "@@rA */
	0xD3,0x73,0x21,0xAE,0x72,0x30,0x46,0x24,	/* 03F0: s!r0F$ */
	0xF1,0x72,0xE0,0x71,0x23,0x9B,0x71,0x31,	/* 03F8: rq#q1 */
	0x23,0x4F,0x24,0xF6,0x72,0x30,0xF2,0x72,	/* 0400: #O$r0r */
	0xE0,0x2C,0x40,0x71,0x31,0xF9,0xC0,0xD3,	/* 0408: ,@q1 */
	0x62,0x0F,0x22,0xF0,0x60,0xBE,0x74,0x27,	/* 0410: b."`t' */
	0x88,0xD0,0x73,0x21,0x34,0x30,0xD1,0x71,	/* 0418: s!40q */
	0x73,0x21,0x33,0xF2,0x70,0x73,0x21,0x35,	/* 0420: s!3ps!5 */
	0xF2,0x75,0x24,0xFA,0x73,0x21,0x34,0x30,	/* 0428: u$s!40 */
	0x75,0xF5,0x73,0x21,0x34,0xE0,0xB2,0x22,	/* 0430: us!4" */
	0xF0,0x71,0x21,0x34,0x30,0x71,0x21,0x33,	/* 0438: q!40q!3 */
	0xF2,0xF1,0x71,0xE1,0x71,0x21,0x34,0x30,	/* 0440: qq!40 */
	0x81,0x71,0x21,0x34,0xE0,0x22,0xF0,0x8A,	/* 0448: q!4" */
	0xF1,0x22,0x89,0x3C,0x00,0x00,0x07,0x00,	/* 0450: "<.... */
	0x00,0x08,0x00,0x00,0x00,0x81,0x00,0x80,	/* 0458: ...... */
	0xFF,0x7F,0xFF,0x7F,0xFA,0x8D,0xB6,0x8D,	/* 0460:  */
	0x7C,0x8D,0xFF,0x80,0x00,0x00,0x02,0x00,	/* 0468: |.... */
	0x01,0x00,0x6E,0x00,0x68,0x4D,0x69,0x4D,	/* 0470: ..n.hMiM */
	0x10,0x00,0x06,0x00,0x34,0x81,0x00,0x00,	/* 0478: ....4.. */
	0xFF,0x80,0x00,0x00,0xFF,0x80,0x00,0x00,	/* 0480: .... */
	0xFF,0x80,0xFF,0x80,0x62,0x8D,0x03,0x00,	/* 0488: b.. */
	0x3C,0x02,0x00,0x02,0x00,0x11,0x00,0xB2,	/* 0490: <...... */
	0x8D,0x02,0x00,0x12,0x00,0x7C,0x8D,0x02,	/* 0498: ....|. */
	0x00,0x13,0x00,0xFF,0x80,0x60,0xBC,0x21,	/* 04A0: ...`! */
	0xF5,0x00,0x00,0x00,0x00,0xBE,0x4C,0x00,	/* 04A8: ....L. */
	0x00,0x08,0x40,0xC6,0x02,0x06,0x00,0xC6,	/* 04B0: ..@... */
	0x83,0x00,0x00,0xFF,0x80,0x92,0x01,0xD0,	/* 04B8: ... */
	0x83,0x00,0x08,0x62,0x85,0xFF,0x80,0x62,	/* 04C0: ..bb */
	0x8D,0x04,0x00,0x04,0x00,0x20,0x02,0x00,	/* 04C8: .... .. */
	0x11,0x00,0xF6,0x8D,0x02,0x00,0x12,0x00,	/* 04D0: ...... */
	0xB6,0x8D,0x02,0x00,0x13,0x00,0xFF,0x80,	/* 04D8: .... */
	0x02,0x00,0x04,0x00,0xF2,0x8D,0x00,0x00,	/* 04E0: ...... */
	0x00,0x00,0x60,0xBC,0x21,0xF5,0x8A,0x34,	/* 04E8: ..`!4 */
	0x89,0x06,0xB2,0x8D,0x7C,0x8D,0xFF,0x80,	/* 04F0: .| */
	0x8A,0xCB,0x06,0x89,0x06,0xF6,0x8D,0xB6,	/* 04F8: .. */
	0x8D,0xFF,0x80,0x86,0xF1,0x22,0x8B,0xC4,	/* 0500: " */
	0xF2,0x3E,0x85,0x60,0xBC,0x75,0xD3,0x73,	/* 0508: >`us */
	0x2A,0x36,0x2C,0x48,0xF4,0x75,0x2D,0x96,	/* 0510: *6,Hu- */
	0xA5,0x28,0x4E,0x75,0x2F,0x99,0x26,0x44,	/* 0518: (Nu.&D */
	0xD0,0x73,0x51,0x73,0x75,0x29,0x91,0xA5,	/* 0520: sQsu) */
	0x28,0x41,0x75,0x2E,0x9A,0x73,0x31,0xD0,	/* 0528: (Au.s1 */
	0x26,0x44,0xD1,0x40,0xD2,0x22,0x21,0x47,	/* 0530: &D@"!G */
	0x21,0xFB,0x73,0x30,0x75,0x24,0x20,0x2E,	/* 0538: !s0u$ . */
	0x92,0xA5,0x29,0x44,0x75,0x2D,0x90,0x2C,	/* 0540: )Du-, */
	0x48,0xD0,0x73,0x53,0x73,0x52,0x75,0x26,	/* 0548: HsSsRu& */
	0x97,0xA5,0x28,0x45,0x75,0x2C,0x90,0x73,	/* 0550: (Eu,s */
	0x33,0xD0,0x2C,0x48,0xD1,0x40,0xD2,0x22,	/* 0558: 3,H@" */
	0x21,0x47,0x21,0xFB,0x73,0x32,0x75,0x24,	/* 0560: !G!s2u$ */
	0x20,0x2B,0x98,0xA5,0x28,0x45,0x75,0x2A,	/* 0568:  +(Eu* */
	0x96,0x75,0x21,0x23,0x9E,0x40,0xB4,0x22,	/* 0570: u!#@" */
	0xF0,0x03,0x00,0x02,0x00,0x01,0x00,0x00,	/* 0578: ....... */
	0x00,0xA4,0x00,0x71,0xD2,0x72,0x61,0x4F,	/* 0580: ..qraO */
	0x21,0xFB,0x44,0x24,0x26,0x29,0x96,0x22,	/* 0588: !D$&)" */
	0xF0,0x60,0xBE,0x73,0x58,0xD0,0x41,0x74,	/* 0590: `sXAt */
	0x70,0x60,0x3E,0x24,0xFF,0xF0,0x21,0xA3,	/* 0598: p`>$! */
	0x70,0x30,0x74,0x70,0x30,0xF2,0x70,0xE0,	/* 05A0: p0tp0p */
	0x70,0x60,0x3E,0x74,0xF4,0x70,0x60,0xEE,	/* 05A8: p`>tp` */
	0xB2,0x22,0xF0,0x24,0xF2,0xB2,0x22,0xF0,	/* 05B0: "$" */
	0x60,0xBF,0x75,0xC0,0xA4,0x24,0x20,0x40,	/* 05B8: `u$ @ */
	0xD5,0x21,0x40,0x72,0x63,0x9B,0x73,0xE0,	/* 05C0: !@rcs */
	0x75,0x72,0x63,0x95,0x74,0xE0,0x73,0x30,	/* 05C8: urcts0 */
	0x24,0xF2,0xF4,0x21,0xA5,0x74,0x30,0x24,	/* 05D0: $!t0$ */
	0xF2,0xF4,0xAF,0x75,0xD0,0x2A,0x45,0x74,	/* 05D8: u*Et */
	0x30,0x72,0x24,0x2A,0x28,0x95,0x40,0xB1,	/* 05E0: 0r$*(@ */
	0x22,0xF0,0x41,0xB1,0x22,0xF0,0x60,0xBE,	/* 05E8: "A"` */
	0x73,0x58,0xD0,0x74,0x73,0x24,0x28,0x24,	/* 05F0: sXts$($ */
	0x94,0x25,0xFA,0x70,0xE0,0x24,0xF2,0xF4,	/* 05F8: %p$ */
	0x21,0xA0,0x74,0x70,0xE1,0x74,0x70,0x60,	/* 0600: !tptp` */
	0xEE,0x70,0x31,0x70,0x60,0xEF,0x40,0xB2,	/* 0608: p1p`@ */
	0x22,0xF0,0x28,0x4E,0xB2,0x22,0xF0,0x72,	/* 0610: "(N"r */
	0x21,0x20,0x40,0xE0,0x71,0x24,0x21,0x26,	/* 0618: ! @q$!& */
	0x95,0x22,0xF0,0x00,0x00,0x78,0x00,0x71,	/* 0620: "..x.q */
	0x58,0xD2,0x72,0x60,0x44,0x21,0xFB,0x41,	/* 0628: Xr`D!A */
	0x24,0x25,0x2F,0x91,0x22,0xF0,0x20,0x43,	/* 0630: $%." C */
	0x6F,0x70,0x79,0x72,0x69,0x67,0x68,0x74,	/* 0638: opyright */
	0x20,0x28,0x63,0x29,0x20,0x50,0x65,0x72,	/* 0640:  (c) Per */
	0x6C,0x65,0x20,0x53,0x79,0x73,0x74,0x65,	/* 0648: le Syste */
	0x6D,0x73,0x20,0x4C,0x74,0x64,0x20,0x31,	/* 0650: ms Ltd 1 */
	0x39,0x39,0x36,0x2D,0x32,0x30,0x30,0x30,	/* 0658: 996-2000 */
	0x2E,0x0D,0x0A,0x4A,0x45,0x54,0x5F,0x5F,	/* 0660: ...JET__ */
	0x2E,0x42,0x49,0x4E,0x20,0x56,0x65,0x72,	/* 0668: .BIN Ver */
	0x73,0x69,0x6F,0x6E,0x20,0x34,0x2E,0x30,	/* 0670: sion 4.0 */
	0x2E,0x35,0x20,0x43,0x72,0x65,0x61,0x74,	/* 0678: .5 Creat */
	0x65,0x64,0x20,0x4D,0x61,0x79,0x20,0x31,	/* 0680: ed May 1 */
	0x34,0x20,0x32,0x30,0x30,0x31,0x20,0x40,	/* 0688: 4 2001 @ */
	0x20,0x31,0x35,0x3A,0x33,0x39,0x3A,0x31,	/* 0690:  15:39:1 */
	0x38,0x00,0x45,0x30,0x20,0xA2,0x00,0x71,	/* 0698: 8.E0 .q */
	0x5A,0xD2,0x60,0x44,0x21,0xFB,0x72,0x42,	/* 06A0: Z`D!rB */
	0x24,0xFA,0x67,0x49,0x21,0xFB,0x72,0xE1,	/* 06A8: $gI!r */
	0x22,0xF0,0x20,0x60,0xBE,0x73,0x5C,0xD1,	/* 06B0: " `s\ */
	0x40,0x71,0xE0,0x27,0x20,0x20,0x40,0xD0,	/* 06B8: @q'  @ */
	0x40,0x40,0x73,0x24,0x29,0x2A,0x94,0x21,	/* 06C0: @@s$)*! */
	0x20,0x40,0xD0,0x40,0x27,0x2E,0x20,0x40,	/* 06C8:  @@'. @ */
	0x73,0x24,0x29,0x29,0x96,0x24,0x40,0x71,	/* 06D0: s$))$@q */
	0x30,0x81,0x23,0xFB,0x71,0x60,0x3E,0x71,	/* 06D8: 0#q`>q */
	0x30,0xE2,0x26,0x44,0x71,0x30,0xE1,0x73,	/* 06E0: 0&Dq0s */
	0x22,0x2C,0x28,0x95,0x71,0x30,0x23,0xFB,	/* 06E8: ",(q0# */
	0x71,0x30,0xF1,0x41,0xF4,0xC0,0x23,0xA9,	/* 06F0: q0A# */
	0x71,0x60,0x34,0x73,0x24,0x2A,0x25,0x95,	/* 06F8: q`4s$*% */
	0x28,0x40,0x54,0xF1,0x2F,0x40,0x24,0xF6,	/* 0700: (@T.@$ */
	0x21,0xAC,0x41,0x71,0x27,0x37,0x40,0x24,	/* 0708: !Aq'7@$ */
	0xFF,0xF0,0xC0,0xA5,0x71,0x27,0x36,0x21,	/* 0710: q'6! */
	0xA3,0x71,0x60,0x36,0x73,0x24,0x2A,0x21,	/* 0718: q`6s$*! */
	0x96,0x73,0x22,0x2C,0x9C,0x0B,0x73,0x22,	/* 0720: s",.s" */
	0x25,0x2E,0x97,0x05,0x73,0x21,0x27,0x2D,	/* 0728: %..s!'- */
	0x92,0x21,0x20,0x40,0x30,0x41,0xF2,0x21,	/* 0730: ! @0A! */
	0x20,0x40,0xE0,0x60,0x04,0x00,0x00,0x0E,	/* 0738:  @`.... */
	0x17,0x71,0x5C,0xD2,0x72,0x60,0x44,0x21,	/* 0740: .q\r`D! */
	0xFB,0x41,0x24,0x24,0x2D,0x97,0x22,0xF0,	/* 0748: A$$-" */
	0x20,0x60,0xBF,0x72,0x5D,0xD0,0x70,0x60,	/* 0750:  `r]p` */
	0x3F,0x31,0x21,0xA1,0x40,0x23,0x2D,0x20,	/* 0758: ?1!@#-  */
	0x49,0x70,0x60,0x3F,0x31,0x21,0xFA,0x72,	/* 0760: Ip`?1!r */
	0x24,0x20,0x21,0x90,0x07,0x29,0x4C,0x72,	/* 0768: $ !.)Lr */
	0x24,0x20,0x20,0x98,0x72,0x22,0x2F,0x25,	/* 0770: $  r".% */
	0x92,0x62,0x0B,0x24,0xF2,0x58,0x71,0x23,	/* 0778: b.$Xq# */
	0x2E,0x22,0x98,0x71,0x22,0x2F,0x2D,0x91,	/* 0780: ."q".- */
	0x40,0x27,0x28,0x20,0x40,0xE0,0x61,0x0B,	/* 0788: @'( @a. */
	0x20,0x60,0xBF,0x41,0x73,0x23,0x28,0x26,	/* 0790:  `As#(& */
	0xE6,0x43,0x73,0x23,0x28,0x26,0xE8,0x40,	/* 0798: Cs#(&@ */
	0x73,0x23,0x28,0x27,0xE4,0x42,0x73,0x23,	/* 07A0: s#('Bs# */
	0x28,0x26,0xE8,0x40,0x73,0x23,0x28,0x27,	/* 07A8: (&@s#(' */
	0xE4,0x41,0x73,0x23,0x28,0x26,0xE8,0x40,	/* 07B0: As#(&@ */
	0x73,0x23,0x28,0x27,0xE4,0x40,0x73,0x23,	/* 07B8: s#('@s# */
	0x28,0x26,0xE8,0x40,0x73,0x23,0x28,0x27,	/* 07C0: (&@s#(' */
	0xE4,0x43,0x73,0x23,0x28,0x26,0xE8,0x40,	/* 07C8: Cs#(&@ */
	0x73,0x23,0x28,0x27,0xEA,0x42,0x73,0x23,	/* 07D0: s#('Bs# */
	0x28,0x26,0xE8,0x40,0x73,0x23,0x28,0x27,	/* 07D8: (&@s#(' */
	0xEA,0x41,0x73,0x23,0x28,0x26,0xE8,0x40,	/* 07E0: As#(&@ */
	0x73,0x23,0x28,0x27,0xEA,0x40,0x73,0x23,	/* 07E8: s#('@s# */
	0x28,0x26,0xE8,0x40,0x73,0x23,0x28,0x27,	/* 07F0: (&@s#(' */
	0xEA,0x44,0x73,0x23,0x28,0x26,0xE8,0x2A,	/* 07F8: Ds#(&* */
	0x48,0x73,0x23,0x28,0x26,0xED,0x40,0x73,	/* 0800: Hs#(&@s */
	0x23,0x28,0x26,0xEE,0x40,0x73,0x23,0x28,	/* 0808: #(&@s#( */
	0x26,0xEF,0x41,0x73,0x23,0x28,0x26,0xEC,	/* 0810: &As#(& */
	0x43,0x73,0x23,0x28,0x26,0xE6,0x43,0x73,	/* 0818: Cs#(&Cs */
	0x23,0x28,0x26,0xE6,0x43,0x73,0x23,0x28,	/* 0820: #(&Cs#( */
	0x26,0xE6,0x44,0x73,0x23,0x28,0x26,0xE8,	/* 0828: &Ds#(& */
	0x2A,0x48,0x73,0x23,0x28,0x26,0xED,0x22,	/* 0830: *Hs#(&" */
	0x40,0x73,0x23,0x28,0x26,0xEE,0x40,0x73,	/* 0838: @s#(&@s */
	0x23,0x28,0x26,0xEF,0x43,0x73,0x23,0x28,	/* 0840: #(&Cs#( */
	0x26,0xE6,0x43,0x73,0x23,0x28,0x26,0xE6,	/* 0848: &Cs#(& */
	0x43,0x73,0x23,0x28,0x26,0xE6,0x40,0x73,	/* 0850: Cs#(&@s */
	0x23,0x28,0x26,0xEC,0x40,0xD0,0x43,0x73,	/* 0858: #(&@Cs */
	0x23,0x28,0x26,0xE6,0x70,0x81,0xD0,0x21,	/* 0860: #(&p! */
	0x40,0x70,0xF9,0xA2,0x60,0x00,0x44,0x73,	/* 0868: @p`.Ds */
	0x23,0x28,0x26,0xE8,0x40,0x73,0x23,0x28,	/* 0870: #(&@s#( */
	0x26,0xED,0x22,0x40,0x73,0x23,0x28,0x26,	/* 0878: &"@s#(& */
	0xEE,0x43,0x73,0x23,0x28,0x26,0xEF,0x41,	/* 0880: Cs#(&A */
	0x73,0x23,0x28,0x26,0xEC,0x43,0x73,0x23,	/* 0888: s#(&Cs# */
	0x28,0x26,0xE6,0x43,0x73,0x23,0x28,0x26,	/* 0890: (&Cs#(& */
	0xE6,0x43,0x73,0x23,0x28,0x26,0xE6,0x43,	/* 0898: Cs#(&C */
	0x73,0x23,0x28,0x26,0xE6,0x40,0x73,0x23,	/* 08A0: s#(&@s# */
	0x28,0x26,0xEC,0x40,0x73,0x23,0x28,0x26,	/* 08A8: (&@s#(& */
	0xE6,0x40,0x73,0x23,0x28,0x26,0xE8,0x26,	/* 08B0: @s#(&& */
	0x44,0x72,0x23,0x2E,0x2B,0x9E,0xB1,0x22,	/* 08B8: Dr#.+" */
	0xF0,0x60,0xBE,0x40,0xD0,0x74,0x31,0xD1,	/* 08C0: `@t1 */
	0x74,0x87,0xF1,0x74,0x32,0x27,0x2F,0x2F,	/* 08C8: tt2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x74,0x87,	/* 08D0: O$#t */
	0xF1,0x71,0x23,0x28,0x27,0xEF,0x74,0x87,	/* 08D8: q#('t */
	0xF1,0x43,0x24,0xF6,0x71,0x23,0x28,0x26,	/* 08E0: C$q#(& */
	0xE8,0x71,0x23,0x28,0x26,0x3C,0x2F,0x4F,	/* 08E8: q#(&<.O */
	0x24,0xF6,0x74,0x21,0x53,0xF1,0x24,0xF6,	/* 08F0: $t!S$ */
	0x25,0xFA,0xD1,0x28,0x40,0x24,0xF6,0xA5,	/* 08F8: %(@$ */
	0x70,0x44,0x24,0xFB,0xD0,0x71,0x22,0x40,	/* 0900: pD$q"@ */
	0x24,0xF6,0xA6,0x70,0x24,0x40,0x24,0xFB,	/* 0908: $p$@$ */
	0xD0,0x71,0x21,0x40,0x24,0xF6,0xA6,0x70,	/* 0910: q!@$p */
	0x22,0x40,0x24,0xFB,0xD0,0x71,0x24,0x40,	/* 0918: "@$q$@ */
	0x24,0xF6,0xA5,0x70,0x42,0x24,0xFB,0xD0,	/* 0920: $pB$ */
	0x70,0x74,0x5C,0x23,0xFB,0xB2,0x22,0xF0,	/* 0928: pt\#" */
	0x60,0xBD,0x40,0xD2,0x72,0x44,0xF8,0x75,	/* 0930: `@rDu */
	0x23,0x28,0x27,0xEF,0x75,0x74,0x61,0x25,	/* 0938: #('uta% */
	0x90,0x72,0x21,0xA3,0x75,0x23,0x28,0x27,	/* 0940: r!u#(' */
	0x3F,0x2F,0x4F,0x24,0xF6,0x44,0x24,0xF0,	/* 0948: ?.O$D$ */
	0xD1,0x75,0x23,0x28,0x27,0x3F,0x0E,0x75,	/* 0950: u#('?.u */
	0x23,0x28,0x27,0x3F,0x47,0x24,0xF6,0xD1,	/* 0958: #('?G$ */
	0x75,0x23,0x28,0x27,0x3F,0x71,0x45,0xF4,	/* 0960: u#('?qE */
	0xA7,0x40,0x75,0x23,0x28,0x24,0xEB,0x07,	/* 0968: @u#($. */
	0x28,0x40,0x75,0x23,0x28,0x24,0xEB,0x22,	/* 0970: (@u#($" */
	0x47,0x75,0x23,0x28,0x27,0xEE,0x40,0xD0,	/* 0978: Gu#('@ */
	0x70,0x75,0x23,0x28,0x26,0xE8,0x70,0xC0,	/* 0980: pu#(&p */
	0x22,0xA8,0x71,0x45,0xF4,0xC0,0x22,0xA2,	/* 0988: "qE" */
	0x40,0x75,0x23,0x28,0x27,0xE6,0x24,0x44,	/* 0990: @u#('$D */
	0x75,0x23,0x28,0x24,0x30,0x2F,0x4F,0x24,	/* 0998: u#($0.O$ */
	0xF6,0xF9,0xA8,0x24,0x42,0x75,0x23,0x28,	/* 09A0: $Bu#( */
	0x27,0xE2,0x07,0x21,0x4F,0x75,0x23,0x28,	/* 09A8: '.!Ou#( */
	0x27,0xE2,0x70,0x81,0xD0,0x44,0x70,0xF9,	/* 09B0: 'pDp */
	0xA3,0x20,0x63,0x04,0x40,0x75,0x23,0x28,	/* 09B8:  c.@u#( */
	0x21,0xE8,0x40,0x75,0x23,0x28,0x26,0xEC,	/* 09C0: !@u#(& */
	0x40,0x75,0x23,0x28,0x26,0xED,0x75,0x23,	/* 09C8: @u#(&u# */
	0x28,0x20,0x35,0x2F,0x4F,0x24,0xF6,0xAD,	/* 09D0: ( 5.O$ */
	0x75,0x23,0x28,0x20,0x35,0x2F,0x4F,0x24,	/* 09D8: u#( 5.O$ */
	0xF6,0xA3,0x20,0x60,0x03,0x72,0x81,0xD2,	/* 09E0:  `.r */
	0x42,0x72,0xF9,0xA2,0x6B,0x06,0xB3,0x22,	/* 09E8: Brk." */
	0xF0,0x60,0xBB,0x76,0x23,0x59,0xD4,0x21,	/* 09F0: `v#Y! */
	0x28,0x40,0xD1,0x41,0x27,0x28,0x28,0x40,	/* 09F8: (@A'((@ */
	0xE0,0x74,0x62,0x33,0x87,0xF1,0x81,0x74,	/* 0A00: tb3t */
	0x62,0x33,0x87,0x23,0xFB,0x41,0x27,0x28,	/* 0A08: b3#A'( */
	0x28,0x40,0xE0,0x71,0x21,0x37,0xD1,0x40,	/* 0A10: (@q!7@ */
	0x27,0x28,0x28,0x40,0xE0,0x71,0x57,0xF1,	/* 0A18: '((@qW */
	0x25,0xFA,0xD0,0xAD,0x70,0x74,0xFA,0x30,	/* 0A20: %pt0 */
	0xD2,0x71,0x76,0x21,0x22,0x2E,0x9C,0x62,	/* 0A28: qv!".b */
	0xA0,0x71,0x31,0xD3,0x71,0x34,0xD2,0x70,	/* 0A30: q1q4p */
	0xC0,0x25,0xA1,0x72,0x41,0x24,0xF6,0xC0,	/* 0A38: %rA$ */
	0x24,0xAA,0x71,0x8D,0xF1,0x71,0x56,0xF1,	/* 0A40: $qqV */
	0xF4,0x24,0xA1,0x72,0x41,0x24,0xFB,0x25,	/* 0A48: $rA$% */
	0xFA,0xD2,0x71,0xE4,0x71,0x87,0xF1,0x71,	/* 0A50: qqq */
	0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,0x89,	/* 0A58: 2'..O$ */
	0x23,0xFB,0x71,0x87,0xF1,0x73,0x23,0x28,	/* 0A60: #qs#( */
	0x27,0xEF,0x71,0x87,0xF1,0x43,0x24,0xF6,	/* 0A68: 'qC$ */
	0x73,0x23,0x28,0x26,0xE8,0x73,0x23,0x28,	/* 0A70: s#(&s#( */
	0x20,0x36,0x2F,0x4F,0x24,0xF6,0x44,0x24,	/* 0A78:  6.O$D$ */
	0xFB,0x73,0x23,0x28,0x20,0xE6,0x41,0x71,	/* 0A80: s#( Aq */
	0x22,0x89,0x23,0xFB,0x72,0x21,0x40,0x24,	/* 0A88: "#r!@$ */
	0xF6,0x2E,0xAC,0x72,0x28,0x40,0x24,0xF6,	/* 0A90: .r(@$ */
	0x24,0xAA,0x71,0x87,0xF1,0x71,0x32,0x27,	/* 0A98: $qq2' */
	0x2F,0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,	/* 0AA0: ..O$# */
	0x71,0x87,0xF1,0x73,0x23,0x28,0x27,0xEF,	/* 0AA8: qs#(' */
	0x71,0x87,0xF1,0x43,0x24,0xF6,0x73,0x23,	/* 0AB0: qC$s# */
	0x28,0x26,0xE8,0x73,0x23,0x28,0x20,0x35,	/* 0AB8: (&s#( 5 */
	0x2F,0x4F,0x24,0xF6,0xC0,0x2B,0xA5,0x40,	/* 0AC0: .O$+@ */
	0xD0,0x21,0x20,0x40,0x71,0x76,0x2E,0x2A,	/* 0AC8: ! @qv.* */
	0x92,0x22,0x42,0x73,0x23,0x28,0x20,0xE5,	/* 0AD0: "Bs#(  */
	0x72,0x22,0x40,0x24,0xFB,0x6C,0x4F,0x24,	/* 0AD8: r"@$lO$ */
	0xF6,0xD2,0x29,0x08,0x41,0x71,0x55,0xF1,	/* 0AE0: ).AqU */
	0x71,0x8B,0xF1,0xFC,0x2F,0x4F,0x24,0xF6,	/* 0AE8: q.O$ */
	0x24,0x40,0xF0,0x24,0xFF,0xF0,0xC0,0x28,	/* 0AF0: $@$( */
	0xA3,0x71,0x87,0xF1,0x71,0x32,0x27,0x2F,	/* 0AF8: qq2'. */
	0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,0x71,	/* 0B00: .O$#q */
	0x87,0xF1,0x73,0x23,0x28,0x27,0xEF,0x71,	/* 0B08: s#('q */
	0x87,0xF1,0x43,0x24,0xF6,0x73,0x23,0x28,	/* 0B10: C$s#( */
	0x26,0xE8,0x73,0x23,0x28,0x20,0x35,0x2F,	/* 0B18: &s#( 5. */
	0x4F,0x24,0xF6,0xC0,0x25,0xA6,0x71,0x21,	/* 0B20: O$%q! */
	0x58,0xF1,0x48,0x24,0xF6,0x21,0xA9,0x21,	/* 0B28: XH$!! */
	0x20,0x40,0xD0,0x21,0x20,0x40,0x71,0x76,	/* 0B30:  @! @qv */
	0x2E,0x23,0x98,0x22,0x41,0x73,0x23,0x28,	/* 0B38: .#"As#( */
	0x20,0xE5,0x72,0x66,0x4F,0x24,0xF6,0xD2,	/* 0B40:  rfO$ */
	0x71,0x23,0x81,0xF1,0x28,0x40,0x24,0xF6,	/* 0B48: q#(@$ */
	0xAE,0x21,0x20,0x20,0x40,0xD0,0x21,0x20,	/* 0B50: !  @!  */
	0x20,0x40,0x71,0x76,0x2E,0x21,0x94,0x71,	/* 0B58:  @qv.!q */
	0x21,0x58,0xF1,0x24,0x40,0x24,0xF6,0xAE,	/* 0B60: !X$@$ */
	0x22,0x20,0x20,0x40,0xD0,0x22,0x20,0x20,	/* 0B68: "  @"   */
	0x40,0x71,0x76,0x2D,0x2F,0x9D,0x72,0x61,	/* 0B70: @qv-.ra */
	0x4F,0x24,0xF6,0xD2,0x72,0x71,0xE4,0x71,	/* 0B78: O$rqq */
	0x22,0x50,0xF1,0x21,0x40,0x24,0xF6,0x22,	/* 0B80: "P!@$" */
	0xA7,0x71,0x87,0xF1,0x71,0x32,0x27,0x2F,	/* 0B88: qq2'. */
	0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,0x71,	/* 0B90: .O$#q */
	0x87,0xF1,0x73,0x23,0x28,0x27,0xEF,0x71,	/* 0B98: s#('q */
	0x87,0xF1,0x43,0x24,0xF6,0x73,0x23,0x28,	/* 0BA0: C$s#( */
	0x26,0xE8,0x71,0x76,0x23,0x28,0x2B,0x9F,	/* 0BA8: &qv#(+ */
	0x61,0x24,0x0E,0x60,0xBA,0x78,0x31,0xD1,	/* 0BB0: a$.`x1 */
	0x78,0x34,0xD2,0x78,0x24,0x85,0xF1,0xC0,	/* 0BB8: x4x$ */
	0xA7,0x2F,0x4F,0x78,0x24,0x85,0x23,0xFB,	/* 0BC0: .Ox$# */
	0x78,0x87,0xF1,0x78,0x32,0x27,0x2F,0x2F,	/* 0BC8: xx2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x78,0x87,	/* 0BD0: O$#x */
	0xF1,0x71,0x23,0x28,0x27,0xEF,0x78,0x87,	/* 0BD8: q#('x */
	0xF1,0x43,0x24,0xF6,0x71,0x23,0x28,0x26,	/* 0BE0: C$q#(& */
	0xE8,0x78,0x21,0x8F,0xF1,0x23,0xA8,0x78,	/* 0BE8: x!#x */
	0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,0xD0,	/* 0BF0: 2'..O$ */
	0x78,0x87,0xF1,0x43,0xF9,0x21,0xA2,0x70,	/* 0BF8: xC!p */
	0x21,0x8D,0xF1,0x81,0x70,0x21,0x8D,0x23,	/* 0C00: !p!# */
	0xFB,0x22,0x44,0x71,0x23,0x28,0x27,0xEF,	/* 0C08: "Dq#(' */
	0x0E,0x70,0x5E,0xF1,0x81,0x70,0x5E,0x23,	/* 0C10: .p^p^# */
	0xFB,0x48,0x71,0x23,0x28,0x27,0xEF,0x40,	/* 0C18: Hq#('@ */
	0x78,0x21,0x8F,0x23,0xFB,0x25,0x0A,0x78,	/* 0C20: x!#%.x */
	0x24,0x85,0xF1,0x22,0x43,0x24,0xF6,0x25,	/* 0C28: $"C$% */
	0xA0,0x78,0x21,0x58,0xF1,0x42,0x24,0xF6,	/* 0C30: x!XB$ */
	0xAB,0x71,0x23,0x28,0x20,0x3B,0x44,0x24,	/* 0C38: q#( ;D$ */
	0xF6,0xC0,0x23,0xA6,0x78,0x21,0x59,0xF1,	/* 0C40: #x!Y */
	0x21,0x40,0x24,0xF6,0xAB,0x71,0x23,0x28,	/* 0C48: !@$q#( */
	0x26,0x3C,0x24,0x40,0x24,0xF6,0x22,0xA2,	/* 0C50: &<$@$" */
	0x78,0x21,0x58,0xF1,0x21,0x40,0x24,0xF6,	/* 0C58: x!X!@$ */
	0xAA,0x71,0x23,0x28,0x26,0x3C,0x21,0x40,	/* 0C60: q#(&<!@ */
	0x24,0xF6,0xAF,0x72,0x22,0x20,0x40,0x24,	/* 0C68: $r" @$ */
	0xF6,0xC0,0xA7,0x20,0x78,0x22,0x85,0xF1,	/* 0C70:  x" */
	0x21,0xA6,0x72,0x62,0x2F,0x4F,0x24,0xF6,	/* 0C78: !rb.O$ */
	0xD2,0x71,0x23,0x28,0x20,0x35,0x2F,0x4F,	/* 0C80: q#( 5.O */
	0x24,0xF6,0x22,0xA9,0x40,0xB6,0x22,0xF0,	/* 0C88: $"@" */
	0x72,0x21,0x20,0x40,0x24,0xFB,0x41,0x24,	/* 0C90: r! @$A$ */
	0xFB,0x78,0xE4,0x78,0x22,0x87,0xF1,0xAA,	/* 0C98: xx" */
	0x20,0x28,0x44,0x71,0x23,0x28,0x20,0xE6,	/* 0CA0:  (Dq#(  */
	0x08,0x20,0x29,0x42,0x71,0x23,0x28,0x20,	/* 0CA8: . )Bq#(  */
	0xE6,0x41,0xB6,0x22,0xF0,0x78,0x22,0x85,	/* 0CB0: A"x" */
	0xF1,0x21,0xAD,0x78,0x22,0x87,0xF1,0x25,	/* 0CB8: !x"% */
	0x2F,0xAA,0x40,0x71,0x23,0x28,0x21,0xE5,	/* 0CC0: .@q#(! */
	0x40,0x71,0x23,0x28,0x21,0xE6,0x21,0x48,	/* 0CC8: @q#(!!H */
	0x71,0x23,0x28,0x20,0xE5,0x25,0x2E,0x0B,	/* 0CD0: q#( %.. */
	0x41,0x78,0x22,0x85,0x23,0xFB,0x78,0x22,	/* 0CD8: Ax"#x" */
	0x87,0xF1,0x22,0xAC,0x71,0x23,0x28,0x24,	/* 0CE0: "q#($ */
	0x30,0x2F,0x4F,0x24,0xF6,0x24,0x42,0xF4,	/* 0CE8: 0.O$$B */
	0xA8,0x21,0x4F,0x71,0x23,0x28,0x27,0xE2,	/* 0CF0: !Oq#(' */
	0x0D,0x40,0x71,0x23,0x28,0x27,0xE6,0x24,	/* 0CF8: .@q#('$ */
	0x42,0x71,0x23,0x28,0x27,0xE2,0x22,0x40,	/* 0D00: Bq#('"@ */
	0x78,0x21,0x55,0x23,0xFB,0x22,0x28,0x0C,	/* 0D08: x!U#"(. */
	0x71,0x23,0x28,0x24,0x30,0x2F,0x4F,0x24,	/* 0D10: q#($0.O$ */
	0xF6,0x24,0x42,0xF4,0xA8,0x21,0x20,0x23,	/* 0D18: $B! # */
	0x42,0x21,0xFB,0xD3,0x06,0x2F,0x2F,0x43,	/* 0D20: B!...C */
	0x21,0xFB,0xD3,0x78,0x24,0x85,0xF1,0x41,	/* 0D28: !x$A */
	0x24,0xF6,0x21,0x22,0xAB,0x78,0x5B,0xF1,	/* 0D30: $!"x[ */
	0x4F,0x24,0xF6,0xD0,0x78,0x53,0xF1,0x24,	/* 0D38: O$xS$ */
	0x48,0xF4,0xC0,0xAA,0x70,0x4F,0xF4,0xC0,	/* 0D40: HpO */
	0xA5,0x78,0x23,0x83,0xF1,0xD0,0x78,0x53,	/* 0D48: x#xS */
	0xF1,0x24,0x48,0xF4,0xC0,0xA9,0x41,0x21,	/* 0D50: $HA! */
	0x4E,0x70,0x24,0xFF,0xF0,0xC0,0xAF,0x78,	/* 0D58: Np$x */
	0x53,0xF1,0x24,0x48,0xF4,0xAD,0x41,0x70,	/* 0D60: S$HAp */
	0x4D,0x24,0xFF,0xF0,0xC0,0xA5,0x78,0x21,	/* 0D68: M$x! */
	0x5B,0xF1,0xD0,0x21,0x41,0x70,0xF9,0x21,	/* 0D70: [!Ap! */
	0xA0,0x70,0x22,0xAD,0x70,0x43,0xF4,0x22,	/* 0D78: p"pC" */
	0xA8,0x70,0x44,0xF4,0xC0,0x22,0xAA,0x22,	/* 0D80: pD"" */
	0x00,0x21,0x43,0x70,0xF9,0xAE,0x70,0x21,	/* 0D88: .!Cpp! */
	0x41,0xF4,0x21,0xA5,0x70,0x21,0x42,0xF4,	/* 0D90: A!p!B */
	0xC0,0x21,0xA6,0x0D,0x70,0x21,0x43,0xF4,	/* 0D98: !.p!C */
	0xA8,0x20,0x70,0x21,0x44,0xF4,0xC0,0xA9,	/* 0DA0:  p!D */
	0x20,0x4C,0x78,0x21,0x55,0x23,0xFB,0x08,	/* 0DA8:  Lx!U#. */
	0x20,0x22,0x40,0x78,0x21,0x55,0x23,0xFB,	/* 0DB0:  "@x!U# */
	0x70,0x73,0x28,0xF1,0x30,0x71,0x23,0x28,	/* 0DB8: ps(0q#( */
	0x27,0xE2,0x70,0x73,0x28,0xF1,0x31,0x71,	/* 0DC0: 'ps(1q */
	0x23,0x28,0x27,0xE6,0x78,0x22,0x8D,0xF1,	/* 0DC8: #('x" */
	0x2F,0x40,0x24,0xF6,0x78,0x5B,0xF1,0x4F,	/* 0DD0: .@$x[O */
	0x24,0xF6,0x24,0xFB,0x78,0x22,0x8D,0x23,	/* 0DD8: $$x"# */
	0xFB,0x78,0x23,0x83,0xF1,0x78,0x21,0x5B,	/* 0DE0: x#x![ */
	0x23,0xFB,0x78,0x5B,0xF1,0x44,0x24,0xF0,	/* 0DE8: #x[D$ */
	0xD0,0x78,0x53,0xF1,0x24,0x48,0xF4,0xC0,	/* 0DF0: xS$H */
	0xAC,0x20,0x70,0x4F,0xF4,0xC0,0xA6,0x20,	/* 0DF8:  pO  */
	0x78,0x21,0x5A,0xF1,0xD0,0x78,0x53,0xF1,	/* 0E00: x!ZxS */
	0x24,0x48,0xF4,0xC0,0xAB,0x20,0x41,0x21,	/* 0E08: $H A! */
	0x4E,0x70,0x24,0xFF,0xF0,0xC0,0x21,0xA1,	/* 0E10: Np$! */
	0x78,0x53,0xF1,0x24,0x48,0xF4,0xAF,0x20,	/* 0E18: xS$H  */
	0x41,0x70,0x4D,0x24,0xFF,0xF0,0xC0,0xA6,	/* 0E20: ApM$ */
	0x20,0x78,0x23,0x87,0xF1,0xD0,0x70,0x73,	/* 0E28:  x#ps */
	0x28,0xF1,0x30,0x71,0x23,0x28,0x27,0xE8,	/* 0E30: (0q#(' */
	0x70,0x73,0x28,0xF1,0x31,0x71,0x23,0x28,	/* 0E38: ps(1q#( */
	0x27,0xEC,0x78,0x22,0x8D,0xF1,0x4F,0x24,	/* 0E40: 'x"O$ */
	0xF6,0x78,0x5B,0xF1,0x2F,0x40,0x24,0xF6,	/* 0E48: x[.@$ */
	0x24,0xFB,0x78,0x22,0x8D,0x23,0xFB,0x78,	/* 0E50: $x"#x */
	0x21,0x5A,0xF1,0x78,0x23,0x87,0x23,0xFB,	/* 0E58: !Zx## */
	0x78,0x24,0x85,0xF1,0x42,0x24,0xF6,0x21,	/* 0E60: x$B$! */
	0x23,0xA2,0x40,0x78,0x21,0xEC,0x40,0x78,	/* 0E68: #@x!@x */
	0x21,0xED,0x40,0x78,0x21,0xEE,0x40,0x78,	/* 0E70: !@x!@x */
	0x21,0xEF,0x78,0x53,0xF1,0x24,0x48,0xF4,	/* 0E78: !xS$H */
	0xA9,0x20,0x4C,0x78,0x22,0x51,0x23,0xFB,	/* 0E80:  Lx"Q# */
	0x08,0x20,0x22,0x40,0x78,0x22,0x51,0x23,	/* 0E88: . "@x"Q# */
	0xFB,0x40,0x78,0x24,0x83,0x23,0xFB,0x40,	/* 0E90: @x$#@ */
	0x78,0x22,0x52,0x23,0xFB,0x78,0x21,0x8D,	/* 0E98: x"R#x! */
	0xF1,0x71,0x23,0x28,0x21,0xEA,0x78,0x5F,	/* 0EA0: q#(!x_ */
	0xF1,0x71,0x23,0x28,0x21,0xEB,0x78,0x21,	/* 0EA8: q#(!x! */
	0x8B,0xF1,0x71,0x23,0x28,0x21,0xEC,0x78,	/* 0EB0: q#(!x */
	0x5E,0xF1,0x71,0x23,0x28,0x21,0xED,0x40,	/* 0EB8: ^q#(!@ */
	0x78,0x21,0x89,0x23,0xFB,0x78,0x5A,0xF1,	/* 0EC0: x!#xZ */
	0x25,0xFA,0xD0,0x43,0x24,0xF6,0xD3,0x70,	/* 0EC8: %C$p */
	0x21,0x40,0x24,0xF6,0xC0,0x22,0xA0,0x70,	/* 0ED0: !@$"p */
	0x48,0x24,0xF6,0xA9,0x20,0x73,0x22,0x40,	/* 0ED8: H$ s"@ */
	0x24,0xFB,0xD3,0x07,0x20,0x73,0x24,0x40,	/* 0EE0: $. s$@ */
	0x24,0xFB,0xD3,0x70,0x44,0x24,0xF6,0xA7,	/* 0EE8: $pD$ */
	0x20,0x73,0x28,0x40,0x24,0xFB,0xD3,0x78,	/* 0EF0:  s(@$x */
	0x5D,0xF1,0x28,0x40,0x24,0xF6,0xA3,0x20,	/* 0EF8: ](@$  */
	0x07,0x20,0x73,0x21,0x40,0x24,0xFB,0xD3,	/* 0F00: . s!@$ */
	0x78,0x21,0x85,0xF1,0x25,0xFA,0xD0,0x4F,	/* 0F08: x!%O */
	0x24,0xF6,0x4F,0xF4,0xA3,0x20,0x06,0x20,	/* 0F10: $O .  */
	0x73,0x48,0x24,0xFB,0xD3,0x73,0x71,0x23,	/* 0F18: sH$sq# */
	0x28,0x20,0xE8,0x40,0xD3,0x70,0x28,0x40,	/* 0F20: ( @p(@ */
	0x24,0xF6,0xA7,0x20,0x73,0x21,0x40,0x24,	/* 0F28: $ s!@$ */
	0xFB,0xD3,0x73,0x71,0x23,0x28,0x20,0xE9,	/* 0F30: sq#(  */
	0x78,0x53,0xF1,0x24,0x48,0xF4,0xA9,0x20,	/* 0F38: xS$H  */
	0x48,0x71,0x23,0x28,0x20,0xEA,0x08,0x20,	/* 0F40: Hq#( .  */
	0x28,0x44,0x71,0x23,0x28,0x20,0xEA,0x78,	/* 0F48: (Dq#( x */
	0x21,0x50,0xF1,0x25,0xFA,0xD0,0x78,0x22,	/* 0F50: !P%x" */
	0x81,0x23,0xFB,0x70,0x28,0x40,0x24,0xF6,	/* 0F58: #p(@$ */
	0xA5,0x20,0x40,0xD3,0x21,0x06,0x70,0x48,	/* 0F60:  @!.pH */
	0x24,0xF6,0xA5,0x20,0x42,0xD3,0x0D,0x20,	/* 0F68: $ B.  */
	0x70,0x44,0x24,0xF6,0xA5,0x20,0x44,0xD3,	/* 0F70: pD$ D */
	0x03,0x20,0x43,0xD3,0x70,0x41,0x24,0xF6,	/* 0F78: . CpA$ */
	0xA9,0x20,0x73,0x21,0x48,0x24,0xFB,0xD3,	/* 0F80:  s!H$ */
	0x0D,0x20,0x70,0x42,0x24,0xF6,0xC0,0xA6,	/* 0F88: . pB$ */
	0x20,0x73,0x48,0x24,0xFB,0xD3,0x73,0x71,	/* 0F90:  sH$sq */
	0x23,0x28,0x21,0xEE,0x78,0x24,0x85,0xF1,	/* 0F98: #(!x$ */
	0x42,0x24,0xF6,0x25,0xA8,0x40,0xD3,0x78,	/* 0FA0: B$%@x */
	0x5D,0xF1,0x44,0x24,0xF6,0x22,0xAB,0x78,	/* 0FA8: ]D$"x */
	0x22,0x87,0xF1,0xAF,0x20,0x71,0x23,0x28,	/* 0FB0: " q#( */
	0x24,0x30,0x2F,0x4F,0x24,0xF6,0x24,0x42,	/* 0FB8: $0.O$$B */
	0xF4,0xAF,0x20,0x72,0x64,0x2F,0x4F,0x24,	/* 0FC0:  rd.O$ */
	0xF6,0xD2,0x73,0x42,0x24,0xFB,0xD3,0x21,	/* 0FC8: sB$! */
	0x00,0x72,0x24,0x20,0x40,0x24,0xFB,0xD2,	/* 0FD0: .r$ @$ */
	0x08,0x20,0x72,0x64,0x2F,0x4F,0x24,0xF6,	/* 0FD8: . rd.O$ */
	0xD2,0x78,0x21,0x51,0xF1,0x2F,0x4F,0xF4,	/* 0FE0: x!Q.O */
	0xAE,0x20,0x78,0x22,0x87,0xF1,0xC0,0xA7,	/* 0FE8:  x" */
	0x20,0x73,0x28,0x40,0x24,0xFB,0xD3,0x73,	/* 0FF0:  s(@$s */
	0x71,0x23,0x28,0x21,0xEF,0x78,0x22,0x87,	/* 0FF8: q#(!x" */
	0xF1,0x22,0xA9,0x78,0x22,0x87,0xF1,0x22,	/* 1000: "x"" */
	0x23,0xA6,0x71,0x23,0x28,0x24,0x30,0x2F,	/* 1008: #q#($0. */
	0x4F,0x24,0xF6,0x24,0x42,0xF4,0x22,0x22,	/* 1010: O$$B"" */
	0xA7,0x78,0x5D,0xF1,0x44,0x24,0xF6,0x22,	/* 1018: x]D$" */
	0x21,0xAE,0x72,0x24,0x20,0x40,0x24,0xFB,	/* 1020: !r$ @$ */
	0xD2,0x22,0x21,0x04,0x40,0xD3,0x40,0xD0,	/* 1028: "!.@@ */
	0x40,0xD4,0x40,0xD5,0x78,0x5D,0xF1,0x78,	/* 1030: @@x]x */
	0x21,0x58,0xF1,0x23,0xF3,0x48,0x24,0xF6,	/* 1038: !X#H$ */
	0x21,0xA5,0x73,0x21,0x20,0x40,0x24,0xFB,	/* 1040: !s! @$ */
	0xD3,0x78,0x5D,0xF1,0x48,0x24,0xF6,0xA7,	/* 1048: x]H$ */
	0x70,0x21,0x20,0x40,0x24,0xFB,0xD0,0x78,	/* 1050: p! @$x */
	0x5A,0xF1,0x78,0x23,0x81,0xF1,0x23,0xF3,	/* 1058: Zx## */
	0x28,0x40,0x24,0xF6,0x21,0xA8,0x73,0x21,	/* 1060: (@$!s! */
	0x20,0x20,0x40,0x24,0xFB,0xD3,0x78,0x5A,	/* 1068:   @$xZ */
	0xF1,0x28,0x40,0x24,0xF6,0xA8,0x70,0x21,	/* 1070: (@$p! */
	0x20,0x20,0x40,0x24,0xFB,0xD0,0x78,0x5A,	/* 1078:   @$xZ */
	0xF1,0x28,0x40,0x24,0xF6,0xC0,0x21,0xA8,	/* 1080: (@$! */
	0x74,0x21,0x20,0x20,0x40,0x24,0xFB,0xD4,	/* 1088: t!  @$ */
	0x78,0x21,0x87,0xF1,0x41,0x24,0xF6,0xA8,	/* 1090: x!A$ */
	0x75,0x21,0x20,0x20,0x40,0x24,0xFB,0xD5,	/* 1098: u!  @$ */
	0x78,0x5D,0xF1,0x78,0x21,0x58,0xF1,0x23,	/* 10A0: x]x!X# */
	0xF3,0x24,0x40,0x24,0xF6,0x21,0xA8,0x73,	/* 10A8: $@$!s */
	0x22,0x20,0x20,0x40,0x24,0xFB,0xD3,0x78,	/* 10B0: "  @$x */
	0x5D,0xF1,0x24,0x40,0x24,0xF6,0xA8,0x70,	/* 10B8: ]$@$p */
	0x22,0x20,0x20,0x40,0x24,0xFB,0xD0,0x78,	/* 10C0: "  @$x */
	0x5D,0xF1,0x24,0x40,0x24,0xF6,0xC0,0x21,	/* 10C8: ]$@$! */
	0xA8,0x74,0x22,0x20,0x20,0x40,0x24,0xFB,	/* 10D0: t"  @$ */
	0xD4,0x78,0x21,0x87,0xF1,0x42,0x24,0xF6,	/* 10D8: x!B$ */
	0xA8,0x75,0x22,0x20,0x20,0x40,0x24,0xFB,	/* 10E0: u"  @$ */
	0xD5,0x78,0x5D,0xF1,0x78,0x21,0x58,0xF1,	/* 10E8: x]x!X */
	0x23,0xF3,0x43,0x24,0xF6,0x22,0xA1,0x73,	/* 10F0: #C$"s */
	0x43,0x24,0xFB,0xD3,0x78,0x5D,0xF1,0x42,	/* 10F8: C$x]B */
	0x24,0xF6,0x21,0xA4,0x78,0x5D,0xF1,0x41,	/* 1100: $!x]A */
	0x24,0xF6,0xA8,0x20,0x70,0x42,0x24,0xFB,	/* 1108: $ pB$ */
	0xD0,0x06,0x20,0x70,0x41,0x24,0xFB,0xD0,	/* 1110: . pA$ */
	0x78,0x21,0x85,0xF1,0x78,0x21,0x59,0xF1,	/* 1118: x!x!Y */
	0x23,0xF3,0x21,0x40,0x24,0xF6,0x21,0xA6,	/* 1120: #!@$! */
	0x73,0x21,0x40,0x24,0xFB,0xD3,0x78,0x21,	/* 1128: s!@$x! */
	0x85,0xF1,0x21,0x40,0x24,0xF6,0xA7,0x20,	/* 1130: !@$  */
	0x70,0x21,0x40,0x24,0xFB,0xD0,0x78,0x5D,	/* 1138: p!@$x] */
	0xF1,0x78,0x21,0x58,0xF1,0x23,0xF3,0x21,	/* 1140: x!X#! */
	0x40,0x24,0xF6,0x21,0xA5,0x73,0x22,0x40,	/* 1148: @$!s"@ */
	0x24,0xFB,0xD3,0x78,0x5D,0xF1,0x21,0x40,	/* 1150: $x]!@ */
	0x24,0xF6,0xA7,0x20,0x70,0x22,0x40,0x24,	/* 1158: $ p"@$ */
	0xFB,0xD0,0x78,0x24,0x85,0xF1,0x22,0x40,	/* 1160: x$"@ */
	0x24,0xF6,0xA6,0x73,0x78,0x77,0x28,0x20,	/* 1168: $sxw(  */
	0x92,0x78,0x24,0x85,0xF1,0x21,0x40,0x24,	/* 1170: x$!@$ */
	0xF6,0xA8,0x75,0xD0,0x74,0x78,0x77,0x2A,	/* 1178: utxw* */
	0x2E,0x99,0x78,0x5D,0xF1,0x22,0x40,0x24,	/* 1180: .x]"@$ */
	0xF6,0x22,0xAB,0x78,0x77,0x68,0x23,0x91,	/* 1188: "xwh# */
	0x78,0x21,0x53,0xF1,0x2F,0x40,0x24,0xF6,	/* 1190: x!S.@$ */
	0x25,0xFA,0xD0,0x71,0x23,0x28,0x21,0xE6,	/* 1198: %q#(! */
	0x71,0x23,0x28,0x21,0x35,0x4F,0x24,0xF6,	/* 11A0: q#(!5O$ */
	0x70,0x60,0x40,0x24,0xF6,0x24,0xFB,0x71,	/* 11A8: p`@$$q */
	0x23,0x28,0x21,0xE5,0x21,0x09,0x22,0x44,	/* 11B0: #(!!."D */
	0x78,0x5C,0x23,0xFB,0x40,0x71,0x23,0x28,	/* 11B8: x\#@q#( */
	0x21,0xE6,0x71,0x23,0x28,0x21,0x35,0x4F,	/* 11C0: !q#(!5O */
	0x24,0xF6,0x71,0x23,0x28,0x21,0xE5,0x72,	/* 11C8: $q#(!r */
	0x62,0x2F,0x2F,0x4F,0x24,0xF6,0xD2,0x78,	/* 11D0: b..O$x */
	0x5D,0xF1,0x22,0x40,0x24,0xF6,0xA8,0x72,	/* 11D8: ]"@$r */
	0x22,0x20,0x20,0x40,0x24,0xFB,0xD2,0x78,	/* 11E0: "  @$x */
	0x24,0x85,0xF1,0x22,0x40,0x24,0xF6,0x24,	/* 11E8: $"@$$ */
	0xAF,0x72,0x60,0x44,0x24,0xF6,0xD2,0x78,	/* 11F0: r`D$x */
	0x5D,0xF1,0x42,0x24,0xF6,0xA5,0x72,0x42,	/* 11F8: ]B$rB */
	0x24,0xFB,0xD2,0x78,0x5D,0xF1,0x48,0x24,	/* 1200: $x]H$ */
	0xF6,0xA5,0x72,0x48,0x24,0xFB,0xD2,0x78,	/* 1208: rH$x */
	0x5D,0xF1,0x41,0x24,0xF6,0xA5,0x72,0x41,	/* 1210: ]A$rA */
	0x24,0xFB,0xD2,0x78,0x5A,0xF1,0x28,0x40,	/* 1218: $xZ(@ */
	0x24,0xF6,0xA5,0x72,0x48,0x24,0xFB,0xD2,	/* 1220: $rH$ */
	0x78,0x5D,0xF1,0x24,0x40,0x24,0xF6,0xA5,	/* 1228: x]$@$ */
	0x72,0x48,0x24,0xFB,0xD2,0x72,0x48,0x24,	/* 1230: rH$rH$ */
	0xF6,0xA6,0x72,0x6F,0x4F,0x24,0xF6,0xD2,	/* 1238: roO$ */
	0x78,0x5D,0xF1,0x78,0x21,0x58,0x23,0xFB,	/* 1240: x]x!X# */
	0x78,0x5A,0xF1,0x78,0x23,0x81,0x23,0xFB,	/* 1248: xZx## */
	0x78,0x21,0x85,0xF1,0x78,0x21,0x59,0x23,	/* 1250: x!x!Y# */
	0xFB,0x78,0x24,0x85,0xF1,0x41,0x24,0xF6,	/* 1258: x$A$ */
	0x24,0xAC,0x71,0x23,0x28,0x24,0x30,0x2F,	/* 1260: $q#($0. */
	0x4F,0x24,0xF6,0x24,0x42,0xF4,0xA5,0x77,	/* 1268: O$$Bw */
	0x21,0x5B,0xD3,0x03,0x77,0x5D,0xD3,0x78,	/* 1270: ![.w]x */
	0x5B,0xF1,0x44,0x24,0xF0,0xD0,0x78,0x53,	/* 1278: [D$xS */
	0xF1,0x24,0x48,0xF4,0xC0,0xAA,0x41,0x21,	/* 1280: $HA! */
	0x4E,0x70,0x24,0xFF,0xF0,0xC0,0x21,0xA8,	/* 1288: Np$! */
	0x78,0x53,0xF1,0x24,0x48,0xF4,0xA7,0x41,	/* 1290: xS$HA */
	0x70,0x4D,0x24,0xFF,0xF0,0xAA,0x70,0x73,	/* 1298: pM$ps */
	0xFA,0x30,0x71,0x23,0x28,0x22,0xE1,0x06,	/* 12A0: 0q#(". */
	0x48,0x71,0x23,0x28,0x22,0xE1,0x24,0x4E,	/* 12A8: Hq#("$N */
	0x71,0x23,0x28,0x20,0xE5,0x72,0x78,0xE4,	/* 12B0: q#( rx */
	0x40,0xB6,0x22,0xF0,0x21,0x4A,0x71,0x23,	/* 12B8: @"!Jq# */
	0x28,0x20,0xE5,0x72,0x60,0x4E,0x24,0xF6,	/* 12C0: ( r`N$ */
	0x78,0xE4,0x29,0x40,0x71,0x23,0x28,0x20,	/* 12C8: x)@q#(  */
	0xE6,0x40,0x78,0x22,0x85,0x23,0xFB,0x78,	/* 12D0: @x"#x */
	0x57,0xF1,0x44,0xF4,0xA6,0x40,0x78,0x57,	/* 12D8: WD@xW */
	0x23,0xFB,0x03,0x78,0x77,0x9E,0x41,0x77,	/* 12E0: #.xwAw */
	0x28,0xE4,0x40,0x78,0x24,0x85,0x23,0xFB,	/* 12E8: (@x$# */
	0x40,0xB6,0x22,0xF0,0x60,0xBF,0x73,0x31,	/* 12F0: @"`s1 */
	0xD0,0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,	/* 12F8: ss2'. */
	0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,	/* 1300: .O$#s */
	0x87,0xF1,0x70,0x23,0x28,0x27,0xEF,0x73,	/* 1308: p#('s */
	0x87,0xF1,0x43,0x24,0xF6,0x70,0x23,0x28,	/* 1310: C$p#( */
	0x26,0xE8,0x70,0x23,0x28,0x26,0x3C,0x28,	/* 1318: &p#(&<( */
	0x40,0x24,0xF6,0xA9,0x40,0x73,0x57,0x23,	/* 1320: @$@sW# */
	0xFB,0x41,0x72,0x28,0xE4,0x40,0xB1,0x22,	/* 1328: Ar(@" */
	0xF0,0x60,0xBF,0x73,0x31,0xD0,0x73,0x87,	/* 1330: `s1s */
	0xF1,0x73,0x32,0x27,0x2F,0x2F,0x4F,0x24,	/* 1338: s2'..O$ */
	0xF6,0x89,0x23,0xFB,0x73,0x87,0xF1,0x70,	/* 1340: #sp */
	0x23,0x28,0x27,0xEF,0x73,0x87,0xF1,0x43,	/* 1348: #('sC */
	0x24,0xF6,0x70,0x23,0x28,0x26,0xE8,0x73,	/* 1350: $p#(&s */
	0x72,0x22,0x28,0x95,0xA4,0x40,0xB1,0x22,	/* 1358: r"(@" */
	0xF0,0x73,0x8D,0xF1,0x73,0x56,0xF1,0xF4,	/* 1360: ssV */
	0xA4,0x41,0xB1,0x22,0xF0,0x73,0x21,0x8F,	/* 1368: A"s! */
	0xF1,0xA8,0x73,0x72,0x2D,0x9C,0x40,0xB1,	/* 1370: sr-@ */
	0x22,0xF0,0x73,0x22,0x89,0xF1,0xC0,0xA9,	/* 1378: "s" */
	0x73,0x34,0x22,0x20,0x40,0x24,0xFB,0x73,	/* 1380: s4" @$s */
	0xE4,0x73,0x34,0x22,0x20,0x40,0x24,0xF6,	/* 1388: s4" @$ */
	0xA8,0x73,0x72,0x2B,0x9D,0x40,0xB1,0x22,	/* 1390: sr+@" */
	0xF0,0x73,0x34,0x21,0x20,0x40,0x24,0xFB,	/* 1398: s4! @$ */
	0x73,0xE4,0x73,0x22,0x87,0xF1,0xAF,0x73,	/* 13A0: ss"s */
	0x34,0x41,0x24,0xFB,0x73,0xE4,0x28,0x44,	/* 13A8: 4A$s(D */
	0x70,0x23,0x28,0x20,0xE6,0x0E,0x73,0x34,	/* 13B0: p#( .s4 */
	0x41,0x24,0xFB,0x73,0xE4,0x29,0x42,0x70,	/* 13B8: A$s)Bp */
	0x23,0x28,0x20,0xE6,0x40,0xB1,0x22,0xF0,	/* 13C0: #( @" */
	0x60,0xBE,0x74,0x31,0xD0,0x74,0x87,0xF1,	/* 13C8: `t1t */
	0x74,0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,	/* 13D0: t2'..O$ */
	0x89,0x23,0xFB,0x74,0x87,0xF1,0x70,0x23,	/* 13D8: #tp# */
	0x28,0x27,0xEF,0x74,0x87,0xF1,0x43,0x24,	/* 13E0: ('tC$ */
	0xF6,0x70,0x23,0x28,0x26,0xE8,0x74,0x23,	/* 13E8: p#(&t# */
	0x85,0xF1,0xD1,0x43,0x71,0xF9,0xAD,0x71,	/* 13F0: Cqq */
	0x21,0xA0,0x71,0x41,0xF4,0x21,0xA1,0x71,	/* 13F8: !qA!q */
	0x42,0xF4,0xAD,0x06,0x71,0x43,0xF4,0x22,	/* 1400: B.qC" */
	0xA3,0x71,0x41,0x74,0x23,0x85,0x23,0xFB,	/* 1408: qAt## */
	0x74,0x34,0x41,0x24,0xFB,0x74,0xE4,0x70,	/* 1410: t4A$tp */
	0x23,0x28,0x20,0x36,0x2F,0x4F,0x24,0xF6,	/* 1418: #( 6.O$ */
	0x42,0x24,0xFB,0x70,0x23,0x28,0x20,0xE6,	/* 1420: B$p#(  */
	0x40,0xB2,0x22,0xF0,0x74,0x57,0xF1,0x4C,	/* 1428: @"tWL */
	0xF4,0xC0,0xA6,0x21,0x42,0x74,0x57,0x23,	/* 1430: !BtW# */
	0xFB,0x40,0xB2,0x22,0xF0,0x72,0x71,0x21,	/* 1438: @"rq! */
	0x29,0x9F,0xC0,0xA5,0x40,0x72,0x57,0x23,	/* 1440: )@rW# */
	0xFB,0x40,0x22,0xF0,0x40,0x22,0xF0,0x41,	/* 1448: @"@"A */
	0x22,0xF0,0x60,0xBD,0x75,0x31,0xD1,0x75,	/* 1450: "`u1u */
	0x87,0xF1,0x75,0x32,0x27,0x2F,0x2F,0x4F,	/* 1458: u2'..O */
	0x24,0xF6,0x89,0x23,0xFB,0x75,0x87,0xF1,	/* 1460: $#u */
	0x71,0x23,0x28,0x27,0xEF,0x75,0x87,0xF1,	/* 1468: q#('u */
	0x43,0x24,0xF6,0x71,0x23,0x28,0x26,0xE8,	/* 1470: C$q#(& */
	0x75,0x74,0x21,0x26,0x94,0xA4,0x40,0xB3,	/* 1478: ut!&@ */
	0x22,0xF0,0x71,0x23,0x28,0x20,0x35,0x2F,	/* 1480: "q#( 5. */
	0x4F,0x24,0xF6,0xA4,0x40,0xB3,0x22,0xF0,	/* 1488: O$@" */
	0x75,0x21,0x8F,0xF1,0xC0,0x24,0xAE,0x75,	/* 1490: u!$u */
	0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,0xD0,	/* 1498: 2'..O$ */
	0x75,0x34,0x22,0x20,0x40,0x24,0xF6,0x26,	/* 14A0: u4" @$& */
	0xAE,0x75,0x87,0xF1,0x43,0xF9,0x21,0xAD,	/* 14A8: uC! */
	0x70,0x21,0x8D,0xF1,0x60,0x8F,0x25,0xFA,	/* 14B0: p!`% */
	0x70,0x21,0x8D,0x23,0xFB,0x2F,0x4F,0x24,	/* 14B8: p!#.O$ */
	0xF6,0xC0,0x22,0xA1,0x24,0x44,0x71,0x23,	/* 14C0: "$Dq# */
	0x28,0x27,0xEF,0x21,0x08,0x70,0x5E,0xF1,	/* 14C8: ('!.p^ */
	0x60,0x8F,0x25,0xFA,0x70,0x5E,0x23,0xFB,	/* 14D0: `%p^# */
	0x2F,0x4F,0x24,0xF6,0xC0,0xA7,0x21,0x40,	/* 14D8: .O$!@ */
	0x71,0x23,0x28,0x27,0xEF,0x40,0x75,0x8D,	/* 14E0: q#('@u */
	0x23,0xFB,0x40,0x75,0x55,0x23,0xFB,0x40,	/* 14E8: #@uU#@ */
	0x75,0x56,0x23,0xFB,0x40,0x75,0x8B,0x23,	/* 14F0: uV#@u# */
	0xFB,0x40,0x75,0x22,0x89,0x23,0xFB,0x75,	/* 14F8: @u"#u */
	0x34,0x62,0x2F,0x4F,0x24,0xF6,0x75,0xE4,	/* 1500: 4b.O$u */
	0x75,0x22,0x87,0xF1,0x28,0xA2,0x21,0x44,	/* 1508: u"(!D */
	0x71,0x23,0x28,0x20,0xE5,0x2A,0x08,0x75,	/* 1510: q#( *.u */
	0x22,0x89,0xF1,0x22,0xA8,0x75,0x34,0x21,	/* 1518: ""u4! */
	0x20,0x40,0x24,0xF6,0x22,0xAA,0x75,0x22,	/* 1520:  @$"u" */
	0x50,0xF1,0x41,0x24,0xF6,0x25,0xAD,0x21,	/* 1528: PA$%! */
	0x48,0x71,0x23,0x28,0x20,0xE5,0x75,0x22,	/* 1530: Hq#( u" */
	0x50,0xF1,0x60,0x4E,0x24,0xF6,0x75,0x22,	/* 1538: P`N$u" */
	0x50,0x23,0xFB,0x24,0x07,0x75,0x34,0x22,	/* 1540: P#$.u4" */
	0x20,0x40,0x24,0xFB,0x75,0xE4,0x23,0x0C,	/* 1548:  @$u#. */
	0x75,0x34,0x21,0x20,0x40,0x24,0xFB,0x75,	/* 1550: u4! @$u */
	0xE4,0x40,0x75,0x8D,0x23,0xFB,0x40,0x75,	/* 1558: @u#@u */
	0x56,0x23,0xFB,0x75,0x22,0x87,0xF1,0xAF,	/* 1560: V#u" */
	0x75,0x34,0x41,0x24,0xFB,0x75,0xE4,0x28,	/* 1568: u4A$u( */
	0x44,0x71,0x23,0x28,0x20,0xE6,0x0E,0x75,	/* 1570: Dq#( .u */
	0x34,0x41,0x24,0xFB,0x75,0xE4,0x29,0x42,	/* 1578: 4A$u)B */
	0x71,0x23,0x28,0x20,0xE6,0x28,0x42,0x71,	/* 1580: q#( (Bq */
	0x23,0x28,0x20,0xE5,0x40,0xB3,0x22,0xF0,	/* 1588: #( @" */
	0x75,0x21,0x87,0xF1,0x41,0x24,0xF6,0xC0,	/* 1590: u!A$ */
	0xAB,0x40,0xD0,0x21,0x20,0x20,0x40,0x75,	/* 1598: @!  @u */
	0x74,0x26,0x2C,0x97,0x75,0x21,0x87,0xF1,	/* 15A0: t&,u! */
	0x42,0x24,0xF6,0xC0,0xAB,0x40,0xD0,0x22,	/* 15A8: B$@" */
	0x20,0x20,0x40,0x75,0x74,0x26,0x2B,0x93,	/* 15B0:   @ut&+ */
	0x28,0x40,0x71,0x23,0x28,0x20,0xE5,0x75,	/* 15B8: (@q#( u */
	0x34,0x60,0x4E,0x24,0xF6,0x75,0xE4,0x40,	/* 15C0: 4`N$u@ */
	0x71,0x23,0x28,0x20,0xE6,0x41,0x75,0x21,	/* 15C8: q#( Au! */
	0x8F,0x23,0xFB,0x21,0x40,0x75,0x57,0x23,	/* 15D0: #!@uW# */
	0xFB,0x41,0x74,0x28,0xE4,0x40,0xB3,0x22,	/* 15D8: At(@" */
	0xF0,0x60,0xBE,0x74,0x31,0xD0,0x74,0x87,	/* 15E0: `t1t */
	0xF1,0x74,0x32,0x27,0x2F,0x2F,0x4F,0x24,	/* 15E8: t2'..O$ */
	0xF6,0x89,0x23,0xFB,0x74,0x87,0xF1,0x70,	/* 15F0: #tp */
	0x23,0x28,0x27,0xEF,0x74,0x87,0xF1,0x43,	/* 15F8: #('tC */
	0x24,0xF6,0x70,0x23,0x28,0x26,0xE8,0x74,	/* 1600: $p#(&t */
	0x23,0x85,0xF1,0xD1,0x43,0x71,0xF9,0xA5,	/* 1608: #Cq */
	0x71,0x24,0xAD,0x71,0x0E,0x71,0x43,0xF4,	/* 1610: q$q.qC */
	0xAA,0x71,0x44,0xF4,0x22,0xA6,0x71,0x45,	/* 1618: qD"qE */
	0xF4,0x22,0xA1,0x74,0x53,0xF1,0x24,0x48,	/* 1620: "tS$H */
	0xF4,0xC0,0x21,0xA2,0x70,0x23,0x28,0x20,	/* 1628: !p#(  */
	0x35,0x2F,0x4F,0x24,0xF6,0xC0,0xAD,0x28,	/* 1630: 5.O$( */
	0x42,0x70,0x23,0x28,0x20,0xE5,0x44,0x74,	/* 1638: Bp#( Dt */
	0x23,0x85,0x23,0xFB,0x74,0x34,0x41,0x24,	/* 1640: ##t4A$ */
	0xFB,0x74,0xE4,0x70,0x23,0x28,0x20,0x36,	/* 1648: tp#( 6 */
	0x2F,0x4F,0x24,0xF6,0x42,0x24,0xFB,0x70,	/* 1650: .O$B$p */
	0x23,0x28,0x20,0xE6,0x41,0xB2,0x22,0xF0,	/* 1658: #( A" */
	0x40,0xB2,0x22,0xF0,0x60,0xBF,0x73,0x31,	/* 1660: @"`s1 */
	0xD0,0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,	/* 1668: ss2'. */
	0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,	/* 1670: .O$#s */
	0x87,0xF1,0x70,0x23,0x28,0x27,0xEF,0x73,	/* 1678: p#('s */
	0x87,0xF1,0x43,0x24,0xF6,0x70,0x23,0x28,	/* 1680: C$p#( */
	0x26,0xE8,0x73,0x22,0x87,0xF1,0xC0,0xAE,	/* 1688: &s" */
	0x70,0x23,0x28,0x20,0x3B,0x2F,0x4B,0x24,	/* 1690: p#( ;.K$ */
	0xF6,0x70,0x23,0x28,0x20,0xEB,0x40,0x73,	/* 1698: p#( @s */
	0x57,0x23,0xFB,0x41,0x72,0x28,0xE4,0x40,	/* 16A0: W#Ar(@ */
	0xB1,0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,	/* 16A8: "`s1 */
	0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,0x2F,	/* 16B0: ss2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,0x87,	/* 16B8: O$#s */
	0xF1,0x70,0x23,0x28,0x27,0xEF,0x73,0x87,	/* 16C0: p#('s */
	0xF1,0x43,0x24,0xF6,0x70,0x23,0x28,0x26,	/* 16C8: C$p#(& */
	0xE8,0x70,0x23,0x28,0x20,0x35,0x2F,0x4F,	/* 16D0: p#( 5.O */
	0x24,0xF6,0xA4,0x40,0xB1,0x22,0xF0,0x73,	/* 16D8: $@"s */
	0x8D,0xF1,0x73,0x56,0x23,0xFB,0x28,0x42,	/* 16E0: sV#(B */
	0x70,0x23,0x28,0x20,0xE5,0x73,0x72,0x68,	/* 16E8: p#( srh */
	0x93,0x40,0xB1,0x22,0xF0,0x72,0x8B,0xF1,	/* 16F0: @"r */
	0x72,0x55,0x23,0xFB,0x41,0x71,0x28,0xE4,	/* 16F8: rU#Aq( */
	0x40,0x72,0x57,0x23,0xFB,0x40,0x22,0xF0,	/* 1700: @rW#@" */
	0x60,0xBF,0x73,0x31,0xD0,0x73,0x87,0xF1,	/* 1708: `s1s */
	0x73,0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,	/* 1710: s2'..O$ */
	0x89,0x23,0xFB,0x73,0x87,0xF1,0x70,0x23,	/* 1718: #sp# */
	0x28,0x27,0xEF,0x73,0x87,0xF1,0x43,0x24,	/* 1720: ('sC$ */
	0xF6,0x70,0x23,0x28,0x26,0xE8,0x73,0x22,	/* 1728: p#(&s" */
	0x87,0xF1,0xC0,0x21,0xA1,0x70,0x23,0x28,	/* 1730: !p#( */
	0x20,0x3B,0x2F,0x4F,0x24,0xF6,0x44,0x24,	/* 1738:  ;.O$D$ */
	0xFB,0x70,0x23,0x28,0x20,0xEB,0x41,0x72,	/* 1740: p#( Ar */
	0x28,0xE4,0x40,0x73,0x57,0x23,0xFB,0x40,	/* 1748: (@sW#@ */
	0xB1,0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,	/* 1750: "`s1 */
	0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,0x2F,	/* 1758: ss2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,0x87,	/* 1760: O$#s */
	0xF1,0x70,0x23,0x28,0x27,0xEF,0x73,0x87,	/* 1768: p#('s */
	0xF1,0x43,0x24,0xF6,0x70,0x23,0x28,0x26,	/* 1770: C$p#(& */
	0xE8,0x74,0x70,0x23,0x28,0x26,0xEF,0x4F,	/* 1778: tp#(&O */
	0x72,0x22,0x2F,0x2F,0x97,0x70,0x23,0x28,	/* 1780: r"..p#( */
	0x26,0x3F,0x2F,0x4F,0x24,0xF6,0x75,0x24,	/* 1788: &?.O$u$ */
	0xF6,0x21,0xAE,0x40,0x70,0x23,0x28,0x26,	/* 1790: !@p#(& */
	0xEF,0x4F,0x72,0x22,0x2F,0x2D,0x9D,0x70,	/* 1798: Or".-p */
	0x23,0x28,0x26,0x3F,0x2F,0x4F,0x24,0xF6,	/* 17A0: #(&?.O$ */
	0x75,0x24,0xF6,0xA9,0x76,0x81,0xB1,0x22,	/* 17A8: u$v" */
	0xF0,0x76,0xB1,0x22,0xF0,0x40,0xB1,0x22,	/* 17B0: v"@" */
	0xF0,0x60,0xBC,0x76,0x31,0xD2,0x40,0xD3,	/* 17B8: `v1@ */
	0x76,0x87,0xF1,0x76,0x32,0x27,0x2F,0x2F,	/* 17C0: vv2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x76,0x87,	/* 17C8: O$#v */
	0xF1,0x72,0x23,0x28,0x27,0xEF,0x76,0x87,	/* 17D0: r#('v */
	0xF1,0x43,0x24,0xF6,0x72,0x23,0x28,0x26,	/* 17D8: C$r#(& */
	0xE8,0x76,0x22,0x87,0xF1,0xC0,0xA2,0x4E,	/* 17E0: v"N */
	0xD3,0x73,0xC0,0xAB,0x22,0x40,0xD0,0x49,	/* 17E8: s"@I */
	0xD1,0x41,0x76,0x75,0x6A,0x9D,0xD3,0x73,	/* 17F0: Avujs */
	0xC0,0xAB,0x21,0x40,0xD0,0x4B,0xD1,0x44,	/* 17F8: !@KD */
	0x76,0x75,0x6B,0x9F,0xD3,0x72,0x23,0x28,	/* 1800: vukr#( */
	0x26,0x3F,0x28,0x40,0x24,0xF6,0x25,0xFA,	/* 1808: &?(@$% */
	0xD1,0xC0,0xA7,0x4E,0xD3,0x71,0x76,0x5C,	/* 1810: Nqv\ */
	0x23,0xFB,0x73,0xC0,0x23,0xAA,0x48,0xD0,	/* 1818: #s#H */
	0x42,0x72,0x23,0x28,0x26,0xEF,0x4F,0x75,	/* 1820: Br#(&Ou */
	0x22,0x2F,0x25,0x90,0x40,0x72,0x23,0x28,	/* 1828: ".%@r#( */
	0x26,0xEF,0x4F,0x75,0x22,0x2F,0x24,0x94,	/* 1830: &Ou".$ */
	0x72,0x23,0x28,0x26,0x3F,0x28,0x40,0x24,	/* 1838: r#(&?(@$ */
	0xF6,0x25,0xFA,0xD1,0xAA,0x73,0xC0,0xA2,	/* 1840: %s */
	0x70,0xD3,0x71,0x76,0x5C,0x23,0xFB,0x70,	/* 1848: pqv\#p */
	0x60,0x8F,0x25,0xFA,0xD0,0xA2,0x63,0x08,	/* 1850: `%c. */
	0x73,0xC0,0x23,0xAC,0x42,0x72,0x23,0x28,	/* 1858: s#Br#( */
	0x26,0xEF,0x4F,0x75,0x22,0x2F,0x21,0x94,	/* 1860: &Ou".! */
	0x40,0x72,0x23,0x28,0x26,0xEF,0x22,0x27,	/* 1868: @r#(&"' */
	0x21,0x40,0xD0,0x72,0x23,0x28,0x26,0x3F,	/* 1870: !@r#(&? */
	0x2F,0x4F,0x24,0xF6,0x25,0xFA,0xD1,0x24,	/* 1878: .O$%$ */
	0x40,0x24,0xF6,0xC0,0xA9,0x70,0x60,0x8F,	/* 1880: @$p` */
	0x25,0xFA,0xD0,0xA2,0x61,0x05,0x70,0xC0,	/* 1888: %a.p */
	0xA7,0x71,0x76,0x5C,0x23,0xFB,0x4D,0xD3,	/* 1890: qv\#M */
	0x4F,0x75,0x22,0x2E,0x2D,0x9E,0x42,0x72,	/* 1898: Ou".-Br */
	0x23,0x28,0x26,0xEF,0x4F,0x75,0x22,0x2E,	/* 18A0: #(&Ou". */
	0x2D,0x92,0x40,0x72,0x23,0x28,0x26,0xEF,	/* 18A8: -@r#(& */
	0x28,0x42,0x72,0x23,0x28,0x20,0xE5,0x73,	/* 18B0: (Br#( s */
	0x76,0x21,0x54,0x23,0xFB,0x73,0xA6,0x45,	/* 18B8: v!T#sE */
	0x72,0x23,0x28,0x26,0xEF,0x40,0x76,0x57,	/* 18C0: r#(&@vW */
	0x23,0xFB,0x40,0xB4,0x22,0xF0,0x21,0x40,	/* 18C8: #@"!@ */
	0x72,0x71,0x9F,0x22,0xF0,0x42,0x72,0x71,	/* 18D0: rq"Brq */
	0x99,0x22,0xF0,0x28,0x40,0x72,0x71,0x92,	/* 18D8: "(@rq */
	0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,0x73,	/* 18E0: "`s1s */
	0x87,0xF1,0x73,0x32,0x27,0x2F,0x2F,0x4F,	/* 18E8: s2'..O */
	0x24,0xF6,0x89,0x23,0xFB,0x73,0x87,0xF1,	/* 18F0: $#s */
	0x70,0x23,0x28,0x27,0xEF,0x73,0x87,0xF1,	/* 18F8: p#('s */
	0x43,0x24,0xF6,0x70,0x23,0x28,0x26,0xE8,	/* 1900: C$p#(& */
	0x74,0x46,0x24,0xF6,0xA7,0x73,0x34,0x41,	/* 1908: tF$s4A */
	0x24,0xFB,0x73,0xE4,0x70,0x23,0x28,0x20,	/* 1910: $sp#(  */
	0x36,0x2F,0x4F,0x24,0xF6,0x74,0x24,0xFB,	/* 1918: 6.O$t$ */
	0x70,0x23,0x28,0x20,0xE6,0x41,0x72,0x28,	/* 1920: p#( Ar( */
	0xE4,0x40,0x73,0x57,0x23,0xFB,0x40,0xB1,	/* 1928: @sW#@ */
	0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,0x73,	/* 1930: "`s1s */
	0x87,0xF1,0x73,0x32,0x27,0x2F,0x2F,0x4F,	/* 1938: s2'..O */
	0x24,0xF6,0x89,0x23,0xFB,0x73,0x87,0xF1,	/* 1940: $#s */
	0x70,0x23,0x28,0x27,0xEF,0x73,0x87,0xF1,	/* 1948: p#('s */
	0x43,0x24,0xF6,0x70,0x23,0x28,0x26,0xE8,	/* 1950: C$p#(& */
	0x73,0x34,0x60,0x4E,0x24,0xF6,0x73,0xE4,	/* 1958: s4`N$s */
	0x40,0x70,0x23,0x28,0x20,0xE6,0x41,0x72,	/* 1960: @p#( Ar */
	0x28,0xE4,0x40,0x73,0x57,0x23,0xFB,0x40,	/* 1968: (@sW#@ */
	0xB1,0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,	/* 1970: "`s1 */
	0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,0x2F,	/* 1978: ss2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,0x87,	/* 1980: O$#s */
	0xF1,0x70,0x23,0x28,0x27,0xEF,0x73,0x87,	/* 1988: p#('s */
	0xF1,0x43,0x24,0xF6,0x70,0x23,0x28,0x26,	/* 1990: C$p#(& */
	0xE8,0x74,0x41,0x24,0xF6,0x24,0xA8,0x75,	/* 1998: tA$$u */
	0x41,0x24,0xF6,0x22,0xA6,0x70,0x23,0x28,	/* 19A0: A$"p#( */
	0x20,0x39,0x2F,0x4F,0x24,0xF6,0x24,0x40,	/* 19A8:  9.O$$@ */
	0x24,0xFB,0x70,0x23,0x28,0x20,0xE9,0x70,	/* 19B0: $p#( p */
	0x23,0x28,0x20,0x3A,0x2F,0x4F,0x24,0xF6,	/* 19B8: #( :.O$ */
	0x23,0x40,0x24,0xFB,0x70,0x23,0x28,0x20,	/* 19C0: #@$p#(  */
	0xEA,0x21,0x0C,0x70,0x23,0x28,0x20,0x39,	/* 19C8: !.p#( 9 */
	0x2B,0x4F,0x24,0xF6,0x70,0x23,0x28,0x20,	/* 19D0: +O$p#(  */
	0xE9,0x70,0x23,0x28,0x20,0x3A,0x2C,0x4F,	/* 19D8: p#( :,O */
	0x24,0xF6,0x70,0x23,0x28,0x20,0xEA,0x74,	/* 19E0: $p#( t */
	0x42,0x24,0xF6,0x22,0xA7,0x75,0x42,0x24,	/* 19E8: B$"uB$ */
	0xF6,0x21,0xA3,0x70,0x23,0x28,0x20,0x39,	/* 19F0: !p#( 9 */
	0x2F,0x4F,0x24,0xF6,0x28,0x40,0x24,0xFB,	/* 19F8: .O$(@$ */
	0x70,0x23,0x28,0x20,0xE9,0x0E,0x70,0x23,	/* 1A00: p#( .p# */
	0x28,0x20,0x39,0x27,0x4F,0x24,0xF6,0x70,	/* 1A08: ( 9'O$p */
	0x23,0x28,0x20,0xE9,0x74,0x21,0x40,0x24,	/* 1A10: #( t!@$ */
	0xF6,0x22,0xA7,0x75,0x21,0x40,0x24,0xF6,	/* 1A18: "u!@$ */
	0x21,0xA2,0x70,0x23,0x28,0x20,0x39,0x2F,	/* 1A20: !p#( 9. */
	0x4F,0x24,0xF6,0x42,0x24,0xFB,0x70,0x23,	/* 1A28: O$B$p# */
	0x28,0x20,0xE9,0x0E,0x70,0x23,0x28,0x20,	/* 1A30: ( .p#(  */
	0x39,0x2F,0x4D,0x24,0xF6,0x70,0x23,0x28,	/* 1A38: 9.M$p#( */
	0x20,0xE9,0x74,0x22,0x40,0x24,0xF6,0xAD,	/* 1A40:  t"@$ */
	0x73,0x22,0x50,0xF1,0x21,0x40,0x24,0xFB,	/* 1A48: s"P!@$ */
	0x73,0x22,0x50,0x23,0xFB,0x73,0x53,0xF1,	/* 1A50: s"P#sS */
	0x24,0x48,0xF4,0x23,0xA8,0x74,0x21,0x20,	/* 1A58: $H#t!  */
	0x20,0x40,0x24,0xF6,0x21,0x2A,0xA0,0x73,	/* 1A60:  @$!*s */
	0x21,0x52,0xF1,0x48,0x24,0xF6,0x21,0x27,	/* 1A68: !RH$!' */
	0xAF,0x75,0x21,0x20,0x20,0x40,0x24,0xF6,	/* 1A70: u!  @$ */
	0x21,0x25,0xAF,0x70,0x23,0x28,0x21,0x35,	/* 1A78: !%p#(!5 */
	0x2F,0x40,0x24,0xF6,0x49,0x24,0xFB,0x70,	/* 1A80: .@$I$p */
	0x23,0x28,0x21,0xE5,0x42,0x70,0x23,0x28,	/* 1A88: #(!Bp#( */
	0x26,0xED,0x21,0x27,0x02,0x70,0x23,0x28,	/* 1A90: &!'.p#( */
	0x21,0x35,0x2F,0x40,0x24,0xF6,0x4F,0x24,	/* 1A98: !5.@$O$ */
	0xFB,0x70,0x23,0x28,0x21,0xE5,0x74,0x21,	/* 1AA0: p#(!t! */
	0x20,0x40,0x24,0xF6,0x22,0xA9,0x75,0x21,	/* 1AA8:  @$"u! */
	0x20,0x40,0x24,0xF6,0x21,0xA3,0x70,0x23,	/* 1AB0:  @$!p# */
	0x28,0x21,0x3F,0x2F,0x4F,0x24,0xF6,0x48,	/* 1AB8: (!?.O$H */
	0x24,0xFB,0x70,0x23,0x28,0x21,0xEF,0x0F,	/* 1AC0: $p#(!. */
	0x20,0x70,0x23,0x28,0x21,0x3F,0x2F,0x47,	/* 1AC8:  p#(!?.G */
	0x24,0xF6,0x70,0x23,0x28,0x21,0xEF,0x74,	/* 1AD0: $p#(!t */
	0x21,0x20,0x20,0x40,0x24,0xF6,0x27,0xA7,	/* 1AD8: !  @$' */
	0x73,0x21,0x52,0xF1,0x48,0x24,0xF6,0x23,	/* 1AE0: s!RH$# */
	0xA8,0x75,0x21,0x20,0x20,0x40,0x24,0xF6,	/* 1AE8: u!  @$ */
	0x21,0xA6,0x70,0x23,0x28,0x21,0x3F,0x2F,	/* 1AF0: !p#(!?. */
	0x4B,0x24,0xF6,0x70,0x23,0x28,0x21,0xEF,	/* 1AF8: K$p#(! */
	0x42,0x70,0x23,0x28,0x26,0xED,0x24,0x0F,	/* 1B00: Bp#(&$. */
	0x70,0x23,0x28,0x21,0x3F,0x2F,0x4F,0x24,	/* 1B08: p#(!?.O$ */
	0xF6,0x44,0x24,0xFB,0x70,0x23,0x28,0x21,	/* 1B10: D$p#(! */
	0xEF,0x40,0x70,0x23,0x28,0x26,0xED,0x23,	/* 1B18: @p#(&# */
	0x06,0x75,0x21,0x20,0x20,0x40,0x24,0xF6,	/* 1B20: .u!  @$ */
	0x21,0xA9,0x70,0x23,0x28,0x20,0x39,0x2F,	/* 1B28: !p#( 9. */
	0x4F,0x24,0xF6,0x44,0x24,0xFB,0x70,0x23,	/* 1B30: O$D$p# */
	0x28,0x20,0xE9,0x41,0x70,0x23,0x28,0x26,	/* 1B38: ( Ap#(& */
	0xEC,0x21,0x04,0x70,0x23,0x28,0x20,0x39,	/* 1B40: !.p#( 9 */
	0x2F,0x4B,0x24,0xF6,0x70,0x23,0x28,0x20,	/* 1B48: .K$p#(  */
	0xE9,0x40,0x70,0x23,0x28,0x26,0xEC,0x74,	/* 1B50: @p#(&t */
	0x22,0x20,0x20,0x40,0x24,0xF6,0x21,0x20,	/* 1B58: "  @$!  */
	0xA7,0x73,0x21,0x52,0xF1,0x48,0x24,0xF6,	/* 1B60: s!RH$ */
	0x23,0xA8,0x75,0x22,0x20,0x20,0x40,0x24,	/* 1B68: #u"  @$ */
	0xF6,0x21,0xA9,0x70,0x23,0x28,0x20,0x39,	/* 1B70: !p#( 9 */
	0x2F,0x4F,0x24,0xF6,0x44,0x24,0xFB,0x70,	/* 1B78: .O$D$p */
	0x23,0x28,0x20,0xE9,0x41,0x70,0x23,0x28,	/* 1B80: #( Ap#( */
	0x26,0xEC,0x2D,0x0C,0x70,0x23,0x28,0x20,	/* 1B88: &-.p#(  */
	0x39,0x2F,0x4B,0x24,0xF6,0x70,0x23,0x28,	/* 1B90: 9.K$p#( */
	0x20,0xE9,0x40,0x70,0x23,0x28,0x26,0xEC,	/* 1B98:  @p#(& */
	0x2C,0x06,0x75,0x22,0x20,0x20,0x40,0x24,	/* 1BA0: ,.u"  @$ */
	0xF6,0x21,0xA6,0x70,0x23,0x28,0x21,0x3F,	/* 1BA8: !p#(!? */
	0x2F,0x4B,0x24,0xF6,0x70,0x23,0x28,0x21,	/* 1BB0: .K$p#(! */
	0xEF,0x42,0x70,0x23,0x28,0x26,0xED,0x2A,	/* 1BB8: Bp#(&* */
	0x07,0x70,0x23,0x28,0x21,0x3F,0x2F,0x4F,	/* 1BC0: .p#(!?.O */
	0x24,0xF6,0x44,0x24,0xFB,0x70,0x23,0x28,	/* 1BC8: $D$p#( */
	0x21,0xEF,0x40,0x70,0x23,0x28,0x26,0xED,	/* 1BD0: !@p#(& */
	0x28,0x0E,0x70,0x23,0x28,0x21,0x35,0x2F,	/* 1BD8: (.p#(!5. */
	0x40,0x24,0xF6,0x70,0x23,0x28,0x21,0xE5,	/* 1BE0: @$p#(! */
	0x40,0x70,0x23,0x28,0x26,0xED,0x21,0x07,	/* 1BE8: @p#(&!. */
	0x75,0x21,0x20,0x20,0x40,0x24,0xF6,0xA9,	/* 1BF0: u!  @$ */
	0x20,0x41,0x70,0x23,0x28,0x26,0xEC,0x07,	/* 1BF8:  Ap#(&. */
	0x20,0x40,0x70,0x23,0x28,0x26,0xEC,0x74,	/* 1C00:  @p#(&t */
	0x22,0x20,0x20,0x40,0x24,0xF6,0x25,0xA8,	/* 1C08: "  @$% */
	0x73,0x21,0x52,0xF1,0x48,0x24,0xF6,0x21,	/* 1C10: s!RH$! */
	0xA9,0x75,0x22,0x20,0x20,0x40,0x24,0xF6,	/* 1C18: u"  @$ */
	0xA9,0x20,0x41,0x70,0x23,0x28,0x26,0xEC,	/* 1C20:  Ap#(& */
	0x23,0x0E,0x40,0x70,0x23,0x28,0x26,0xEC,	/* 1C28: #.@p#(& */
	0x23,0x06,0x75,0x22,0x20,0x20,0x40,0x24,	/* 1C30: #.u"  @$ */
	0xF6,0x21,0xA9,0x70,0x23,0x28,0x21,0x35,	/* 1C38: !p#(!5 */
	0x2F,0x40,0x24,0xF6,0x49,0x24,0xFB,0x70,	/* 1C40: .@$I$p */
	0x23,0x28,0x21,0xE5,0x42,0x70,0x23,0x28,	/* 1C48: #(!Bp#( */
	0x26,0xED,0x21,0x04,0x70,0x23,0x28,0x21,	/* 1C50: &!.p#(! */
	0x35,0x2F,0x40,0x24,0xF6,0x70,0x23,0x28,	/* 1C58: 5.@$p#( */
	0x21,0xE5,0x40,0x70,0x23,0x28,0x26,0xED,	/* 1C60: !@p#(& */
	0xB1,0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,	/* 1C68: "`s1 */
	0x73,0x87,0xF1,0x73,0x32,0x27,0x2F,0x2F,	/* 1C70: ss2'.. */
	0x4F,0x24,0xF6,0x89,0x23,0xFB,0x73,0x87,	/* 1C78: O$#s */
	0xF1,0x70,0x23,0x28,0x27,0xEF,0x73,0x87,	/* 1C80: p#('s */
	0xF1,0x43,0x24,0xF6,0x70,0x23,0x28,0x26,	/* 1C88: C$p#(& */
	0xE8,0x74,0x21,0x20,0x20,0x40,0x24,0xF6,	/* 1C90: t!  @$ */
	0x23,0xA9,0x73,0x21,0x52,0xF1,0x48,0x24,	/* 1C98: #s!RH$ */
	0xF6,0x21,0xA9,0x75,0x21,0x20,0x20,0x40,	/* 1CA0: !u!  @ */
	0x24,0xF6,0xA9,0x20,0x42,0x70,0x23,0x28,	/* 1CA8: $ Bp#( */
	0x26,0xED,0x21,0x0F,0x40,0x70,0x23,0x28,	/* 1CB0: &!.@p#( */
	0x26,0xED,0x21,0x07,0x75,0x21,0x20,0x20,	/* 1CB8: &!.u!   */
	0x40,0x24,0xF6,0xA9,0x20,0x41,0x70,0x23,	/* 1CC0: @$ Ap# */
	0x28,0x26,0xEC,0x07,0x20,0x40,0x70,0x23,	/* 1CC8: (&. @p# */
	0x28,0x26,0xEC,0x74,0x22,0x20,0x20,0x40,	/* 1CD0: (&t"  @ */
	0x24,0xF6,0x23,0xAC,0x73,0x21,0x52,0xF1,	/* 1CD8: $#s!R */
	0x48,0x24,0xF6,0x21,0xAB,0x75,0x22,0x20,	/* 1CE0: H$!u"  */
	0x20,0x40,0x24,0xF6,0xAA,0x20,0x41,0x70,	/* 1CE8:  @$ Ap */
	0x23,0x28,0x26,0xEC,0xB1,0x22,0xF0,0x40,	/* 1CF0: #(&"@ */
	0x70,0x23,0x28,0x26,0xEC,0xB1,0x22,0xF0,	/* 1CF8: p#(&" */
	0x75,0x22,0x20,0x20,0x40,0x24,0xF6,0xAA,	/* 1D00: u"  @$ */
	0x20,0x42,0x70,0x23,0x28,0x26,0xED,0xB1,	/* 1D08:  Bp#(& */
	0x22,0xF0,0x40,0x70,0x23,0x28,0x26,0xED,	/* 1D10: "@p#(& */
	0xB1,0x22,0xF0,0x76,0xF6,0x82,0x00,0x04,	/* 1D18: "v.. */
	0x00,0x16,0x00,0x00,0x00,0x41,0x00,0x00,	/* 1D20: .....A.. */
	0x00,0x41,0x00,0x04,0x00,0x82,0x00,0x03,	/* 1D28: .A..... */
	0x00,0x41,0x00,0x03,0x00,0x82,0x00,0x02,	/* 1D30: .A..... */
	0x00,0x4E,0x00,0x02,0x00,0x41,0x00,0x02,	/* 1D38: .N...A.. */
	0x00,0x82,0x00,0x01,0x00,0x57,0x00,0x02,	/* 1D40: ....W.. */
	0x00,0x41,0x00,0x01,0x00,0x82,0x00,0x00,	/* 1D48: .A..... */
	0x00,0x2B,0x00,0x00,0x00,0xA3,0x00,0x04,	/* 1D50: .+..... */
	0x00,0x1B,0x00,0x00,0x00,0x51,0x00,0x00,	/* 1D58: .....Q.. */
	0x00,0x51,0x00,0x04,0x00,0xA3,0x00,0x03,	/* 1D60: .Q..... */
	0x00,0x51,0x00,0x03,0x00,0xA3,0x00,0x02,	/* 1D68: .Q..... */
	0x00,0x62,0x00,0x02,0x00,0x51,0x00,0x02,	/* 1D70: .b...Q.. */
	0x00,0xA3,0x00,0x01,0x00,0x6D,0x00,0x02,	/* 1D78: ....m.. */
	0x00,0x51,0x00,0x01,0x00,0xA3,0x00,0x00,	/* 1D80: .Q..... */
	0x00,0x36,0x00,0x00,0x00,0x36,0x00,0x05,	/* 1D88: .6...6.. */
	0x00,0x1B,0x00,0x05,0x00,0x0D,0x00,0x05,	/* 1D90: ........ */
	0x00,0xF4,0x00,0x04,0x00,0x6F,0x00,0x04,	/* 1D98: ....o.. */
	0x00,0x5B,0x00,0x04,0x00,0xF4,0x00,0x03,	/* 1DA0: .[..... */
	0x00,0x6D,0x00,0x01,0x00,0x38,0x00,0x00,	/* 1DA8: .m...8.. */
	0x00,0x31,0x00,0x00,0x00,0x29,0x00,0x00,	/* 1DB0: .1...).. */
	0x00,0x62,0x00,0x05,0x00,0x53,0x00,0x05,	/* 1DB8: .b...S.. */
	0x00,0xD9,0x00,0x00,0x00,0x30,0x00,0x05,	/* 1DC0: ....0.. */
	0x00,0x6D,0x00,0x00,0x00,0xF0,0x00,0x01,	/* 1DC8: .m..... */
	0x00,0x01,0x00,0x0A,0x00,0x0A,0x00,0x0A,	/* 1DD0: ........ */
	0x00,0x0A,0x00,0x09,0x00,0x08,0x00,0x06,	/* 1DD8: ........ */
	0x00,0x0A,0x00,0x03,0x00,0x02,0x00,0x01,	/* 1DE0: ........ */
	0x00,0xF0,0x00,0x01,0x00,0x01,0x00,0x0A,	/* 1DE8: ....... */
	0x00,0x0A,0x00,0x0A,0x00,0x0A,0x00,0x09,	/* 1DF0: ........ */
	0x00,0x08,0x00,0x06,0x00,0x0A,0x00,0x03,	/* 1DF8: ........ */
	0x00,0x02,0x00,0x01,0x00,0x01,0x00,0x01,	/* 1E00: ........ */
	0x00,0x01,0x00,0xF0,0x00,0x0A,0x00,0x0A,	/* 1E08: ....... */
	0x00,0x0A,0x00,0x06,0x00,0x01,0x00,0x01,	/* 1E10: ........ */
	0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x03,	/* 1E18: ........ */
	0x00,0x01,0x00,0x02,0x20,0x51,0x00,0x4F,	/* 1E20: .... Q.O */
	0x00,0x4D,0x00,0x4B,0x00,0x49,0x00,0x47,	/* 1E28: .M.K.I.G */
	0x00,0x45,0x00,0x43,0x00,0x41,0x00,0x3F,	/* 1E30: .E.C.A.? */
	0x00,0x3D,0x00,0x3B,0x00,0x39,0x00,0x37,	/* 1E38: .=.;.9.7 */
	0x00,0x35,0x00,0x33,0x00,0x31,0x00,0x2F,	/* 1E40: .5.3.1.. */
	0x00,0x2D,0x00,0x2C,0x00,0x3C,0x0C,0x71,	/* 1E48: .-.,.<.q */
	0x5D,0xD2,0x68,0x47,0x21,0xFB,0x72,0x25,	/* 1E50: ]hG!r% */
	0x47,0x24,0xFA,0x65,0x2D,0x42,0x21,0xFB,	/* 1E58: G$e-B! */
	0x72,0x25,0xE2,0x65,0x27,0x43,0x21,0xFB,	/* 1E60: r%e'C! */
	0x72,0x25,0xE0,0x65,0x26,0x45,0x21,0xFB,	/* 1E68: r%e&E! */
	0x72,0x24,0xEE,0x65,0x25,0x46,0x21,0xFB,	/* 1E70: r$e%F! */
	0x72,0x24,0xEC,0x66,0x23,0x49,0x21,0xFB,	/* 1E78: r$f#I! */
	0x72,0x24,0xEA,0x67,0x28,0x40,0x21,0xFB,	/* 1E80: r$g(@! */
	0x72,0x24,0xE8,0x67,0x26,0x45,0x21,0xFB,	/* 1E88: r$g&E! */
	0x72,0x24,0xE6,0x67,0x21,0x43,0x21,0xFB,	/* 1E90: r$g!C! */
	0x72,0x24,0xE4,0x68,0x2C,0x44,0x21,0xFB,	/* 1E98: r$h,D! */
	0x72,0x24,0xE2,0x6A,0x2A,0x4A,0x21,0xFB,	/* 1EA0: r$j*J! */
	0x72,0x24,0xE0,0x6A,0x29,0x4F,0x21,0xFB,	/* 1EA8: r$j)O! */
	0x72,0x23,0xEE,0x6A,0x29,0x44,0x21,0xFB,	/* 1EB0: r#j)D! */
	0x72,0x23,0xEC,0x6A,0x27,0x4D,0x21,0xFB,	/* 1EB8: r#j'M! */
	0x72,0x23,0xEA,0x6A,0x20,0x40,0x21,0xFB,	/* 1EC0: r#j @! */
	0x72,0x23,0xE8,0x6B,0x26,0x41,0x21,0xFB,	/* 1EC8: r#k&A! */
	0x72,0x23,0xE6,0x61,0x2C,0x2D,0x4A,0x21,	/* 1ED0: r#a,-J! */
	0xFB,0x72,0x23,0xE4,0x6B,0x21,0x43,0x21,	/* 1ED8: r#k!C! */
	0xFB,0x72,0x23,0xE2,0x61,0x2C,0x2C,0x49,	/* 1EE0: r#a,,I */
	0x21,0xFB,0x72,0x23,0xE0,0x61,0x2C,0x2C,	/* 1EE8: !r#a,, */
	0x40,0x21,0xFB,0x72,0x22,0xEE,0x72,0x6D,	/* 1EF0: @!r"rm */
	0x4A,0x21,0xFB,0x21,0x44,0x22,0x2D,0x22,	/* 1EF8: J!!D"-" */
	0x94,0x22,0xF0,0x60,0xBD,0x74,0x26,0x50,	/* 1F00: "`t&P */
	0xD1,0x21,0x28,0x40,0xD0,0x71,0x65,0x3C,	/* 1F08: !(@qe< */
	0x87,0xF1,0x81,0x71,0x65,0x3C,0x87,0x23,	/* 1F10: qe<# */
	0xFB,0x74,0x2C,0x93,0x70,0x57,0xF1,0x25,	/* 1F18: t,pW% */
	0xFA,0xD2,0xAE,0x72,0x71,0x62,0x59,0xFA,	/* 1F20: rqbY */
	0x30,0xD2,0x70,0x74,0x2B,0x25,0x97,0x2A,	/* 1F28: 0pt+%* */
	0xA8,0x70,0x31,0xD2,0x70,0x34,0x41,0x24,	/* 1F30: p1p4A$ */
	0xF6,0xC0,0x24,0xA8,0x70,0x8D,0xF1,0x70,	/* 1F38: $pp */
	0x56,0xF1,0xF4,0x23,0xAF,0x70,0x34,0x41,	/* 1F40: V#p4A */
	0x24,0xFB,0x70,0xE4,0x70,0x87,0xF1,0x70,	/* 1F48: $ppp */
	0x32,0x27,0x2F,0x2F,0x4F,0x24,0xF6,0x89,	/* 1F50: 2'..O$ */
	0x23,0xFB,0x70,0x87,0xF1,0x72,0x23,0x28,	/* 1F58: #pr#( */
	0x27,0xEF,0x70,0x87,0xF1,0x43,0x24,0xF6,	/* 1F60: 'pC$ */
	0x72,0x23,0x28,0x26,0xE8,0x72,0x23,0x28,	/* 1F68: r#(&r#( */
	0x20,0x36,0x2F,0x4F,0x24,0xF6,0x44,0x24,	/* 1F70:  6.O$D$ */
	0xFB,0x72,0x23,0x28,0x20,0xE6,0x41,0x70,	/* 1F78: r#( Ap */
	0x22,0x89,0x23,0xFB,0x70,0x34,0x21,0x40,	/* 1F80: "#p4!@ */
	0x24,0xF6,0x21,0xAC,0x41,0x70,0x55,0xF1,	/* 1F88: $!ApU */
	0x70,0x8B,0xF1,0xFC,0x2F,0x4F,0x24,0xF6,	/* 1F90: p.O$ */
	0x22,0x40,0xF0,0x24,0xFF,0xF0,0xC0,0xA8,	/* 1F98: "@$ */
	0x70,0x34,0x61,0x4F,0x24,0xF6,0x70,0xE4,	/* 1FA0: p4aO$p */
	0x70,0x22,0x50,0xF1,0x21,0x40,0x24,0xF6,	/* 1FA8: p"P!@$ */
	0x22,0xA7,0x70,0x87,0xF1,0x70,0x32,0x27,	/* 1FB0: "pp2' */
	0x2F,0x2F,0x4F,0x24,0xF6,0x89,0x23,0xFB,	/* 1FB8: ..O$# */
	0x70,0x87,0xF1,0x72,0x23,0x28,0x27,0xEF,	/* 1FC0: pr#(' */
	0x70,0x87,0xF1,0x43,0x24,0xF6,0x72,0x23,	/* 1FC8: pC$r# */
	0x28,0x26,0xE8,0x70,0x74,0x22,0x24,0x29,	/* 1FD0: (&pt"$) */
	0x96,0x70,0x21,0x37,0xD0,0x6D,0x0E,0x60,	/* 1FD8: p!7m.` */
	0xB4,0x7D,0x26,0x50,0xD6,0x76,0x30,0xD5,	/* 1FE0: }&Pv0 */
	0x76,0x31,0xD1,0x75,0x33,0xD0,0x71,0x44,	/* 1FE8: v1u3qD */
	0xF8,0x70,0x23,0x28,0x27,0xEF,0x70,0x23,	/* 1FF0: p#('p# */
	0x28,0x26,0x37,0x2F,0x4F,0x24,0xF6,0x25,	/* 1FF8: (&7.O$% */
	0xFA,0xD3,0x41,0x24,0xF6,0x25,0x26,0xAC,	/* 2000: A$%& */
	0x70,0x23,0x28,0x26,0x3B,0x2F,0x4F,0x24,	/* 2008: p#(&;.O$ */
	0xF6,0x25,0xFA,0xD2,0x43,0x24,0xF6,0x70,	/* 2010: %C$p */
	0x23,0x28,0x26,0xE8,0x71,0x72,0x43,0x24,	/* 2018: #(&qrC$ */
	0xF6,0x28,0xF1,0x75,0x55,0xFA,0x30,0xD4,	/* 2020: (uU0 */
	0x70,0x23,0x28,0x24,0x33,0x47,0x24,0xF6,	/* 2028: p#($3G$ */
	0x43,0xF4,0x2C,0xAF,0x40,0xD9,0x70,0x23,	/* 2030: C,@p# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0xD8,	/* 2038: (&2.O$ */
	0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,	/* 2040: p#(&2.O$ */
	0xF6,0xDB,0x78,0x48,0x24,0xF6,0x21,0xA0,	/* 2048: xH$! */
	0x74,0x21,0x89,0xF1,0x41,0x24,0xFB,0x74,	/* 2050: t!A$t */
	0x21,0x89,0x23,0xFB,0x41,0x76,0x22,0xE4,	/* 2058: !#Av" */
	0x78,0x47,0x24,0xF6,0xAD,0x74,0x21,0x50,	/* 2060: xG$t!P */
	0xF1,0x28,0x40,0x24,0xF6,0xA4,0x41,0x76,	/* 2068: (@$Av */
	0x22,0xE4,0x78,0x41,0x24,0xF6,0xA8,0x74,	/* 2070: "xA$t */
	0x21,0x3E,0x41,0xF2,0x74,0x21,0xEE,0x78,	/* 2078: !>At!x */
	0x42,0x24,0xF6,0xAA,0x74,0x21,0x3C,0x41,	/* 2080: B$t!<A */
	0xF2,0x74,0x21,0xEC,0x41,0xD9,0x78,0x44,	/* 2088: t!AxD */
	0x24,0xF6,0xAA,0x74,0x21,0x3D,0x41,0xF2,	/* 2090: $t!=A */
	0x74,0x21,0xED,0x41,0xD9,0x79,0x24,0x2C,	/* 2098: t!Ay$, */
	0xA9,0x74,0x21,0x50,0xF1,0x24,0x40,0x24,	/* 20A0: t!P$@$ */
	0xF6,0xA5,0x74,0x22,0x8B,0xF1,0xDB,0x74,	/* 20A8: t"t */
	0x55,0xF1,0xD8,0x74,0x8B,0xF1,0x25,0xFA,	/* 20B0: Ut% */
	0xD9,0x78,0x81,0xFC,0x2F,0x4F,0x24,0xF6,	/* 20B8: x.O$ */
	0x25,0xFA,0xDA,0x24,0x29,0xAC,0x7B,0x78,	/* 20C0: %$){x */
	0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,	/* 20C8: .O$t+P */
	0x23,0xFB,0x78,0x81,0x74,0x55,0x23,0xFB,	/* 20D0: #xtU# */
	0x79,0x78,0x81,0x81,0xFC,0x2F,0x4F,0x24,	/* 20D8: yx.O$ */
	0xF6,0xD7,0x74,0x34,0x48,0x24,0xF6,0x24,	/* 20E0: t4H$$ */
	0x28,0xA0,0x7A,0x21,0x4F,0xF9,0x24,0x27,	/* 20E8: (z!O$' */
	0xA9,0x22,0x40,0x77,0xF9,0x24,0x27,0xA2,	/* 20F0: "@w$' */
	0x74,0x34,0x21,0x40,0x24,0xFB,0x74,0xE4,	/* 20F8: t4!@$t */
	0x24,0x26,0x07,0x74,0x34,0x21,0x40,0x24,	/* 2100: $&.t4!@$ */
	0xF6,0xC0,0x24,0x24,0xA5,0x74,0x22,0x87,	/* 2108: $$t" */
	0xF1,0xC0,0xAC,0x74,0x21,0x54,0xF1,0x41,	/* 2110: t!TA */
	0x24,0xFB,0x74,0x21,0x54,0x23,0xFB,0x74,	/* 2118: $t!T#t */
	0x55,0xF1,0xD8,0x74,0x8B,0xF1,0x25,0xFA,	/* 2120: Ut% */
	0xD9,0x78,0x81,0xFC,0x2F,0x4F,0x24,0xF6,	/* 2128: x.O$ */
	0xDA,0x70,0x23,0x28,0x20,0x3E,0x2F,0x4F,	/* 2130: p#( >.O */
	0x24,0xF6,0xD7,0x7A,0x77,0xF9,0xA3,0x77,	/* 2138: $zww */
	0xDB,0x02,0x7A,0xDB,0x77,0x7B,0x2F,0x4F,	/* 2140: .zw{.O */
	0x24,0xF6,0xFC,0x2F,0x4F,0x24,0xF6,0xD7,	/* 2148: $.O$ */
	0x7B,0x2F,0x4F,0x24,0xF6,0x41,0xF4,0xDB,	/* 2150: {.O$A */
	0x41,0x22,0x40,0x7B,0x24,0xFF,0xF0,0xC0,	/* 2158: A"@{$ */
	0x23,0x2A,0xA3,0x7B,0x42,0x21,0xFB,0x28,	/* 2160: #*{B!( */
	0xF1,0xF6,0x23,0x28,0x00,0x20,0x23,0x26,	/* 2168: #(. #& */
	0x03,0x20,0x23,0x24,0x06,0x20,0x23,0x22,	/* 2170: . #$. #" */
	0x09,0x20,0x23,0x20,0x0C,0x20,0x22,0x2E,	/* 2178: . # . ". */
	0x0F,0x20,0x22,0x2D,0x02,0x20,0x22,0x2B,	/* 2180: . "-. "+ */
	0x05,0x20,0x22,0x29,0x08,0x20,0x22,0x27,	/* 2188: . "). "' */
	0x0B,0x20,0x22,0x25,0x0E,0x20,0x22,0x24,	/* 2190: . "%. "$ */
	0x01,0x20,0x22,0x22,0x04,0x20,0x22,0x20,	/* 2198: . "". "  */
	0x07,0x20,0x21,0x2E,0x0A,0x20,0x21,0x2C,	/* 21A0: . !.. !, */
	0x0D,0x20,0x21,0x2B,0x00,0x20,0x21,0x29,	/* 21A8: . !+. !) */
	0x03,0x20,0x21,0x27,0x06,0x20,0x21,0x25,	/* 21B0: . !'. !% */
	0x09,0x20,0x21,0x23,0x0C,0x20,0x21,0x21,	/* 21B8: . !#. !! */
	0x0F,0x20,0x21,0x20,0x02,0x20,0x2E,0x06,	/* 21C0: . ! . .. */
	0x20,0x20,0x2C,0x09,0x20,0x20,0x2A,0x0C,	/* 21C8:   ,.  *. */
	0x20,0x20,0x28,0x0F,0x20,0x20,0x27,0x02,	/* 21D0:   (.  '. */
	0x20,0x20,0x25,0x05,0x20,0x20,0x23,0x08,	/* 21D8:   %.  #. */
	0x20,0x20,0x21,0x0B,0x20,0x20,0x78,0xDB,	/* 21E0:   !.  x */
	0x78,0x81,0xD8,0x70,0x23,0x28,0x26,0x32,	/* 21E8: xp#(&2 */
	0x2F,0x4F,0x24,0xF6,0x7B,0x2F,0x4F,0x24,	/* 21F0: .O${.O$ */
	0xF6,0x74,0x2B,0x50,0xF2,0x23,0xFB,0x78,	/* 21F8: t+P#x */
	0xDB,0x78,0x81,0xD8,0x70,0x23,0x28,0x26,	/* 2200: xp#(& */
	0x32,0x2F,0x4F,0x24,0xF6,0x7B,0x2F,0x4F,	/* 2208: 2.O${.O */
	0x24,0xF6,0x74,0x2B,0x50,0xF2,0x23,0xFB,	/* 2210: $t+P# */
	0x78,0xDB,0x78,0x81,0xD8,0x70,0x23,0x28,	/* 2218: xxp#( */
	0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,0x2F,	/* 2220: &2.O${. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x23,	/* 2228: O$t+P# */
	0xFB,0x78,0xDB,0x78,0x81,0xD8,0x70,0x23,	/* 2230: xxp# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 2238: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,	/* 2240: .O$t+P */
	0x23,0xFB,0x78,0xDB,0x78,0x81,0xD8,0x70,	/* 2248: #xxp */
	0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,	/* 2250: #(&2.O$ */
	0x7B,0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,	/* 2258: {.O$t+P */
	0xF2,0x23,0xFB,0x78,0xDB,0x78,0x81,0xD8,	/* 2260: #xx */
	0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,	/* 2268: p#(&2.O$ */
	0xF6,0x7B,0x2F,0x4F,0x24,0xF6,0x74,0x2B,	/* 2270: {.O$t+ */
	0x50,0xF2,0x23,0xFB,0x78,0xDB,0x78,0x81,	/* 2278: P#xx */
	0xD8,0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,	/* 2280: p#(&2.O */
	0x24,0xF6,0x7B,0x2F,0x4F,0x24,0xF6,0x74,	/* 2288: ${.O$t */
	0x2B,0x50,0xF2,0x23,0xFB,0x78,0xDB,0x78,	/* 2290: +P#xx */
	0x81,0xD8,0x70,0x23,0x28,0x26,0x32,0x2F,	/* 2298: p#(&2. */
	0x4F,0x24,0xF6,0x7B,0x2F,0x4F,0x24,0xF6,	/* 22A0: O${.O$ */
	0x74,0x2B,0x50,0xF2,0x23,0xFB,0x78,0xDB,	/* 22A8: t+P#x */
	0x78,0x81,0xD8,0x70,0x23,0x28,0x26,0x32,	/* 22B0: xp#(&2 */
	0x2F,0x4F,0x24,0xF6,0x7B,0x2F,0x4F,0x24,	/* 22B8: .O${.O$ */
	0xF6,0x74,0x2B,0x50,0xF2,0x23,0xFB,0x78,	/* 22C0: t+P#x */
	0xDB,0x78,0x81,0xD8,0x70,0x23,0x28,0x26,	/* 22C8: xp#(& */
	0x32,0x2F,0x4F,0x24,0xF6,0x7B,0x2F,0x4F,	/* 22D0: 2.O${.O */
	0x24,0xF6,0x74,0x2B,0x50,0xF2,0x23,0xFB,	/* 22D8: $t+P# */
	0x78,0xDB,0x78,0x81,0xD8,0x70,0x23,0x28,	/* 22E0: xxp#( */
	0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,0x2F,	/* 22E8: &2.O${. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x23,	/* 22F0: O$t+P# */
	0xFB,0x78,0xDB,0x78,0x81,0xD8,0x70,0x23,	/* 22F8: xxp# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 2300: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,	/* 2308: .O$t+P */
	0x23,0xFB,0x78,0xDB,0x78,0x81,0xD8,0x70,	/* 2310: #xxp */
	0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,	/* 2318: #(&2.O$ */
	0x7B,0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,	/* 2320: {.O$t+P */
	0xF2,0x23,0xFB,0x78,0xDB,0x78,0x81,0xD8,	/* 2328: #xx */
	0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,	/* 2330: p#(&2.O$ */
	0xF6,0x7B,0x2F,0x4F,0x24,0xF6,0x74,0x2B,	/* 2338: {.O$t+ */
	0x50,0xF2,0x23,0xFB,0x78,0xDB,0x78,0x81,	/* 2340: P#xx */
	0xD8,0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,	/* 2348: p#(&2.O */
	0x24,0xF6,0x7B,0x2F,0x4F,0x24,0xF6,0x74,	/* 2350: ${.O$t */
	0x2B,0x50,0xF2,0x23,0xFB,0x78,0xDB,0x78,	/* 2358: +P#xx */
	0x81,0xD8,0x70,0x23,0x28,0x26,0x32,0x2F,	/* 2360: p#(&2. */
	0x4F,0x24,0xF6,0x7B,0x2F,0x4F,0x24,0xF6,	/* 2368: O${.O$ */
	0x74,0x2B,0x50,0xF2,0x23,0xFB,0x78,0xDB,	/* 2370: t+P#x */
	0x78,0x81,0xD8,0x70,0x23,0x28,0x26,0x32,	/* 2378: xp#(&2 */
	0x2F,0x4F,0x24,0xF6,0x7B,0x2F,0x4F,0x24,	/* 2380: .O${.O$ */
	0xF6,0x74,0x2B,0x50,0xF2,0x23,0xFB,0x78,	/* 2388: t+P#x */
	0xDB,0x78,0x81,0xD8,0x70,0x23,0x28,0x26,	/* 2390: xp#(& */
	0x32,0x2F,0x4F,0x24,0xF6,0x7B,0x2F,0x4F,	/* 2398: 2.O${.O */
	0x24,0xF6,0x74,0x2B,0x50,0xF2,0x23,0xFB,	/* 23A0: $t+P# */
	0x78,0xDB,0x78,0x81,0xD8,0x70,0x23,0x28,	/* 23A8: xxp#( */
	0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,0x2F,	/* 23B0: &2.O${. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x23,	/* 23B8: O$t+P# */
	0xFB,0x78,0xDB,0x78,0x81,0xD8,0x70,0x23,	/* 23C0: xxp# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 23C8: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,	/* 23D0: .O$t+P */
	0x23,0xFB,0x78,0xDB,0x78,0x81,0xD8,0x70,	/* 23D8: #xxp */
	0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,	/* 23E0: #(&2.O$ */
	0x7B,0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,	/* 23E8: {.O$t+P */
	0xF2,0x23,0xFB,0x78,0xDB,0x78,0x81,0xD8,	/* 23F0: #xx */
	0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,	/* 23F8: p#(&2.O$ */
	0xF6,0x7B,0x2F,0x4F,0x24,0xF6,0x74,0x2B,	/* 2400: {.O$t+ */
	0x50,0xF2,0x23,0xFB,0x78,0xDB,0x78,0x81,	/* 2408: P#xx */
	0xD8,0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,	/* 2410: p#(&2.O */
	0x24,0xF6,0x7B,0x2F,0x4F,0x24,0xF6,0x74,	/* 2418: ${.O$t */
	0x2B,0x50,0xF2,0x23,0xFB,0x78,0xDB,0x78,	/* 2420: +P#xx */
	0x81,0xD8,0x70,0x23,0x28,0x26,0x32,0x2F,	/* 2428: p#(&2. */
	0x4F,0x24,0xF6,0x7B,0x2F,0x4F,0x24,0xF6,	/* 2430: O${.O$ */
	0x74,0x2B,0x50,0xF2,0x23,0xFB,0x78,0xDB,	/* 2438: t+P#x */
	0x78,0x81,0xD8,0x70,0x23,0x28,0x26,0x32,	/* 2440: xp#(&2 */
	0x2F,0x4F,0x24,0xF6,0x7B,0x2F,0x4F,0x24,	/* 2448: .O${.O$ */
	0xF6,0x74,0x2B,0x50,0xF2,0x23,0xFB,0x78,	/* 2450: t+P#x */
	0xDB,0x78,0x81,0xD8,0x70,0x23,0x28,0x26,	/* 2458: xp#(& */
	0x32,0x2F,0x4F,0x24,0xF6,0x7B,0x2F,0x4F,	/* 2460: 2.O${.O */
	0x24,0xF6,0x74,0x2B,0x50,0xF2,0x23,0xFB,	/* 2468: $t+P# */
	0x78,0xDB,0x78,0x81,0xD8,0x70,0x23,0x28,	/* 2470: xxp#( */
	0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,0x2F,	/* 2478: &2.O${. */
	0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,0x23,	/* 2480: O$t+P# */
	0xFB,0x78,0xDB,0x78,0x81,0xD8,0x70,0x23,	/* 2488: xxp# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 2490: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,0xF2,	/* 2498: .O$t+P */
	0x23,0xFB,0x78,0xDB,0x78,0x81,0xD8,0x70,	/* 24A0: #xxp */
	0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,	/* 24A8: #(&2.O$ */
	0x7B,0x2F,0x4F,0x24,0xF6,0x74,0x2B,0x50,	/* 24B0: {.O$t+P */
	0xF2,0x23,0xFB,0x78,0xDB,0x78,0x81,0xD8,	/* 24B8: #xx */
	0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,	/* 24C0: p#(&2.O$ */
	0xF6,0x7B,0x2F,0x4F,0x24,0xF6,0x74,0x2B,	/* 24C8: {.O$t+ */
	0x50,0xF2,0x23,0xFB,0x78,0xDB,0x78,0x81,	/* 24D0: P#xx */
	0xD8,0x70,0x23,0x28,0x26,0x32,0x2F,0x4F,	/* 24D8: p#(&2.O */
	0x24,0xF6,0x7B,0x2F,0x4F,0x24,0xF6,0x74,	/* 24E0: ${.O$t */
	0x2B,0x50,0xF2,0x23,0xFB,0x78,0xDB,0x78,	/* 24E8: +P#xx */
	0x81,0xD8,0x70,0x23,0x28,0x26,0x32,0x2F,	/* 24F0: p#(&2. */
	0x4F,0x24,0xF6,0x7B,0x2F,0x4F,0x24,0xF6,	/* 24F8: O${.O$ */
	0x74,0x2B,0x50,0xF2,0x23,0xFB,0x78,0x74,	/* 2500: t+P#xt */
	0x55,0x23,0xFB,0x77,0x74,0x21,0x3F,0xF2,	/* 2508: U#wt!? */
	0x74,0x21,0xEF,0x77,0x77,0x60,0x8F,0xD7,	/* 2510: t!ww` */
	0x2F,0x4F,0x24,0xF6,0x21,0xA2,0x70,0x23,	/* 2518: .O$!p# */
	0x28,0x26,0x32,0x77,0x77,0x60,0x8F,0xD7,	/* 2520: (&2ww` */
	0x2F,0x4F,0x24,0xF6,0xA3,0x20,0x61,0x0E,	/* 2528: .O$ a. */
	0x79,0x78,0x81,0xFC,0x2F,0x4F,0x24,0xF6,	/* 2530: yx.O$ */
	0xD7,0x74,0x34,0x48,0x24,0xF6,0x21,0xA2,	/* 2538: t4H$! */
	0x7A,0x21,0x4F,0xF9,0xAD,0x22,0x40,0x77,	/* 2540: z!O"@w */
	0xF9,0xA8,0x74,0x34,0x21,0x40,0x24,0xFB,	/* 2548: t4!@$ */
	0x74,0xE4,0x41,0x76,0x22,0xE5,0x72,0x23,	/* 2550: tAv"r# */
	0x4F,0x24,0xF6,0x70,0x23,0x28,0x26,0xEB,	/* 2558: O$p#(& */
	0x21,0x02,0x77,0x74,0x21,0x3F,0xF2,0x74,	/* 2560: !.wt!?t */
	0x21,0xEF,0x72,0x23,0x4F,0x24,0xF6,0x70,	/* 2568: !r#O$p */
	0x23,0x28,0x26,0xEB,0x73,0x42,0x24,0xF6,	/* 2570: #(&sB$ */
	0x24,0x27,0xA0,0x70,0x23,0x28,0x26,0x3A,	/* 2578: $'p#(&: */
	0x2F,0x4F,0x24,0xF6,0x25,0xFA,0xD2,0x43,	/* 2580: .O$%C */
	0x24,0xF6,0x70,0x23,0x28,0x26,0xE8,0x71,	/* 2588: $p#(&q */
	0x72,0x43,0x24,0xF6,0x28,0xF1,0x75,0x55,	/* 2590: rC$(uU */
	0xFA,0x30,0x25,0xFA,0xD4,0x22,0x87,0xF1,	/* 2598: 0%" */
	0xC0,0xAC,0x74,0x21,0x54,0xF1,0x42,0x24,	/* 25A0: t!TB$ */
	0xFB,0x74,0x21,0x54,0x23,0xFB,0x74,0x23,	/* 25A8: t!T#t# */
	0x85,0xF1,0xA9,0x74,0x7D,0x21,0x2D,0x2A,	/* 25B0: t}!-* */
	0x92,0x24,0x22,0x05,0x74,0x8D,0xF1,0xDA,	/* 25B8: $".t */
	0x74,0x56,0xF1,0xD9,0x74,0x34,0x21,0x20,	/* 25C0: tVt4!  */
	0x40,0x24,0xF6,0x22,0xA8,0x74,0x34,0x61,	/* 25C8: @$"t4a */
	0x2F,0x4F,0x24,0xF6,0x74,0xE4,0x74,0x34,	/* 25D0: .O$tt4 */
	0x22,0x20,0x40,0x24,0xFB,0x74,0xE4,0x74,	/* 25D8: " @$tt */
	0x34,0x60,0x4E,0x24,0xF6,0x74,0xE4,0x70,	/* 25E0: 4`N$tp */
	0x23,0x28,0x20,0x36,0x2F,0x49,0x24,0xF6,	/* 25E8: #( 6.I$ */
	0x70,0x23,0x28,0x20,0xE6,0x7A,0x79,0xFC,	/* 25F0: p#( zy */
	0x2F,0x4F,0x24,0xF6,0x25,0xFA,0xD8,0x74,	/* 25F8: .O$%t */
	0x21,0x55,0xF1,0xF9,0xA6,0x74,0x21,0x55,	/* 2600: !Ut!U */
	0xF1,0xD7,0x02,0x78,0xD7,0x77,0x2F,0x4F,	/* 2608: .xw.O */
	0x24,0xF6,0x25,0xFA,0xD7,0xC0,0x21,0xA0,	/* 2610: $%! */
	0x70,0x23,0x28,0x20,0x36,0x44,0x24,0xF6,	/* 2618: p#( 6D$ */
	0xA7,0x42,0x74,0x22,0x52,0x23,0xFB,0x06,	/* 2620: Bt"R#. */
	0x77,0x74,0x22,0x52,0x23,0xFB,0x77,0x41,	/* 2628: wt"R#wA */
	0xF4,0xD7,0x41,0x22,0x40,0x77,0x24,0xFF,	/* 2630: A"@w$ */
	0xF0,0xC0,0x23,0x20,0xA3,0x77,0x42,0x21,	/* 2638: # wB! */
	0xFB,0x28,0xF1,0xF6,0x22,0x2E,0x05,0x20,	/* 2640: ("..  */
	0x22,0x2C,0x0D,0x20,0x22,0x2B,0x05,0x20,	/* 2648: ",. "+.  */
	0x22,0x29,0x0D,0x20,0x22,0x28,0x05,0x20,	/* 2650: "). "(.  */
	0x22,0x26,0x0D,0x20,0x22,0x25,0x05,0x20,	/* 2658: "&. "%.  */
	0x22,0x23,0x0D,0x20,0x22,0x22,0x05,0x20,	/* 2660: "#. "".  */
	0x22,0x20,0x0D,0x20,0x21,0x2F,0x05,0x20,	/* 2668: " . !..  */
	0x21,0x2D,0x0D,0x20,0x21,0x2C,0x05,0x20,	/* 2670: !-. !,.  */
	0x21,0x2A,0x0D,0x20,0x21,0x29,0x05,0x20,	/* 2678: !*. !).  */
	0x21,0x27,0x0D,0x20,0x21,0x26,0x05,0x20,	/* 2680: !'. !&.  */
	0x21,0x24,0x0D,0x20,0x21,0x23,0x05,0x20,	/* 2688: !$. !#.  */
	0x21,0x21,0x0D,0x20,0x21,0x20,0x05,0x20,	/* 2690: !!. ! .  */
	0x2E,0x0E,0x20,0x20,0x2D,0x06,0x20,0x20,	/* 2698: ..  -.   */
	0x2B,0x0E,0x20,0x20,0x2A,0x06,0x20,0x20,	/* 26A0: +.  *.   */
	0x28,0x0E,0x20,0x20,0x27,0x06,0x20,0x20,	/* 26A8: (.  '.   */
	0x25,0x0E,0x20,0x20,0x24,0x06,0x20,0x20,	/* 26B0: %.  $.   */
	0x22,0x0E,0x20,0x20,0x21,0x06,0x20,0x20,	/* 26B8: ".  !.   */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 26C0: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 26C8: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 26D0: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 26D8: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 26E0: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 26E8: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 26F0: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 26F8: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2700: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2708: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2710: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2718: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2720: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2728: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2730: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2738: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2740: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2748: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2750: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2758: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2760: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2768: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2770: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2778: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2780: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2788: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2790: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2798: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 27A0: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 27A8: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 27B0: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 27B8: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 27C0: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 27C8: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 27D0: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 27D8: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 27E0: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 27E8: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 27F0: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 27F8: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2800: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2808: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2810: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2818: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2820: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2828: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2830: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2838: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2840: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2848: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2850: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2858: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2860: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2868: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2870: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2878: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2880: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2888: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2890: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2898: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 28A0: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 28A8: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 28B0: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 28B8: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 28C0: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 28C8: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 28D0: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 28D8: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 28E0: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 28E8: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 28F0: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 28F8: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2900: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2908: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2910: p#(& */
	0x79,0xD7,0x79,0x81,0xD9,0x74,0x23,0x50,	/* 2918: yyt#P */
	0x77,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x70,	/* 2920: w.O$p */
	0x23,0x28,0x26,0xE3,0x79,0xD7,0x79,0x81,	/* 2928: #(&yy */
	0xD9,0x74,0x23,0x50,0x77,0x2F,0x4F,0x24,	/* 2930: t#Pw.O$ */
	0xF6,0xF2,0xF1,0x70,0x23,0x28,0x26,0xE3,	/* 2938: p#(& */
	0x7A,0x79,0xFC,0x2F,0x4F,0x24,0xF6,0xD7,	/* 2940: zy.O$ */
	0x79,0x74,0x56,0x23,0xFB,0x78,0x2C,0x40,	/* 2948: ytV#x,@ */
	0xF9,0x21,0xA0,0x2C,0x41,0x77,0xF9,0xAB,	/* 2950: !,Aw */
	0x74,0x34,0x28,0x20,0x40,0x24,0xFB,0x74,	/* 2958: t4( @$t */
	0xE4,0x22,0x01,0x78,0x24,0x40,0xF9,0x21,	/* 2960: ".x$@! */
	0xAB,0x24,0x41,0x77,0xF9,0x21,0xA5,0x74,	/* 2968: $Aw!t */
	0x34,0x28,0x20,0x40,0x24,0xF6,0xAD,0x74,	/* 2970: 4( @$t */
	0x34,0x68,0x2F,0x4F,0x24,0xF6,0x74,0xE4,	/* 2978: 4h.O$t */
	0x41,0x76,0x22,0xE4,0x77,0xAE,0x74,0x24,	/* 2980: Av"wt$ */
	0x81,0xF1,0x41,0x24,0xFB,0x74,0x24,0x81,	/* 2988: A$t$ */
	0x23,0xFB,0x24,0x0D,0x70,0x23,0x28,0x20,	/* 2990: #$.p#(  */
	0x36,0x44,0x24,0xF6,0x21,0xA3,0x70,0x23,	/* 2998: 6D$!p# */
	0x28,0x20,0x36,0x2F,0x4B,0x24,0xF6,0x42,	/* 29A0: ( 6.K$B */
	0x24,0xFB,0x70,0x23,0x28,0x20,0xE6,0x23,	/* 29A8: $p#( # */
	0x00,0x74,0x34,0x60,0x4E,0x24,0xF6,0x74,	/* 29B0: .t4`N$t */
	0xE4,0x70,0x23,0x28,0x20,0x36,0x2F,0x49,	/* 29B8: p#( 6.I */
	0x24,0xF6,0x70,0x23,0x28,0x20,0xE6,0x74,	/* 29C0: $p#( t */
	0x24,0x81,0xF1,0x41,0x24,0xF6,0x21,0xA1,	/* 29C8: $A$! */
	0x41,0x76,0x22,0xE4,0x74,0x24,0x81,0xF1,	/* 29D0: Av"t$ */
	0x60,0x4E,0x24,0xF6,0x74,0x24,0x81,0x23,	/* 29D8: `N$t$# */
	0xFB,0x72,0x23,0x4F,0x24,0xF6,0x70,0x23,	/* 29E0: r#O$p# */
	0x28,0x26,0xEA,0x73,0x44,0x24,0xF6,0x25,	/* 29E8: (&sD$% */
	0xA9,0x70,0x23,0x28,0x26,0x39,0x2F,0x4F,	/* 29F0: p#(&9.O */
	0x24,0xF6,0x25,0xFA,0xD2,0x43,0x24,0xF6,	/* 29F8: $%C$ */
	0x70,0x23,0x28,0x26,0xE8,0x71,0x72,0x43,	/* 2A00: p#(&qrC */
	0x24,0xF6,0x28,0xF1,0x75,0x55,0xFA,0x30,	/* 2A08: $(uU0 */
	0x25,0xFA,0xD4,0x7D,0x21,0x2A,0x25,0x97,	/* 2A10: %}!*% */
	0x74,0x7D,0x62,0x2E,0x2A,0x93,0x74,0x22,	/* 2A18: t}b.*t" */
	0x87,0xF1,0xC0,0xAC,0x74,0x21,0x54,0xF1,	/* 2A20: t!T */
	0x44,0x24,0xFB,0x74,0x21,0x54,0x23,0xFB,	/* 2A28: D$t!T# */
	0x41,0x76,0x22,0xE4,0x74,0x21,0x89,0xF1,	/* 2A30: Av"t! */
	0x42,0x24,0xFB,0x74,0x21,0x89,0x23,0xFB,	/* 2A38: B$t!# */
	0x72,0x23,0x4F,0x24,0xF6,0x70,0x23,0x28,	/* 2A40: r#O$p#( */
	0x26,0xE9,0x71,0x81,0x2F,0x4F,0x24,0xF6,	/* 2A48: &q.O$ */
	0x25,0xFA,0xD1,0x41,0xF9,0x21,0xA2,0x40,	/* 2A50: %A!@ */
	0xD1,0x75,0x30,0xAA,0x75,0x30,0x27,0x2F,	/* 2A58: u0u0'. */
	0x2F,0x4F,0x24,0xF6,0xD5,0x03,0x28,0x40,	/* 2A60: .O$.(@ */
	0xD5,0x73,0xC0,0x21,0xA0,0x75,0x76,0x30,	/* 2A68: s!uv0 */
	0xF4,0xC0,0x6A,0x27,0xA6,0x71,0x76,0x31,	/* 2A70: j'qv1 */
	0xF4,0xA3,0x6A,0x26,0x0E,0x75,0x76,0xE0,	/* 2A78: j&.uv */
	0x71,0x76,0xE1,0xBC,0x22,0xF0,0x76,0xF6,	/* 2A80: qv"v */
	0x80,0x68,0x08,0x71,0x26,0x50,0xD2,0x60,	/* 2A88: h.q&P` */
	0x45,0x21,0xFB,0x72,0x41,0x24,0xFA,0x22,	/* 2A90: E!rA$" */
	0xF0,0x60,0xBF,0x73,0x31,0x25,0xFA,0xD0,	/* 2A98: `s1% */
	0x21,0x40,0x24,0xF6,0x21,0xA5,0x70,0x61,	/* 2AA0: !@$!pa */
	0x4F,0x24,0xF6,0x23,0x28,0x20,0x3D,0x2F,	/* 2AA8: O$#( =. */
	0x4F,0x24,0xF6,0x23,0xF2,0x41,0x24,0xF0,	/* 2AB0: O$#A$ */
	0xB1,0x22,0xF0,0x70,0x61,0x4F,0x24,0xF6,	/* 2AB8: "paO$ */
	0x23,0x28,0x20,0x3D,0x2F,0x4F,0x24,0xF6,	/* 2AC0: #( =.O$ */
	0x23,0xF2,0x41,0x24,0xF1,0xB1,0x22,0xF0,	/* 2AC8: #A$" */
	0x60,0xBE,0x74,0x31,0xD1,0x74,0x32,0x27,	/* 2AD0: `t1t2' */
	0x2F,0x2F,0x4F,0x24,0xF6,0xD0,0x75,0x41,	/* 2AD8: ..O$uA */
	0xF4,0xAF,0x74,0x8F,0xF1,0x23,0xF2,0x70,	/* 2AE0: t#p */
	0x52,0xF1,0x24,0xF6,0x70,0x52,0x23,0xFB,	/* 2AE8: R$pR# */
	0x0C,0x70,0x52,0xF1,0x74,0x8F,0xF1,0x24,	/* 2AF0: .pRt$ */
	0xFB,0x70,0x52,0x23,0xFB,0x70,0x52,0xF1,	/* 2AF8: pR#pR */
	0x23,0xF2,0x71,0x6F,0x40,0x24,0xF6,0x28,	/* 2B00: #qo@$( */
	0x40,0x24,0xFB,0x23,0x28,0x20,0xE0,0xB2,	/* 2B08: @$#(  */
	0x22,0xF0,0x60,0xB8,0x7A,0x31,0xD2,0x7A,	/* 2B10: "`z1z */
	0x55,0xF1,0xD4,0x7A,0x8B,0xF1,0xD6,0x74,	/* 2B18: Uzt */
	0x76,0xFC,0x2F,0x4F,0x24,0xF6,0xD7,0x7C,	/* 2B20: v.O$| */
	0x30,0xD3,0x7A,0x22,0x81,0xF1,0xD5,0x40,	/* 2B28: 0z"@ */
	0xD1,0x24,0x40,0x72,0x23,0x28,0x20,0xE2,	/* 2B30: $@r#(  */
	0x72,0x23,0x28,0x20,0x33,0x2F,0x4F,0x24,	/* 2B38: r#( 3.O$ */
	0xF6,0x7A,0x22,0x83,0xF1,0x24,0xF6,0x25,	/* 2B40: z"$% */
	0xFA,0xD0,0xC0,0x23,0xAD,0x7B,0x28,0x40,	/* 2B48: #{(@ */
	0x24,0xF6,0x23,0xA6,0x75,0x41,0x24,0xF6,	/* 2B50: $#uA$ */
	0xA4,0x41,0xD1,0x22,0x0D,0x75,0x42,0x24,	/* 2B58: A".uB$ */
	0xF6,0x21,0xA4,0x7A,0x21,0x89,0xF1,0x41,	/* 2B60: !z!A */
	0x24,0xFB,0x7A,0x21,0x89,0x23,0xFB,0x41,	/* 2B68: $z!#A */
	0x79,0x28,0xE4,0x41,0xD1,0x21,0x03,0x74,	/* 2B70: y(A!.t */
	0xD1,0x74,0x81,0xD4,0x40,0x71,0x2F,0x4F,	/* 2B78: t@q.O */
	0x24,0xF6,0x7A,0x2B,0x50,0xF2,0x23,0xFB,	/* 2B80: $z+P# */
	0x41,0xD1,0x73,0x42,0x24,0xF6,0x25,0xA1,	/* 2B88: AsB$% */
	0x73,0x44,0x24,0xF6,0xAE,0x73,0x41,0x24,	/* 2B90: sD$sA$ */
	0xF6,0xC0,0x21,0xAB,0x7A,0x58,0xF1,0x70,	/* 2B98: !zXp */
	0xF4,0x21,0xA4,0x7A,0x58,0xF1,0x70,0xF4,	/* 2BA0: !zXp */
	0xC0,0x22,0xA3,0x7A,0x21,0x81,0xF1,0x70,	/* 2BA8: "z!p */
	0xF4,0x21,0xAB,0x41,0xD1,0x21,0x07,0x73,	/* 2BB0: !A!.s */
	0x60,0x4B,0x24,0xF6,0xD3,0x7A,0x58,0xF1,	/* 2BB8: `K$zX */
	0x70,0xF4,0xA9,0x7A,0x21,0x81,0xF1,0x70,	/* 2BC0: pz!p */
	0xF4,0xC0,0xA3,0x20,0x41,0xD1,0x7A,0x21,	/* 2BC8:  Az! */
	0x81,0xF1,0x70,0xF4,0xC0,0xAB,0x71,0xC0,	/* 2BD0: pq */
	0xA8,0x20,0x73,0x44,0x24,0xFB,0xD3,0x41,	/* 2BD8:  sD$A */
	0xD1,0x7B,0x27,0x40,0x24,0xF6,0x26,0xA4,	/* 2BE0: {'@$& */
	0x71,0xC0,0x26,0xA0,0x73,0x67,0x20,0x20,	/* 2BE8: q&sg   */
	0x40,0x24,0xF6,0x25,0xA7,0x75,0x48,0x24,	/* 2BF0: @$%uH$ */
	0xF6,0xA5,0x20,0x41,0xD1,0x27,0x0D,0x75,	/* 2BF8:  A'.u */
	0x44,0x24,0xF6,0x23,0xA2,0x2F,0x4F,0x74,	/* 2C00: D$#.Ot */
	0x2F,0x4F,0x24,0xF6,0x7A,0x2B,0x50,0xF2,	/* 2C08: .O$z+P */
	0x23,0xFB,0x40,0x74,0x81,0x2F,0x4F,0x24,	/* 2C10: #@t.O$ */
	0xF6,0x7A,0x2B,0x50,0xF2,0x23,0xFB,0x74,	/* 2C18: z+P#t */
	0x81,0x81,0x25,0xFA,0xD1,0x81,0xD4,0x70,	/* 2C20: %p */
	0x71,0x2F,0x4F,0x24,0xF6,0x7A,0x2B,0x50,	/* 2C28: q.O$z+P */
	0xF2,0x23,0xFB,0x41,0xD1,0x24,0x05,0x74,	/* 2C30: #A$.t */
	0xD1,0x74,0x81,0xD4,0x40,0x71,0x2F,0x4F,	/* 2C38: t@q.O */
	0x24,0xF6,0x7A,0x2B,0x50,0xF2,0x23,0xFB,	/* 2C40: $z+P# */
	0x41,0xD1,0x23,0x00,0x70,0x2F,0x4F,0xF4,	/* 2C48: A#.p.O */
	0xC0,0x22,0xA9,0x75,0x44,0x24,0xF6,0x22,	/* 2C50: "uD$" */
	0xA3,0x2F,0x4F,0x74,0x2F,0x4F,0x24,0xF6,	/* 2C58: .Ot.O$ */
	0x7A,0x2B,0x50,0xF2,0x23,0xFB,0x74,0x81,	/* 2C60: z+P#t */
	0x25,0xFA,0xD1,0x81,0xD4,0x2F,0x4F,0x71,	/* 2C68: %.Oq */
	0x2F,0x4F,0x24,0xF6,0x7A,0x2B,0x50,0xF2,	/* 2C70: .O$z+P */
	0x23,0xFB,0x41,0xD1,0x71,0xC0,0x22,0xA6,	/* 2C78: #Aq" */
	0x41,0x74,0x76,0xFC,0x2F,0x4F,0x24,0xF6,	/* 2C80: Atv.O$ */
	0x2F,0x4E,0xF0,0x24,0xFF,0xF0,0xC0,0x21,	/* 2C88: .N$! */
	0xA5,0x74,0xD1,0x74,0x81,0xD4,0x70,0x71,	/* 2C90: ttpq */
	0x2F,0x4F,0x24,0xF6,0x7A,0x2B,0x50,0xF2,	/* 2C98: .O$z+P */
	0x23,0xFB,0x41,0x79,0x28,0xE5,0x72,0x23,	/* 2CA0: #Ay(r# */
	0x28,0x20,0x31,0x2F,0x4F,0x24,0xF6,0x25,	/* 2CA8: ( 1.O$% */
	0xFA,0xDB,0x41,0x24,0xF6,0xA3,0x61,0x27,	/* 2CB0: A$a' */
	0x06,0x2C,0x40,0x77,0xF9,0x24,0xA8,0x41,	/* 2CB8: .,@w$A */
	0x74,0x76,0xFC,0x2F,0x4F,0x24,0xF6,0x2B,	/* 2CC0: tv.O$+ */
	0x4F,0x24,0xFF,0xF0,0xC0,0x23,0xA8,0x73,	/* 2CC8: O$#s */
	0x48,0x24,0xF6,0x23,0xA2,0x7A,0x21,0x58,	/* 2CD0: H$#z!X */
	0xF1,0x48,0x24,0xF6,0x21,0xA3,0x73,0x22,	/* 2CD8: H$!s" */
	0x40,0x24,0xF6,0xA7,0x73,0x64,0x4F,0x24,	/* 2CE0: @$sdO$ */
	0xF6,0xD3,0x06,0x73,0x2D,0x40,0x24,0xFB,	/* 2CE8: .s-@$ */
	0xD3,0x7A,0x23,0x81,0xF1,0x28,0x40,0x24,	/* 2CF0: z#(@$ */
	0xF6,0xAD,0x29,0x40,0x72,0x23,0x28,0x20,	/* 2CF8: )@r#(  */
	0xE2,0x73,0x21,0x40,0x24,0xFB,0xD3,0x74,	/* 2D00: s!@$t */
	0x7A,0x55,0x23,0xFB,0x73,0x7C,0xE0,0xB8,	/* 2D08: zU#s| */
	0x22,0xF0,0x60,0xB7,0x7A,0x26,0x52,0xD5,	/* 2D10: "`z&R */
	0x21,0x28,0x40,0xD1,0x71,0x21,0x37,0x25,	/* 2D18: !(@q!7% */
	0xFA,0xD1,0x57,0xF1,0x25,0xFA,0xD0,0xAC,	/* 2D20: W% */
	0x70,0x75,0xFA,0x30,0xD0,0x71,0x7A,0x25,	/* 2D28: pu0qz% */
	0x29,0x9D,0x61,0xA8,0x71,0x31,0x25,0xFA,	/* 2D30: )aq1% */
	0xD3,0x21,0x20,0x20,0x40,0x24,0xF6,0x2A,	/* 2D38: !  @$* */
	0xAF,0x73,0x23,0x28,0x20,0x31,0x2F,0x4F,	/* 2D40: s#( 1.O */
	0x24,0xF6,0x25,0xFA,0xD2,0x44,0x24,0xF6,	/* 2D48: $%D$ */
	0x28,0xA6,0x71,0x56,0xF1,0xD0,0x71,0x8D,	/* 2D50: (qVq */
	0xF1,0x70,0xFC,0x2F,0x4F,0x24,0xF6,0x25,	/* 2D58: p.O$% */
	0xFA,0xD7,0x25,0xA4,0x71,0x23,0x50,0x70,	/* 2D60: %q#Pp */
	0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x73,0x23,	/* 2D68: .O$s# */
	0x28,0x20,0xE3,0x41,0x71,0x22,0x52,0x23,	/* 2D70: ( Aq"R# */
	0xFB,0x70,0x81,0x71,0x56,0x23,0xFB,0x71,	/* 2D78: pqV#q */
	0x34,0x28,0x20,0x40,0x24,0xF6,0x21,0xA4,	/* 2D80: 4( @$! */
	0x24,0x41,0x77,0xF9,0x21,0xAC,0x71,0x34,	/* 2D88: $Aw!q4 */
	0x68,0x2F,0x4F,0x24,0xF6,0x71,0xE4,0x41,	/* 2D90: h.O$qA */
	0x75,0x22,0xE2,0x0E,0x77,0x2B,0x4F,0xF9,	/* 2D98: u".w+O */
	0xA9,0x71,0x34,0x28,0x20,0x40,0x24,0xFB,	/* 2DA0: q4( @$ */
	0x71,0xE4,0x71,0x24,0x81,0xF1,0x41,0x24,	/* 2DA8: qq$A$ */
	0xFB,0x71,0x24,0x81,0x23,0xFB,0x22,0x00,	/* 2DB0: q$#". */
	0x71,0x24,0x81,0xF1,0x41,0x24,0xF6,0x21,	/* 2DB8: q$A$! */
	0xA1,0x41,0x75,0x22,0xE2,0x71,0x24,0x81,	/* 2DC0: Au"q$ */
	0xF1,0x60,0x4E,0x24,0xF6,0x71,0x24,0x81,	/* 2DC8: `N$q$ */
	0x23,0xFB,0x40,0x71,0x22,0x52,0x23,0xFB,	/* 2DD0: #@q"R# */
	0x72,0x41,0x24,0xF6,0x21,0x29,0xA2,0x71,	/* 2DD8: rA$!)q */
	0x34,0xD6,0x16,0xD0,0x72,0x71,0x7A,0x62,	/* 2DE0: 4.rqzb */
	0x22,0x98,0x76,0x71,0xE4,0x21,0x28,0x01,	/* 2DE8: "vq!(. */
	0x71,0x34,0xD4,0x73,0x23,0x28,0x20,0x31,	/* 2DF0: q4s#( 1 */
	0x2F,0x4F,0x24,0xF6,0x25,0xFA,0xD2,0x44,	/* 2DF8: .O$%D */
	0x24,0xF6,0x21,0x21,0xA2,0x74,0x24,0x40,	/* 2E00: $!!t$@ */
	0x24,0xF6,0x23,0xAB,0x74,0x28,0x40,0x24,	/* 2E08: $#t(@$ */
	0xF6,0x21,0xAE,0x71,0x21,0x83,0xF1,0x73,	/* 2E10: !q!s */
	0x23,0x28,0x20,0xE3,0x41,0x71,0x22,0x52,	/* 2E18: #( Aq"R */
	0x23,0xFB,0x74,0x22,0x40,0x24,0xFB,0x25,	/* 2E20: #t"@$% */
	0xFA,0xD4,0x6C,0x4F,0x24,0xF6,0xD4,0x2E,	/* 2E28: lO$. */
	0x06,0x71,0x59,0xF1,0x73,0x23,0x28,0x20,	/* 2E30: .qYs#(  */
	0xE3,0x41,0x71,0x22,0x52,0x23,0xFB,0x74,	/* 2E38: Aq"R#t */
	0x67,0x4F,0x24,0xF6,0xD4,0x2D,0x00,0x74,	/* 2E40: gO$-.t */
	0x44,0x24,0xF6,0xC0,0x2C,0xA9,0x71,0x56,	/* 2E48: D$,qV */
	0xF1,0xD0,0x71,0x8D,0xF1,0x70,0xFC,0x2F,	/* 2E50: qp. */
	0x4F,0x24,0xF6,0x25,0xFA,0xD7,0x29,0xA7,	/* 2E58: O$%) */
	0x70,0x71,0x23,0x50,0xF2,0xF1,0x25,0xFA,	/* 2E60: pq#P% */
	0xD8,0x4A,0xF4,0xC0,0x23,0xAC,0x74,0x24,	/* 2E68: J#t$ */
	0x20,0x40,0x24,0xF6,0x23,0xA4,0x74,0x21,	/* 2E70:  @$#t! */
	0x20,0x40,0x24,0xF6,0x21,0xA8,0x78,0x73,	/* 2E78:  @$!xs */
	0x23,0x28,0x20,0xE3,0x41,0x71,0x22,0x52,	/* 2E80: #( Aq"R */
	0x23,0xFB,0x74,0x61,0x2F,0x4F,0x24,0xF6,	/* 2E88: #ta.O$ */
	0xD4,0x70,0x81,0xD0,0x22,0x03,0x4D,0x73,	/* 2E90: p".Ms */
	0x23,0x28,0x20,0xE3,0x41,0x71,0x22,0x52,	/* 2E98: #( Aq"R */
	0x23,0xFB,0x74,0x21,0x20,0x40,0x24,0xFB,	/* 2EA0: #t! @$ */
	0xD4,0x0F,0x78,0x73,0x23,0x28,0x20,0xE3,	/* 2EA8: .xs#(  */
	0x41,0x71,0x22,0x52,0x23,0xFB,0x70,0x81,	/* 2EB0: Aq"R#p */
	0xD0,0x70,0x71,0x56,0x23,0xFB,0x71,0x34,	/* 2EB8: pqV#q4 */
	0x28,0x20,0x40,0x24,0xF6,0x21,0xA4,0x24,	/* 2EC0: ( @$!$ */
	0x41,0x77,0xF9,0x21,0xAC,0x71,0x34,0x68,	/* 2EC8: Aw!q4h */
	0x2F,0x4F,0x24,0xF6,0x71,0xE4,0x41,0x75,	/* 2ED0: .O$qAu */
	0x22,0xE2,0x0E,0x77,0x2B,0x4F,0xF9,0xA9,	/* 2ED8: ".w+O */
	0x71,0x34,0x28,0x20,0x40,0x24,0xFB,0x71,	/* 2EE0: q4( @$q */
	0xE4,0x71,0x24,0x81,0xF1,0x41,0x24,0xFB,	/* 2EE8: q$A$ */
	0x71,0x24,0x81,0x23,0xFB,0x22,0x00,0x71,	/* 2EF0: q$#".q */
	0x24,0x81,0xF1,0x41,0x24,0xF6,0x21,0xA1,	/* 2EF8: $A$! */
	0x41,0x75,0x22,0xE2,0x71,0x24,0x81,0xF1,	/* 2F00: Au"q$ */
	0x60,0x4E,0x24,0xF6,0x71,0x24,0x81,0x23,	/* 2F08: `N$q$# */
	0xFB,0x40,0x71,0x22,0x52,0x23,0xFB,0x72,	/* 2F10: @q"R#r */
	0x41,0x24,0xF6,0xA8,0x14,0xD0,0x72,0x71,	/* 2F18: A$.rq */
	0x7A,0x64,0x2E,0x9E,0x74,0x21,0x40,0x24,	/* 2F20: zd.t!@$ */
	0xF6,0x24,0xA3,0x41,0x71,0x55,0xF1,0x71,	/* 2F28: $AqUq */
	0x8B,0xF1,0xFC,0x2F,0x4F,0x24,0xF6,0x24,	/* 2F30: .O$$ */
	0x40,0xF0,0x24,0xFF,0xF0,0xC0,0x22,0xAE,	/* 2F38: @$" */
	0x74,0x28,0x40,0x24,0xF6,0xA6,0x74,0x6C,	/* 2F40: t(@$tl */
	0x4F,0x24,0xF6,0xD4,0x74,0x22,0x40,0x24,	/* 2F48: O$t"@$ */
	0xF6,0xA6,0x74,0x24,0x40,0x24,0xFB,0xD4,	/* 2F50: t$@$ */
	0x71,0x23,0x81,0xF1,0x28,0x40,0x24,0xF6,	/* 2F58: q#(@$ */
	0xA7,0x28,0x40,0x73,0x23,0x28,0x20,0xE2,	/* 2F60: (@s#(  */
	0x74,0x61,0x4F,0x24,0xF6,0xD4,0x74,0x71,	/* 2F68: taO$tq */
	0xE4,0x62,0x2A,0x08,0x60,0xBD,0x75,0x31,	/* 2F70: b*.`u1 */
	0xD1,0x75,0x34,0x25,0xFA,0xD2,0xD0,0x75,	/* 2F78: u4%u */
	0x21,0x8F,0xF1,0xA6,0x40,0x75,0x21,0x8F,	/* 2F80: !@u! */
	0x23,0xFB,0x75,0x57,0xF1,0x48,0xF4,0xC0,	/* 2F88: #uWH */
	0x22,0xA0,0x75,0x5A,0xF1,0x75,0x23,0x81,	/* 2F90: "uZu# */
	0xF1,0xF4,0xC0,0x21,0xA5,0x75,0x21,0x85,	/* 2F98: !u! */
	0xF1,0x75,0x21,0x59,0xF1,0xF4,0xC0,0xAA,	/* 2FA0: u!Y */
	0x75,0x5B,0xF1,0x75,0x22,0x8D,0xF1,0xF4,	/* 2FA8: u[u" */
	0x23,0xAF,0x21,0x4A,0x71,0x23,0x28,0x20,	/* 2FB0: #!Jq#(  */
	0xE2,0x75,0x5A,0xF1,0x71,0x23,0x28,0x20,	/* 2FB8: uZq#(  */
	0xE0,0x75,0x21,0x85,0xF1,0x71,0x23,0x28,	/* 2FC0: u!q#( */
	0x20,0xE0,0x75,0x5B,0xF1,0x71,0x23,0x28,	/* 2FC8:  u[q#( */
	0x20,0xE1,0x75,0x5A,0xF1,0x75,0x23,0x81,	/* 2FD0:  uZu# */
	0x23,0xFB,0x75,0x21,0x85,0xF1,0x75,0x21,	/* 2FD8: #u!u! */
	0x59,0x23,0xFB,0x75,0x5B,0xF1,0x75,0x22,	/* 2FE0: Y#u[u" */
	0x8D,0x23,0xFB,0x45,0x71,0x23,0x28,0x20,	/* 2FE8: #Eq#(  */
	0xE2,0x75,0x21,0x87,0xF1,0x41,0x24,0xF6,	/* 2FF0: u!A$ */
	0xA8,0x75,0x5A,0xF1,0x28,0x40,0x24,0xF6,	/* 2FF8: uZ(@$ */
	0xA8,0x29,0x40,0x71,0x23,0x28,0x20,0xE2,	/* 3000: )@q#(  */
	0x07,0x28,0x40,0x71,0x23,0x28,0x20,0xE2,	/* 3008: .(@q#(  */
	0x75,0x21,0x87,0xF1,0x42,0x24,0xF6,0xA7,	/* 3010: u!B$ */
	0x41,0x75,0x74,0x65,0x2B,0x92,0x06,0x40,	/* 3018: Aute+.@ */
	0x75,0x74,0x65,0x2A,0x9B,0x40,0x75,0x21,	/* 3020: ute*@u! */
	0x89,0x23,0xFB,0x75,0x21,0x8B,0xF1,0x75,	/* 3028: #u!u */
	0x58,0x23,0xFB,0x75,0x21,0x8D,0xF1,0x75,	/* 3030: X#u!u */
	0x59,0x23,0xFB,0x75,0x5E,0xF1,0x75,0x21,	/* 3038: Y#u^u! */
	0x81,0x23,0xFB,0x75,0x5F,0xF1,0x75,0x21,	/* 3040: #u_u! */
	0x83,0x23,0xFB,0x75,0x21,0x50,0xF1,0x75,	/* 3048: #u!Pu */
	0x22,0x81,0x23,0xFB,0x75,0x21,0x51,0xF1,	/* 3050: "#u!Q */
	0x75,0x22,0x83,0x23,0xFB,0x75,0x5D,0xF1,	/* 3058: u"#u] */
	0x75,0x21,0x58,0x23,0xFB,0x41,0x75,0x22,	/* 3060: u!X#Au" */
	0x51,0x23,0xFB,0x40,0x75,0x24,0x83,0x23,	/* 3068: Q#@u$# */
	0xFB,0x40,0x75,0x22,0x52,0x23,0xFB,0x70,	/* 3070: @u"R#p */
	0x60,0x44,0x24,0xF6,0xD0,0x75,0x5D,0xF1,	/* 3078: `D$u] */
	0x42,0x24,0xF6,0xA5,0x70,0x42,0x24,0xFB,	/* 3080: B$pB$ */
	0xD0,0x75,0x5D,0xF1,0x48,0x24,0xF6,0xA5,	/* 3088: u]H$ */
	0x70,0x48,0x24,0xFB,0xD0,0x75,0x5D,0xF1,	/* 3090: pH$u] */
	0x41,0x24,0xF6,0xA5,0x70,0x41,0x24,0xFB,	/* 3098: A$pA$ */
	0xD0,0x70,0x25,0x2B,0x2F,0x4F,0x24,0xF6,	/* 30A0: p%+.O$ */
	0xD0,0x75,0x5D,0xF1,0x44,0x24,0xF6,0xA7,	/* 30A8: u]D$ */
	0x70,0x24,0x20,0x40,0x24,0xFB,0xD0,0x75,	/* 30B0: p$ @$u */
	0x5D,0xF1,0x22,0x40,0x24,0xF6,0xA8,0x70,	/* 30B8: ]"@$p */
	0x22,0x20,0x20,0x40,0x24,0xFB,0xD0,0x75,	/* 30C0: "  @$u */
	0x5D,0xF1,0x28,0x40,0x24,0xF6,0xA8,0x70,	/* 30C8: ](@$p */
	0x67,0x20,0x20,0x40,0x24,0xFB,0xD0,0x75,	/* 30D0: g  @$u */
	0x5A,0xF1,0x28,0x40,0x24,0xF6,0xA5,0x70,	/* 30D8: Z(@$p */
	0x48,0x24,0xFB,0xD0,0x75,0x5D,0xF1,0x24,	/* 30E0: H$u]$ */
	0x40,0x24,0xF6,0xA5,0x70,0x48,0x24,0xFB,	/* 30E8: @$pH$ */
	0xD0,0x72,0x24,0x20,0x40,0x24,0xF6,0xAF,	/* 30F0: r$ @$ */
	0x70,0x24,0x20,0x40,0x24,0xF6,0xC0,0xA7,	/* 30F8: p$ @$ */
	0x70,0x61,0x2F,0x4F,0x24,0xF6,0xD0,0x72,	/* 3100: pa.O$r */
	0x42,0x24,0xF6,0xAC,0x70,0x42,0x24,0xF6,	/* 3108: B$pB$ */
	0xC0,0xA6,0x70,0x60,0x4B,0x24,0xF6,0xD0,	/* 3110: p`K$ */
	0x75,0x23,0x81,0xF1,0x28,0x40,0x24,0xF6,	/* 3118: u#(@$ */
	0xA5,0x70,0x48,0x24,0xFB,0xD0,0x70,0x22,	/* 3120: pH$p" */
	0x20,0x20,0x40,0x24,0xF6,0xAA,0x75,0x74,	/* 3128:   @$ut */
	0x66,0x26,0x96,0x75,0x5C,0x23,0xFB,0x06,	/* 3130: f&u\#. */
	0x22,0x44,0x75,0x5C,0x23,0xFB,0x75,0x57,	/* 3138: "Du\#uW */
	0xF1,0x44,0xF4,0xA6,0x40,0x75,0x57,0x23,	/* 3140: D@uW# */
	0xFB,0x03,0x75,0x74,0x9B,0x70,0x75,0xE4,	/* 3148: .utpu */
	0x41,0x74,0x28,0xE4,0x40,0xB3,0x22,0xF0,	/* 3150: At(@" */
	0x72,0x71,0x66,0x23,0x9C,0x44,0x24,0xF6,	/* 3158: rqf#D$ */
	0xAA,0x40,0x72,0x57,0x23,0xFB,0x41,0x71,	/* 3160: @rW#Aq */
	0x28,0xE4,0x05,0x46,0x72,0x57,0x23,0xFB,	/* 3168: (.FrW# */
	0x40,0x22,0xF0,0x60,0xBF,0x73,0x31,0xD0,	/* 3170: @"`s1 */
	0x73,0x8D,0xF1,0x73,0x56,0xF1,0xF4,0xC0,	/* 3178: ssV */
	0x21,0xA2,0x70,0x23,0x28,0x20,0x30,0x2F,	/* 3180: !p#( 0. */
	0x4F,0x24,0xF6,0xA8,0x73,0x72,0x22,0x9F,	/* 3188: O$sr" */
	0x40,0xB1,0x22,0xF0,0x41,0xB1,0x22,0xF0,	/* 3190: @"A" */
	0x26,0x40,0x72,0x31,0x23,0x28,0x20,0xE2,	/* 3198: &@r1#(  */
	0x21,0x42,0x72,0x57,0x23,0xFB,0x40,0x22,	/* 31A0: !BrW#@" */
	0xF0,0x27,0x45,0x72,0x31,0x23,0x28,0x20,	/* 31A8: 'Er1#(  */
	0xE2,0x40,0x72,0x57,0x23,0xFB,0x40,0x22,	/* 31B0: @rW#@" */
	0xF0,0x40,0x22,0xF0,0x40,0x22,0xF0,0x60,	/* 31B8: @"@"` */
	0xBF,0x73,0x31,0xD0,0x40,0x73,0x56,0x23,	/* 31C0: s1@sV# */
	0xFB,0x40,0x73,0x8D,0x23,0xFB,0x40,0x73,	/* 31C8: @s#@s */
	0x8B,0x23,0xFB,0x40,0x73,0x55,0x23,0xFB,	/* 31D0: #@sU# */
	0x73,0x21,0x59,0xF1,0x21,0x40,0x24,0xF6,	/* 31D8: s!Y!@$ */
	0xAD,0x73,0x21,0x59,0xF1,0x61,0x4F,0x24,	/* 31E0: s!YaO$ */
	0xF6,0x70,0x23,0x28,0x20,0xE0,0x70,0x23,	/* 31E8: p#( p# */
	0x28,0x20,0x31,0x48,0x24,0xF6,0x24,0xA4,	/* 31F0: ( 1H$$ */
	0x73,0x21,0x87,0xF1,0x41,0x24,0xF6,0xC0,	/* 31F8: s!A$ */
	0xA7,0x29,0x40,0x70,0x23,0x28,0x20,0xE2,	/* 3200: )@p#(  */
	0x73,0x21,0x87,0xF1,0x42,0x24,0xF6,0xC0,	/* 3208: s!B$ */
	0xA6,0x40,0x73,0x72,0x67,0x2B,0x99,0x40,	/* 3210: @srg+@ */
	0x73,0xE4,0x23,0x40,0x70,0x23,0x28,0x20,	/* 3218: s#@p#(  */
	0xE2,0x22,0x40,0x70,0x23,0x28,0x20,0xE2,	/* 3220: "@p#(  */
	0x41,0x73,0x21,0x8F,0x23,0xFB,0x21,0x40,	/* 3228: As!#!@ */
	0x73,0x57,0x23,0xFB,0x41,0x72,0x28,0xE4,	/* 3230: sW#Ar( */
	0x40,0xB1,0x22,0xF0,0x40,0xB1,0x22,0xF0,	/* 3238: @"@" */
	0x72,0x34,0x46,0x24,0xF6,0x46,0xF4,0xC0,	/* 3240: r4F$F */
	0xA8,0x72,0x34,0x60,0x4B,0x24,0xF6,0x72,	/* 3248: r4`K$r */
	0xE4,0x40,0x72,0x57,0x23,0xFB,0x41,0x71,	/* 3250: @rW#Aq */
	0x28,0xE4,0x40,0x22,0xF0,0x60,0xBF,0x73,	/* 3258: (@"`s */
	0x31,0xD0,0x73,0x8D,0xF1,0x73,0x56,0x23,	/* 3260: 1ssV# */
	0xFB,0x73,0x34,0x68,0x2F,0x4F,0x24,0xF6,	/* 3268: s4h.O$ */
	0x73,0xE4,0x73,0x21,0x59,0xF1,0x21,0x40,	/* 3270: ss!Y!@ */
	0x24,0xF6,0x21,0xA7,0x73,0x72,0x67,0x21,	/* 3278: $!srg! */
	0x98,0x42,0x24,0xF6,0xC0,0xAD,0x23,0x40,	/* 3280: B$#@ */
	0x70,0x23,0x28,0x20,0xE2,0x44,0x70,0x23,	/* 3288: p#( Dp# */
	0x28,0x20,0xE2,0x73,0x72,0x65,0x99,0x40,	/* 3290: ( sre@ */
	0xB1,0x22,0xF0,0x72,0x8B,0xF1,0x72,0x55,	/* 3298: "rrU */
	0x23,0xFB,0x40,0x72,0x57,0x23,0xFB,0x41,	/* 32A0: #@rW#A */
	0x71,0x28,0xE4,0x40,0x22,0xF0,0x72,0x34,	/* 32A8: q(@"r4 */
	0x42,0x24,0xF6,0xA7,0x72,0x34,0x44,0x24,	/* 32B0: B$r4D$ */
	0xFB,0x72,0xE4,0x40,0x72,0x57,0x23,0xFB,	/* 32B8: r@rW# */
	0x41,0x71,0x28,0xE4,0x40,0x22,0xF0,0x40,	/* 32C0: Aq(@"@ */
	0x72,0x57,0x23,0xFB,0x40,0x22,0xF0,0x74,	/* 32C8: rW#@"t */
	0xF6,0x1D,0x00,0x1B,0x00,0x19,0x00,0x17,	/* 32D0: ....... */
	0x00,0x15,0x00,0x13,0x00,0x11,0x00,0x0F,	/* 32D8: ........ */
	0x00,0x0D,0x00,0x0B,0x00,0x09,0x00,0x07,	/* 32E0: ........ */
	0x00,0x05,0x00,0x03,0x00,0x01,0x00,0x00,	/* 32E8: ........ */
	0x00,0x98,0x12,0x71,0x26,0x52,0xD2,0x63,	/* 32F0: ..q&Rc */
	0x4C,0x21,0xFB,0x72,0x21,0xEE,0x65,0x4C,	/* 32F8: L!r!eL */
	0x21,0xFB,0x72,0x21,0xEC,0x66,0x42,0x21,	/* 3300: !r!fB! */
	0xFB,0x72,0x21,0xEA,0x6B,0x4D,0x21,0xFB,	/* 3308: r!kM! */
	0x72,0x21,0xE8,0x6D,0x49,0x21,0xFB,0x72,	/* 3310: r!mI!r */
	0x21,0xE6,0x61,0x2A,0x40,0x21,0xFB,0x72,	/* 3318: !a*@!r */
	0x21,0xE4,0x61,0x29,0x45,0x21,0xFB,0x72,	/* 3320: !a)E!r */
	0x21,0xE2,0x61,0x28,0x4A,0x21,0xFB,0x72,	/* 3328: !a(J!r */
	0x21,0xE0,0x61,0x27,0x42,0x21,0xFB,0x72,	/* 3330: !a'B!r */
	0xEE,0x61,0x25,0x4A,0x21,0xFB,0x72,0xEC,	/* 3338: a%J!r */
	0x61,0x22,0x4E,0x21,0xFB,0x72,0xEA,0x63,	/* 3340: a"N!rc */
	0x22,0x48,0x21,0xFB,0x72,0xE8,0x61,0x20,	/* 3348: "H!ra  */
	0x45,0x21,0xFB,0x72,0xE6,0x63,0x21,0x4A,	/* 3350: E!rc!J */
	0x21,0xFB,0x72,0xE4,0x63,0x21,0x43,0x21,	/* 3358: !rc!C! */
	0xFB,0x72,0xE2,0x72,0x69,0x49,0x21,0xFB,	/* 3360: rriI! */
	0x21,0x40,0x21,0x28,0x2B,0x97,0x22,0xF0,	/* 3368: !@!(+" */
	0x20,0x61,0xBD,0x21,0x74,0x28,0x51,0xD9,	/* 3370:  a!t(Q */
	0x40,0xDA,0x40,0xD8,0x28,0x40,0xD7,0x28,	/* 3378: @@(@( */
	0x40,0xD2,0x40,0xD6,0x76,0x48,0x24,0xF1,	/* 3380: @@vH$ */
	0xD4,0x40,0xD3,0x40,0xD1,0x71,0x44,0x24,	/* 3388: @@qD$ */
	0xF1,0x76,0x48,0x24,0xF1,0xFA,0x23,0x28,	/* 3390: vH$#( */
	0x20,0x3D,0x2A,0x40,0x24,0xF6,0x2A,0x40,	/* 3398:  =*@$*@ */
	0xF4,0xC0,0xAE,0x71,0x41,0xF2,0xD1,0x41,	/* 33A0: qAA */
	0x44,0x71,0x24,0xFF,0xF0,0xC0,0xAB,0x62,	/* 33A8: Dq$b */
	0x0C,0x41,0xD8,0x41,0xD3,0x7A,0x41,0xF4,	/* 33B0: .AAzA */
	0x28,0xAA,0x73,0xC0,0x21,0xA5,0x74,0x23,	/* 33B8: (s!t# */
	0x28,0x20,0x31,0x2F,0x4F,0x24,0xF6,0x2F,	/* 33C0: ( 1.O$. */
	0x4F,0xF4,0x28,0xA4,0x41,0xDA,0x78,0x41,	/* 33C8: O(AxA */
	0xF4,0x27,0xA7,0x76,0x21,0xA8,0x72,0x51,	/* 33D0: 'v!rQ */
	0xF1,0x21,0x28,0x40,0xF8,0x77,0x28,0x50,	/* 33D8: !(@w(P */
	0xFA,0x25,0xFA,0xD7,0x67,0x20,0x20,0x40,	/* 33E0: %g  @ */
	0x24,0xFB,0x72,0xE0,0x77,0xD2,0x76,0x48,	/* 33E8: $rwvH */
	0x24,0xF1,0xD4,0x40,0x72,0xE0,0x76,0x72,	/* 33F0: $@rvr */
	0x83,0x23,0xFB,0x74,0x72,0xE3,0x78,0x2D,	/* 33F8: #trx- */
	0xA0,0x48,0x72,0x51,0x23,0xFB,0x40,0x74,	/* 3400: HrQ#@t */
	0x23,0x28,0x27,0xEF,0x40,0x74,0x23,0x28,	/* 3408: #('@t#( */
	0x26,0xE8,0x40,0x74,0x23,0x28,0x21,0xE8,	/* 3410: &@t#(! */
	0x44,0x74,0x23,0x28,0x27,0xEF,0x40,0x74,	/* 3418: Dt#('@t */
	0x23,0x28,0x26,0xE8,0x25,0x45,0x74,0x23,	/* 3420: #(&%Et# */
	0x28,0x21,0xE8,0x40,0x74,0x23,0x28,0x27,	/* 3428: (!@t#(' */
	0xEF,0x74,0x23,0x28,0x21,0x38,0x2F,0x4F,	/* 3430: t#(!8.O */
	0x24,0xF6,0x25,0x45,0xF4,0x22,0xAF,0x22,	/* 3438: $%E"" */
	0x48,0xD1,0x22,0x0D,0x2F,0x4F,0x21,0xB3,	/* 3440: H"..O! */
	0x22,0xF0,0x2F,0x4F,0x21,0xB3,0x22,0xF0,	/* 3448: ".O!" */
	0x78,0xC0,0xA4,0x20,0x7A,0x21,0xA1,0x67,	/* 3450: x z!g */
	0x21,0x2E,0x40,0x70,0xE0,0x21,0x28,0x40,	/* 3458: !.@p!(@ */
	0x70,0x21,0xE7,0x41,0x21,0xB3,0x22,0xF0,	/* 3460: p!A!" */
	0x2F,0x4F,0x21,0xB3,0x22,0xF0,0x24,0x48,	/* 3468: .O!"$H */
	0xD1,0x71,0x72,0x54,0x23,0xFB,0x74,0x23,	/* 3470: qrT#t# */
	0x28,0x27,0x3F,0x2F,0x4F,0x24,0xF6,0x72,	/* 3478: ('?.O$r */
	0x5F,0x23,0xFB,0x74,0x23,0x28,0x24,0x30,	/* 3480: _#t#($0 */
	0x2F,0x4F,0x24,0xF6,0x72,0x21,0x8F,0x23,	/* 3488: .O$r!# */
	0xFB,0x44,0x74,0x23,0x28,0x27,0xEF,0x74,	/* 3490: Dt#('t */
	0x23,0x28,0x24,0x30,0x2F,0x4F,0x24,0xF6,	/* 3498: #($0.O$ */
	0x72,0x21,0x50,0x23,0xFB,0x72,0x54,0xF1,	/* 34A0: r!P#rT */
	0x24,0x48,0xF4,0xA8,0x79,0x31,0x41,0xF2,	/* 34A8: $Hy1A */
	0x79,0xE1,0x21,0x04,0x74,0x23,0x28,0x23,	/* 34B0: y!.t#(# */
	0x39,0x43,0x24,0xF6,0x81,0x72,0x22,0x81,	/* 34B8: 9C$r" */
	0x23,0xFB,0x79,0x32,0x41,0xF2,0x79,0xE2,	/* 34C0: #y2Ay */
	0x74,0x21,0x74,0x62,0x24,0x26,0x91,0x25,	/* 34C8: t!tb$&% */
	0x03,0x74,0x23,0x28,0x24,0x30,0x2F,0x4F,	/* 34D0: .t#($0.O */
	0x24,0xF6,0xD1,0x79,0x30,0x41,0xF2,0x79,	/* 34D8: $y0Ay */
	0xE0,0x71,0x41,0x24,0xF6,0x21,0xA8,0x71,	/* 34E0: qA$!q */
	0x2A,0x4B,0xF4,0xA5,0x20,0x44,0xD1,0x03,	/* 34E8: *K D. */
	0x20,0x4A,0xD1,0x71,0x72,0x54,0x23,0xFB,	/* 34F0:  JqrT# */
	0x44,0x72,0x51,0x23,0xFB,0x21,0x06,0x71,	/* 34F8: DrQ#!.q */
	0x2A,0x4A,0xF4,0xA5,0x20,0x48,0xD1,0x03,	/* 3500: *J H. */
	0x20,0x4B,0xD1,0x71,0x72,0x54,0x23,0xFB,	/* 3508:  KqrT# */
	0x48,0x72,0x51,0x23,0xFB,0x2F,0x4F,0x74,	/* 3510: HrQ#.Ot */
	0x6F,0x40,0x24,0xF6,0x28,0x40,0x24,0xFB,	/* 3518: o@$(@$ */
	0x23,0x28,0x20,0xE0,0x77,0x28,0x50,0xD3,	/* 3520: #( w(P */
	0x76,0xAF,0x73,0x23,0x50,0x67,0x20,0x20,	/* 3528: vs#Pg   */
	0x40,0x24,0xFB,0x70,0xE0,0x73,0x70,0x21,	/* 3530: @$psp! */
	0xE7,0x40,0xD1,0x41,0x72,0x51,0xF1,0x40,	/* 3538: @ArQ@ */
	0x24,0xFF,0xF0,0xC0,0x21,0x24,0xAB,0x73,	/* 3540: $!$s */
	0xD0,0x73,0x71,0x72,0x55,0xFA,0xE0,0x72,	/* 3548: sqrUr */
	0x54,0xF1,0x70,0x53,0x23,0xFB,0x21,0x40,	/* 3550: TpS#!@ */
	0x70,0x57,0x23,0xFB,0x41,0x70,0x21,0x8F,	/* 3558: pW#Ap! */
	0x23,0xFB,0x71,0x70,0x87,0x23,0xFB,0x2F,	/* 3560: #qp#. */
	0x4F,0x70,0x21,0x51,0x23,0xFB,0x78,0x26,	/* 3568: Op!Q#x& */
	0xA4,0x21,0x23,0x4D,0x21,0xFB,0x1B,0x21,	/* 3570: !#M!.! */
	0x40,0x24,0xFA,0x74,0x70,0xE1,0x41,0x71,	/* 3578: @$tpAq */
	0x43,0x24,0xFF,0xF0,0xAA,0x74,0x23,0x28,	/* 3580: C$t#( */
	0x27,0x3F,0x4F,0x24,0xF6,0xD5,0x0D,0x74,	/* 3588: '?O$.t */
	0x23,0x28,0x27,0x3F,0x2F,0x4F,0x24,0xF6,	/* 3590: #('?.O$ */
	0x44,0x24,0xF0,0xD5,0x75,0x2F,0x4F,0x24,	/* 3598: D$u.O$ */
	0xF6,0x25,0xFA,0xD5,0x70,0x21,0x52,0x23,	/* 35A0: %p!R# */
	0xFB,0x75,0x1B,0xF2,0xF1,0x70,0x21,0x53,	/* 35A8: u.p!S */
	0x23,0xFB,0x75,0x47,0x24,0xF6,0x45,0xF4,	/* 35B0: #uG$E */
	0xC0,0xAD,0x71,0xA5,0x71,0x44,0xF4,0xC0,	/* 35B8: qqD */
	0xA6,0x41,0x70,0x22,0x87,0x23,0xFB,0x4B,	/* 35C0: Ap"#K */
	0x70,0x21,0x5B,0x23,0xFB,0x4B,0x70,0x23,	/* 35C8: p![#Kp# */
	0x87,0x23,0xFB,0x28,0x0E,0x2E,0x4A,0x21,	/* 35D0: #(..J! */
	0xFB,0x1B,0x48,0x24,0xFA,0x72,0x54,0xF1,	/* 35D8: .H$rT */
	0x48,0xF4,0x21,0xAD,0x72,0x54,0xF1,0x4B,	/* 35E0: H!rTK */
	0xF4,0x21,0xA6,0x71,0x1B,0xFA,0x30,0x48,	/* 35E8: !q.0H */
	0xF8,0x74,0xFA,0x70,0xE1,0x41,0x71,0x1B,	/* 35F0: tpAq. */
	0xFA,0x30,0x24,0xF1,0x70,0x8F,0x23,0xFB,	/* 35F8: 0$p# */
	0x0F,0x71,0x48,0xF8,0x74,0xFA,0x70,0xE1,	/* 3600: .qHtp */
	0x41,0x71,0x24,0xF1,0x70,0x8F,0x23,0xFB,	/* 3608: Aq$p# */
	0x71,0x41,0x24,0xF6,0xC0,0xAE,0x72,0x54,	/* 3610: qA$rT */
	0xF1,0x44,0xF4,0xA8,0x72,0x54,0xF1,0x4A,	/* 3618: DrTJ */
	0xF4,0xC0,0x23,0xAF,0x70,0x31,0xD5,0x2E,	/* 3620: #p1. */
	0x40,0x75,0x61,0x4F,0x24,0xF6,0x23,0x28,	/* 3628: @uaO$#( */
	0x20,0xE4,0x40,0x75,0x61,0x4F,0x24,0xF6,	/* 3630:  @uaO$ */
	0x23,0x28,0x20,0xE5,0x40,0x75,0x61,0x4F,	/* 3638: #( @uaO */
	0x24,0xF6,0x23,0x28,0x20,0xE6,0x42,0x75,	/* 3640: $#( Bu */
	0x61,0x4F,0x24,0xF6,0x23,0x28,0x20,0xE7,	/* 3648: aO$#(  */
	0x75,0x61,0x4F,0x24,0xF6,0x23,0x28,0x20,	/* 3650: uaO$#(  */
	0x3E,0x40,0x75,0x61,0x4F,0x24,0xF6,0x23,	/* 3658: >@uaO$# */
	0x28,0x20,0xED,0x77,0x67,0x20,0x20,0x40,	/* 3660: ( wg  @ */
	0x24,0xFB,0x70,0xE2,0x73,0x21,0x28,0x50,	/* 3668: $ps!(P */
	0x25,0xFA,0xD3,0x23,0x50,0x67,0x20,0x20,	/* 3670: %#Pg   */
	0x40,0x24,0xFB,0x70,0xE0,0x73,0x70,0x21,	/* 3678: @$psp! */
	0xE7,0x71,0x41,0xF2,0xD1,0x41,0x72,0x51,	/* 3680: qAArQ */
	0xF1,0x71,0x24,0xFF,0xF0,0xC0,0xA3,0x61,	/* 3688: q$a */
	0x2B,0x05,0x76,0x41,0xF2,0xD6,0x41,0x44,	/* 3690: +.vAAD */
	0x76,0x24,0xFF,0xF0,0xC0,0xA3,0x63,0x2E,	/* 3698: v$c. */
	0x03,0x67,0x21,0x2E,0x40,0x70,0xE0,0x21,	/* 36A0: .g!.@p! */
	0x28,0x40,0x70,0x21,0xE7,0x41,0x21,0xB3,	/* 36A8: (@p!A! */
	0x22,0xF0,0x20,0xF0,0xD0,0x00,0xF0,0x00,	/* 36B0: " .. */
	0xC0,0x00,0x00,0xF0,0xD0,0xF0,0xF0,0x00,	/* 36B8: ... */
	0xC0,0x00,0x00,0x00,0x00,0x03,0x00,0x04,	/* 36C0: ....... */
	0x00,0x07,0x00,0x60,0xBC,0x75,0x28,0x54,	/* 36C8: ...`u(T */
	0xD1,0x71,0x67,0x38,0x35,0x41,0xF2,0x71,	/* 36D0: qg85Aq */
	0x67,0x38,0xE5,0x21,0x28,0x40,0x25,0xFA,	/* 36D8: g8!(@% */
	0xD0,0x53,0xF1,0x2F,0x40,0x24,0xF6,0xC0,	/* 36E0: S.@$ */
	0x24,0xA5,0x70,0x57,0xF1,0xC0,0x23,0xA2,	/* 36E8: $pW# */
	0x70,0x34,0x22,0x20,0x20,0x40,0x24,0xF6,	/* 36F0: p4"  @$ */
	0x22,0xA8,0x70,0x5C,0xF1,0xD3,0x70,0x75,	/* 36F8: "p\pu */
	0x6C,0x29,0x96,0x2F,0x4F,0x24,0xF6,0x25,	/* 3700: l).O$% */
	0xFA,0xD2,0x73,0xF4,0x21,0xA4,0x72,0x70,	/* 3708: s!rp */
	0x5C,0x23,0xFB,0x70,0x21,0x89,0xF1,0x42,	/* 3710: \#p!B */
	0x24,0xFB,0x70,0x21,0x89,0x23,0xFB,0x41,	/* 3718: $p!#A */
	0x71,0xE0,0x70,0x21,0x37,0x25,0xFA,0xD0,	/* 3720: qp!7% */
	0x21,0x28,0x40,0xF4,0xA2,0x64,0x0B,0x71,	/* 3728: !(@d.q */
	0x30,0x71,0x31,0x24,0xFB,0x21,0xAE,0x41,	/* 3730: 0q1$!A */
	0x71,0x67,0x38,0xE4,0x71,0x30,0x27,0x2C,	/* 3738: qg8q0', */
	0x28,0x40,0xE0,0x71,0x67,0x38,0x56,0xF1,	/* 3740: (@qg8V */
	0x81,0x71,0x67,0x38,0x56,0x23,0xFB,0x40,	/* 3748: qg8V#@ */
	0x71,0xE0,0x40,0x71,0xE1,0xB4,0x22,0xF0,	/* 3750: q@q" */
	0x20,0x61,0xBF,0x21,0x72,0x28,0x56,0xD9,	/* 3758:  a!r(V */
	0x28,0x40,0xD3,0x40,0xD2,0x79,0x67,0x36,	/* 3760: (@@yg6 */
	0x53,0xF1,0x81,0x79,0x67,0x36,0x53,0x23,	/* 3768: Syg6S# */
	0xFB,0x28,0x40,0xDA,0x40,0xDF,0x73,0x33,	/* 3770: (@@s3 */
	0xD1,0x72,0x44,0xF8,0x71,0x23,0x28,0x27,	/* 3778: rDq#(' */
	0xEF,0x71,0x23,0x28,0x26,0x37,0x2F,0x4F,	/* 3780: q#(&7.O */
	0x24,0xF6,0x25,0xFA,0xD5,0x41,0x24,0xF6,	/* 3788: $%A$ */
	0x26,0x24,0xA8,0x71,0x23,0x28,0x26,0x3B,	/* 3790: &$q#(&; */
	0x2F,0x4F,0x24,0xF6,0xD4,0x71,0x23,0x28,	/* 3798: .O$q#( */
	0x26,0x38,0x2F,0x4F,0x24,0xF6,0xD7,0x74,	/* 37A0: &8.O$t */
	0x43,0x24,0xF6,0x71,0x23,0x28,0x26,0xE8,	/* 37A8: C$q#(& */
	0x71,0x23,0x28,0x24,0x33,0x47,0x24,0xF6,	/* 37B0: q#($3G$ */
	0x25,0xFA,0xD6,0x43,0xF4,0x21,0x24,0xAE,	/* 37B8: %C!$ */
	0x76,0x47,0xF4,0xC0,0x26,0x21,0xA4,0x40,	/* 37C0: vG&!@ */
	0xDB,0x72,0x74,0x43,0x24,0xF6,0x28,0xF1,	/* 37C8: rtC$( */
	0x73,0x55,0xFA,0x30,0xD6,0x71,0x23,0x28,	/* 37D0: sU0q#( */
	0x26,0x32,0x2F,0x4F,0x24,0xF6,0xD8,0x71,	/* 37D8: &2.O$q */
	0x23,0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,	/* 37E0: #(&2.O$ */
	0x21,0xD0,0x78,0x48,0x24,0xF6,0x21,0xA0,	/* 37E8: !xH$! */
	0x76,0x21,0x89,0xF1,0x41,0x24,0xFB,0x76,	/* 37F0: v!A$v */
	0x21,0x89,0x23,0xFB,0x41,0x79,0x60,0xEE,	/* 37F8: !#Ay` */
	0x78,0x47,0x24,0xF6,0xAD,0x76,0x21,0x50,	/* 3800: xG$v!P */
	0xF1,0x28,0x40,0x24,0xF6,0xA4,0x41,0x79,	/* 3808: (@$Ay */
	0x60,0xEE,0x78,0x41,0x24,0xF6,0xA8,0x76,	/* 3810: `xA$v */
	0x21,0x3E,0x41,0xF2,0x76,0x21,0xEE,0x78,	/* 3818: !>Av!x */
	0x42,0x24,0xF6,0xAA,0x76,0x21,0x3C,0x41,	/* 3820: B$v!<A */
	0xF2,0x76,0x21,0xEC,0x41,0xDB,0x78,0x44,	/* 3828: v!AxD */
	0x24,0xF6,0xAA,0x76,0x21,0x3D,0x41,0xF2,	/* 3830: $v!=A */
	0x76,0x21,0xED,0x41,0xDB,0x7B,0x25,0x28,	/* 3838: v!A{%( */
	0xAA,0x76,0x21,0x50,0xF1,0x24,0x40,0x24,	/* 3840: v!P$@$ */
	0xF6,0xA6,0x76,0x22,0x8B,0xF1,0x21,0xD0,	/* 3848: v"! */
	0x76,0x55,0xF1,0xDB,0x76,0x8B,0xF1,0xDD,	/* 3850: vUv */
	0x76,0x34,0xDE,0x7D,0x7B,0x41,0xF2,0xF4,	/* 3858: v4}{A */
	0x2F,0x4F,0x24,0xF6,0x25,0xFA,0xDC,0x25,	/* 3860: .O$%% */
	0x25,0xA9,0x21,0x70,0x7B,0x2F,0x4F,0x24,	/* 3868: %!p{.O$ */
	0xF6,0x76,0x2B,0x50,0xF2,0x23,0xFB,0x7B,	/* 3870: v+P#{ */
	0x41,0xF2,0x76,0x55,0x23,0xFB,0x7D,0x7B,	/* 3878: AvU#}{ */
	0x41,0xF2,0x41,0xF2,0xF4,0x2F,0x4F,0x24,	/* 3880: AA.O$ */
	0xF6,0xD0,0x7E,0x48,0x24,0xF6,0x25,0x23,	/* 3888: ~H$%# */
	0xAA,0x41,0x7C,0x23,0x4F,0x24,0xFF,0xF0,	/* 3890: A|#O$ */
	0xC0,0x25,0x22,0xAF,0x41,0x24,0x40,0x70,	/* 3898: %"A$@p */
	0x24,0xFF,0xF0,0xC0,0x25,0x22,0xA4,0x7E,	/* 38A0: $%"~ */
	0x21,0x40,0x24,0xFB,0xDE,0x76,0x21,0x58,	/* 38A8: !@$v!X */
	0xF1,0x48,0x24,0xF6,0x22,0xA7,0x7E,0x22,	/* 38B0: H$"~" */
	0x40,0x24,0xF6,0xC0,0x21,0xAF,0x71,0x23,	/* 38B8: @$!q# */
	0x28,0x20,0x35,0x2F,0x4F,0x24,0xF6,0xC0,	/* 38C0: ( 5.O$ */
	0x21,0xA3,0x40,0xD0,0x21,0x20,0x40,0x76,	/* 38C8: !@! @v */
	0x21,0x72,0x61,0x20,0x29,0x9D,0x22,0x42,	/* 38D0: !ra )"B */
	0x71,0x23,0x28,0x20,0xE5,0x76,0x23,0x81,	/* 38D8: q#( v# */
	0xF1,0x28,0x40,0x24,0xF6,0xAD,0x40,0xD0,	/* 38E0: (@$@ */
	0x21,0x20,0x20,0x40,0x76,0x21,0x72,0x61,	/* 38E8: !  @v!ra */
	0x20,0x28,0x90,0x76,0x21,0x58,0xF1,0x24,	/* 38F0:  (v!X$ */
	0x40,0x24,0xF6,0x24,0x2C,0xAD,0x40,0xD0,	/* 38F8: @$$,@ */
	0x22,0x20,0x20,0x40,0x76,0x21,0x72,0x61,	/* 3900: "  @v!ra */
	0x20,0x26,0x98,0x24,0x2B,0x0D,0x72,0x74,	/* 3908:  &$+.rt */
	0x43,0x24,0xF6,0x28,0xF1,0x73,0x55,0xFA,	/* 3910: C$(sU */
	0x30,0x25,0xFA,0xD6,0x22,0x87,0xF1,0xC0,	/* 3918: 0%" */
	0xAC,0x76,0x21,0x54,0xF1,0x41,0x24,0xFB,	/* 3920: v!TA$ */
	0x76,0x21,0x54,0x23,0xFB,0x76,0x55,0xF1,	/* 3928: v!T#vU */
	0xDB,0x76,0x8B,0xF1,0xDD,0x76,0x34,0xDE,	/* 3930: vv4 */
	0x7D,0x7B,0x41,0xF2,0xF4,0x2F,0x4F,0x24,	/* 3938: }{A.O$ */
	0xF6,0xDC,0x41,0x79,0x60,0xEF,0x71,0x23,	/* 3940: Ay`q# */
	0x28,0x20,0x3E,0x2F,0x4F,0x24,0xF6,0xD0,	/* 3948: ( >.O$ */
	0x41,0x7C,0x70,0x24,0xFF,0xF0,0xA3,0x7C,	/* 3950: A|p$| */
	0xD8,0x02,0x70,0xD8,0x78,0x23,0x29,0xAB,	/* 3958: .px#) */
	0x70,0x78,0xF4,0xD0,0x78,0x41,0xF4,0xD8,	/* 3960: pxxA */
	0x41,0x22,0x40,0x78,0x24,0xFF,0xF0,0xC0,	/* 3968: A"@x$ */
	0x23,0x28,0xA3,0x78,0x42,0x21,0xFB,0x28,	/* 3970: #(xB!( */
	0xF1,0xF6,0x23,0x26,0x01,0x20,0x23,0x24,	/* 3978: #&. #$ */
	0x05,0x20,0x23,0x22,0x09,0x20,0x23,0x20,	/* 3980: . #". #  */
	0x0D,0x20,0x22,0x2F,0x01,0x20,0x22,0x2D,	/* 3988: . ".. "- */
	0x05,0x20,0x22,0x2B,0x09,0x20,0x22,0x29,	/* 3990: . "+. ") */
	0x0D,0x20,0x22,0x28,0x01,0x20,0x22,0x26,	/* 3998: . "(. "& */
	0x05,0x20,0x22,0x24,0x09,0x20,0x22,0x22,	/* 39A0: . "$. "" */
	0x0D,0x20,0x22,0x21,0x01,0x20,0x21,0x2F,	/* 39A8: . "!. !. */
	0x05,0x20,0x21,0x2D,0x09,0x20,0x21,0x2B,	/* 39B0: . !-. !+ */
	0x0D,0x20,0x21,0x2A,0x01,0x20,0x21,0x28,	/* 39B8: . !*. !( */
	0x05,0x20,0x21,0x26,0x09,0x20,0x21,0x24,	/* 39C0: . !&. !$ */
	0x0D,0x20,0x21,0x23,0x01,0x20,0x21,0x21,	/* 39C8: . !#. !! */
	0x05,0x20,0x2F,0x0A,0x20,0x20,0x2D,0x0E,	/* 39D0: . ..  -. */
	0x20,0x20,0x2C,0x02,0x20,0x20,0x2A,0x06,	/* 39D8:   ,.  *. */
	0x20,0x20,0x28,0x0A,0x20,0x20,0x26,0x0E,	/* 39E0:   (.  &. */
	0x20,0x20,0x25,0x02,0x20,0x20,0x23,0x06,	/* 39E8:   %.  #. */
	0x20,0x20,0x21,0x0A,0x20,0x20,0x71,0x23,	/* 39F0:   !.  q# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 39F8: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3A00: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3A08: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3A10: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3A18: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3A20: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3A28: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3A30: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3A38: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3A40: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3A48: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3A50: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3A58: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3A60: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3A68: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3A70: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3A78: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3A80: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3A88: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3A90: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3A98: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3AA0: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3AA8: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3AB0: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3AB8: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3AC0: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3AC8: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3AD0: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3AD8: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3AE0: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3AE8: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3AF0: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3AF8: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3B00: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3B08: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3B10: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3B18: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3B20: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3B28: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3B30: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3B38: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3B40: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3B48: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3B50: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3B58: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3B60: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3B68: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3B70: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3B78: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3B80: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3B88: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3B90: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3B98: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3BA0: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3BA8: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3BB0: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3BB8: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3BC0: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3BC8: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3BD0: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3BD8: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3BE0: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3BE8: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3BF0: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3BF8: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3C00: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3C08: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3C10: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3C18: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3C20: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3C28: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3C30: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3C38: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3C40: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3C48: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3C50: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3C58: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3C60: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3C68: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3C70: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3C78: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3C80: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3C88: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3C90: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3C98: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3CA0: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3CA8: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3CB0: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3CB8: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3CC0: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3CC8: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3CD0: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x71,0x23,	/* 3CD8: #{Aq# */
	0x28,0x26,0x32,0x2F,0x4F,0x24,0xF6,0x7B,	/* 3CE0: (&2.O${ */
	0x2F,0x4F,0x24,0xF6,0x76,0x2B,0x50,0xF2,	/* 3CE8: .O$v+P */
	0x23,0xFB,0x7B,0x41,0xF2,0xDB,0x7B,0x76,	/* 3CF0: #{A{v */
	0x55,0x23,0xFB,0x70,0x76,0x21,0x3F,0xF2,	/* 3CF8: U#pv!? */
	0x76,0x21,0xEF,0x70,0x25,0xFA,0x60,0x4F,	/* 3D00: v!p%`O */
	0xF2,0xD0,0x21,0xA0,0x71,0x23,0x28,0x26,	/* 3D08: !q#(& */
	0x32,0x70,0x25,0xFA,0x60,0x4F,0xF2,0xD0,	/* 3D10: 2p%`O */
	0xA3,0x20,0x60,0x00,0x7D,0x7B,0x41,0xF2,	/* 3D18:  `.}{A */
	0xF4,0x2F,0x4F,0x24,0xF6,0xD0,0x7E,0x48,	/* 3D20: .O$~H */
	0x24,0xF6,0x28,0xA2,0x41,0x7C,0x23,0x4F,	/* 3D28: $(A|#O */
	0x24,0xFF,0xF0,0xC0,0x27,0xA8,0x41,0x24,	/* 3D30: $'A$ */
	0x40,0x70,0x24,0xFF,0xF0,0xC0,0x26,0xAE,	/* 3D38: @p$& */
	0x7E,0x21,0x40,0x24,0xFB,0xDE,0x76,0x21,	/* 3D40: ~!@$v! */
	0x58,0xF1,0x48,0x24,0xF6,0x23,0xA3,0x7E,	/* 3D48: XH$#~ */
	0x22,0x40,0x24,0xF6,0xC0,0x22,0xAB,0x71,	/* 3D50: "@$"q */
	0x23,0x28,0x20,0x35,0x2F,0x4F,0x24,0xF6,	/* 3D58: #( 5.O$ */
	0xA8,0x7E,0x2C,0x40,0x24,0xFB,0xDE,0x21,	/* 3D60: ~,@$! */
	0x09,0x40,0xD0,0x21,0x20,0x40,0x76,0x21,	/* 3D68: .@! @v! */
	0x72,0x62,0x2B,0x2F,0x9E,0x22,0x42,0x71,	/* 3D70: rb+."Bq */
	0x23,0x28,0x20,0xE5,0x7E,0x22,0x40,0x24,	/* 3D78: #( ~"@$ */
	0xFB,0xDE,0x76,0x23,0x81,0xF1,0x28,0x40,	/* 3D80: v#(@ */
	0x24,0xF6,0xAD,0x40,0xD0,0x21,0x20,0x20,	/* 3D88: $@!   */
	0x40,0x76,0x21,0x72,0x62,0x2B,0x2D,0x9B,	/* 3D90: @v!rb+- */
	0x76,0x21,0x58,0xF1,0x24,0x40,0x24,0xF6,	/* 3D98: v!X$@$ */
	0xAD,0x40,0xD0,0x22,0x20,0x20,0x40,0x76,	/* 3DA0: @"  @v */
	0x21,0x72,0x62,0x2B,0x2C,0x95,0x74,0x23,	/* 3DA8: !rb+,t# */
	0x4F,0x24,0xF6,0x71,0x23,0x28,0x26,0xEB,	/* 3DB0: O$q#(& */
	0x77,0x71,0x23,0x28,0x26,0xE8,0x7E,0x76,	/* 3DB8: wq#(&~v */
	0xE4,0x21,0x08,0x70,0x76,0x21,0x3F,0xF2,	/* 3DC0: !.pv!? */
	0x76,0x21,0xEF,0x74,0x23,0x4F,0x24,0xF6,	/* 3DC8: v!t#O$ */
	0x71,0x23,0x28,0x26,0xEB,0x77,0x71,0x23,	/* 3DD0: q#(&wq# */
	0x28,0x26,0xE8,0x75,0x42,0x24,0xF6,0x24,	/* 3DD8: (&uB$$ */
	0x2C,0xAE,0x71,0x23,0x28,0x26,0x3A,0x2F,	/* 3DE0: ,q#(&:. */
	0x4F,0x24,0xF6,0xD4,0x71,0x23,0x28,0x26,	/* 3DE8: O$q#(& */
	0x38,0x2F,0x4F,0x24,0xF6,0xD7,0x74,0x43,	/* 3DF0: 8.O$tC */
	0x24,0xF6,0x71,0x23,0x28,0x26,0xE8,0x72,	/* 3DF8: $q#(&r */
	0x74,0x43,0x24,0xF6,0x28,0xF1,0x73,0x55,	/* 3E00: tC$(sU */
	0xFA,0x30,0x25,0xFA,0xD0,0x22,0x87,0xF1,	/* 3E08: 0%" */
	0xC0,0xAC,0x70,0x21,0x54,0xF1,0x42,0x24,	/* 3E10: p!TB$ */
	0xFB,0x70,0x21,0x54,0x23,0xFB,0x70,0x23,	/* 3E18: p!T#p# */
	0x85,0xF1,0xAC,0x70,0x21,0x72,0x25,0x23,	/* 3E20: p!r%# */
	0x92,0x70,0x34,0xD6,0x24,0x26,0x0E,0x70,	/* 3E28: p4$&.p */
	0x8D,0xF1,0xDE,0x70,0x56,0xF1,0xD8,0x70,	/* 3E30: pVp */
	0x34,0x25,0xFA,0xD6,0x21,0x20,0x40,0x24,	/* 3E38: 4%! @$ */
	0xF6,0x21,0xAE,0x76,0x61,0x2F,0x4F,0x24,	/* 3E40: !va.O$ */
	0xF6,0x22,0x20,0x40,0x24,0xFB,0x60,0x4E,	/* 3E48: " @$`N */
	0x24,0xF6,0xD6,0x71,0x23,0x28,0x20,0x36,	/* 3E50: $q#( 6 */
	0x2F,0x49,0x24,0xF6,0x71,0x23,0x28,0x20,	/* 3E58: .I$q#(  */
	0xE6,0x7E,0x78,0xF4,0x2F,0x4F,0x24,0xF6,	/* 3E60: ~x.O$ */
	0x25,0xFA,0xDC,0x23,0x2D,0xA8,0x70,0x53,	/* 3E68: %#-pS */
	0xF1,0x24,0x48,0xF4,0xA3,0x4C,0xDB,0x03,	/* 3E70: $HL. */
	0x22,0x40,0xDB,0x7B,0xDD,0x41,0x7C,0x7D,	/* 3E78: "@{A|} */
	0x24,0xFF,0xF0,0xA3,0x7C,0xDB,0x02,0x7D,	/* 3E80: $|.} */
	0xDB,0x7B,0x70,0x22,0x52,0x23,0xFB,0x76,	/* 3E88: {p"R#v */
	0x24,0x20,0x40,0x24,0xF6,0x25,0xA9,0x7B,	/* 3E90: $ @$%{ */
	0x23,0x24,0xA7,0x70,0x23,0x50,0x78,0x2F,	/* 3E98: #$p#Px. */
	0x4F,0x24,0xF6,0xF2,0xF1,0x4A,0xF4,0x21,	/* 3EA0: O$J! */
	0xAF,0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,	/* 3EA8: p#Px.O$ */
	0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,	/* 3EB0: q#(& */
	0x78,0x41,0xF2,0xD8,0x7B,0x60,0x4F,0xF2,	/* 3EB8: xA{`O */
	0xDB,0x7D,0x60,0x4F,0xF2,0xDD,0x22,0x02,	/* 3EC0: }`O". */
	0x41,0x42,0x7D,0x24,0xFF,0xF0,0x23,0x21,	/* 3EC8: AB}$#! */
	0xA1,0x4D,0x71,0x23,0x28,0x26,0xE3,0x4A,	/* 3ED0: Mq#(&J */
	0x71,0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,	/* 3ED8: q#(&xA */
	0xD8,0x7B,0x60,0x4F,0xF2,0xDB,0x7D,0x42,	/* 3EE0: {`O}B */
	0xF4,0xDD,0x7B,0x22,0x2F,0xA4,0x65,0x0B,	/* 3EE8: {".e. */
	0x7B,0x41,0xF4,0xDB,0x41,0x22,0x40,0x7B,	/* 3EF0: {AA"@{ */
	0x24,0xFF,0xF0,0xC0,0x22,0x2E,0xA3,0x7B,	/* 3EF8: $".{ */
	0x42,0x21,0xFB,0x28,0xF1,0xF6,0x22,0x2C,	/* 3F00: B!(", */
	0x06,0x20,0x22,0x2A,0x0F,0x20,0x22,0x29,	/* 3F08: . "*. ") */
	0x08,0x20,0x22,0x28,0x01,0x20,0x22,0x26,	/* 3F10: . "(. "& */
	0x0A,0x20,0x22,0x25,0x03,0x20,0x22,0x23,	/* 3F18: . "%. "# */
	0x0C,0x20,0x22,0x22,0x05,0x20,0x22,0x20,	/* 3F20: . "". "  */
	0x0E,0x20,0x21,0x2F,0x07,0x20,0x21,0x2E,	/* 3F28: . !.. !. */
	0x00,0x20,0x21,0x2C,0x09,0x20,0x21,0x2B,	/* 3F30: . !,. !+ */
	0x02,0x20,0x21,0x29,0x0B,0x20,0x21,0x28,	/* 3F38: . !). !( */
	0x04,0x20,0x21,0x26,0x0D,0x20,0x21,0x25,	/* 3F40: . !&. !% */
	0x06,0x20,0x21,0x23,0x0F,0x20,0x21,0x22,	/* 3F48: . !#. !" */
	0x08,0x20,0x21,0x21,0x01,0x20,0x2F,0x0B,	/* 3F50: . !!. .. */
	0x20,0x20,0x2E,0x04,0x20,0x20,0x2C,0x0D,	/* 3F58:   ..  ,. */
	0x20,0x20,0x2B,0x06,0x20,0x20,0x29,0x0F,	/* 3F60:   +.  ). */
	0x20,0x20,0x28,0x08,0x20,0x20,0x27,0x01,	/* 3F68:   (.  '. */
	0x20,0x20,0x25,0x0A,0x20,0x20,0x24,0x03,	/* 3F70:   %.  $. */
	0x20,0x20,0x22,0x0C,0x20,0x20,0x21,0x05,	/* 3F78:   ".  !. */
	0x20,0x20,0x70,0x23,0x50,0x78,0x2F,0x4F,	/* 3F80:   p#Px.O */
	0x24,0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,	/* 3F88: $q#(& */
	0xE3,0x78,0x41,0xF2,0xD8,0x70,0x23,0x50,	/* 3F90: xAp#P */
	0x78,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x71,	/* 3F98: x.O$q */
	0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,0xD8,	/* 3FA0: #(&xA */
	0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,0xF6,	/* 3FA8: p#Px.O$ */
	0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,0x78,	/* 3FB0: q#(&x */
	0x41,0xF2,0xD8,0x70,0x23,0x50,0x78,0x2F,	/* 3FB8: Ap#Px. */
	0x4F,0x24,0xF6,0xF2,0xF1,0x71,0x23,0x28,	/* 3FC0: O$q#( */
	0x26,0xE3,0x78,0x41,0xF2,0xD8,0x70,0x23,	/* 3FC8: &xAp# */
	0x50,0x78,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,	/* 3FD0: Px.O$ */
	0x71,0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,	/* 3FD8: q#(&xA */
	0xD8,0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,	/* 3FE0: p#Px.O$ */
	0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,	/* 3FE8: q#(& */
	0x78,0x41,0xF2,0xD8,0x70,0x23,0x50,0x78,	/* 3FF0: xAp#Px */
	0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x71,0x23,	/* 3FF8: .O$q# */
	0x28,0x26,0xE3,0x78,0x41,0xF2,0xD8,0x70,	/* 4000: (&xAp */
	0x23,0x50,0x78,0x2F,0x4F,0x24,0xF6,0xF2,	/* 4008: #Px.O$ */
	0xF1,0x71,0x23,0x28,0x26,0xE3,0x78,0x41,	/* 4010: q#(&xA */
	0xF2,0xD8,0x70,0x23,0x50,0x78,0x2F,0x4F,	/* 4018: p#Px.O */
	0x24,0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,	/* 4020: $q#(& */
	0xE3,0x78,0x41,0xF2,0xD8,0x70,0x23,0x50,	/* 4028: xAp#P */
	0x78,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x71,	/* 4030: x.O$q */
	0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,0xD8,	/* 4038: #(&xA */
	0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,0xF6,	/* 4040: p#Px.O$ */
	0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,0x78,	/* 4048: q#(&x */
	0x41,0xF2,0xD8,0x70,0x23,0x50,0x78,0x2F,	/* 4050: Ap#Px. */
	0x4F,0x24,0xF6,0xF2,0xF1,0x71,0x23,0x28,	/* 4058: O$q#( */
	0x26,0xE3,0x78,0x41,0xF2,0xD8,0x70,0x23,	/* 4060: &xAp# */
	0x50,0x78,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,	/* 4068: Px.O$ */
	0x71,0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,	/* 4070: q#(&xA */
	0xD8,0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,	/* 4078: p#Px.O$ */
	0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,	/* 4080: q#(& */
	0x78,0x41,0xF2,0xD8,0x70,0x23,0x50,0x78,	/* 4088: xAp#Px */
	0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x71,0x23,	/* 4090: .O$q# */
	0x28,0x26,0xE3,0x78,0x41,0xF2,0xD8,0x70,	/* 4098: (&xAp */
	0x23,0x50,0x78,0x2F,0x4F,0x24,0xF6,0xF2,	/* 40A0: #Px.O$ */
	0xF1,0x71,0x23,0x28,0x26,0xE3,0x78,0x41,	/* 40A8: q#(&xA */
	0xF2,0xD8,0x70,0x23,0x50,0x78,0x2F,0x4F,	/* 40B0: p#Px.O */
	0x24,0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,	/* 40B8: $q#(& */
	0xE3,0x78,0x41,0xF2,0xD8,0x70,0x23,0x50,	/* 40C0: xAp#P */
	0x78,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x71,	/* 40C8: x.O$q */
	0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,0xD8,	/* 40D0: #(&xA */
	0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,0xF6,	/* 40D8: p#Px.O$ */
	0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,0x78,	/* 40E0: q#(&x */
	0x41,0xF2,0xD8,0x70,0x23,0x50,0x78,0x2F,	/* 40E8: Ap#Px. */
	0x4F,0x24,0xF6,0xF2,0xF1,0x71,0x23,0x28,	/* 40F0: O$q#( */
	0x26,0xE3,0x78,0x41,0xF2,0xD8,0x70,0x23,	/* 40F8: &xAp# */
	0x50,0x78,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,	/* 4100: Px.O$ */
	0x71,0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,	/* 4108: q#(&xA */
	0xD8,0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,	/* 4110: p#Px.O$ */
	0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,	/* 4118: q#(& */
	0x78,0x41,0xF2,0xD8,0x70,0x23,0x50,0x78,	/* 4120: xAp#Px */
	0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x71,0x23,	/* 4128: .O$q# */
	0x28,0x26,0xE3,0x78,0x41,0xF2,0xD8,0x70,	/* 4130: (&xAp */
	0x23,0x50,0x78,0x2F,0x4F,0x24,0xF6,0xF2,	/* 4138: #Px.O$ */
	0xF1,0x71,0x23,0x28,0x26,0xE3,0x78,0x41,	/* 4140: q#(&xA */
	0xF2,0xD8,0x70,0x23,0x50,0x78,0x2F,0x4F,	/* 4148: p#Px.O */
	0x24,0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,	/* 4150: $q#(& */
	0xE3,0x78,0x41,0xF2,0xD8,0x70,0x23,0x50,	/* 4158: xAp#P */
	0x78,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x71,	/* 4160: x.O$q */
	0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,0xD8,	/* 4168: #(&xA */
	0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,0xF6,	/* 4170: p#Px.O$ */
	0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,0x78,	/* 4178: q#(&x */
	0x41,0xF2,0xD8,0x70,0x23,0x50,0x78,0x2F,	/* 4180: Ap#Px. */
	0x4F,0x24,0xF6,0xF2,0xF1,0x71,0x23,0x28,	/* 4188: O$q#( */
	0x26,0xE3,0x78,0x41,0xF2,0xD8,0x70,0x23,	/* 4190: &xAp# */
	0x50,0x78,0x2F,0x4F,0x24,0xF6,0xF2,0xF1,	/* 4198: Px.O$ */
	0x71,0x23,0x28,0x26,0xE3,0x78,0x41,0xF2,	/* 41A0: q#(&xA */
	0xD8,0x70,0x23,0x50,0x78,0x2F,0x4F,0x24,	/* 41A8: p#Px.O$ */
	0xF6,0xF2,0xF1,0x71,0x23,0x28,0x26,0xE3,	/* 41B0: q#(& */
	0x78,0x41,0xF2,0xD8,0x70,0x23,0x50,0x78,	/* 41B8: xAp#Px */
	0x2F,0x4F,0x24,0xF6,0xF2,0xF1,0x71,0x23,	/* 41C0: .O$q# */
	0x28,0x26,0xE3,0x78,0x41,0xF2,0xD8,0x70,	/* 41C8: (&xAp */
	0x23,0x50,0x78,0x2F,0x4F,0x24,0xF6,0xF2,	/* 41D0: #Px.O$ */
	0xF1,0x71,0x23,0x28,0x26,0xE3,0x78,0x41,	/* 41D8: q#(&xA */
	0xF2,0xD8,0x7E,0x78,0x2F,0x4F,0x24,0xF6,	/* 41E0: ~x.O$ */
	0xF4,0x2F,0x4F,0x24,0xF6,0xDB,0x78,0x2F,	/* 41E8: .O$x. */
	0x4F,0x24,0xF6,0x70,0x56,0x23,0xFB,0x41,	/* 41F0: O$pV#A */
	0x7C,0x2C,0x40,0x24,0xFF,0xF0,0xC0,0xA9,	/* 41F8: |,@$ */
	0x41,0x2C,0x41,0x7B,0x24,0xFF,0xF0,0x22,	/* 4200: A,A{$" */
	0xA8,0x41,0x7C,0x24,0x40,0x24,0xFF,0xF0,	/* 4208: A|$@$ */
	0xC0,0x22,0xA5,0x41,0x24,0x41,0x7B,0x24,	/* 4210: "A$A{$ */
	0xFF,0xF0,0xC0,0x21,0xAB,0x76,0x28,0x20,	/* 4218: !v(  */
	0x40,0x24,0xF6,0x21,0xA3,0x76,0x68,0x2F,	/* 4220: @$!vh. */
	0x4F,0x24,0xF6,0xD6,0x41,0x79,0x60,0xEE,	/* 4228: O$Ay` */
	0x07,0x76,0x28,0x20,0x40,0x24,0xFB,0xD6,	/* 4230: .v( @$ */
	0x70,0x24,0x81,0xF1,0x41,0x24,0xFB,0x70,	/* 4238: p$A$p */
	0x24,0x81,0x23,0xFB,0x25,0x07,0x71,0x23,	/* 4240: $#%.q# */
	0x28,0x20,0x36,0x44,0x24,0xF6,0x21,0xA9,	/* 4248: ( 6D$! */
	0x42,0x70,0x22,0x52,0x23,0xFB,0x71,0x23,	/* 4250: Bp"R#q# */
	0x28,0x20,0x36,0x2F,0x4B,0x24,0xF6,0x42,	/* 4258: ( 6.K$B */
	0x24,0xFB,0x71,0x23,0x28,0x20,0xE6,0x23,	/* 4260: $q#( # */
	0x04,0x40,0x70,0x22,0x52,0x23,0xFB,0x76,	/* 4268: .@p"R#v */
	0x60,0x4E,0x24,0xF6,0xD6,0x71,0x23,0x28,	/* 4270: `N$q#( */
	0x20,0x36,0x2F,0x49,0x24,0xF6,0x71,0x23,	/* 4278:  6.I$q# */
	0x28,0x20,0xE6,0x70,0x24,0x81,0xF1,0x41,	/* 4280: ( p$A */
	0x24,0xF6,0x21,0xA1,0x41,0x79,0x60,0xEE,	/* 4288: $!Ay` */
	0x70,0x24,0x81,0xF1,0x60,0x4E,0x24,0xF6,	/* 4290: p$`N$ */
	0x70,0x24,0x81,0x23,0xFB,0x74,0x23,0x4F,	/* 4298: p$#t#O */
	0x24,0xF6,0x71,0x23,0x28,0x26,0xEA,0x77,	/* 42A0: $q#(&w */
	0x71,0x23,0x28,0x26,0xE8,0x76,0x70,0xE4,	/* 42A8: q#(&vp */
	0x75,0x44,0x24,0xF6,0x26,0xA9,0x71,0x23,	/* 42B0: uD$&q# */
	0x28,0x26,0x39,0x2F,0x4F,0x24,0xF6,0xD4,	/* 42B8: (&9.O$ */
	0x71,0x23,0x28,0x26,0x38,0x2F,0x4F,0x24,	/* 42C0: q#(&8.O$ */
	0xF6,0xD7,0x74,0x43,0x24,0xF6,0x71,0x23,	/* 42C8: tC$q# */
	0x28,0x26,0xE8,0x72,0x74,0x43,0x24,0xF6,	/* 42D0: (&rtC$ */
	0x28,0xF1,0x73,0x55,0xFA,0x30,0x25,0xFA,	/* 42D8: (sU0% */
	0xD0,0x21,0x72,0x21,0x28,0x99,0x70,0x21,	/* 42E0: !r!(p! */
	0x72,0x63,0x25,0x2D,0x94,0x70,0x22,0x87,	/* 42E8: rc%-p" */
	0xF1,0xC0,0xAC,0x70,0x21,0x54,0xF1,0x44,	/* 42F0: p!TD */
	0x24,0xFB,0x70,0x21,0x54,0x23,0xFB,0x41,	/* 42F8: $p!T#A */
	0x79,0x60,0xEE,0x70,0x21,0x89,0xF1,0x42,	/* 4300: y`p!B */
	0x24,0xFB,0x70,0x21,0x89,0x23,0xFB,0x74,	/* 4308: $p!#t */
	0x23,0x4F,0x24,0xF6,0x71,0x23,0x28,0x26,	/* 4310: #O$q#(& */
	0xE9,0x77,0x71,0x23,0x28,0x26,0xE8,0x73,	/* 4318: wq#(&s */
	0x89,0xF1,0x71,0x23,0x28,0x27,0xEF,0x72,	/* 4320: q#('r */
	0x41,0xF2,0xD2,0x41,0x72,0x41,0x24,0xFF,	/* 4328: AArA$ */
	0xF0,0xC0,0x21,0xA2,0x40,0xD2,0x73,0x30,	/* 4330: !@s0 */
	0xAA,0x73,0x30,0x27,0x2F,0x2F,0x4F,0x24,	/* 4338: s0'..O$ */
	0xF6,0xD3,0x03,0x28,0x40,0xD3,0x75,0xC0,	/* 4340: .(@u */
	0xAE,0x73,0x7A,0xF4,0xC0,0x6B,0x22,0xA6,	/* 4348: szk" */
	0x72,0x7F,0xF4,0xA3,0x6B,0x21,0x0F,0x21,	/* 4350: rk!.! */
	0xB1,0x22,0xF0,0x60,0xBE,0x74,0x32,0x27,	/* 4358: "`t2' */
	0x2F,0x2F,0x4F,0x24,0xF6,0x33,0xD1,0x74,	/* 4360: ..O$3t */
	0x23,0x85,0xF1,0xD0,0x43,0x70,0xF9,0x21,	/* 4368: #Cp! */
	0xA0,0x70,0x2F,0xA8,0x70,0x41,0xF4,0x21,	/* 4370: p.pA! */
	0xAA,0x70,0x42,0xF4,0xC0,0x2E,0xAD,0x24,	/* 4378: pB.$ */
	0x09,0x70,0x43,0xF4,0x2E,0xA6,0x70,0x44,	/* 4380: .pC.pD */
	0xF4,0x27,0xA6,0x70,0x45,0xF4,0xC0,0x2D,	/* 4388: 'pE- */
	0xAB,0x2A,0x05,0x71,0x23,0x28,0x20,0x35,	/* 4390: *.q#( 5 */
	0x2F,0x4F,0x24,0xF6,0xC0,0x2C,0xAD,0x71,	/* 4398: .O$,q */
	0x23,0x28,0x20,0x39,0x22,0x40,0x24,0xF6,	/* 43A0: #( 9"@$ */
	0xC0,0x21,0xA9,0x71,0x23,0x28,0x20,0x39,	/* 43A8: !q#( 9 */
	0x2F,0x4F,0x24,0xF6,0x22,0x40,0x24,0xFB,	/* 43B0: .O$"@$ */
	0x71,0x23,0x28,0x20,0xE9,0x24,0x4E,0x71,	/* 43B8: q#( $Nq */
	0x23,0x28,0x20,0xE5,0x42,0x74,0x23,0x85,	/* 43C0: #( Bt# */
	0x23,0xFB,0x71,0x23,0x28,0x20,0x35,0x2F,	/* 43C8: #q#( 5. */
	0x4F,0x24,0xF6,0xC0,0x29,0xA6,0x40,0x71,	/* 43D0: O$)@q */
	0x23,0x28,0x26,0xE3,0x28,0x41,0x71,0x23,	/* 43D8: #(&(Aq# */
	0x28,0x26,0xE3,0x74,0x34,0x60,0x4E,0x24,	/* 43E0: (&t4`N$ */
	0xF6,0x74,0xE4,0x71,0x23,0x28,0x20,0x36,	/* 43E8: tq#( 6 */
	0x2F,0x49,0x24,0xF6,0x71,0x23,0x28,0x20,	/* 43F0: .I$q#(  */
	0xE6,0x43,0x74,0x23,0x85,0x23,0xFB,0x26,	/* 43F8: Ct##& */
	0x0B,0x71,0x23,0x28,0x20,0x35,0x2F,0x4F,	/* 4400: .q#( 5.O */
	0x24,0xF6,0xC0,0x25,0xAF,0x71,0x23,0x28,	/* 4408: $%q#( */
	0x20,0x39,0x22,0x40,0x24,0xF6,0xC0,0x21,	/* 4410:  9"@$! */
	0xA9,0x71,0x23,0x28,0x20,0x39,0x2F,0x4F,	/* 4418: q#( 9.O */
	0x24,0xF6,0x22,0x40,0x24,0xFB,0x71,0x23,	/* 4420: $"@$q# */
	0x28,0x20,0xE9,0x24,0x4E,0x71,0x23,0x28,	/* 4428: ( $Nq#( */
	0x20,0xE5,0x45,0x74,0x23,0x85,0x23,0xFB,	/* 4430:  Et## */
	0x71,0x23,0x28,0x20,0x35,0x2F,0x4F,0x24,	/* 4438: q#( 5.O$ */
	0xF6,0xC0,0x22,0xA8,0x40,0x71,0x23,0x28,	/* 4440: "@q#( */
	0x26,0xE3,0x28,0x43,0x71,0x23,0x28,0x26,	/* 4448: &(Cq#(& */
	0xE3,0x71,0x23,0x28,0x20,0x39,0x2D,0x4F,	/* 4450: q#( 9-O */
	0x24,0xF6,0x71,0x23,0x28,0x20,0xE9,0x24,	/* 4458: $q#( $ */
	0x4E,0x71,0x23,0x28,0x20,0xE5,0x40,0x74,	/* 4460: Nq#( @t */
	0x23,0x85,0x23,0xFB,0xB2,0x22,0xF0,0x60,	/* 4468: ##"` */
	0xBF,0x73,0x31,0x25,0xFA,0xD0,0x23,0x28,	/* 4470: s1%#( */
	0x20,0x35,0x2F,0x4F,0x24,0xF6,0x21,0xA0,	/* 4478:  5.O$! */
	0x73,0x22,0x50,0xF1,0x21,0x40,0x24,0xFB,	/* 4480: s"P!@$ */
	0x73,0x22,0x50,0x23,0xFB,0xB1,0x22,0xF0,	/* 4488: s"P#" */
	0x73,0x22,0x50,0xF1,0x61,0x4F,0x24,0xF6,	/* 4490: s"PaO$ */
	0x73,0x22,0x50,0x23,0xFB,0x73,0x21,0x58,	/* 4498: s"P#s!X */
	0xF1,0x21,0x40,0x24,0xF6,0x24,0xAC,0x70,	/* 44A0: !@$$p */
	0x23,0x28,0x26,0x3C,0x21,0x40,0x24,0xF6,	/* 44A8: #(&<!@$ */
	0x22,0xA0,0x73,0x22,0x50,0xF1,0x41,0x24,	/* 44B0: "s"PA$ */
	0xF6,0x25,0xA5,0x21,0x48,0x70,0x23,0x28,	/* 44B8: %!Hp#( */
	0x20,0xE5,0x73,0x22,0x50,0xF1,0x60,0x4E,	/* 44C0:  s"P`N */
	0x24,0xF6,0x73,0x22,0x50,0x23,0xFB,0xB1,	/* 44C8: $s"P# */
	0x22,0xF0,0x73,0x22,0x50,0xF1,0x41,0x24,	/* 44D0: "s"PA$ */
	0xF6,0x23,0xF2,0x23,0xA3,0x21,0x44,0x70,	/* 44D8: ##!Dp */
	0x23,0x28,0x20,0xE5,0x73,0x22,0x50,0xF1,	/* 44E0: #( s"P */
	0x41,0x24,0xFB,0x73,0x22,0x50,0x23,0xFB,	/* 44E8: A$s"P# */
	0xB1,0x22,0xF0,0x73,0x22,0x50,0xF1,0x41,	/* 44F0: "s"PA */
	0x24,0xF6,0x21,0xA4,0x21,0x48,0x70,0x23,	/* 44F8: $!!Hp# */
	0x28,0x20,0xE5,0x73,0x22,0x50,0xF1,0x60,	/* 4500: ( s"P` */
	0x4E,0x24,0xF6,0x73,0x22,0x50,0x23,0xFB,	/* 4508: N$s"P# */
	0xB1,0x22,0xF0,0x60,0xBF,0x72,0x3A,0xD0,	/* 4510: "`r: */
	0x72,0x3A,0x72,0x3B,0x72,0x3B,0x26,0x2B,	/* 4518: r:r;r;&+ */
	0x96,0x72,0x72,0x3B,0xD2,0xD3,0xB1,0x60,	/* 4520: rr;` */
	0xB8,0x79,0x28,0x56,0xD5,0x7A,0x37,0x7A,	/* 4528: y(Vz7z */
	0x35,0xF4,0x75,0x21,0xEB,0x7A,0x37,0x75,	/* 4530: 5u!z7u */
	0x21,0xEC,0x7A,0x3D,0x75,0x21,0xEF,0x7A,	/* 4538: !z=u!z */
	0x3C,0x75,0x22,0xE0,0x41,0x75,0x22,0xE3,	/* 4540: <u"Au" */
	0x24,0x20,0x40,0x75,0x22,0xE4,0x7A,0x75,	/* 4548: $ @u"zu */
	0x21,0xEE,0x75,0x21,0x55,0x79,0x2B,0x26,	/* 4550: !u!Uy+& */
	0x9E,0xC0,0x22,0xA5,0x21,0xFE,0x75,0xEE,	/* 4558: "!u */
	0x22,0xF2,0x75,0xED,0x75,0x16,0x44,0x24,	/* 4560: "uu.D$ */
	0xFA,0x24,0xF2,0xD0,0x24,0xF2,0xD1,0x40,	/* 4568: $$@ */
	0xD2,0x24,0xF2,0xD3,0x40,0xD4,0x16,0x41,	/* 4570: $@.A */
	0x79,0x64,0x2F,0x28,0x9E,0x79,0x2C,0x20,	/* 4578: yd.(y,  */
	0x98,0xB8,0x22,0xF0,0x20,0x00,0x20,0x01,	/* 4580: " . . */
	0x00,0xD4,0x01,0x71,0x28,0x56,0xD2,0x60,	/* 4588: ..q(V` */
	0x42,0x21,0xFB,0x72,0xE0,0x72,0x61,0x4D,	/* 4590: B!rraM */
	0x21,0xFB,0x41,0x26,0x28,0x97,0x22,0xF0,	/* 4598: !A&(" */
	0x20,0x74,0xD1,0x23,0x2F,0x05,0x74,0xD1,	/* 45A0:  t#..t */
	0x24,0x21,0x0C,0x11,0x72,0x42,0x23,0x2E,	/* 45A8: $!..rB#. */
	0x9A,0x71,0x22,0xF0,0x40,0xD1,0x11,0x72,	/* 45B0: q"@.r */
	0x41,0x23,0x2D,0x9F,0x71,0x2F,0x4F,0x24,	/* 45B8: A#-q.O$ */
	0xF6,0x22,0xF0,0x13,0x72,0x42,0x23,0x2F,	/* 45C0: ".rB#. */
	0x9E,0x22,0xF0,0x13,0x72,0x41,0x23,0x2F,	/* 45C8: ".rA#. */
	0x96,0x22,0xF0,0x60,0xBE,0x73,0x29,0x39,	/* 45D0: "`s)9 */
	0xD0,0x40,0xD1,0x73,0x2A,0x31,0x24,0xF2,	/* 45D8: @s*1$ */
	0xF4,0x21,0xA4,0x73,0x2A,0x31,0x74,0xF9,	/* 45E0: !s*1t */
	0xC0,0xAD,0x74,0x73,0x2A,0x32,0xF9,0xC0,	/* 45E8: ts*2 */
	0xA6,0x41,0x47,0x73,0x2B,0x2B,0x9A,0x70,	/* 45F0: AGs++p */
	0x24,0xF2,0xF4,0x21,0xAB,0x70,0x32,0x74,	/* 45F8: $!p2t */
	0xF9,0xC0,0xA9,0x70,0x33,0x70,0x32,0xF2,	/* 4600: p3p2 */
	0x74,0xF9,0xC0,0xAA,0x70,0x30,0xD0,0x70,	/* 4608: tp0p */
	0x24,0xF2,0xF4,0xA4,0x61,0x07,0x41,0xD1,	/* 4610: $a.A */
	0x71,0xA6,0x41,0x47,0x73,0x2B,0x29,0x91,	/* 4618: qAGs+) */
	0xB2,0x22,0xF0,0x60,0xBF,0x11,0xD0,0x72,	/* 4620: "`.r */
	0x29,0x39,0x24,0xF2,0xF4,0xC0,0x21,0xA0,	/* 4628: )9$! */
	0x21,0x25,0x46,0x21,0xFB,0x72,0x2A,0xEB,	/* 4630: !%F!r* */
	0x22,0x26,0x45,0x21,0xFB,0x72,0x2A,0xEC,	/* 4638: "&E!r* */
	0x75,0x72,0x67,0x9F,0x76,0xA8,0x77,0x23,	/* 4640: urgvw# */
	0xF4,0x21,0x50,0x76,0xF9,0xA4,0x41,0xB1,	/* 4648: !PvA */
	0x22,0xF0,0x77,0x81,0xD7,0x73,0x24,0xF2,	/* 4650: "ws$ */
	0xF4,0x26,0xAB,0x75,0x73,0xE2,0x76,0x73,	/* 4658: &usvs */
	0xE3,0x76,0x73,0x32,0xF5,0x60,0x5D,0x77,	/* 4660: vs2`]w */
	0x23,0xF4,0xFC,0x73,0xE4,0x74,0x73,0x34,	/* 4668: #sts4 */
	0x60,0xEF,0x74,0x73,0xE6,0x2A,0x27,0x4B,	/* 4670: `ts*'K */
	0x21,0xFB,0x73,0x34,0xE0,0x70,0x31,0x73,	/* 4678: !s4p1s */
	0x34,0xE1,0x73,0x73,0x34,0xE2,0x40,0xD0,	/* 4680: 4ss4@ */
	0x77,0x60,0x8F,0x40,0xF9,0x21,0xA5,0x70,	/* 4688: w`@!p */
	0x18,0xFA,0x30,0x70,0x83,0x73,0x34,0xFA,	/* 4690: .0ps4 */
	0xE0,0x70,0x81,0xD0,0x77,0x60,0x8F,0x70,	/* 4698: pw`p */
	0xF9,0xA2,0x61,0x0B,0x77,0x73,0xE5,0x24,	/* 46A0: a.ws$ */
	0xF2,0x81,0x73,0xE7,0x72,0x28,0x58,0x72,	/* 46A8: sr(Xr */
	0x2D,0x99,0x72,0x29,0x39,0x73,0xE0,0x73,	/* 46B0: -r)9ss */
	0x72,0x29,0xE9,0x72,0x28,0x58,0x72,0x21,	/* 46B8: r)r(Xr! */
	0x2E,0x90,0x40,0xB1,0x22,0xF0,0x41,0xB1,	/* 46C0: .@"A */
	0x22,0xF0,0x60,0xBE,0x73,0x28,0x58,0xD1,	/* 46C8: "`s(X */
	0x71,0x73,0x2B,0x97,0x74,0x71,0x21,0x31,	/* 46D0: qs+tq!1 */
	0xF4,0xAD,0x71,0x21,0x31,0xD0,0x70,0x30,	/* 46D8: q!1p0 */
	0x24,0xF2,0xF4,0x22,0xA2,0x21,0x00,0x71,	/* 46E0: $"!.q */
	0x21,0x31,0x30,0x71,0x21,0xE1,0x71,0x73,	/* 46E8: !10q!qs */
	0x21,0x2A,0x9F,0x40,0xB2,0x22,0xF0,0x70,	/* 46F0: !*@"p */
	0x30,0x74,0xF4,0xAB,0x70,0x30,0xD0,0x70,	/* 46F8: 0tp0p */
	0x30,0x24,0xF2,0xF4,0xA2,0x60,0x00,0x70,	/* 4700: 0$`.p */
	0x30,0x24,0xF2,0xF4,0xAD,0x74,0x30,0x70,	/* 4708: 0$t0p */
	0xE0,0x71,0x73,0x21,0x28,0x9C,0x40,0xB2,	/* 4710: qs!(@ */
	0x22,0xF0,0x71,0x73,0x21,0x28,0x93,0x41,	/* 4718: "qs!(A */
	0xB2,0x22,0xF0,0x72,0x71,0x65,0x93,0xA6,	/* 4720: "rqe */
	0x41,0x48,0x71,0x2A,0x28,0x93,0x22,0xF0,	/* 4728: AHq*(" */
	0x72,0x71,0x66,0x96,0xA6,0x41,0x48,0x71,	/* 4730: rqfAHq */
	0x2A,0x27,0x96,0x72,0x71,0x23,0x2F,0x9D,	/* 4738: *'rq#. */
	0x22,0xF0,0x01,0x00,0x00,0x00,0x00,0x00,	/* 4740: "...... */
	0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x0A,	/* 4748: ........ */
	0x00,0x08,0x00,0x07,0x00,0x05,0x00,0x04,	/* 4750: ........ */
	0x00,0x02,0x00,0x01,0x00,0xAE,0x02,0x71,	/* 4758: ......q */
	0x28,0x58,0xD2,0x62,0x4B,0x21,0xFB,0x72,	/* 4760: (XbK!r */
	0x4D,0x24,0xFA,0x72,0x62,0x4F,0x21,0xFB,	/* 4768: M$rbO! */
	0x47,0x24,0x2B,0x91,0x22,0xF0,0x20,0x72,	/* 4770: G$+" r */
	0x22,0xFB,0x22,0xF0,0x22,0xF2,0x72,0xF2,	/* 4778: """r */
	0xD2,0x72,0x22,0xFB,0x22,0xF0,0x21,0xF5,	/* 4780: r""! */
	0x22,0xF0,0x20,0x60,0xB8,0x40,0xD3,0x24,	/* 4788: " `@$ */
	0xF2,0xD0,0x24,0xF2,0xD1,0x21,0xFE,0x41,	/* 4790: $!A */
	0xF4,0xA2,0x28,0x01,0x41,0xD4,0x7A,0x33,	/* 4798: (.Az3 */
	0xC1,0xA6,0x40,0x7A,0xE3,0x40,0x22,0xA0,	/* 47A0: @z@" */
	0x24,0xF2,0x24,0xF2,0xD6,0xD7,0x7A,0x34,	/* 47A8: $$z4 */
	0x24,0xF2,0xF4,0xC0,0xA8,0x16,0x16,0x7A,	/* 47B0: $..z */
	0xE4,0x7A,0xE5,0x40,0xA7,0x16,0x7A,0x35,	/* 47B8: z@.z5 */
	0xE1,0x16,0x7A,0xE5,0x15,0x16,0x42,0xF7,	/* 47C0: .z..B */
	0x41,0x7A,0xE9,0x41,0x7A,0x30,0x40,0x24,	/* 47C8: AzAz0@$ */
	0xFF,0xF0,0x21,0xA1,0x41,0xD3,0x7A,0x31,	/* 47D0: !Az1 */
	0x24,0xF2,0xF4,0x21,0xA0,0x10,0x7A,0x32,	/* 47D8: $!.z2 */
	0xE1,0x10,0x7A,0xE2,0x0E,0x7A,0x30,0x60,	/* 47E0: .z.z0` */
	0x4F,0xF2,0x7A,0xE0,0x06,0x10,0x7A,0xE1,	/* 47E8: Oz..z */
	0x10,0x7A,0xE2,0x40,0x7A,0xE9,0x7A,0x3A,	/* 47F0: .z@zz: */
	0x24,0xF2,0xF4,0xA5,0x14,0x7A,0x5A,0x42,	/* 47F8: $.zZB */
	0xFB,0x41,0xD5,0x7A,0x34,0x24,0xF2,0xF4,	/* 4800: Az4$ */
	0xC0,0xA5,0x41,0x7A,0xE3,0x40,0xAC,0x7A,	/* 4808: Az@z */
	0x34,0x31,0x7A,0x34,0xD6,0x7A,0xE4,0x15,	/* 4810: 41z4z. */
	0x76,0x42,0xFB,0x27,0x0B,0x7A,0x36,0xC1,	/* 4818: vB'.z6 */
	0xA7,0x20,0x40,0x7A,0xE6,0x40,0x22,0xA2,	/* 4820:  @z@" */
	0x24,0xF2,0x24,0xF2,0xD6,0xD7,0x7A,0x37,	/* 4828: $$z7 */
	0x24,0xF2,0xF4,0xC0,0xAA,0x20,0x16,0x16,	/* 4830: $ .. */
	0x7A,0xE7,0x7A,0xE8,0x40,0xA8,0x20,0x16,	/* 4838: zz@ . */
	0x7A,0x38,0xE1,0x16,0x7A,0xE8,0x15,0x16,	/* 4840: z8.z.. */
	0x42,0xF7,0x7A,0x39,0xA6,0x20,0x14,0x7A,	/* 4848: Bz9 .z */
	0x5A,0x42,0xF7,0x41,0x7A,0x30,0x40,0x24,	/* 4850: ZBAz0@$ */
	0xFF,0xF0,0x21,0xA1,0x41,0xD3,0x7A,0x31,	/* 4858: !Az1 */
	0x24,0xF2,0xF4,0x21,0xA1,0x10,0x7A,0x32,	/* 4860: $!.z2 */
	0xE1,0x10,0x7A,0xE2,0x0F,0x7A,0x30,0x60,	/* 4868: .z.z0` */
	0x4F,0xF2,0x7A,0xE0,0x07,0x20,0x10,0x7A,	/* 4870: Oz. .z */
	0xE1,0x10,0x7A,0xE2,0x41,0xD5,0x7A,0x37,	/* 4878: .zAz7 */
	0x24,0xF2,0xF4,0xC0,0xA7,0x20,0x41,0x7A,	/* 4880: $ Az */
	0xE6,0x40,0xAD,0x20,0x7A,0x37,0x31,0x7A,	/* 4888: @ z71z */
	0x37,0xD6,0x7A,0xE7,0x15,0x76,0x42,0xFB,	/* 4890: 7z.vB */
	0x73,0xA5,0x20,0x12,0x10,0x42,0xF7,0xB8,	/* 4898: s ..B */
	0x22,0xF0,0x60,0xBB,0x41,0xD0,0x21,0xFE,	/* 48A0: "`A! */
	0x41,0xF4,0xA3,0x20,0x27,0x0B,0x77,0x33,	/* 48A8: A '.w3 */
	0xC1,0xA7,0x20,0x40,0x77,0xE3,0x40,0x22,	/* 48B0:  @w@" */
	0xA2,0x24,0xF2,0x24,0xF2,0xD2,0xD3,0x77,	/* 48B8: $$w */
	0x34,0x24,0xF2,0xF4,0xC0,0xAA,0x20,0x12,	/* 48C0: 4$ . */
	0x12,0x77,0xE4,0x77,0xE5,0x40,0xA8,0x20,	/* 48C8: .ww@  */
	0x12,0x77,0x35,0xE1,0x12,0x77,0xE5,0x11,	/* 48D0: .w5.w. */
	0x12,0x42,0xF7,0x41,0x77,0xE9,0x77,0x31,	/* 48D8: .BAww1 */
	0x24,0xF2,0xF4,0xAB,0x20,0x77,0x31,0xD1,	/* 48E0: $ w1 */
	0x77,0x31,0x31,0x77,0xE1,0x09,0x20,0x77,	/* 48E8: w11w. w */
	0x30,0x41,0xF2,0x77,0xE0,0x05,0x20,0x10,	/* 48F0: 0Aw. . */
	0x71,0x42,0xFB,0x40,0x77,0xE9,0x77,0x3A,	/* 48F8: qB@ww: */
	0x24,0xF2,0xF4,0xA6,0x20,0x10,0x77,0x5A,	/* 4900: $ .wZ */
	0x42,0xFB,0x41,0xD1,0x77,0x34,0x24,0xF2,	/* 4908: BAw4$ */
	0xF4,0xC0,0xA7,0x20,0x41,0x77,0xE3,0x40,	/* 4910:  Aw@ */
	0xAD,0x20,0x77,0x34,0x31,0x77,0x34,0xD2,	/* 4918:  w41w4 */
	0x77,0xE4,0x11,0x72,0x42,0xFB,0xB5,0x22,	/* 4920: w.rB" */
	0xF0,0x77,0x36,0xC1,0xA7,0x20,0x40,0x77,	/* 4928: w6 @w */
	0xE6,0x40,0x22,0xA2,0x24,0xF2,0x24,0xF2,	/* 4930: @"$$ */
	0xD3,0xD4,0x77,0x37,0x24,0xF2,0xF4,0xC0,	/* 4938: w7$ */
	0xAA,0x20,0x13,0x13,0x77,0xE7,0x77,0xE8,	/* 4940:  ..ww */
	0x40,0xA8,0x20,0x13,0x77,0x38,0xE1,0x13,	/* 4948: @ .w8. */
	0x77,0xE8,0x12,0x13,0x42,0xF7,0x77,0x39,	/* 4950: w..Bw9 */
	0xA6,0x20,0x11,0x77,0x5A,0x42,0xF7,0x77,	/* 4958:  .wZBw */
	0x31,0x24,0xF2,0xF4,0xAB,0x20,0x77,0x31,	/* 4960: 1$ w1 */
	0xD2,0x77,0x31,0x31,0x77,0xE1,0x09,0x20,	/* 4968: w11w.  */
	0x77,0x30,0x41,0xF2,0x77,0xE0,0x05,0x20,	/* 4970: w0Aw.  */
	0x10,0x72,0x42,0xFB,0x41,0xD2,0x77,0x37,	/* 4978: .rBAw7 */
	0x24,0xF2,0xF4,0xC0,0xA7,0x20,0x41,0x77,	/* 4980: $ Aw */
	0xE6,0x40,0xAD,0x20,0x77,0x37,0x31,0x77,	/* 4988: @ w71w */
	0x37,0xD3,0x77,0xE7,0x12,0x73,0x42,0xFB,	/* 4990: 7w.sB */
	0xB5,0x22,0xF0,0x60,0xBF,0x22,0xF9,0x41,	/* 4998: "`"A */
	0x73,0x24,0xF6,0x21,0xA5,0x72,0xD0,0x74,	/* 49A0: s$!rt */
	0x73,0x60,0x8F,0x10,0x25,0xF5,0x21,0x93,	/* 49A8: s`.%! */
	0x70,0x72,0xF4,0xC0,0x41,0x24,0xFD,0x25,	/* 49B0: prA$% */
	0xF5,0x04,0x74,0x73,0x72,0xF7,0x22,0xF9,	/* 49B8: .tsr" */
	0xB1,0x22,0xF0,0x27,0x22,0x06,0x20,0x22,	/* 49C0: "'". " */
	0xF9,0x41,0x72,0x24,0xF6,0xA9,0x73,0x72,	/* 49C8: Ar$sr */
	0x60,0x8F,0x71,0x25,0xF5,0x99,0x04,0x73,	/* 49D0: `q%.s */
	0x72,0x71,0xFB,0x22,0xF9,0x22,0xF0,0x27,	/* 49D8: rq""' */
	0x20,0x03,0x20,0x01,0x00,0xFF,0xFF,0xFF,	/* 49E0:  . .. */
	0xFF,0xFF,0xFF,0xEF,0x7F,0x00,0x00,0x00,	/* 49E8: ... */
	0x00,0x00,0x00,0x00,0x00,0x0F,0x27,0x02,	/* 49F0: ......'. */
	0x04,0x15,0x00,0x14,0x00,0x12,0x00,0x11,	/* 49F8: ........ */
	0x00,0x10,0x00,0x0F,0x00,0x0E,0x00,0x0C,	/* 4A00: ........ */
	0x00,0x06,0x00,0x66,0x00,0x71,0x29,0x53,	/* 4A08: ...f.q)S */
	0xD2,0x61,0x43,0x21,0xFB,0x72,0x22,0x8F,	/* 4A10: aC!r" */
	0x41,0x24,0xFA,0x63,0x44,0x21,0xFB,0x72,	/* 4A18: A$cD!r */
	0x82,0x21,0x45,0x24,0xFA,0x72,0x63,0x4F,	/* 4A20: !E$rcO */
	0x21,0xFB,0x49,0x21,0x2F,0x97,0x22,0xF0,	/* 4A28: !I!." */
	0x20,0x73,0x72,0xE0,0x24,0xF2,0x72,0xE1,	/* 4A30:  sr$r */
	0x41,0x72,0xE3,0x24,0xF2,0x72,0xE4,0x41,	/* 4A38: Ar$rA */
	0x72,0xE6,0x24,0xF2,0x72,0xE7,0x40,0x72,	/* 4A40: r$r@r */
	0xE9,0x24,0xF2,0x72,0xEA,0x22,0xF0,0x41,	/* 4A48: $r"A */
	0x72,0x30,0x40,0x24,0xFF,0xF0,0xA8,0x40,	/* 4A50: r0@$@ */
	0x21,0x4B,0xD2,0xD3,0x27,0x25,0x02,0x72,	/* 4A58: !K'%.r */
	0x30,0x60,0x4F,0xF2,0x72,0xE0,0x22,0xF0,	/* 4A60: 0`Or" */
	0x72,0x30,0x41,0xF2,0x72,0xE0,0x22,0xF0,	/* 4A68: r0Ar" */
	0x20,0x46,0x01,0x71,0x2A,0x5B,0xD2,0x61,	/* 4A70:  F.q*[a */
	0x4D,0x21,0xFB,0x72,0xE1,0x63,0x4E,0x21,	/* 4A78: M!rcN! */
	0xFB,0x72,0xE0,0x22,0xF0,0x60,0xBA,0x78,	/* 4A80: r"`x */
	0x24,0xF2,0xF4,0x24,0xA2,0x78,0x60,0x5E,	/* 4A88: $$x`^ */
	0xD1,0x78,0x41,0x24,0xF6,0xC0,0x22,0xA1,	/* 4A90: xA$" */
	0x77,0x2A,0x35,0x71,0xF9,0xC0,0x21,0xA9,	/* 4A98: w*5q! */
	0x77,0x2A,0x37,0x71,0xF9,0x21,0xA2,0x71,	/* 4AA0: w*7q!q */
	0x30,0x24,0xF2,0x81,0xF4,0xC0,0xAA,0x71,	/* 4AA8: 0$q */
	0x31,0x60,0x4C,0x24,0xF6,0x71,0x31,0xF4,	/* 4AB0: 1`L$q1 */
	0xA6,0x41,0x44,0x77,0x26,0x2F,0x92,0x77,	/* 4AB8: ADw&.w */
	0x2A,0x5D,0x25,0xFA,0xD4,0x30,0x25,0xFA,	/* 4AC0: *]%0% */
	0xD5,0xD0,0x77,0x2A,0x3E,0xD2,0x06,0xB6,	/* 4AC8: w*>. */
	0x22,0xF0,0x70,0x30,0xD0,0x70,0x72,0xF4,	/* 4AD0: "p0pr */
	0xA7,0x71,0x70,0x30,0xF9,0xA2,0x60,0x02,	/* 4AD8: qp0`. */
	0x70,0x30,0x25,0xFA,0xD3,0x75,0xF4,0xA7,	/* 4AE0: p0%u */
	0x71,0x71,0x31,0xF2,0x73,0xF4,0xA5,0x73,	/* 4AE8: qq1ss */
	0x71,0xE0,0x21,0x06,0x73,0x72,0xF4,0xC0,	/* 4AF0: q!.sr */
	0xA4,0x20,0x71,0x74,0xE1,0x70,0x30,0x31,	/* 4AF8:  qtp01 */
	0x71,0x31,0xF2,0x71,0xE1,0x70,0x30,0x30,	/* 4B00: q1qp00 */
	0x71,0xE0,0x70,0x70,0x31,0xF2,0x71,0xF4,	/* 4B08: qpp1q */
	0x21,0xA0,0x71,0x70,0xE0,0x71,0x30,0x74,	/* 4B10: !qpq0t */
	0x30,0xF4,0xC0,0x21,0xA7,0x71,0x74,0xE1,	/* 4B18: 0!qt */
	0x21,0x02,0x71,0x31,0x70,0x31,0xF2,0x70,	/* 4B20: !.q1p1p */
	0xE1,0x71,0x30,0x70,0xE0,0x70,0x30,0x74,	/* 4B28: q0pp0t */
	0x30,0xF4,0xA4,0x20,0xB6,0x22,0xF0,0x70,	/* 4B30: 0 "p */
	0x74,0xE1,0xB6,0x22,0xF0,0x60,0xBE,0x73,	/* 4B38: t"`s */
	0x2A,0x5D,0xD0,0x70,0x32,0x21,0xA8,0x70,	/* 4B40: *]p2!p */
	0x60,0x3E,0xD1,0x70,0x53,0x73,0x21,0x92,	/* 4B48: `>pSs! */
	0x74,0x73,0x6C,0x91,0x70,0x60,0x3F,0xD1,	/* 4B50: tslp`? */
	0x70,0x53,0x73,0x96,0xB2,0x22,0xF0,0xB2,	/* 4B58: pSs" */
	0x22,0xF0,0x75,0xF6,0x20,0x60,0xBE,0x73,	/* 4B60: "u `s */
	0x2A,0x5D,0xD0,0x70,0x5E,0x25,0xFA,0x25,	/* 4B68: *]p^%% */
	0xFA,0xD1,0xE0,0x71,0x70,0xE0,0x71,0x70,	/* 4B70: qpqp */
	0xE1,0x40,0x71,0xE1,0x41,0x70,0x53,0x73,	/* 4B78: @qApSs */
	0x61,0x2A,0x9E,0x74,0x70,0x60,0xEA,0x75,	/* 4B80: a*tp`u */
	0x74,0xF2,0x70,0x60,0xEB,0x41,0x70,0xE2,	/* 4B88: tp`Ap */
	0x76,0xA8,0x40,0x70,0x60,0xE3,0x74,0x70,	/* 4B90: v@p`tp */
	0x60,0xE8,0xB2,0x22,0xF0,0x40,0x71,0x2A,	/* 4B98: `"@q* */
	0xEF,0x22,0xF0,0x0E,0x00,0x0D,0x00,0x0B,	/* 4BA0: "..... */
	0x00,0x0A,0x00,0x08,0x00,0x07,0x00,0x05,	/* 4BA8: ........ */
	0x00,0x04,0x00,0x01,0x00,0x00,0x00,0x6A,	/* 4BB0: .......j */
	0x00,0x71,0x2A,0x5D,0xD2,0x72,0x61,0x41,	/* 4BB8: .q*]raA */
	0x21,0xFB,0x4A,0x26,0x90,0x22,0xF0,0x00,	/* 4BC0: !J&". */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 4BC8: ........ */
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,	/* 4BD0: .......` */
	0xBE,0x41,0x75,0x76,0x24,0xFF,0xF0,0x21,	/* 4BD8: Auv$! */
	0xA7,0x74,0xD0,0x75,0x74,0xF2,0xD1,0x71,	/* 4BE0: tutq */
	0x70,0xF9,0x21,0xA0,0x40,0x70,0xE0,0x70,	/* 4BE8: p!@pp */
	0x51,0xD0,0x71,0x70,0xF9,0xA6,0x60,0x04,	/* 4BF0: Qqp`. */
	0x41,0xB2,0x22,0xF0,0x73,0x21,0x9C,0xD0,	/* 4BF8: A"s! */
	0x70,0x30,0xAF,0x70,0x30,0x70,0xF2,0xD0,	/* 4C00: p0p0p */
	0x70,0x51,0xD1,0x73,0x99,0x70,0x30,0xA2,	/* 4C08: pQsp0 */
	0x60,0x01,0x40,0xB2,0x22,0xF0,0x75,0xF6,	/* 4C10: `.@"u */
	0x20,0x68,0xB9,0x60,0x4A,0x21,0xFB,0x22,	/* 4C18:  h`J!" */
	0xF0,0x7E,0x02,0x22,0xF0,0x71,0x60,0x8F,	/* 4C20: ~."q` */
	0xD1,0x71,0x60,0x4F,0xF9,0x21,0xA4,0x24,	/* 4C28: q`O!$ */
	0xF2,0x71,0x72,0xFA,0x30,0x73,0xFA,0xE0,	/* 4C30: qr0s */
	0x71,0x60,0x8F,0xD1,0x71,0x60,0x4F,0xF9,	/* 4C38: q`q`O */
	0xA2,0x61,0x0C,0x22,0xF0,0x60,0xB4,0x7D,	/* 4C40: a."`} */
	0x2B,0x5D,0xD0,0x7E,0x7F,0x24,0xFB,0xAE,	/* 4C48: +]~$ */
	0x1E,0x2E,0x44,0x21,0xFB,0x23,0x2F,0x92,	/* 4C50: ..D!#. */
	0xAB,0x60,0x4F,0xBC,0x22,0xF0,0x70,0x61,	/* 4C58: `O"pa */
	0x3A,0xBC,0x22,0xF0,0x40,0x7E,0x41,0x23,	/* 4C60: :"@~A# */
	0xF7,0xD8,0x7F,0x40,0x23,0xF7,0xD9,0x78,	/* 4C68: @#x */
	0x60,0x4E,0x24,0xF6,0xD6,0x79,0xD7,0x2C,	/* 4C70: `N$y, */
	0x42,0x21,0xFB,0x16,0x14,0x22,0x24,0x9B,	/* 4C78: B!.."$ */
	0x70,0x61,0x3E,0xDA,0x70,0x7D,0x21,0x2F,	/* 4C80: pa>p}!. */
	0x92,0x10,0xD3,0x70,0x61,0x33,0x21,0xA8,	/* 4C88: .pa3! */
	0x70,0x61,0x34,0x73,0xF9,0xC0,0xA6,0x73,	/* 4C90: pa4ss */
	0x70,0x61,0x35,0xF9,0xA5,0x70,0x61,0x32,	/* 4C98: pa5pa2 */
	0xD1,0x02,0x73,0xD1,0x71,0x69,0x5A,0xD1,	/* 4CA0: .sqiZ */
	0x70,0x61,0x3A,0xD2,0x70,0x61,0x3B,0x21,	/* 4CA8: pa:pa;! */
	0xFD,0xDA,0xDB,0x70,0x61,0x3A,0x21,0xFD,	/* 4CB0: pa:! */
	0xD8,0xD9,0x40,0x7A,0x78,0x24,0xFF,0xD6,	/* 4CB8: @zx$ */
	0x7B,0x79,0x24,0xFF,0xD7,0x16,0x1E,0x23,	/* 4CC0: {y$..# */
	0x28,0x90,0xC0,0x22,0xAA,0x70,0x61,0x3B,	/* 4CC8: ("pa; */
	0x24,0xF2,0xF4,0x22,0xA2,0x70,0x61,0x33,	/* 4CD0: $"pa3 */
	0x22,0xAB,0x71,0x21,0xFD,0xD8,0xD9,0x70,	/* 4CD8: "q!p */
	0x61,0x3A,0x21,0xFD,0xD6,0xD7,0x40,0x78,	/* 4CE0: a:!@x */
	0x76,0x24,0xFF,0xDA,0x79,0x77,0x24,0xFF,	/* 4CE8: v$yw$ */
	0xDB,0x1A,0x1E,0x23,0x25,0x94,0xAE,0x70,	/* 4CF0: ..#%p */
	0x61,0x3F,0xD6,0x70,0x7D,0x21,0x27,0x9D,	/* 4CF8: a?p}!' */
	0x60,0x4F,0xBC,0x22,0xF0,0x75,0x74,0x41,	/* 4D00: `O"utA */
	0x23,0xF6,0xDA,0xDB,0x70,0x61,0x3A,0x21,	/* 4D08: #pa:! */
	0xFD,0xD6,0xD7,0x40,0x7A,0x76,0x23,0xF7,	/* 4D10: @zv# */
	0xD8,0x7B,0x77,0x23,0xF7,0xD9,0x78,0x70,	/* 4D18: {w#xp */
	0x61,0xEA,0x70,0x61,0x33,0xA6,0x70,0x61,	/* 4D20: apa3pa */
	0x3A,0x70,0x61,0xE4,0x70,0x61,0x3F,0xD6,	/* 4D28: :papa? */
	0x70,0x7D,0x21,0x24,0x98,0x72,0xBC,0x22,	/* 4D30: p}!$r" */
	0xF0,0x00,0x00,0x00,0x00,0x02,0x00,0x00,	/* 4D38: ....... */
	0x00,0x60,0xBD,0x75,0xD2,0x41,0x74,0x2A,	/* 4D40: .`uAt* */
	0x3A,0x75,0x24,0xFF,0xF0,0xC0,0xA4,0x74,	/* 4D48: :u$t */
	0x2A,0x3A,0xD5,0x75,0xD0,0x40,0x25,0xFA,	/* 4D50: *:u@% */
	0xD1,0x70,0x74,0x61,0x2E,0x97,0x25,0xFA,	/* 4D58: pta.% */
	0xD0,0x60,0x4F,0xF4,0xC0,0x22,0xA2,0x41,	/* 4D60: `O"A */
	0x75,0x72,0x24,0xFF,0xF0,0xA5,0x24,0xF2,	/* 4D68: ur$$ */
	0xB3,0x22,0xF0,0x72,0x25,0xFA,0xD5,0xD0,	/* 4D70: "r% */
	0x40,0x25,0xFA,0xD1,0x70,0x74,0x61,0x2C,	/* 4D78: @%pta, */
	0x94,0x25,0xFA,0xD0,0x60,0x4F,0xF4,0x22,	/* 4D80: %`O" */
	0xA4,0x75,0x70,0xE1,0x74,0x2A,0x5D,0x25,	/* 4D88: upt*]% */
	0xFA,0xD2,0x31,0x25,0xFA,0x25,0xFA,0xD1,	/* 4D90: 1%% */
	0x31,0xF2,0x70,0xF4,0x21,0xA4,0x70,0x71,	/* 4D98: 1p!pq */
	0xE0,0x70,0x72,0xE1,0x72,0x30,0x72,0x31,	/* 4DA0: prr0r1 */
	0xE0,0x70,0xB3,0x22,0xF0,0x24,0xF2,0xB3,	/* 4DA8: p"$ */
	0x22,0xF0,0x75,0x71,0x31,0xF2,0x71,0xE1,	/* 4DB0: "uq1q */
	0x72,0x31,0xB3,0x22,0xF0,0x60,0xBB,0x40,	/* 4DB8: r1"`@ */
	0xD1,0x77,0x21,0xAB,0x77,0x52,0x60,0x4D,	/* 4DC0: w!wR`M */
	0xF4,0x60,0x4C,0x24,0xF6,0xD7,0x76,0x2A,	/* 4DC8: `L$v* */
	0x5D,0x25,0xFA,0xD2,0x30,0x25,0xFA,0xD3,	/* 4DD0: ]%0% */
	0x30,0xD0,0x71,0xC0,0x25,0xAB,0x05,0x24,	/* 4DD8: 0q%.$ */
	0xF2,0xB5,0x22,0xF0,0x70,0x72,0x30,0xF4,	/* 4DE0: "pr0 */
	0x23,0xAA,0x41,0x77,0x70,0x31,0x24,0xFF,	/* 4DE8: #Awp1$ */
	0xF0,0x22,0xAB,0x70,0x31,0x77,0xF4,0xAF,	/* 4DF0: "p1w */
	0x70,0x31,0x77,0xF4,0x70,0xE1,0x70,0x70,	/* 4DF8: p1wppp */
	0x31,0xF2,0xD0,0x77,0x70,0xE1,0x04,0x70,	/* 4E00: 1wp.p */
	0x30,0x73,0xE0,0x24,0xF2,0x81,0x70,0xE0,	/* 4E08: 0s$p */
	0x70,0x72,0x31,0xF4,0xC0,0xA3,0x73,0x72,	/* 4E10: pr1sr */
	0xE1,0x70,0x52,0xD4,0x41,0xD1,0x70,0xD3,	/* 4E18: pRAp */
	0x70,0x30,0xD0,0x0B,0x77,0x76,0x6E,0x99,	/* 4E20: p0.wvn */
	0x25,0xFA,0xD0,0x24,0xF2,0xF4,0xA5,0x71,	/* 4E28: %$q */
	0xC0,0xA7,0x64,0x00,0x24,0xF2,0xB5,0x22,	/* 4E30: d.$" */
	0xF0,0x74,0xB5,0x22,0xF0,0x60,0xBD,0x74,	/* 4E38: t"`t */
	0x2B,0x5D,0xD1,0x71,0x60,0x32,0xC0,0x21,	/* 4E40: +]q`2! */
	0xA1,0x71,0x61,0x3C,0x22,0xA8,0x40,0xD0,	/* 4E48: qa<"@ */
	0x71,0x61,0x39,0x71,0x61,0x38,0x74,0x62,	/* 4E50: qa9qa8tb */
	0x20,0x9B,0x71,0x61,0x3E,0xD0,0x71,0x60,	/* 4E58:  qa>q` */
	0x53,0x74,0x21,0x9B,0x75,0x74,0x6A,0x95,	/* 4E60: St!utj */
	0xD0,0x71,0x61,0x3F,0xD2,0x71,0x60,0x53,	/* 4E68: qa?q`S */
	0x74,0x9F,0x70,0xB3,0x22,0xF0,0x24,0xF2,	/* 4E70: tp"$ */
	0xB3,0x22,0xF0,0x7E,0xF6,0x7A,0xF6,0x74,	/* 4E78: "~zt */
	0xF6,0x76,0xF6,0x01,0x00,0x00,0x00,0x00,	/* 4E80: v..... */
	0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,	/* 4E88: ........ */
	0x20,0x0A,0x00,0x08,0x00,0x07,0x00,0x05,	/* 4E90:  ....... */
	0x00,0x04,0x00,0x02,0x00,0x01,0x00,0xFE,	/* 4E98: ....... */
	0x02,0x71,0x2B,0x5D,0xD2,0x62,0x4A,0x21,	/* 4EA0: .q+]bJ! */
	0xFB,0x72,0x4D,0x24,0xFA,0x72,0x62,0x4F,	/* 4EA8: rM$rbO */
	0x21,0xFB,0x47,0x62,0x26,0x9F,0x22,0xF0,	/* 4EB0: !Gb&" */
	0x20,0x20,0x60,0xBB,0x78,0xD0,0x77,0x11,	/* 4EB8:   `xw. */
	0x13,0x23,0x94,0x11,0x76,0x44,0x24,0xFA,	/* 4EC0: .#.vD$ */
	0xB5,0x22,0xF0,0x60,0xBB,0x77,0x30,0x77,	/* 4EC8: "`w0w */
	0x31,0x24,0xF2,0xF4,0x24,0xFB,0xC0,0x21,	/* 4ED0: 1$$! */
	0xA0,0x78,0x30,0x60,0x4F,0xF4,0x78,0x31,	/* 4ED8: x0`Ox1 */
	0x60,0x4F,0xF4,0x24,0xFB,0xC0,0xA2,0x21,	/* 4EE0: `O$! */
	0xF0,0x78,0xD0,0x77,0x13,0x11,0x98,0x11,	/* 4EE8: xw... */
	0x76,0x44,0x24,0xFA,0xB5,0x22,0xF0,0x60,	/* 4EF0: vD$"` */
	0xB4,0x40,0xDA,0x40,0xDB,0x24,0xF2,0x7F,	/* 4EF8: @@$ */
	0x31,0x24,0xF6,0x21,0xA3,0x41,0xDA,0x40,	/* 4F00: 1$!A@ */
	0x40,0x7F,0x30,0x24,0xFF,0xD8,0xD1,0x71,	/* 4F08: @0$q */
	0x40,0x7F,0x31,0x24,0xFF,0xD9,0xD1,0x08,	/* 4F10: @1$. */
	0x40,0xDA,0x7F,0x30,0xD8,0x7F,0x31,0xD9,	/* 4F18: @01 */
	0x24,0xF2,0x21,0x70,0x31,0x24,0xF6,0x21,	/* 4F20: $!p1$! */
	0xA6,0x7A,0xC0,0xDB,0x40,0x40,0x21,0x70,	/* 4F28: z@@!p */
	0x30,0x24,0xFF,0xD6,0xD1,0x71,0x40,0x21,	/* 4F30: 0$q@! */
	0x70,0x31,0x24,0xFF,0xD7,0xD1,0x0A,0x7A,	/* 4F38: p1$.z */
	0xDB,0x21,0x70,0x30,0xD6,0x21,0x70,0x31,	/* 4F40: !p0!p1 */
	0xD7,0x16,0xD0,0x18,0x12,0x14,0x22,0x9D,	/* 4F48: ...." */
	0x7B,0xAE,0x40,0x40,0x74,0x24,0xFF,0xD4,	/* 4F50: {@@t$ */
	0xD1,0x71,0x40,0x75,0x24,0xFF,0xD5,0xD1,	/* 4F58: q@u$ */
	0x7A,0xAE,0x40,0x40,0x72,0x24,0xFF,0xD2,	/* 4F60: z@@r$ */
	0xD1,0x71,0x40,0x73,0x24,0xFF,0xD3,0xD1,	/* 4F68: q@s$ */
	0x14,0x7D,0x44,0x24,0xFA,0x12,0x7E,0x44,	/* 4F70: .}D$.~D */
	0x24,0xFA,0xBC,0x22,0xF0,0x60,0xB6,0x7E,	/* 4F78: $"`~ */
	0x30,0xC0,0xA8,0x7E,0x31,0xC0,0xA4,0x21,	/* 4F80: 0~1! */
	0xF0,0x2B,0x0B,0x7E,0x31,0xC0,0x21,0xAA,	/* 4F88: +.~1! */
	0x40,0x7D,0x31,0x7E,0x30,0x21,0xFA,0x7B,	/* 4F90: @}1~0!{ */
	0xE1,0xD2,0x72,0x7D,0x30,0x7E,0x30,0x21,	/* 4F98: r}0~0! */
	0xFA,0x7B,0xE0,0x7C,0xE0,0x40,0x7C,0xE1,	/* 4FA0: {|@| */
	0x29,0x0C,0x7E,0x31,0x7E,0x30,0x21,0xF9,	/* 4FA8: ).~1~0! */
	0xD4,0xD5,0xD6,0x76,0xC0,0xAA,0x40,0xD3,	/* 4FB0: v@ */
	0x7D,0x31,0xD2,0x7D,0x30,0xD1,0x21,0x01,	/* 4FB8: }1}0!. */
	0x40,0x7D,0x31,0x76,0x23,0xF6,0xD0,0xD3,	/* 4FC0: @}1v# */
	0x7D,0x31,0x7D,0x30,0x76,0x23,0xF6,0xD1,	/* 4FC8: }1}0v# */
	0xD2,0x40,0x7B,0xE1,0x73,0x75,0xF4,0xC0,	/* 4FD0: @{su */
	0xA5,0x60,0x4F,0x7B,0xE0,0x08,0x73,0x72,	/* 4FD8: `O{.sr */
	0x75,0x21,0xFA,0x7B,0xE0,0xD0,0x7B,0x30,	/* 4FE0: u!{{0 */
	0x24,0xA9,0x40,0x74,0x7B,0x30,0x23,0xF1,	/* 4FE8: $@t{0# */
	0xD7,0xD8,0x78,0x75,0x7B,0x30,0x23,0xF1,	/* 4FF0: xu{0# */
	0xD8,0xD9,0x40,0x71,0x77,0x24,0xFF,0xD1,	/* 4FF8: @qw$ */
	0xD0,0x70,0x72,0x78,0x24,0xFF,0xD2,0xD0,	/* 5000: prx$ */
	0x70,0x73,0x79,0x24,0xFF,0xD3,0xD0,0x24,	/* 5008: psy$$ */
	0xF2,0x73,0x24,0xF6,0x21,0xAD,0x7B,0x30,	/* 5010: s$!{0 */
	0x60,0x8F,0x7B,0xE0,0x40,0x74,0x71,0x23,	/* 5018: `{@tq# */
	0xF7,0xD1,0xD0,0x70,0x75,0x72,0x23,0xF7,	/* 5020: pur# */
	0xD2,0xD0,0x70,0x40,0x73,0x23,0xF7,0xD3,	/* 5028: p@s# */
	0xD0,0x62,0x0C,0x76,0xC0,0xA7,0x71,0x7C,	/* 5030: b.vq| */
	0xE0,0x72,0x7C,0xE1,0x09,0x72,0x71,0x76,	/* 5038: r|.rqv */
	0x23,0xF5,0x7C,0xE0,0x7C,0xE1,0xBA,0x22,	/* 5040: #||" */
	0xF0,0x20,0x40,0xD3,0x71,0x31,0x72,0x31,	/* 5048:  @q1r1 */
	0xF4,0xC0,0xAF,0x24,0xF2,0x71,0x30,0x23,	/* 5050: $q0# */
	0xF3,0x24,0xF2,0x72,0x30,0x23,0xF3,0xF9,	/* 5058: $r0# */
	0xD3,0x06,0x71,0x31,0x72,0x31,0xF9,0xD3,	/* 5060: .q1r1 */
	0x73,0x22,0xF0,0x60,0xBE,0x74,0xD1,0x76,	/* 5068: s"`tv */
	0x25,0xA0,0x41,0x21,0x40,0x76,0x24,0xFF,	/* 5070: %A!@v$ */
	0xF0,0xA4,0x21,0x40,0xD3,0x02,0x76,0xD3,	/* 5078: !@.v */
	0x40,0xD0,0x73,0x40,0xF9,0x21,0xA0,0x75,	/* 5080: @s@!u */
	0x70,0x74,0xF2,0x23,0xFB,0x70,0x81,0xD0,	/* 5088: pt#p */
	0x73,0x70,0xF9,0xA3,0x20,0x60,0x00,0x73,	/* 5090: sp `.s */
	0xD5,0x76,0x73,0xF4,0xD6,0x76,0x22,0xA2,	/* 5098: vsv" */
	0x41,0x75,0x76,0x24,0xFF,0xF0,0xA5,0x20,	/* 50A0: Auv$  */
	0x75,0xD3,0x03,0x20,0x76,0xD3,0x74,0x75,	/* 50A8: u. vtu */
	0x74,0xF2,0x73,0x24,0xFA,0x73,0x75,0xF5,	/* 50B0: ts$su */
	0xD5,0x76,0x73,0xF4,0xD6,0x76,0xA3,0x20,	/* 50B8: vsv  */
	0x62,0x0E,0x71,0xB2,0x22,0xF0,0x20,0x70,	/* 50C0: b.q" p */
	0x72,0xE0,0x10,0x72,0xE1,0x40,0x22,0xF0,	/* 50C8: r.r@" */
	0x72,0x30,0x72,0x31,0xE0,0x73,0xC0,0xA2,	/* 50D0: r0r1s */
	0x41,0xD3,0x73,0x72,0x31,0xE1,0x72,0x31,	/* 50D8: Asr1r1 */
	0x23,0xFC,0x71,0x22,0xF0,0x22,0xF9,0x72,	/* 50E0: #q""r */
	0x31,0xF6,0x22,0xF0,0x22,0xF9,0x72,0x31,	/* 50E8: 1""r1 */
	0xF6,0x22,0xF0,0x40,0x40,0x60,0xBB,0x73,	/* 50F0: "@@`s */
	0x36,0x73,0x34,0x60,0xEF,0x10,0x73,0x57,	/* 50F8: 6s4`.sW */
	0x41,0xFB,0x21,0xF5,0x20,0x60,0xBF,0x73,	/* 5100: A! `s */
	0x57,0x21,0xF2,0xD0,0x70,0x24,0xF2,0xF4,	/* 5108: W!p$ */
	0xA4,0x40,0xB1,0x22,0xF0,0x41,0xB1,0x22,	/* 5110: @"A" */
	0xF0,0x72,0x71,0x61,0x98,0xA5,0x41,0x4B,	/* 5118: rqaAK */
	0x71,0x28,0x9E,0x63,0x4E,0x21,0xFB,0x72,	/* 5120: q(cN!r */
	0x34,0xE0,0x70,0x72,0xE1,0x72,0x34,0x21,	/* 5128: 4prr4! */
	0xFE,0x24,0xFB,0x23,0xF9,0x22,0xF0,0x72,	/* 5130: $#"r */
	0x71,0x63,0x9A,0xA5,0x41,0x4B,0x71,0x27,	/* 5138: qcAKq' */
	0x90,0x64,0x40,0x21,0xFB,0x72,0x34,0xE0,	/* 5140: d@!r4 */
	0x70,0x72,0xE1,0x72,0x34,0x60,0x4E,0x24,	/* 5148: prr4`N$ */
	0xF6,0x23,0xF9,0x22,0xF0,0x72,0x71,0x65,	/* 5150: #"rqe */
	0x9C,0xA5,0x41,0x4B,0x71,0x25,0x92,0x66,	/* 5158: AKq%f */
	0x42,0x21,0xFB,0x72,0x34,0xE0,0x70,0x72,	/* 5160: B!r4pr */
	0xE1,0x72,0x34,0x41,0x24,0xFB,0x23,0xF9,	/* 5168: r4A$# */
	0x22,0xF0,0x20,0x72,0xA5,0x72,0x71,0x29,	/* 5170: " rrq) */
	0xED,0x07,0x22,0x27,0x20,0x4F,0x71,0x29,	/* 5178: ."' Oq) */
	0xED,0x72,0x71,0x29,0x5B,0xD2,0xD3,0x6B,	/* 5180: rq)[k */
	0x07,0x71,0x2C,0x38,0x24,0xF2,0xF4,0xA6,	/* 5188: .q,8$ */
	0x71,0x2C,0x38,0xD3,0x71,0x92,0x62,0x0B,	/* 5190: q,8qb. */
	0x77,0xF6,0x20,0x00,0x00,0x00,0x00,0x71,	/* 5198: w ....q */
	0x2C,0x58,0xD2,0x72,0x60,0x43,0x21,0xFB,	/* 51A0: ,Xr`C! */
	0x41,0x65,0x27,0x99,0x22,0xF0,0x20,0x21,	/* 51A8: Ae'" ! */
	0x02,0x60,0xBE,0x24,0xF2,0xD0,0x75,0xD1,	/* 51B0: .`$u */
	0x24,0xF2,0x24,0xF2,0x73,0x60,0x90,0xB2,	/* 51B8: $$s` */
	0x22,0xF0,0x20,0x25,0xF8,0x21,0xF0,0x22,	/* 51C0: " %!" */
	0xF0,0x60,0xBA,0x40,0x21,0xFE,0xF4,0x21,	/* 51C8: `@!! */
	0xAE,0x24,0xF2,0xD4,0x10,0xD5,0x4B,0x21,	/* 51D0: $.K! */
	0xFB,0xD2,0x40,0x13,0x25,0xF2,0x23,0xF9,	/* 51D8: @.%# */
	0x10,0x14,0x41,0xFB,0x24,0xF3,0x11,0x41,	/* 51E0: ..A$.A */
	0x24,0xF8,0x24,0xF4,0x72,0x23,0xFC,0x79,	/* 51E8: $$r#y */
	0x7C,0x33,0xF2,0x7C,0xE3,0x77,0x7C,0xE6,	/* 51F0: |3|w| */
	0x78,0x7C,0xE7,0x40,0xD4,0x42,0xD5,0x74,	/* 51F8: x|@Bt */
	0xC0,0xA4,0x7C,0x39,0xD1,0x03,0x7C,0x3A,	/* 5200: |9.|: */
	0xD1,0x71,0x7A,0xF9,0x25,0xAB,0x24,0xF2,	/* 5208: qz%$ */
	0x71,0x23,0xF3,0xD0,0x70,0x41,0x24,0xF0,	/* 5210: q#pA$ */
	0xD2,0x72,0x24,0xF2,0xFA,0xD0,0x79,0x70,	/* 5218: r$yp */
	0x33,0xF2,0x70,0xE3,0x79,0x70,0x34,0xF2,	/* 5220: 3pyp4 */
	0x70,0xE4,0x74,0x23,0xA5,0x22,0x40,0x70,	/* 5228: pt#"@p */
	0x31,0x24,0xF6,0xC0,0x22,0xAC,0x42,0x70,	/* 5230: 1$"Bp */
	0x31,0x24,0xF6,0x21,0xA4,0x70,0x37,0x4A,	/* 5238: 1$!p7J */
	0x21,0xFB,0xF0,0xE0,0x70,0x34,0x70,0x37,	/* 5240: !p4p7 */
	0x23,0xFC,0xD4,0xF6,0x70,0x23,0xFC,0x21,	/* 5248: #p#! */
	0x01,0x70,0x34,0x70,0x37,0x60,0xEF,0x41,	/* 5250: .p4p7`A */
	0x70,0x31,0x24,0xF6,0xC0,0x70,0x37,0xF2,	/* 5258: p1$p7 */
	0x23,0xF9,0x70,0x3E,0xD3,0x73,0xD1,0x65,	/* 5260: #p>se */
	0x00,0x14,0x26,0x4F,0x22,0xF1,0x21,0xF5,	/* 5268: ..&O"! */
	0xB6,0x22,0xF0,0x20,0x60,0xBA,0x77,0x3F,	/* 5270: " `w? */
	0xD0,0x24,0xF2,0x70,0x23,0xF3,0xD1,0x71,	/* 5278: $p#q */
	0x41,0x24,0xF0,0xD5,0x75,0x24,0xF2,0xFA,	/* 5280: A$u$ */
	0xD4,0x74,0x39,0xD1,0x71,0x74,0x34,0xF9,	/* 5288: t9qt4 */
	0x24,0xAC,0x24,0xF2,0x71,0x23,0xF3,0xD0,	/* 5290: $$q# */
	0x70,0x41,0x24,0xF0,0xD2,0x72,0x24,0xF2,	/* 5298: pA$r$ */
	0xFA,0xD0,0x22,0x40,0x70,0x31,0x24,0xF6,	/* 52A0: "@p1$ */
	0xC0,0x22,0xAC,0x42,0x70,0x31,0x24,0xF6,	/* 52A8: "Bp1$ */
	0x21,0xA4,0x70,0x37,0x4A,0x21,0xFB,0xF0,	/* 52B0: !p7J! */
	0xE0,0x70,0x34,0x70,0x37,0x23,0xFC,0xD4,	/* 52B8: p4p7# */
	0xF6,0x70,0x23,0xFC,0x21,0x01,0x70,0x34,	/* 52C0: p#!.p4 */
	0x70,0x37,0x60,0xEF,0x41,0x70,0x31,0x24,	/* 52C8: p7`Ap1$ */
	0xF6,0xC0,0x70,0x37,0xF2,0x23,0xF9,0x70,	/* 52D0: p7#p */
	0x3E,0xD3,0x73,0xD1,0x65,0x0E,0xB6,0x22,	/* 52D8: >se." */
	0xF0,0x20,0x20,0x65,0x2D,0x25,0x04,0x20,	/* 52E0:   e-%.  */
	0x20,0x60,0x08                          	/* 52E8:  `.      */

};
int si3_t225_dsize = sizeof(si3_t225_download);		/* 0x52EB (21227) */

unsigned short si3_t225_downloadaddr = 0x0000;

/* End of SI3_T225.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\spxutils.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_UTILS.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Utility functions.													*
*																						*
****************************************************************************************/

#define FILE_ID	SPX_UTILS_C		// File ID for Event Logging see SPX_DEFS.H for values.

// Paging...  
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_InitMultiString)
#pragma alloc_text (PAGE, Spx_GetRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_PutRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_LogMessage)
#pragma alloc_text (PAGE, Spx_LogError)
#pragma alloc_text (PAGE, Spx_MemCompare)
#endif


/////////////////////////////////////////////////////////////////////////////////////////
//	
//	Description:
//
//		This routine will take a null terminated list of ascii strings and combine
//		them together to generate a unicode multi-string block
//
//	Arguments:
//
//		Multi		- TRUE if a MULTI_SZ list is required, FALSE for a simple UNICODE
//
//		MultiString - a unicode structure in which a multi-string will be built
//		...         - a null terminated list of narrow strings which will be
//			       combined together. This list must contain at least a trailing NULL
//
//	Return Value:
//
//		NTSTATUS
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...)
{

	ANSI_STRING ansiString;
	NTSTATUS status;
	PCSTR rawString;
	PWSTR unicodeLocation;
	ULONG multiLength = 0;
	UNICODE_STRING unicodeString;
	va_list ap;
	ULONG i;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	va_start(ap,MultiString);
  
	// Make sure that we won't leak memory
	ASSERT(MultiString->Buffer == NULL);

	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{
		RtlInitAnsiString(&ansiString, rawString);
		multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
		rawString = va_arg(ap, PCSTR);
	}

	va_end( ap );

	if (multiLength == 0) 
	{
		// Done
		RtlInitUnicodeString(MultiString, NULL);
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (1)\n", PRODUCT_NAME));

		return STATUS_SUCCESS;
	}

	

	if(multi)
		multiLength += sizeof(WCHAR);	// We need an extra null if we want a MULTI_SZ list


	MultiString->MaximumLength = (USHORT)multiLength;
	MultiString->Buffer = SpxAllocateMem(PagedPool, multiLength);
	MultiString->Length = 0;

	if (MultiString->Buffer == NULL) 
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (2) - FAILURE\n", PRODUCT_NAME));

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	SpxDbgMsg(SPX_MISC_DBG, ("%s: Allocated %lu bytes for buffer\n", PRODUCT_NAME, multiLength));

#if DBG
	RtlFillMemory(MultiString->Buffer, multiLength, 0xff);
#endif

	unicodeString.Buffer = MultiString->Buffer;
	unicodeString.MaximumLength = (USHORT) multiLength;

	va_start(ap, MultiString);
	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{

		RtlInitAnsiString(&ansiString,rawString);
		status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);

		// We don't allocate memory, so if something goes wrong here,
		// its the function that's at fault
		ASSERT(SPX_SUCCESS(status));

		// Check for any commas and replace them with NULLs
		ASSERT(unicodeString.Length % sizeof(WCHAR) == 0);

		for (i = 0; i < (unicodeString.Length / sizeof(WCHAR)); i++) 
		{
			if (unicodeString.Buffer[i] == L'\x2C' || unicodeString.Buffer[i] == L'\x0C' ) 
			{
				unicodeString.Buffer[i] = L'\0'; 
			}
		}


		SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer: %ws\n", PRODUCT_NAME, unicodeString.Buffer));

		// Move the buffers along
		unicodeString.Buffer += ((unicodeString.Length / sizeof(WCHAR)) + 1);
		unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
		unicodeString.Length = 0;

		// Next
		rawString = va_arg(ap, PCSTR);

	} // while

	va_end(ap);

	if(multi)
	{
		ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));
	}
	else
	{
		ASSERT(unicodeString.MaximumLength == 0);
	}


	// Stick the final null there
 	SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer last addr: 0x%X\n", PRODUCT_NAME, unicodeString.Buffer));

	if(multi)
		unicodeString.Buffer[0] = L'\0'; 		// We need an extra null if we want a MULTI_SZ list


	MultiString->Length = (USHORT)multiLength - sizeof(WCHAR);
	MultiString->MaximumLength = (USHORT)multiLength;

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (3) - SUCCESS\n", PRODUCT_NAME));

	return STATUS_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:	
//		Reads a registry key value from an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		KeyNameString       ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//
//		Data                Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	)

{

	UNICODE_STRING              keyName;
	ULONG                       length;
	PKEY_VALUE_FULL_INFORMATION fullInfo;

	NTSTATUS                    status = STATUS_INSUFFICIENT_RESOURCES;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Enter Spx_GetRegistryKeyValue\n", PRODUCT_NAME));


	RtlInitUnicodeString (&keyName, KeyNameString);

	length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength + DataLength;
	fullInfo = SpxAllocateMem(PagedPool, length); 

	if(fullInfo) 
	{
		status = ZwQueryValueKey(	Handle,
									&keyName,
									KeyValueFullInformation,
									fullInfo,
									length,
									&length);

		if(SPX_SUCCESS(status)) 
		{
			// If there is enough room in the data buffer, copy the output
			if(DataLength >= fullInfo->DataLength) 
				RtlCopyMemory (Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, fullInfo->DataLength);
		}

		SpxFreeMem(fullInfo);
	}

	return status;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//
//		Writes a registry key value to an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		PKeyNameString      ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//    
//		Dtype				REG_XYZ value type
//
//		PData               Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	)
{

	NTSTATUS status;
	UNICODE_STRING keyname;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Enter Spx_PutRegistryKeyValue\n", PRODUCT_NAME));

	RtlInitUnicodeString(&keyname, NULL);
	keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
	keyname.Buffer = SpxAllocateMem(PagedPool, keyname.MaximumLength);

	if(keyname.Buffer == NULL) 
		  return STATUS_INSUFFICIENT_RESOURCES;

	RtlAppendUnicodeToString(&keyname, PKeyNameString);

	status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

	SpxFreeMem(keyname.Buffer);

	return status;
}




VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp)	// Limited to 51 characters + 1 null
{
	
	UNICODE_STRING ErrorMsg;

	ErrorMsg.Length = 0;
	ErrorMsg.Buffer = 0;
	Spx_InitMultiString(FALSE, &ErrorMsg, szTemp, NULL);


	switch(MessageSeverity)
	{
	case STATUS_SEVERITY_SUCCESS:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_SUCCESS,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;
	
	case STATUS_SEVERITY_INFORMATIONAL:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_INFORMATIONAL,			// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_WARNING:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_WARNING,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_ERROR:
	default:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_ERROR,					// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	}

	if(ErrorMsg.Buffer != NULL)
		SpxFreeMem(ErrorMsg.Buffer);

}

/////////////////////////////////////////////////////////////////////////////////////////
//																
//	Spx_LogError														
//															
/////////////////////////////////////////////////////////////////////////////////////////
/*
	Routine Description:

		This routine allocates an error log entry, copies the supplied data
		to it, and requests that it be written to the error log file.

	Arguments:

		DriverObject - A pointer to the driver object for the device.

		DeviceObject - A pointer to the device object associated with the
		device that had the error, early in initialization, one may not
		yet exist.

		P1,P2 - If phyical addresses for the controller ports involved
		with the error are available, put them through as dump data.

		SequenceNumber - A ulong value that is unique to an IRP over the
		life of the irp in this driver - 0 generally means an error not
		associated with an irp.

		MajorFunctionCode - If there is an error associated with the irp,
		this is the major function code of that irp.

		RetryCount - The number of times a particular operation has been retried.

		UniqueErrorValue - A unique long word that identifies the particular
		call to this function.

		FinalStatus - The final status given to the irp that was associated
		with this error.  If this log entry is being made during one of
		the retries this value will be STATUS_SUCCESS.

		SpecificIOStatus - The IO status for a particular error.

		LengthOfInsert1 - The length in bytes (including the terminating NULL)
						  of the first insertion string.

		Insert1 - The first insertion string.

		LengthOfInsert2 - The length in bytes (including the terminating NULL)
						  of the second insertion string.  NOTE, there must
						  be a first insertion string for their to be
						  a second insertion string.

		Insert2 - The second insertion string.

	Return Value:	None.
*/


VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	)
{

	PIO_ERROR_LOG_PACKET ErrorLogEntry;

	PVOID objectToUse;
	SHORT dumpToAllocate = 0;
	PUCHAR ptrToFirstInsert;
	PUCHAR ptrToSecondInsert;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(Insert1 == NULL) 
		LengthOfInsert1 = 0;

	if(Insert2 == NULL) 
		LengthOfInsert2 = 0;


	if(ARGUMENT_PRESENT(DeviceObject)) 
		objectToUse = DeviceObject;
	else 
		objectToUse = DriverObject;


	if(Spx_MemCompare(P1, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	if(Spx_MemCompare(P2, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	ErrorLogEntry = IoAllocateErrorLogEntry(objectToUse,
											(UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + dumpToAllocate 
											+ LengthOfInsert1 + LengthOfInsert2)	
											);

	if(ErrorLogEntry != NULL) 
	{
		ErrorLogEntry->ErrorCode			= SpecificIOStatus;
		ErrorLogEntry->SequenceNumber		= SequenceNumber;
		ErrorLogEntry->MajorFunctionCode	= MajorFunctionCode;
		ErrorLogEntry->RetryCount			= RetryCount;
		ErrorLogEntry->UniqueErrorValue		= UniqueErrorValue;
		ErrorLogEntry->FinalStatus			= FinalStatus;
		ErrorLogEntry->DumpDataSize			= dumpToAllocate;

		
		if(dumpToAllocate) 
		{
			RtlCopyMemory(&ErrorLogEntry->DumpData[0], &P1,	sizeof(PHYSICAL_ADDRESS));

			if(dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) 
			{
				RtlCopyMemory(	((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS),
								&P2,
								sizeof(PHYSICAL_ADDRESS)
								);

				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + (2*sizeof(PHYSICAL_ADDRESS));

			} 
			else 
			{
				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS);
			}

		} 
		else 
		{
			ptrToFirstInsert = (PUCHAR)&ErrorLogEntry->DumpData[0];
		}

		ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

		if(LengthOfInsert1) 
		{
			ErrorLogEntry->NumberOfStrings	= 1;
			ErrorLogEntry->StringOffset		= (USHORT)(ptrToFirstInsert - (PUCHAR)ErrorLogEntry);

			RtlCopyMemory(ptrToFirstInsert, Insert1, LengthOfInsert1);

			if(LengthOfInsert2) 
			{
				ErrorLogEntry->NumberOfStrings = 2;
				RtlCopyMemory(ptrToSecondInsert, Insert2, LengthOfInsert2);
			}
		}


		IoWriteErrorLogEntry(ErrorLogEntry);

	}

}



SPX_MEM_COMPARES
Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB)
/*++
Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.
--*/
{
	LARGE_INTEGER a;
	LARGE_INTEGER b;

	LARGE_INTEGER lower;
	ULONG lowerSpan;
	LARGE_INTEGER higher;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	a = A;
	b = B;

	if(a.QuadPart == b.QuadPart) 
	  return AddressesAreEqual;


	if(a.QuadPart > b.QuadPart) 
	{
		higher = a;
		lower = b;
		lowerSpan = SpanOfB;
	} 
	else 
	{
		higher = b;
		lower = a;
		lowerSpan = SpanOfA;
	}

	if((higher.QuadPart - lower.QuadPart) >= lowerSpan)
      return AddressesAreDisjoint;


	return AddressesOverlap;
}


NTSTATUS
PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard)
{
	/******************************************************** 
	* Setting bit 17 in the CNTRL register of the PLX 9050	* 
	* chip forces a retry on writes while a read is pending.*
	* This is to prevent the card locking up on Intel Xeon  *
	* multiprocessor systems with the NX chipset.			*
	********************************************************/

	#define CNTRL_REG_OFFSET	0x14	// DWORD Offset (BYTE Offset 0x50) 
	
	NTSTATUS	status = STATUS_SUCCESS;
	PULONG		pPCIConfigRegisters = NULL;			// Pointer to PCI Config Registers.
	CHAR		szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering PLX_9050_CNTRL_REG_FIX for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	pPCIConfigRegisters = MmMapIoSpace(pCard->PCIConfigRegisters, pCard->SpanOfPCIConfigRegisters, FALSE);

	if(pPCIConfigRegisters != NULL)
	{
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */

		if(pPCIConfigRegisters[CNTRL_REG_OFFSET] == 0)	// If bit 7 is set Config Registers are zero (unreadable) 
		{
			// We have to blindly write the value to the register.
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;	// Set bits 17 & 21 of PLX CNTRL register 
		}
		else
		{	
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 1] &= ~0x40;		// Clear bit 14 of PLX CNTRL register
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;		// Set bits 17 & 21 of PLX CNTRL register
		}

		MmUnmapIoSpace(pPCIConfigRegisters, pCard->SpanOfPCIConfigRegisters);
	}
	else
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Insufficient resources available for Card %d.\n", 
			PRODUCT_NAME, pCard->CardNumber));
	
		sprintf(szErrorMsg, "Card at %08X%08X: Insufficient resources.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	return status;
}


//
// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	

	if(Set) 
		pDevExt->PnpPowerFlags |= Value;			
	else 
		pDevExt->PnpPowerFlags &= ~Value;	

	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->StalledIrpLock, &oldIrql);	

	pDevExt->UnstallingFlag = Set;			

	KeReleaseSpinLock(&pDevExt->StalledIrpLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
BOOLEAN
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll)
{
	KIRQL oldIrql;
	BOOLEAN bRet = FALSE; 

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	
	
	if(bAll)
	{
		// If all the requested SetFlags are set
		// and if all of the requested ClearedFlags are cleared then return true.
		if(((ulSetFlags & pDevExt->PnpPowerFlags) == ulSetFlags) && !(ulClearedFlags & pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}
	else
	{
		// If any of the requested SetFlags are set 
		// or if any of the requested ClearedFlags are cleared then return true.
		if((ulSetFlags & pDevExt->PnpPowerFlags) || (ulClearedFlags & ~pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}


	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);
	
	return bRet;
}




PVOID 
SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 

	pRet = ExAllocatePoolWithTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


PVOID 
SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 
	
	pRet = ExAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


#ifndef BUILD_SPXMINIPORT
void
SpxFreeMem(PVOID pMem)
{
	ASSERT(pMem != NULL);	// Assert if the pointer is NULL.

	ExFreePool(pMem);
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////
// Must be called just before an IoCompleteRequest if IrpCondition == IRP_SUBMITTED
//
///////////////////////////////////////////////////////////////////////////////////////////
VOID
SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition)
{
	PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	switch(pIrpStack->MajorFunction)		// Don't filter Plug and Play IRPs 
	{

	case IRP_MJ_FLUSH_BUFFERS:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.FlushIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.FlushIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.FlushIrpsQueued);
				pPort->PerfStats.FlushIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.FlushIrpsQueued);
				if(pPort->PerfStats.FlushIrpsQueued) 
					pPort->PerfStats.FlushIrpsQueued--;		// Decrement counter for performance stats.

				break;


			default:
				break;
			}

			break;
		}


	case IRP_MJ_WRITE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.WriteIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.WriteIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.WriteIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.WriteIrpsQueued);
				pPort->PerfStats.WriteIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.WriteIrpsQueued);
				if(pPort->PerfStats.WriteIrpsQueued) 
					pPort->PerfStats.WriteIrpsQueued--;		// Decrement counter for performance stats.

				break;

			default:
				break;
			}

			break;
		}

	case IRP_MJ_READ:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.ReadIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.ReadIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.ReadIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.ReadIrpsQueued);
				pPort->PerfStats.ReadIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.ReadIrpsQueued);
				if(pPort->PerfStats.ReadIrpsQueued) 
					pPort->PerfStats.ReadIrpsQueued--;		// Decrement counter for performance stats.
				
				break;


			default:
				break;
			}

			break;
		}

	case IRP_MJ_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.IoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.IoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_INTERNAL_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InternalIoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InternalIoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}


	case IRP_MJ_CREATE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CreateIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CreateIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLOSE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CloseIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CloseIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLEANUP:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CleanUpIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CleanUpIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_QUERY_INFORMATION:
	case IRP_MJ_SET_INFORMATION:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InfoIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InfoIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}
	
	default:
		break;

	}
}


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    clear the perf stats.
//
// Arguments:
//    pPort - Pointer to a the Port Device Extension.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
{
    RtlZeroMemory(&pPort->PerfStats, sizeof(PORT_PERFORMANCE_STATS));

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\slxos_nt.c ===
/*

    #########     ##              ##        ##      ########        #########
   ##########     ##              ##        ##     ##########      ##########
  ##              ##                ##    ##      ##        ##    ##
  ##              ##                ##    ##      ##        ##    ##
   #########      ##                  ####        ##        ##     #########
    #########     ##                  ####        ##        ##      #########
            ##    ##                  ####        ##        ##              ##
            ##    ##                  ####        ##        ##              ##
  ##        ##    ##                ##    ##      ##        ##    ##        ##
  ##        ##    ##                ##    ##      ##        ##    ##        ##
   ##########     ############    ##        ##     ##########      ##########
    ########      ############    ##        ##      ########        ########

      SI Intelligent I/O Board driver
      Copyright (c) Specialix International 1993
*/

#include "precomp.h"			/* Precompiled Headers */

//
// The SI family of serial controllers claim to provide the functionality
// of a Data Communications Equipment (DCE).  Unfortunately, the serial
// chips used in the Terminal Adapters (TAs) are designed for use as Data
// Terminal Equipments (DTEs).  In practice, this means that the board is
// really a DTE with three pairs of signals swapped - Rx/Tx, DTR/DSR, and
// CTS/RTS.  The NT serial driver is for a DTE, so it can be supported.
// The only problem is that the names of the control functions for the SI
// board assume that the board is a DCE, so top-level calls which try to
// set (say) DTR must set bits in the hardware which claim to set DSR (but
// which really set DTR anyway).
//

/*************************************************************************\
*                                                                         *
* Internal Functions                                                      *
*                                                                         *
\*************************************************************************/

int		slxos_init(IN PCARD_DEVICE_EXTENSION pCard);
BOOLEAN slxos_txint(IN PPORT_DEVICE_EXTENSION pPort);
void	slxos_rxint(IN PPORT_DEVICE_EXTENSION pPort);
void	slxos_mint(IN PPORT_DEVICE_EXTENSION pPort);

BOOLEAN SendTxChar(IN PPORT_DEVICE_EXTENSION pPort);
VOID	PutReceivedChar(IN PPORT_DEVICE_EXTENSION pPort);
BOOLEAN	ExceptionHandle(IN PPORT_DEVICE_EXTENSION pPort, IN UCHAR State);

ULONG	CopyCharsToTxBuffer(IN PPORT_DEVICE_EXTENSION pPort, 
							IN PUCHAR InputBuffer, 
							IN ULONG InputBufferLength);




/*************************************************************************\
*                                                                         *
* BOOLEAN Slxos_Present(IN PVOID Context)                                 *
*                                                                         *
* Check for an SI family board at given address                           *
\*************************************************************************/
BOOLEAN Slxos_Present(IN PVOID Context)
{
    PCARD_DEVICE_EXTENSION pCard = Context;
    PUCHAR addr = pCard->Controller;
    USHORT offset;
    UCHAR pos;
    ULONG Si_2BaseAddress[] = {
        0xc0000,
        0xc8000,
        0xd0000,
        0xd8000,
        0xdc0000,
        0xdc8000,
        0xdd0000,
        0xdd8000
        };

    SpxDbgMsg(SERDIAG1, ("%s: In Slxos_Present: CardType: %d\n", PRODUCT_NAME, pCard->CardType));
        

    switch (pCard->CardType) 
	{
    case SiHost_1:
		{
			addr[0x8000] = 0;
            
			for (offset = 0; offset < 0x8000; offset++) 
				addr[offset] = 0;

            
			for (offset = 0; offset < 0x8000; offset++) 
			{
				if (addr[offset] != 0) 
					return FALSE;
			}
            
			for (offset = 0; offset < 0x8000; offset++) 
				addr[offset] = 0xff;

            
			for (offset = 0; offset < 0x8000; offset++) 
			{
				if (addr[offset] != 0xff) 
					return FALSE;
			}
            
			return TRUE;
		}

	case SiHost_2:
		{
			BOOLEAN FoundBoard;
			PUCHAR	cp;

/* Host2 ISA board... */

			FoundBoard = TRUE;		/* Assume TRUE */
			
			for(offset=SI2_ISA_ID_BASE; offset<SI2_ISA_ID_BASE+8; offset++)
			{
				if((addr[offset]&0x7) != ((UCHAR)(~offset)&0x7)) 
					FoundBoard = FALSE;
			}

			if(FoundBoard) 
				return(TRUE);

/* Jet ISA board... */

			FoundBoard = TRUE;			/* Assume TRUE */
			offset = SX_VPD_ROM+0x20;	/* Address of ROM message */

			for(cp = "JET HOST BY KEV#";*cp != '\0';++cp)
			{
				if(addr[offset] != *cp) FoundBoard = FALSE;
				offset += 2;
			}

			if((addr[SX_VPD_ROM+0x0E]&0xF0) != 0x20) 
				FoundBoard = FALSE;

			if(FoundBoard)
			{
				pCard->CardType = Si3Isa;		/* Alter controller type */
				return(TRUE);
			}

			break;
		}

	case Si_2:
		{
            SpxDbgMsg(SERDIAG1, ("Si_2 card at slot %d?\n", pCard->SlotNumber));
                
                
            WRITE_PORT_UCHAR((PUCHAR)0x96, (UCHAR)((pCard->SlotNumber-1) | 8));

            if (READ_PORT_UCHAR((PUCHAR)0x101) == 0x6b 
			&& READ_PORT_UCHAR((PUCHAR)0x100) == 0x9b) 
			{
                pos = READ_PORT_UCHAR((PUCHAR)0x102);
                pCard->PhysAddr.LowPart = Si_2BaseAddress[(pos >> 4) & 7];
                pCard->OriginalVector = (pos & 0x80) == 0 ? 5 : 9;
                WRITE_PORT_UCHAR((PUCHAR)0x96, 0);

                return TRUE;
            }

            WRITE_PORT_UCHAR((PUCHAR)0x96, 0);

            return FALSE;
		}

#define INBZ(port) \
    READ_PORT_UCHAR((PUCHAR)((pCard->SlotNumber << 12) | port))
        
	case SiEisa:
	case Si3Eisa:
		{
			unsigned int id, rev;
			BOOLEAN	FoundBoard;
			PUCHAR	cp;

			id = INBZ(SI2_EISA_ID_HI) << 16;			/* Read board ID and revision */
			id |= INBZ(SI2_EISA_ID_MI) << 8;
			id |= INBZ(SI2_EISA_ID_LO);
			rev = INBZ(SI2_EISA_ID_REV);

			if(id == SI2_EISA_ID)
			{
				pCard->PhysAddr.LowPart = (INBZ(SI2_EISA_ADDR_HI)<<24) + (INBZ(SI2_EISA_ADDR_LO)<<16);
				pCard->OriginalVector = ((INBZ(SI2_EISA_IVEC)&SI2_EISA_IVEC_MASK)>>4);

				if(rev < 0x20) 
					return(TRUE);		/* Found SiEisa board */

				pCard->CardType = Si3Eisa;	/* Assume Si3Eisa board */
				FoundBoard = TRUE;			/* Assume TRUE */

				if(addr)				/* Check if address valid */
				{
					offset = SX_VPD_ROM+0x20;	/* Address of ROM message */

					for(cp = "JET HOST BY KEV#";*cp != '\0';++cp)
					{
						if(addr[offset] != *cp) 
							FoundBoard = FALSE;

						offset += 2;
					}

					if((addr[SX_VPD_ROM+0x0E]&0xF0) != 0x70) 
						FoundBoard = FALSE;
				}

				if(FoundBoard) 
					return(TRUE);		/* Found Si3Eisa board */
			}

			break;
		}
#undef INBZ

	case Si3Pci:
		{
			BOOLEAN	FoundBoard;
			PUCHAR	cp;

			FoundBoard = TRUE;			/* Assume TRUE */

			if(addr)				/* Check if address valid */
			{
				offset = SX_VPD_ROM+0x20;	/* Address of ROM message */

				for(cp = "JET HOST BY KEV#";*cp != '\0';++cp)
				{
					if(addr[offset] != *cp) 
						FoundBoard = FALSE;

					offset += 2;
				}

				if((addr[SX_VPD_ROM+0x0E]&0xF0) != 0x50) 
					FoundBoard = FALSE;
			}

			if(FoundBoard) 
				return(TRUE);		/* Found Si3Pci board */

			break;
		}

        
	case SiPCI:
	case SxPlusPci:
		return TRUE;			/* Already found by NT */

	default:
		break;
    }

    return FALSE;

}

/*************************************************************************\
*                                                                         *
* BOOLEAN Slxos_ResetBoard(IN PVOID Context)                              *
*                                                                         *
* Set interrupt vector for card and initialize.                           *
*                                                                         *
\*************************************************************************/
int Slxos_ResetBoard(IN PVOID Context)
{
    PCARD_DEVICE_EXTENSION pCard = Context;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_ResetBoard for %x.\n", PRODUCT_NAME, pCard->Controller));
 
	return(slxos_init(pCard));
}

/***************************************************************************\
*                                                                           *
* VOID slxos_init(IN PCARD_DEVICE_EXTENSION pCard)                       *
*                                                                           *
* Initialise routine, called once at system startup.                        *
*                                                                           *
\***************************************************************************/
int slxos_init(IN PCARD_DEVICE_EXTENSION pCard)
{
    volatile PUCHAR addr = pCard->Controller;
    USHORT offset;
    UCHAR c;
    ULONG numberOfPorts;
    ULONG numberOfPortsThisModule;
    BOOLEAN lastModule;
    ULONG channel;
    ULONG port;
    LARGE_INTEGER delay;
    
	int SXDCs=0;
	int OTHERs=0;

    SpxDbgMsg(SERDIAG1, ("%s: slxos_init for %x.\n", PRODUCT_NAME, pCard->Controller));
        
    switch (pCard->CardType) 
	{
        
	case SiHost_1:
		{
            addr[0x8000] = 0;
            addr[0xa000] = 0;

            for (offset = 0; offset < si2_z280_dsize; offset++) 
                addr[offset] = si2_z280_download[offset];

            addr[0xc000] = 0;
            addr[0xe000] = 0;
            break;
		}
    
	case SiHost_2:
		{
            addr[0x7ff8] = 0;
            addr[0x7ffd] = 0;
            addr[0x7ffc] = 0x10;

            for (offset = 0; offset < si2_z280_dsize; offset++) 
                addr[offset] = si2_z280_download[offset];

			addr[0x7ff8] = 0x10;

			if(!(pCard->PolledMode))
			{
				switch (pCard->OriginalVector) 
				{
					case 11:
						addr[0x7ff9] = 0x10;
						break;

					case 12:
						addr[0x7ffa] = 0x10;
						break;

					case 15:
						addr[0x7ffb] = 0x10;
						break;
				}
			}

            addr[0x7ffd] = 0x10;
            break;
		}
    
	case Si_2:
		{
            WRITE_PORT_UCHAR((PUCHAR)0x96, (UCHAR)((pCard->SlotNumber-1) | 8));
            c = READ_PORT_UCHAR((PUCHAR)0x102);
            c |= 0x04;          /* Reset card */
            WRITE_PORT_UCHAR((PUCHAR)0x102, c);
            c |= 0x07;          /* Enable access to card */
            WRITE_PORT_UCHAR((PUCHAR)0x102, c);

            for (offset = 0; offset < si2_z280_dsize; offset++)
                addr[offset] = si2_z280_download[offset];

            c &= 0xF0;
            c |= 0x0B;              /* enable card */
            WRITE_PORT_UCHAR((PUCHAR)0x102, c);
            WRITE_PORT_UCHAR((PUCHAR)0x96, 0);
            break;
		}

        
	case SiEisa:
		{
            port = (pCard->SlotNumber << 12) | 0xc02;
            c = (UCHAR)pCard->OriginalVector << 4;

			if(pCard->PolledMode)
				WRITE_PORT_UCHAR((PUCHAR)port,0x00);/* Select NO Interrupt + Set RESET */
			else
				WRITE_PORT_UCHAR((PUCHAR)port, c);
				
			for (offset = 0; offset < si2_z280_dsize; offset++) 
				addr[offset] = si2_z280_download[offset];

			addr[0x42] = 1;
			c = (UCHAR) ((pCard->OriginalVector << 4) | 4);

			if(pCard->PolledMode)
				WRITE_PORT_UCHAR((PUCHAR)port,0x04);/* Select NO Interrupt +  Clear RESET */
			else
				WRITE_PORT_UCHAR((PUCHAR)port, c);
				
			c = READ_PORT_UCHAR((PUCHAR)(port + 1));

            break;
		}

        
	case SiPCI:
		{
			int	loop;
			addr[SI2_PCI_SET_IRQ] = 0;			/* clear any interrupts */
			addr[SI2_PCI_RESET] = 0;			/* put z280 into reset */
			loop = 0;

			for(offset = 0;offset < si2_z280_dsize;offset++)	/* Load the TA/MTA code */
				addr[offset] = si2_z280_download[offset];

			addr[SI2_EISA_OFF] = SI2_EISA_VAL;	/* Set byte to indicate EISA/PCI */
			addr[SI2_PCI_SET_IRQ] = 0;			/* clear any interrupts */
			addr[SI2_PCI_RESET] = 1;			/* remove reset from z280 */
			break;
		}

	case Si3Isa:
	case Si3Eisa:
	case Si3Pci:
		{
			int		loop;

/* First, halt the card... */

			addr[SX_CONFIG] = 0;
			addr[SX_RESET] = 0;
			loop = 0;
			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */

			while((addr[SX_RESET] & 1)!=0 && loop++<10000)	/* spin 'til done */
				KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */

/* Copy across the Si3 TA/MTA download code... */

			for(offset = 0;offset < si3_t225_dsize;offset++)	/* Load the Si3 TA/MTA code */
				addr[si3_t225_downloadaddr+offset] = si3_t225_download[offset];

/* Install bootstrap and start the card up... */

			for(loop=0;loop<si3_t225_bsize;loop++)		/* Install bootstrap */
				addr[si3_t225_bootloadaddr+loop] = si3_t225_bootstrap[loop];

			addr[SX_RESET] = 0;				/* Reset card again */

/* Wait for board to come out of reset... */

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */

			while((addr[SX_RESET]&1)!=0 && loop++<10000)	/* spin 'til reset */
			{
				KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */
				SpxDbgMsg(SERDIAG1,("%s[Si3]: slxos_init for %x.  Waiting for board reset to end\n",
					PRODUCT_NAME, pCard->Controller));
			}

			SpxDbgMsg(SERDIAG1,("%s[Si3]: slxos_init for %x.  Board Reset ended: %d\n",
				PRODUCT_NAME, pCard->Controller, addr[SX_RESET]));
				
			if((addr[SX_RESET]&1) != 0) 
				return(CARD_RESET_ERROR);		/* Board not reset */

			if(pCard->PolledMode)
				addr[SX_CONFIG] = SX_CONF_BUSEN;	/* Poll only, no interrupt */
			else
			{
				if(pCard->CardType == Si3Pci)		/* Don't set IRQ level for PCI */
					addr[SX_CONFIG] = SX_CONF_BUSEN+SX_CONF_HOSTIRQ;
				else						/* Set IRQ level for ISA/EISA */
					addr[SX_CONFIG] = SX_CONF_BUSEN+SX_CONF_HOSTIRQ+(UCHAR)(pCard->OriginalVector<<4);
			}

			break;
		}

	case SxPlusPci:
		{
			int	loop;

/* First, halt the card... */

			addr[SX_CONFIG] = 0;
			addr[SX_RESET] = 0;
			loop = 0;
			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */

			while((addr[SX_RESET] & 1)!=0 && loop++<10000)	/* spin 'til done */
				KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */

/* Copy across the SX+ TA/MTA download code... */

			for(offset = 0; offset < si4_cf_dsize; offset++)	/* Load the SX+ TA/MTA code */
				pCard->BaseController[si4_cf_downloadaddr+offset] = si4_cf_download[offset];

/* Start the card up... */

			addr[SX_RESET] = 0;			/* Reset card again */

/* Wait for board to come out of reset... */

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */

			while((addr[SX_RESET]&1)!=0 && loop++<10000)	/* spin 'til reset */
			{
				KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */
				SpxDbgMsg(SERDIAG1,("%s[SX+]: slxos_init for %x.  Waiting for board reset to end\n",
					PRODUCT_NAME, pCard->Controller));
			}

			SpxDbgMsg(SERDIAG1,("%s[SX+]: slxos_init for %x.  Board Reset ended: %d\n",
				PRODUCT_NAME, pCard->Controller,addr[SX_RESET]));

			if((addr[SX_RESET]&1) != 0) 
				return(CARD_RESET_ERROR);		/* Board not reset */

			if(pCard->PolledMode)
				addr[SX_CONFIG] = SX_CONF_BUSEN;	/* Poll only, no interrupt */
			else
				addr[SX_CONFIG] = SX_CONF_BUSEN + SX_CONF_HOSTIRQ;

			break;
		}

	default:
		break;

    }


    SpxDbgMsg(SERDIAG1,("%s: slxos_init for %x.  Done reset\n", PRODUCT_NAME, pCard->Controller));
        
    numberOfPorts = 0;
    //
    // Set delay for 0.1 second.
    //
    delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));

    do
    {
        KeDelayExecutionThread(KernelMode,FALSE,&delay);
        SpxDbgMsg(SERDIAG1,("%s: slxos_init for %x.  Waiting for reset to end\n",
            PRODUCT_NAME, pCard->Controller));

        if(++numberOfPorts > 10)
            break;

    } while(addr[0] == 0);

    SpxDbgMsg(SERDIAG1, ("%s: slxos_init for %x.  Reset ended: %d\n", PRODUCT_NAME, pCard->Controller, addr[0]));
       
        
    if (addr[0] == 0xff || addr[0] == 0) 
		return (DCODE_OR_NO_MODULES_ERROR);


    numberOfPorts = 0;
    addr += sizeof(SXCARD);
    lastModule = FALSE;
    
    
    for (offset = 0; offset < 4 && !lastModule; offset++) 
	{

		if ( ((PMOD)addr)->mc_chip == SXDC )	/* Test for SXDC */
			SXDCs++;  /* Increment SXDC counter */
		else
			OTHERs++;  /* Increment OTHER counter */

        numberOfPortsThisModule = ((PMOD)addr)->mc_type & 31;
        lastModule = (((PMOD)addr)->mc_next & 0x7fff) == 0;
        addr += sizeof(SXMODULE);

        for (channel = 0; channel < numberOfPortsThisModule; channel++) 
		{

#ifndef	ESIL_XXX0				/* ESIL_XXX0 23/09/98 */
			if (numberOfPorts < pCard->ConfiguredNumberOfPorts)
                pCard->PortExtTable[numberOfPorts]->pChannel = addr;
#endif							/* ESIL_XXX0 23/09/98 */
			numberOfPorts++;
            addr += sizeof(SXCHANNEL);
        }

    }


	if (SXDCs > 0)
	{ 	
		if (pCard->CardType==SiHost_1 || pCard->CardType==SiHost_2 
		||	pCard->CardType==Si_2 || pCard->CardType==SiEisa   
		||	pCard->CardType==SiPCI)
		{
			pCard->NumberOfPorts = 0;
			return(NON_SX_HOST_CARD_ERROR);
		}	      

		if (OTHERs > 0)
		{
			pCard->NumberOfPorts = 0;
	        return(MODULE_MIXTURE_ERROR);
		}
       
	}		     

    pCard->NumberOfPorts = numberOfPorts;

	return(SUCCESS);
}


/*************************************************************************\
*                                                                         *
* BOOLEAN Slxos_ResetChannel(IN PVOID Context)                            *
*                                                                         *
* Initialize Channel.                                                     *
* SRER Interrupts will be enabled in EnableAllInterrupts().               *
*                                                                         *
* Return Value:                                                           *
*           Always FALSE.                                                 *
*                                                                         *
\*************************************************************************/
BOOLEAN Slxos_ResetChannel(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    SpxDbgMsg(SERDIAG1, ("%s: In Slxos_ResetChannel for %x\n", PRODUCT_NAME, pPort->pChannel));

    // Set Xon/Xoff chars.
    Slxos_SetChars(pPort);

    //
    // Now we set the line control, modem control, and the
    // baud to what they should be.
    //
    Slxos_SetLineControl(pPort);
    SerialSetupNewHandFlow(pPort, &pPort->HandFlow);
//    pPort->LastModemStatus = 0;
    SerialHandleModemUpdate(pPort);
    Slxos_SetBaud(pPort);

    return FALSE;
}


/*****************************************************************************
****************************                     *****************************
****************************   Slxos_CheckBaud   *****************************
****************************                     *****************************
******************************************************************************

Prototype:	BOOLEAN	Slxos_CheckBaud(PPORT_DEVICE_EXTENSION pPort,ULONG BaudRate)

Description:	Checks the supplied baud rate against the supported range.

Parameters:	pPort is a pointer to the device extension
		BaudRate is the baud rate as an integer

Returns:	TRUE if baud is supported,
		FALSE if not

*/

BOOLEAN	Slxos_CheckBaud(PPORT_DEVICE_EXTENSION pPort,ULONG BaudRate)
{
	PCHAN channelControl = (PCHAN)pPort->pChannel;

	switch(BaudRate)
	{
	case 75:
	case 110:
	case 150:
	case 300:
	case 600:
	case 1200:
	case 1800:
	case 2000:
	case 2400:
	case 4800:
	case 9600:
	case 19200:
	case 38400:
	case 57600:
		return(TRUE);

	case 115200:		   /* 115200 is only available to MTAs and SXDCs */
        if((channelControl->type != MTA_CD1400) && (channelControl->type != SXDC)) 
			break;

		return(TRUE);

	case 50:
	case 134:
	case 200:
	case 7200:
	case 14400:
	case 28800:
	case 56000:
	case 64000:
	case 76800:
	case 128000:
	case 150000:
	case 230400:
	case 256000:
	case 460800:
	case 921600:
		if(channelControl->type == SXDC)
			return(TRUE);
			
	default:
		break;
	}
	return(FALSE);

} /* Slxos_CheckBaud */

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetBaud(IN PVOID Context)                                   *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the Baud Rate of the device.                                       *
*                                                                           *
* Context - Pointer to a structure that contains a pointer to               *
*           the device extension and what should be the current             *
*           baud rate.                                                      *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetBaud(IN PVOID Context)
{

    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    UCHAR index2 = 0;
    UCHAR index = CSR_9600;

    SpxDbgMsg(SERDIAG1, ("%s: In Slxos_SetBaud for %x, changing to %d baud.\n",
        PRODUCT_NAME, pPort->pChannel, pPort->CurrentBaud));
        
    switch (pPort->CurrentBaud) 
	{
	case 75:
		index = CSR_75;
		break;

    case 150:
        index = CSR_150;
        break;

    case 300:
        index = CSR_300;
        break;

    case 600:
        index = CSR_600;
        break;

    case 1200:
        index = CSR_1200;
        break;

    case 1800:
        index = CSR_1800;
        break;

    case 2000:
        index = CSR_2000;
        break;

    case 2400:
        index = CSR_2400;
        break;

    case 4800:
        index = CSR_4800;
        break;

    case 9600:
        index = CSR_9600;
        break;

    case 19200:
        index = CSR_19200;
        break;

    case 38400:
        index = CSR_38400;
        break;

    case 57600:
        index = CSR_57600;
        break;

    case 115200:			
		index = CSR_110;
		break;

	case 50:
		if(channelControl->type != SXDC) 
			break;

		index = CSR_EXTBAUD;
		index2 = BAUD_50;
		break;

	case 110:
		if(channelControl->type != SXDC)
		{
			index = CSR_110;
			break;
		}
		else
		{	
	    	index = CSR_EXTBAUD;
	    	index2 = BAUD_110;
	    	break;
		}
		break;

	case 134:
		if(channelControl->type != SXDC) 
			break;

		index = CSR_EXTBAUD;
	   	index2 = BAUD_134_5;
       	break;

	case 200:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_200;
		break;

	case 7200:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_7200;
		break;

	case 14400:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_14400;
		break;

	case 56000:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_56000;
		break;

	case 64000:
		if(channelControl->type != SXDC) 
			break;
	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_64000;
       	break;

	case 76800:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	   	index2 = BAUD_76800;
       	break;

	case 128000:
		if(channelControl->type != SXDC) 
			break;

	   	index = CSR_EXTBAUD;
	    index2 = BAUD_128000;
        break;

	case 150000:
		if(channelControl->type != SXDC) 
			break;

	    index = CSR_EXTBAUD;
	    index2 = BAUD_150000;
   		break;

   	case 256000:
		if(channelControl->type != SXDC) 
			break;

		index = CSR_EXTBAUD;
	    index2 = BAUD_256000;
   		break;

	case 28800:
		if(channelControl->type != SXDC) 
			break;

		index = CSR_EXTBAUD;
	    index2 = BAUD_28800;
   		break;

	case 230400:
	    if(channelControl->type != SXDC) 
			break;

	    index = CSR_EXTBAUD;
	    index2 = BAUD_230400;
	    break;

	case 460800:
	    if(channelControl->type != SXDC) 
			break;

	    index = CSR_EXTBAUD;
	    index2 = BAUD_460800;
	    break;

	case 921600:
	    if(channelControl->type != SXDC) 
			break;

	    index = CSR_EXTBAUD;
	    index2 = BAUD_921600;
	    break;

    default:
        index = CSR_9600;

        SpxDbgMsg(SERDIAG1, ("%s: Invalid BaudRate: %ld\n", PRODUCT_NAME, pPort->CurrentBaud));
		break;
    }

    channelControl->hi_csr = index + (index << 4);
    channelControl->hi_txbaud = index2;		/* Set extended transmit baud rate */
    channelControl->hi_rxbaud = index2;		/* Set extended receive baud rate */

	// Set mask so only the baud rate is configured.
	channelControl->hs_config_mask |= CFGMASK_BAUD;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetLineControl(IN PVOID Context)                            *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the Line Control of the device.                                    *
*                                                                           *
* Context - Pointer to a structure that contains a pointer to               *
*           the device extension.                                           *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetLineControl(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN) pPort->pChannel;
    UCHAR mr1 = 0;
    UCHAR mr2 = 0;
    BOOLEAN needParityDetection = FALSE;

    SpxDbgMsg(SERDIAG1, ("%s: In Slxos_SetLineControl for %x.\n", PRODUCT_NAME, pPort->pChannel));

    switch (pPort->LineControl & SERIAL_DATA_MASK) 
	{
	case SERIAL_5_DATA:
        mr1 |= MR1_5_BITS;
        break;

    case SERIAL_6_DATA:
        mr1 |= MR1_6_BITS;
        break;

    case SERIAL_7_DATA:
		mr1 |= MR1_7_BITS;
		break;

    case SERIAL_8_DATA:
        mr1 |= MR1_8_BITS;
        break;
    }

    switch (pPort->LineControl & SERIAL_STOP_MASK) 
	{
    case SERIAL_1_STOP:
        mr2 = MR2_1_STOP;
        break;

    case SERIAL_2_STOP:
        mr2 = MR2_2_STOP;
        break;
    }

    switch (pPort->LineControl & SERIAL_PARITY_MASK) 
	{
    case SERIAL_NONE_PARITY:
        mr1 |= MR1_NONE;
        break;

    case SERIAL_ODD_PARITY:
        mr1 |= MR1_ODD | MR1_WITH;
        needParityDetection = TRUE;
        break;

    case SERIAL_EVEN_PARITY:
        mr1 |= MR1_EVEN | MR1_WITH;
        needParityDetection = TRUE;
        break;

    case SERIAL_MARK_PARITY:
        mr1 |= MR1_ODD | MR1_FORCE;
        needParityDetection = TRUE;
        break;

    case SERIAL_SPACE_PARITY:
        mr1 |= MR1_EVEN | MR1_FORCE;
        needParityDetection = TRUE;
        break;
    }

    channelControl->hi_mr1 = mr1;
    channelControl->hi_mr2 = mr2;

    if (needParityDetection)
        channelControl->hi_prtcl |= SP_PAEN;
	else 
        channelControl->hi_prtcl &= ~SP_PAEN;


    //
    // received breaks should cause interrupts
    //
    channelControl->hi_break |= BR_INT;
    channelControl->hi_break |= BR_ERRINT;		/* Treat parity/overrun/framing errors as exceptions */


	// Set mask so only the line control is configured.
	channelControl->hs_config_mask |= CFGMASK_LINE;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* VOID Slxos_SetChars(IN PVOID Context)                                     *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set Special Chars.                                                     *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Slxos_SetChars(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_SetChars for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    channelControl->hi_txon = pPort->SpecialChars.XonChar;
    channelControl->hi_txoff = pPort->SpecialChars.XoffChar;
    channelControl->hi_rxon = pPort->SpecialChars.XonChar;
    channelControl->hi_rxoff = pPort->SpecialChars.XoffChar;
    channelControl->hi_err_replace = pPort->SpecialChars.ErrorChar;

	// Set mask so only the special chars are configured.
	channelControl->hs_config_mask |= CFGMASK_LINE;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);
}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetDTR(IN PVOID Context)                                    *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the DTR in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetDTR(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Setting DTR for %x.\n", PRODUCT_NAME, pPort->pChannel));

    //
    // Set DTR (usual nomenclature problem).
    //
    channelControl->hi_op |= OP_DTR;

    if(channelControl->hi_prtcl&SP_DTR_RXFLOW)	/* If flow control is enabled */
    	return(FALSE);				/* Don't try to set the signal */

	// Set mask so only the modem pins are configured.
	channelControl->hs_config_mask |= CFGMASK_MODEM;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_ClearDTR(IN PVOID Context)                                  *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the DTR in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_ClearDTR(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl =  (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Clearing DTR for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    //
    // Clear DTR (usual nomenclature problem).
    //
    channelControl->hi_op &= ~OP_DTR;

    if(channelControl->hi_prtcl&SP_DTR_RXFLOW)	/* If flow control is enabled */
    	return(FALSE);				/* Don't try to set the signal */

	// Set mask so only the modem pins are configured.
	channelControl->hs_config_mask |= CFGMASK_MODEM;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetRTS (IN PVOID Context)                                   *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the RTS in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetRTS(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Setting RTS for %x.\n", PRODUCT_NAME, channelControl));
        
    //
    // Set RTS (usual nomenclature problem).
    //
    channelControl->hi_op |= OP_RTS;

    if(channelControl->hi_mr1 & MR1_RTS_RXFLOW)	/* If flow control is enabled */
    	return(FALSE);				/* Don't try to set the signal */


	// Set mask so only the modem pins are configured.
	channelControl->hs_config_mask |= CFGMASK_MODEM;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_ClearRTS (IN PVOID Context)                                 *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set the RTS in the modem control register.                             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_ClearRTS(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Clearing RTS for %x.\n", PRODUCT_NAME, channelControl));

    //
    // Clear RTS (usual nomenclature problem).
    //
    channelControl->hi_op &= ~OP_RTS;

    if(channelControl->hi_mr1 & MR1_RTS_RXFLOW)	/* If flow control is enabled */
    	return(FALSE);				/* Don't try to set the signal */

	// Set mask so only the modem pins are configured.
	channelControl->hs_config_mask |= CFGMASK_MODEM;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;
}


/*****************************************************************************
***************************                       ****************************
***************************   Slxos_FlushTxBuff   ****************************
***************************                       ****************************
******************************************************************************

Prototype:	BOOLEAN	Slxos_FlushTxBuff(IN PVOID Context)

Description:	Flushes the transmit buffer by setting the pointers equal.

Parameters:	Context is a pointer to the device extension

Returns:	FALSE

*/
BOOLEAN	Slxos_FlushTxBuff(IN PVOID Context)
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	PCHAN channelControl = (PCHAN)pPort->pChannel;

	SpxDbgMsg(SERDIAG1,("%s: Flushing Transmit Buffer for channel %x.\n",PRODUCT_NAME,channelControl));
	channelControl->hi_txipos = channelControl->hi_txopos;	/* Set in = out */
	

/* ESIL_0925 08/11/99 */
    switch (channelControl->hi_hstat) 
	{
	case HS_IDLE_OPEN:
        channelControl->hi_hstat = HS_WFLUSH;
        pPort->PendingOperation = HS_IDLE_OPEN;
		break;

    case HS_LOPEN:
    case HS_MOPEN:
    case HS_IDLE_MPEND:	
    case HS_CONFIG:
    case HS_STOP:	
    case HS_RESUME:	
    case HS_WFLUSH:
    case HS_RFLUSH:
    case HS_SUSPEND:
    case HS_CLOSE:	
        pPort->PendingOperation = HS_WFLUSH;
        break;

    default:
        break;
    }

/* ESIL_0925 08/11/99 */

    return FALSE;

} /* Slxos_FlushTxBuff */

  
/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SendXon(IN PVOID Context)                                   *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to send an Xon Character.                                                 *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SendXon(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_SendXon for %x.\n", PRODUCT_NAME, channelControl));

    //
    // Empty the receive buffers.  This will provoke the hardware into sending an XON if necessary.
    //
    channelControl->hi_rxopos = channelControl->hi_rxipos;

    //
    // If we send an xon, by definition we can't be holding by Xoff.
    //
    pPort->TXHolding &= ~SERIAL_TX_XOFF;

    //
    // If we are sending an xon char then by definition 
	// we can't be "holding" up reception by Xoff.
    //
    pPort->RXHolding &= ~SERIAL_RX_XOFF;

    SpxDbgMsg(SERDIAG1, ("%s: Sending Xon for %x. RXHolding = %d, TXHolding = %d\n",
         PRODUCT_NAME, pPort->pChannel, pPort->RXHolding, pPort->TXHolding));
       
    return FALSE;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_SetFlowControl(IN PVOID Context)                            *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to set Flow Control                                                       *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_SetFlowControl(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    BOOLEAN needHardwareFlowControl = FALSE;

    SpxDbgMsg(SERDIAG1, ("%s: Setting Flow Control for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    if (pPort->HandFlow.ControlHandShake & SERIAL_OUT_HANDSHAKEMASK) 
        needHardwareFlowControl = TRUE;


    if (pPort->HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Setting CTS Flow Control.\n",PRODUCT_NAME));

        //
        // This looks wrong, too, for the same reason.
        //
        channelControl->hi_mr2 |= MR2_CTS_TXFLOW;
        needHardwareFlowControl = TRUE;
    } 
	else 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Clearing CTS Flow Control.\n",PRODUCT_NAME));

        //
        // This looks wrong, too, for the same reason.
        //
        channelControl->hi_mr2 &= ~MR2_CTS_TXFLOW;
    }

    if ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE) 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Setting RTS Flow Control.\n",PRODUCT_NAME));

        //
        // Set flow control in the hardware (usual nomenclature problem).
        //
        channelControl->hi_mr1 |= MR1_RTS_RXFLOW;
        needHardwareFlowControl = TRUE;
    } 
	else 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Clearing RTS Flow Control.\n",PRODUCT_NAME));

        //
        // Clear flow control in the hardware (usual nomenclature problem).
        //
        channelControl->hi_mr1 &= ~MR1_RTS_RXFLOW;
    }

/* DSR Transmit Flow Control... */
    
    if(pPort->HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE)
    {
		SpxDbgMsg(SERDIAG1,("%s: Setting DSR Flow Control.\n",PRODUCT_NAME));
        
		channelControl->hi_prtcl = SP_DSR_TXFLOW;		/* Enable DSR Transmit Flow Control */
        needHardwareFlowControl = TRUE;
    }
    else
    {
		SpxDbgMsg(SERDIAG1,("%s: Clearing DSR Flow Control.\n",PRODUCT_NAME));
        
		channelControl->hi_prtcl &= ~SP_DSR_TXFLOW;		/* Disable DSR Transmit Flow Control */
    }

/* DTR Receive Flow Control... */

    if((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
    {
		SpxDbgMsg(SERDIAG1,("%s: Setting DTR Flow Control.\n",PRODUCT_NAME));
        
		channelControl->hi_prtcl |= SP_DTR_RXFLOW;		/* Enable DTR Receive Flow Control */
        needHardwareFlowControl = TRUE;
    }
    else
    {
		SpxDbgMsg(SERDIAG1,("%s: Clearing DTR Flow Control.\n",PRODUCT_NAME));
        
		channelControl->hi_prtcl &= ~SP_DTR_RXFLOW;		/* Disable DTR Receive Flow Control */
    }

    if (pPort->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Setting Receive Xon/Xoff Flow Control.\n",PRODUCT_NAME));

        channelControl->hi_prtcl |= SP_RXEN;
    } 
	else 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Clearing Receive Xon/Xoff Flow Control.\n",PRODUCT_NAME));
            
        channelControl->hi_prtcl &= ~SP_RXEN;
    }

    if (pPort->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Setting Transmit Xon/Xoff Flow Control.\n",PRODUCT_NAME));

        channelControl->hi_prtcl |= SP_TXEN;
    } 
	else 
	{
        SpxDbgMsg(SERDIAG1, ("%s: Clearing Transmit Xon/Xoff Flow Control.\n",PRODUCT_NAME));

        channelControl->hi_prtcl &= ~SP_TXEN;
    }

/* Enable error character replacement... */

	if(pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)	/* Replace "bad" error characters ? */
		channelControl->hi_break |= BR_ERR_REPLACE;	/* Yes */
	else	
		channelControl->hi_break &= ~BR_ERR_REPLACE;	/* No */

    //
    // Enable detection of modem signal transitions if needed
    //
    if (needHardwareFlowControl) 
        channelControl->hi_prtcl |= SP_DCEN;
	else 
        channelControl->hi_prtcl &= ~SP_DCEN;

    //
    // permanently enable input pin checking
    //
    channelControl->hi_prtcl |= SP_DCEN;


	// Set mask so only the flow control is configured.
	channelControl->hs_config_mask |= CFGMASK_FLOW;

	// Send configue port command.
	SX_CONFIGURE_PORT(pPort, channelControl);

    return FALSE;

}

/***************************************************************************\
*                                                                           *
* VOID Slxos_Resume(IN PVOID Context)                                       *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to simulate Xon received.                                                 *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Slxos_Resume(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_Resume for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    switch (channelControl->hi_hstat) 
	{
	case HS_IDLE_OPEN:
        channelControl->hi_hstat = HS_RESUME;
        pPort->PendingOperation = HS_IDLE_OPEN;
		break;

    case HS_LOPEN:
    case HS_MOPEN:
    case HS_IDLE_MPEND:	
    case HS_CONFIG:
    case HS_STOP:	
    case HS_RESUME:	
    case HS_WFLUSH:
    case HS_RFLUSH:
    case HS_SUSPEND:
    case HS_CLOSE:	
        pPort->PendingOperation = HS_RESUME;
        break;

    default:
        break;
    }
 
}

/***************************************************************************\
*                                                                           *
* UCHAR Slxos_GetModemStatus(IN PVOID Context)                              *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Get Modem Status in UART style.                                        *
*                                                                           *
* This routine suffers particularly badly from the SI's attempt to be       *
* a DCE, effectively meaning that it swaps CTS/RTS and DSR/DTR.             *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           MSR Register - UART Style.                                      *
*                                                                           *
\***************************************************************************/
UCHAR Slxos_GetModemStatus(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    UCHAR ModemStatus = 0, Status, ModemDeltas;

    SpxDbgMsg( SERDIAG1, ("%s: Slxos_GetModemStatus for %x.\n",	PRODUCT_NAME, channelControl));

    //
    // Modify modem status only if signals have changed.
    // Note that it is possible that a signal transition may have been missed
    //
    if((Status = channelControl->hi_ip) != pPort->LastStatus)
	{
        if (Status & IP_DSR)
            ModemStatus |= SERIAL_MSR_DSR;

        if (Status & IP_DCD)
            ModemStatus |= SERIAL_MSR_DCD;

        if (Status & IP_CTS)
            ModemStatus |= SERIAL_MSR_CTS;

        if (Status & IP_RI)
            ModemStatus |= SERIAL_MSR_RI;

        pPort->LastModemStatus = ModemStatus;/* Store modem status without deltas */

        ModemDeltas = Status ^ pPort->LastStatus;
        pPort->LastStatus = Status;

        if (ModemDeltas & IP_DSR)
            ModemStatus |= SERIAL_MSR_DDSR;

        if (ModemDeltas & IP_DCD)
            ModemStatus |= SERIAL_MSR_DDCD;

        if (ModemDeltas & IP_CTS)
            ModemStatus |= SERIAL_MSR_DCTS;

        if (ModemDeltas & IP_RI)
            ModemStatus |= SERIAL_MSR_TERI;

		SpxDbgMsg( SERDIAG1, ("%s: Get New Modem Status for 0x%x, Status = 0x%x hi_ip 0x%x\n",
			PRODUCT_NAME, pPort->pChannel, ModemStatus, Status));

		return ModemStatus;

    }

    SpxDbgMsg( SERDIAG1, ("%s: Get Last Modem Status for 0x%x, Status = 0x%x hi_ip 0x%x\n",
            PRODUCT_NAME, pPort->pChannel, pPort->LastModemStatus, channelControl->hi_ip));
        
    return pPort->LastModemStatus;
}

/***************************************************************************\
*                                                                           *
* UCHAR Slxos_GetModemControl(IN PVOID Context)                             *
*                                                                           *
* This routine which is not only called at interrupt level is used          *
* to Get Modem Control - RTS/DTR in UART style. RTS is a DTR output.        *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           MCR Register - UART Style.                                      *
*                                                                           *
\***************************************************************************/
ULONG Slxos_GetModemControl(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    ULONG ModemControl = 0;
    UCHAR Status;

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_GetModemControl for %x.\n", PRODUCT_NAME, channelControl));
        
    // Get Signal States
    Status = channelControl->hi_op;

    if(Status & OP_RTS) 
        ModemControl |= SERIAL_MCR_RTS;

    if(Status & OP_DTR) 
        ModemControl |= SERIAL_MCR_DTR;

    return ModemControl;
}

/***************************************************************************\
*                                                                           *
* VOID Slxos_EnableAllInterrupts(IN PVOID Context)                          *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Enable All Interrupts.                                                 *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Slxos_EnableAllInterrupts(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;

    SpxDbgMsg(SERDIAG1,("%s: EnableAllInterrupts for %x.\n", PRODUCT_NAME, pPort->pChannel));
   
    switch (channelControl->hi_hstat) 
	{
	case HS_IDLE_CLOSED:
        channelControl->hi_hstat = HS_LOPEN;
        pPort->PendingOperation = HS_IDLE_OPEN;
		break;

    case HS_CLOSE:
	case HS_FORCE_CLOSED:
        pPort->PendingOperation = HS_LOPEN;
		break;

    default:
        break;
    }

   
}

/***************************************************************************\
*                                                                           *
* VOID Slxos_DisableAllInterrupts(IN PVOID Context)                         *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Disable All Interrupts.                                                *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           None.                                                           *
*                                                                           *
\***************************************************************************/
VOID Slxos_DisableAllInterrupts(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
	int	timeout = 100;
       

    SpxDbgMsg(SERDIAG1, ("%s: DisableAllInterrupts for %x.\n", PRODUCT_NAME, pPort->pChannel));

/* ESIL_0925 08/11/99 */
	// Whilst the firmware is in a transitory state then wait for time out period.
	while(((channelControl->hi_hstat != HS_IDLE_OPEN)
	&& (channelControl->hi_hstat != HS_IDLE_CLOSED)
	&& (channelControl->hi_hstat != HS_IDLE_BREAK))
	&& (--timeout))
	{
		LARGE_INTEGER delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(10000000));/* 10mS */
		KeDelayExecutionThread(KernelMode,FALSE,&delay);	/* Wait */
	}
/* ESIL_0925 08/11/99 */


    channelControl->hi_hstat = HS_FORCE_CLOSED;
    pPort->PendingOperation = HS_IDLE_CLOSED;

}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_TurnOnBreak(IN PVOID Context)                               *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Turn Break On.                                                         *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_TurnOnBreak(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
       

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_TurnOnBreak for %x.\n", PRODUCT_NAME, pPort->pChannel));
        
    switch (channelControl->hi_hstat) 
	{
	case HS_IDLE_OPEN:
        channelControl->hi_hstat = HS_START;
        pPort->PendingOperation = HS_IDLE_OPEN;
		break;

    case HS_LOPEN:
    case HS_MOPEN:
    case HS_IDLE_MPEND:	
    case HS_CONFIG:
    case HS_STOP:	
    case HS_RESUME:	
    case HS_WFLUSH:
    case HS_RFLUSH:
    case HS_SUSPEND:
    case HS_CLOSE:	
        pPort->PendingOperation = HS_START;
        break;

    default:
        break;
    }

    return FALSE;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_TurnOffBreak(IN PVOID Context)                              *
*                                                                           *
* This routine which is only called at interrupt level is used              *
* to Turn Break Off.                                                        *
*                                                                           *
* Context - Really a pointer to the device extension.                       *
*                                                                           *
* Return Value:                                                             *
*           This routine always returns FALSE.                              *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_TurnOffBreak(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
        

    SpxDbgMsg(SERDIAG1, ("%s: Slxos_TurnOffBreak for %x.\n", PRODUCT_NAME, pPort->pChannel));
    
    // If we were about to start breaking then lets forget about it??
    if (pPort->PendingOperation == HS_START)
	{
        pPort->PendingOperation = HS_IDLE_OPEN;
	}
	else
	{
		switch (channelControl->hi_hstat) 
		{	
		case HS_IDLE_BREAK:		// If we are in the HS_IDLE_BREAK state we go to HS_STOP now.
			channelControl->hi_hstat = HS_STOP;
			pPort->PendingOperation = HS_IDLE_OPEN;
			break;

		case HS_START:			// If we are in the HS_START state we go to HS_STOP soon.	
			pPort->PendingOperation = HS_STOP;
			break;

		default:				// Otherwise we are unable to do anything.
			break;
		}

	}


    return FALSE;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN Slxos_Interrupt(IN PVOID Context)                                 *
*                                                                           *
\***************************************************************************/
BOOLEAN Slxos_Interrupt(IN PVOID Context)
{
    PCARD_DEVICE_EXTENSION pCard = Context;
    BOOLEAN ServicedAnInterrupt = FALSE;
    UCHAR c;

    SpxDbgMsg(SERDIAG5, ("%s: In Slxos_Interrupt: Context: %x; CardType: %d\n",
        PRODUCT_NAME, Context, pCard->CardType));

    switch (pCard->CardType) 
	{
	case SiHost_1:
		pCard->Controller[0xa000] = 0;
		pCard->Controller[0xe000] = 0;
		break;
        
	case Si_2:
		WRITE_PORT_UCHAR((PUCHAR)0x96, (UCHAR)((pCard->SlotNumber-1) | 8));
		c = READ_PORT_UCHAR((PUCHAR)0x102);
		c &= ~0x08;
		WRITE_PORT_UCHAR((PUCHAR)0x102, c);
		c |= 0x08;
		WRITE_PORT_UCHAR((PUCHAR)0x102, c);
		WRITE_PORT_UCHAR((PUCHAR)0x96, 0);            /* De-select slot */
		break;

    case SiHost_2:
		pCard->Controller[0x7FFD] = 0x00;
		pCard->Controller[0x7FFD] = 0x10;
		break;

	case SiEisa:
		READ_PORT_UCHAR((PUCHAR)((pCard->SlotNumber << 12) | 0xc03));
		break;

    case SiPCI:
		pCard->Controller[SI2_PCI_SET_IRQ] = 0;/* Reset interrupts */
        break;

	case Si3Isa:
	case Si3Eisa:
	case Si3Pci:
	case SxPlusPci:
	    if(pCard->Controller[SX_IRQ_STATUS]&1)
			return(FALSE);
	    
		pCard->Controller[SX_RESET_IRQ]=0;	/* Reset interrupts */

	default:
		break;
    }

    ((PSXCARD)pCard->Controller)->cc_int_pending = 0;

	IoRequestDpc(pCard->DeviceObject,NULL,pCard);	/* Request DPC to handle interrupt */

	return(TRUE);				/* Interrupt acknowledged */
}

/*****************************************************************************
******************************                  ******************************
******************************   Slxos_IsrDpc   ******************************
******************************                  ******************************
******************************************************************************

Prototype:	VOID	Slxos_IsrDpc
			(
				IN PKDPC 		Dpc,
				IN PDEVICE_OBJECT	DeviceObject,
				IN PIRP 		Irp,
				IN PVOID 		Context
			)

Description:	Polls the board for work to do.

Parameters:	Context is a pointer to the device extension

Returns:	FALSE

*/

VOID	Slxos_IsrDpc
(
	IN PKDPC 		Dpc,
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP 		Irp,
	IN PVOID 		Context
)
{
	PCARD_DEVICE_EXTENSION	pCard = Context;

	KeAcquireSpinLockAtDpcLevel(&pCard->DpcLock);	/* Protect Dpc for this board */
	Slxos_PollForInterrupt(pCard,FALSE);			/* Service the board */
	KeReleaseSpinLockFromDpcLevel(&pCard->DpcLock);	/* Free the Dpc lock */

} /* Slxos_IsrDpc */

/*****************************************************************************
****************************                     *****************************
****************************   Slxos_PolledDpc   *****************************
****************************                     *****************************
******************************************************************************

Prototype:	VOID	Slxos_PolledDpc(IN PKDPC Dpc,IN PVOID Context,IN PVOID SysArg1,IN PVOID SysArg2)

Description:	Polls the board for work to do.

Parameters:	Context is a pointer to the device extension

Returns:	FALSE

*/

VOID Slxos_PolledDpc(IN PKDPC Dpc,IN PVOID Context,IN PVOID SysArg1,IN PVOID SysArg2)
{
	PCARD_DEVICE_EXTENSION	pCard = Context;
	LARGE_INTEGER			PolledPeriod;

	KeAcquireSpinLockAtDpcLevel(&pCard->DpcLock);	/* Protect Dpc for this board */
	Slxos_PollForInterrupt(pCard,FALSE);			/* Service the board */
	KeReleaseSpinLockFromDpcLevel(&pCard->DpcLock);	/* Free the Dpc lock */
	PolledPeriod.QuadPart = -100000;				/* 100,000*100nS = 10mS */
	KeSetTimer(&pCard->PolledModeTimer,PolledPeriod,&pCard->PolledModeDpc);

} /* Slxos_PolledDpc */

/*****************************************************************************
*****************************                    *****************************
*****************************   Slxos_SyncExec   *****************************
*****************************                    *****************************
******************************************************************************

Prototype:	VOID	Slxos_SyncExec(PPORT_DEVICE_EXTENSION pPort,PKSYNCHRONIZE_ROUTINE SyncRoutine,PVOID SyncContext)

Description:	Synchronizes execution between driver threads and the DPC.

Parameters:	pPort points to the serial device extension.
			SyncRoutine is the function to call in synchronization.
			SyncContext is the data to call the function with.

Returns:	None

*/

VOID Slxos_SyncExec(PPORT_DEVICE_EXTENSION pPort,PKSYNCHRONIZE_ROUTINE SyncRoutine,PVOID SyncContext,int index)
{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	KIRQL	OldIrql;

	KeAcquireSpinLock(&pCard->DpcLock,&OldIrql);	/* Protect Dpc for this board */
	(SyncRoutine)(SyncContext);						/* Call the synchronized function */
	KeReleaseSpinLock(&pCard->DpcLock,OldIrql);		/* Free the Dpc lock */

} /* SlxosSyncExec */

/*****************************************************************************
*************************                            *************************
*************************   Slxos_PollForInterrupt   *************************
*************************                            *************************
******************************************************************************

Prototype:		BOOLEAN	Slxos_PollForInterrupt(IN PVOID Context,IN BOOLEAN Obsolete)

Description:	Checks the specified card and performs read, write and control servicing as necessary.

Parameters:		Context specifies the context of the call, this is casted to a "pCard" structure.
				Obsolete is a variable no longer used in this function

Returns:		TRUE (always)

NOTE:			Slxos_PollForInterrupt is protected by a DpcLock associated with a given board.
				This function ASSUMES that the lock has been obtained before being called.

*/

BOOLEAN	Slxos_PollForInterrupt(IN PVOID Context,IN BOOLEAN Obsolete)
{
	PCARD_DEVICE_EXTENSION	pCard = Context;
	PPORT_DEVICE_EXTENSION	pPort;
	UCHAR			nChan;
	PCHAN			pChan;
#if	DBG
	ULONG			SavedDebugLevel = SpxDebugLevel;
#endif

/* Check to see if Dpc is already running to prevent being called recursively... */

	if(pCard->DpcFlag) 
		return(FALSE);			/* Dpc is already running */
	
	pCard->DpcFlag = TRUE;		/* Mark Dpc as running */

#if	DBG
	if(!(SpxDebugLevel & SERINTERRUPT))	/* If interrupt flag not set */
		SpxDebugLevel = 0;				/* disable messages */
#endif

/* Check each channel on the card for servicing... */

	for(nChan = 0; nChan < pCard->NumberOfPorts; nChan++)
	{
#ifdef ESIL_XXX0					/* ESIL_XXX0 24/09/98 */
		if(!(pCard->AttachedPDO[nChan]))		/* Get PDO for this channel */
			continue;				/* NULL, skip to next */

		if(!(pPort = (PPORT_DEVICE_EXTENSION)pCard->AttachedPDO[nChan]->DeviceExtension))
			continue;				/* NULL, skip to next */

#ifndef	BUILD_SPXMINIPORT
		if(!(pPort->PnpPowerFlags & PPF_POWERED))	/* Is port powered ? */
			continue;								/* No, skip */
#endif
#else						/* ESIL_XXX0 24/09/98 */
		if(!(pPort = pCard->PortExtTable[nChan]))	/* Get extension structure for this channel */
			continue;								/* NULL, skip to next */
#endif						/* ESIL_XXX0 24/09/98 */

        if(!(pChan = (PCHAN)pPort->pChannel))		/* Get channel structure on card */
        	continue;								/* NULL, skip to next */


		switch(pChan->hi_hstat)		// Check current state of channel
		{
		case HS_IDLE_OPEN:
			{
				// We can move from the IDLE_OPEN state to any of the following states.
				switch(pPort->PendingOperation)
				{
				case HS_FORCE_CLOSED:
				case HS_CLOSE:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_CLOSED;	// Wait for IDLE_CLOSED 
					break;

				case HS_CONFIG:
				case HS_RESUME:
				case HS_WFLUSH:
				case HS_RFLUSH:
				case HS_SUSPEND:
				case HS_START:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_OPEN;		// Wait for IDLE_OPEN 
					break;

				default:
					break;	// We cannot move to any other states from here.

				}

				break;
			}

		case HS_IDLE_BREAK:
			{
				// We can move from the HS_IDLE_BREAK state to any of the following states.
				switch(pPort->PendingOperation)
				{
				case HS_FORCE_CLOSED:
				case HS_CLOSE:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_CLOSED;	// Wait for IDLE_CLOSED 
					break;

				case HS_STOP:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_OPEN;		// Wait for IDLE_OPEN 
					break;

				default:
					break;	// We cannot move to any other states from here.
				}

				break;
			}

		case HS_IDLE_CLOSED:
			{
				// We can move from the HS_IDLE_CLOSED state to any of the following states.
				switch(pPort->PendingOperation)
				{
				case HS_FORCE_CLOSED:
				case HS_CLOSE:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_CLOSED;	// Wait for IDLE_CLOSED 
					break;

				case HS_LOPEN:
				case HS_MOPEN:
					pChan->hi_hstat = pPort->PendingOperation;	// Set pending operation
					pPort->PendingOperation = HS_IDLE_OPEN;		// Wait for IDLE_OPEN 
					break;

				default:
					break;	// We cannot move to any other states from here.
				}

				break;

			}


		default:
			break;	// We are not in a state that is under the driver's control.
		
		}	


		switch(pChan->hi_hstat)		// Check current state of channel now
		{
		case HS_LOPEN:				
		case HS_MOPEN:
		case HS_IDLE_MPEND:
		case HS_CONFIG:
		case HS_CLOSE:
		case HS_IDLE_CLOSED:
			break;

		default:
			{
				if(pPort->DeviceIsOpen)							// If Port is open
				{
					slxos_mint(pPort);							// Service modem changes 
					ExceptionHandle(pPort, pChan->hi_state);	// Service exceptions 

					if(pChan->hi_state & ST_BREAK)				// If break received
						pChan->hi_state &= ~ST_BREAK;			// Clear break status 

					slxos_rxint(pPort);							// Service Receive Data 
					slxos_txint(pPort);							// Service Transmit Data 
				}

				break;
			}
		}



	} /* for(nChan... */

	pCard->DpcFlag = FALSE;					/* No longer running the Dpc */
#if	DBG
	SpxDebugLevel = SavedDebugLevel;
#endif
	return(TRUE);						/* Done */

} /* Slxos_PollForInterrupt */

/***************************************************************************\
*                                                                           *
* BOOLEAN ExceptionHandle(                                                  *
*    IN PPORT_DEVICE_EXTENSION pPort,										*
*    IN UCHAR State)                                                        *
*                                                                           *
\***************************************************************************/
BOOLEAN ExceptionHandle(IN PPORT_DEVICE_EXTENSION pPort, IN UCHAR State)
{
    UCHAR lineStatus = 0;
	PCHAN pChan = (PCHAN)pPort->pChannel;

    SpxDbgMsg( SERDIAG1, ("%s: exception, state 0x%x\n", PRODUCT_NAME, State));

    if(State & ST_BREAK) 
	{
        SpxDbgMsg( SERDIAG1, ("ST_BREAK\n"));
        lineStatus |= SERIAL_LSR_BI;
    }


	if(pChan->err_framing)	lineStatus |= SERIAL_LSR_FE;	/* Framing Errors */
	if(pChan->err_parity)	lineStatus |= SERIAL_LSR_PE;	/* Parity Errors */
	if(pChan->err_overrun)	lineStatus |= SERIAL_LSR_OE;	/* Overrun Errors */
	if(pChan->err_overflow)	lineStatus |= SERIAL_LSR_OE;	/* Overflow Errors */

	pChan->err_framing	= 0;								/* Reset errros */
	pChan->err_parity	= 0;
	pChan->err_overrun	= 0;
	pChan->err_overflow = 0;

    if(lineStatus != 0) 
	{
        SerialProcessLSR(pPort, lineStatus);
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN slxos_txint(IN PPORT_DEVICE_EXTENSION pPort)						*
*                                                                           *
\***************************************************************************/
BOOLEAN slxos_txint(IN PPORT_DEVICE_EXTENSION pPort)
{
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    UCHAR nchars;
    BOOLEAN ServicedAnInterrupt = FALSE;

    SpxDbgMsg(SERDIAG2, ("%s: slxos_txint for %x.\n", PRODUCT_NAME, pPort->pChannel));


#if USE_NEW_TX_BUFFER_EMPTY_DETECT
	// Only on cards that we can detect a Tx buffer empty event. 
	if(pPort->DetectEmptyTxBuffer && pPort->DataInTxBuffer)
	{	// If there was some data in Tx buffer...
		if(!Slxos_GetCharsInTxBuffer(pPort) && !((PCHAN)pPort->pChannel)->tx_fifo_count)	// ... and now it is empty then...
		{
			pPort->DataInTxBuffer = FALSE;		// Reset flag now that buffer is empty.

			pPort->EmptiedTransmit = TRUE;		// set flag to indicate we have done some transmission
												// since a Tx Empty event was asked for.

			if(!pPort->WriteLength && !pPort->TransmitImmediate)
				SerialProcessEmptyTransmit(pPort);	// See if we need to signal the Tx empty event.	
		}
	}
#endif

    for (;;) 
	{
		// If we have nothing at all remaining to send then exit.
		if(!pPort->WriteLength && !pPort->TransmitImmediate)
			break;

		// Calculate out how much space we have remaining in the card buffer.
        nchars = 255 - ((CHAR)channelControl->hi_txipos - (CHAR)channelControl->hi_txopos);

		// If we have no space left in the buffer then exit as we can't send anything.
        if(nchars == 0)
            break;
  

		// If we have no immediate chars to send & we are flowed off for any reason
		// then exit because we will not be able to send anything. 
		if(!pPort->TransmitImmediate && pPort->TXHolding)
            break;

		// Try to send some data...
		ServicedAnInterrupt = TRUE;
        SendTxChar(pPort);


		// If we have no ordinary data to send or we are flowed 
		// off for any reason at all then break out or we will hang!
 		if(!pPort->WriteLength || pPort->TXHolding)
            break;
    }

    return ServicedAnInterrupt;
}

/***************************************************************************\
*                                                                           *
* ULONG CopyCharsToTxBuffer(IN PPORT_DEVICE_EXTENSION pPort)				*
*                                                                           *
* This routine which is only called at interrupt level is used to fill the  *
* transmit buffer of the device, or empty the list of queued characters to  *
* transmit if there are fewer characters available than that.               *
*                                                                           *
* pPort - The current device extension.										*
*                                                                           *
* InputBuffer - Source of characters to transfer to the queue.              *
*                                                                           *
* InputBufferLength - Maximum number of characters to transfer.             *
*                                                                           *
* Return Value:                                                             *
*           This routine returns the number of characters copied to the     *
*           transmit buffer.                                                *
*                                                                           *
\***************************************************************************/
ULONG CopyCharsToTxBuffer(IN PPORT_DEVICE_EXTENSION pPort, IN PUCHAR InputBuffer, IN ULONG InputBufferLength)
{
	PCHAN channelControl = (PCHAN)pPort->pChannel;
	UCHAR nchars;

    nchars = (CHAR)channelControl->hi_txipos - (CHAR)channelControl->hi_txopos;
    nchars = 255 - nchars;

    if(InputBufferLength < nchars) 
	{
		nchars = (UCHAR)InputBufferLength;
    }

    SpxDbgMsg(SERDIAG1, ("%s: Copying %d/%d characters to Tx buffer\n", PRODUCT_NAME, nchars, InputBufferLength));

    if(nchars) 
	{
        if(channelControl->hi_txipos + nchars <= 256) 
		{
			if(pPort->pParentCardExt->CardType == SiPCI)
			{
				SpxCopyBytes(	&channelControl->hi_txbuf[channelControl->hi_txipos],
								InputBuffer,
								nchars);
			}
			else
			{
				RtlMoveMemory(	&channelControl->hi_txbuf[channelControl->hi_txipos],
								InputBuffer,
								nchars);
			}
		} 
		else 
		{
            UCHAR sizeOfFirstMove = 256 - channelControl->hi_txipos;

			if(pPort->pParentCardExt->CardType == SiPCI)
			{
				SpxCopyBytes(	&channelControl->hi_txbuf[channelControl->hi_txipos],
								InputBuffer,
								sizeOfFirstMove);
			}
			else
			{
				RtlMoveMemory(	&channelControl->hi_txbuf[channelControl->hi_txipos],
								InputBuffer,
								sizeOfFirstMove);
			}

			if(pPort->pParentCardExt->CardType == SiPCI)
			{
				SpxCopyBytes(	&channelControl->hi_txbuf[0],
								InputBuffer + sizeOfFirstMove,
								nchars - sizeOfFirstMove);
			}
			else
			{
				RtlMoveMemory(	&channelControl->hi_txbuf[0],
								InputBuffer + sizeOfFirstMove,
								nchars - sizeOfFirstMove);
			}
        }

		pPort->DataInTxBuffer = TRUE;	// Set flag to indicate we have placed data in Tx buffer on card.

        channelControl->hi_txipos += nchars;
		pPort->PerfStats.TransmittedCount += nchars;	// Increment counter for performance stats.

#ifdef WMI_SUPPORT 
		pPort->WmiPerfData.TransmittedCount += nchars;
#endif
    }

    return nchars;
}


void	SpxCopyBytes(PUCHAR To, PUCHAR From,ULONG Count)
{
	while(Count--) *To++ = *From++;

} /* SpxCopyBytes */

/***************************************************************************\
*                                                                           *
* ULONG Slxos_GetCharsInTxBuffer(IN PVOID Context)                          *
*                                                                           *
* This routine is used to return the number of characters stored in the     *
* hardware transmit buffer.                                                 *
*                                                                           *
* Context - really the current device extension.                            *
*                                                                           *
* Return Value:                                                             *
*           This routine returns the number of characters in the            *
*           transmit buffer.                                                *
*                                                                           *
\***************************************************************************/
ULONG Slxos_GetCharsInTxBuffer(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    UCHAR nchars;

    nchars = (CHAR)channelControl->hi_txipos - (CHAR)channelControl->hi_txopos;

    return nchars;
}

/***************************************************************************\
*                                                                           *
* BOOLEAN SendTxChar(IN PPORT_DEVICE_EXTENSION pPort)						*
*                                                                           *
\***************************************************************************/
BOOLEAN SendTxChar(IN PPORT_DEVICE_EXTENSION pPort)
{
    PCHAN channelControl = (PCHAN)pPort->pChannel;
    ULONG nchars;

    if(pPort->WriteLength || pPort->TransmitImmediate) 
	{

        //
        // Even though all of the characters being
        // sent haven't all been sent, this variable
        // will be checked when the transmit queue is
        // empty.  If it is still true and there is a
        // wait on the transmit queue being empty then
        // we know we finished transmitting all characters
        // following the initiation of the wait since
        // the code that initiates the wait will set
        // this variable to false.
        //
        // One reason it could be false is that
        // the writes were cancelled before they
        // actually started, or that the writes
        // failed due to timeouts.  This variable
        // basically says a character was written
        // by the isr at some point following the
        // initiation of the wait.
        //

        pPort->EmptiedTransmit = TRUE;

        //
        // If we have output flow control based on
        // the modem status lines, then we have to do
        // all the modem work before we output each
        // character. (Otherwise we might miss a
        // status line change.)
        //

        if(pPort->TransmitImmediate && (!pPort->TXHolding || (pPort->TXHolding == SERIAL_TX_XOFF))) 
		{

            //
            // Even if transmission is being held
            // up, we should still transmit an immediate
            // character if all that is holding us
            // up is xon/xoff (OS/2 rules).
            //
            SpxDbgMsg(SERDIAG1, ("%s: slxos_txint. TransmitImmediate.\n",PRODUCT_NAME));

            if(CopyCharsToTxBuffer(pPort, &pPort->ImmediateChar, 1) != 0) 
			{
				pPort->TransmitImmediate = FALSE;

				KeInsertQueueDpc(&pPort->CompleteImmediateDpc, NULL, NULL);
            }
        } 
		else if(!pPort->TXHolding) 
		{

            nchars = CopyCharsToTxBuffer(pPort, pPort->WriteCurrentChar, pPort->WriteLength);

            pPort->WriteCurrentChar += nchars;
            pPort->WriteLength -= nchars;

            if(!pPort->WriteLength) 
			{
                PIO_STACK_LOCATION IrpSp;

                //
                // No more characters left.  This write is complete.  
                // Take care when updating the information field, 
                // we could have an xoff counter masquerading as a write irp.
                //

                IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);

                pPort->CurrentWriteIrp->IoStatus.Information
                     = (IrpSp->MajorFunction == IRP_MJ_WRITE) 
					 ? (IrpSp->Parameters.Write.Length) : (1);

				KeInsertQueueDpc(&pPort->CompleteWriteDpc, NULL, NULL);
	                   
            }

        }
    }

    return TRUE;
}

/*****************************************************************************
******************************                 *******************************
******************************   slxos_rxint   *******************************
******************************                 *******************************
******************************************************************************

Prototype:	void	slxos_rxint(IN PPORT_DEVICE_EXTENSION pPort)

Description:	Check for and transfer receive data for the specified device

Parameters:	pPort points to the extension structure for the device

Returns:	None

NOTE:		This routine is only called at device level.

*/

void slxos_rxint(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCHAN	pChan = (PCHAN)pPort->pChannel;
	UCHAR	out = pChan->hi_rxopos;
	UCHAR	in;
#ifdef	ESIL_XXX0				/* ESIL_XXX0 15/20/98 */
	UCHAR	svout = pPort->saved_hi_rxopos;
	UCHAR	svin;
#endif						/* ESIL_XXX0 15/20/98 */
	int	len;

#ifdef	ESIL_XXX0				/* ESIL_XXX0 15/20/98 */
	while((svin = pPort->saved_hi_rxipos) != svout)
	{
		if(pPort->RXHolding & (SERIAL_RX_XOFF|SERIAL_RX_RTS|SERIAL_RX_DTR)) 
			break;/* Flowed off */
		
		if(svout <= svin)	
			len = svin - svout;		/* Length of block to copy */
		else			
			len = 0x100 - svout;	/* Length of block to end of buffer */
		
		if(len == 0)	
			break;					/* Buffer is empty, done */

		svout += SerialPutBlock(pPort, &pPort->saved_hi_rxbuf[svout], (UCHAR)len, TRUE);
		pPort->saved_hi_rxopos = svout;						/* Update output pointer on card */
	}
#endif						/* ESIL_XXX0 15/20/98 */

	while((in = pChan->hi_rxipos) != out)
	{
		if(pPort->RXHolding & (SERIAL_RX_XOFF|SERIAL_RX_RTS|SERIAL_RX_DTR)) 
			break;	/* Flowed off */
		
		if(out <= in)	
			len = in - out;			/* Length of block to copy */
		else		
			len = 0x100 - out;		/* Length of block to end of buffer */
		
		if(len == 0)	
			break;					/* Buffer is empty, done */

		out += SerialPutBlock(pPort, &pChan->hi_rxbuf[out], (UCHAR)len, TRUE);/* Copy block & update output pointer (and wrap) */
	}

	pChan->hi_rxopos = out;			/* Update output pointer on card */

} /* slxos_rxint */

/*****************************************************************************
*******************************                *******************************
*******************************   slxos_mint   *******************************
*******************************                *******************************
******************************************************************************

Prototype:	void	slxos_mint(IN PPORT_DEVICE_EXTENSION pPort)

Description:	Check for and report changes in input modem signals

Parameters:	pPort points to the extension structure for the device

Returns:	None

NOTE:		This routine is only called at device level.

*/

void slxos_mint(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCHAN pChan = (PCHAN)pPort->pChannel;

	SerialHandleModemUpdate(pPort);

} /* slxos_mint */



/************************************************
*
*	DisplayCompletedIrp((PIRP Irp,int index))
*
*************************************************/
#ifdef	CHECK_COMPLETED
void	DisplayCompletedIrp(PIRP Irp,int index)
{
	PIO_STACK_LOCATION	IrpSp;

	IrpSp = IoGetCurrentIrpStackLocation(Irp);

	if(IrpSp->MajorFunction == IRP_MJ_WRITE)
	{
		SpxDbgMsg(SERDEBUG,("Complete WRITE Irp %lX at %d\n",Irp,index));
	}

	if(IrpSp->MajorFunction == IRP_MJ_READ)
	{
		int	loop, len;

		SpxDbgMsg(SERDEBUG,("Complete READ Irp %lX at %d, requested %d, returned %d [",
			Irp, index, IrpSp->Parameters.Read.Length, Irp->IoStatus.Information));

		len = Irp->IoStatus.Information;

		if(len > 10) 
			len = 10;

		for(loop=0; loop<len; loop++)
			SpxDbgMsg(SERDEBUG,("%02X ", ((PUCHAR)Irp->AssociatedIrp.SystemBuffer)[loop]));

		SpxDbgMsg(SERDEBUG,("]\n"));
	}

} /* DisplayCompletedIrp */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\spx_pnp.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_PNP.C															*
*																						*
*	Creation:		27th September 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Generic Plug and Play Functions	to handle PnP IRPS.					*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/

#define FILE_ID		SPX_PNP_C		// File ID for Event Logging see SPX_DEFS.H for values.

 
/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp);
NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard);
NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp);
NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort);
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject);


// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_AddDevice)
#pragma alloc_text (PAGE, Spx_DispatchPnp)

#pragma alloc_text (PAGE, Spx_Card_FDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Card_StartDevice)
#pragma alloc_text (PAGE, Spx_Card_StopDevice)
#pragma alloc_text (PAGE, Spx_Card_RemoveDevice)

#pragma alloc_text (PAGE, Spx_CallDriverBelow)

#pragma alloc_text (PAGE, Spx_Port_PDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Port_StartDevice)
#pragma alloc_text (PAGE, Spx_Port_StopDevice)
#pragma alloc_text (PAGE, Spx_Port_RemoveDevice)

#pragma alloc_text (PAGE, Spx_EnumPorts)
#pragma alloc_text (PAGE, Spx_DoExternalNaming)
#pragma alloc_text (PAGE, Spx_GetExternalName)
#pragma alloc_text (PAGE, Spx_RemoveExternalNaming)
#pragma alloc_text (PAGE, Spx_CreatePortInstanceID)
#endif


#include <initguid.h>
#include <ntddser.h>


/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_AddDevice   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)

description:	Create a functional device object (FDO) for the specified card physical device object.

parameters:		pDriver point to the driver object
				pPDO points to a card physical device object (PDO)

returns:		STATUS_SUCCESS
				STATUS_NO_MORE_ENTRIES
*/

NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)
{
	NTSTATUS				status = STATUS_SUCCESS;
	PDEVICE_OBJECT			pDevObject = NULL;
	PCARD_DEVICE_EXTENSION	pCard = NULL;
	PDEVICE_OBJECT			pLowerDevObject = NULL;
	static ULONG			CardNumber = 0;
	ULONG					i = 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_AddDevice.\n", PRODUCT_NAME));

	if(pPDO == NULL)
	{
		SpxDbgMsg(SPX_MISC_DBG, ("%s: In Spx_AddDevice - No more entries.\n", PRODUCT_NAME));
		return(STATUS_NO_MORE_ENTRIES);
	}

/* Create the device object... */

	status = IoCreateDevice(pDriverObject,
							sizeof(CARD_DEVICE_EXTENSION),
							NULL, 							// Doesn't need a name.
							FILE_DEVICE_CONTROLLER, 
							FILE_DEVICE_SECURE_OPEN, 
							TRUE, 
							&pDevObject);

	if(!SPX_SUCCESS(status))
	{
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed for card %d. CardExt at 0x%X.\n",
			PRODUCT_NAME,CardNumber++,&pDevObject));

		sprintf(szErrorMsg, "Card %d: Failed IoCreateDevice.", CardNumber++);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pDriverObject,					// Driver Object
						NULL,							// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		if(pDevObject)					// Clean up Device Object
			IoDeleteDevice(pDevObject);

		SpxDbgMsg(SPX_ERRORS, ("%s: Leaving Spx_AddDevice - FAILURE.\n", PRODUCT_NAME));
		return(status);
	}


	ASSERT(pDevObject != NULL);

/* Initialise the device extension... */

	pCard = pDevObject->DeviceExtension;							/* Point to card extension */
	RtlZeroMemory(pCard,sizeof(CARD_DEVICE_EXTENSION));				/* Zero extension structure */

	pDevObject->Flags |= DO_POWER_PAGABLE;				// Get power IRPs at IRQL PASSIVE_LEVEL 
	pDevObject->Flags &= ~DO_DEVICE_INITIALIZING;
	pLowerDevObject = IoAttachDeviceToDeviceStack(pDevObject,pPDO);	/* Attach to device stack */
	ASSERT(pLowerDevObject != NULL);

	KeInitializeSpinLock(&pCard->PnpPowerFlagsLock);	/* Initialise the PNP flags lock */
	ClearPnpPowerFlags(pCard,PPF_STARTED);				/* Not started yet */
	ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);			/* Not pending a stop */
	ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);		/* Not pending a remove */

	pCard->IsFDO = TRUE;								/* Card Object is a Functional Device Object (FDO) */
	pCard->CardNumber = CardNumber++;					/* Enumerate card devices */
	pCard->DeviceObject = pDevObject;					/* Back pointer to device object */
	pCard->LowerDeviceObject= pLowerDevObject;			/* Pointer to device below in device stack */
	pCard->DriverObject = pDriverObject;				/* Pointer to driver object */
	pCard->PDO = pPDO;									/* Pointer to card physical device object (PDO) */
    pCard->DeviceState = PowerDeviceD0;					/* Initial power state */
	pCard->SystemState = PowerSystemWorking;			/* System in full power State */
	pCard->NumPDOs = 0;									/* Initialise attached port PDO pointers */

	for(i=0; i<PRODUCT_MAX_PORTS; i++)
		pCard->AttachedPDO[i] = NULL;

	SetPnpPowerFlags(pCard,PPF_POWERED);				/* Initially assumed we are powered */

	XXX_CardInit(pCard);								/* Initialise non-hardware extension fields */

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Leaving Spx_AddDevice - SUCCESS.\n",PRODUCT_NAME));

	return(status);

} /* Spx_AddDevice */

/*****************************************************************************
****************************                     *****************************
****************************   Spx_DispatchPnp   *****************************
****************************                     *****************************
******************************************************************************

prototype:		NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	The plug and play dispatch routine.
				Determines whether IRP is for a card or a port and calls other functions to handle it. 

parameters:		pDevObject points to a device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PCOMMON_OBJECT_DATA		CommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
	NTSTATUS				status = STATUS_SUCCESS;
	
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(CommonData->IsFDO)									/* Functional Device Object ? */
		status = Spx_Card_FDO_DispatchPnp(pDevObject,pIrp);	/* Yes, must be card device */
	else	
		status = Spx_Port_PDO_DispatchPnp(pDevObject,pIrp);	/* No, must be port device */

	return(status);

} /* Spx_DispatchPnp */

/*****************************************************************************
************************                              ************************
************************   Spx_Card_FDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)

description:	The plug and play dispatch routine to handle IRPs for card devices.

parameters:		pDevObject points to a card device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)
{
	PCARD_DE