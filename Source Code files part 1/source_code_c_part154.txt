r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2930_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2930_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2947_Chain4WordMove_00000003_00000009_00000000_id	:
		S_2947_Chain4WordMove_00000003_00000009_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2947)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2927if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2927if_f_id	:
		L13_2927if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L22_209if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2948_CopyWord4PlaneChain4_00000003_00000009_00000000_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2948_CopyWord4PlaneChain4_00000003_00000009_00000000_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_210if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_210if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_209if_f_id	:
		L22_209if_f:	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2948_CopyWord4PlaneChain4_00000003_00000009_00000000_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2948_CopyWord4PlaneChain4_00000003_00000009_00000000_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_210if_d_id	:
		L22_210if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2948_CopyWord4PlaneChain4_00000003_00000009_00000000_00000000_id	:
		S_2948_CopyWord4PlaneChain4_00000003_00000009_00000000_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2948)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2928if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2928if_f_id	:
		L13_2928if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_964if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_967w_d;	
	case	L23_966w_t_id	:
		L23_966w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_966w_t;	
	case	L23_967w_d_id	:
		L23_967w_d:	;	
	{	extern	IUH	L23_965if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_965if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_964if_f_id	:
		L23_964if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_969w_d;	
	case	L23_968w_t_id	:
		L23_968w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_968w_t;	
	case	L23_969w_d_id	:
		L23_969w_d:	;	
	case	L23_965if_d_id	:
		L23_965if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2949_Chain4WordMove_00000003_0000000e_00000000_id	:
		S_2949_Chain4WordMove_00000003_0000000e_00000000	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2949)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2929if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2929if_f_id	:
		L13_2929if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L22_211if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2950_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2950_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_212if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_212if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_211if_f_id	:
		L22_211if_f:	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2950_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2950_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_212if_d_id	:
		L22_212if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sevid028.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001_id,
L13_2962if_f_id,
L23_1034w_t_id,
L23_1036if_f_id,
L23_1035w_d_id,
L23_1032if_f_id,
L23_1037w_t_id,
L23_1039if_f_id,
L23_1038w_d_id,
L23_1033if_d_id,
S_2983_Chain4ByteMove_00000000_00000019_00000001_id,
L13_2963if_f_id,
L22_233if_f_id,
L22_234if_d_id,
S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001_id,
L13_2964if_f_id,
L23_1042w_t_id,
L23_1043w_d_id,
L23_1040if_f_id,
L23_1044w_t_id,
L23_1045w_d_id,
L23_1041if_d_id,
S_2985_Chain4ByteMove_00000000_0000001e_00000001_id,
L13_2965if_f_id,
L22_235if_f_id,
L22_236if_d_id,
S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001_id,
L13_2966if_f_id,
L23_1048w_t_id,
L23_1050if_f_id,
L23_1049w_d_id,
L23_1046if_f_id,
L23_1051w_t_id,
L23_1053if_f_id,
L23_1052w_d_id,
L23_1047if_d_id,
S_2987_Chain4ByteMove_00000000_0000001f_00000001_id,
L13_2967if_f_id,
L22_237if_f_id,
L22_238if_d_id,
S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001_id,
L13_2968if_f_id,
L23_1056w_t_id,
L23_1057w_d_id,
L23_1054if_f_id,
L23_1058w_t_id,
L23_1059w_d_id,
L23_1055if_d_id,
S_2989_Chain4WordMove_00000000_00000008_00000001_id,
L13_2969if_f_id,
L22_239if_f_id,
L22_240if_d_id,
S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001_id,
L13_2970if_f_id,
S_2991_Chain4WordMove_00000000_00000009_00000001_id,
L13_2971if_f_id,
L22_241if_f_id,
L22_242if_d_id,
S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001_id,
L13_2972if_f_id,
L23_1062w_t_id,
L23_1063w_d_id,
L23_1060if_f_id,
L23_1064w_t_id,
L23_1065w_d_id,
L23_1061if_d_id,
S_2993_Chain4WordMove_00000000_0000000e_00000001_id,
L13_2973if_f_id,
L22_243if_f_id,
L22_244if_d_id,
S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001_id,
L13_2974if_f_id,
S_2995_Chain4WordMove_00000000_0000000f_00000001_id,
L13_2975if_f_id,
L22_245if_f_id,
L22_246if_d_id,
S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001_id,
L13_2976if_f_id,
L23_1068w_t_id,
L23_1069w_d_id,
L23_1066if_f_id,
L23_1070w_t_id,
L23_1071w_d_id,
L23_1067if_d_id,
S_2997_Chain4WordMove_00000000_00000010_00000001_id,
L13_2977if_f_id,
L22_247if_f_id,
L22_248if_d_id,
S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001_id,
L13_2978if_f_id,
S_2999_Chain4WordMove_00000000_00000011_00000001_id,
L13_2979if_f_id,
L22_249if_f_id,
L22_250if_d_id,
S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001_id,
L13_2980if_f_id,
L23_1074w_t_id,
L23_1075w_d_id,
L23_1072if_f_id,
L23_1076w_t_id,
L23_1077w_d_id,
L23_1073if_d_id,
S_3001_Chain4WordMove_00000000_00000016_00000001_id,
L13_2981if_f_id,
L22_251if_f_id,
L22_252if_d_id,
S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001_id,
L13_2982if_f_id,
S_3003_Chain4WordMove_00000000_00000017_00000001_id,
L13_2983if_f_id,
L22_253if_f_id,
L22_254if_d_id,
S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001_id,
L13_2984if_f_id,
L23_1080w_t_id,
L23_1081w_d_id,
L23_1078if_f_id,
L23_1082w_t_id,
L23_1083w_d_id,
L23_1079if_d_id,
S_3005_Chain4WordMove_00000000_00000018_00000001_id,
L13_2985if_f_id,
L22_255if_f_id,
L22_256if_d_id,
S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001_id,
L13_2986if_f_id,
S_3007_Chain4WordMove_00000000_00000019_00000001_id,
L13_2987if_f_id,
L22_257if_f_id,
L22_258if_d_id,
S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001_id,
L13_2988if_f_id,
L23_1086w_t_id,
L23_1087w_d_id,
L23_1084if_f_id,
L23_1088w_t_id,
L23_1089w_d_id,
L23_1085if_d_id,
S_3009_Chain4WordMove_00000000_0000001e_00000001_id,
L13_2989if_f_id,
L22_259if_f_id,
L22_260if_d_id,
S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001_id,
L13_2990if_f_id,
S_3011_Chain4WordMove_00000000_0000001f_00000001_id,
L13_2991if_f_id,
L22_261if_f_id,
L22_262if_d_id,
S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001_id,
L13_2992if_f_id,
L23_1092w_t_id,
L23_1093w_d_id,
L23_1090if_f_id,
L23_1094w_t_id,
L23_1095w_d_id,
L23_1091if_d_id,
S_3013_Chain4DwordMove_00000000_00000008_00000001_id,
L13_2993if_f_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001 = (IHPE)S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001 ;
LOCAL IUH L13_2962if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2962if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2962if_f = (IHPE)L13_2962if_f ;
LOCAL IUH L23_1034w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1034w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1034w_t = (IHPE)L23_1034w_t ;
LOCAL IUH L23_1036if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1036if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1036if_f = (IHPE)L23_1036if_f ;
LOCAL IUH L23_1035w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1035w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1035w_d = (IHPE)L23_1035w_d ;
LOCAL IUH L23_1032if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1032if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1032if_f = (IHPE)L23_1032if_f ;
LOCAL IUH L23_1037w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1037w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1037w_t = (IHPE)L23_1037w_t ;
LOCAL IUH L23_1039if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1039if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1039if_f = (IHPE)L23_1039if_f ;
LOCAL IUH L23_1038w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1038w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1038w_d = (IHPE)L23_1038w_d ;
LOCAL IUH L23_1033if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1033if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1033if_d = (IHPE)L23_1033if_d ;
GLOBAL IUH S_2983_Chain4ByteMove_00000000_00000019_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2983_Chain4ByteMove_00000000_00000019_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2983_Chain4ByteMove_00000000_00000019_00000001 = (IHPE)S_2983_Chain4ByteMove_00000000_00000019_00000001 ;
LOCAL IUH L13_2963if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2963if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2963if_f = (IHPE)L13_2963if_f ;
LOCAL IUH L22_233if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_233if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_233if_f = (IHPE)L22_233if_f ;
LOCAL IUH L22_234if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_234if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_234if_d = (IHPE)L22_234if_d ;
GLOBAL IUH S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001 = (IHPE)S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001 ;
LOCAL IUH L13_2964if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2964if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2964if_f = (IHPE)L13_2964if_f ;
LOCAL IUH L23_1042w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1042w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1042w_t = (IHPE)L23_1042w_t ;
LOCAL IUH L23_1043w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1043w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1043w_d = (IHPE)L23_1043w_d ;
LOCAL IUH L23_1040if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1040if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1040if_f = (IHPE)L23_1040if_f ;
LOCAL IUH L23_1044w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1044w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1044w_t = (IHPE)L23_1044w_t ;
LOCAL IUH L23_1045w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1045w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1045w_d = (IHPE)L23_1045w_d ;
LOCAL IUH L23_1041if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1041if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1041if_d = (IHPE)L23_1041if_d ;
GLOBAL IUH S_2985_Chain4ByteMove_00000000_0000001e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2985_Chain4ByteMove_00000000_0000001e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2985_Chain4ByteMove_00000000_0000001e_00000001 = (IHPE)S_2985_Chain4ByteMove_00000000_0000001e_00000001 ;
LOCAL IUH L13_2965if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2965if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2965if_f = (IHPE)L13_2965if_f ;
LOCAL IUH L22_235if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_235if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_235if_f = (IHPE)L22_235if_f ;
LOCAL IUH L22_236if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_236if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_236if_d = (IHPE)L22_236if_d ;
GLOBAL IUH S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001 = (IHPE)S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001 ;
LOCAL IUH L13_2966if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2966if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2966if_f = (IHPE)L13_2966if_f ;
LOCAL IUH L23_1048w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1048w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1048w_t = (IHPE)L23_1048w_t ;
LOCAL IUH L23_1050if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1050if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1050if_f = (IHPE)L23_1050if_f ;
LOCAL IUH L23_1049w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1049w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1049w_d = (IHPE)L23_1049w_d ;
LOCAL IUH L23_1046if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1046if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1046if_f = (IHPE)L23_1046if_f ;
LOCAL IUH L23_1051w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1051w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1051w_t = (IHPE)L23_1051w_t ;
LOCAL IUH L23_1053if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1053if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1053if_f = (IHPE)L23_1053if_f ;
LOCAL IUH L23_1052w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1052w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1052w_d = (IHPE)L23_1052w_d ;
LOCAL IUH L23_1047if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1047if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1047if_d = (IHPE)L23_1047if_d ;
GLOBAL IUH S_2987_Chain4ByteMove_00000000_0000001f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2987_Chain4ByteMove_00000000_0000001f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2987_Chain4ByteMove_00000000_0000001f_00000001 = (IHPE)S_2987_Chain4ByteMove_00000000_0000001f_00000001 ;
LOCAL IUH L13_2967if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2967if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2967if_f = (IHPE)L13_2967if_f ;
LOCAL IUH L22_237if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_237if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_237if_f = (IHPE)L22_237if_f ;
LOCAL IUH L22_238if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_238if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_238if_d = (IHPE)L22_238if_d ;
GLOBAL IUH S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001 = (IHPE)S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001 ;
LOCAL IUH L13_2968if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2968if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2968if_f = (IHPE)L13_2968if_f ;
LOCAL IUH L23_1056w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1056w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1056w_t = (IHPE)L23_1056w_t ;
LOCAL IUH L23_1057w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1057w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1057w_d = (IHPE)L23_1057w_d ;
LOCAL IUH L23_1054if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1054if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1054if_f = (IHPE)L23_1054if_f ;
LOCAL IUH L23_1058w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1058w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1058w_t = (IHPE)L23_1058w_t ;
LOCAL IUH L23_1059w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1059w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1059w_d = (IHPE)L23_1059w_d ;
LOCAL IUH L23_1055if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1055if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1055if_d = (IHPE)L23_1055if_d ;
GLOBAL IUH S_2989_Chain4WordMove_00000000_00000008_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2989_Chain4WordMove_00000000_00000008_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2989_Chain4WordMove_00000000_00000008_00000001 = (IHPE)S_2989_Chain4WordMove_00000000_00000008_00000001 ;
LOCAL IUH L13_2969if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2969if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2969if_f = (IHPE)L13_2969if_f ;
LOCAL IUH L22_239if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_239if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_239if_f = (IHPE)L22_239if_f ;
LOCAL IUH L22_240if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_240if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_240if_d = (IHPE)L22_240if_d ;
GLOBAL IUH S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001 = (IHPE)S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001 ;
LOCAL IUH L13_2970if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2970if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2970if_f = (IHPE)L13_2970if_f ;
GLOBAL IUH S_2991_Chain4WordMove_00000000_00000009_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2991_Chain4WordMove_00000000_00000009_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2991_Chain4WordMove_00000000_00000009_00000001 = (IHPE)S_2991_Chain4WordMove_00000000_00000009_00000001 ;
LOCAL IUH L13_2971if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2971if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2971if_f = (IHPE)L13_2971if_f ;
LOCAL IUH L22_241if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_241if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_241if_f = (IHPE)L22_241if_f ;
LOCAL IUH L22_242if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_242if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_242if_d = (IHPE)L22_242if_d ;
GLOBAL IUH S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001 = (IHPE)S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001 ;
LOCAL IUH L13_2972if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2972if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2972if_f = (IHPE)L13_2972if_f ;
LOCAL IUH L23_1062w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1062w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1062w_t = (IHPE)L23_1062w_t ;
LOCAL IUH L23_1063w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1063w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1063w_d = (IHPE)L23_1063w_d ;
LOCAL IUH L23_1060if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1060if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1060if_f = (IHPE)L23_1060if_f ;
LOCAL IUH L23_1064w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1064w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1064w_t = (IHPE)L23_1064w_t ;
LOCAL IUH L23_1065w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1065w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1065w_d = (IHPE)L23_1065w_d ;
LOCAL IUH L23_1061if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1061if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1061if_d = (IHPE)L23_1061if_d ;
GLOBAL IUH S_2993_Chain4WordMove_00000000_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2993_Chain4WordMove_00000000_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2993_Chain4WordMove_00000000_0000000e_00000001 = (IHPE)S_2993_Chain4WordMove_00000000_0000000e_00000001 ;
LOCAL IUH L13_2973if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2973if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2973if_f = (IHPE)L13_2973if_f ;
LOCAL IUH L22_243if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_243if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_243if_f = (IHPE)L22_243if_f ;
LOCAL IUH L22_244if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_244if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_244if_d = (IHPE)L22_244if_d ;
GLOBAL IUH S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001 = (IHPE)S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001 ;
LOCAL IUH L13_2974if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2974if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2974if_f = (IHPE)L13_2974if_f ;
GLOBAL IUH S_2995_Chain4WordMove_00000000_0000000f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2995_Chain4WordMove_00000000_0000000f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2995_Chain4WordMove_00000000_0000000f_00000001 = (IHPE)S_2995_Chain4WordMove_00000000_0000000f_00000001 ;
LOCAL IUH L13_2975if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2975if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2975if_f = (IHPE)L13_2975if_f ;
LOCAL IUH L22_245if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_245if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_245if_f = (IHPE)L22_245if_f ;
LOCAL IUH L22_246if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_246if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_246if_d = (IHPE)L22_246if_d ;
GLOBAL IUH S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001 = (IHPE)S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001 ;
LOCAL IUH L13_2976if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2976if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2976if_f = (IHPE)L13_2976if_f ;
LOCAL IUH L23_1068w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1068w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1068w_t = (IHPE)L23_1068w_t ;
LOCAL IUH L23_1069w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1069w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1069w_d = (IHPE)L23_1069w_d ;
LOCAL IUH L23_1066if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1066if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1066if_f = (IHPE)L23_1066if_f ;
LOCAL IUH L23_1070w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1070w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1070w_t = (IHPE)L23_1070w_t ;
LOCAL IUH L23_1071w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1071w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1071w_d = (IHPE)L23_1071w_d ;
LOCAL IUH L23_1067if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1067if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1067if_d = (IHPE)L23_1067if_d ;
GLOBAL IUH S_2997_Chain4WordMove_00000000_00000010_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2997_Chain4WordMove_00000000_00000010_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2997_Chain4WordMove_00000000_00000010_00000001 = (IHPE)S_2997_Chain4WordMove_00000000_00000010_00000001 ;
LOCAL IUH L13_2977if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2977if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2977if_f = (IHPE)L13_2977if_f ;
LOCAL IUH L22_247if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_247if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_247if_f = (IHPE)L22_247if_f ;
LOCAL IUH L22_248if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_248if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_248if_d = (IHPE)L22_248if_d ;
GLOBAL IUH S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001 = (IHPE)S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001 ;
LOCAL IUH L13_2978if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2978if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2978if_f = (IHPE)L13_2978if_f ;
GLOBAL IUH S_2999_Chain4WordMove_00000000_00000011_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_2999_Chain4WordMove_00000000_00000011_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_2999_Chain4WordMove_00000000_00000011_00000001 = (IHPE)S_2999_Chain4WordMove_00000000_00000011_00000001 ;
LOCAL IUH L13_2979if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2979if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2979if_f = (IHPE)L13_2979if_f ;
LOCAL IUH L22_249if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_249if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_249if_f = (IHPE)L22_249if_f ;
LOCAL IUH L22_250if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_250if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_250if_d = (IHPE)L22_250if_d ;
GLOBAL IUH S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001 = (IHPE)S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001 ;
LOCAL IUH L13_2980if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2980if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2980if_f = (IHPE)L13_2980if_f ;
LOCAL IUH L23_1074w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1074w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1074w_t = (IHPE)L23_1074w_t ;
LOCAL IUH L23_1075w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1075w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1075w_d = (IHPE)L23_1075w_d ;
LOCAL IUH L23_1072if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1072if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1072if_f = (IHPE)L23_1072if_f ;
LOCAL IUH L23_1076w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1076w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1076w_t = (IHPE)L23_1076w_t ;
LOCAL IUH L23_1077w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1077w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1077w_d = (IHPE)L23_1077w_d ;
LOCAL IUH L23_1073if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1073if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1073if_d = (IHPE)L23_1073if_d ;
GLOBAL IUH S_3001_Chain4WordMove_00000000_00000016_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3001_Chain4WordMove_00000000_00000016_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3001_Chain4WordMove_00000000_00000016_00000001 = (IHPE)S_3001_Chain4WordMove_00000000_00000016_00000001 ;
LOCAL IUH L13_2981if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2981if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2981if_f = (IHPE)L13_2981if_f ;
LOCAL IUH L22_251if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_251if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_251if_f = (IHPE)L22_251if_f ;
LOCAL IUH L22_252if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_252if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_252if_d = (IHPE)L22_252if_d ;
GLOBAL IUH S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001 = (IHPE)S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001 ;
LOCAL IUH L13_2982if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2982if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2982if_f = (IHPE)L13_2982if_f ;
GLOBAL IUH S_3003_Chain4WordMove_00000000_00000017_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3003_Chain4WordMove_00000000_00000017_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3003_Chain4WordMove_00000000_00000017_00000001 = (IHPE)S_3003_Chain4WordMove_00000000_00000017_00000001 ;
LOCAL IUH L13_2983if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2983if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2983if_f = (IHPE)L13_2983if_f ;
LOCAL IUH L22_253if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_253if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_253if_f = (IHPE)L22_253if_f ;
LOCAL IUH L22_254if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_254if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_254if_d = (IHPE)L22_254if_d ;
GLOBAL IUH S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001 = (IHPE)S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001 ;
LOCAL IUH L13_2984if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2984if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2984if_f = (IHPE)L13_2984if_f ;
LOCAL IUH L23_1080w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1080w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1080w_t = (IHPE)L23_1080w_t ;
LOCAL IUH L23_1081w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1081w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1081w_d = (IHPE)L23_1081w_d ;
LOCAL IUH L23_1078if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1078if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1078if_f = (IHPE)L23_1078if_f ;
LOCAL IUH L23_1082w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1082w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1082w_t = (IHPE)L23_1082w_t ;
LOCAL IUH L23_1083w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1083w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1083w_d = (IHPE)L23_1083w_d ;
LOCAL IUH L23_1079if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1079if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1079if_d = (IHPE)L23_1079if_d ;
GLOBAL IUH S_3005_Chain4WordMove_00000000_00000018_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3005_Chain4WordMove_00000000_00000018_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3005_Chain4WordMove_00000000_00000018_00000001 = (IHPE)S_3005_Chain4WordMove_00000000_00000018_00000001 ;
LOCAL IUH L13_2985if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2985if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2985if_f = (IHPE)L13_2985if_f ;
LOCAL IUH L22_255if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_255if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_255if_f = (IHPE)L22_255if_f ;
LOCAL IUH L22_256if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_256if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_256if_d = (IHPE)L22_256if_d ;
GLOBAL IUH S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001 = (IHPE)S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001 ;
LOCAL IUH L13_2986if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2986if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2986if_f = (IHPE)L13_2986if_f ;
GLOBAL IUH S_3007_Chain4WordMove_00000000_00000019_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3007_Chain4WordMove_00000000_00000019_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3007_Chain4WordMove_00000000_00000019_00000001 = (IHPE)S_3007_Chain4WordMove_00000000_00000019_00000001 ;
LOCAL IUH L13_2987if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2987if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2987if_f = (IHPE)L13_2987if_f ;
LOCAL IUH L22_257if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_257if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_257if_f = (IHPE)L22_257if_f ;
LOCAL IUH L22_258if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_258if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_258if_d = (IHPE)L22_258if_d ;
GLOBAL IUH S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001 = (IHPE)S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001 ;
LOCAL IUH L13_2988if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2988if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2988if_f = (IHPE)L13_2988if_f ;
LOCAL IUH L23_1086w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1086w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1086w_t = (IHPE)L23_1086w_t ;
LOCAL IUH L23_1087w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1087w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1087w_d = (IHPE)L23_1087w_d ;
LOCAL IUH L23_1084if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1084if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1084if_f = (IHPE)L23_1084if_f ;
LOCAL IUH L23_1088w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1088w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1088w_t = (IHPE)L23_1088w_t ;
LOCAL IUH L23_1089w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1089w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1089w_d = (IHPE)L23_1089w_d ;
LOCAL IUH L23_1085if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1085if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1085if_d = (IHPE)L23_1085if_d ;
GLOBAL IUH S_3009_Chain4WordMove_00000000_0000001e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3009_Chain4WordMove_00000000_0000001e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3009_Chain4WordMove_00000000_0000001e_00000001 = (IHPE)S_3009_Chain4WordMove_00000000_0000001e_00000001 ;
LOCAL IUH L13_2989if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2989if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2989if_f = (IHPE)L13_2989if_f ;
LOCAL IUH L22_259if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_259if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_259if_f = (IHPE)L22_259if_f ;
LOCAL IUH L22_260if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_260if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_260if_d = (IHPE)L22_260if_d ;
GLOBAL IUH S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001 = (IHPE)S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001 ;
LOCAL IUH L13_2990if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2990if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2990if_f = (IHPE)L13_2990if_f ;
GLOBAL IUH S_3011_Chain4WordMove_00000000_0000001f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3011_Chain4WordMove_00000000_0000001f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3011_Chain4WordMove_00000000_0000001f_00000001 = (IHPE)S_3011_Chain4WordMove_00000000_0000001f_00000001 ;
LOCAL IUH L13_2991if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2991if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2991if_f = (IHPE)L13_2991if_f ;
LOCAL IUH L22_261if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_261if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_261if_f = (IHPE)L22_261if_f ;
LOCAL IUH L22_262if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_262if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_262if_d = (IHPE)L22_262if_d ;
GLOBAL IUH S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001 = (IHPE)S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001 ;
LOCAL IUH L13_2992if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2992if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2992if_f = (IHPE)L13_2992if_f ;
LOCAL IUH L23_1092w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1092w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1092w_t = (IHPE)L23_1092w_t ;
LOCAL IUH L23_1093w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1093w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1093w_d = (IHPE)L23_1093w_d ;
LOCAL IUH L23_1090if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1090if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1090if_f = (IHPE)L23_1090if_f ;
LOCAL IUH L23_1094w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1094w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1094w_t = (IHPE)L23_1094w_t ;
LOCAL IUH L23_1095w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1095w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1095w_d = (IHPE)L23_1095w_d ;
LOCAL IUH L23_1091if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1091if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1091if_d = (IHPE)L23_1091if_d ;
GLOBAL IUH S_3013_Chain4DwordMove_00000000_00000008_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3013_Chain4DwordMove_00000000_00000008_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3013_Chain4DwordMove_00000000_00000008_00000001 = (IHPE)S_3013_Chain4DwordMove_00000000_00000008_00000001 ;
LOCAL IUH L13_2993if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2993if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2993if_f = (IHPE)L13_2993if_f ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	case	S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001_id	:
		S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2982)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2962if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2962if_f_id	:
		L13_2962if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1032if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1035w_d;	
	case	L23_1034w_t_id	:
		L23_1034w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1036if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1036if_f_id	:
		L23_1036if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1034w_t;	
	case	L23_1035w_d_id	:
		L23_1035w_d:	;	
	{	extern	IUH	L23_1033if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1033if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1032if_f_id	:
		L23_1032if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1038w_d;	
	case	L23_1037w_t_id	:
		L23_1037w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r20)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1039if_f;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1039if_f_id	:
		L23_1039if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1037w_t;	
	case	L23_1038w_d_id	:
		L23_1038w_d:	;	
	case	L23_1033if_d_id	:
		L23_1033if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2983_Chain4ByteMove_00000000_00000019_00000001_id	:
		S_2983_Chain4ByteMove_00000000_00000019_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2983)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2963if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2963if_f_id	:
		L13_2963if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_233if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	{	extern	IUH	L22_234if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_234if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_233if_f_id	:
		L22_233if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	case	L22_234if_d_id	:
		L22_234if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001_id	:
		S_2984_CopyByte4PlaneChain4_00000000_00000019_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2984)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2964if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2964if_f_id	:
		L13_2964if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1040if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1043w_d;	
	case	L23_1042w_t_id	:
		L23_1042w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1042w_t;	
	case	L23_1043w_d_id	:
		L23_1043w_d:	;	
	{	extern	IUH	L23_1041if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1041if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1040if_f_id	:
		L23_1040if_f:	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1045w_d;	
	case	L23_1044w_t_id	:
		L23_1044w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1044w_t;	
	case	L23_1045w_d_id	:
		L23_1045w_d:	;	
	case	L23_1041if_d_id	:
		L23_1041if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2985_Chain4ByteMove_00000000_0000001e_00000001_id	:
		S_2985_Chain4ByteMove_00000000_0000001e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2985)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2965if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2965if_f_id	:
		L13_2965if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_235if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	{	extern	IUH	L22_236if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_236if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_235if_f_id	:
		L22_235if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	case	L22_236if_d_id	:
		L22_236if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001_id	:
		S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2986)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2966if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2966if_f_id	:
		L13_2966if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1046if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1049w_d;	
	case	L23_1048w_t_id	:
		L23_1048w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1050if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1050if_f_id	:
		L23_1050if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1048w_t;	
	case	L23_1049w_d_id	:
		L23_1049w_d:	;	
	{	extern	IUH	L23_1047if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1047if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1046if_f_id	:
		L23_1046if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1052w_d;	
	case	L23_1051w_t_id	:
		L23_1051w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1053if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1053if_f_id	:
		L23_1053if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1051w_t;	
	case	L23_1052w_d_id	:
		L23_1052w_d:	;	
	case	L23_1047if_d_id	:
		L23_1047if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2987_Chain4ByteMove_00000000_0000001f_00000001_id	:
		S_2987_Chain4ByteMove_00000000_0000001f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2987)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2967if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2967if_f_id	:
		L13_2967if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_237if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	{	extern	IUH	L22_238if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_238if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_237if_f_id	:
		L22_237if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	case	L22_238if_d_id	:
		L22_238if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001_id	:
		S_2988_CopyByte4PlaneChain4_00000000_0000001f_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2988)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2968if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2968if_f_id	:
		L13_2968if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1054if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1057w_d;	
	case	L23_1056w_t_id	:
		L23_1056w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1056w_t;	
	case	L23_1057w_d_id	:
		L23_1057w_d:	;	
	{	extern	IUH	L23_1055if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1055if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1054if_f_id	:
		L23_1054if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1059w_d;	
	case	L23_1058w_t_id	:
		L23_1058w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1058w_t;	
	case	L23_1059w_d_id	:
		L23_1059w_d:	;	
	case	L23_1055if_d_id	:
		L23_1055if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2989_Chain4WordMove_00000000_00000008_00000001_id	:
		S_2989_Chain4WordMove_00000000_00000008_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2989)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2969if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2969if_f_id	:
		L13_2969if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_239if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_240if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_240if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_239if_f_id	:
		L22_239if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_240if_d_id	:
		L22_240if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001_id	:
		S_2990_CopyWordPlnByPlnChain4_00000000_00000008_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2990)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2970if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2970if_f_id	:
		L13_2970if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2966_CopyBytePlnByPlnChain4_00000000_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2966_CopyBytePlnByPlnChain4_00000000_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2991_Chain4WordMove_00000000_00000009_00000001_id	:
		S_2991_Chain4WordMove_00000000_00000009_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2991)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2971if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2971if_f_id	:
		L13_2971if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_241if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_242if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_242if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_241if_f_id	:
		L22_241if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_242if_d_id	:
		L22_242if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001_id	:
		S_2992_CopyWord4PlaneChain4_00000000_00000009_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2992)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2972if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2972if_f_id	:
		L13_2972if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1060if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1063w_d;	
	case	L23_1062w_t_id	:
		L23_1062w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1062w_t;	
	case	L23_1063w_d_id	:
		L23_1063w_d:	;	
	{	extern	IUH	L23_1061if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1061if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1060if_f_id	:
		L23_1060if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1065w_d;	
	case	L23_1064w_t_id	:
		L23_1064w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1064w_t;	
	case	L23_1065w_d_id	:
		L23_1065w_d:	;	
	case	L23_1061if_d_id	:
		L23_1061if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2993_Chain4WordMove_00000000_0000000e_00000001_id	:
		S_2993_Chain4WordMove_00000000_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2993)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2973if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2973if_f_id	:
		L13_2973if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_243if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_244if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_244if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_243if_f_id	:
		L22_243if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_244if_d_id	:
		L22_244if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001_id	:
		S_2994_CopyWordPlnByPlnChain4_00000000_0000000e_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2994)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2974if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2974if_f_id	:
		L13_2974if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2970_CopyBytePlnByPlnChain4_00000000_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2970_CopyBytePlnByPlnChain4_00000000_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2995_Chain4WordMove_00000000_0000000f_00000001_id	:
		S_2995_Chain4WordMove_00000000_0000000f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2995)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2975if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2975if_f_id	:
		L13_2975if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_245if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_246if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_246if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_245if_f_id	:
		L22_245if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_246if_d_id	:
		L22_246if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001_id	:
		S_2996_CopyWord4PlaneChain4_00000000_0000000f_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2996)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2976if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2976if_f_id	:
		L13_2976if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1066if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1069w_d;	
	case	L23_1068w_t_id	:
		L23_1068w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1068w_t;	
	case	L23_1069w_d_id	:
		L23_1069w_d:	;	
	{	extern	IUH	L23_1067if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1067if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1066if_f_id	:
		L23_1066if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1071w_d;	
	case	L23_1070w_t_id	:
		L23_1070w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1070w_t;	
	case	L23_1071w_d_id	:
		L23_1071w_d:	;	
	case	L23_1067if_d_id	:
		L23_1067if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2997_Chain4WordMove_00000000_00000010_00000001_id	:
		S_2997_Chain4WordMove_00000000_00000010_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2997)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2977if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2977if_f_id	:
		L13_2977if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_247if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_248if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_248if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_247if_f_id	:
		L22_247if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_248if_d_id	:
		L22_248if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001_id	:
		S_2998_CopyWordPlnByPlnChain4_00000000_00000010_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2998)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2978if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2978if_f_id	:
		L13_2978if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2974_CopyBytePlnByPlnChain4_00000000_00000010_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2974_CopyBytePlnByPlnChain4_00000000_00000010_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_2999_Chain4WordMove_00000000_00000011_00000001_id	:
		S_2999_Chain4WordMove_00000000_00000011_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(2999)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2979if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2979if_f_id	:
		L13_2979if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_249if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_250if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_250if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_249if_f_id	:
		L22_249if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_250if_d_id	:
		L22_250if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001_id	:
		S_3000_CopyWord4PlaneChain4_00000000_00000011_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3000)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2980if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2980if_f_id	:
		L13_2980if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1072if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1075w_d;	
	case	L23_1074w_t_id	:
		L23_1074w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1074w_t;	
	case	L23_1075w_d_id	:
		L23_1075w_d:	;	
	{	extern	IUH	L23_1073if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1073if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1072if_f_id	:
		L23_1072if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1077w_d;	
	case	L23_1076w_t_id	:
		L23_1076w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1076w_t;	
	case	L23_1077w_d_id	:
		L23_1077w_d:	;	
	case	L23_1073if_d_id	:
		L23_1073if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3001_Chain4WordMove_00000000_00000016_00000001_id	:
		S_3001_Chain4WordMove_00000000_00000016_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3001)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2981if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2981if_f_id	:
		L13_2981if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_251if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_252if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_252if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_251if_f_id	:
		L22_251if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_252if_d_id	:
		L22_252if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001_id	:
		S_3002_CopyWordPlnByPlnChain4_00000000_00000016_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3002)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2982if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2982if_f_id	:
		L13_2982if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2978_CopyBytePlnByPlnChain4_00000000_00000016_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2978_CopyBytePlnByPlnChain4_00000000_00000016_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3003_Chain4WordMove_00000000_00000017_00000001_id	:
		S_3003_Chain4WordMove_00000000_00000017_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3003)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2983if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2983if_f_id	:
		L13_2983if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_253if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_254if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_254if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_253if_f_id	:
		L22_253if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_254if_d_id	:
		L22_254if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001_id	:
		S_3004_CopyWord4PlaneChain4_00000000_00000017_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3004)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2984if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2984if_f_id	:
		L13_2984if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1078if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1081w_d;	
	case	L23_1080w_t_id	:
		L23_1080w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1080w_t;	
	case	L23_1081w_d_id	:
		L23_1081w_d:	;	
	{	extern	IUH	L23_1079if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1079if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1078if_f_id	:
		L23_1078if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1083w_d;	
	case	L23_1082w_t_id	:
		L23_1082w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	^	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	^	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1082w_t;	
	case	L23_1083w_d_id	:
		L23_1083w_d:	;	
	case	L23_1079if_d_id	:
		L23_1079if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3005_Chain4WordMove_00000000_00000018_00000001_id	:
		S_3005_Chain4WordMove_00000000_00000018_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3005)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2985if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2985if_f_id	:
		L13_2985if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_255if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_256if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_256if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_255if_f_id	:
		L22_255if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_256if_d_id	:
		L22_256if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001_id	:
		S_3006_CopyWordPlnByPlnChain4_00000000_00000018_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3006)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2986if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2986if_f_id	:
		L13_2986if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2982_CopyBytePlnByPlnChain4_00000000_00000018_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3007_Chain4WordMove_00000000_00000019_00000001_id	:
		S_3007_Chain4WordMove_00000000_00000019_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3007)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2987if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2987if_f_id	:
		L13_2987if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_257if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_258if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_258if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_257if_f_id	:
		L22_257if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_258if_d_id	:
		L22_258if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001_id	:
		S_3008_CopyWord4PlaneChain4_00000000_00000019_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3008)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2988if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2988if_f_id	:
		L13_2988if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1084if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1087w_d;	
	case	L23_1086w_t_id	:
		L23_1086w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1086w_t;	
	case	L23_1087w_d_id	:
		L23_1087w_d:	;	
	{	extern	IUH	L23_1085if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1085if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1084if_f_id	:
		L23_1084if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1089w_d;	
	case	L23_1088w_t_id	:
		L23_1088w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1088w_t;	
	case	L23_1089w_d_id	:
		L23_1089w_d:	;	
	case	L23_1085if_d_id	:
		L23_1085if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3009_Chain4WordMove_00000000_0000001e_00000001_id	:
		S_3009_Chain4WordMove_00000000_0000001e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3009)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2989if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2989if_f_id	:
		L13_2989if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_259if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_260if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_260if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_259if_f_id	:
		L22_259if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_260if_d_id	:
		L22_260if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001_id	:
		S_3010_CopyWordPlnByPlnChain4_00000000_0000001e_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3010)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2990if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2990if_f_id	:
		L13_2990if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2986_CopyBytePlnByPlnChain4_00000000_0000001e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3011_Chain4WordMove_00000000_0000001f_00000001_id	:
		S_3011_Chain4WordMove_00000000_0000001f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3011)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2991if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2991if_f_id	:
		L13_2991if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_261if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_262if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_262if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_261if_f_id	:
		L22_261if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_262if_d_id	:
		L22_262if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001_id	:
		S_3012_CopyWord4PlaneChain4_00000000_0000001f_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3012)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2992if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2992if_f_id	:
		L13_2992if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1090if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1093w_d;	
	case	L23_1092w_t_id	:
		L23_1092w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1092w_t;	
	case	L23_1093w_d_id	:
		L23_1093w_d:	;	
	{	extern	IUH	L23_1091if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1091if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1090if_f_id	:
		L23_1090if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1095w_d;	
	case	L23_1094w_t_id	:
		L23_1094w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1094w_t;	
	case	L23_1095w_d_id	:
		L23_1095w_d:	;	
	case	L23_1091if_d_id	:
		L23_1091if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3013_Chain4DwordMove_00000000_00000008_00000001_id	:
		S_3013_Chain4DwordMove_00000000_00000008_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3013)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2993if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2993if_f_id	:
		L13_2993if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2989_Chain4WordMove_00000000_00000008_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2989_Chain4WordMove_00000000_00000008_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sf_c.h ===
#ifndef _Sf_c_h
#define _Sf_c_h
#define IBM_bit0 (31)
#define IBM_bit1 (30)
#define IBM_bit2 (29)
#define IBM_bit3 (28)
#define IBM_bit4 (27)
#define IBM_bit5 (26)
#define IBM_bit6 (25)
#define IBM_bit7 (24)
#define IBM_bit8 (23)
#define IBM_bit9 (22)
#define IBM_bit10 (21)
#define IBM_bit11 (20)
#define IBM_bit12 (19)
#define IBM_bit13 (18)
#define IBM_bit14 (17)
#define IBM_bit15 (16)
#define IBM_bit16 (15)
#define IBM_bit17 (14)
#define IBM_bit18 (13)
#define IBM_bit19 (12)
#define IBM_bit20 (11)
#define IBM_bit21 (10)
#define IBM_bit22 (9)
#define IBM_bit23 (8)
#define IBM_bit24 (7)
#define IBM_bit25 (6)
#define IBM_bit26 (5)
#define IBM_bit27 (4)
#define IBM_bit28 (3)
#define IBM_bit29 (2)
#define IBM_bit30 (1)
#define IBM_bit31 (0)
#define DecrementerRegWrite (22)
#define DecrementerRegRead (6)
#define HwIntBit (15)
#define HW_ADAPTOR_DW (1)
#define HW_ADAPTOR_W (2)
#define HW_ADAPTOR_B (3)
#define StringFellow (0)
#endif /* ! _Sf_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\shift_c.h ===
#ifndef _Shift_c_h
#define _Shift_c_h
#endif /* ! _Shift_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\simple_c.h ===
#ifndef _Simple_c_h
#define _Simple_c_h
#endif /* ! _Simple_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sinit012.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_0383_CiGetVideomark_word_00000014_id,
S_0384_CiGetVideomark_string_00000015_id,
S_0385_CiGetVideoread_shift_count_00000016_id,
S_0386_CiGetVideoread_mapped_plane_00000017_id,
S_0387_CiGetVideocolour_comp_00000018_id,
S_0388_CiGetVideodont_care_00000019_id,
S_0389_CiGetVideov7_bank_vid_copy_off_0000001a_id,
S_0390_CiGetVideoscreen_ptr_0000001b_id,
S_0391_CiGetVideorotate_0000001c_id,
S_0392_CiGetVideocalc_data_xor_0000001d_id,
S_0393_CiGetVideocalc_latch_xor_0000001e_id,
S_0394_CiGetVideoread_byte_addr_0000001f_id,
S_0395_CiGetVideov7_fg_latches_00000020_id,
S_0396_CiGetVideoGC_regs_00000021_id,
S_0397_CiGetVideolast_GC_index_00000022_id,
S_0398_CiGetVideodither_00000023_id,
S_0399_CiGetVideowrmode_00000024_id,
S_0400_CiGetVideochain_00000025_id,
S_0401_CiGetVideowrstate_00000026_id,
S_0402_CiSetVideolatches_00000027_id,
S_0403_CiSetVideorplane_00000028_id,
S_0404_CiSetVideowplane_00000029_id,
S_0405_CiSetVideoscratch_0000002a_id,
S_0406_CiSetVideosr_masked_val_0000002b_id,
S_0407_CiSetVideosr_nmask_0000002c_id,
S_0408_CiSetVideodata_and_mask_0000002d_id,
S_0409_CiSetVideodata_xor_mask_0000002e_id,
S_0410_CiSetVideolatch_xor_mask_0000002f_id,
S_0411_CiSetVideobit_prot_mask_00000030_id,
S_0412_CiSetVideoplane_enable_00000031_id,
S_0413_CiSetVideoplane_enable_mask_00000032_id,
S_0414_CiSetVideosr_lookup_00000033_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_0383_CiGetVideomark_word_00000014 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0383_CiGetVideomark_word_00000014_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0383_CiGetVideomark_word_00000014 = (IHPE)S_0383_CiGetVideomark_word_00000014 ;
GLOBAL IUH S_0384_CiGetVideomark_string_00000015 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0384_CiGetVideomark_string_00000015_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0384_CiGetVideomark_string_00000015 = (IHPE)S_0384_CiGetVideomark_string_00000015 ;
GLOBAL IUH S_0385_CiGetVideoread_shift_count_00000016 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0385_CiGetVideoread_shift_count_00000016_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0385_CiGetVideoread_shift_count_00000016 = (IHPE)S_0385_CiGetVideoread_shift_count_00000016 ;
GLOBAL IUH S_0386_CiGetVideoread_mapped_plane_00000017 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0386_CiGetVideoread_mapped_plane_00000017_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0386_CiGetVideoread_mapped_plane_00000017 = (IHPE)S_0386_CiGetVideoread_mapped_plane_00000017 ;
GLOBAL IUH S_0387_CiGetVideocolour_comp_00000018 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0387_CiGetVideocolour_comp_00000018_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0387_CiGetVideocolour_comp_00000018 = (IHPE)S_0387_CiGetVideocolour_comp_00000018 ;
GLOBAL IUH S_0388_CiGetVideodont_care_00000019 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0388_CiGetVideodont_care_00000019_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0388_CiGetVideodont_care_00000019 = (IHPE)S_0388_CiGetVideodont_care_00000019 ;
GLOBAL IUH S_0389_CiGetVideov7_bank_vid_copy_off_0000001a IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0389_CiGetVideov7_bank_vid_copy_off_0000001a_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0389_CiGetVideov7_bank_vid_copy_off_0000001a = (IHPE)S_0389_CiGetVideov7_bank_vid_copy_off_0000001a ;
GLOBAL IUH S_0390_CiGetVideoscreen_ptr_0000001b IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0390_CiGetVideoscreen_ptr_0000001b_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0390_CiGetVideoscreen_ptr_0000001b = (IHPE)S_0390_CiGetVideoscreen_ptr_0000001b ;
GLOBAL IUH S_0391_CiGetVideorotate_0000001c IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0391_CiGetVideorotate_0000001c_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0391_CiGetVideorotate_0000001c = (IHPE)S_0391_CiGetVideorotate_0000001c ;
GLOBAL IUH S_0392_CiGetVideocalc_data_xor_0000001d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0392_CiGetVideocalc_data_xor_0000001d_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0392_CiGetVideocalc_data_xor_0000001d = (IHPE)S_0392_CiGetVideocalc_data_xor_0000001d ;
GLOBAL IUH S_0393_CiGetVideocalc_latch_xor_0000001e IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0393_CiGetVideocalc_latch_xor_0000001e_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0393_CiGetVideocalc_latch_xor_0000001e = (IHPE)S_0393_CiGetVideocalc_latch_xor_0000001e ;
GLOBAL IUH S_0394_CiGetVideoread_byte_addr_0000001f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0394_CiGetVideoread_byte_addr_0000001f_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0394_CiGetVideoread_byte_addr_0000001f = (IHPE)S_0394_CiGetVideoread_byte_addr_0000001f ;
GLOBAL IUH S_0395_CiGetVideov7_fg_latches_00000020 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0395_CiGetVideov7_fg_latches_00000020_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0395_CiGetVideov7_fg_latches_00000020 = (IHPE)S_0395_CiGetVideov7_fg_latches_00000020 ;
GLOBAL IUH S_0396_CiGetVideoGC_regs_00000021 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0396_CiGetVideoGC_regs_00000021_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0396_CiGetVideoGC_regs_00000021 = (IHPE)S_0396_CiGetVideoGC_regs_00000021 ;
GLOBAL IUH S_0397_CiGetVideolast_GC_index_00000022 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0397_CiGetVideolast_GC_index_00000022_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0397_CiGetVideolast_GC_index_00000022 = (IHPE)S_0397_CiGetVideolast_GC_index_00000022 ;
GLOBAL IUH S_0398_CiGetVideodither_00000023 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0398_CiGetVideodither_00000023_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0398_CiGetVideodither_00000023 = (IHPE)S_0398_CiGetVideodither_00000023 ;
GLOBAL IUH S_0399_CiGetVideowrmode_00000024 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0399_CiGetVideowrmode_00000024_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0399_CiGetVideowrmode_00000024 = (IHPE)S_0399_CiGetVideowrmode_00000024 ;
GLOBAL IUH S_0400_CiGetVideochain_00000025 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0400_CiGetVideochain_00000025_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0400_CiGetVideochain_00000025 = (IHPE)S_0400_CiGetVideochain_00000025 ;
GLOBAL IUH S_0401_CiGetVideowrstate_00000026 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0401_CiGetVideowrstate_00000026_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0401_CiGetVideowrstate_00000026 = (IHPE)S_0401_CiGetVideowrstate_00000026 ;
GLOBAL IUH S_0402_CiSetVideolatches_00000027 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0402_CiSetVideolatches_00000027_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0402_CiSetVideolatches_00000027 = (IHPE)S_0402_CiSetVideolatches_00000027 ;
GLOBAL IUH S_0403_CiSetVideorplane_00000028 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0403_CiSetVideorplane_00000028_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0403_CiSetVideorplane_00000028 = (IHPE)S_0403_CiSetVideorplane_00000028 ;
GLOBAL IUH S_0404_CiSetVideowplane_00000029 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0404_CiSetVideowplane_00000029_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0404_CiSetVideowplane_00000029 = (IHPE)S_0404_CiSetVideowplane_00000029 ;
GLOBAL IUH S_0405_CiSetVideoscratch_0000002a IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0405_CiSetVideoscratch_0000002a_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0405_CiSetVideoscratch_0000002a = (IHPE)S_0405_CiSetVideoscratch_0000002a ;
GLOBAL IUH S_0406_CiSetVideosr_masked_val_0000002b IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0406_CiSetVideosr_masked_val_0000002b_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0406_CiSetVideosr_masked_val_0000002b = (IHPE)S_0406_CiSetVideosr_masked_val_0000002b ;
GLOBAL IUH S_0407_CiSetVideosr_nmask_0000002c IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0407_CiSetVideosr_nmask_0000002c_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0407_CiSetVideosr_nmask_0000002c = (IHPE)S_0407_CiSetVideosr_nmask_0000002c ;
GLOBAL IUH S_0408_CiSetVideodata_and_mask_0000002d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0408_CiSetVideodata_and_mask_0000002d_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0408_CiSetVideodata_and_mask_0000002d = (IHPE)S_0408_CiSetVideodata_and_mask_0000002d ;
GLOBAL IUH S_0409_CiSetVideodata_xor_mask_0000002e IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0409_CiSetVideodata_xor_mask_0000002e_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0409_CiSetVideodata_xor_mask_0000002e = (IHPE)S_0409_CiSetVideodata_xor_mask_0000002e ;
GLOBAL IUH S_0410_CiSetVideolatch_xor_mask_0000002f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0410_CiSetVideolatch_xor_mask_0000002f_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0410_CiSetVideolatch_xor_mask_0000002f = (IHPE)S_0410_CiSetVideolatch_xor_mask_0000002f ;
GLOBAL IUH S_0411_CiSetVideobit_prot_mask_00000030 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0411_CiSetVideobit_prot_mask_00000030_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0411_CiSetVideobit_prot_mask_00000030 = (IHPE)S_0411_CiSetVideobit_prot_mask_00000030 ;
GLOBAL IUH S_0412_CiSetVideoplane_enable_00000031 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0412_CiSetVideoplane_enable_00000031_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0412_CiSetVideoplane_enable_00000031 = (IHPE)S_0412_CiSetVideoplane_enable_00000031 ;
GLOBAL IUH S_0413_CiSetVideoplane_enable_mask_00000032 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0413_CiSetVideoplane_enable_mask_00000032_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0413_CiSetVideoplane_enable_mask_00000032 = (IHPE)S_0413_CiSetVideoplane_enable_mask_00000032 ;
GLOBAL IUH S_0414_CiSetVideosr_lookup_00000033 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0414_CiSetVideosr_lookup_00000033_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0414_CiSetVideosr_lookup_00000033 = (IHPE)S_0414_CiSetVideosr_lookup_00000033 ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	case	S_0383_CiGetVideomark_word_00000014_id	:
		S_0383_CiGetVideomark_word_00000014	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6597)	;	
	*((IUH	*)&(r21))	=	(IS32)(1360)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6598)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0384_CiGetVideomark_string_00000015_id	:
		S_0384_CiGetVideomark_string_00000015	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6599)	;	
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6600)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0385_CiGetVideoread_shift_count_00000016_id	:
		S_0385_CiGetVideoread_shift_count_00000016	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6601)	;	
	*((IUH	*)&(r20))	=	(IS32)(1368)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6602)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0386_CiGetVideoread_mapped_plane_00000017_id	:
		S_0386_CiGetVideoread_mapped_plane_00000017	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6603)	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6604)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0387_CiGetVideocolour_comp_00000018_id	:
		S_0387_CiGetVideocolour_comp_00000018	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6605)	;	
	*((IUH	*)&(r20))	=	(IS32)(1376)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6606)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0388_CiGetVideodont_care_00000019_id	:
		S_0388_CiGetVideodont_care_00000019	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6607)	;	
	*((IUH	*)&(r20))	=	(IS32)(1380)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6608)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0389_CiGetVideov7_bank_vid_copy_off_0000001a_id	:
		S_0389_CiGetVideov7_bank_vid_copy_off_0000001a	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6609)	;	
	*((IUH	*)&(r20))	=	(IS32)(1384)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6610)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0390_CiGetVideoscreen_ptr_0000001b_id	:
		S_0390_CiGetVideoscreen_ptr_0000001b	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6611)	;	
	*((IUH	*)&(r21))	=	(IS32)(1400)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6612)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0391_CiGetVideorotate_0000001c_id	:
		S_0391_CiGetVideorotate_0000001c	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6613)	;	
	*((IUH	*)&(r20))	=	(IS32)(1404)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6614)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0392_CiGetVideocalc_data_xor_0000001d_id	:
		S_0392_CiGetVideocalc_data_xor_0000001d	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6615)	;	
	*((IUH	*)&(r20))	=	(IS32)(1408)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6616)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0393_CiGetVideocalc_latch_xor_0000001e_id	:
		S_0393_CiGetVideocalc_latch_xor_0000001e	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6617)	;	
	*((IUH	*)&(r20))	=	(IS32)(1412)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6618)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0394_CiGetVideoread_byte_addr_0000001f_id	:
		S_0394_CiGetVideoread_byte_addr_0000001f	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6619)	;	
	*((IUH	*)&(r21))	=	(IS32)(1416)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6620)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0395_CiGetVideov7_fg_latches_00000020_id	:
		S_0395_CiGetVideov7_fg_latches_00000020	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6621)	;	
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6622)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0396_CiGetVideoGC_regs_00000021_id	:
		S_0396_CiGetVideoGC_regs_00000021	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6623)	;	
	*((IUH	*)&(r21))	=	(IS32)(1424)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6624)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0397_CiGetVideolast_GC_index_00000022_id	:
		S_0397_CiGetVideolast_GC_index_00000022	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6625)	;	
	*((IUH	*)&(r20))	=	(IS32)(1428)	;	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6626)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE);	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)&(r20)	+	REGBYTE);	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0398_CiGetVideodither_00000023_id	:
		S_0398_CiGetVideodither_00000023	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6627)	;	
	*((IUH	*)&(r20))	=	(IS32)(1429)	;	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6628)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE);	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)&(r20)	+	REGBYTE);	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0399_CiGetVideowrmode_00000024_id	:
		S_0399_CiGetVideowrmode_00000024	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6629)	;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6630)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE);	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)&(r20)	+	REGBYTE);	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0400_CiGetVideochain_00000025_id	:
		S_0400_CiGetVideochain_00000025	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6631)	;	
	*((IUH	*)&(r20))	=	(IS32)(1431)	;	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6632)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE);	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)&(r20)	+	REGBYTE);	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0401_CiGetVideowrstate_00000026_id	:
		S_0401_CiGetVideowrstate_00000026	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6633)	;	
	*((IUH	*)&(r20))	=	(IS32)(1432)	;	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6634)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE);	
	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	=	*((IU8	*)&(r21)	+	REGBYTE)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)&(r20)	+	REGBYTE);	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0402_CiSetVideolatches_00000027_id	:
		S_0402_CiSetVideolatches_00000027	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6635)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6636)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0403_CiSetVideorplane_00000028_id	:
		S_0403_CiSetVideorplane_00000028	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6637)	;	
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6638)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0404_CiSetVideowplane_00000029_id	:
		S_0404_CiSetVideowplane_00000029	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6639)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6640)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0405_CiSetVideoscratch_0000002a_id	:
		S_0405_CiSetVideoscratch_0000002a	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6641)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6642)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0406_CiSetVideosr_masked_val_0000002b_id	:
		S_0406_CiSetVideosr_masked_val_0000002b	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6643)	;	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6644)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0407_CiSetVideosr_nmask_0000002c_id	:
		S_0407_CiSetVideosr_nmask_0000002c	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6645)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6646)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0408_CiSetVideodata_and_mask_0000002d_id	:
		S_0408_CiSetVideodata_and_mask_0000002d	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6647)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6648)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0409_CiSetVideodata_xor_mask_0000002e_id	:
		S_0409_CiSetVideodata_xor_mask_0000002e	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6649)	;	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6650)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0410_CiSetVideolatch_xor_mask_0000002f_id	:
		S_0410_CiSetVideolatch_xor_mask_0000002f	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6651)	;	
	*((IUH	*)&(r20))	=	(IS32)(1312)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6652)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0411_CiSetVideobit_prot_mask_00000030_id	:
		S_0411_CiSetVideobit_prot_mask_00000030	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6653)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6654)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0412_CiSetVideoplane_enable_00000031_id	:
		S_0412_CiSetVideoplane_enable_00000031	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6655)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6656)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0413_CiSetVideoplane_enable_mask_00000032_id	:
		S_0413_CiSetVideoplane_enable_mask_00000032	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6657)	;	
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6658)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0414_CiSetVideosr_lookup_00000033_id	:
		S_0414_CiSetVideosr_lookup_00000033	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6659)	;	
	*((IUH	*)&(r20))	=	(IS32)(1328)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6660)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sinit011.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_0363_CiGetVideolatches_00000000_id,
S_0364_CiGetVideorplane_00000001_id,
S_0365_CiGetVideowplane_00000002_id,
S_0366_CiGetVideoscratch_00000003_id,
S_0367_CiGetVideosr_masked_val_00000004_id,
S_0368_CiGetVideosr_nmask_00000005_id,
S_0369_CiGetVideodata_and_mask_00000006_id,
S_0370_CiGetVideodata_xor_mask_00000007_id,
S_0371_CiGetVideolatch_xor_mask_00000008_id,
S_0372_CiGetVideobit_prot_mask_00000009_id,
S_0373_CiGetVideoplane_enable_0000000a_id,
S_0374_CiGetVideoplane_enable_mask_0000000b_id,
S_0375_CiGetVideosr_lookup_0000000c_id,
S_0376_CiGetVideofwd_str_read_addr_0000000d_id,
S_0377_CiGetVideobwd_str_read_addr_0000000e_id,
S_0378_CiGetVideodirty_total_0000000f_id,
S_0379_CiGetVideodirty_low_00000010_id,
S_0380_CiGetVideodirty_high_00000011_id,
S_0381_CiGetVideovideo_copy_00000012_id,
S_0382_CiGetVideomark_byte_00000013_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_0363_CiGetVideolatches_00000000 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0363_CiGetVideolatches_00000000_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0363_CiGetVideolatches_00000000 = (IHPE)S_0363_CiGetVideolatches_00000000 ;
GLOBAL IUH S_0364_CiGetVideorplane_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0364_CiGetVideorplane_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0364_CiGetVideorplane_00000001 = (IHPE)S_0364_CiGetVideorplane_00000001 ;
GLOBAL IUH S_0365_CiGetVideowplane_00000002 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0365_CiGetVideowplane_00000002_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0365_CiGetVideowplane_00000002 = (IHPE)S_0365_CiGetVideowplane_00000002 ;
GLOBAL IUH S_0366_CiGetVideoscratch_00000003 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0366_CiGetVideoscratch_00000003_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0366_CiGetVideoscratch_00000003 = (IHPE)S_0366_CiGetVideoscratch_00000003 ;
GLOBAL IUH S_0367_CiGetVideosr_masked_val_00000004 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0367_CiGetVideosr_masked_val_00000004_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0367_CiGetVideosr_masked_val_00000004 = (IHPE)S_0367_CiGetVideosr_masked_val_00000004 ;
GLOBAL IUH S_0368_CiGetVideosr_nmask_00000005 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0368_CiGetVideosr_nmask_00000005_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0368_CiGetVideosr_nmask_00000005 = (IHPE)S_0368_CiGetVideosr_nmask_00000005 ;
GLOBAL IUH S_0369_CiGetVideodata_and_mask_00000006 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0369_CiGetVideodata_and_mask_00000006_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0369_CiGetVideodata_and_mask_00000006 = (IHPE)S_0369_CiGetVideodata_and_mask_00000006 ;
GLOBAL IUH S_0370_CiGetVideodata_xor_mask_00000007 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0370_CiGetVideodata_xor_mask_00000007_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0370_CiGetVideodata_xor_mask_00000007 = (IHPE)S_0370_CiGetVideodata_xor_mask_00000007 ;
GLOBAL IUH S_0371_CiGetVideolatch_xor_mask_00000008 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0371_CiGetVideolatch_xor_mask_00000008_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0371_CiGetVideolatch_xor_mask_00000008 = (IHPE)S_0371_CiGetVideolatch_xor_mask_00000008 ;
GLOBAL IUH S_0372_CiGetVideobit_prot_mask_00000009 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0372_CiGetVideobit_prot_mask_00000009_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0372_CiGetVideobit_prot_mask_00000009 = (IHPE)S_0372_CiGetVideobit_prot_mask_00000009 ;
GLOBAL IUH S_0373_CiGetVideoplane_enable_0000000a IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0373_CiGetVideoplane_enable_0000000a_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0373_CiGetVideoplane_enable_0000000a = (IHPE)S_0373_CiGetVideoplane_enable_0000000a ;
GLOBAL IUH S_0374_CiGetVideoplane_enable_mask_0000000b IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0374_CiGetVideoplane_enable_mask_0000000b_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0374_CiGetVideoplane_enable_mask_0000000b = (IHPE)S_0374_CiGetVideoplane_enable_mask_0000000b ;
GLOBAL IUH S_0375_CiGetVideosr_lookup_0000000c IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0375_CiGetVideosr_lookup_0000000c_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0375_CiGetVideosr_lookup_0000000c = (IHPE)S_0375_CiGetVideosr_lookup_0000000c ;
GLOBAL IUH S_0376_CiGetVideofwd_str_read_addr_0000000d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0376_CiGetVideofwd_str_read_addr_0000000d_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0376_CiGetVideofwd_str_read_addr_0000000d = (IHPE)S_0376_CiGetVideofwd_str_read_addr_0000000d ;
GLOBAL IUH S_0377_CiGetVideobwd_str_read_addr_0000000e IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0377_CiGetVideobwd_str_read_addr_0000000e_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0377_CiGetVideobwd_str_read_addr_0000000e = (IHPE)S_0377_CiGetVideobwd_str_read_addr_0000000e ;
GLOBAL IUH S_0378_CiGetVideodirty_total_0000000f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0378_CiGetVideodirty_total_0000000f_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0378_CiGetVideodirty_total_0000000f = (IHPE)S_0378_CiGetVideodirty_total_0000000f ;
GLOBAL IUH S_0379_CiGetVideodirty_low_00000010 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0379_CiGetVideodirty_low_00000010_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0379_CiGetVideodirty_low_00000010 = (IHPE)S_0379_CiGetVideodirty_low_00000010 ;
GLOBAL IUH S_0380_CiGetVideodirty_high_00000011 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0380_CiGetVideodirty_high_00000011_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0380_CiGetVideodirty_high_00000011 = (IHPE)S_0380_CiGetVideodirty_high_00000011 ;
GLOBAL IUH S_0381_CiGetVideovideo_copy_00000012 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0381_CiGetVideovideo_copy_00000012_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0381_CiGetVideovideo_copy_00000012 = (IHPE)S_0381_CiGetVideovideo_copy_00000012 ;
GLOBAL IUH S_0382_CiGetVideomark_byte_00000013 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0382_CiGetVideomark_byte_00000013_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0382_CiGetVideomark_byte_00000013 = (IHPE)S_0382_CiGetVideomark_byte_00000013 ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	case	S_0363_CiGetVideolatches_00000000_id	:
		S_0363_CiGetVideolatches_00000000	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6557)	;	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6558)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0364_CiGetVideorplane_00000001_id	:
		S_0364_CiGetVideorplane_00000001	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6559)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6560)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0365_CiGetVideowplane_00000002_id	:
		S_0365_CiGetVideowplane_00000002	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6561)	;	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6562)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0366_CiGetVideoscratch_00000003_id	:
		S_0366_CiGetVideoscratch_00000003	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6563)	;	
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6564)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0367_CiGetVideosr_masked_val_00000004_id	:
		S_0367_CiGetVideosr_masked_val_00000004	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6565)	;	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6566)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0368_CiGetVideosr_nmask_00000005_id	:
		S_0368_CiGetVideosr_nmask_00000005	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6567)	;	
	*((IUH	*)&(r20))	=	(IS32)(1300)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6568)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0369_CiGetVideodata_and_mask_00000006_id	:
		S_0369_CiGetVideodata_and_mask_00000006	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6569)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6570)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0370_CiGetVideodata_xor_mask_00000007_id	:
		S_0370_CiGetVideodata_xor_mask_00000007	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6571)	;	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6572)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0371_CiGetVideolatch_xor_mask_00000008_id	:
		S_0371_CiGetVideolatch_xor_mask_00000008	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6573)	;	
	*((IUH	*)&(r20))	=	(IS32)(1312)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6574)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0372_CiGetVideobit_prot_mask_00000009_id	:
		S_0372_CiGetVideobit_prot_mask_00000009	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6575)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6576)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0373_CiGetVideoplane_enable_0000000a_id	:
		S_0373_CiGetVideoplane_enable_0000000a	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6577)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6578)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0374_CiGetVideoplane_enable_mask_0000000b_id	:
		S_0374_CiGetVideoplane_enable_mask_0000000b	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6579)	;	
	*((IUH	*)&(r20))	=	(IS32)(1324)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6580)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0375_CiGetVideosr_lookup_0000000c_id	:
		S_0375_CiGetVideosr_lookup_0000000c	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6581)	;	
	*((IUH	*)&(r21))	=	(IS32)(1328)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6582)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0376_CiGetVideofwd_str_read_addr_0000000d_id	:
		S_0376_CiGetVideofwd_str_read_addr_0000000d	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6583)	;	
	*((IUH	*)&(r21))	=	(IS32)(1332)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6584)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0377_CiGetVideobwd_str_read_addr_0000000e_id	:
		S_0377_CiGetVideobwd_str_read_addr_0000000e	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6585)	;	
	*((IUH	*)&(r21))	=	(IS32)(1336)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6586)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0378_CiGetVideodirty_total_0000000f_id	:
		S_0378_CiGetVideodirty_total_0000000f	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6587)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6588)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0379_CiGetVideodirty_low_00000010_id	:
		S_0379_CiGetVideodirty_low_00000010	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6589)	;	
	*((IUH	*)&(r20))	=	(IS32)(1344)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6590)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0380_CiGetVideodirty_high_00000011_id	:
		S_0380_CiGetVideodirty_high_00000011	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6591)	;	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6592)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0381_CiGetVideovideo_copy_00000012_id	:
		S_0381_CiGetVideovideo_copy_00000012	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6593)	;	
	*((IUH	*)&(r21))	=	(IS32)(1352)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6594)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0382_CiGetVideomark_byte_00000013_id	:
		S_0382_CiGetVideomark_byte_00000013	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6595)	;	
	*((IUH	*)&(r21))	=	(IS32)(1356)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6596)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue	=	*((IUH	*)&(r20))	);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sevid029.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_3014_Chain4DwordMove_00000000_00000009_00000001_id,
L13_2994if_f_id,
S_3015_Chain4DwordMove_00000000_0000000e_00000001_id,
L13_2995if_f_id,
S_3016_Chain4DwordMove_00000000_0000000f_00000001_id,
L13_2996if_f_id,
S_3017_Chain4DwordMove_00000000_00000010_00000001_id,
L13_2997if_f_id,
S_3018_Chain4DwordMove_00000000_00000011_00000001_id,
L13_2998if_f_id,
S_3019_Chain4DwordMove_00000000_00000016_00000001_id,
L13_2999if_f_id,
S_3020_Chain4DwordMove_00000000_00000017_00000001_id,
L13_3000if_f_id,
S_3021_Chain4DwordMove_00000000_00000018_00000001_id,
L13_3001if_f_id,
S_3022_Chain4DwordMove_00000000_00000019_00000001_id,
L13_3002if_f_id,
S_3023_Chain4DwordMove_00000000_0000001e_00000001_id,
L13_3003if_f_id,
S_3024_Chain4DwordMove_00000000_0000001f_00000001_id,
L13_3004if_f_id,
S_3025_Chain4ByteMove_00000001_00000000_00000001_id,
L13_3005if_f_id,
L22_263if_f_id,
L22_264if_d_id,
S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001_id,
L13_3006if_f_id,
L23_1098w_t_id,
L23_1100if_f_id,
L23_1099w_d_id,
L23_1096if_f_id,
L23_1101w_t_id,
L23_1103if_f_id,
L23_1102w_d_id,
L23_1097if_d_id,
S_3027_Chain4WordMove_00000001_00000000_00000001_id,
L13_3007if_f_id,
L22_265if_f_id,
L22_267if_f_id,
L22_268if_f_id,
L22_269if_f_id,
L22_270if_f_id,
L22_266if_d_id,
S_3028_Chain4DwordMove_00000001_00000000_00000001_id,
L13_3008if_f_id,
S_3029_Chain4ByteMove_00000002_00000008_00000001_id,
L13_3009if_f_id,
L22_271if_f_id,
L22_272if_d_id,
S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001_id,
L13_3010if_f_id,
L23_1106w_t_id,
L23_1108if_f_id,
L23_1107w_d_id,
L23_1104if_f_id,
L23_1109w_t_id,
L23_1111if_f_id,
L23_1110w_d_id,
L23_1105if_d_id,
S_3031_Chain4ByteMove_00000002_00000009_00000001_id,
L13_3011if_f_id,
L22_273if_f_id,
L22_274if_d_id,
S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001_id,
L13_3012if_f_id,
L23_1114w_t_id,
L23_1115w_d_id,
L23_1112if_f_id,
L23_1116w_t_id,
L23_1117w_d_id,
L23_1113if_d_id,
S_3033_Chain4ByteMove_00000002_0000000e_00000001_id,
L13_3013if_f_id,
L22_275if_f_id,
L22_276if_d_id,
S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001_id,
L13_3014if_f_id,
L23_1120w_t_id,
L23_1122if_f_id,
L23_1121w_d_id,
L23_1118if_f_id,
L23_1123w_t_id,
L23_1125if_f_id,
L23_1124w_d_id,
L23_1119if_d_id,
S_3035_Chain4ByteMove_00000002_0000000f_00000001_id,
L13_3015if_f_id,
L22_277if_f_id,
L22_278if_d_id,
S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001_id,
L13_3016if_f_id,
L23_1128w_t_id,
L23_1129w_d_id,
L23_1126if_f_id,
L23_1130w_t_id,
L23_1131w_d_id,
L23_1127if_d_id,
S_3037_Chain4WordMove_00000002_00000008_00000001_id,
L13_3017if_f_id,
L22_279if_f_id,
L22_280if_d_id,
S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001_id,
L13_3018if_f_id,
S_3039_Chain4WordMove_00000002_00000009_00000001_id,
L13_3019if_f_id,
L22_281if_f_id,
L22_282if_d_id,
S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001_id,
L13_3020if_f_id,
L23_1134w_t_id,
L23_1135w_d_id,
L23_1132if_f_id,
L23_1136w_t_id,
L23_1137w_d_id,
L23_1133if_d_id,
S_3041_Chain4WordMove_00000002_0000000e_00000001_id,
L13_3021if_f_id,
L22_283if_f_id,
L22_284if_d_id,
S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001_id,
L13_3022if_f_id,
S_3043_Chain4WordMove_00000002_0000000f_00000001_id,
L13_3023if_f_id,
L22_285if_f_id,
L22_286if_d_id,
S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001_id,
L13_3024if_f_id,
L23_1140w_t_id,
L23_1141w_d_id,
L23_1138if_f_id,
L23_1142w_t_id,
L23_1143w_d_id,
L23_1139if_d_id,
S_3045_Chain4DwordMove_00000002_00000008_00000001_id,
L13_3025if_f_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_3014_Chain4DwordMove_00000000_00000009_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3014_Chain4DwordMove_00000000_00000009_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3014_Chain4DwordMove_00000000_00000009_00000001 = (IHPE)S_3014_Chain4DwordMove_00000000_00000009_00000001 ;
LOCAL IUH L13_2994if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2994if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2994if_f = (IHPE)L13_2994if_f ;
GLOBAL IUH S_3015_Chain4DwordMove_00000000_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3015_Chain4DwordMove_00000000_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3015_Chain4DwordMove_00000000_0000000e_00000001 = (IHPE)S_3015_Chain4DwordMove_00000000_0000000e_00000001 ;
LOCAL IUH L13_2995if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2995if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2995if_f = (IHPE)L13_2995if_f ;
GLOBAL IUH S_3016_Chain4DwordMove_00000000_0000000f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3016_Chain4DwordMove_00000000_0000000f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3016_Chain4DwordMove_00000000_0000000f_00000001 = (IHPE)S_3016_Chain4DwordMove_00000000_0000000f_00000001 ;
LOCAL IUH L13_2996if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2996if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2996if_f = (IHPE)L13_2996if_f ;
GLOBAL IUH S_3017_Chain4DwordMove_00000000_00000010_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3017_Chain4DwordMove_00000000_00000010_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3017_Chain4DwordMove_00000000_00000010_00000001 = (IHPE)S_3017_Chain4DwordMove_00000000_00000010_00000001 ;
LOCAL IUH L13_2997if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2997if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2997if_f = (IHPE)L13_2997if_f ;
GLOBAL IUH S_3018_Chain4DwordMove_00000000_00000011_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3018_Chain4DwordMove_00000000_00000011_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3018_Chain4DwordMove_00000000_00000011_00000001 = (IHPE)S_3018_Chain4DwordMove_00000000_00000011_00000001 ;
LOCAL IUH L13_2998if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2998if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2998if_f = (IHPE)L13_2998if_f ;
GLOBAL IUH S_3019_Chain4DwordMove_00000000_00000016_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3019_Chain4DwordMove_00000000_00000016_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3019_Chain4DwordMove_00000000_00000016_00000001 = (IHPE)S_3019_Chain4DwordMove_00000000_00000016_00000001 ;
LOCAL IUH L13_2999if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_2999if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_2999if_f = (IHPE)L13_2999if_f ;
GLOBAL IUH S_3020_Chain4DwordMove_00000000_00000017_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3020_Chain4DwordMove_00000000_00000017_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3020_Chain4DwordMove_00000000_00000017_00000001 = (IHPE)S_3020_Chain4DwordMove_00000000_00000017_00000001 ;
LOCAL IUH L13_3000if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3000if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3000if_f = (IHPE)L13_3000if_f ;
GLOBAL IUH S_3021_Chain4DwordMove_00000000_00000018_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3021_Chain4DwordMove_00000000_00000018_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3021_Chain4DwordMove_00000000_00000018_00000001 = (IHPE)S_3021_Chain4DwordMove_00000000_00000018_00000001 ;
LOCAL IUH L13_3001if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3001if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3001if_f = (IHPE)L13_3001if_f ;
GLOBAL IUH S_3022_Chain4DwordMove_00000000_00000019_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3022_Chain4DwordMove_00000000_00000019_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3022_Chain4DwordMove_00000000_00000019_00000001 = (IHPE)S_3022_Chain4DwordMove_00000000_00000019_00000001 ;
LOCAL IUH L13_3002if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3002if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3002if_f = (IHPE)L13_3002if_f ;
GLOBAL IUH S_3023_Chain4DwordMove_00000000_0000001e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3023_Chain4DwordMove_00000000_0000001e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3023_Chain4DwordMove_00000000_0000001e_00000001 = (IHPE)S_3023_Chain4DwordMove_00000000_0000001e_00000001 ;
LOCAL IUH L13_3003if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3003if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3003if_f = (IHPE)L13_3003if_f ;
GLOBAL IUH S_3024_Chain4DwordMove_00000000_0000001f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3024_Chain4DwordMove_00000000_0000001f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3024_Chain4DwordMove_00000000_0000001f_00000001 = (IHPE)S_3024_Chain4DwordMove_00000000_0000001f_00000001 ;
LOCAL IUH L13_3004if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3004if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3004if_f = (IHPE)L13_3004if_f ;
GLOBAL IUH S_3025_Chain4ByteMove_00000001_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3025_Chain4ByteMove_00000001_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3025_Chain4ByteMove_00000001_00000000_00000001 = (IHPE)S_3025_Chain4ByteMove_00000001_00000000_00000001 ;
LOCAL IUH L13_3005if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3005if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3005if_f = (IHPE)L13_3005if_f ;
LOCAL IUH L22_263if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_263if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_263if_f = (IHPE)L22_263if_f ;
LOCAL IUH L22_264if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_264if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_264if_d = (IHPE)L22_264if_d ;
GLOBAL IUH S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001 = (IHPE)S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001 ;
LOCAL IUH L13_3006if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3006if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3006if_f = (IHPE)L13_3006if_f ;
LOCAL IUH L23_1098w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1098w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1098w_t = (IHPE)L23_1098w_t ;
LOCAL IUH L23_1100if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1100if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1100if_f = (IHPE)L23_1100if_f ;
LOCAL IUH L23_1099w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1099w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1099w_d = (IHPE)L23_1099w_d ;
LOCAL IUH L23_1096if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1096if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1096if_f = (IHPE)L23_1096if_f ;
LOCAL IUH L23_1101w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1101w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1101w_t = (IHPE)L23_1101w_t ;
LOCAL IUH L23_1103if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1103if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1103if_f = (IHPE)L23_1103if_f ;
LOCAL IUH L23_1102w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1102w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1102w_d = (IHPE)L23_1102w_d ;
LOCAL IUH L23_1097if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1097if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1097if_d = (IHPE)L23_1097if_d ;
GLOBAL IUH S_3027_Chain4WordMove_00000001_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3027_Chain4WordMove_00000001_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3027_Chain4WordMove_00000001_00000000_00000001 = (IHPE)S_3027_Chain4WordMove_00000001_00000000_00000001 ;
LOCAL IUH L13_3007if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3007if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3007if_f = (IHPE)L13_3007if_f ;
LOCAL IUH L22_265if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_265if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_265if_f = (IHPE)L22_265if_f ;
LOCAL IUH L22_267if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_267if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_267if_f = (IHPE)L22_267if_f ;
LOCAL IUH L22_268if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_268if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_268if_f = (IHPE)L22_268if_f ;
LOCAL IUH L22_269if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_269if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_269if_f = (IHPE)L22_269if_f ;
LOCAL IUH L22_270if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_270if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_270if_f = (IHPE)L22_270if_f ;
LOCAL IUH L22_266if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_266if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_266if_d = (IHPE)L22_266if_d ;
GLOBAL IUH S_3028_Chain4DwordMove_00000001_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3028_Chain4DwordMove_00000001_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3028_Chain4DwordMove_00000001_00000000_00000001 = (IHPE)S_3028_Chain4DwordMove_00000001_00000000_00000001 ;
LOCAL IUH L13_3008if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3008if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3008if_f = (IHPE)L13_3008if_f ;
GLOBAL IUH S_3029_Chain4ByteMove_00000002_00000008_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3029_Chain4ByteMove_00000002_00000008_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3029_Chain4ByteMove_00000002_00000008_00000001 = (IHPE)S_3029_Chain4ByteMove_00000002_00000008_00000001 ;
LOCAL IUH L13_3009if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3009if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3009if_f = (IHPE)L13_3009if_f ;
LOCAL IUH L22_271if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_271if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_271if_f = (IHPE)L22_271if_f ;
LOCAL IUH L22_272if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_272if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_272if_d = (IHPE)L22_272if_d ;
GLOBAL IUH S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001 = (IHPE)S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001 ;
LOCAL IUH L13_3010if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3010if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3010if_f = (IHPE)L13_3010if_f ;
LOCAL IUH L23_1106w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1106w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1106w_t = (IHPE)L23_1106w_t ;
LOCAL IUH L23_1108if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1108if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1108if_f = (IHPE)L23_1108if_f ;
LOCAL IUH L23_1107w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1107w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1107w_d = (IHPE)L23_1107w_d ;
LOCAL IUH L23_1104if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1104if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1104if_f = (IHPE)L23_1104if_f ;
LOCAL IUH L23_1109w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1109w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1109w_t = (IHPE)L23_1109w_t ;
LOCAL IUH L23_1111if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1111if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1111if_f = (IHPE)L23_1111if_f ;
LOCAL IUH L23_1110w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1110w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1110w_d = (IHPE)L23_1110w_d ;
LOCAL IUH L23_1105if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1105if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1105if_d = (IHPE)L23_1105if_d ;
GLOBAL IUH S_3031_Chain4ByteMove_00000002_00000009_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3031_Chain4ByteMove_00000002_00000009_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3031_Chain4ByteMove_00000002_00000009_00000001 = (IHPE)S_3031_Chain4ByteMove_00000002_00000009_00000001 ;
LOCAL IUH L13_3011if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3011if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3011if_f = (IHPE)L13_3011if_f ;
LOCAL IUH L22_273if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_273if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_273if_f = (IHPE)L22_273if_f ;
LOCAL IUH L22_274if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_274if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_274if_d = (IHPE)L22_274if_d ;
GLOBAL IUH S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001 = (IHPE)S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001 ;
LOCAL IUH L13_3012if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3012if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3012if_f = (IHPE)L13_3012if_f ;
LOCAL IUH L23_1114w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1114w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1114w_t = (IHPE)L23_1114w_t ;
LOCAL IUH L23_1115w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1115w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1115w_d = (IHPE)L23_1115w_d ;
LOCAL IUH L23_1112if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1112if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1112if_f = (IHPE)L23_1112if_f ;
LOCAL IUH L23_1116w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1116w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1116w_t = (IHPE)L23_1116w_t ;
LOCAL IUH L23_1117w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1117w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1117w_d = (IHPE)L23_1117w_d ;
LOCAL IUH L23_1113if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1113if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1113if_d = (IHPE)L23_1113if_d ;
GLOBAL IUH S_3033_Chain4ByteMove_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3033_Chain4ByteMove_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3033_Chain4ByteMove_00000002_0000000e_00000001 = (IHPE)S_3033_Chain4ByteMove_00000002_0000000e_00000001 ;
LOCAL IUH L13_3013if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3013if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3013if_f = (IHPE)L13_3013if_f ;
LOCAL IUH L22_275if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_275if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_275if_f = (IHPE)L22_275if_f ;
LOCAL IUH L22_276if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_276if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_276if_d = (IHPE)L22_276if_d ;
GLOBAL IUH S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001 = (IHPE)S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001 ;
LOCAL IUH L13_3014if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3014if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3014if_f = (IHPE)L13_3014if_f ;
LOCAL IUH L23_1120w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1120w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1120w_t = (IHPE)L23_1120w_t ;
LOCAL IUH L23_1122if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1122if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1122if_f = (IHPE)L23_1122if_f ;
LOCAL IUH L23_1121w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1121w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1121w_d = (IHPE)L23_1121w_d ;
LOCAL IUH L23_1118if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1118if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1118if_f = (IHPE)L23_1118if_f ;
LOCAL IUH L23_1123w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1123w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1123w_t = (IHPE)L23_1123w_t ;
LOCAL IUH L23_1125if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1125if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1125if_f = (IHPE)L23_1125if_f ;
LOCAL IUH L23_1124w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1124w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1124w_d = (IHPE)L23_1124w_d ;
LOCAL IUH L23_1119if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1119if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1119if_d = (IHPE)L23_1119if_d ;
GLOBAL IUH S_3035_Chain4ByteMove_00000002_0000000f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3035_Chain4ByteMove_00000002_0000000f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3035_Chain4ByteMove_00000002_0000000f_00000001 = (IHPE)S_3035_Chain4ByteMove_00000002_0000000f_00000001 ;
LOCAL IUH L13_3015if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3015if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3015if_f = (IHPE)L13_3015if_f ;
LOCAL IUH L22_277if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_277if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_277if_f = (IHPE)L22_277if_f ;
LOCAL IUH L22_278if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_278if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_278if_d = (IHPE)L22_278if_d ;
GLOBAL IUH S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001 = (IHPE)S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001 ;
LOCAL IUH L13_3016if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3016if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3016if_f = (IHPE)L13_3016if_f ;
LOCAL IUH L23_1128w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1128w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1128w_t = (IHPE)L23_1128w_t ;
LOCAL IUH L23_1129w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1129w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1129w_d = (IHPE)L23_1129w_d ;
LOCAL IUH L23_1126if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1126if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1126if_f = (IHPE)L23_1126if_f ;
LOCAL IUH L23_1130w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1130w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1130w_t = (IHPE)L23_1130w_t ;
LOCAL IUH L23_1131w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1131w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1131w_d = (IHPE)L23_1131w_d ;
LOCAL IUH L23_1127if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1127if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1127if_d = (IHPE)L23_1127if_d ;
GLOBAL IUH S_3037_Chain4WordMove_00000002_00000008_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3037_Chain4WordMove_00000002_00000008_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3037_Chain4WordMove_00000002_00000008_00000001 = (IHPE)S_3037_Chain4WordMove_00000002_00000008_00000001 ;
LOCAL IUH L13_3017if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3017if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3017if_f = (IHPE)L13_3017if_f ;
LOCAL IUH L22_279if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_279if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_279if_f = (IHPE)L22_279if_f ;
LOCAL IUH L22_280if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_280if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_280if_d = (IHPE)L22_280if_d ;
GLOBAL IUH S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001 = (IHPE)S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001 ;
LOCAL IUH L13_3018if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3018if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3018if_f = (IHPE)L13_3018if_f ;
GLOBAL IUH S_3039_Chain4WordMove_00000002_00000009_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3039_Chain4WordMove_00000002_00000009_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3039_Chain4WordMove_00000002_00000009_00000001 = (IHPE)S_3039_Chain4WordMove_00000002_00000009_00000001 ;
LOCAL IUH L13_3019if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3019if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3019if_f = (IHPE)L13_3019if_f ;
LOCAL IUH L22_281if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_281if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_281if_f = (IHPE)L22_281if_f ;
LOCAL IUH L22_282if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_282if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_282if_d = (IHPE)L22_282if_d ;
GLOBAL IUH S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001 = (IHPE)S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001 ;
LOCAL IUH L13_3020if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3020if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3020if_f = (IHPE)L13_3020if_f ;
LOCAL IUH L23_1134w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1134w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1134w_t = (IHPE)L23_1134w_t ;
LOCAL IUH L23_1135w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1135w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1135w_d = (IHPE)L23_1135w_d ;
LOCAL IUH L23_1132if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1132if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1132if_f = (IHPE)L23_1132if_f ;
LOCAL IUH L23_1136w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1136w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1136w_t = (IHPE)L23_1136w_t ;
LOCAL IUH L23_1137w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1137w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1137w_d = (IHPE)L23_1137w_d ;
LOCAL IUH L23_1133if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1133if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1133if_d = (IHPE)L23_1133if_d ;
GLOBAL IUH S_3041_Chain4WordMove_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3041_Chain4WordMove_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3041_Chain4WordMove_00000002_0000000e_00000001 = (IHPE)S_3041_Chain4WordMove_00000002_0000000e_00000001 ;
LOCAL IUH L13_3021if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3021if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3021if_f = (IHPE)L13_3021if_f ;
LOCAL IUH L22_283if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_283if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_283if_f = (IHPE)L22_283if_f ;
LOCAL IUH L22_284if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_284if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_284if_d = (IHPE)L22_284if_d ;
GLOBAL IUH S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001 = (IHPE)S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001 ;
LOCAL IUH L13_3022if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3022if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3022if_f = (IHPE)L13_3022if_f ;
GLOBAL IUH S_3043_Chain4WordMove_00000002_0000000f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3043_Chain4WordMove_00000002_0000000f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3043_Chain4WordMove_00000002_0000000f_00000001 = (IHPE)S_3043_Chain4WordMove_00000002_0000000f_00000001 ;
LOCAL IUH L13_3023if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3023if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3023if_f = (IHPE)L13_3023if_f ;
LOCAL IUH L22_285if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_285if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_285if_f = (IHPE)L22_285if_f ;
LOCAL IUH L22_286if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_286if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_286if_d = (IHPE)L22_286if_d ;
GLOBAL IUH S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001 = (IHPE)S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001 ;
LOCAL IUH L13_3024if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3024if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3024if_f = (IHPE)L13_3024if_f ;
LOCAL IUH L23_1140w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1140w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1140w_t = (IHPE)L23_1140w_t ;
LOCAL IUH L23_1141w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1141w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1141w_d = (IHPE)L23_1141w_d ;
LOCAL IUH L23_1138if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1138if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1138if_f = (IHPE)L23_1138if_f ;
LOCAL IUH L23_1142w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1142w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1142w_t = (IHPE)L23_1142w_t ;
LOCAL IUH L23_1143w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1143w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1143w_d = (IHPE)L23_1143w_d ;
LOCAL IUH L23_1139if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1139if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1139if_d = (IHPE)L23_1139if_d ;
GLOBAL IUH S_3045_Chain4DwordMove_00000002_00000008_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3045_Chain4DwordMove_00000002_00000008_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3045_Chain4DwordMove_00000002_00000008_00000001 = (IHPE)S_3045_Chain4DwordMove_00000002_00000008_00000001 ;
LOCAL IUH L13_3025if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3025if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3025if_f = (IHPE)L13_3025if_f ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3014_Chain4DwordMove_00000000_00000009_00000001_id	:
		S_3014_Chain4DwordMove_00000000_00000009_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3014)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2994if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2994if_f_id	:
		L13_2994if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2991_Chain4WordMove_00000000_00000009_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2991_Chain4WordMove_00000000_00000009_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3015_Chain4DwordMove_00000000_0000000e_00000001_id	:
		S_3015_Chain4DwordMove_00000000_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3015)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2995if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2995if_f_id	:
		L13_2995if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2993_Chain4WordMove_00000000_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2993_Chain4WordMove_00000000_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3016_Chain4DwordMove_00000000_0000000f_00000001_id	:
		S_3016_Chain4DwordMove_00000000_0000000f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3016)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2996if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2996if_f_id	:
		L13_2996if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2995_Chain4WordMove_00000000_0000000f_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2995_Chain4WordMove_00000000_0000000f_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3017_Chain4DwordMove_00000000_00000010_00000001_id	:
		S_3017_Chain4DwordMove_00000000_00000010_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3017)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2997if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2997if_f_id	:
		L13_2997if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2997_Chain4WordMove_00000000_00000010_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2997_Chain4WordMove_00000000_00000010_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3018_Chain4DwordMove_00000000_00000011_00000001_id	:
		S_3018_Chain4DwordMove_00000000_00000011_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3018)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2998if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2998if_f_id	:
		L13_2998if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2999_Chain4WordMove_00000000_00000011_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2999_Chain4WordMove_00000000_00000011_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3019_Chain4DwordMove_00000000_00000016_00000001_id	:
		S_3019_Chain4DwordMove_00000000_00000016_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3019)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_2999if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_2999if_f_id	:
		L13_2999if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3001_Chain4WordMove_00000000_00000016_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3001_Chain4WordMove_00000000_00000016_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3020_Chain4DwordMove_00000000_00000017_00000001_id	:
		S_3020_Chain4DwordMove_00000000_00000017_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3020)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3000if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3000if_f_id	:
		L13_3000if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3003_Chain4WordMove_00000000_00000017_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3003_Chain4WordMove_00000000_00000017_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3021_Chain4DwordMove_00000000_00000018_00000001_id	:
		S_3021_Chain4DwordMove_00000000_00000018_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3021)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3001if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3001if_f_id	:
		L13_3001if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3005_Chain4WordMove_00000000_00000018_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3005_Chain4WordMove_00000000_00000018_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3022_Chain4DwordMove_00000000_00000019_00000001_id	:
		S_3022_Chain4DwordMove_00000000_00000019_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3022)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3002if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3002if_f_id	:
		L13_3002if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3007_Chain4WordMove_00000000_00000019_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3007_Chain4WordMove_00000000_00000019_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3023_Chain4DwordMove_00000000_0000001e_00000001_id	:
		S_3023_Chain4DwordMove_00000000_0000001e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3023)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3003if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3003if_f_id	:
		L13_3003if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3009_Chain4WordMove_00000000_0000001e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3009_Chain4WordMove_00000000_0000001e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3024_Chain4DwordMove_00000000_0000001f_00000001_id	:
		S_3024_Chain4DwordMove_00000000_0000001f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3024)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3004if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3004if_f_id	:
		L13_3004if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3011_Chain4WordMove_00000000_0000001f_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3011_Chain4WordMove_00000000_0000001f_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3025_Chain4ByteMove_00000001_00000000_00000001_id	:
		S_3025_Chain4ByteMove_00000001_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3025)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3005if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3005if_f_id	:
		L13_3005if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_263if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16686)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r3)	+	REGBYTE)	=	(IS32)(-1)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2868_Chain4ByteFill_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2868_Chain4ByteFill_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16687)	;	
	{	extern	IUH	L22_264if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_264if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_263if_f_id	:
		L22_263if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)(LocalIUH+1))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	case	L22_264if_d_id	:
		L22_264if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001_id	:
		S_3026_CopyBytePlnByPlnChain4_00000001_00000000_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3026)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3006if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3006if_f_id	:
		L13_3006if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1096if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1099w_d;	
	case	L23_1098w_t_id	:
		L23_1098w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1100if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1100if_f_id	:
		L23_1100if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1098w_t;	
	case	L23_1099w_d_id	:
		L23_1099w_d:	;	
	{	extern	IUH	L23_1097if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1097if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1096if_f_id	:
		L23_1096if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1102w_d;	
	case	L23_1101w_t_id	:
		L23_1101w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1103if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1103if_f_id	:
		L23_1103if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1101w_t;	
	case	L23_1102w_d_id	:
		L23_1102w_d:	;	
	case	L23_1097if_d_id	:
		L23_1097if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3027_Chain4WordMove_00000001_00000000_00000001_id	:
		S_3027_Chain4WordMove_00000001_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3027)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3007if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3007if_f_id	:
		L13_3007if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L22_265if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16680)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU16	*)&(r3)	+	REGWORD	)	=	(IS32)(-1)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2872_Chain4WordFill_00000001_00000000()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2872_Chain4WordFill_00000001_00000000(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16681)	;	
	{	extern	IUH	L22_266if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_266if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_265if_f_id	:
		L22_265if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L22_267if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	+	*((IUH	*)(LocalIUH+1))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2216_CopyDirWord1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2216_CopyDirWord1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L22_267if_f_id	:
		L22_267if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L22_268if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2216_CopyDirWord1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2216_CopyDirWord1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L22_268if_f_id	:
		L22_268if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L22_269if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	;		
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2216_CopyDirWord1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2216_CopyDirWord1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L22_269if_f_id	:
		L22_269if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IUH	*)&(r22))	=	(IS32)(3)	;	
	if(*((IU32	*)&(r22)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	if	((*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	(1	<<	*((IU32	*)&(r22)	+	REGLONG)))	==	0)	goto	L22_270if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16404)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	;		
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r2))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r21))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r3))	=	*((IUH	*)&(r20))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_2216_CopyDirWord1Plane_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_2216_CopyDirWord1Plane_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004257),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16405)	;	
	case	L22_270if_f_id	:
		L22_270if_f:	;	
	case	L22_266if_d_id	:
		L22_266if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3028_Chain4DwordMove_00000001_00000000_00000001_id	:
		S_3028_Chain4DwordMove_00000001_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3028)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3008if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3008if_f_id	:
		L13_3008if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3027_Chain4WordMove_00000001_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3027_Chain4WordMove_00000001_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3029_Chain4ByteMove_00000002_00000008_00000001_id	:
		S_3029_Chain4ByteMove_00000002_00000008_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3029)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3009if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3009if_f_id	:
		L13_3009if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_271if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	{	extern	IUH	L22_272if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_272if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_271if_f_id	:
		L22_271if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	case	L22_272if_d_id	:
		L22_272if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001_id	:
		S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3030)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3010if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3010if_f_id	:
		L13_3010if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1104if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1107w_d;	
	case	L23_1106w_t_id	:
		L23_1106w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1108if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1108if_f_id	:
		L23_1108if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1106w_t;	
	case	L23_1107w_d_id	:
		L23_1107w_d:	;	
	{	extern	IUH	L23_1105if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1105if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1104if_f_id	:
		L23_1104if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1110w_d;	
	case	L23_1109w_t_id	:
		L23_1109w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r20)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1111if_f;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1111if_f_id	:
		L23_1111if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1109w_t;	
	case	L23_1110w_d_id	:
		L23_1110w_d:	;	
	case	L23_1105if_d_id	:
		L23_1105if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3031_Chain4ByteMove_00000002_00000009_00000001_id	:
		S_3031_Chain4ByteMove_00000002_00000009_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3031)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3011if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3011if_f_id	:
		L13_3011if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_273if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	{	extern	IUH	L22_274if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_274if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_273if_f_id	:
		L22_273if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	case	L22_274if_d_id	:
		L22_274if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001_id	:
		S_3032_CopyByte4PlaneChain4_00000002_00000009_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3032)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3012if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3012if_f_id	:
		L13_3012if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1112if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1115w_d;	
	case	L23_1114w_t_id	:
		L23_1114w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1114w_t;	
	case	L23_1115w_d_id	:
		L23_1115w_d:	;	
	{	extern	IUH	L23_1113if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1113if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1112if_f_id	:
		L23_1112if_f:	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1117w_d;	
	case	L23_1116w_t_id	:
		L23_1116w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1116w_t;	
	case	L23_1117w_d_id	:
		L23_1117w_d:	;	
	case	L23_1113if_d_id	:
		L23_1113if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3033_Chain4ByteMove_00000002_0000000e_00000001_id	:
		S_3033_Chain4ByteMove_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3033)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3013if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3013if_f_id	:
		L13_3013if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_275if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	{	extern	IUH	L22_276if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_276if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_275if_f_id	:
		L22_275if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	case	L22_276if_d_id	:
		L22_276if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001_id	:
		S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3034)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3014if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3014if_f_id	:
		L13_3014if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1118if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1121w_d;	
	case	L23_1120w_t_id	:
		L23_1120w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1122if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1122if_f_id	:
		L23_1122if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1120w_t;	
	case	L23_1121w_d_id	:
		L23_1121w_d:	;	
	{	extern	IUH	L23_1119if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1119if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1118if_f_id	:
		L23_1118if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1124w_d;	
	case	L23_1123w_t_id	:
		L23_1123w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1125if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1125if_f_id	:
		L23_1125if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1123w_t;	
	case	L23_1124w_d_id	:
		L23_1124w_d:	;	
	case	L23_1119if_d_id	:
		L23_1119if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3035_Chain4ByteMove_00000002_0000000f_00000001_id	:
		S_3035_Chain4ByteMove_00000002_0000000f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3035)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3015if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3015if_f_id	:
		L13_3015if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_277if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	{	extern	IUH	L22_278if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_278if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_277if_f_id	:
		L22_277if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	case	L22_278if_d_id	:
		L22_278if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001_id	:
		S_3036_CopyByte4PlaneChain4_00000002_0000000f_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3036)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3016if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3016if_f_id	:
		L13_3016if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1126if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1129w_d;	
	case	L23_1128w_t_id	:
		L23_1128w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1308)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1128w_t;	
	case	L23_1129w_d_id	:
		L23_1129w_d:	;	
	{	extern	IUH	L23_1127if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1127if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1126if_f_id	:
		L23_1126if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1131w_d;	
	case	L23_1130w_t_id	:
		L23_1130w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1130w_t;	
	case	L23_1131w_d_id	:
		L23_1131w_d:	;	
	case	L23_1127if_d_id	:
		L23_1127if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3037_Chain4WordMove_00000002_00000008_00000001_id	:
		S_3037_Chain4WordMove_00000002_00000008_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3037)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3017if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3017if_f_id	:
		L13_3017if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_279if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_280if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_280if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_279if_f_id	:
		L22_279if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_280if_d_id	:
		L22_280if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001_id	:
		S_3038_CopyWordPlnByPlnChain4_00000002_00000008_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3038)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3018if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3018if_f_id	:
		L13_3018if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3030_CopyBytePlnByPlnChain4_00000002_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3039_Chain4WordMove_00000002_00000009_00000001_id	:
		S_3039_Chain4WordMove_00000002_00000009_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3039)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3019if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3019if_f_id	:
		L13_3019if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_281if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_282if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_282if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_281if_f_id	:
		L22_281if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_282if_d_id	:
		L22_282if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001_id	:
		S_3040_CopyWord4PlaneChain4_00000002_00000009_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3040)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3020if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3020if_f_id	:
		L13_3020if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1132if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1135w_d;	
	case	L23_1134w_t_id	:
		L23_1134w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1134w_t;	
	case	L23_1135w_d_id	:
		L23_1135w_d:	;	
	{	extern	IUH	L23_1133if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1133if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1132if_f_id	:
		L23_1132if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1137w_d;	
	case	L23_1136w_t_id	:
		L23_1136w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	|	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1136w_t;	
	case	L23_1137w_d_id	:
		L23_1137w_d:	;	
	case	L23_1133if_d_id	:
		L23_1133if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3041_Chain4WordMove_00000002_0000000e_00000001_id	:
		S_3041_Chain4WordMove_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3041)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3021if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3021if_f_id	:
		L13_3021if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_283if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_284if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_284if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_283if_f_id	:
		L22_283if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_284if_d_id	:
		L22_284if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001_id	:
		S_3042_CopyWordPlnByPlnChain4_00000002_0000000e_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3042)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3022if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3022if_f_id	:
		L13_3022if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3034_CopyBytePlnByPlnChain4_00000002_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3043_Chain4WordMove_00000002_0000000f_00000001_id	:
		S_3043_Chain4WordMove_00000002_0000000f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3043)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3023if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3023if_f_id	:
		L13_3023if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_285if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_286if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_286if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_285if_f_id	:
		L22_285if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_286if_d_id	:
		L22_286if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001_id	:
		S_3044_CopyWord4PlaneChain4_00000002_0000000f_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3044)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3024if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3024if_f_id	:
		L13_3024if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1138if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1141w_d;	
	case	L23_1140w_t_id	:
		L23_1140w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1308)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1280)	;	
	*((IUH	*)&(r23))	=	(IS32)(1312)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1140w_t;	
	case	L23_1141w_d_id	:
		L23_1141w_d:	;	
	{	extern	IUH	L23_1139if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1139if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1138if_f_id	:
		L23_1138if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1143w_d;	
	case	L23_1142w_t_id	:
		L23_1142w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r20)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r20)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r21))	=	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r21)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	if	(*((IU32	*)&(r22)	+	REGLONG)	+	*((IU32	*)&(r21)	+	REGLONG)	>	32	||	*((IU32	*)&(r22)	+	REGLONG)	==	0)
	CrulesRuntimeError("Bad	long	bitfield");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	(IU32)((*((IU32	*)(LocalIUH+8)	+	REGLONG)	<<	(32-(*((IU32	*)&(r21)	+	REGLONG)	+	*((IU32	*)&(r22)	+	REGLONG)))))	>>	(32	-	*((IU32	*)&(r22)	+	REGLONG));	
	*((IUH	*)&(r20))	=	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r22))	=	(IS32)(1328)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(*((IHPE	*)&(r20)))	)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16361)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1312)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1304)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r24))	=	(IS32)(1308)	;	
	*((IU32	*)&(r23)	+	REGLONG)	=	*((IU32	*)&(r23)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r24)))	)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16362)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1142w_t;	
	case	L23_1143w_d_id	:
		L23_1143w_d:	;	
	case	L23_1139if_d_id	:
		L23_1139if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3045_Chain4DwordMove_00000002_00000008_00000001_id	:
		S_3045_Chain4DwordMove_00000002_00000008_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3045)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3025if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3025if_f_id	:
		L13_3025if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3037_Chain4WordMove_00000002_00000008_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3037_Chain4WordMove_00000002_00000008_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sevid030.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_3046_Chain4DwordMove_00000002_00000009_00000001_id,
L13_3026if_f_id,
S_3047_Chain4DwordMove_00000002_0000000e_00000001_id,
L13_3027if_f_id,
S_3048_Chain4DwordMove_00000002_0000000f_00000001_id,
L13_3028if_f_id,
S_3049_Chain4ByteMove_00000003_00000008_00000001_id,
L13_3029if_f_id,
L22_287if_f_id,
L22_288if_d_id,
S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001_id,
L13_3030if_f_id,
L23_1146w_t_id,
L23_1148if_f_id,
L23_1147w_d_id,
L23_1144if_f_id,
L23_1149w_t_id,
L23_1151if_f_id,
L23_1150w_d_id,
L23_1145if_d_id,
S_3051_Chain4ByteMove_00000003_00000009_00000001_id,
L13_3031if_f_id,
L22_289if_f_id,
L22_290if_d_id,
S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001_id,
L13_3032if_f_id,
L23_1154w_t_id,
L23_1155w_d_id,
L23_1152if_f_id,
L23_1156w_t_id,
L23_1157w_d_id,
L23_1153if_d_id,
S_3053_Chain4ByteMove_00000003_0000000e_00000001_id,
L13_3033if_f_id,
L22_291if_f_id,
L22_292if_d_id,
S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001_id,
L13_3034if_f_id,
L23_1160w_t_id,
L23_1162if_f_id,
L23_1161w_d_id,
L23_1158if_f_id,
L23_1163w_t_id,
L23_1165if_f_id,
L23_1164w_d_id,
L23_1159if_d_id,
S_3055_Chain4ByteMove_00000003_0000000f_00000001_id,
L13_3035if_f_id,
L22_293if_f_id,
L22_294if_d_id,
S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001_id,
L13_3036if_f_id,
L23_1168w_t_id,
L23_1169w_d_id,
L23_1166if_f_id,
L23_1170w_t_id,
L23_1171w_d_id,
L23_1167if_d_id,
S_3057_Chain4WordMove_00000003_00000008_00000001_id,
L13_3037if_f_id,
L22_295if_f_id,
L22_296if_d_id,
S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001_id,
L13_3038if_f_id,
S_3059_Chain4WordMove_00000003_00000009_00000001_id,
L13_3039if_f_id,
L22_297if_f_id,
L22_298if_d_id,
S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001_id,
L13_3040if_f_id,
L23_1174w_t_id,
L23_1175w_d_id,
L23_1172if_f_id,
L23_1176w_t_id,
L23_1177w_d_id,
L23_1173if_d_id,
S_3061_Chain4WordMove_00000003_0000000e_00000001_id,
L13_3041if_f_id,
L22_299if_f_id,
L22_300if_d_id,
S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001_id,
L13_3042if_f_id,
S_3063_Chain4WordMove_00000003_0000000f_00000001_id,
L13_3043if_f_id,
L22_301if_f_id,
L22_302if_d_id,
S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001_id,
L13_3044if_f_id,
L23_1180w_t_id,
L23_1181w_d_id,
L23_1178if_f_id,
L23_1182w_t_id,
L23_1183w_d_id,
L23_1179if_d_id,
S_3065_Chain4DwordMove_00000003_00000008_00000001_id,
L13_3045if_f_id,
S_3066_Chain4DwordMove_00000003_00000009_00000001_id,
L13_3046if_f_id,
S_3067_Chain4DwordMove_00000003_0000000e_00000001_id,
L13_3047if_f_id,
S_3068_Chain4DwordMove_00000003_0000000f_00000001_id,
L13_3048if_f_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_3046_Chain4DwordMove_00000002_00000009_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3046_Chain4DwordMove_00000002_00000009_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3046_Chain4DwordMove_00000002_00000009_00000001 = (IHPE)S_3046_Chain4DwordMove_00000002_00000009_00000001 ;
LOCAL IUH L13_3026if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3026if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3026if_f = (IHPE)L13_3026if_f ;
GLOBAL IUH S_3047_Chain4DwordMove_00000002_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3047_Chain4DwordMove_00000002_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3047_Chain4DwordMove_00000002_0000000e_00000001 = (IHPE)S_3047_Chain4DwordMove_00000002_0000000e_00000001 ;
LOCAL IUH L13_3027if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3027if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3027if_f = (IHPE)L13_3027if_f ;
GLOBAL IUH S_3048_Chain4DwordMove_00000002_0000000f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3048_Chain4DwordMove_00000002_0000000f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3048_Chain4DwordMove_00000002_0000000f_00000001 = (IHPE)S_3048_Chain4DwordMove_00000002_0000000f_00000001 ;
LOCAL IUH L13_3028if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3028if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3028if_f = (IHPE)L13_3028if_f ;
GLOBAL IUH S_3049_Chain4ByteMove_00000003_00000008_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3049_Chain4ByteMove_00000003_00000008_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3049_Chain4ByteMove_00000003_00000008_00000001 = (IHPE)S_3049_Chain4ByteMove_00000003_00000008_00000001 ;
LOCAL IUH L13_3029if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3029if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3029if_f = (IHPE)L13_3029if_f ;
LOCAL IUH L22_287if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_287if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_287if_f = (IHPE)L22_287if_f ;
LOCAL IUH L22_288if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_288if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_288if_d = (IHPE)L22_288if_d ;
GLOBAL IUH S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001 = (IHPE)S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001 ;
LOCAL IUH L13_3030if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3030if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3030if_f = (IHPE)L13_3030if_f ;
LOCAL IUH L23_1146w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1146w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1146w_t = (IHPE)L23_1146w_t ;
LOCAL IUH L23_1148if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1148if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1148if_f = (IHPE)L23_1148if_f ;
LOCAL IUH L23_1147w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1147w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1147w_d = (IHPE)L23_1147w_d ;
LOCAL IUH L23_1144if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1144if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1144if_f = (IHPE)L23_1144if_f ;
LOCAL IUH L23_1149w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1149w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1149w_t = (IHPE)L23_1149w_t ;
LOCAL IUH L23_1151if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1151if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1151if_f = (IHPE)L23_1151if_f ;
LOCAL IUH L23_1150w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1150w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1150w_d = (IHPE)L23_1150w_d ;
LOCAL IUH L23_1145if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1145if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1145if_d = (IHPE)L23_1145if_d ;
GLOBAL IUH S_3051_Chain4ByteMove_00000003_00000009_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3051_Chain4ByteMove_00000003_00000009_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3051_Chain4ByteMove_00000003_00000009_00000001 = (IHPE)S_3051_Chain4ByteMove_00000003_00000009_00000001 ;
LOCAL IUH L13_3031if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3031if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3031if_f = (IHPE)L13_3031if_f ;
LOCAL IUH L22_289if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_289if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_289if_f = (IHPE)L22_289if_f ;
LOCAL IUH L22_290if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_290if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_290if_d = (IHPE)L22_290if_d ;
GLOBAL IUH S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001 = (IHPE)S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001 ;
LOCAL IUH L13_3032if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3032if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3032if_f = (IHPE)L13_3032if_f ;
LOCAL IUH L23_1154w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1154w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1154w_t = (IHPE)L23_1154w_t ;
LOCAL IUH L23_1155w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1155w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1155w_d = (IHPE)L23_1155w_d ;
LOCAL IUH L23_1152if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1152if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1152if_f = (IHPE)L23_1152if_f ;
LOCAL IUH L23_1156w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1156w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1156w_t = (IHPE)L23_1156w_t ;
LOCAL IUH L23_1157w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1157w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1157w_d = (IHPE)L23_1157w_d ;
LOCAL IUH L23_1153if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1153if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1153if_d = (IHPE)L23_1153if_d ;
GLOBAL IUH S_3053_Chain4ByteMove_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3053_Chain4ByteMove_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3053_Chain4ByteMove_00000003_0000000e_00000001 = (IHPE)S_3053_Chain4ByteMove_00000003_0000000e_00000001 ;
LOCAL IUH L13_3033if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3033if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3033if_f = (IHPE)L13_3033if_f ;
LOCAL IUH L22_291if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_291if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_291if_f = (IHPE)L22_291if_f ;
LOCAL IUH L22_292if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_292if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_292if_d = (IHPE)L22_292if_d ;
GLOBAL IUH S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001 = (IHPE)S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001 ;
LOCAL IUH L13_3034if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3034if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3034if_f = (IHPE)L13_3034if_f ;
LOCAL IUH L23_1160w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1160w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1160w_t = (IHPE)L23_1160w_t ;
LOCAL IUH L23_1162if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1162if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1162if_f = (IHPE)L23_1162if_f ;
LOCAL IUH L23_1161w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1161w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1161w_d = (IHPE)L23_1161w_d ;
LOCAL IUH L23_1158if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1158if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1158if_f = (IHPE)L23_1158if_f ;
LOCAL IUH L23_1163w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1163w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1163w_t = (IHPE)L23_1163w_t ;
LOCAL IUH L23_1165if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1165if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1165if_f = (IHPE)L23_1165if_f ;
LOCAL IUH L23_1164w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1164w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1164w_d = (IHPE)L23_1164w_d ;
LOCAL IUH L23_1159if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1159if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1159if_d = (IHPE)L23_1159if_d ;
GLOBAL IUH S_3055_Chain4ByteMove_00000003_0000000f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3055_Chain4ByteMove_00000003_0000000f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3055_Chain4ByteMove_00000003_0000000f_00000001 = (IHPE)S_3055_Chain4ByteMove_00000003_0000000f_00000001 ;
LOCAL IUH L13_3035if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3035if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3035if_f = (IHPE)L13_3035if_f ;
LOCAL IUH L22_293if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_293if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_293if_f = (IHPE)L22_293if_f ;
LOCAL IUH L22_294if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_294if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_294if_d = (IHPE)L22_294if_d ;
GLOBAL IUH S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001 = (IHPE)S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001 ;
LOCAL IUH L13_3036if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3036if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3036if_f = (IHPE)L13_3036if_f ;
LOCAL IUH L23_1168w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1168w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1168w_t = (IHPE)L23_1168w_t ;
LOCAL IUH L23_1169w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1169w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1169w_d = (IHPE)L23_1169w_d ;
LOCAL IUH L23_1166if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1166if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1166if_f = (IHPE)L23_1166if_f ;
LOCAL IUH L23_1170w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1170w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1170w_t = (IHPE)L23_1170w_t ;
LOCAL IUH L23_1171w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1171w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1171w_d = (IHPE)L23_1171w_d ;
LOCAL IUH L23_1167if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1167if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1167if_d = (IHPE)L23_1167if_d ;
GLOBAL IUH S_3057_Chain4WordMove_00000003_00000008_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3057_Chain4WordMove_00000003_00000008_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3057_Chain4WordMove_00000003_00000008_00000001 = (IHPE)S_3057_Chain4WordMove_00000003_00000008_00000001 ;
LOCAL IUH L13_3037if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3037if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3037if_f = (IHPE)L13_3037if_f ;
LOCAL IUH L22_295if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_295if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_295if_f = (IHPE)L22_295if_f ;
LOCAL IUH L22_296if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_296if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_296if_d = (IHPE)L22_296if_d ;
GLOBAL IUH S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001 = (IHPE)S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001 ;
LOCAL IUH L13_3038if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3038if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3038if_f = (IHPE)L13_3038if_f ;
GLOBAL IUH S_3059_Chain4WordMove_00000003_00000009_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3059_Chain4WordMove_00000003_00000009_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3059_Chain4WordMove_00000003_00000009_00000001 = (IHPE)S_3059_Chain4WordMove_00000003_00000009_00000001 ;
LOCAL IUH L13_3039if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3039if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3039if_f = (IHPE)L13_3039if_f ;
LOCAL IUH L22_297if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_297if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_297if_f = (IHPE)L22_297if_f ;
LOCAL IUH L22_298if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_298if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_298if_d = (IHPE)L22_298if_d ;
GLOBAL IUH S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001 = (IHPE)S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001 ;
LOCAL IUH L13_3040if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3040if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3040if_f = (IHPE)L13_3040if_f ;
LOCAL IUH L23_1174w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1174w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1174w_t = (IHPE)L23_1174w_t ;
LOCAL IUH L23_1175w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1175w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1175w_d = (IHPE)L23_1175w_d ;
LOCAL IUH L23_1172if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1172if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1172if_f = (IHPE)L23_1172if_f ;
LOCAL IUH L23_1176w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1176w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1176w_t = (IHPE)L23_1176w_t ;
LOCAL IUH L23_1177w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1177w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1177w_d = (IHPE)L23_1177w_d ;
LOCAL IUH L23_1173if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1173if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1173if_d = (IHPE)L23_1173if_d ;
GLOBAL IUH S_3061_Chain4WordMove_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3061_Chain4WordMove_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3061_Chain4WordMove_00000003_0000000e_00000001 = (IHPE)S_3061_Chain4WordMove_00000003_0000000e_00000001 ;
LOCAL IUH L13_3041if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3041if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3041if_f = (IHPE)L13_3041if_f ;
LOCAL IUH L22_299if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_299if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_299if_f = (IHPE)L22_299if_f ;
LOCAL IUH L22_300if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_300if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_300if_d = (IHPE)L22_300if_d ;
GLOBAL IUH S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001 = (IHPE)S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001 ;
LOCAL IUH L13_3042if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3042if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3042if_f = (IHPE)L13_3042if_f ;
GLOBAL IUH S_3063_Chain4WordMove_00000003_0000000f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3063_Chain4WordMove_00000003_0000000f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3063_Chain4WordMove_00000003_0000000f_00000001 = (IHPE)S_3063_Chain4WordMove_00000003_0000000f_00000001 ;
LOCAL IUH L13_3043if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3043if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3043if_f = (IHPE)L13_3043if_f ;
LOCAL IUH L22_301if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_301if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_301if_f = (IHPE)L22_301if_f ;
LOCAL IUH L22_302if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L22_302if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L22_302if_d = (IHPE)L22_302if_d ;
GLOBAL IUH S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001 = (IHPE)S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001 ;
LOCAL IUH L13_3044if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3044if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3044if_f = (IHPE)L13_3044if_f ;
LOCAL IUH L23_1180w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1180w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1180w_t = (IHPE)L23_1180w_t ;
LOCAL IUH L23_1181w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1181w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1181w_d = (IHPE)L23_1181w_d ;
LOCAL IUH L23_1178if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1178if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1178if_f = (IHPE)L23_1178if_f ;
LOCAL IUH L23_1182w_t IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1182w_t_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1182w_t = (IHPE)L23_1182w_t ;
LOCAL IUH L23_1183w_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1183w_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1183w_d = (IHPE)L23_1183w_d ;
LOCAL IUH L23_1179if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L23_1179if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L23_1179if_d = (IHPE)L23_1179if_d ;
GLOBAL IUH S_3065_Chain4DwordMove_00000003_00000008_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3065_Chain4DwordMove_00000003_00000008_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3065_Chain4DwordMove_00000003_00000008_00000001 = (IHPE)S_3065_Chain4DwordMove_00000003_00000008_00000001 ;
LOCAL IUH L13_3045if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3045if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3045if_f = (IHPE)L13_3045if_f ;
GLOBAL IUH S_3066_Chain4DwordMove_00000003_00000009_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3066_Chain4DwordMove_00000003_00000009_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3066_Chain4DwordMove_00000003_00000009_00000001 = (IHPE)S_3066_Chain4DwordMove_00000003_00000009_00000001 ;
LOCAL IUH L13_3046if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3046if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3046if_f = (IHPE)L13_3046if_f ;
GLOBAL IUH S_3067_Chain4DwordMove_00000003_0000000e_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3067_Chain4DwordMove_00000003_0000000e_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3067_Chain4DwordMove_00000003_0000000e_00000001 = (IHPE)S_3067_Chain4DwordMove_00000003_0000000e_00000001 ;
LOCAL IUH L13_3047if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3047if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3047if_f = (IHPE)L13_3047if_f ;
GLOBAL IUH S_3068_Chain4DwordMove_00000003_0000000f_00000001 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_3068_Chain4DwordMove_00000003_0000000f_00000001_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_3068_Chain4DwordMove_00000003_0000000f_00000001 = (IHPE)S_3068_Chain4DwordMove_00000003_0000000f_00000001 ;
LOCAL IUH L13_3048if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L13_3048if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L13_3048if_f = (IHPE)L13_3048if_f ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3046_Chain4DwordMove_00000002_00000009_00000001_id	:
		S_3046_Chain4DwordMove_00000002_00000009_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3046)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3026if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3026if_f_id	:
		L13_3026if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3039_Chain4WordMove_00000002_00000009_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3039_Chain4WordMove_00000002_00000009_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3047_Chain4DwordMove_00000002_0000000e_00000001_id	:
		S_3047_Chain4DwordMove_00000002_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3047)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3027if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3027if_f_id	:
		L13_3027if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3041_Chain4WordMove_00000002_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3041_Chain4WordMove_00000002_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3048_Chain4DwordMove_00000002_0000000f_00000001_id	:
		S_3048_Chain4DwordMove_00000002_0000000f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3048)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3028if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3028if_f_id	:
		L13_3028if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3043_Chain4WordMove_00000002_0000000f_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3043_Chain4WordMove_00000002_0000000f_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3049_Chain4ByteMove_00000003_00000008_00000001_id	:
		S_3049_Chain4ByteMove_00000003_00000008_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3049)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3029if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3029if_f_id	:
		L13_3029if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_287if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	{	extern	IUH	L22_288if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_288if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_287if_f_id	:
		L22_287if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	case	L22_288if_d_id	:
		L22_288if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001_id	:
		S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3050)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3030if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3030if_f_id	:
		L13_3030if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1144if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1147w_d;	
	case	L23_1146w_t_id	:
		L23_1146w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r20)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1148if_f;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r20)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1148if_f_id	:
		L23_1148if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1146w_t;	
	case	L23_1147w_d_id	:
		L23_1147w_d:	;	
	{	extern	IUH	L23_1145if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1145if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1144if_f_id	:
		L23_1144if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1150w_d;	
	case	L23_1149w_t_id	:
		L23_1149w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r20)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1151if_f;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1151if_f_id	:
		L23_1151if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1149w_t;	
	case	L23_1150w_d_id	:
		L23_1150w_d:	;	
	case	L23_1145if_d_id	:
		L23_1145if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3051_Chain4ByteMove_00000003_00000009_00000001_id	:
		S_3051_Chain4ByteMove_00000003_00000009_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3051)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3031if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3031if_f_id	:
		L13_3031if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_289if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	{	extern	IUH	L22_290if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_290if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_289if_f_id	:
		L22_289if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	case	L22_290if_d_id	:
		L22_290if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001_id	:
		S_3052_CopyByte4PlaneChain4_00000003_00000009_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3052)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3032if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3032if_f_id	:
		L13_3032if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1152if_f;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1155w_d;	
	case	L23_1154w_t_id	:
		L23_1154w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1154w_t;	
	case	L23_1155w_d_id	:
		L23_1155w_d:	;	
	{	extern	IUH	L23_1153if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1153if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1152if_f_id	:
		L23_1152if_f:	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1157w_d;	
	case	L23_1156w_t_id	:
		L23_1156w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1156w_t;	
	case	L23_1157w_d_id	:
		L23_1157w_d:	;	
	case	L23_1153if_d_id	:
		L23_1153if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3053_Chain4ByteMove_00000003_0000000e_00000001_id	:
		S_3053_Chain4ByteMove_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3053)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3033if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3033if_f_id	:
		L13_3033if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_291if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	{	extern	IUH	L22_292if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_292if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_291if_f_id	:
		L22_291if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
	case	L22_292if_d_id	:
		L22_292if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001_id	:
		S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3054)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3034if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3034if_f_id	:
		L13_3034if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1158if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1161w_d;	
	case	L23_1160w_t_id	:
		L23_1160w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r20)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1320)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r21)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1162if_f;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1162if_f_id	:
		L23_1162if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1160w_t;	
	case	L23_1161w_d_id	:
		L23_1161w_d:	;	
	{	extern	IUH	L23_1159if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1159if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1158if_f_id	:
		L23_1158if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1164w_d;	
	case	L23_1163w_t_id	:
		L23_1163w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(3)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r20)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	<<	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1320)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)&(r20)	+	REGLONG)	==	*((IU32	*)&(r22)	+	REGLONG))	goto	L23_1165if_f;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1296)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)&(r23)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	(IS32)(1288)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)((*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20))))	)	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	case	L23_1165if_f_id	:
		L23_1165if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+7)	+	REGLONG)	=	*((IU32	*)(LocalIUH+7)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1163w_t;	
	case	L23_1164w_d_id	:
		L23_1164w_d:	;	
	case	L23_1159if_d_id	:
		L23_1159if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3055_Chain4ByteMove_00000003_0000000f_00000001_id	:
		S_3055_Chain4ByteMove_00000003_0000000f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3055)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3035if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3035if_f_id	:
		L13_3035if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_293if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	{	extern	IUH	L22_294if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_294if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_293if_f_id	:
		L22_293if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16660)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16661)	;	
	case	L22_294if_d_id	:
		L22_294if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001_id	:
		S_3056_CopyByte4PlaneChain4_00000003_0000000f_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3056)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3036if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3036if_f_id	:
		L13_3036if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r21)	+	REGBYTE))	goto	L23_1166if_f;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1169w_d;	
	case	L23_1168w_t_id	:
		L23_1168w_t:	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1168w_t;	
	case	L23_1169w_d_id	:
		L23_1169w_d:	;	
	{	extern	IUH	L23_1167if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1167if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1166if_f_id	:
		L23_1166if_f:	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1171w_d;	
	case	L23_1170w_t_id	:
		L23_1170w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1296)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r23)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1170w_t;	
	case	L23_1171w_d_id	:
		L23_1171w_d:	;	
	case	L23_1167if_d_id	:
		L23_1167if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3057_Chain4WordMove_00000003_00000008_00000001_id	:
		S_3057_Chain4WordMove_00000003_00000008_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3057)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3037if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3037if_f_id	:
		L13_3037if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_295if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_296if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_296if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_295if_f_id	:
		L22_295if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_296if_d_id	:
		L22_296if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001_id	:
		S_3058_CopyWordPlnByPlnChain4_00000003_00000008_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3058)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3038if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3038if_f_id	:
		L13_3038if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3050_CopyBytePlnByPlnChain4_00000003_00000008_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3059_Chain4WordMove_00000003_00000009_00000001_id	:
		S_3059_Chain4WordMove_00000003_00000009_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3059)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3039if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3039if_f_id	:
		L13_3039if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_297if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_298if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_298if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_297if_f_id	:
		L22_297if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_298if_d_id	:
		L22_298if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001_id	:
		S_3060_CopyWord4PlaneChain4_00000003_00000009_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3060)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3040if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3040if_f_id	:
		L13_3040if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1172if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1175w_d;	
	case	L23_1174w_t_id	:
		L23_1174w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IU32	*)&(r21)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	&	*((IU32	*)&(r21)	+	REGLONG);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1174w_t;	
	case	L23_1175w_d_id	:
		L23_1175w_d:	;	
	{	extern	IUH	L23_1173if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1173if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1172if_f_id	:
		L23_1172if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1177w_d;	
	case	L23_1176w_t_id	:
		L23_1176w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1176w_t;	
	case	L23_1177w_d_id	:
		L23_1177w_d:	;	
	case	L23_1173if_d_id	:
		L23_1173if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3061_Chain4WordMove_00000003_0000000e_00000001_id	:
		S_3061_Chain4WordMove_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3061)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3041if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3041if_f_id	:
		L13_3041if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_299if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	{	extern	IUH	L22_300if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_300if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_299if_f_id	:
		L22_299if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16670)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16671)	;	
	case	L22_300if_d_id	:
		L22_300if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001_id	:
		S_3062_CopyWordPlnByPlnChain4_00000003_0000000e_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	24	>	0	)	LocalIUH	=	(IUH	*)malloc	(	24	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3062)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3042if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3042if_f_id	:
		L13_3042if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16658)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3054_CopyBytePlnByPlnChain4_00000003_0000000e_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16659)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3063_Chain4WordMove_00000003_0000000f_00000001_id	:
		S_3063_Chain4WordMove_00000003_0000000f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3063)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3043if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3043if_f_id	:
		L13_3043if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	-	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	-	*((IU32	*)&(r20)	+	REGLONG);	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r3)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004273),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+3)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L22_301if_f;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	(IS32)(-1)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	{	extern	IUH	L22_302if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L22_302if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L22_301if_f_id	:
		L22_301if_f:	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	-	*((IUH	*)&(r21));	
	*((IUH	*)&(r3))	=	*((IUH	*)&(r21))	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	{	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	((IUH	(*)())(IHP)(*((IHPE	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))))	)(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004261),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)&(r21))	=	(IS32)(1292)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)&(r2))	;	
	*((IUH	*)(r1+0))	=	(IS32)(16672)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(1292)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)(LocalIUH+1)	+	REGLONG)	;	
	*((IU32	*)&(r5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	;	
	*((IU8	*)&(r6)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004161),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16673)	;	
	case	L22_302if_d_id	:
		L22_302if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001_id	:
		S_3064_CopyWord4PlaneChain4_00000003_0000000f_00000000_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	44	>	0	)	LocalIUH	=	(IUH	*)malloc	(	44	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3064)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3044if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3044if_f_id	:
		L13_3044if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+3)	+	REGLONG)	=	*((IU32	*)&(r5)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+4)	+	REGBYTE)	=	*((IU8	*)&(r6)	+	REGBYTE)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+3)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU8	*)(LocalIUH+4)	+	REGBYTE)	==	*((IU8	*)&(r20)	+	REGBYTE))	goto	L23_1178if_f;	
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1181w_d;	
	case	L23_1180w_t_id	:
		L23_1180w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	(IS32)(1296)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+6))	-	*((IUH	*)&(r20));	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r21))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r20))	=	(IS32)(1296)	;	
	*((IUH	*)&(r22))	=	(IS32)(1280)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IU32	*)&(r22)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IUH	*)&(r23))	=	(IS32)(1280)	;	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r23)))	)	&	*((IU32	*)&(r22)	+	REGLONG);	
	*((IU32	*)&(r21)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+6))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+6))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(2)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r21));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r21)	+	REGLONG))	goto	L23_1180w_t;	
	case	L23_1181w_d_id	:
		L23_1181w_d:	;	
	{	extern	IUH	L23_1179if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L23_1179if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L23_1178if_f_id	:
		L23_1178if_f:	;	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r20))	=	*((IU32	*)(LocalIUH+2)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1284)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	*((IU32	*)(LocalIUH+0)	+	REGLONG);	
	*((IUH	*)&(r22))	=	(IS32)(1288)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	<=	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1183w_d;	
	case	L23_1182w_t_id	:
		L23_1182w_t:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	*((IU32	*)(LocalIUH+5)	+	REGLONG)	=	*((IU32	*)(LocalIUH+5)	+	REGLONG)	-	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r21))	=	*((IU8	*)(*((IHPE	*)&(r20)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1296)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r23)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IU8	*)(*((IHPE	*)&(r21)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+9))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	);	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16360)	;	
	*((IUH	*)&(r20))	=	(IS32)(1316)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)(LocalIUH+8)	+	REGLONG)	&	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r20))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IUH	*)&(r22))	=	(IS32)(1296)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	^	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	)	;	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	&	*((IU32	*)(LocalIUH+8)	+	REGLONG);	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	;	
	*((IUH	*)&(r22))	=	*((IU8	*)(*((IHPE	*)&(r21)))	);	
	*((IU32	*)&(r23)	+	REGLONG)	=	~(*((IU32	*)(LocalIUH+8)	+	REGLONG));	
	*((IU32	*)&(r22)	+	REGLONG)	=	*((IU32	*)&(r22)	+	REGLONG)	&	*((IU32	*)&(r23)	+	REGLONG);	
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	|	*((IU32	*)&(r22)	+	REGLONG)	;	
	*((IU32	*)(LocalIUH+8)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16363)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	*((IU8	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	=	*((IU8	*)(LocalIUH+8)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+9))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+9))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+10))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+10))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+7))	-	*((IUH	*)&(r20));	
	*((IUH	*)(LocalIUH+7))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((IU32	*)(LocalIUH+5)	+	REGLONG)	>	*((IU32	*)&(r20)	+	REGLONG))	goto	L23_1182w_t;	
	case	L23_1183w_d_id	:
		L23_1183w_d:	;	
	case	L23_1179if_d_id	:
		L23_1179if_d:	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3065_Chain4DwordMove_00000003_00000008_00000001_id	:
		S_3065_Chain4DwordMove_00000003_00000008_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3065)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3045if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3045if_f_id	:
		L13_3045if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3057_Chain4WordMove_00000003_00000008_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3057_Chain4WordMove_00000003_00000008_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3066_Chain4DwordMove_00000003_00000009_00000001_id	:
		S_3066_Chain4DwordMove_00000003_00000009_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3066)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3046if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3046if_f_id	:
		L13_3046if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3059_Chain4WordMove_00000003_00000009_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3059_Chain4WordMove_00000003_00000009_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3067_Chain4DwordMove_00000003_0000000e_00000001_id	:
		S_3067_Chain4DwordMove_00000003_0000000e_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3067)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3047if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3047if_f_id	:
		L13_3047if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3061_Chain4WordMove_00000003_0000000e_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3061_Chain4WordMove_00000003_0000000e_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	*((IUH	*)(r1+0))	=	(IS32)(16201)	;	
	case	S_3068_Chain4DwordMove_00000003_0000000f_00000001_id	:
		S_3068_Chain4DwordMove_00000003_0000000f_00000001	:	
	*((IUH	*)(r1+0))	=	(IS32)(82)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	20	>	0	)	LocalIUH	=	(IUH	*)malloc	(	20	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+8))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	*((IUH	*)(r1+8))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r20)))	+	*((IHPE	*)&(r22)))	)	=	(IS32)(3068)	;	
	if	(*((IUH	*)(r1+8))	<=	*((IUH	*)(r1+16)))	goto	L13_3048if_f;	
	*((IUH	*)(r1+8))	=	*((IUH	*)(r1+12))	;	
	case	L13_3048if_f_id	:
		L13_3048if_f:	;	
	*((IUH	*)(r1+0))	=	(IS32)(83)	;	
	*((IU32	*)(LocalIUH+0)	+	REGLONG)	=	*((IU32	*)&(r2)	+	REGLONG)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r3))	;	
	*((IU32	*)(LocalIUH+2)	+	REGLONG)	=	*((IU32	*)&(r4)	+	REGLONG)	;	
	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	=	*((IU8	*)&(r5)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(16684)	;	
	*((IU32	*)&(r2)	+	REGLONG)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)&(r3))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if(*((IU32	*)&(r21)	+	REGLONG)>=32)
	CrulesRuntimeError("Bad	Bit	No");
	else
	*((IU32	*)&(r20)	+	REGLONG)	=	*((IU32	*)(LocalIUH+2)	+	REGLONG)	<<	*((IU32	*)&(r21)	+	REGLONG)	;	
	*((IU32	*)&(r4)	+	REGLONG)	=	*((IU32	*)&(r20)	+	REGLONG)	;	
	*((IU8	*)&(r5)	+	REGBYTE)	=	*((IU8	*)(LocalIUH+3)	+	REGBYTE)	;	
/*	J_SAVE_RETURN	NOT	IMPLIMENTED	*/
	{	extern	IUH	S_3063_Chain4WordMove_00000003_0000000f_00000001()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;	returnValue	=	S_3063_Chain4WordMove_00000003_0000000f_00000001(v1,v2,v3,v4);	}
	/*	j_state	(IS32)(-2013004225),	(IS32)(-1),	(IS32)(0)	*/
/*	J_LOAD_RETURN	NOT	IMPLIMENTED	*/
	*((IUH	*)(r1+0))	=	(IS32)(16685)	;	
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
/*J_KILL__*/
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return(returnValue);	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sinit013.c ===
/* #defines and enum      */
#include  "insignia.h"
#include  "host_def.h"
#include <stdlib.h>
#include  "j_c_lang.h"
extern IU8	J_EXT_DATA[] ;
typedef enum 
{
S_0415_CiSetVideofwd_str_read_addr_00000034_id,
S_0416_CiSetVideobwd_str_read_addr_00000035_id,
S_0417_CiSetVideodirty_total_00000036_id,
S_0418_CiSetVideodirty_low_00000037_id,
S_0419_CiSetVideodirty_high_00000038_id,
S_0420_CiSetVideovideo_copy_00000039_id,
S_0421_CiSetVideomark_byte_0000003a_id,
S_0422_CiSetVideomark_word_0000003b_id,
S_0423_CiSetVideomark_string_0000003c_id,
S_0424_CiSetVideoread_shift_count_0000003d_id,
S_0425_CiSetVideoread_mapped_plane_0000003e_id,
S_0426_CiSetVideocolour_comp_0000003f_id,
S_0427_CiSetVideodont_care_00000040_id,
S_0428_CiSetVideov7_bank_vid_copy_off_00000041_id,
S_0429_CiSetVideoscreen_ptr_00000042_id,
S_0430_CiSetVideorotate_00000043_id,
S_0431_CiSetVideocalc_data_xor_00000044_id,
S_0432_CiSetVideocalc_latch_xor_00000045_id,
S_0433_CiSetVideoread_byte_addr_00000046_id,
S_0434_CiSetVideov7_fg_latches_00000047_id,
S_0435_CiSetVideoGC_regs_00000048_id,
S_0436_CiSetVideolast_GC_index_00000049_id,
S_0437_CiSetVideodither_0000004a_id,
S_0438_CiSetVideowrmode_0000004b_id,
S_0439_CiSetVideochain_0000004c_id,
S_0440_CiSetVideowrstate_0000004d_id,
S_0441_CisetWritePointers_0000004e_id,
L30_1if_f_id,
L30_5or2_id,
L30_6if_f_id,
L30_7if_f_id,
L30_8if_d_id,
L30_9if_f_id,
L30_11if_f_id,
L30_13if_f_id,
L30_14if_d_id,
L30_12if_d_id,
L30_10if_d_id,
L30_3if_f_id,
L30_15if_f_id,
L30_16if_d_id,
L30_4if_d_id,
L30_2if_d_id,
L30_0endgen_id,
S_0442_CisetReadPointers_0000004f_id,
L30_17if_f_id,
L30_19if_f_id,
L30_21if_f_id,
L30_22if_d_id,
L30_20if_d_id,
L30_18if_d_id,
S_0443_CisetMarkPointers_00000050_id,
L30_23if_f_id,
L30_25if_f_id,
L30_27if_f_id,
L30_28if_d_id,
L30_26if_d_id,
L30_24if_d_id,
LAST_ENTRY
} ID ;
/* END of #defines and enum      */
/* DATA space definitions */
/* END of DATA space definitions */
/* FUNCTIONS              */
LOCAL IUH crules IPT5( ID, id , IUH , v1, IUH , v2,  IUH , v3,  IUH , v4 ) ;
GLOBAL IUH S_0415_CiSetVideofwd_str_read_addr_00000034 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0415_CiSetVideofwd_str_read_addr_00000034_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0415_CiSetVideofwd_str_read_addr_00000034 = (IHPE)S_0415_CiSetVideofwd_str_read_addr_00000034 ;
GLOBAL IUH S_0416_CiSetVideobwd_str_read_addr_00000035 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0416_CiSetVideobwd_str_read_addr_00000035_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0416_CiSetVideobwd_str_read_addr_00000035 = (IHPE)S_0416_CiSetVideobwd_str_read_addr_00000035 ;
GLOBAL IUH S_0417_CiSetVideodirty_total_00000036 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0417_CiSetVideodirty_total_00000036_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0417_CiSetVideodirty_total_00000036 = (IHPE)S_0417_CiSetVideodirty_total_00000036 ;
GLOBAL IUH S_0418_CiSetVideodirty_low_00000037 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0418_CiSetVideodirty_low_00000037_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0418_CiSetVideodirty_low_00000037 = (IHPE)S_0418_CiSetVideodirty_low_00000037 ;
GLOBAL IUH S_0419_CiSetVideodirty_high_00000038 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0419_CiSetVideodirty_high_00000038_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0419_CiSetVideodirty_high_00000038 = (IHPE)S_0419_CiSetVideodirty_high_00000038 ;
GLOBAL IUH S_0420_CiSetVideovideo_copy_00000039 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0420_CiSetVideovideo_copy_00000039_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0420_CiSetVideovideo_copy_00000039 = (IHPE)S_0420_CiSetVideovideo_copy_00000039 ;
GLOBAL IUH S_0421_CiSetVideomark_byte_0000003a IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0421_CiSetVideomark_byte_0000003a_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0421_CiSetVideomark_byte_0000003a = (IHPE)S_0421_CiSetVideomark_byte_0000003a ;
GLOBAL IUH S_0422_CiSetVideomark_word_0000003b IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0422_CiSetVideomark_word_0000003b_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0422_CiSetVideomark_word_0000003b = (IHPE)S_0422_CiSetVideomark_word_0000003b ;
GLOBAL IUH S_0423_CiSetVideomark_string_0000003c IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0423_CiSetVideomark_string_0000003c_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0423_CiSetVideomark_string_0000003c = (IHPE)S_0423_CiSetVideomark_string_0000003c ;
GLOBAL IUH S_0424_CiSetVideoread_shift_count_0000003d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0424_CiSetVideoread_shift_count_0000003d_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0424_CiSetVideoread_shift_count_0000003d = (IHPE)S_0424_CiSetVideoread_shift_count_0000003d ;
GLOBAL IUH S_0425_CiSetVideoread_mapped_plane_0000003e IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0425_CiSetVideoread_mapped_plane_0000003e_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0425_CiSetVideoread_mapped_plane_0000003e = (IHPE)S_0425_CiSetVideoread_mapped_plane_0000003e ;
GLOBAL IUH S_0426_CiSetVideocolour_comp_0000003f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0426_CiSetVideocolour_comp_0000003f_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0426_CiSetVideocolour_comp_0000003f = (IHPE)S_0426_CiSetVideocolour_comp_0000003f ;
GLOBAL IUH S_0427_CiSetVideodont_care_00000040 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0427_CiSetVideodont_care_00000040_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0427_CiSetVideodont_care_00000040 = (IHPE)S_0427_CiSetVideodont_care_00000040 ;
GLOBAL IUH S_0428_CiSetVideov7_bank_vid_copy_off_00000041 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0428_CiSetVideov7_bank_vid_copy_off_00000041_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0428_CiSetVideov7_bank_vid_copy_off_00000041 = (IHPE)S_0428_CiSetVideov7_bank_vid_copy_off_00000041 ;
GLOBAL IUH S_0429_CiSetVideoscreen_ptr_00000042 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0429_CiSetVideoscreen_ptr_00000042_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0429_CiSetVideoscreen_ptr_00000042 = (IHPE)S_0429_CiSetVideoscreen_ptr_00000042 ;
GLOBAL IUH S_0430_CiSetVideorotate_00000043 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0430_CiSetVideorotate_00000043_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0430_CiSetVideorotate_00000043 = (IHPE)S_0430_CiSetVideorotate_00000043 ;
GLOBAL IUH S_0431_CiSetVideocalc_data_xor_00000044 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0431_CiSetVideocalc_data_xor_00000044_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0431_CiSetVideocalc_data_xor_00000044 = (IHPE)S_0431_CiSetVideocalc_data_xor_00000044 ;
GLOBAL IUH S_0432_CiSetVideocalc_latch_xor_00000045 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0432_CiSetVideocalc_latch_xor_00000045_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0432_CiSetVideocalc_latch_xor_00000045 = (IHPE)S_0432_CiSetVideocalc_latch_xor_00000045 ;
GLOBAL IUH S_0433_CiSetVideoread_byte_addr_00000046 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0433_CiSetVideoread_byte_addr_00000046_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0433_CiSetVideoread_byte_addr_00000046 = (IHPE)S_0433_CiSetVideoread_byte_addr_00000046 ;
GLOBAL IUH S_0434_CiSetVideov7_fg_latches_00000047 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0434_CiSetVideov7_fg_latches_00000047_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0434_CiSetVideov7_fg_latches_00000047 = (IHPE)S_0434_CiSetVideov7_fg_latches_00000047 ;
GLOBAL IUH S_0435_CiSetVideoGC_regs_00000048 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0435_CiSetVideoGC_regs_00000048_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0435_CiSetVideoGC_regs_00000048 = (IHPE)S_0435_CiSetVideoGC_regs_00000048 ;
GLOBAL IUH S_0436_CiSetVideolast_GC_index_00000049 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0436_CiSetVideolast_GC_index_00000049_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0436_CiSetVideolast_GC_index_00000049 = (IHPE)S_0436_CiSetVideolast_GC_index_00000049 ;
GLOBAL IUH S_0437_CiSetVideodither_0000004a IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0437_CiSetVideodither_0000004a_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0437_CiSetVideodither_0000004a = (IHPE)S_0437_CiSetVideodither_0000004a ;
GLOBAL IUH S_0438_CiSetVideowrmode_0000004b IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0438_CiSetVideowrmode_0000004b_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0438_CiSetVideowrmode_0000004b = (IHPE)S_0438_CiSetVideowrmode_0000004b ;
GLOBAL IUH S_0439_CiSetVideochain_0000004c IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0439_CiSetVideochain_0000004c_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0439_CiSetVideochain_0000004c = (IHPE)S_0439_CiSetVideochain_0000004c ;
GLOBAL IUH S_0440_CiSetVideowrstate_0000004d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0440_CiSetVideowrstate_0000004d_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0440_CiSetVideowrstate_0000004d = (IHPE)S_0440_CiSetVideowrstate_0000004d ;
GLOBAL IUH S_0441_CisetWritePointers_0000004e IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0441_CisetWritePointers_0000004e_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0441_CisetWritePointers_0000004e = (IHPE)S_0441_CisetWritePointers_0000004e ;
LOCAL IUH L30_1if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_1if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_1if_f = (IHPE)L30_1if_f ;
LOCAL IUH L30_5or2 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_5or2_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_5or2 = (IHPE)L30_5or2 ;
LOCAL IUH L30_6if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_6if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_6if_f = (IHPE)L30_6if_f ;
LOCAL IUH L30_7if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_7if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_7if_f = (IHPE)L30_7if_f ;
LOCAL IUH L30_8if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_8if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_8if_d = (IHPE)L30_8if_d ;
LOCAL IUH L30_9if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_9if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_9if_f = (IHPE)L30_9if_f ;
LOCAL IUH L30_11if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_11if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_11if_f = (IHPE)L30_11if_f ;
LOCAL IUH L30_13if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_13if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_13if_f = (IHPE)L30_13if_f ;
LOCAL IUH L30_14if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_14if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_14if_d = (IHPE)L30_14if_d ;
LOCAL IUH L30_12if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_12if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_12if_d = (IHPE)L30_12if_d ;
LOCAL IUH L30_10if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_10if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_10if_d = (IHPE)L30_10if_d ;
LOCAL IUH L30_3if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_3if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_3if_f = (IHPE)L30_3if_f ;
LOCAL IUH L30_15if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_15if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_15if_f = (IHPE)L30_15if_f ;
LOCAL IUH L30_16if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_16if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_16if_d = (IHPE)L30_16if_d ;
LOCAL IUH L30_4if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_4if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_4if_d = (IHPE)L30_4if_d ;
LOCAL IUH L30_2if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_2if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_2if_d = (IHPE)L30_2if_d ;
LOCAL IUH L30_0endgen IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_0endgen_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_0endgen = (IHPE)L30_0endgen ;
GLOBAL IUH S_0442_CisetReadPointers_0000004f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0442_CisetReadPointers_0000004f_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0442_CisetReadPointers_0000004f = (IHPE)S_0442_CisetReadPointers_0000004f ;
LOCAL IUH L30_17if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_17if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_17if_f = (IHPE)L30_17if_f ;
LOCAL IUH L30_19if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_19if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_19if_f = (IHPE)L30_19if_f ;
LOCAL IUH L30_21if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_21if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_21if_f = (IHPE)L30_21if_f ;
LOCAL IUH L30_22if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_22if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_22if_d = (IHPE)L30_22if_d ;
LOCAL IUH L30_20if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_20if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_20if_d = (IHPE)L30_20if_d ;
LOCAL IUH L30_18if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_18if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_18if_d = (IHPE)L30_18if_d ;
GLOBAL IUH S_0443_CisetMarkPointers_00000050 IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(S_0443_CisetMarkPointers_00000050_id,v1,v2,v3,v4));
}
GLOBAL IHPE j_S_0443_CisetMarkPointers_00000050 = (IHPE)S_0443_CisetMarkPointers_00000050 ;
LOCAL IUH L30_23if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_23if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_23if_f = (IHPE)L30_23if_f ;
LOCAL IUH L30_25if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_25if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_25if_f = (IHPE)L30_25if_f ;
LOCAL IUH L30_27if_f IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_27if_f_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_27if_f = (IHPE)L30_27if_f ;
LOCAL IUH L30_28if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_28if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_28if_d = (IHPE)L30_28if_d ;
LOCAL IUH L30_26if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_26if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_26if_d = (IHPE)L30_26if_d ;
LOCAL IUH L30_24if_d IFN4(IUH , v1, IUH , v2 , IUH , v3 ,IUH , v4 ) 
{
	return (crules(L30_24if_d_id,v1,v2,v3,v4));
}
LOCAL IHPE j_L30_24if_d = (IHPE)L30_24if_d ;
/* END of FUNCTIONS              */
/* DATA label definitions */
/* END of DATA label definitions */
/* DATA initializations   */
/* END of DATA initializations */
/* CODE inline section    */
LOCAL   IUH     crules  IFN5( ID ,id ,IUH ,v1 ,IUH ,v2 ,IUH ,v3 ,IUH, v4 )
{
IUH returnValue = (IUH)0; 
IUH		 *CopyLocalIUH = (IUH *)0; 
EXTENDED	*CopyLocalFPH = (EXTENDED *)0 ;
SAVED IUH		 *LocalIUH = (IUH *)0; 
SAVED EXTENDED	*LocalFPH = (EXTENDED *)0 ;
switch ( id ) 
{
	 /* J_SEG (IS32)(0) */
	case	S_0415_CiSetVideofwd_str_read_addr_00000034_id	:
		S_0415_CiSetVideofwd_str_read_addr_00000034	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6661)	;	
	*((IUH	*)&(r20))	=	(IS32)(1332)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6662)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0416_CiSetVideobwd_str_read_addr_00000035_id	:
		S_0416_CiSetVideobwd_str_read_addr_00000035	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6663)	;	
	*((IUH	*)&(r20))	=	(IS32)(1336)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6664)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0417_CiSetVideodirty_total_00000036_id	:
		S_0417_CiSetVideodirty_total_00000036	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6665)	;	
	*((IUH	*)&(r20))	=	(IS32)(1340)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6666)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0418_CiSetVideodirty_low_00000037_id	:
		S_0418_CiSetVideodirty_low_00000037	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6667)	;	
	*((IUH	*)&(r20))	=	(IS32)(1344)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6668)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0419_CiSetVideodirty_high_00000038_id	:
		S_0419_CiSetVideodirty_high_00000038	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6669)	;	
	*((IUH	*)&(r20))	=	(IS32)(1348)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6670)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0420_CiSetVideovideo_copy_00000039_id	:
		S_0420_CiSetVideovideo_copy_00000039	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6671)	;	
	*((IUH	*)&(r20))	=	(IS32)(1352)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6672)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0421_CiSetVideomark_byte_0000003a_id	:
		S_0421_CiSetVideomark_byte_0000003a	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6673)	;	
	*((IUH	*)&(r20))	=	(IS32)(1356)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6674)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0422_CiSetVideomark_word_0000003b_id	:
		S_0422_CiSetVideomark_word_0000003b	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6675)	;	
	*((IUH	*)&(r20))	=	(IS32)(1360)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6676)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0423_CiSetVideomark_string_0000003c_id	:
		S_0423_CiSetVideomark_string_0000003c	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6677)	;	
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6678)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0424_CiSetVideoread_shift_count_0000003d_id	:
		S_0424_CiSetVideoread_shift_count_0000003d	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6679)	;	
	*((IUH	*)&(r20))	=	(IS32)(1368)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6680)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0425_CiSetVideoread_mapped_plane_0000003e_id	:
		S_0425_CiSetVideoread_mapped_plane_0000003e	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6681)	;	
	*((IUH	*)&(r20))	=	(IS32)(1372)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6682)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0426_CiSetVideocolour_comp_0000003f_id	:
		S_0426_CiSetVideocolour_comp_0000003f	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6683)	;	
	*((IUH	*)&(r20))	=	(IS32)(1376)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6684)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0427_CiSetVideodont_care_00000040_id	:
		S_0427_CiSetVideodont_care_00000040	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6685)	;	
	*((IUH	*)&(r20))	=	(IS32)(1380)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6686)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0428_CiSetVideov7_bank_vid_copy_off_00000041_id	:
		S_0428_CiSetVideov7_bank_vid_copy_off_00000041	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6687)	;	
	*((IUH	*)&(r20))	=	(IS32)(1384)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6688)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0429_CiSetVideoscreen_ptr_00000042_id	:
		S_0429_CiSetVideoscreen_ptr_00000042	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6689)	;	
	*((IUH	*)&(r20))	=	(IS32)(1400)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6690)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0430_CiSetVideorotate_00000043_id	:
		S_0430_CiSetVideorotate_00000043	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6691)	;	
	*((IUH	*)&(r20))	=	(IS32)(1404)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6692)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0431_CiSetVideocalc_data_xor_00000044_id	:
		S_0431_CiSetVideocalc_data_xor_00000044	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6693)	;	
	*((IUH	*)&(r20))	=	(IS32)(1408)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6694)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0432_CiSetVideocalc_latch_xor_00000045_id	:
		S_0432_CiSetVideocalc_latch_xor_00000045	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6695)	;	
	*((IUH	*)&(r20))	=	(IS32)(1412)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6696)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0433_CiSetVideoread_byte_addr_00000046_id	:
		S_0433_CiSetVideoread_byte_addr_00000046	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6697)	;	
	*((IUH	*)&(r20))	=	(IS32)(1416)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6698)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0434_CiSetVideov7_fg_latches_00000047_id	:
		S_0434_CiSetVideov7_fg_latches_00000047	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6699)	;	
	*((IUH	*)&(r20))	=	(IS32)(1420)	;	
	*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU32	*)(LocalIUH+0)	+	REGLONG)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6700)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0435_CiSetVideoGC_regs_00000048_id	:
		S_0435_CiSetVideoGC_regs_00000048	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6701)	;	
	*((IUH	*)&(r20))	=	(IS32)(1424)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6702)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0436_CiSetVideolast_GC_index_00000049_id	:
		S_0436_CiSetVideolast_GC_index_00000049	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6703)	;	
	*((IUH	*)&(r20))	=	(IS32)(1428)	;	
	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6704)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0437_CiSetVideodither_0000004a_id	:
		S_0437_CiSetVideodither_0000004a	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6705)	;	
	*((IUH	*)&(r20))	=	(IS32)(1429)	;	
	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6706)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0438_CiSetVideowrmode_0000004b_id	:
		S_0438_CiSetVideowrmode_0000004b	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6707)	;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6708)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0439_CiSetVideochain_0000004c_id	:
		S_0439_CiSetVideochain_0000004c	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6709)	;	
	*((IUH	*)&(r20))	=	(IS32)(1431)	;	
	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6710)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0440_CiSetVideowrstate_0000004d_id	:
		S_0440_CiSetVideowrstate_0000004d	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r21))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6711)	;	
	*((IUH	*)&(r20))	=	(IS32)(1432)	;	
	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IU8	*)(LocalIUH+0)	+	REGBYTE)	;	
	*((IUH	*)(r1+0))	=	(IS32)(6712)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0441_CisetWritePointers_0000004e_id	:
		S_0441_CisetWritePointers_0000004e	:	

	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	4	>	0	)	LocalIUH	=	(IUH	*)malloc	(	4	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6713)	;	
	{	extern	IHPE	j_EvidWriteFuncs;	*((IUH	*)&(r21))	=	j_EvidWriteFuncs;	}	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1429)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L30_1if_f;	
	*((IUH	*)&(r21))	=	(IS32)(96)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1472)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1476)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1480)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1484)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1488)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1492)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1496)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1500)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1504)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1508)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1512)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1516)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	{	extern	IUH	L30_2if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_2if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_1if_f_id	:
		L30_1if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(288)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	==	*((IU8	*)&(r22)	+	REGBYTE))	goto	L30_5or2;	
	*((IUH	*)&(r20))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L30_3if_f;	
	case	L30_5or2_id	:
		L30_5or2:	;	
	*((IUH	*)&(r21))	=	(IS32)(1404)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IU32	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	<=	*((IU32	*)&(r22)	+	REGLONG))	goto	L30_6if_f;	
	{	extern	IHPE	j_EvidWriteFuncs;	*((IUH	*)&(r20))	=	j_EvidWriteFuncs;	}	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(48)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1472)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1476)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1480)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1484)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1488)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1492)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1496)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1500)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1504)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1508)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1512)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1516)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	{	extern	IUH	L30_0endgen()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_0endgen(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_6if_f_id	:
		L30_6if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L30_7if_f;	
	*((IUH	*)&(r20))	=	(IS32)(240)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	{	extern	IUH	L30_8if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_8if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_7if_f_id	:
		L30_7if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1248)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	case	L30_8if_d_id	:
		L30_8if_d:	;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(0)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L30_9if_f;	
	{	extern	IHPE	j_modeLookup;	*((IUH	*)&(r21))	=	j_modeLookup;	}	
	*((IUH	*)&(r22))	=	(IS32)(1432)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r22)))	);	
	*((IUH	*)&(r23))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r23))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r22))	=	(IS32)(12)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(*((IHPE	*)&(r21)))	)	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	+	*((IUH	*)(LocalIUH+0))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	{	extern	IUH	L30_10if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_10if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_9if_f_id	:
		L30_9if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L30_11if_f;	
	*((IUH	*)&(r20))	=	(IS32)(576)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	{	extern	IUH	L30_12if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_12if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_11if_f_id	:
		L30_11if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(2)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L30_13if_f;	
	*((IUH	*)&(r21))	=	(IS32)(624)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1432)	;	
	*((IUH	*)&(r22))	=	(IS32)(15)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	&	*((IU8	*)&(r22)	+	REGBYTE);	
	{	extern	IHPE	j_modeLookup;	*((IUH	*)&(r21))	=	j_modeLookup;	}	
	*((IUH	*)&(r20))	=	*((IU8	*)&(r20)	+	REGBYTE);	
	*((IUH	*)&(r23))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r23))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r22))	=	(IS32)(12)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(*((IHPE	*)&(r20)))	)	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	+	*((IUH	*)(LocalIUH+0))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	{	extern	IUH	L30_14if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_14if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_13if_f_id	:
		L30_13if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(816)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1432)	;	
	*((IUH	*)&(r22))	=	(IS32)(15)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	&	*((IU8	*)&(r22)	+	REGBYTE);	
	{	extern	IHPE	j_modeLookup;	*((IUH	*)&(r20))	=	j_modeLookup;	}	
	*((IUH	*)&(r21))	=	*((IU8	*)&(r21)	+	REGBYTE);	
	*((IUH	*)&(r23))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r23))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r22))	=	(IS32)(12)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(*((IHPE	*)&(r21)))	)	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	+	*((IUH	*)(LocalIUH+0))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	case	L30_14if_d_id	:
		L30_14if_d:	;	
	case	L30_12if_d_id	:
		L30_12if_d:	;	
	case	L30_10if_d_id	:
		L30_10if_d:	;	
	{	extern	IUH	L30_4if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_4if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_3if_f_id	:
		L30_3if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(1)	;	
	if	(*((IS8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	!=		*((IS8	*)&(r22)	+	REGBYTE))	goto	L30_15if_f;	
	*((IUH	*)&(r20))	=	(IS32)(1430)	;	
	*((IUH	*)&(r22))	=	(IS32)(12)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	*	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)&(r21)	+	REGBYTE);	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	+	*((IUH	*)(LocalIUH+0))	;		
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r21))	;	
	{	extern	IUH	L30_16if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_16if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_15if_f_id	:
		L30_15if_f:	;	
	{	extern	IHPE	j_EvidWriteFuncs;	*((IUH	*)&(r20))	=	j_EvidWriteFuncs;	}	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r20))	;	
	case	L30_16if_d_id	:
		L30_16if_d:	;	
	case	L30_4if_d_id	:
		L30_4if_d:	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1472)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1476)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1480)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1484)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1488)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1492)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1496)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1500)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1504)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1508)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1512)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)(LocalIUH+0))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1516)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+0))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	;	
	case	L30_2if_d_id	:
		L30_2if_d:	;	
	case	L30_0endgen_id	:
		L30_0endgen:	;	
	*((IUH	*)(r1+0))	=	(IS32)(6714)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0442_CisetReadPointers_0000004f_id	:
		S_0442_CisetReadPointers_0000004f	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6715)	;	
	{	extern	IHPE	j_EvidReadFuncs;	*((IUH	*)&(r21))	=	j_EvidReadFuncs;	}	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(0)	;	
	if	(*((ISH	*)(LocalIUH+0))	!=		*((ISH	*)&(r20)))	goto	L30_17if_f;	
	*((IUH	*)&(r21))	=	(IS32)(40)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(5)	;	
	*((IU8	*)&(r20)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	*	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r20))	=	*((IU8	*)&(r20)	+	REGBYTE);	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r20))	=	*((IUH	*)&(r20))	+	*((IUH	*)(LocalIUH+1))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1536)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1540)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1544)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1548)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1552)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	{	extern	IUH	L30_18if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_18if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_17if_f_id	:
		L30_17if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(1)	;	
	if	(*((ISH	*)(LocalIUH+0))	!=		*((ISH	*)&(r21)))	goto	L30_19if_f;	
	*((IUH	*)&(r20))	=	(IS32)(100)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(1431)	;	
	*((IUH	*)&(r22))	=	(IS32)(5)	;	
	*((IU8	*)&(r21)	+	REGBYTE)	=	*((IU8	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	*	*((IU8	*)&(r22)	+	REGBYTE)	;	
	*((IUH	*)&(r21))	=	*((IU8	*)&(r21)	+	REGBYTE);	
	*((IUH	*)&(r22))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	*	*((IUH	*)&(r22))	;	
	*((IUH	*)&(r21))	=	*((IUH	*)&(r21))	+	*((IUH	*)(LocalIUH+1))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1536)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1540)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1544)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1548)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1552)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	{	extern	IUH	L30_20if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_20if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_19if_f_id	:
		L30_19if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	if	(*((ISH	*)(LocalIUH+0))	!=		*((ISH	*)&(r20)))	goto	L30_21if_f;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1536)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1540)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1544)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1548)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1552)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	{	extern	IUH	L30_22if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_22if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_21if_f_id	:
		L30_21if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(20)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1536)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1540)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1544)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1548)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1552)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	;	
	case	L30_22if_d_id	:
		L30_22if_d:	;	
	case	L30_20if_d_id	:
		L30_20if_d:	;	
	case	L30_18if_d_id	:
		L30_18if_d:	;	
	*((IUH	*)(r1+0))	=	(IS32)(6716)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
	 /* J_SEG (IS32)(0) */
	case	S_0443_CisetMarkPointers_00000050_id	:
		S_0443_CisetMarkPointers_00000050	:	
	*((IUH	*)&(r2))	=	v1	;	
	/*	ENTER_SECTION	*/	CopyLocalIUH=LocalIUH;	CopyLocalFPH=LocalFPH;	
	if(	8	>	0	)	LocalIUH	=	(IUH	*)malloc	(	8	)	;
	if(	0	>	0	)	LocalFPH	=		(EXTENDED	*)malloc	(	0	)		;	
	{	extern	IHPE	j_Gdp;	*((IUH	*)&(r20))	=	j_Gdp;	}	
	*((IUH	*)&(r1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)(LocalIUH+0))	=	*((IUH	*)&(r2))	;	
	*((IUH	*)&(r17))	=	*((IUH	*)(r1+164))	;	
	*((IUH	*)&(r16))	=	*((IUH	*)(r1+168))	;	
	*((IUH	*)&(r15))	=	*((IUH	*)(r1+172))	;	
	*((IUH	*)&(r14))	=	*((IUH	*)(r1+176))	;	
	*((IUH	*)&(r13))	=	*((IUH	*)(r1+524))	;	
	*((IUH	*)&(r12))	=	*((IUH	*)(r1+552))	;	
	*((IUH	*)&(r11))	=	*((IUH	*)(r1+3064))	;	
	*((IUH	*)&(r10))	=	*((IUH	*)(r1+416))	;	
	*((IUH	*)&(r9))	=	*((IUH	*)(r1+420))	;	
	*((IUH	*)(r1+0))	=	(IS32)(6717)	;	
	{	extern	IHPE	j_EvidMarkFuncs;	*((IUH	*)&(r21))	=	j_EvidMarkFuncs;	}	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(2)	;	
	if	(*((ISH	*)(LocalIUH+0))	!=		*((ISH	*)&(r20)))	goto	L30_23if_f;	
	*((IUH	*)&(r21))	=	(IS32)(32)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1356)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1360)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	{	extern	IUH	L30_24if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_24if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_23if_f_id	:
		L30_23if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(0)	;	
	if	(*((ISH	*)(LocalIUH+0))	!=		*((ISH	*)&(r21)))	goto	L30_25if_f;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1356)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1360)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r21))	;	
	*((IUH	*)&(r20))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r20))	;		
	*((IUH	*)&(r21))	=	(IS32)(1364)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r21)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	{	extern	IUH	L30_26if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_26if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_25if_f_id	:
		L30_25if_f:	;	
	*((IUH	*)&(r20))	=	(IS32)(3)	;	
	if	(*((ISH	*)(LocalIUH+0))	!=		*((ISH	*)&(r20)))	goto	L30_27if_f;	
	*((IUH	*)&(r21))	=	(IS32)(48)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1356)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1360)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	{	extern	IUH	L30_28if_d()	;	
	IUH	returnValue,v1=0,v2=0,v3=0,v4=0;		returnValue	=	L30_28if_d(v1,v2,v3,v4);	return(returnValue);	}	
	/*	j_state	(IS32)(-2013004285),	(IS32)(0),	(IS32)(0)	*/
	case	L30_27if_f_id	:
		L30_27if_f:	;	
	*((IUH	*)&(r21))	=	(IS32)(16)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1356)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1360)	;	
	*((IUH	*)&(r22))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r23))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r22)))	+	*((IHPE	*)&(r23)))	)	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)&(r20))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)&(r20))	;	
	*((IUH	*)&(r21))	=	(IS32)(4)	;	
	*((IUH	*)(LocalIUH+1))	=	*((IUH	*)(LocalIUH+1))	+	*((IUH	*)&(r21))	;		
	*((IUH	*)&(r20))	=	(IS32)(1364)	;	
	*((IUH	*)&(r21))	=	*((IUH	*)(LocalIUH+1))	;	
	*((IUH	*)&(r22))	=	(IS32)(-4)	;	
	*((IUH	*)((*((IHPE	*)&(r1)))	+	*((IHPE	*)&(r20)))	)	=	*((IUH	*)((*((IHPE	*)&(r21)))	+	*((IHPE	*)&(r22)))	)	;	
	case	L30_28if_d_id	:
		L30_28if_d:	;	
	case	L30_26if_d_id	:
		L30_26if_d:	;	
	case	L30_24if_d_id	:
		L30_24if_d:	;	
	*((IUH	*)(r1+0))	=	(IS32)(6718)	;	
	*((IUH	*)(r1+164))	=	*((IUH	*)&(r17))	;	
	*((IUH	*)(r1+168))	=	*((IUH	*)&(r16))	;	
	*((IUH	*)(r1+172))	=	*((IUH	*)&(r15))	;	
	*((IUH	*)(r1+176))	=	*((IUH	*)&(r14))	;	
	*((IUH	*)(r1+524))	=	*((IUH	*)&(r13))	;	
	*((IUH	*)(r1+552))	=	*((IUH	*)&(r12))	;	
	*((IUH	*)(r1+3064))	=	*((IUH	*)&(r11))	;	
	*((IUH	*)(r1+416))	=	*((IUH	*)&(r10))	;	
	*((IUH	*)(r1+420))	=	*((IUH	*)&(r9))	;	
	/*	J_LEAVE_SECTION	*/
	if(LocalIUH)	free(LocalIUH)	;
	if(LocalFPH)	free(LocalFPH);
	LocalIUH=CopyLocalIUH	;LocalFPH=	CopyLocalFPH;
	return	;	
	/*	j_state	(IS32)(-2013004285),	(IS32)(-1),	(IS32)(0)	*/
/* END of inline CODE */
/* CODE outline section   */
}
}
/* END of outline CODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\string_c.h ===
#ifndef _String_c_h
#define _String_c_h
#endif /* ! _String_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\strint_c.h ===
#ifndef _StrInt_c_h
#define _StrInt_c_h
#define INTEL_FORWARDS (1)
#define INTEL_BACKWARDS (0)
#define BackwardsM (1)
#endif /* ! _StrInt_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\stack_c.h ===
#ifndef _Stack_c_h
#define _Stack_c_h
#define STACK_SAFETY_MARGIN_SHIFT (5)
#define STACK_SAFETY_MARGIN (32)
#define PAGE_SIZE (4096)
#define STK16_ITEM_SZ (2)
#define STK32_ITEM_SZ (4)
#define STK16_SLOT8 (-8)
#define STK16_SLOT7 (-7)
#define STK16_SLOT6 (-6)
#define STK16_SLOT5 (-5)
#define STK16_SLOT4 (-4)
#define STK16_SLOT3 (-3)
#define STK16_SLOT2 (-2)
#define STK16_SLOT1 (-1)
#define STK16_ITEM1 (0)
#define STK16_ITEM2 (1)
#define STK16_ITEM3 (2)
#define STK16_ITEM4 (3)
#define STK16_ITEM5 (4)
#define STK16_ITEM6 (5)
#define STK16_ITEM7 (6)
#define STK16_ITEM8 (7)
#define STK32_SLOT8 (-8)
#define STK32_SLOT7 (-7)
#define STK32_SLOT6 (-6)
#define STK32_SLOT5 (-5)
#define STK32_SLOT4 (-4)
#define STK32_SLOT3 (-3)
#define STK32_SLOT2 (-2)
#define STK32_SLOT1 (-1)
#define STK32_ITEM1 (0)
#define STK32_ITEM2 (1)
#define STK32_ITEM3 (2)
#define STK32_ITEM4 (3)
#define STK32_ITEM5 (4)
#define STK32_ITEM6 (5)
#define STK32_ITEM7 (6)
#define STK32_ITEM8 (7)
enum IronRequestType
{
	IRON_STACK = 0,
	IRON_STRUCT = 1
};
#endif /* ! _Stack_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sub_c.h ===
#ifndef _Sub_c_h
#define _Sub_c_h
#endif /* ! _Sub_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\stub_c.h ===
#ifndef _Stub_c_h
#define _Stub_c_h
#endif /* ! _Stub_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\strsub_c.h ===
#ifndef _StrSub_c_h
#define _StrSub_c_h
#endif /* ! _StrSub_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\sunhst_c.h ===
#ifndef _Sunhst_c_h
#define _Sunhst_c_h
#define SunBranchCodeSizeAdjustment (2)
#define SUN_HOST_DEST_REG_ID (16)
#define SunPureAddressAdjustment (8)
#define SunCallToRetAddrAdjustment (8)
#define SunFpuOverflowExceptionBit (8)
#define SunFpuUnderflowExceptionBit (7)
#define SunFpuPrecisionExceptionBit (5)
#endif /* ! _Sunhst_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\task_c.h ===
#ifndef _Task_c_h
#define _Task_c_h
#define TSS386_MINLIM (103)
#define TSS386_EIP_OFFSET (32)
#define TSS386_CR3_OFFSET (28)
#define TSS386_IO_MAP_PTR_OFS (102)
#define TSS286_MINLIM (41)
#define TSS286_IP_OFFSET (14)
#endif /* ! _Task_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\vglob.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\test_c.h ===
#ifndef _Test_c_h
#define _Test_c_h
#endif /* ! _Test_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\trace_c.h ===
#ifndef _Trace_c_h
#define _Trace_c_h
enum TraceBits
{
	TraceRecordBit = 0,
	TraceDisplayBit = 1,
	TracePromptBit = 2,
	TraceProfileBit = 3
};
struct TraceRingREC
{
	IUH *start;
	IUH *insert;
	IUH *end;
	IUH size;
	IUH count;
};
#endif /* ! _Trace_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\unchn_c.h ===
#ifndef _Unchn_c_h
#define _Unchn_c_h
#endif /* ! _Unchn_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\univer_c.h ===
#ifndef _Univer_c_h
#define _Univer_c_h
#define CsHashTableSize (128)
#define CsHashTableMask (127)
#define universeHandleBits (11)
#define UniHashTableSize (8192)
#define ConstraintGuessNULL ((struct ConstraintGuessREC*)0)
#define CsSelectorGuessNULL ((struct CsSelectorGuessREC*)0)
#define CsSelectorHashNULL ((struct CsSelectorHashREC*)0)
#define NumberOfUniverses (2000)
struct ConstraintGuessREC
{
	IU16 constraint;
	IS16 handleAdjust;
	IUH notUsed;
};
struct CsSelectorGuessREC
{
	IUH notUsed;
	IU16 CodeSegSelector;
	IS16 handleAdjust;
};
struct UniHashREC
{
	IU16 uniHandle;
	IS16 nextHashAdjust;
};
struct CsSelectorHashREC
{
	struct EntryPointCacheREC *oldUniverse;
	IU16 newCs;
	struct EntryPointCacheREC *newUniverse;
	struct CsSelectorHashREC *missLoop;
};
#endif /* ! _Univer_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\xchg_c.h ===
#ifndef _Xchg_c_h
#define _Xchg_c_h
#endif /* ! _Xchg_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\vglob_c.h ===
#ifndef _Vglob_c_h
#define _Vglob_c_h
#define NUM_WRITE_FUNCS (12)
#define NUM_MARK_FUNCS (4)
#define NUM_READ_FUNCS (5)
#endif /* ! _Vglob_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\xlat_c.h ===
#ifndef _Xlat_c_h
#define _Xlat_c_h
#endif /* ! _Xlat_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\xfer_c.h ===
#ifndef _Xfer_c_h
#define _Xfer_c_h
#define PMDC_SAMELEVEL (4)
#define PMDC_RING2 (2)
#define PMDC_RING1 (1)
#define PMDC_RING0 (0)
#define PM_SS_TSS (1)
#define PM_SS_STK (2)
enum xferTypeEnum
{
	PMXT_CALLF = 0,
	PMXT_JMPF = 1,
	PMXT_INT = 2
};
#endif /* ! _Xfer_c_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\dasm386\build.c ===
/*
 * Dummy file to make DASM386 build for NT prod variants.
 */

void BuildTheProdMasterPackYouBugger(void)
{
/*
 * Recurse!
 */

BuildTheProdMasterPackYouBugger();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\cvidc\vglfunc.c ===
#include "insignia.h"
#include "host_def.h"

#include "evidgen.h"


extern IHPE  S_0363_CiGetVideolatches_00000000 IFN0();
extern IHPE  S_0364_CiGetVideorplane_00000001 IFN0();
extern IHPE  S_0365_CiGetVideowplane_00000002 IFN0();
extern IHPE  S_0366_CiGetVideoscratch_00000003 IFN0();
extern IHPE  S_0367_CiGetVideosr_masked_val_00000004 IFN0();
extern IHPE  S_0368_CiGetVideosr_nmask_00000005 IFN0();
extern IHPE  S_0369_CiGetVideodata_and_mask_00000006 IFN0();
extern IHPE  S_0370_CiGetVideodata_xor_mask_00000007 IFN0();
extern IHPE  S_0371_CiGetVideolatch_xor_mask_00000008 IFN0();
extern IHPE  S_0372_CiGetVideobit_prot_mask_00000009 IFN0();
extern IHPE  S_0373_CiGetVideoplane_enable_0000000a IFN0();
extern IHPE  S_0374_CiGetVideoplane_enable_mask_0000000b IFN0();
extern IHPE  S_0375_CiGetVideosr_lookup_0000000c IFN0();
extern IHPE  S_0376_CiGetVideofwd_str_read_addr_0000000d IFN0();
extern IHPE  S_0377_CiGetVideobwd_str_read_addr_0000000e IFN0();
extern IHPE  S_0378_CiGetVideodirty_total_0000000f IFN0();
extern IHPE  S_0379_CiGetVideodirty_low_00000010 IFN0();
extern IHPE  S_0380_CiGetVideodirty_high_00000011 IFN0();
extern IHPE  S_0381_CiGetVideovideo_copy_00000012 IFN0();
extern IHPE  S_0382_CiGetVideomark_byte_00000013 IFN0();
extern IHPE  S_0383_CiGetVideomark_word_00000014 IFN0();
extern IHPE  S_0384_CiGetVideomark_string_00000015 IFN0();
extern IHPE  S_0385_CiGetVideoread_shift_count_00000016 IFN0();
extern IHPE  S_0386_CiGetVideoread_mapped_plane_00000017 IFN0();
extern IHPE  S_0387_CiGetVideocolour_comp_00000018 IFN0();
extern IHPE  S_0388_CiGetVideodont_care_00000019 IFN0();
extern IHPE  S_0389_CiGetVideov7_bank_vid_copy_off_0000001a IFN0();
extern IHPE  S_0390_CiGetVideoscreen_ptr_0000001b IFN0();
extern IHPE  S_0391_CiGetVideorotate_0000001c IFN0();
extern IHPE  S_0392_CiGetVideocalc_data_xor_0000001d IFN0();
extern IHPE  S_0393_CiGetVideocalc_latch_xor_0000001e IFN0();
extern IHPE  S_0394_CiGetVideoread_byte_addr_0000001f IFN0();
extern IHPE  S_0395_CiGetVideov7_fg_latches_00000020 IFN0();
extern IHPE  S_0396_CiGetVideoGC_regs_00000021 IFN0();
extern IHPE  S_0397_CiGetVideolast_GC_index_00000022 IFN0();
extern IHPE  S_0398_CiGetVideodither_00000023 IFN0();
extern IHPE  S_0399_CiGetVideowrmode_00000024 IFN0();
extern IHPE  S_0400_CiGetVideochain_00000025 IFN0();
extern IHPE  S_0401_CiGetVideowrstate_00000026 IFN0();
extern void  S_0402_CiSetVideolatches_00000027 IFN1(IHPE, value);
extern void  S_0403_CiSetVideorplane_00000028 IFN1(IHPE, value);
extern void  S_0404_CiSetVideowplane_00000029 IFN1(IHPE, value);
extern void  S_0405_CiSetVideoscratch_0000002a IFN1(IHPE, value);
extern void  S_0406_CiSetVideosr_masked_val_0000002b IFN1(IHPE, value);
extern void  S_0407_CiSetVideosr_nmask_0000002c IFN1(IHPE, value);
extern void  S_0408_CiSetVideodata_and_mask_0000002d IFN1(IHPE, value);
extern void  S_0409_CiSetVideodata_xor_mask_0000002e IFN1(IHPE, value);
extern void  S_0410_CiSetVideolatch_xor_mask_0000002f IFN1(IHPE, value);
extern void  S_0411_CiSetVideobit_prot_mask_00000030 IFN1(IHPE, value);
extern void  S_0412_CiSetVideoplane_enable_00000031 IFN1(IHPE, value);
extern void  S_0413_CiSetVideoplane_enable_mask_00000032 IFN1(IHPE, value);
extern void  S_0414_CiSetVideosr_lookup_00000033 IFN1(IHPE, value);
extern void  S_0415_CiSetVideofwd_str_read_addr_00000034 IFN1(IHPE, value);
extern void  S_0416_CiSetVideobwd_str_read_addr_00000035 IFN1(IHPE, value);
extern void  S_0417_CiSetVideodirty_total_00000036 IFN1(IHPE, value);
extern void  S_0418_CiSetVideodirty_low_00000037 IFN1(IHPE, value);
extern void  S_0419_CiSetVideodirty_high_00000038 IFN1(IHPE, value);
extern void  S_0420_CiSetVideovideo_copy_00000039 IFN1(IHPE, value);
extern void  S_0421_CiSetVideomark_byte_0000003a IFN1(IHPE, value);
extern void  S_0422_CiSetVideomark_word_0000003b IFN1(IHPE, value);
extern void  S_0423_CiSetVideomark_string_0000003c IFN1(IHPE, value);
extern void  S_0424_CiSetVideoread_shift_count_0000003d IFN1(IHPE, value);
extern void  S_0425_CiSetVideoread_mapped_plane_0000003e IFN1(IHPE, value);
extern void  S_0426_CiSetVideocolour_comp_0000003f IFN1(IHPE, value);
extern void  S_0427_CiSetVideodont_care_00000040 IFN1(IHPE, value);
extern void  S_0428_CiSetVideov7_bank_vid_copy_off_00000041 IFN1(IHPE, value);
extern void  S_0429_CiSetVideoscreen_ptr_00000042 IFN1(IHPE, value);
extern void  S_0430_CiSetVideorotate_00000043 IFN1(IHPE, value);
extern void  S_0431_CiSetVideocalc_data_xor_00000044 IFN1(IHPE, value);
extern void  S_0432_CiSetVideocalc_latch_xor_00000045 IFN1(IHPE, value);
extern void  S_0433_CiSetVideoread_byte_addr_00000046 IFN1(IHPE, value);
extern void  S_0434_CiSetVideov7_fg_latches_00000047 IFN1(IHPE, value);
extern void  S_0435_CiSetVideoGC_regs_00000048 IFN1(IHPE, value);
extern void  S_0436_CiSetVideolast_GC_index_00000049 IFN1(IHPE, value);
extern void  S_0437_CiSetVideodither_0000004a IFN1(IHPE, value);
extern void  S_0438_CiSetVideowrmode_0000004b IFN1(IHPE, value);
extern void  S_0439_CiSetVideochain_0000004c IFN1(IHPE, value);
extern void  S_0440_CiSetVideowrstate_0000004d IFN1(IHPE, value);

struct VideoVector C_Video = 
 {

    S_0363_CiGetVideolatches_00000000,
    S_0364_CiGetVideorplane_00000001,
    S_0365_CiGetVideowplane_00000002,
    S_0366_CiGetVideoscratch_00000003,
    S_0367_CiGetVideosr_masked_val_00000004,
    S_0368_CiGetVideosr_nmask_00000005,
    S_0369_CiGetVideodata_and_mask_00000006,
    S_0370_CiGetVideodata_xor_mask_00000007,
    S_0371_CiGetVideolatch_xor_mask_00000008,
    S_0372_CiGetVideobit_prot_mask_00000009,
    S_0373_CiGetVideoplane_enable_0000000a,
    S_0374_CiGetVideoplane_enable_mask_0000000b,
    S_0375_CiGetVideosr_lookup_0000000c,
    S_0376_CiGetVideofwd_str_read_addr_0000000d,
    S_0377_CiGetVideobwd_str_read_addr_0000000e,
    S_0378_CiGetVideodirty_total_0000000f,
    S_0379_CiGetVideodirty_low_00000010,
    S_0380_CiGetVideodirty_high_00000011,
    S_0381_CiGetVideovideo_copy_00000012,
    S_0382_CiGetVideomark_byte_00000013,
    S_0383_CiGetVideomark_word_00000014,
    S_0384_CiGetVideomark_string_00000015,
    S_0385_CiGetVideoread_shift_count_00000016,
    S_0386_CiGetVideoread_mapped_plane_00000017,
    S_0387_CiGetVideocolour_comp_00000018,
    S_0388_CiGetVideodont_care_00000019,
    S_0389_CiGetVideov7_bank_vid_copy_off_0000001a,
    S_0390_CiGetVideoscreen_ptr_0000001b,
    S_0391_CiGetVideorotate_0000001c,
    S_0392_CiGetVideocalc_data_xor_0000001d,
    S_0393_CiGetVideocalc_latch_xor_0000001e,
    S_0394_CiGetVideoread_byte_addr_0000001f,
    S_0395_CiGetVideov7_fg_latches_00000020,
    S_0396_CiGetVideoGC_regs_00000021,
    S_0397_CiGetVideolast_GC_index_00000022,
    S_0398_CiGetVideodither_00000023,
    S_0399_CiGetVideowrmode_00000024,
    S_0400_CiGetVideochain_00000025,
    S_0401_CiGetVideowrstate_00000026,
    S_0402_CiSetVideolatches_00000027,
    S_0403_CiSetVideorplane_00000028,
    S_0404_CiSetVideowplane_00000029,
    S_0405_CiSetVideoscratch_0000002a,
    S_0406_CiSetVideosr_masked_val_0000002b,
    S_0407_CiSetVideosr_nmask_0000002c,
    S_0408_CiSetVideodata_and_mask_0000002d,
    S_0409_CiSetVideodata_xor_mask_0000002e,
    S_0410_CiSetVideolatch_xor_mask_0000002f,
    S_0411_CiSetVideobit_prot_mask_00000030,
    S_0412_CiSetVideoplane_enable_00000031,
    S_0413_CiSetVideoplane_enable_mask_00000032,
    S_0414_CiSetVideosr_lookup_00000033,
    S_0415_CiSetVideofwd_str_read_addr_00000034,
    S_0416_CiSetVideobwd_str_read_addr_00000035,
    S_0417_CiSetVideodirty_total_00000036,
    S_0418_CiSetVideodirty_low_00000037,
    S_0419_CiSetVideodirty_high_00000038,
    S_0420_CiSetVideovideo_copy_00000039,
    S_0421_CiSetVideomark_byte_0000003a,
    S_0422_CiSetVideomark_word_0000003b,
    S_0423_CiSetVideomark_string_0000003c,
    S_0424_CiSetVideoread_shift_count_0000003d,
    S_0425_CiSetVideoread_mapped_plane_0000003e,
    S_0426_CiSetVideocolour_comp_0000003f,
    S_0427_CiSetVideodont_care_00000040,
    S_0428_CiSetVideov7_bank_vid_copy_off_00000041,
    S_0429_CiSetVideoscreen_ptr_00000042,
    S_0430_CiSetVideorotate_00000043,
    S_0431_CiSetVideocalc_data_xor_00000044,
    S_0432_CiSetVideocalc_latch_xor_00000045,
    S_0433_CiSetVideoread_byte_addr_00000046,
    S_0434_CiSetVideov7_fg_latches_00000047,
    S_0435_CiSetVideoGC_regs_00000048,
    S_0436_CiSetVideolast_GC_index_00000049,
    S_0437_CiSetVideodither_0000004a,
    S_0438_CiSetVideowrmode_0000004b,
    S_0439_CiSetVideochain_0000004c,
    S_0440_CiSetVideowrstate_0000004d, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\dasm386\dasm386.c ===
/*[

   dasm.c

   LOCAL CHAR SccsID[]="@(#)dasm386.c	1.14 07/25/94 Copyright Insignia Solutions Ltd.";

   Dis-assemble an Intel Instruction
   ---------------------------------

   The possible formats are:-

      ssss:oooo 11223344     PRE INST ARGS

      ssss:oooo 11223344556677
      		         PRE PRE INST ARGS

      ssss:oooo 1122334455667788 INST ARGS
		99001122334455

      ssss:oooo 1122334455667788
		99001122334455
      		         PRE PRE INST ARGS

      ssss:oooo 1122334455667788 INST ARGS

      etc.
]*/

#include "insignia.h"
#include "host_def.h"
#include "xt.h"


#include <stdio.h>

/* dasm386 forms part of the ccpu386.o (and ccpu386.o) libraries
 * used for pigging, and as part of spc.ccpu386.
 * When used for pigging the CCPU sas is not available, and will
 * cause link errors is "sas_hw_at" is used in this file.
 * We #undef CCPU to avoid this problem sogul "sas_xxx" be added
 * in this file at a later date.
 */
#ifdef	PIG
#undef	CCPU
#endif	/* PIG */
#include "sas.h"

#define DASM_INTERNAL
#include "decode.h"
#include "dasm.h"
#include "d_oper.h"
#include "d_inst.h"

#include CpuH

/*
   The instruction names.
   **MUST** be in same order as "d_inst.h".
 */
LOCAL CHAR *inst_name[] =
   {
   "AAA",		/* I_AAA	*/
   "AAD",		/* I_AAD	*/
   "AAM",		/* I_AAM	*/
   "AAS",		/* I_AAS	*/
   "ADC",		/* I_ADC8	*/
   "ADC",		/* I_ADC16	*/
   "ADC",		/* I_ADC32	*/
   "ADD",		/* I_ADD8	*/
   "ADD",		/* I_ADD16	*/
   "ADD",		/* I_ADD32	*/
   "AND",		/* I_AND8	*/
   "AND",		/* I_AND16	*/
   "AND",		/* I_AND32	*/
   "ARPL",		/* I_ARPL	*/
   "BOUND",		/* I_BOUND16	*/
   "BOUND",		/* I_BOUND32	*/
   "BSF",		/* I_BSF16	*/
   "BSF",		/* I_BSF32	*/
   "BSR",		/* I_BSR16	*/
   "BSR",		/* I_BSR32	*/
   "BSWAP",		/* I_BSWAP	*/
   "BT",		/* I_BT16	*/
   "BT",		/* I_BT32	*/
   "BTC",		/* I_BTC16	*/
   "BTC",		/* I_BTC32	*/
   "BTR",		/* I_BTR16	*/
   "BTR",		/* I_BTR32	*/
   "BTS",		/* I_BTS16	*/
   "BTS",		/* I_BTS32	*/
   "CALLF",		/* I_CALLF16	*/
   "CALLF",		/* I_CALLF32	*/
   "CALLN",		/* I_CALLN16	*/
   "CALLN",		/* I_CALLN32	*/
   "CALLN",		/* I_CALLR16	*/
   "CALLN",		/* I_CALLR32	*/
   "CBW",		/* I_CBW	*/
   "CDQ",		/* I_CDQ	*/
   "CLC",		/* I_CLC	*/
   "CLD",		/* I_CLD	*/
   "CLI",		/* I_CLI	*/
   "CLTS",		/* I_CLTS	*/
   "CMC",		/* I_CMC	*/
   "CMP",		/* I_CMP8	*/
   "CMP",		/* I_CMP16	*/
   "CMP",		/* I_CMP32	*/
   "CMPSB",		/* I_CMPSB	*/
   "CMPSD",		/* I_CMPSD	*/
   "CMPSW",		/* I_CMPSW	*/
   "CMPXCHG",		/* I_CMPXCHG8	*/
   "CMPXCHG",		/* I_CMPXCHG16	*/
   "CMPXCHG",		/* I_CMPXCHG32	*/
   "CWD",		/* I_CWD	*/
   "CWDE",		/* I_CWDE	*/
   "DAA",		/* I_DAA	*/
   "DAS",		/* I_DAS	*/
   "DEC",		/* I_DEC8	*/
   "DEC",		/* I_DEC16	*/
   "DEC",		/* I_DEC32	*/
   "DIV",		/* I_DIV8	*/
   "DIV",		/* I_DIV16	*/
   "DIV",		/* I_DIV32	*/
   "ENTER",		/* I_ENTER16	*/
   "ENTER",		/* I_ENTER32	*/
   "F2XM1",		/* I_F2XM1	*/
   "FABS",		/* I_FABS	*/
   "FADD",		/* I_FADD	*/
   "FADDP",		/* I_FADDP	*/
   "FBLD",		/* I_FBLD	*/
   "FBSTP",		/* I_FBSTP	*/
   "FCHS",		/* I_FCHS	*/
   "FCLEX",		/* I_FCLEX	*/
   "FCOM",		/* I_FCOM	*/
   "FCOMP",		/* I_FCOMP	*/
   "FCOMPP",		/* I_FCOMPP	*/
   "FCOS",		/* I_FCOS	*/
   "FDECSTP",		/* I_FDECSTP	*/
   "FDIV",		/* I_FDIV	*/
   "FDIVP",		/* I_FDIVP	*/
   "FDIVR",		/* I_FDIVR	*/
   "FDIVRP",		/* I_FDIVRP	*/
   "FFREE",		/* I_FFREE	*/
   "FFREEP",		/* I_FFREEP	*/
   "FIADD",		/* I_FIADD	*/
   "FICOM",		/* I_FICOM	*/
   "FICOMP",		/* I_FICOMP	*/
   "FIDIV",		/* I_FIDIV	*/
   "FIDIVR",		/* I_FIDIVR	*/
   "FILD",		/* I_FILD	*/
   "FIMUL",		/* I_FIMUL	*/
   "FINCSTP",		/* I_FINCSTP	*/
   "FINIT",		/* I_FINIT	*/
   "FIST",		/* I_FIST	*/
   "FISTP",		/* I_FISTP	*/
   "FISUB",		/* I_FISUB	*/
   "FISUBR",		/* I_FISUBR	*/
   "FLD",		/* I_FLD	*/
   "FLD1",		/* I_FLD1	*/
   "FLDCW",		/* I_FLDCW	*/
   "FLDENV",		/* I_FLDENV16	*/
   "FLDENV",		/* I_FLDENV32	*/
   "FLDL2E",		/* I_FLDL2E	*/
   "FLDL2T",		/* I_FLDL2T	*/
   "FLDLG2",		/* I_FLDLG2	*/
   "FLDLN2",		/* I_FLDLN2	*/
   "FLDPI",		/* I_FLDPI	*/
   "FLDZ",		/* I_FLDZ	*/
   "FMUL",		/* I_FMUL	*/
   "FMULP",		/* I_FMULP	*/
   "FNOP",		/* I_FNOP	*/
   "FPATAN",		/* I_FPATAN	*/
   "FPREM",		/* I_FPREM	*/
   "FPREM1",		/* I_FPREM1	*/
   "FPTAN",		/* I_FPTAN	*/
   "FRNDINT",		/* I_FRNDINT	*/
   "FRSTOR",		/* I_FRSTOR16	*/
   "FRSTOR",		/* I_FRSTOR32	*/
   "FSAVE",		/* I_FSAVE16	*/
   "FSAVE",		/* I_FSAVE32	*/
   "FSCALE",		/* I_FSCALE	*/
   "FSETPM",		/* I_FSETPM	*/
   "FSIN",		/* I_FSIN	*/
   "FSINCOS",		/* I_FSINCOS	*/
   "FSQRT",		/* I_FSQRT	*/
   "FST",		/* I_FST	*/
   "FSTCW",		/* I_FSTCW	*/
   "FSTENV",		/* I_FSTENV16	*/
   "FSTENV",		/* I_FSTENV32	*/
   "FSTP",		/* I_FSTP	*/
   "FSTSW",		/* I_FSTSW	*/
   "FSUB",		/* I_FSUB	*/
   "FSUBP",		/* I_FSUBP	*/
   "FSUBR",		/* I_FSUBR	*/
   "FSUBRP",		/* I_FSUBRP	*/
   "FTST",		/* I_FTST	*/
   "FUCOM",		/* I_FUCOM	*/
   "FUCOMP",		/* I_FUCOMP	*/
   "FUCOMPP",		/* I_FUCOMPP	*/
   "FXAM",		/* I_FXAM	*/
   "FXCH",		/* I_FXCH	*/
   "FXTRACT",		/* I_FXTRACT	*/
   "FYL2X",		/* I_FYL2X	*/
   "FYL2XP1",		/* I_FYL2XP1	*/
   "HLT",		/* I_HLT	*/
   "IDIV",		/* I_IDIV8	*/
   "IDIV",		/* I_IDIV16	*/
   "IDIV",		/* I_IDIV32	*/
   "IMUL",		/* I_IMUL8	*/
   "IMUL",		/* I_IMUL16	*/
   "IMUL",		/* I_IMUL32	*/
   "IMUL",		/* I_IMUL16T2	*/
   "IMUL",		/* I_IMUL16T3	*/
   "IMUL",		/* I_IMUL32T2	*/
   "IMUL",		/* I_IMUL32T3	*/
   "IN",		/* I_IN8	*/
   "IN",		/* I_IN16	*/
   "IN",		/* I_IN32	*/
   "INC",		/* I_INC8	*/
   "INC",		/* I_INC16	*/
   "INC",		/* I_INC32	*/
   "INSB",		/* I_INSB	*/
   "INSD",		/* I_INSD	*/
   "INSW",		/* I_INSW	*/
   "INT",		/* I_INT3	*/
   "INT",		/* I_INT	*/
   "INTO",		/* I_INTO	*/
   "INVD",		/* I_INVD	*/
   "INVLPG",		/* I_INVLPG	*/
   "IRET",		/* I_IRET	*/
   "IRETD",		/* I_IRETD	*/
   "JB",		/* I_JB16	*/
   "JB",		/* I_JB32	*/
   "JBE",		/* I_JBE16	*/
   "JBE",		/* I_JBE32	*/
   "JCXZ",		/* I_JCXZ	*/
   "JECXZ",		/* I_JECXZ	*/
   "JL",		/* I_JL16	*/
   "JL",		/* I_JL32	*/
   "JLE",		/* I_JLE16	*/
   "JLE",		/* I_JLE32	*/
   "JMP",		/* I_JMPF16	*/
   "JMP",		/* I_JMPF32	*/
   "JMP",		/* I_JMPN	*/
   "JMP",		/* I_JMPR16	*/
   "JMP",		/* I_JMPR32	*/
   "JNB",		/* I_JNB16	*/
   "JNB",		/* I_JNB32	*/
   "JNBE",		/* I_JNBE16	*/
   "JNBE",		/* I_JNBE32	*/
   "JNL",		/* I_JNL16	*/
   "JNL",		/* I_JNL32	*/
   "JNLE",		/* I_JNLE16	*/
   "JNLE",		/* I_JNLE32	*/
   "JNO",		/* I_JNO16	*/
   "JNO",		/* I_JNO32	*/
   "JNP",		/* I_JNP16	*/
   "JNP",		/* I_JNP32	*/
   "JNS",		/* I_JNS16	*/
   "JNS",		/* I_JNS32	*/
   "JNZ",		/* I_JNZ16	*/
   "JNZ",		/* I_JNZ32	*/
   "JO",		/* I_JO16	*/
   "JO",		/* I_JO32	*/
   "JP",		/* I_JP16	*/
   "JP",		/* I_JP32	*/
   "JS",		/* I_JS16	*/
   "JS",		/* I_JS32	*/
   "JZ",		/* I_JZ16	*/
   "JZ",		/* I_JZ32	*/
   "LAHF",		/* I_LAHF	*/
   "LAR",		/* I_LAR	*/
   "LDS",		/* I_LDS	*/
   "LEA",		/* I_LEA	*/
   "LEAVE",		/* I_LEAVE16	*/
   "LEAVE",		/* I_LEAVE32	*/
   "LES",		/* I_LES	*/
   "LFS",		/* I_LFS	*/
   "LGDT",		/* I_LGDT16	*/
   "LGDT",		/* I_LGDT32	*/
   "LGS",		/* I_LGS	*/
   "LIDT",		/* I_LIDT16	*/
   "LIDT",		/* I_LIDT32	*/
   "LLDT",		/* I_LLDT	*/
   "LMSW",		/* I_LMSW	*/
   "LOADALL",		/* I_LOADALL	*/
   "LOCK",		/* I_LOCK	*/
   "LODSB",		/* I_LODSB	*/
   "LODSD",		/* I_LODSD	*/
   "LODSW",		/* I_LODSW	*/
   "LOOP",		/* I_LOOP16	*/
   "LOOP",		/* I_LOOP32	*/
   "LOOPE",		/* I_LOOPE16	*/
   "LOOPE",		/* I_LOOPE32	*/
   "LOOPNE",		/* I_LOOPNE16	*/
   "LOOPNE",		/* I_LOOPNE32	*/
   "LSL",		/* I_LSL	*/
   "LSS",		/* I_LSS	*/
   "LTR",		/* I_LTR	*/
   "MOV",		/* I_MOV_SR	*/
   "MOV",		/* I_MOV_CR	*/
   "MOV",		/* I_MOV_DR	*/
   "MOV",		/* I_MOV_TR	*/
   "MOV",		/* I_MOV8	*/
   "MOV",		/* I_MOV16	*/
   "MOV",		/* I_MOV32	*/
   "MOVSB",		/* I_MOVSB	*/
   "MOVSD",		/* I_MOVSD	*/
   "MOVSW",		/* I_MOVSW	*/
   "MOVSX",		/* I_MOVSX8	*/
   "MOVSX",		/* I_MOVSX16	*/
   "MOVZX",		/* I_MOVZX8	*/
   "MOVZX",		/* I_MOVZX16	*/
   "MUL",		/* I_MUL8	*/
   "MUL",		/* I_MUL16	*/
   "MUL",		/* I_MUL32	*/
   "NEG",		/* I_NEG8	*/
   "NEG",		/* I_NEG16	*/
   "NEG",		/* I_NEG32	*/
   "NOP",		/* I_NOP	*/
   "NOT",		/* I_NOT8	*/
   "NOT",		/* I_NOT16	*/
   "NOT",		/* I_NOT32	*/
   "OR",		/* I_OR8	*/
   "OR",		/* I_OR16	*/
   "OR",		/* I_OR32	*/
   "OUT",		/* I_OUT8	*/
   "OUT",		/* I_OUT16	*/
   "OUT",		/* I_OUT32	*/
   "OUTSB",		/* I_OUTSB	*/
   "OUTSD",		/* I_OUTSD	*/
   "OUTSW",		/* I_OUTSW	*/
   "POP",		/* I_POP16	*/
   "POP",		/* I_POP32	*/
   "POP",		/* I_POP_SR	*/
   "POPA",		/* I_POPA	*/
   "POPAD",		/* I_POPAD	*/
   "POPF",		/* I_POPF	*/
   "POPFD",		/* I_POPFD	*/
   "PUSH",		/* I_PUSH16	*/
   "PUSH",		/* I_PUSH32	*/
   "PUSHA",		/* I_PUSHA	*/
   "PUSHAD",		/* I_PUSHAD	*/
   "PUSHF",		/* I_PUSHF	*/
   "PUSHFD",		/* I_PUSHFD	*/
   "RCL",		/* I_RCL8	*/
   "RCL",		/* I_RCL16	*/
   "RCL",		/* I_RCL32	*/
   "RCR",		/* I_RCR8	*/
   "RCR",		/* I_RCR16	*/
   "RCR",		/* I_RCR32	*/
   "RETF",		/* I_RETF16	*/
   "RETF",		/* I_RETF32	*/
   "RET",		/* I_RETN16	*/
   "RET",		/* I_RETN32	*/
   "ROL",		/* I_ROL8	*/
   "ROL",		/* I_ROL16	*/
   "ROL",		/* I_ROL32	*/
   "ROR",		/* I_ROR8	*/
   "ROR",		/* I_ROR16	*/
   "ROR",		/* I_ROR32	*/
   "REP INSB",		/* I_R_INSB	*/
   "REP INSD",		/* I_R_INSD	*/
   "REP INSW",		/* I_R_INSW	*/
   "REP OUTSB",		/* I_R_OUTSB	*/
   "REP OUTSD",		/* I_R_OUTSD	*/
   "REP OUTSW",		/* I_R_OUTSW	*/
   "REP LODSB",		/* I_R_LODSB	*/
   "REP LODSD",		/* I_R_LODSD	*/
   "REP LODSW",		/* I_R_LODSW	*/
   "REP MOVSB",		/* I_R_MOVSB	*/
   "REP MOVSD",		/* I_R_MOVSD	*/
   "REP MOVSW",		/* I_R_MOVSW	*/
   "REP STOSB",		/* I_R_STOSB	*/
   "REP STOSD",		/* I_R_STOSD	*/
   "REP STOSW",		/* I_R_STOSW	*/
   "REPE CMPSB",	/* I_RE_CMPSB	*/
   "REPE CMPSD",	/* I_RE_CMPSD	*/
   "REPE CMPSW",	/* I_RE_CMPSW	*/
   "REPNE CMPSB",	/* I_RNE_CMPSB	*/
   "REPNE CMPSD",	/* I_RNE_CMPSD	*/
   "REPNE CMPSW",	/* I_RNE_CMPSW	*/
   "REPE SCASB",	/* I_RE_SCASB	*/
   "REPE SCASD",	/* I_RE_SCASD	*/
   "REPE SCASW",	/* I_RE_SCASW	*/
   "REPNE SCASB",	/* I_RNE_SCASB	*/
   "REPNE SCASD",	/* I_RNE_SCASD	*/
   "REPNE SCASW",	/* I_RNE_SCASW	*/
   "SAHF",		/* I_SAHF	*/
   "SAR",		/* I_SAR8	*/
   "SAR",		/* I_SAR16	*/
   "SAR",		/* I_SAR32	*/
   "SBB",		/* I_SBB8	*/
   "SBB",		/* I_SBB16	*/
   "SBB",		/* I_SBB32	*/
   "SCASB",		/* I_SCASB	*/
   "SCASD",		/* I_SCASD	*/
   "SCASW",		/* I_SCASW	*/
   "SETB",		/* I_SETB	*/
   "SETBE",		/* I_SETBE	*/
   "SETL",		/* I_SETL	*/
   "SETLE",		/* I_SETLE	*/
   "SETNB",		/* I_SETNB	*/
   "SETNBE",		/* I_SETNBE	*/
   "SETNL",		/* I_SETNL	*/
   "SETNLE",		/* I_SETNLE	*/
   "SETNO",		/* I_SETNO	*/
   "SETNP",		/* I_SETNP	*/
   "SETNS",		/* I_SETNS	*/
   "SETNZ",		/* I_SETNZ	*/
   "SETO",		/* I_SETO	*/
   "SETP",		/* I_SETP	*/
   "SETS",		/* I_SETS	*/
   "SETZ",		/* I_SETZ	*/
   "SGDT",		/* I_SGDT16	*/
   "SGDT",		/* I_SGDT32	*/
   "SHL",		/* I_SHL8	*/
   "SHL",		/* I_SHL16	*/
   "SHL",		/* I_SHL32	*/
   "SHLD",		/* I_SHLD16	*/
   "SHLD",		/* I_SHLD32	*/
   "SHR",		/* I_SHR8	*/
   "SHR",		/* I_SHR16	*/
   "SHR",		/* I_SHR32	*/
   "SHRD",		/* I_SHRD16	*/
   "SHRD",		/* I_SHRD32	*/
   "SIDT",		/* I_SIDT16	*/
   "SIDT",		/* I_SIDT32	*/
   "SLDT",		/* I_SLDT	*/
   "SMSW",		/* I_SMSW	*/
   "STC",		/* I_STC	*/
   "STD",		/* I_STD	*/
   "STI",		/* I_STI	*/
   "STOSB",		/* I_STOSB	*/
   "STOSD",		/* I_STOSD	*/
   "STOSW",		/* I_STOSW	*/
   "STR",		/* I_STR	*/
   "SUB",		/* I_SUB8	*/
   "SUB",		/* I_SUB16	*/
   "SUB",		/* I_SUB32	*/
   "TEST",		/* I_TEST8	*/
   "TEST",		/* I_TEST16	*/
   "TEST",		/* I_TEST32	*/
   "VERR",		/* I_VERR	*/
   "VERW",		/* I_VERW	*/
   "WAIT",		/* I_WAIT	*/
   "WBINVD",		/* I_WBINVD	*/
   "XADD",		/* I_XADD8	*/
   "XADD",		/* I_XADD16	*/
   "XADD",		/* I_XADD32	*/
   "XCHG",		/* I_XCHG8	*/
   "XCHG",		/* I_XCHG16	*/
   "XCHG",		/* I_XCHG32	*/
   "XLAT",		/* I_XLAT	*/
   "XOR",		/* I_XOR8	*/
   "XOR",		/* I_XOR16	*/
   "XOR",		/* I_XOR32	*/
   "????",		/* I_ZBADOP	*/
   "BOP",		/* I_ZBOP	*/
   "FRSRVD",		/* I_ZFRSRVD	*/
   "RSRVD", 		/* I_ZRSRVD	*/
   "UNSIMULATE"		/* I_ZZEXIT	*/
   };

#define NR_VALID_INSTS (sizeof(inst_name)/sizeof(CHAR *))

/*
   Character to print before each argument.
 */
LOCAL CHAR arg_preface[] = { ' ', ',', ',' };

/*
   Register (byte) names.
 */
LOCAL CHAR *Rb_name[] =
   {
   "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH"
   };

/*
   Register (word) names.
 */
LOCAL CHAR *Rw_name[] =
   {
   "AX", "CX", "DX", "BX", "SP", "BP", "SI", "DI"
   };

/*
   Register (double word) names.
 */
LOCAL CHAR *Rd_name[] =
   {
   "EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI"
   };

/*
   Segment Register (word) names.
 */
LOCAL CHAR *Sw_name[] =
   {
   "ES", "CS", "SS", "DS", "FS", "GS"
   };

/*
   Control Register (double word) names.
 */
LOCAL CHAR *Cd_name[] =
   {
   "CR0",        "CR1(UNDEF)", "CR2",        "CR3",
   "CR4(UNDEF)", "CR5(UNDEF)", "CR6(UNDEF)", "CR7(UNDEF)"
   };

/*
   Debug Register (double word) names.
 */
LOCAL CHAR *Dd_name[] =
   {
   "DR0", "DR1", "DR2", "DR3", "DR4(UNDEF)", "DR5(UNDEF)", "DR6", "DR7"
   };

/*
   Test Register (double word) names.
 */
LOCAL CHAR *Td_name[] =
   {
   "TR0(UNDEF)", "TR1(UNDEF)", "TR2(UNDEF)", "TR3",
   "TR4",        "TR5",        "TR6",        "TR7"
   };

/*
   Memory Addressing names.
 */

typedef struct
   {
   CHAR *positive;
   CHAR *negative;
   ULONG disp_mask;
   ULONG sign_mask;
   } MEM_RECORD;

LOCAL MEM_RECORD mem_name[] =
   {
   { "%s[BX+SI%s]",      "%s[BX+SI%s]",      0x00000000, 0x00000000}, /* A_1600    */
   { "%s[BX+DI%s]",      "%s[BX+DI%s]",      0x00000000, 0x00000000}, /* A_1601    */
   { "%s[BP+SI%s]",      "%s[BP+SI%s]",      0x00000000, 0x00000000}, /* A_1602    */
   { "%s[BP+DI%s]",      "%s[BP+DI%s]",      0x00000000, 0x00000000}, /* A_1603    */
   { "%s[SI%s]",         "%s[SI%s]",         0x00000000, 0x00000000}, /* A_1604    */
   { "%s[DI%s]",         "%s[DI%s]",         0x00000000, 0x00000000}, /* A_1605    */
   { "%s[%s%04x]",       "%s[%s%04x]",       0x0000ffff, 0x00000000}, /* A_1606    */
   { "%s[BX%s]",         "%s[BX%s]",         0x00000000, 0x00000000}, /* A_1607    */
   { "%s[BX+SI%s+%02x]", "%s[BX+SI%s-%02x]", 0x000000ff, 0x00000080}, /* A_1610    */
   { "%s[BX+DI%s+%02x]", "%s[BX+DI%s-%02x]", 0x000000ff, 0x00000080}, /* A_1611    */
   { "%s[BP+SI%s+%02x]", "%s[BP+SI%s-%02x]", 0x000000ff, 0x00000080}, /* A_1612    */
   { "%s[BP+DI%s+%02x]", "%s[BP+DI%s-%02x]", 0x000000ff, 0x00000080}, /* A_1613    */
   { "%s[SI%s+%02x]",    "%s[SI%s-%02x]",    0x000000ff, 0x00000080}, /* A_1614    */
   { "%s[DI%s+%02x]",    "%s[DI%s-%02x]",    0x000000ff, 0x00000080}, /* A_1615    */
   { "%s[BP%s+%02x]",    "%s[BP%s-%02x]",    0x000000ff, 0x00000080}, /* A_1616    */
   { "%s[BX%s+%02x]",    "%s[BX%s-%02x]",    0x000000ff, 0x00000080}, /* A_1617    */
   { "%s[BX+SI%s+%04x]", "%s[BX+SI%s+%04x]", 0x0000ffff, 0x00000000}, /* A_1620    */
   { "%s[BX+DI%s+%04x]", "%s[BX+DI%s+%04x]", 0x0000ffff, 0x00000000}, /* A_1621    */
   { "%s[BP+SI%s+%04x]", "%s[BP+SI%s+%04x]", 0x0000ffff, 0x00000000}, /* A_1622    */
   { "%s[BP+DI%s+%04x]", "%s[BP+DI%s+%04x]", 0x0000ffff, 0x00000000}, /* A_1623    */
   { "%s[SI%s+%04x]",    "%s[SI%s+%04x]",    0x0000ffff, 0x00000000}, /* A_1624    */
   { "%s[DI%s+%04x]",    "%s[DI%s+%04x]",    0x0000ffff, 0x00000000}, /* A_1625    */
   { "%s[BP%s+%04x]",    "%s[BP%s-%04x]",    0x0000ffff, 0x0000f000}, /* A_1626    */
   { "%s[BX%s+%04x]",    "%s[BX%s+%04x]",    0x0000ffff, 0x00000000}, /* A_1627    */
   { "%s[EAX%s]",        "%s[EAX%s]",        0x00000000, 0x00000000}, /* A_3200    */
   { "%s[ECX%s]",        "%s[ECX%s]",        0x00000000, 0x00000000}, /* A_3201    */
   { "%s[EDX%s]",        "%s[EDX%s]",        0x00000000, 0x00000000}, /* A_3202    */
   { "%s[EBX%s]",        "%s[EBX%s]",        0x00000000, 0x00000000}, /* A_3203    */
   { "%s[%s%08x]",       "%s[%s%08x]",       0xffffffff, 0x00000000}, /* A_3205    */
   { "%s[ESI%s]",        "%s[ESI%s]",        0x00000000, 0x00000000}, /* A_3206    */
   { "%s[EDI%s]",        "%s[EDI%s]",        0x00000000, 0x00000000}, /* A_3207    */
   { "%s[EAX+%s%02x]",   "%s[EAX-%s%02x]",   0x000000ff, 0x00000080}, /* A_3210    */
   { "%s[ECX+%s%02x]",   "%s[ECX-%s%02x]",   0x000000ff, 0x00000080}, /* A_3211    */
   { "%s[EDX+%s%02x]",   "%s[EDX-%s%02x]",   0x000000ff, 0x00000080}, /* A_3212    */
   { "%s[EBX+%s%02x]",   "%s[EBX-%s%02x]",   0x000000ff, 0x00000080}, /* A_3213    */
   { "%s[EBP+%s%02x]",   "%s[EBP-%s%02x]",   0x000000ff, 0x00000080}, /* A_3215    */
   { "%s[ESI+%s%02x]",   "%s[ESI-%s%02x]",   0x000000ff, 0x00000080}, /* A_3216    */
   { "%s[EDI+%s%02x]",   "%s[EDI-%s%02x]",   0x000000ff, 0x00000080}, /* A_3217    */
   { "%s[EAX+%s%08x]",   "%s[EAX+%s%08x]",   0xffffffff, 0x00000000}, /* A_3220    */
   { "%s[ECX+%s%08x]",   "%s[ECX+%s%08x]",   0xffffffff, 0x00000000}, /* A_3221    */
   { "%s[EDX+%s%08x]",   "%s[EDX+%s%08x]",   0xffffffff, 0x00000000}, /* A_3222    */
   { "%s[EBX+%s%08x]",   "%s[EBX+%s%08x]",   0xffffffff, 0x00000000}, /* A_3223    */
   { "%s[EBP+%s%08x]",   "%s[EBP-%s%08x]",   0xffffffff, 0xfff00000}, /* A_3225    */
   { "%s[ESI+%s%08x]",   "%s[ESI+%s%08x]",   0xffffffff, 0x00000000}, /* A_3226    */
   { "%s[EDI+%s%08x]",   "%s[EDI+%s%08x]",   0xffffffff, 0x00000000}, /* A_3227    */
   { "%s[EAX%s]",        "%s[EAX%s]",        0x00000000, 0x00000000}, /* A_32S00   */
   { "%s[ECX%s]",        "%s[ECX%s]",        0x00000000, 0x00000000}, /* A_32S01   */
   { "%s[EDX%s]",        "%s[EDX%s]",        0x00000000, 0x00000000}, /* A_32S02   */
   { "%s[EBX%s]",        "%s[EBX%s]",        0x00000000, 0x00000000}, /* A_32S03   */
   { "%s[ESP%s]",        "%s[ESP%s]",        0x00000000, 0x00000000}, /* A_32S04   */
   { "%s[%08x%s]",       "%s[%08x%s]",       0xffffffff, 0x00000000}, /* A_32S05   */
   { "%s[ESI%s]",        "%s[ESI%s]",        0x00000000, 0x00000000}, /* A_32S06   */
   { "%s[EDI%s]",        "%s[EDI%s]",        0x00000000, 0x00000000}, /* A_32S07   */
   { "%s[EAX%s+%02x]",   "%s[EAX%s-%02x]",   0x000000ff, 0x00000080}, /* A_32S10   */
   { "%s[ECX%s+%02x]",   "%s[ECX%s-%02x]",   0x000000ff, 0x00000080}, /* A_32S11   */
   { "%s[EDX%s+%02x]",   "%s[EDX%s-%02x]",   0x000000ff, 0x00000080}, /* A_32S12   */
   { "%s[EBX%s+%02x]",   "%s[EBX%s-%02x]",   0x000000ff, 0x00000080}, /* A_32S13   */
   { "%s[ESP%s+%02x]",   "%s[ESP%s-%02x]",   0x000000ff, 0x00000080}, /* A_32S14   */
   { "%s[EBP%s+%02x]",   "%s[EBP%s-%02x]",   0x000000ff, 0x00000080}, /* A_32S15   */
   { "%s[ESI%s+%02x]",   "%s[ESI%s-%02x]",   0x000000ff, 0x00000080}, /* A_32S16   */
   { "%s[EDI%s+%02x]",   "%s[EDI%s-%02x]",   0x000000ff, 0x00000080}, /* A_32S17   */
   { "%s[EAX%s+%08x]",   "%s[EAX%s+%08x]",   0xffffffff, 0x00000000}, /* A_32S20   */
   { "%s[ECX%s+%08x]",   "%s[ECX%s+%08x]",   0xffffffff, 0x00000000}, /* A_32S21   */
   { "%s[EDX%s+%08x]",   "%s[EDX%s+%08x]",   0xffffffff, 0x00000000}, /* A_32S22   */
   { "%s[EBX%s+%08x]",   "%s[EBX%s+%08x]",   0xffffffff, 0x00000000}, /* A_32S23   */
   { "%s[ESP%s+%08x]",   "%s[ESP%s+%08x]",   0xffffffff, 0x00000000}, /* A_32S24   */
   { "%s[EBP%s+%08x]",   "%s[EBP%s-%08x]",   0xffffffff, 0xfff00000}, /* A_32S25   */
   { "%s[ESI%s+%08x]",   "%s[ESI%s+%08x]",   0xffffffff, 0x00000000}, /* A_32S26   */
   { "%s[EDI%s+%08x]",   "%s[EDI%s+%08x]",   0xffffffff, 0x00000000}, /* A_32S27   */
   { "%s[%s%04x]",       "%s[%s%04x]",       0x0000ffff, 0x00000000}, /* A_MOFFS16 */
   { "%s[%s%08x]",       "%s[%s%08x]",       0xffffffff, 0x00000000}, /* A_MOFFS32 */
   { "%s[BX+AL%s]",      "%s[BX+AL%s]",      0x00000000, 0x00000000}, /* A_16XLT   */
   { "%s[EBX+AL%s]",     "%s[EBX+AL%s]",     0x00000000, 0x00000000}, /* A_32XLT   */
   { "%s[SI%s]",         "%s[SI%s]",         0x00000000, 0x00000000}, /* A_16STSRC */
   { "%s[ESI%s]",        "%s[ESI%s]",        0x00000000, 0x00000000}, /* A_32STSRC */
   { "%s[DI%s]",         "%s[DI%s]",         0x00000000, 0x00000000}, /* A_16STDST */
   { "%s[EDI%s]",        "%s[EDI%s]",        0x00000000, 0x00000000}  /* A_32STDST */
   };

LOCAL char *mem_id[] =
   {
   "",           /* A_M */
   "",           /* A_M14 */
   "",           /* A_M28 */
   "",           /* A_M94 */
   "",           /* A_M108 */
   "DWord Ptr ", /* A_Ma16 */
   "QWord Ptr ", /* A_Ma32 */
   "Byte Ptr ",  /* A_Mb */
   "DWord Ptr ", /* A_Md */
   "Word Ptr ",  /* A_Mi16 */
   "DWord Ptr ", /* A_Mi32 */
   "QWord Ptr ", /* A_Mi64 */
   "TByte Ptr ", /* A_Mi80 */
   "DWord Ptr ", /* A_Mp16 */
   "FWord Ptr ", /* A_Mp32 */
   "DWord Ptr ", /* A_Mr32 */
   "QWord Ptr ", /* A_Mr64 */
   "Tbyte Ptr ", /* A_Mr80 */
   "FWord Ptr ", /* A_Ms */
   "Word Ptr "   /* A_Mw */
   };

/*
   SIB byte names.
 */
LOCAL CHAR *sib_name[] =
   {
   "",
   "+EAX",   "+ECX",   "+EDX",   "+EBX",
   "",       "+EBP",   "+ESI",   "+EDI",
   "+2*EAX", "+2*ECX", "+2*EDX", "+2*EBX",
   "+undef", "+2*EBP", "+2*ESI", "+2*EDI",
   "+4*EAX", "+4*ECX", "+4*EDX", "+4*EBX",
   "+undef", "+4*EBP", "+4*ESI", "+4*EDI",
   "+8*EAX", "+8*ECX", "+8*EDX", "+8*EBX",
   "+undef", "+8*EBP", "+8*ESI", "+8*EDI"
   };



/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Read a byte from the given Intel linear address, return -1 if      */
/* unable to read a                                                   */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
LOCAL IS32 read_byte IFN1(LIN_ADDR, linAddr)
{
	IU8 res = Sas.Sas_hw_at(linAddr);

	/* if (was_error)
	 *	return -1;
	 * else
	*/
	return (IS32)(res);
}

/*
   =====================================================================
   EXECUTION STARTS HERE.
   =====================================================================
 */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Dis-assemble a single Intel Instruction.                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL IU16
dasm IFN4(char *, txt, IU16, seg, LIN_ADDR, off, SIZE_SPECIFIER, default_size)
   {
   /* txt		Buffer to hold dis-assembly text (-1 means not required) */
   /* seg		Segment for instruction to be dis-assembled */
   /* off		Offset for instruction to be dis-assembled */
   /* default_size	16BIT or 32BIT */

   char *fmt, *newline;
	
   /* format for seg:off */
   if ( off & 0xffff0000 )
   {
      fmt = "%04x:%08x ";
      newline = "\n              ";
   }
   else
   {
      fmt = "%04x:%04x ";
      newline = "\n          ";
   }

   return (dasm_internal(txt,
		     seg,
		     off,
		     default_size,
		     effective_addr(seg, off),
		     read_byte,
		     fmt,
		     newline));
}

#pragma warning(disable:4146)       // unary minus operator applied to unsigned type

extern IU16 dasm_internal IFN8(
   char *, txt,	/* Buffer to hold dis-assembly text (-1 means not required) */
   IU16, seg,	/* Segment for xxxx:... text in dis-assembly */
   LIN_ADDR, off,	/* ditto offset */
   SIZE_SPECIFIER, default_size,/* 16BIT or 32BIT code segment */
   LIN_ADDR, p,			/* linear address of start of instruction */
   read_byte_proc, byte_at,	/* like sas_hw_at() to use to read intel
				 * but will return -1 if there is an error
				 */
   char *, fmt,		/* sprintf format for first line seg:offset */
   char *, newline)		/* strcat text to separate lines */
{
   LIN_ADDR pp;			/* pntr to prefix bytes */
   DECODED_INST d_inst;		/* Decoded form of Intel instruction */
   DECODED_ARG *d_arg;		/* pntr to decoded form of Intel operand */
   USHORT inst_len;		/* Nr. bytes in instruction */
   USHORT mc;			/* Nr. machine code bytes processed */
   char *arg_name;      	/* pntr to symbolic argument name */
   char *inst_txt;
   INT i;
   INT name_len;		/* Nr. chars in symbolic instruction name */
   MEM_RECORD *m_rec;   	/* pntr to memory addressing record */
   UTINY args_out;		/* Nr. arguments actually printed */
   INT prefix_width;		/* Width of prefixes actually printed */
   UTINY memory_id;		/* Memory identifier reference */
   ULONG immed;			/* value for immediate arithmetic */
   IBOOL unreadable = FALSE;	/* TRUE if instr bytes are not readable (past M?) */
   char prefix_buf[16*4];
   char *prefix_txt;

   /* initialise */
   args_out = prefix_width = 0;

   pp=p;

   /* get in decoded form */
   decode(p, &d_inst, default_size, byte_at);

   /* hence find length of instruction */
   inst_len = d_inst.inst_sz;

   /* if no text required, just return the length now */
   if (txt == (char*)-1){
	/* Check bytes were read without errors */
	if ((byte_at(p) < 0) || (byte_at(p+inst_len-1) < 0))
	{
		int i = inst_len - 1;
		while (i > 0)
		{
			if (byte_at(i) >= 0)
				return ((IU16)i);
		}
		return 0;
	}
	return inst_len;
   }

   /* output seg:off in requested format */

   sprintf(txt, fmt, seg, off);
   txt += strlen(txt);

   /* Output upto eight machine code bytes */
   for ( mc = 0; mc < 8; mc++)
      {
      if ( mc < inst_len )
         {
	 IS32 b = byte_at(p++);

	 if (b < 0)
	    {
	    sprintf(txt, "..");		/* print ".." if not readable */
	    unreadable = TRUE;
	    inst_len = mc;
            }
	 else
	    sprintf(txt, "%02x", b);	/* print machine code byte */
         }
      else
	 sprintf(txt, "  ");           /* fill in with spaces */
      txt += 2;
      }

   /* Check inst identifier is within our known range.
    * Get text for opcode and length so we can see if the
    * prefix will fit.
    */
   if ( d_inst.inst_id >= NR_VALID_INSTS )
      {
      fprintf(stderr, "Bad decoded instruction found %d\n", d_inst.inst_id);
      d_inst.inst_id = I_ZBADOP;
      }

   /* Obtain symbolic form of instruction */
   inst_txt = inst_name[d_inst.inst_id];
   name_len = 1 + strlen(inst_txt);

   /* Format prefix bytes if any */
   prefix_txt = prefix_buf;
   *prefix_txt = '\0';

   if ( d_inst.prefix_sz )
      {
      for ( i = 0; i < d_inst.prefix_sz; byte_at(pp), i++)
	 {
	 switch ( byte_at(pp) )
	    {
	 case 0xf1:
	    /* it don't do nothing -- don't display nothing */

	 case 0xf2:
	 case 0xf3:
	    /* if valid instructions will print them */

	 case 0x66:
	 case 0x67:
	    /* the effect is obvious from the operands */
	    break;

	 case 0xf0: sprintf(prefix_txt, " LOCK"); prefix_txt += 5; break;
	 case 0x26: sprintf(prefix_txt, " ES:");  prefix_txt += 4; break;
	 case 0x2e: sprintf(prefix_txt, " CS:");  prefix_txt += 4; break;
	 case 0x36: sprintf(prefix_txt, " SS:");  prefix_txt += 4; break;
	 case 0x3e: sprintf(prefix_txt, " DS:");  prefix_txt += 4; break;
	 case 0x64: sprintf(prefix_txt, " FS:");  prefix_txt += 4; break;
	 case 0x65: sprintf(prefix_txt, " GS:");  prefix_txt += 4; break;

	 default:
	    fprintf(stderr, "Bad prefix found %02x\n", byte_at(pp));
	    break;
	    } /* end switch */

	    pp++;

	 } /* end for */
      } /* end if d_inst.prefix_sz */

      prefix_width = strlen(prefix_buf);
      if ( newline != NULL )
	 {
	 if ( ((inst_len * 2) + prefix_width) > 16)
	    {
	    /* start new line for instruction */
	    strcat(txt, newline);
	    txt += strlen(txt);

	    /* output rest of machine code bytes */
	    for ( ; mc < 16; mc++)
	       {
	       if ( mc < inst_len )
	          {
		  IS32 b = byte_at(p++);

		  if (b < 0)
		     {
		     sprintf(txt, "..");	/* print ".." if not readable */
		     unreadable = TRUE;
		     inst_len = mc;
                     }
		  else
		     sprintf(txt, "%02x", b);	/* print machine code byte */
	          }
	       else
	          sprintf(txt, "  ");           /* fill in with spaces */
	       txt += 2;
       	       }
	    }
	 if ( ((inst_len * 2) + prefix_width) > 32)
	    {
	    /* wont fit on two lines */
	    strcat(txt, newline);
	    txt += strlen(txt);

	    /* output rest of machine code bytes */
	    for ( ; mc < 24; mc++)
	       {
	       sprintf(txt, "  ");           /* fill in with spaces */
	       txt += 2;
       	       }
	    }
	 txt -= (prefix_width <= 17 ? prefix_width: 17);
         }
      if (unreadable)
         {
	 sprintf(txt, "<< Unreadable >>\n");
	 return inst_len;
         }

      sprintf(txt, "%s %s", prefix_buf, inst_txt);
      txt += prefix_width + name_len;

      /* pad out to 11 characters wide */

      for (i = name_len; i <= 11; i++)
	*txt++ = ' ';

   if (d_inst.inst_id != I_ZBADOP)
     {
     /* output each valid argument in turn */
     for ( i = 0; i < 3; i++ )
      {
      d_arg = &d_inst.args[i];
      arg_name = (CHAR *)0;

      if ( d_arg->arg_type != A_ )
	 {
	 /* process valid arg */
	 sprintf(txt, "%c", arg_preface[args_out++]);
	 txt += 1;

	 switch ( d_arg->arg_type )
	    {
	 case A_Rb:	/* aka r8,r/m8                            */
	    arg_name = Rb_name[DCD_IDENTIFIER(d_arg)];
	    break;

	 case A_Rw:	/* aka r16,r/m16                          */
	    arg_name = Rw_name[DCD_IDENTIFIER(d_arg)];
	    break;

	 case A_Rd:	/* aka r32,r/m32                          */
	    arg_name = Rd_name[DCD_IDENTIFIER(d_arg)];
	    break;

	 case A_Sw:	/* aka Sreg                               */
	    arg_name = Sw_name[DCD_IDENTIFIER(d_arg)];
	    break;

	 case A_Cd:	/* aka CRx                                */
	    arg_name = Cd_name[DCD_IDENTIFIER(d_arg)];
	    break;

	 case A_Dd:	/* aka DRx                                */
	    arg_name = Dd_name[DCD_IDENTIFIER(d_arg)];
	    break;

	 case A_Td:	/* aka TRx                                */
	    arg_name = Td_name[DCD_IDENTIFIER(d_arg)];
	    break;

	 case A_M:	/* aka m                                  */
	 case A_M14:	/* aka m14byte                            */
	 case A_M28:	/* aka m28byte                            */
	 case A_M94:	/* aka m94byte                            */
	 case A_M108:	/* aka m108byte                           */
	 case A_Ma16:	/* aka m16&16                             */
	 case A_Ma32:	/* aka m32&32                             */
	 case A_Mb:	/* aka m8,r/m8,moffs8                     */
	 case A_Md:	/* aka m32,r/m32,moffs32                  */
	 case A_Mi16:	/* aka m16int                             */
	 case A_Mi32:	/* aka m32int                             */
	 case A_Mi64:	/* aka m64int                             */
	 case A_Mi80:	/* aka m80dec                             */
	 case A_Mp16:	/* aka m16:16                             */
	 case A_Mp32:	/* aka m16:32                             */
	 case A_Mr32:	/* aka m32real                            */
	 case A_Mr64:	/* aka m64real                            */
	 case A_Mr80:	/* aka m80real                            */
	 case A_Ms:	/* aka m16&32                             */
	 case A_Mw:	/* aka m16,r/m16,moffs16                  */
	    /* First work out memory identifier */
	    switch ( d_arg->arg_type )
	       {
	    case A_M:    memory_id =  0; break;
	    case A_M14:  memory_id =  1; break;
	    case A_M28:  memory_id =  2; break;
	    case A_M94:  memory_id =  3; break;
	    case A_M108: memory_id =  4; break;
	    case A_Ma16: memory_id =  5; break;
	    case A_Ma32: memory_id =  6; break;
	    case A_Mb:   memory_id =  7; break;
	    case A_Md:   memory_id =  8; break;
	    case A_Mi16: memory_id =  9; break;
	    case A_Mi32: memory_id = 10; break;
	    case A_Mi64: memory_id = 11; break;
	    case A_Mi80: memory_id = 12; break;
	    case A_Mp16: memory_id = 13; break;
	    case A_Mp32: memory_id = 14; break;
	    case A_Mr32: memory_id = 15; break;
	    case A_Mr64: memory_id = 16; break;
	    case A_Mr80: memory_id = 17; break;
	    case A_Ms:   memory_id = 18; break;
	    case A_Mw:   memory_id = 19; break;
	       }

	    /* output memory details */
	    m_rec = &mem_name[DCD_IDENTIFIER(d_arg)];
	    if ( m_rec->disp_mask == 0 )
	       {
	       /* no displacement to print out */
	       sprintf(txt, m_rec->positive,
		  mem_id[memory_id],
		  sib_name[DCD_SUBTYPE(d_arg)]);
	       }
	    else
	       {
	       /* displacement to print out */
	       IU32 disp = DCD_DISP(d_arg);
	       char *fmt;

	       /* Do we think this is a negative displacement ? */
	       if (m_rec->sign_mask && ((m_rec->sign_mask & disp) == m_rec->sign_mask))
	       {
		       disp = -disp;
		       fmt = m_rec->negative;
	       }
	       else
		       fmt = m_rec->positive;
	       disp &= m_rec->disp_mask;
	       if ( DCD_IDENTIFIER(d_arg) == A_32S05 )
		  sprintf(txt, fmt,
		     mem_id[memory_id],
		     disp,
		     sib_name[DCD_SUBTYPE(d_arg)]);
	       else
		  sprintf(txt, fmt,
		     mem_id[memory_id],
		     sib_name[DCD_SUBTYPE(d_arg)],
		     disp);
	       }

	    name_len = strlen(txt);
	    txt += name_len;
	    break;

	 case A_I:	/* aka imm8,imm16,imm32                   */
	    immed = DCD_IMMED1(d_arg);
	    switch ( DCD_IDENTIFIER(d_arg) )
	       {
	    case A_IMMC:
	       /* check for inbuilt zero - don't print */
	       if ( immed )
		  {
		  sprintf(txt, "%1d", immed); txt += 1;
		  }
	       else
		  {
		  /* kill preface */
		  args_out--;
		  txt -= 1;
		  *txt = '\0';
		  }
	       break;

	    case A_IMMB:
	       sprintf(txt, "%02x", immed); txt += 2;
	       break;

	    case A_IMMW:
	       sprintf(txt, "%04x", immed); txt += 4;
	       break;

	    case A_IMMD:
	       sprintf(txt, "%08x", immed); txt += 8;
	       break;

	    case A_IMMWB:
	    case A_IMMDB:
	       /* remove sign extension */
	       immed &= 0xff;

	       /* print byte with correct sign */
	       if ( immed <= 0x7f )
		  {
		  sprintf(txt, "+%02x", immed); txt += 3;
		  }
	       else
		  {
		  immed = 0x100 - immed;
		  sprintf(txt, "-%02x", immed); txt += 3;
		  }
	       break;
	       }
	    break;

	 case A_J:	/* aka rel8,rel16,rel32                   */
	    /* calc new dest */
	    immed = off + inst_len + DCD_IMMED1(d_arg);

	    /* handle as 16-bit mode or 32-bit mode */
	    switch ( d_inst.inst_id )
	       {

	    case I_JO16:      case I_JNO16:     case I_JB16:
	    case I_JNB16:     case I_JZ16:      case I_JNZ16:
	    case I_JBE16:     case I_JNBE16:    case I_JS16:
	    case I_JNS16:     case I_JP16:      case I_JNP16:
	    case I_JL16:      case I_JNL16:     case I_JLE16:
	    case I_JNLE16:    case I_LOOPNE16:  case I_LOOPE16:
	    case I_LOOP16:    case I_JCXZ:      case I_CALLR16:
	    case I_JMPR16:
	       immed &= 0xffff;

	       sprintf(txt, "%04x", immed);
	       txt += 4;
	       break;

	    default: /* 32-bit mode */
	       sprintf(txt, "%08x", immed);
	       txt += 8;
	       break;
	       }
	    break;

	 case A_K:	/* aka ptr16:16,ptr16:32                  */
	    {
	    /* handle as 16-bit mode or 32-bit mode */

	    char *sep = ":";

	    switch ( d_inst.inst_id )
	       {
	       case I_CALLF16:    case I_JMPF16:
	       sprintf(txt, "%04x%s%04x", DCD_IMMED2(d_arg), sep, DCD_IMMED1(d_arg));
	       txt += 9;
	       break;

	    default: /* 32-bit mode */
	       sprintf(txt, "%04x%s%08x", DCD_IMMED2(d_arg), sep, DCD_IMMED1(d_arg));
	       txt += 13;
	       break;
	       }
	    }
	    break;

	 case A_V:	/* aka ST,push onto ST, ST(i)             */
	    switch ( DCD_IDENTIFIER(d_arg) )
	       {
	    case A_ST:
	       /* Some cases are obvious - so not all get printed */
	       switch ( d_inst.inst_id )
		  {
	       case I_F2XM1:     case I_FABS:      case I_FBSTP:
	       case I_FCHS:      case I_FCOS:      case I_FIST:
	       case I_FISTP:     case I_FPATAN:    case I_FPREM:
	       case I_FPREM1:    case I_FPTAN:     case I_FRNDINT:
	       case I_FSCALE:    case I_FSIN:      case I_FSINCOS:
	       case I_FSQRT:     case I_FST:       case I_FSTP:
	       case I_FTST:      case I_FXAM:      case I_FXTRACT:
	       case I_FYL2X:     case I_FYL2XP1:
		  break;

	       default: /* do print */
		  arg_name = "ST";
		  break;
		  }
	       break;

	    case A_STP:
	       /* All cases are obvious - so no printing */
	       break;

	    case A_STI:
	       /* Some cases are obvious - so not all get printed */
	       switch ( d_inst.inst_id )
		  {
	       case I_FPATAN:    case I_FPREM:     case I_FPREM1:
	       case I_FSCALE:    case I_FYL2X:     case I_FYL2XP1:
		  break;

	       default: /* do print */
		  sprintf(txt, "ST(%1d", DCD_INDEX(d_arg));
		  txt += 4;
		  arg_name = ")";
		  break;
		  }
	       break;
	       }

	    /* if we aren't printing - kill preface */
	    if ( arg_name == (CHAR *)0 )
	       {
	       args_out--;
	       txt -= 1;
	       *txt = '\0';
	       }
	    break;

	 default:
	    fprintf(stderr, "Bad decoded argument found %d\n",
					       d_arg->arg_type);
	    break;
	    } /* end switch */
	 } /* end if */

      /* print something if we have it */
      if ( arg_name != (CHAR *)0 )
	 {
	 sprintf(txt, "%s", arg_name);
	 name_len = strlen(arg_name);
	 txt += name_len;
	 }
     } /* end for arg */
   }

   if (d_inst.inst_id == I_ZBOP)
     {
     IU8 num = (IU8)DCD_IMMED1(&d_inst.args[0]);
     extern char *bop_name IPT1(IU8, num);
     char *name = bop_name(num);
     if (name != NULL)
       {
       sprintf(txt, " : %s", name);
       txt += strlen(txt);
       }
     }


   /* Finally output any machine code bytes remaining */
   /* iff bytes remaining && room in output format */
   if ( (newline != NULL ) && ( mc < inst_len && mc < 16 ))
      {
      strcat(txt, newline);
      txt += strlen(txt);
      for ( ; mc < inst_len && mc < 16; mc++ )
	 {
	 IS32 b = byte_at(p++);

	 if (b < 0)
	    {
	    sprintf(txt, "..");		/* print ".." if not readable */
	    inst_len = mc;
	    }
	 else
	    sprintf(txt, "%02x", b);	/* print machine code byte */
         p++;
	 txt += 2;
 }
      }

   sprintf(txt, "\n");

   return inst_len;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\dasm.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title        : CPU disassembler
 *
 * Description  : This dissasembler is called from the debugging
 *                software (trace + yoda).
 *
 * Author       : Paul Huckle / Henry Nash
 *
 * Notes        : There are some dependencies between this and the CPU
 *                module - unfortunately exactly what these are lie
 *                hidden in thrown together code and Super Supremes.
 */

/*
 * static char SccsID[]="@(#)dasm.c	1.24 05/16/94 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "DASM1.seg"
#endif



#ifndef PROD

/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "trace.h"

#undef sas_set_buf
#undef sas_inc_buf

#define sas_set_buf(buf,addr)           buf=(OPCODE_FRAME *)M_get_dw_ptr(addr)
#define sas_inc_buf(buf,off)            buf = (OPCODE_FRAME *)inc_M_ptr((long)buf, (long)off)

#define place_op  place_byte(byte_posn,op->OPCODE); \
                  byte_posn += 3;

#define place_2   place_byte(byte_posn,op->SECOND_BYTE); \
                  byte_posn += 3;

#define place_3   place_byte(byte_posn,op->THIRD_BYTE); \
                  byte_posn += 3;

#define place_4   place_byte(byte_posn,op->FOURTH_BYTE); \
                  byte_posn += 3;

#define print_byte_v    i=strlen(out_line);  \
                        place_byte(i,temp_byte.X);  \
                        out_line[i+2] = '\0';

#define print_addr_c      strcat(out_line,temp_char);  \
                          strcat(out_line,",");

#define print_c_addr      strcat(out_line,",");  \
                          strcat(out_line,temp_char);

#define place_23  place_byte(byte_posn,op->SECOND_BYTE); \
                  byte_posn += 3; \
                  place_byte(byte_posn,op->THIRD_BYTE); \
                  byte_posn += 3;

#define place_34  place_byte(byte_posn,op->THIRD_BYTE); \
                  byte_posn += 3; \
                  place_byte(byte_posn,op->FOURTH_BYTE); \
                  byte_posn += 3;

#define print_reg sprintf(temp_char,"%04x",temp_reg.X); \
                  strcat(out_line, temp_char);

#define JUMP " ; Jump"
#define NOJUMP " ; No jump"
#define NOLOOP " ; No loop"

#define jmp_dest  place_byte(byte_posn, op->OPCODE);    \
                byte_posn += 3;                         \
                place_byte(byte_posn,op->SECOND_BYTE);  \
                byte_posn += 3;                         \
                strcat(out_line, ASM[op->OPCODE]);      \
                segoff = segoff + LEN_ASM[op->OPCODE]; \
                sprintf(temp_char,"%04x ",(segoff + (IS8) op->SECOND_BYTE )); \
                strcat(out_line,temp_char);

#define print_return {  if (output_stream == (char *)0)                 \
                            fprintf(trace_file, "%s\n", out_line);      \
                        else                                            \
                            if (output_stream != (char *)-1)            \
                                sprintf(output_stream, "%s\n", out_line);       \
                     if ( nInstr != 0 )                                         \
                        segoff = segoff + disp_length;          \
                     }

#define sbyte  place_byte(byte_posn, op->OPCODE); \
               byte_posn += 3; \
               strcat(out_line, ASM[op->OPCODE]); \
               segoff = segoff + LEN_ASM[op->OPCODE];

#define start_repeat if ( REPEAT != OFF )                  \
                        temp_count.X = getCX();            \
                     else                                  \
                        temp_count.X = 1;

#define load_23       temp_reg.byte.high = op->THIRD_BYTE; \
                      temp_reg.byte.low = op->SECOND_BYTE;

#define load_34       temp_reg.byte.high = op->FOURTH_BYTE; \
                      temp_reg.byte.low = op->THIRD_BYTE;

#define load_2       temp_byte.X = op->SECOND_BYTE;

#define load_3       temp_byte.X = op->THIRD_BYTE;

#define OFF -1
#define REPNE_FLAG 0
#define REPE_FLAG 1

#ifdef CPU_30_STYLE
/* cpu.h no longer supplies this... supply our own */
#ifdef BACK_M
typedef struct
{
                half_word FOURTH_BYTE;
                half_word THIRD_BYTE;
                half_word SECOND_BYTE;
                half_word OPCODE;
}  OPCODE_FRAME;

#else
typedef struct
{
                half_word OPCODE;
                half_word SECOND_BYTE;
                half_word THIRD_BYTE;
                half_word FOURTH_BYTE;
}  OPCODE_FRAME;

#endif /* BACK_M */

#endif /* CPU_30_STYLE */

char trace_buf[512];


#ifdef BIT_ORDER1
        typedef union {
                      half_word X;
                      struct {
                             HALF_WORD_BIT_FIELD mod:2;
                             HALF_WORD_BIT_FIELD xxx:3;
                             HALF_WORD_BIT_FIELD r_m:3;
                      } field;
                      long alignment;   /* ensure compiler aligns union */
        } MODR_M;

        typedef union {
            half_word X;
            struct {
                  HALF_WORD_BIT_FIELD b7:1;
                  HALF_WORD_BIT_FIELD b6:1;
                  HALF_WORD_BIT_FIELD b5:1;
                  HALF_WORD_BIT_FIELD b4:1;
                  HALF_WORD_BIT_FIELD b3:1;
                  HALF_WORD_BIT_FIELD b2:1;
                  HALF_WORD_BIT_FIELD b1:1;
                  HALF_WORD_BIT_FIELD b0:1;
                  } bit;
            long alignment;     /* ensure compiler aligns union */
            } DASMBYTE;
#endif
#ifdef BIGEND
        typedef union {
                       sys_addr all;
                       struct {
                              half_word PAD1;
                              half_word PAD2;
                              half_word high;
                              half_word low;
                       } byte;
        } cpu_addr;
#endif

#ifdef BIT_ORDER2
        typedef union {
                      half_word X;
                      struct {
                             HALF_WORD_BIT_FIELD r_m:3;
                             HALF_WORD_BIT_FIELD xxx:3;
                             HALF_WORD_BIT_FIELD mod:2;
                      } field;
                      long alignment;   /* ensure compiler aligns union */
        } MODR_M;

        typedef union {
            half_word X;
            struct {
                  HALF_WORD_BIT_FIELD b0:1;
                  HALF_WORD_BIT_FIELD b1:1;
                  HALF_WORD_BIT_FIELD b2:1;
                  HALF_WORD_BIT_FIELD b3:1;
                  HALF_WORD_BIT_FIELD b4:1;
                  HALF_WORD_BIT_FIELD b5:1;
                  HALF_WORD_BIT_FIELD b6:1;
                  HALF_WORD_BIT_FIELD b7:1;
                  } bit;
            long alignment;     /* ensure compiler aligns union */
            } DASMBYTE;
#endif
#ifdef LITTLEND
        typedef union {
                       sys_addr all;
                       struct {
                              half_word low;
                              half_word high;
                              half_word PAD2;
                              half_word PAD1;
                       } byte;
        } cpu_addr;
#endif

/*
 * The following are the three addressing mode register mapping tables.
 * These should be indexed with the register field (xxx) in the
 * instruction operand.
 */

/*
 * 16-bit  (w == 1)
 */

char *reg16name[] = { "AX","CX","DX","BX","SP","BP","SI","DI"};

/*
 * 8-bit  (w == 0)
 */

char *reg8name[] = { "AL","CL","DL","BL","AH","CH","DH","BH"};

/*
 * Segements
 */

char *segregname[] = { "ES","CS","SS","DS"};

char *address[] = { "BX+SI","BX+DI","BP+SI","BP+DI",
                    "SI"   ,"DI"   ,"BP"   ,"BX" };



static char out_line[133];
static char temp_char[80];
static char temp_char2[80];
static OPCODE_FRAME *op;
static int byte_posn;
static int disp_length;


static char table[] = { '0','1','2','3','4','5','6','7','8',
                        '9','A','B','C','D','E','F' };

static char *CODE_F7[] = {"TEST  ","TEST  ","NOT   ","NEG   ",
                          "MUL   ","IMUL  ","DIV   ","IDIV  "};
static char *CODE_83[] = {"ADD-  ","OR-   ","ADC-  ","SBB-  ",
                          "AND-  ","SUB-  ","XOR-  ","CMP-  "};
static char *CODE_80[] = {"ADD   ","OR    ","ADC   ","SBB   ",
                          "AND   ","SUB   ","XOR   ","CMP   "};
static char *CODE_FF[] = {"INC   ","DEC   ","CALL  ","CALLF ",
                          "JMP   ","JMPF  ","PUSH  ","??    "};
static char *CODE_FE[] = {"INC   ","DEC   ","??    ","??    ",
                          "??    ","??    ","??    ","??    "};
static char *CODE_D0[] = {"ROL   ","ROR   ","RCL   ","RCR   ",
                          "SHL   ","SHR   ","SHL   ","SAR   "};
static int LEN_F6[] = { 3,3,2,2,2,2,2,2 };
static int LEN_F7[] = { 4,4,2,2,2,2,2,2 };

static word LEN_ASM[] =
   {
   2,2,2,2,2,3,1,1,  2,2,2,2,2,3,1,1,  /* 00 - 0f */
   2,2,2,2,2,3,1,1,  2,2,2,2,2,3,1,1,  /* 10 - 1f */
   2,2,2,2,2,3,1,1,  2,2,2,2,2,3,1,1,  /* 20 - 2f */
   2,2,2,2,2,3,1,1,  2,2,2,2,2,3,1,1,  /* 30 - 3f */
   1,1,1,1,1,1,1,1,  1,1,1,1,1,1,1,1,  /* 40 - 4f */
   1,1,1,1,1,1,1,1,  1,1,1,1,1,1,1,1,  /* 50 - 5f */
   1,1,2,2,1,1,1,1,  3,4,2,3,1,1,1,1,  /* 60 - 6f */
   2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2,  /* 70 - 7f */
   3,4,3,3,2,2,2,2,  2,2,2,2,2,2,2,2,  /* 80 - 8f */
   1,1,1,1,1,1,1,1,  1,1,5,1,1,1,1,1,  /* 90 - 9f */
   3,3,3,3,1,1,1,1,  2,3,1,1,1,1,1,1,  /* a0 - af */
   2,2,2,2,2,2,2,2,  3,3,3,3,3,3,3,3,  /* b0 - bf */
   3,3,3,1,2,2,3,4,  4,1,3,1,1,2,1,1,  /* c0 - cf */
   2,2,2,2,2,2,2,1,  2,2,2,2,2,2,2,2,  /* d0 - df */
   2,2,2,2,2,2,2,2,  3,3,5,2,1,1,1,1,  /* e0 - ef */
   1,1,1,1,1,1,0,0,  1,1,1,1,1,1,2,2   /* f0 - ff */
   };

static char *ASM[256] = {

        "ADD   "   ,                            /* opcodes 00 -> 07 */
        "ADD   "   ,
        "ADD   "   ,
        "ADD   "   ,
        "ADD   AL,"   ,
        "ADD   AX,"   ,
        "PUSH  ES" ,
        "POP   ES" ,

        "OR    "   ,                            /* opcodes 08 -> 0F */
        "OR    "   ,
        "OR    "   ,
        "OR    "   ,
        "OR    AL,"   ,
        "OR    AX,"   ,
        "PUSH  CS" ,
        ""   ,

        "ADC   "   ,                            /* opcodes 10 -> 17 */
        "ADC   "   ,
        "ADC   "   ,
        "ADC   "   ,
        "ADC   AL,"   ,
        "ADC   AX,"   ,
        "PUSH  SS" ,
        "POP   SS" ,

        "SBB   "   ,                            /* opcodes 18 -> 1f */
        "SBB   "   ,
        "SBB   "   ,
        "SBB   "   ,
        "SBB   AL,"   ,
        "SBB   AX,"   ,
        "PUSH  DS" ,
        "POP   DS" ,

        "AND   "   ,                            /* opcodes 20 -> 27 */
        "AND   "   ,
        "AND   "   ,
        "AND   "   ,
        "AND   AL,"   ,
        "AND   AX,"   ,
        "ES: "   ,
        "DAA   "   ,

        "SUB   "   ,                            /* opcodes 28 -> 2f */
        "SUB   "   ,
        "SUB   "   ,
        "SUB   "   ,
        "SUB   AL,"   ,
        "SUB   AX,"   ,
        "CS: "   ,
        "DAS"   ,

        "XOR   "   ,                            /* opcodes 30 -> 37 */
        "XOR   "   ,
        "XOR   "   ,
        "XOR   "   ,
        "XOR   AL," ,
        "XOR   AX," ,
        "SS: "   ,
        "AAA   "   ,

        "CMP   "   ,                            /* opcodes 38 -> 3f */
        "CMP   "   ,
        "CMP   "   ,
        "CMP   "   ,
        "CMP   AL," ,
        "CMP   AX," ,
        "DS: "   ,
        "AAS   "   ,

        "INC   AX" ,                            /* opcodes 40 -> 47 */
        "INC   CX" ,
        "INC   DX" ,
        "INC   BX" ,
        "INC   SP" ,
        "INC   BP" ,
        "INC   SI" ,
        "INC   DI" ,

        "DEC   AX" ,                            /* opcodes 48 -> 4f */
        "DEC   CX" ,
        "DEC   DX" ,
        "DEC   BX" ,
        "DEC   SP" ,
        "DEC   BP" ,
        "DEC   SI" ,
        "DEC   DI" ,

        "PUSH  AX" ,                            /* opcodes 50 -> 57 */
        "PUSH  CX" ,
        "PUSH  DX" ,
        "PUSH  BX" ,
        "PUSH  SP" ,
        "PUSH  BP" ,
        "PUSH  SI" ,
        "PUSH  DI" ,

        "POP   AX" ,                            /* opcodes 58 -> 5f */
        "POP   CX" ,
        "POP   DX" ,
        "POP   BX" ,
        "POP   SP" ,
        "POP   BP" ,
        "POP   SI" ,
        "POP   DI" ,

        "PUSHA " ,                              /* opcodes 60 -> 67 */
        "POPA  " ,
        "BOUND " ,
        "ARPL  " ,
        "??    " ,
        "??    " ,
        "??    " ,
        "??    " ,

        "PUSH  " ,                              /* opcodes 68 -> 6f */
        "IMUL  " ,
        "PUSH  " ,
        "IMUL  " ,
        "INSB  " ,
        "INSW  " ,
        "OUTSB " ,
        "OUTSW " ,

        "JO    "   ,                            /* opcodes 70 -> 77 */
        "JNO   "   ,
        "JB    "   ,
        "JNB   "   ,
        "JE    "   ,
        "JNE   "   ,
        "JBE   "   ,
        "JNBE  "   ,

        "JS    "   ,                            /* opcodes 78 -> 7f */
        "JNS   "   ,
        "JP    "   ,
        "JNP   "   ,
        "JL    "   ,
        "JNL   "   ,
        "JLE   "   ,
        "JG    "   ,

        ""          ,                           /* opcodes 80 -> 87 */
        ""          ,
        ""          ,
        ""          ,
        "TEST  "   ,
        "TEST  "   ,
        "XCHG  "   ,
        "XCHG  "   ,

        "MOV   "   ,                            /* opcodes 88 -> 8f */
        "MOV   "   ,
        "MOV   "   ,
        "MOV   "   ,
        "MOV   "   ,
        "LEA   "   ,
        "MOV   "   ,
        "POP   "   ,


        "NOP   ",                       /* opcodes 90 -> 97 */
        "XCHG  AX,CX",
        "XCHG  AX,DX",
        "XCHG  AX,BX",
        "XCHG  AX,SP",
        "XCHG  AX,BP",
        "XCHG  AX,SI",
        "XCHG  AX,DI",

        "CBW   "   ,                            /* opcodes 98 -> 9f */
        "CWD   "   ,
        "CALLF "   ,
        "WAIT  "   ,
        "PUSHF "   ,
        "POPF  "   ,
        "SAHF  "   ,
        "LAHF  "   ,

        "MOV   " ,                              /* opcodes a0 -> a7 */
        "MOV   " ,
        "MOV   "   ,
        "MOV   "   ,
        "MOVSB "   ,
        "MOVSW "   ,
        "CMPSB "   ,
        "CMPSW "   ,

        "TEST  AL," ,                           /* opcodes a8 -> af */
        "TEST  AX," ,
        "STOSB "   ,
        "STOSW "   ,
        "LODSB "   ,
        "LODSW "   ,
        "SCASB "   ,
        "SCASW "   ,

        "MOV   AL," ,                           /* opcodes b0 -> b7 */
        "MOV   CL," ,
        "MOV   DL," ,
        "MOV   BL," ,
        "MOV   AH," ,
        "MOV   CH," ,
        "MOV   DH," ,
        "MOV   BH," ,

        "MOV   AX," ,                           /* opcodes b8 -> bf */
        "MOV   CX," ,
        "MOV   DX," ,
        "MOV   BX," ,
        "MOV   SP," ,
        "MOV   BP," ,
        "MOV   SI," ,
        "MOV   DI," ,

        ""   ,                                  /* opcodes c0 -> c7 */
        ""   ,
        "RET   "   ,
        "RET   "   ,
        "LES   "   ,
        "LDS   "   ,
        "MOV   "   ,
        "MOV   "   ,

        "ENTER "   ,                            /* opcodes c8 -> cf */
        "LEAVE "   ,
        "RETF  "   ,
        "RETF  "   ,
        "INT   3"  ,
        "INT   "   ,
        "INTO  "   ,
        "IRET  "   ,

        ""          ,                           /* opcodes d0 -> d7 */
        ""          ,
        ""          ,
        ""          ,
        "AAM   "   ,
        "AAD   "   ,
        "BOP   "   ,
        "XLAT  "   ,

        ""  ,                                   /* opcodes d8 -> df */
        ""  ,
        ""  ,
        ""  ,
        ""  ,
        ""  ,
        ""  ,
        ""  ,

        "LOOPNZ"  ,                             /* opcodes e0 -> e7 */
        "LOOPE "   ,
        "LOOP  "   ,
        "JCXZ  "   ,
        "INB   " ,
        "INW   " ,
        "OUTB  ",
        "OUTW  ",

        "CALL  "   ,                            /* opcodes e8 -> ef */
        "JMP   "   ,
        "JMPF  "   ,
        "JMP   "   ,
        "INB   ",
        "INW   ",
        "OUTB  ",
        "OUTW  ",

        "LOCK  "   ,                            /* opcodes f0 - f7 */
        "??    "   ,
        "REPNE: "   ,
        "REPE:  "   ,
        "HLT   "   ,
        "CMC   "   ,
        ""          ,
        ""          ,

        "CLC   "   ,                            /* opcodes f8 - ff */
        "STC   "   ,
        "CLI   "   ,
        "STI   "   ,
        "CLD   "   ,
        "STD   "   ,
        ""          ,
        ""          ,
};

static int SEGMENT;

#ifdef NTVDM
OPCODE_FRAME *opcode_ptr;
#else
IMPORT OPCODE_FRAME *opcode_ptr;
#endif

static int offset_reg;  /* ditto */
static int REPEAT = OFF;

static cpu_addr ea;
                                        /* Various temp variables needed */
static DASMBYTE temp_comp_b;            /* ... */
static MODR_M temp;                     /* ... */
static reg temp_reg,temp_seg,temp_count,temp_two,temp_comp, temp_reg1;
static OPCODE_FRAME *temp_frame;        /* ... */
static io_addr temp_addr;              /* ... */
static half_word temp_bit;              /* ... */
static half_word temp_cbit;             /* ... */
static int i;                           /* ... */
static int inst_size;                   /* ... */
static DASMBYTE temp_byte,temp_btwo;    /* for instruction processing */
static char *output_stream;
static word segreg, segoff;
static int nInstr;

LOCAL void show_word IPT1(sys_addr,address);
LOCAL void show_byte IPT1(sys_addr,address);
LOCAL void form_ds_addr IPT2(word,ea,sys_addr *,phys);
LOCAL void place_byte IPT2(int, posn, half_word, value);
LOCAL void get_char_w IPT1(int, nr_words);
LOCAL void get_char_b IPT0();

LOCAL word unassemble IPT0();

GLOBAL word dasm IFN5(
char *, i_output_stream,
word, i_atomicsegover,  /* REDUNDANT */
word, i_segreg,         /* Segment register value for start of disassemble */
word, i_segoff,         /* Offset register value for start of disassemble */
int, i_nInstr)          /* # of instructions to be disassembled */
{
UNUSED(i_atomicsegover);
output_stream = i_output_stream;
segreg = i_segreg;
segoff = i_segoff;
nInstr = i_nInstr;

return unassemble();

}

/* Single Byte defines opcode */
static void SBYTE()
{
   sbyte
   print_return
}

/* Single Byte stack opcodes */
static void STK_PUSH()
{
   sys_addr mem_addr;
   word new_top;

   sbyte
   new_top = getSP() - 2;
   mem_addr = effective_addr(getSS(), new_top);
   temp_char[0] = '\0';
   show_word(mem_addr);
   strcat(out_line,temp_char);
   print_return
}

static void STK_POP()
{
   sys_addr mem_addr;

   sbyte
   mem_addr = effective_addr(getSS(), getSP());
   temp_char[0] = '\0';
   show_word(mem_addr);
   strcat(out_line,temp_char);
   print_return
}

static void JA()     /* Jump on Above
           Jump on Not Below or Equal */
{
   jmp_dest
   if ( getCF() == 0 && getZF() == 0 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JAE()    /* Jump on Above or Equal
           Jump on Not Below
           Jump on Not Carry */
{
   jmp_dest
   if ( getCF() == 0 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JB()     /* Jump on Below
           Jump on Not Above or Equal
           Jump on Carry */
{
   jmp_dest
   if ( getCF() == 1 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JBE()    /* Jump on Below or Equal
           Jump on Not Above */
{
   jmp_dest
   if ( getCF() == 1 || getZF() == 1 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JCXZ()   /* Jump if CX register Zero */
{
   jmp_dest
   if ( getCX() == 0 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JG()     /* Jump on Greater
           Jump on Not Less nor Equal */
{
   jmp_dest
   if ( (getSF() == getOF()) &&
        getZF() == 0 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JGE()    /* Jump on Greater or Equal
           Jump on Not Less */
{
   jmp_dest
   if ( getSF() == getOF() )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JL()     /* Jump on Less
           Jump on Not Greater or Equal */
{
   jmp_dest
   if ( getSF() != getOF() )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JLE()    /* Jump on Less or Equal
           Jump on Not Greater */
{
   jmp_dest
   if ( getSF() != getOF() ||
        getZF() == 1 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JNE()    /* Jump on Not Equal
           Jump on Not Zero */
{
   jmp_dest
   if ( getZF() == 0 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JNO()    /* Jump on Not Overflow */
{
   jmp_dest
   if ( getOF() == 0 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JNS()    /* Jump on Not Sign */
{
   jmp_dest
   if ( getSF() == 0 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JNP()    /* Jump on Nor Parity
           Jump on Parity Odd */
{
   jmp_dest
   if ( getPF() == 0 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JO()     /* Jump on Overflow
           Jump on Not Below oe Equal */
{
   jmp_dest
   if ( getOF() == 1 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JP()     /* Jump on Parity
           Jump on Parity Equal */
{
   jmp_dest
   if ( getPF() == 1 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

static void JS()     /* Jump on Sign */
{
   jmp_dest
   if ( getSF() == 1 )
      strcat(out_line, JUMP);
   else
      strcat(out_line, NOJUMP);
   print_return
}

/*
 * JE Jump on Equal
      Jump on Zero
 */
static void JE()
{
   jmp_dest
  if(getZF())
      strcat(out_line, JUMP);
  else
      strcat(out_line, NOJUMP);
   print_return
}
/*
 * JMP "direct short" operation "
 */
static void JMPDS()
{
   jmp_dest
   print_return
}
static void LOOP()   /* Loop */
{
   jmp_dest
   temp_reg.X = getCX();
   if ( --temp_reg.X != 0 )
      strcat(out_line, " ; Loop");
   else
      strcat(out_line, NOLOOP);
   print_return
}

static void LOOPE()  /* Loop while Equal
           Loop while Zero */
{
   jmp_dest
   temp_reg.X = getCX();
   if ( --temp_reg.X != 0 && getZF() == 1 )
      strcat(out_line, " ; Loop");
   else
      strcat(out_line, NOLOOP);
   print_return
}

static void LOOPNZ() /* Loop while Not Zero
                   Loop while Not Equal */
{
   jmp_dest
   temp_reg.X = getCX();
   if ( --temp_reg.X != 0 && getZF() == 0 )
      strcat(out_line, " ; Loop");
   else
      strcat(out_line, NOLOOP);
   print_return
}

static void CODEF7()    /* DIV,IDIV,IMUL,MUL,NEG,NOT,TEST  - WORD */
{
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_F7[temp.field.xxx]);
   segoff = segoff + LEN_F7[temp.field.xxx];
   switch ( temp.field.xxx ) {
   case 0:   /* TEST - Immed. op. with mem. or reg. op.  */
   case 1:   /* TEST - Immed. op. with mem. or reg. op.  */
      get_char_w(1);
      load_34
      place_34
      print_addr_c
      sprintf(temp_char,"%04x",temp_reg.X);
      strcat(out_line,temp_char);
      break;
   case 2:   /* NOT */
   case 3:   /* NEG */
   case 4:   /* MUL */
   case 5:   /* IMUL */
   case 6:   /* DIV */
   case 7:   /* IDIV */
      get_char_w(1);
      strcat(out_line,temp_char);
      break;
   default:
      break;
   }
   print_return
}

static void CODE81()   /* ADC,ADD,AND,CMP,OR,SBB,SUB,XOR   - WORD */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   temp.X = op->SECOND_BYTE;
   place_op
   place_2
   strcat(out_line, CODE_80[temp.field.xxx]);
   get_char_w(1);
   load_34
   place_34
   print_addr_c
   sprintf(temp_char,"%04x",temp_reg.X);
   strcat(out_line,temp_char);
   print_return

}


static void CODE83()   /* ADC,ADD,AND,CMP,OR,SBB,SUB,XOR   - Byte with sign extension */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   temp.X = op->SECOND_BYTE;
   place_op
   place_2
   strcat(out_line, CODE_83[temp.field.xxx]);
   get_char_w(1);
   load_3
   place_3
   print_addr_c
   print_byte_v
   print_return
}

static void MOV2W()   /* MOV - Immed. op. to mem. or reg. op. */
{
   sbyte
   place_2
   get_char_w(1);
   load_34
   place_34
   print_addr_c
   sprintf(temp_char,"%04x",temp_reg.X);
   strcat(out_line,temp_char);
   print_return
}

static void CODEF6()    /* DIV,IDIV,IMUL,MUL,NEG,NOT,TEST  - BYTE */
{
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_F7[temp.field.xxx]);
   segoff = segoff + LEN_F6[temp.field.xxx];
   switch ( temp.field.xxx ) {   /* select function */
   case 0:   /* TEST - Immed. op. with mem. or reg. op.  */
   case 1:   /* TEST - Immed. op. with mem. or reg. op.  */
      get_char_b();
      load_3
      place_3
      print_addr_c
      print_byte_v
      break;
   case 2:   /* NOT */
   case 3:   /* NEG */
   case 4:   /* MUL */
   case 5:   /* IMUL */
   case 6:   /* DIV */
   case 7:   /* IDIV */
      get_char_b();
      strcat(out_line,temp_char);
      break;
   default:
      break;
   }
   print_return
}

/* two byte opcode of form reg,r/m */
static void B_REG_EA()
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   sprintf(temp_char, "%s,",reg8name[temp.field.xxx]);
   strcat(out_line,temp_char);
   get_char_b();
   strcat(out_line,temp_char);
   print_return
}

/* two byte opcode of form r/m,reg */
static void B_EA_REG()
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   get_char_b();
   strcat(out_line,temp_char);
   sprintf(temp_char,",%s",reg8name[temp.field.xxx]);
   strcat(out_line,temp_char);
   print_return
}

/* two byte opcode of form reg,r/m */
static void W_REG_EA()
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   sprintf(temp_char, "%s,",reg16name[temp.field.xxx]);
   strcat(out_line,temp_char);
   get_char_w(1);
   strcat(out_line,temp_char);
   print_return
}

/* two byte opcode of form r/m,reg */
static void W_EA_REG()
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   get_char_w(1);
   strcat(out_line,temp_char);
   sprintf(temp_char, ",%s", reg16name[temp.field.xxx]);
   strcat(out_line,temp_char);
   print_return
}

static void CODE80()   /* ADC,ADD,AND,CMP,OR,SBB,SUB,XOR   - BYTE */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   temp.X = op->SECOND_BYTE;
   place_op
   place_2
   strcat(out_line, CODE_80[temp.field.xxx]);
   get_char_b();
   load_3
   place_3
   print_addr_c
   print_byte_v
   print_return

}

static void MOV2B()   /* MOV - Immed. op. to mem. or reg. op. */
{
   sbyte
   place_2
   get_char_b();
   load_3
   place_3
   print_addr_c
   print_byte_v
   print_return
}

static void EA_DBL()
{
        temp.X = op->SECOND_BYTE;

/*
 * Deal with the special BOP case: C4 C4.
 */

        if ((op->OPCODE == 0xc4) && (op->SECOND_BYTE == 0xc4))
        {
                place_op
                place_23
                strcat(out_line, "BOP   ");
                load_3
                print_byte_v
                segoff += 3;
        }
        else
        {
                sbyte
                place_2
                if (temp.field.mod == 3)
                        /* Undefined operation */
                        strcat(out_line,"??");
                else
                {
                        get_char_w(2);
                        strcat(out_line, reg16name[temp.field.xxx]);
                        print_c_addr
                }
        }
        print_return
}

static void LEA()   /* Load Effective Address */
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   if ( temp.field.mod == 3 )
      /* Undefined operation */
      strcat(out_line,"??");
   else
      {
     /* First act on the mod value in the instruction */

     strcat(out_line, reg16name[temp.field.xxx]);
     strcat(out_line,",");

     switch ( temp.field.mod ) {
     case 0:
        if ( temp.field.r_m == 6 )
           {  /* Direct addr */
           temp_reg.byte.low = op->THIRD_BYTE;
           temp_reg.byte.high = op->FOURTH_BYTE;
           place_34
           sprintf(temp_char,"%04x",temp_reg.X);
           strcat(out_line, temp_char);
           sas_inc_buf(op,2);
           disp_length = 2;
           goto LAB1;
           }
        else
           {
           temp_two.X = 0;
           sprintf(temp_char, "%s",address[temp.field.r_m]);
           }
        break;

     case 1:
        /* one byte displacement in inst. */
        temp_two.X = (char) op->THIRD_BYTE;
         place_3
            sas_inc_buf(op,1);
        disp_length = 1;
        if ( temp_two.X == 0 )
           sprintf(temp_char, "[%s]",address[temp.field.r_m]);
        else
          {
          if ((IS8)temp_two.X < 0)
            sprintf(temp_char,"[%s-%04x]",address[temp.field.r_m], 0-(IS8)temp_two.X);
          else
            sprintf(temp_char,"[%s+%04x]",address[temp.field.r_m], temp_two.X);
          }
        break;

     case 2:
        /* two byte displacement in inst. */
        temp_two.byte.low = op->THIRD_BYTE;
        temp_two.byte.high = op->FOURTH_BYTE;
        place_34
            sas_inc_buf(op,2);
        disp_length = 2;
        if ( temp_two.X == 0 )
           sprintf(temp_char, "[%s]",address[temp.field.r_m]);
        else
           sprintf(temp_char,"[%s+%04x]",address[temp.field.r_m], temp_two.X);
        break;

     case 3:
        /* Register  NOT ALLOWED */
        strcat(out_line,"??");
        break;
     }

   /* Now act on the r/m (here called r_m) field */

     switch ( temp.field.r_m ) {
     case 0:   /* Based index addr */
        temp_reg.X = getBX() + getSI() + temp_two.X;
        break;
     case 1:   /* Based index addr */
        temp_reg.X = getBX() + getDI() + temp_two.X;
        break;
     case 2:   /* Based index addr */
        temp_reg.X = getBP() + getSI() + temp_two.X;
        break;
     case 3:   /* Based index addr */
        temp_reg.X = getBP() + getDI() + temp_two.X;
        break;
     case 4:   /* Index addr */
        temp_reg.X = getSI() + temp_two.X;
        break;
     case 5:   /* Index addr */
        temp_reg.X = getDI() + temp_two.X;
        break;
     case 6:   /* Base addr */
        temp_reg.X = getBP() + temp_two.X;
        break;
     case 7:   /* Based index addr */
        temp_reg.X = getBX() + temp_two.X;
        break;
     }
     strcat(out_line, temp_char);
     sprintf(temp_char," (%04x)",temp_reg.X);
     strcat(out_line,temp_char);

      }
LAB1 :
   print_return
}

static void JMPD()   /* JMP Intra-segment Direct */
{
   sbyte
   place_23
   load_23
   sprintf(temp_char, "%04x",
          (IU16)(segoff + (short)temp_reg.X));
   strcat(out_line,temp_char);
   print_return
}

static void CODEFF()   /* CALL,DEC,INC,JMP,PUSH  */
{
   sys_addr mem_addr;
   word new_top;

   segoff += LEN_ASM[op->OPCODE];
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_FF[temp.field.xxx]);
   switch ( temp.field.xxx )  {  /* select function */
   case 4:   /* JMP intra-segment indirect */
   case 2:   /* CALL Intra-segment indirect */
      get_char_w(1);
      strcat(out_line,temp_char);
      break;

   case 3:   /* CALL Inter-segment indirect */
   case 5:   /* JMP inter-segment indirect */
      get_char_w(2);
      strcat(out_line,temp_char);
      break;

   case 0:   /* INC */
   case 1:   /* DEC */
      get_char_w(1);
      strcat(out_line,temp_char);
      break;

   case 6:   /* PUSH */
      get_char_w(1);
      new_top = getSP() - 2;
      mem_addr = effective_addr(getSS(), new_top);
      show_word(mem_addr);
      strcat(out_line,temp_char);
      break;

   default:
      break;
   }
   print_return
}

static void JMP4()   /* JMP Inter-segment direct */
{
   sbyte
   load_23
   place_23
   temp_two.X = temp_reg.X;
   /* Increment pointer so we can get at segment data */
            sas_inc_buf(op,2);
   load_23
   place_23
   sprintf(temp_char, "%04x:%04x",temp_reg.X,temp_two.X);
   strcat(out_line,temp_char);
   print_return
}

static void CODEFE()   /* DEC,INC */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_FE[temp.field.xxx]);
   if ( temp.field.xxx == 0 ||
        temp.field.xxx == 1 )
      {
      get_char_b();
      strcat(out_line,temp_char);
      }
   print_return
}

static void POP1()   /* POP mem. or reg. op. */
{
   sys_addr mem_addr;

   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   if ( temp.field.xxx == 0 )
      {
      get_char_w(1);
      mem_addr = effective_addr(getSS(), getSP());
      show_word(mem_addr);
      strcat(out_line,temp_char);
      }
   else
      strcat(out_line,"??");
   print_return
}

static void AAM()
{
   sbyte
   place_2
   print_return
}

static void CODED0()   /* RCL,RCR,ROL,ROR,SAL,SHL,SAR,SHR   - BYTE */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_D0[temp.field.xxx]);
   get_char_b();
   print_addr_c
   strcat(out_line,"1");
   print_return
}

static void CODED1()   /* RCL,RCR,ROL,ROR,SAL,SHL,SAR,SHR   - WORD */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_D0[temp.field.xxx]);
   get_char_w(1);
   print_addr_c
   strcat(out_line,"1");
   print_return
}

static void CODEC0()   /* RCL,RCR,ROL,ROR,SAL,SHL,SAR,SHR by ib times - BYTE */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_D0[temp.field.xxx]);
   get_char_b();
   print_addr_c
   load_3
   place_3
   print_byte_v
   print_return
}

static void CODEC1()   /* RCL,RCR,ROL,ROR,SAL,SHL,SAR,SHR by ib times - WORD */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_D0[temp.field.xxx]);
   get_char_w(1);
   print_addr_c
   load_3
   place_3
   print_byte_v
   print_return
}

static void CODED2()   /* RCL,RCR,ROL,ROR,SAL,SHL,SAR,SHR by CL times - BYTE */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_D0[temp.field.xxx]);
   get_char_b();
   print_addr_c
   strcat(out_line,"CL");
   print_return
}

static void CODED3()   /* RCL,RCR,ROL,ROR,SAL,SHL,SAR,SHR by CL times - WORD */
{
   segoff = segoff + LEN_ASM[op->OPCODE];
   place_op
   place_2
   temp.X = op->SECOND_BYTE;
   strcat(out_line, CODE_D0[temp.field.xxx]);
   get_char_w(1);
   print_addr_c
   strcat(out_line,"CL");
   print_return
}

/* Dasm is so enormous, we have to split it into two segs on Mac. */
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "DASM2.seg"
#endif

static void XCHGW()   /*  XCHG - WORD */
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   get_char_w(1);
   strcat(out_line, reg16name[temp.field.xxx]);
   print_c_addr
   print_return
}

static void XCHGB()   /*  XCHG - BYTE */
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   get_char_b();
   strcat(out_line, reg8name[temp.field.xxx]);
   print_c_addr
   print_return
}

static void STRING()
{
   sbyte
   start_repeat
   print_return
}

/* Stack based single byte and immediate byte */
static void STK_IB()
{
   sys_addr mem_addr;
   word new_top;

   sbyte
   place_2
   temp_byte.X = op->SECOND_BYTE;
   print_byte_v
   new_top = getSP() - 2;
   mem_addr = effective_addr(getSS(), new_top);
   temp_char[0] = '\0';
   show_word(mem_addr);
   strcat(out_line,temp_char);
   print_return
}

/* single byte and immediate byte */
static void SB_IB()
{
   sbyte
   place_2
   temp_byte.X = op->SECOND_BYTE;
   print_byte_v
   print_return
}

/* single byte and immediate word */
static void SB_IW()
{
   sbyte
   load_23
   place_23
   sprintf(temp_char,"%04x",temp_reg.X);
   strcat(out_line,temp_char);
   print_return
}

/* Stack based single byte and immediate word */
static void STK_IW()
{
   sys_addr mem_addr;
   word new_top;

   sbyte
   load_23
   place_23
   sprintf(temp_char,"%04x",temp_reg.X);
   new_top = getSP() - 2;
   mem_addr = effective_addr(getSS(), new_top);
   show_word(mem_addr);
   strcat(out_line,temp_char);
   print_return
}

/* single byte and immediate word and immediate byte */
static void SB_IW_IB()
{
   sbyte
   load_23
   place_23
   sprintf(temp_char,"%04x,",temp_reg.X);
   strcat(out_line,temp_char);
   place_4
   temp_byte.X = op->FOURTH_BYTE;
   print_byte_v
   print_return
}

static void MOV4W()   /* MOV - Mem op to accumulator - WORD */
{
   sys_addr mem_addr;

   sbyte
   place_23
   load_23
   strcat(out_line,"AX,");
   sprintf(temp_char,"[%04x]",temp_reg.X);
   form_ds_addr(temp_reg.X, &mem_addr);
   show_word(mem_addr);
   strcat(out_line,temp_char);
   print_return
}

static void MOV4B()   /* MOV - Mem op to accumulator - BYTE */
{
   sys_addr mem_addr;

   sbyte
   place_23
   load_23
   strcat(out_line,"AL,");
   sprintf(temp_char,"[%04x]",temp_reg.X);
   form_ds_addr(temp_reg.X, &mem_addr);
   show_byte(mem_addr);
   strcat(out_line,temp_char);
   print_return
}

static void MOV5W()   /* MOV - accumulator to mem op - WORD */
{
   sys_addr mem_addr;

   sbyte
   place_23
   load_23
   sprintf(temp_char,"[%04x]",temp_reg.X);
   form_ds_addr(temp_reg.X, &mem_addr);
   show_word(mem_addr);
   strcat(out_line,temp_char);
   strcat(out_line,",AX");
   print_return
}

static void MOV5B()   /* MOV - accumulator to mem op - BYTE */
{
   sys_addr mem_addr;

   sbyte
   place_23
   load_23
   sprintf(temp_char,"[%04x]",temp_reg.X);
   form_ds_addr(temp_reg.X, &mem_addr);
   show_byte(mem_addr);
   strcat(out_line,temp_char);
   strcat(out_line,",AL");
   print_return
}

static void MOV6()   /* MOV - mem or reg op to Segment register */
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   if ( temp.field.xxx == 1 )
      /* Undefined operation */
      strcat(out_line,"??");
   else
      {
      get_char_w(1);
      strcat(out_line, segregname[temp.field.xxx]);
      print_c_addr
      }
   print_return
}

static void MOV7()   /* MOV - Seg reg to mem or reg op */
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   get_char_w(1);
   print_addr_c
   strcat(out_line, segregname[temp.field.xxx]);
   print_return
}

/* reg = ea <op> immed */
static void OP_3B()
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   sprintf(temp_char,"%s,",reg16name[temp.field.xxx]);
   strcat(out_line, temp_char);
   get_char_w(1);
   load_3
   place_3
   print_addr_c
   print_byte_v
   print_return
}

/* reg = ea <op> immed */
static void OP_3W()
{
   sbyte
   place_2
   temp.X = op->SECOND_BYTE;
   sprintf(temp_char,"%s,",reg16name[temp.field.xxx]);
   strcat(out_line, temp_char);
   get_char_w(1);
   load_34
   place_34
   print_addr_c
   sprintf(temp_char,"%04x",temp_reg.X);
   strcat(out_line,temp_char);
   print_return
}

/* Data for 0F opcodes */

#define NR_PREFIX_OPCODES 18

#define I_LAR   0
#define I_LSL   1
#define I_CLTS  2
#define I_LGDT  3
#define I_LIDT  4
#define I_SGDT  5
#define I_SIDT  6
#define I_SMSW  7
#define I_LMSW  8
#define I_LLDT  9
#define I_LTR  10
#define I_SLDT 11
#define I_STR  12
#define I_VERR 13
#define I_VERW 14
#define I_BAD2 15
#define I_BAD3 16
#define I_LOADALL 17

#define PREFIX_NOOPERAND 0
#define PREFIX_RW_EW     1
#define PREFIX_SIXBYTE   2
#define PREFIX_EW        3
#define PREFIX_NOOP3     4

static char *PREFIX_ASM[NR_PREFIX_OPCODES] =
   {
   "LAR   ", "LSL   ", "CLTS  ", "LGDT  ", "LIDT  ", "SGDT  ",
   "SIDT  ", "SMSW  ", "LMSW  ", "LLDT  ", "LTR   ", "SLDT  ",
   "STR   ", "VERR  ", "VERW  ", "??    ", "??    ", "LOADALL"
   };

static int PREFIX_LEN[NR_PREFIX_OPCODES] =
   {
   3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 2
   };

static int PREFIX_OPERAND[NR_PREFIX_OPCODES] =
   {
   PREFIX_RW_EW, PREFIX_RW_EW,
   PREFIX_NOOPERAND,
   PREFIX_SIXBYTE, PREFIX_SIXBYTE, PREFIX_SIXBYTE, PREFIX_SIXBYTE,
   PREFIX_EW, PREFIX_EW, PREFIX_EW, PREFIX_EW,
   PREFIX_EW, PREFIX_EW, PREFIX_EW, PREFIX_EW,
   PREFIX_NOOPERAND,
   PREFIX_NOOP3,
   PREFIX_NOOPERAND,
   };

/* process 0F opcodes */
static void PREFIX()
{
   int inst;

   /* decode opcode */
   load_2
   switch ( temp_byte.X )
      {
   case 0:
      temp.X = op->THIRD_BYTE;
      switch ( temp.field.xxx )
         {
      case 0: inst = I_SLDT; break;
      case 1: inst = I_STR;  break;
      case 2: inst = I_LLDT; break;
      case 3: inst = I_LTR;  break;
      case 4: inst = I_VERR; break;
      case 5: inst = I_VERW; break;
      case 6: inst = I_BAD3; break;
      case 7: inst = I_BAD3; break;
         }
      break;

   case 1:
      temp.X = op->THIRD_BYTE;
      switch ( temp.field.xxx )
         {
      case 0: inst = I_SGDT; break;
      case 1: inst = I_SIDT; break;
      case 2: inst = I_LGDT; break;
      case 3: inst = I_LIDT; break;
      case 4: inst = I_SMSW; break;
      case 5: inst = I_BAD3; break;
      case 6: inst = I_LMSW; break;
      case 7: inst = I_BAD3; break;
         }
      break;

   case 2:  inst = I_LAR;     break;
   case 3:  inst = I_LSL;     break;
   case 5:  inst = I_LOADALL; break;
   case 6:  inst = I_CLTS;    break;
   default: inst = I_BAD2;    break;
      }

   /* process opcode */
   place_op
   place_2
   strcat(out_line, PREFIX_ASM[inst]);
   segoff = segoff + PREFIX_LEN[inst];

   switch ( PREFIX_OPERAND[inst] )
      {
   case PREFIX_NOOP3:
      load_3
      place_3
      break;

   case PREFIX_NOOPERAND:
      break;

   case PREFIX_RW_EW:
      load_3
      place_3
      temp.X = temp_byte.X;
      sprintf(temp_char, "%s,", reg16name[temp.field.xxx]);
      strcat(out_line, temp_char);
            sas_inc_buf(op,1);
      get_char_w(1);
      strcat(out_line, temp_char);
      break;

   case PREFIX_EW:
      load_3
      place_3
            sas_inc_buf(op,1);
      get_char_w(1);
      strcat(out_line, temp_char);
      break;

   case PREFIX_SIXBYTE:
      load_3
      place_3
      if ( temp.field.mod == 3 )
         strcat(out_line, "??");
      else
         {
            sas_inc_buf(op,1);
         get_char_w(3);
         strcat(out_line, temp_char);
         }
      break;

      }

   print_return
}

/* Data for Floating Point opcodes */

#define FP_OP_ST_STn          0
#define FP_OP_STn             1
#define FP_OP_STn_ST          2
#define FP_OP_SHORT_REAL      3
#define FP_OP_LONG_REAL       4
#define FP_OP_TEMP_REAL       5
#define FP_OP_WORD_INT        6
#define FP_OP_SHORT_INT       7
#define FP_OP_LONG_INT        8
#define FP_OP_PACKED_DECIMAL  9
#define FP_OP_WORD           10
#define FP_OP_14BYTES        11
#define FP_OP_94BYTES        12
#define FP_OP_NONE_ADDR      13
#define FP_OP_NONE           14

/* keep these values in ascending order! */
#define FP_ODD_D9_2 15
#define FP_ODD_D9_4 16
#define FP_ODD_D9_5 17
#define FP_ODD_D9_6 18
#define FP_ODD_D9_7 19
#define FP_ODD_DB_4 20
#define FP_ODD_DE_3 21
#define FP_ODD_DF_4 22

/* Floating Point names for memory addressing opcodes */
static char *ASM_D8M[] =   /* DC = D8 */
   {
   "FADD  ", "FMUL  ", "FCOM  ", "FCOMP ",
   "FSUB  ", "FSUBR ", "FDIV  ", "FDIVR "
   };

static char *ASM_D9M[] =
   {
   "FLD   ", "??    ", "FST   ", "FSTP  ",
   "FLDENV ", "FLDCW ", "FSTENV ", "FSTCW "
   };

static char *ASM_DAM[] =   /* DE = DA */
   {
   "FIADD ", "FIMUL ", "FICOM ", "FICOMP ",
   "FISUB ", "FISUBR ", "FIDIV ", "FIDIVR "
   };

static char *ASM_DBM[] =
   {
   "FILD  ", "??    ", "FIST  ", "FISTP ",
   "??    ", "FLD   ", "??    ", "FSTP  "
   };

static char *ASM_DDM[] =
   {
   "FLD   ", "??    ", "FST   ", "FSTP  ",
   "FRSTOR ", "??    ", "FSAVE ", "FSTSW "
   };

static char *ASM_DFM[] =   /* DC = D8 */
   {
   "FILD  ", "??    ", "FIST  ", "FISTP ",
   "FBLD  ", "FILD  ", "FBSTP ", "FISTP "
   };

/* Floating Point operand types for memory addressing opcodes */
static int OP_D8M[] =
   {
   FP_OP_SHORT_REAL, FP_OP_SHORT_REAL, FP_OP_SHORT_REAL, FP_OP_SHORT_REAL,
   FP_OP_SHORT_REAL, FP_OP_SHORT_REAL, FP_OP_SHORT_REAL, FP_OP_SHORT_REAL
   };

static int OP_D9M[] =
   {
   FP_OP_SHORT_REAL, FP_OP_NONE_ADDR, FP_OP_SHORT_REAL, FP_OP_SHORT_REAL,
   FP_OP_14BYTES, FP_OP_WORD, FP_OP_14BYTES, FP_OP_WORD
   };

static int OP_DAM[] =
   {
   FP_OP_SHORT_INT, FP_OP_SHORT_INT, FP_OP_SHORT_INT, FP_OP_SHORT_INT,
   FP_OP_SHORT_INT, FP_OP_SHORT_INT, FP_OP_SHORT_INT, FP_OP_SHORT_INT
   };

static int OP_DBM[] =
   {
   FP_OP_SHORT_INT, FP_OP_NONE_ADDR, FP_OP_SHORT_INT, FP_OP_SHORT_INT,
   FP_OP_NONE_ADDR, FP_OP_TEMP_REAL, FP_OP_NONE_ADDR, FP_OP_TEMP_REAL
   };

static int OP_DCM[] =
   {
   FP_OP_LONG_REAL, FP_OP_LONG_REAL, FP_OP_LONG_REAL, FP_OP_LONG_REAL,
   FP_OP_LONG_REAL, FP_OP_LONG_REAL, FP_OP_LONG_REAL, FP_OP_LONG_REAL
   };

static int OP_DDM[] =
   {
   FP_OP_LONG_REAL, FP_OP_NONE_ADDR, FP_OP_LONG_REAL, FP_OP_LONG_REAL,
   FP_OP_94BYTES, FP_OP_NONE_ADDR, FP_OP_94BYTES, FP_OP_NONE_ADDR
   };

static int OP_DEM[] =
   {
   FP_OP_WORD_INT, FP_OP_WORD_INT, FP_OP_WORD_INT, FP_OP_WORD_INT,
   FP_OP_WORD_INT, FP_OP_WORD_INT, FP_OP_WORD_INT, FP_OP_WORD_INT
   };

static int OP_DFM[] =
   {
   FP_OP_WORD_INT, FP_OP_NONE_ADDR, FP_OP_WORD_INT, FP_OP_WORD_INT,
   FP_OP_PACKED_DECIMAL,FP_OP_LONG_INT, FP_OP_PACKED_DECIMAL,FP_OP_LONG_INT
   };

/* Floating Point names for register addressing opcodes */
/* D8R = D8M */
static char *ASM_D9R[] =
   {
   "FLD   ", "FXCH  ", "", "FSTP  ",
   "", "", "", ""
   };

static char *ASM_DAR[] =
   {
   "??    ", "??    ", "??    ", "??    ",
   "??    ", "??    ", "??    ", "??    "
   };

static char *ASM_DBR[] =
   {
   "??    ", "??    ", "??    ", "??    ",
   "", "??    ", "??    ", "??    "
   };

static char *ASM_DCR[] =
   {
   "FADD  ", "FMUL  ", "FCOM  ", "FCOMP ",
   "FSUBR ", "FSUB  ", "FDIVR ", "FDIV  "
   };

static char *ASM_DDR[] =
   {
   "FFREE ", "FXCH  ", "FST   ", "FSTP  ",
   "??    ", "??    ", "??    ", "??    "
   };

static char *ASM_DER[] =
   {
   "FADDP ", "FMULP ", "FCOMP ", "",
   "FSUBRP ", "FSUBP ", "FDIVRP ", "FDIVP "
   };

static char *ASM_DFR[] =
   {
   "FFREEP ", "FXCH  ", "FSTP  ", "FSTP  ",
   "", "??    ", "??    ", "??    "
   };

static char *ASM_ODD[] =
   {
   /* D9_2 */
   "FNOP  ", "??    ", "??    ", "??    ",
   "??    ", "??    ", "??    ", "??    ",
   /* D9_4 */
   "FCHS  ", "FABS  ", "??    ", "??    ",
   "FTST  ", "FXAM  ", "??    ", "??    ",
   /* D9_5 */
   "FLD1  ", "FLDL2T", "FLDL2E", "FLDPI ",
   "FLDLG2", "FLDLN2", "FLDZ  ", "??    ",
   /* D9_6 */
   "F2XM1 ", "FYL2X ", "FPTAN ", "FPATAN",
   "FXTRACT", "??    ", "FDECSTP", "FINCSTP",
   /* D9_7 */
   "FPREM ", "FYL2XP1", "FSQRT ", "??    ",
   "FRNDINT", "FSCALE", "??    ", "??    ",
   /* DB_4 */
   "??    ", "??    ", "FCLEX ", "FINIT ",
   "FSETPM", "??    ", "??    ", "??    ",
   /* DE_3 */
   "??    ", "FCOMPP", "??    ", "??    ",
   "??    ", "??    ", "??    ", "??    ",
   /* DF_4 */
   "FSTSW AX", "??    ", "??    ", "??    ",
   "??    ", "??    ", "??    ", "??    "
   };

/* Floating Point operand types for register addressing opcodes */
static int OP_D8R[] =
   {
   FP_OP_ST_STn, FP_OP_ST_STn, FP_OP_STn, FP_OP_STn,
   FP_OP_ST_STn, FP_OP_ST_STn, FP_OP_ST_STn, FP_OP_ST_STn
   };

static int OP_D9R[] =
   {
   FP_OP_STn, FP_OP_STn, FP_ODD_D9_2, FP_OP_STn,
   FP_ODD_D9_4, FP_ODD_D9_5, FP_ODD_D9_6, FP_ODD_D9_7,
   };

static int OP_DAR[] =
   {
   FP_OP_NONE, FP_OP_NONE, FP_OP_NONE, FP_OP_NONE,
   FP_OP_NONE, FP_OP_NONE, FP_OP_NONE, FP_OP_NONE
   };

static int OP_DBR[] =
   {
   FP_OP_NONE, FP_OP_NONE, FP_OP_NONE, FP_OP_NONE,
   FP_ODD_DB_4, FP_OP_NONE, FP_OP_NONE, FP_OP_NONE
   };

static int OP_DCR[] =
   {
   FP_OP_STn_ST, FP_OP_STn_ST, FP_OP_STn, FP_OP_STn,
   FP_OP_STn_ST, FP_OP_STn_ST, FP_OP_STn_ST, FP_OP_STn_ST
   };

static int OP_DDR[] =
   {
   FP_OP_STn, FP_OP_STn, FP_OP_STn, FP_OP_STn,
   FP_OP_NONE, FP_OP_NONE, FP_OP_NONE, FP_OP_NONE
   };

static int OP_DER[] =
   {
   FP_OP_STn_ST, FP_OP_STn_ST, FP_OP_STn, FP_ODD_DE_3,
   FP_OP_STn_ST, FP_OP_STn_ST, FP_OP_STn_ST, FP_OP_STn_ST
   };

static int OP_DFR[] =
   {
   FP_OP_STn, FP_OP_STn, FP_OP_STn, FP_OP_STn,
   FP_ODD_DF_4, FP_OP_NONE, FP_OP_NONE, FP_OP_NONE
   };

/* Process Floating Point opcodes */
#ifdef ANSI
static void do_fp(char *mem_names[], int mem_ops[], char *reg_names[], int reg_ops[])
#else
static void do_fp(mem_names, mem_ops, reg_names, reg_ops)
char *mem_names[];
int   mem_ops[];
char *reg_names[];
int   reg_ops[];
#endif
   {
   char *fp_name;
   int fp_op;

   /* decode opcode */
   temp.X = op->SECOND_BYTE;
   if ( temp.field.mod == 3 )
      {
      fp_name = reg_names[temp.field.xxx];
      fp_op   = reg_ops[temp.field.xxx];
      /* beware irregular register addressing */
      if ( fp_op >= FP_ODD_D9_2 )
         {
         fp_op = ( fp_op - FP_ODD_D9_2 ) * 8;
         fp_name = ASM_ODD[fp_op + temp.field.r_m];
         fp_op = FP_OP_NONE;
         }
      }
   else
      {
      fp_name = mem_names[temp.field.xxx];
      fp_op   = mem_ops[temp.field.xxx];
      }

   /* process opcode */
   place_op
   place_2
   strcat(out_line, fp_name);
   segoff += 2;

   switch ( fp_op )
      {
   case FP_OP_NONE:
      break;

   case FP_OP_SHORT_REAL:
      get_char_w(0);
      strcat(out_line, temp_char);
      strcat(out_line, " (SR)");
      break;

   case FP_OP_LONG_REAL:
      get_char_w(0);
      strcat(out_line, temp_char);
      strcat(out_line, " (LR)");
      break;

   case FP_OP_TEMP_REAL:
      get_char_w(0);
      strcat(out_line, temp_char);
      strcat(out_line, " (TR)");
      break;

   case FP_OP_WORD_INT:
      get_char_w(0);
      strcat(out_line, temp_char);
      strcat(out_line, " (WI)");
      break;

   case FP_OP_SHORT_INT:
      get_char_w(0);
      strcat(out_line, temp_char);
      strcat(out_line, " (SI)");
      break;

   case FP_OP_LONG_INT:
      get_char_w(0);
      strcat(out_line, temp_char);
      strcat(out_line, " (LI)");
      break;

   case FP_OP_PACKED_DECIMAL:
      get_char_w(0);
      strcat(out_line, temp_char);
      strcat(out_line, " (PD)");
      break;

   case FP_OP_WORD:
      get_char_w(1);
      strcat(out_line, temp_char);
      break;

   case FP_OP_NONE_ADDR:
   case FP_OP_14BYTES:
   case FP_OP_94BYTES:
      get_char_w(0);
      strcat(out_line, temp_char);
      break;

   case FP_OP_ST_STn:
      strcat(out_line, "ST,");
      /* drop through */

   case FP_OP_STn:
      sprintf(temp_char, "ST(%d)", temp.field.r_m);
      strcat(out_line, temp_char);
      break;

   case FP_OP_STn_ST:
      sprintf(temp_char, "ST(%d)", temp.field.r_m);
      strcat(out_line, temp_char);
      strcat(out_line, ",ST");
      break;
      }

   print_return
   }

static void CODED8()
   {
   do_fp(ASM_D8M, OP_D8M, ASM_D8M, OP_D8R);
   }

static void CODED9()
   {
   do_fp(ASM_D9M, OP_D9M, ASM_D9R, OP_D9R);
   }

static void CODEDA()
   {
   do_fp(ASM_DAM, OP_DAM, ASM_DAR, OP_DAR);
   }

static void CODEDB()
   {
   do_fp(ASM_DBM, OP_DBM, ASM_DBR, OP_DBR);
   }

static void CODEDC()
   {
   do_fp(ASM_D8M, OP_DCM, ASM_DCR, OP_DCR);
   }

static void CODEDD()
   {
   do_fp(ASM_DDM, OP_DDM, ASM_DDR, OP_DDR);
   }

static void CODEDE()
   {
   do_fp(ASM_DAM, OP_DEM, ASM_DER, OP_DER);
   }

static void CODEDF()
   {
   do_fp(ASM_DFM, OP_DFM, ASM_DFR, OP_DFR);
   }

LOCAL word unassemble IPT0()
{
static int (*CPUOPS[])() =
    {
    (int (*)()) B_EA_REG,  /* OP-code 0 */
    (int (*)()) W_EA_REG,  /* OP-code 1 */
    (int (*)()) B_REG_EA,  /* OP-code 2 */
    (int (*)()) W_REG_EA,  /* OP-code 3 */
    (int (*)()) SB_IB,     /* OP-code 4 */
    (int (*)()) SB_IW,     /* OP-code 5 */
    (int (*)()) SBYTE,     /* OP-code 6 */
    (int (*)()) SBYTE,     /* OP-code 7 */
    (int (*)()) B_EA_REG,  /* OP-code 8 */
    (int (*)()) W_EA_REG,  /* OP-code 9 */
    (int (*)()) B_REG_EA,  /* OP-code a */
    (int (*)()) W_REG_EA,  /* OP-code b */
    (int (*)()) SB_IB,     /* OP-code c */
    (int (*)()) SB_IW,     /* OP-code d */
    (int (*)()) SBYTE,     /* OP-code e */
    (int (*)()) PREFIX,    /* OP-code f */

    (int (*)()) B_EA_REG,  /* OP-code 10 */
    (int (*)()) W_EA_REG,  /* OP-code 11 */
    (int (*)()) B_REG_EA,  /* OP-code 12 */
    (int (*)()) W_REG_EA,  /* OP-code 13 */
    (int (*)()) SB_IB,     /* OP-code 14 */
    (int (*)()) SB_IW,     /* OP-code 15 */
    (int (*)()) SBYTE,     /* OP-code 16 */
    (int (*)()) SBYTE,     /* OP-code 17 */
    (int (*)()) B_EA_REG,  /* OP-code 18 */
    (int (*)()) W_EA_REG,  /* OP-code 19 */
    (int (*)()) B_REG_EA,  /* OP-code 1a */
    (int (*)()) W_REG_EA,  /* OP-code 1b */
    (int (*)()) SB_IB,     /* OP-code 1c */
    (int (*)()) SB_IW,     /* OP-code 1d */
    (int (*)()) SBYTE,     /* OP-code 1e */
    (int (*)()) SBYTE,     /* OP-code 1f */

    (int (*)()) B_EA_REG,  /* OP-code 20 */
    (int (*)()) W_EA_REG,  /* OP-code 21 */
    (int (*)()) B_REG_EA,  /* OP-code 22 */
    (int (*)()) W_REG_EA,  /* OP-code 23 */
    (int (*)()) SB_IB,     /* OP-code 24 */
    (int (*)()) SB_IW,     /* OP-code 25 */
    (int (*)()) SBYTE,     /* OP-code 26 */
    (int (*)()) SBYTE,     /* OP-code 27 */
    (int (*)()) B_EA_REG,  /* OP-code 28 */
    (int (*)()) W_EA_REG,  /* OP-code 29 */
    (int (*)()) B_REG_EA,  /* OP-code 2a */
    (int (*)()) W_REG_EA,  /* OP-code 2b */
    (int (*)()) SB_IB,     /* OP-code 2c */
    (int (*)()) SB_IW,     /* OP-code 2d */
    (int (*)()) SBYTE,     /* OP-code 2e */
    (int (*)()) SBYTE,     /* OP-code 2f */

    (int (*)()) B_EA_REG,  /* OP-code 30 */
    (int (*)()) W_EA_REG,  /* OP-code 31 */
    (int (*)()) B_REG_EA,  /* OP-code 32 */
    (int (*)()) W_REG_EA,  /* OP-code 33 */
    (int (*)()) SB_IB,     /* OP-code 34 */
    (int (*)()) SB_IW,     /* OP-code 35 */
    (int (*)()) SBYTE,     /* OP-code 36 */
    (int (*)()) SBYTE,     /* OP-code 37 */
    (int (*)()) B_EA_REG,  /* OP-code 38 */
    (int (*)()) W_EA_REG,  /* OP-code 39 */
    (int (*)()) B_REG_EA,  /* OP-code 3a */
    (int (*)()) W_REG_EA,  /* OP-code 3b */
    (int (*)()) SB_IB,     /* OP-code 3c */
    (int (*)()) SB_IW,     /* OP-code 3d */
    (int (*)()) SBYTE,     /* OP-code 3e */
    (int (*)()) SBYTE,     /* OP-code 3f */

    (int (*)()) SBYTE,     /* OP-code 40 */
    (int (*)()) SBYTE,     /* OP-code 41 */
    (int (*)()) SBYTE,     /* OP-code 42 */
    (int (*)()) SBYTE,     /* OP-code 43 */
    (int (*)()) SBYTE,     /* OP-code 44 */
    (int (*)()) SBYTE,     /* OP-code 45 */
    (int (*)()) SBYTE,     /* OP-code 46 */
    (int (*)()) SBYTE,     /* OP-code 47 */
    (int (*)()) SBYTE,     /* OP-code 48 */
    (int (*)()) SBYTE,     /* OP-code 49 */
    (int (*)()) SBYTE,     /* OP-code 4a */
    (int (*)()) SBYTE,     /* OP-code 4b */
    (int (*)()) SBYTE,     /* OP-code 4c */
    (int (*)()) SBYTE,     /* OP-code 4d */
    (int (*)()) SBYTE,     /* OP-code 4e */
    (int (*)()) SBYTE,     /* OP-code 4f */

    (int (*)()) STK_PUSH,    /* OP-code 50 */
    (int (*)()) STK_PUSH,    /* OP-code 51 */
    (int (*)()) STK_PUSH,    /* OP-code 52 */
    (int (*)()) STK_PUSH,    /* OP-code 53 */
    (int (*)()) STK_PUSH,    /* OP-code 54 */
    (int (*)()) STK_PUSH,    /* OP-code 55 */
    (int (*)()) STK_PUSH,    /* OP-code 56 */
    (int (*)()) STK_PUSH,    /* OP-code 57 */
    (int (*)()) STK_POP,     /* OP-code 58 */
    (int (*)()) STK_POP,     /* OP-code 59 */
    (int (*)()) STK_POP,     /* OP-code 5a */
    (int (*)()) STK_POP,     /* OP-code 5b */
    (int (*)()) STK_POP,     /* OP-code 5c */
    (int (*)()) STK_POP,     /* OP-code 5d */
    (int (*)()) STK_POP,     /* OP-code 5e */
    (int (*)()) STK_POP,     /* OP-code 5f */

    (int (*)()) SBYTE,     /* OP-code 60 */
    (int (*)()) SBYTE,     /* OP-code 61 */
    (int (*)()) EA_DBL,    /* OP-code 62 */
    (int (*)()) W_EA_REG,  /* OP-code 63 */
    (int (*)()) SBYTE,     /* OP-code 64 */
    (int (*)()) SBYTE,     /* OP-code 65 */
    (int (*)()) SBYTE,     /* OP-code 66 */
    (int (*)()) SBYTE,     /* OP-code 67 */
    (int (*)()) STK_IW,    /* OP-code 68 */
    (int (*)()) OP_3W,     /* OP-code 69 */
    (int (*)()) STK_IB,    /* OP-code 6a */
    (int (*)()) OP_3B,     /* OP-code 6b */
    (int (*)()) SBYTE,     /* OP-code 6c */
    (int (*)()) SBYTE,     /* OP-code 6d */
    (int (*)()) SBYTE,     /* OP-code 6e */
    (int (*)()) SBYTE,     /* OP-code 6f */

    (int (*)()) JO,        /* OP-code 70 */
    (int (*)()) JNO,       /* OP-code 71 */
    (int (*)()) JB,        /* OP-code 72 */
    (int (*)()) JAE,       /* OP-code 73 */
    (int (*)()) JE,        /* OP-code 74 */
    (int (*)()) JNE,       /* OP-code 75 */
    (int (*)()) JBE,       /* OP-code 76 */
    (int (*)()) JA,        /* OP-code 77 */
    (int (*)()) JS,        /* OP-code 78 */
    (int (*)()) JNS,       /* OP-code 79 */
    (int (*)()) JP,        /* OP-code 7a */
    (int (*)()) JNP,       /* OP-code 7b */
    (int (*)()) JL,        /* OP-code 7c */
    (int (*)()) JGE,       /* OP-code 7d */
    (int (*)()) JLE,       /* OP-code 7e */
    (int (*)()) JG,        /* OP-code 7f */

    (int (*)()) CODE80,    /* OP-code 80 */
    (int (*)()) CODE81,    /* OP-code 81 */
    (int (*)()) CODE80,    /* OP-code 82 */
    (int (*)()) CODE83,    /* OP-code 83 */
    (int (*)()) B_REG_EA,  /* OP-code 84 */
    (int (*)()) W_REG_EA,  /* OP-code 85 */
    (int (*)()) XCHGB,     /* OP-code 86 */
    (int (*)()) XCHGW,     /* OP-code 87 */
    (int (*)()) B_EA_REG,  /* OP-code 88 */
    (int (*)()) W_EA_REG,  /* OP-code 89 */
    (int (*)()) B_REG_EA,  /* OP-code 8a */
    (int (*)()) W_REG_EA,  /* OP-code 8b */
    (int (*)()) MOV7,      /* OP-code 8c */
    (int (*)()) LEA,       /* OP-code 8d */
    (int (*)()) MOV6,      /* OP-code 8e */
    (int (*)()) POP1,      /* OP-code 8f */

    (int (*)()) SBYTE,     /* OP-code 90 */
    (int (*)()) SBYTE,     /* OP-code 91 */
    (int (*)()) SBYTE,     /* OP-code 92 */
    (int (*)()) SBYTE,     /* OP-code 93 */
    (int (*)()) SBYTE,     /* OP-code 94 */
    (int (*)()) SBYTE,     /* OP-code 95 */
    (int (*)()) SBYTE,     /* OP-code 96 */
    (int (*)()) SBYTE,     /* OP-code 97 */
    (int (*)()) SBYTE,     /* OP-code 98 */
    (int (*)()) SBYTE,     /* OP-code 99 */
    (int (*)()) JMP4,      /* OP-code 9a */
    (int (*)()) SBYTE,     /* OP-code 9b */
    (int (*)()) SBYTE,     /* OP-code 9c */
    (int (*)()) SBYTE,     /* OP-code 9d */
    (int (*)()) SBYTE,     /* OP-code 9e */
    (int (*)()) SBYTE,     /* OP-code 9f */

    (int (*)()) MOV4B,     /* OP-code a0 */
    (int (*)()) MOV4W,     /* OP-code a1 */
    (int (*)()) MOV5B,     /* OP-code a2 */
    (int (*)()) MOV5W,     /* OP-code a3 */
    (int (*)()) STRING,    /* OP-code a4 */
    (int (*)()) STRING,    /* OP-code a5 */
    (int (*)()) STRING,    /* OP-code a6 */
    (int (*)()) STRING,    /* OP-code a7 */
    (int (*)()) SB_IB,     /* OP-code a8 */
    (int (*)()) SB_IW,     /* OP-code a9 */
    (int (*)()) STRING,    /* OP-code aa */
    (int (*)()) STRING,    /* OP-code ab */
    (int (*)()) STRING,    /* OP-code ac */
    (int (*)()) STRING,    /* OP-code ad */
    (int (*)()) STRING,    /* OP-code ae */
    (int (*)()) STRING,    /* OP-code af */

    (int (*)()) SB_IB,     /* OP-code b0 */
    (int (*)()) SB_IB,     /* OP-code b1 */
    (int (*)()) SB_IB,     /* OP-code b2 */
    (int (*)()) SB_IB,     /* OP-code b3 */
    (int (*)()) SB_IB,     /* OP-code b4 */
    (int (*)()) SB_IB,     /* OP-code b5 */
    (int (*)()) SB_IB,     /* OP-code b6 */
    (int (*)()) SB_IB,     /* OP-code b7 */
    (int (*)()) SB_IW,     /* OP-code b8 */
    (int (*)()) SB_IW,     /* OP-code b9 */
    (int (*)()) SB_IW,     /* OP-code ba */
    (int (*)()) SB_IW,     /* OP-code bb */
    (int (*)()) SB_IW,     /* OP-code bc */
    (int (*)()) SB_IW,     /* OP-code bd */
    (int (*)()) SB_IW,     /* OP-code be */
    (int (*)()) SB_IW,     /* OP-code bf */

    (int (*)()) CODEC0,    /* OP-code c0 */
    (int (*)()) CODEC1,    /* OP-code c1 */
    (int (*)()) SB_IW,     /* OP-code c2 */
    (int (*)()) SBYTE,     /* OP-code c3 */
    (int (*)()) EA_DBL,    /* OP-code c4 */
    (int (*)()) EA_DBL,    /* OP-code c5 */
    (int (*)()) MOV2B,     /* OP-code c6 */
    (int (*)()) MOV2W,     /* OP-code c7 */
    (int (*)()) SB_IW_IB,  /* OP-code c8 */
    (int (*)()) SBYTE,     /* OP-code c9 */
    (int (*)()) SB_IW,     /* OP-code ca */
    (int (*)()) SBYTE,     /* OP-code cb */
    (int (*)()) SBYTE,     /* OP-code cc */
    (int (*)()) SB_IB,     /* OP-code cd */
    (int (*)()) SBYTE,     /* OP-code ce */
    (int (*)()) SBYTE,     /* OP-code cf */

    (int (*)()) CODED0,    /* OP-code d0 */
    (int (*)()) CODED1,    /* OP-code d1 */
    (int (*)()) CODED2,    /* OP-code d2 */
    (int (*)()) CODED3,    /* OP-code d3 */
    (int (*)()) AAM,       /* OP-code d4 */
    (int (*)()) AAM,       /* OP-code d5 */
    (int (*)()) SB_IB,     /* OP-code d6 */
    (int (*)()) SBYTE,     /* OP-code d7 */
    (int (*)()) CODED8,    /* OP-code d8 */
    (int (*)()) CODED9,    /* OP-code d9 */
    (int (*)()) CODEDA,    /* OP-code da */
    (int (*)()) CODEDB,    /* OP-code db */
    (int (*)()) CODEDC,    /* OP-code dc */
    (int (*)()) CODEDD,    /* OP-code dd */
    (int (*)()) CODEDE,    /* OP-code de */
    (int (*)()) CODEDF,    /* OP-code df */

    (int (*)()) LOOPNZ,    /* OP-code e0 */
    (int (*)()) LOOPE,     /* OP-code e1 */
    (int (*)()) LOOP,      /* OP-code e2 */
    (int (*)()) JCXZ,      /* OP-code e3 */
    (int (*)()) SB_IB,     /* OP-code e4 */
    (int (*)()) SB_IB,     /* OP-code e5 */
    (int (*)()) SB_IB,     /* OP-code e6 */
    (int (*)()) SB_IB,     /* OP-code e7 */
    (int (*)()) JMPD,      /* OP-code e8 */
    (int (*)()) JMPD,      /* OP-code e9 */
    (int (*)()) JMP4,      /* OP-code ea */
    (int (*)()) JMPDS,     /* OP-code eb */
    (int (*)()) SBYTE,     /* OP-code ec */
    (int (*)()) SBYTE,     /* OP-code ed */
    (int (*)()) SBYTE,     /* OP-code ee */
    (int (*)()) SBYTE,     /* OP-code ef */

    (int (*)()) SBYTE,     /* OP-code f0 */
    (int (*)()) SBYTE,     /* OP-code f1 */
    (int (*)()) SBYTE,     /* OP-code f2 */
    (int (*)()) SBYTE,     /* OP-code f3 */
    (int (*)()) SBYTE,     /* OP-code f4 */
    (int (*)()) SBYTE,     /* OP-code f5 */
    (int (*)()) CODEF6,    /* OP-code f6 */
    (int (*)()) CODEF7,    /* OP-code f7 */
    (int (*)()) SBYTE,     /* OP-code f8 */
    (int (*)()) SBYTE,     /* OP-code f9 */
    (int (*)()) SBYTE,     /* OP-code fa */
    (int (*)()) SBYTE,     /* OP-code fb */
    (int (*)()) SBYTE,     /* OP-code fc */
    (int (*)()) SBYTE,     /* OP-code fd */
    (int (*)()) CODEFE,    /* OP-code fe */
    (int (*)()) CODEFF,    /* OP-code ff */
    };

        half_word opcode;
        int did_prefix;

        /*
         * indirect to the opcode handler
         */

        while (nInstr > 0)
        {
           sprintf(out_line,"%04x:%04x                      ",segreg,segoff);
           byte_posn = 10;
           sas_set_buf(opcode_ptr, effective_addr(segreg,segoff));
           SEGMENT = 0;
           nInstr--;
           disp_length = 0;
           op = opcode_ptr;
           opcode = opcode_ptr->OPCODE;

           /* Handle prefix bytes */
           did_prefix = 0;
           while ( opcode == 0xf2 || opcode == 0xf3 ||
                   opcode == 0x26 || opcode == 0x2e ||
                   opcode == 0x36 || opcode == 0x3e )
              {
              if      ( opcode == 0x26 )
                 SEGMENT = 1;
              else if ( opcode == 0x2e )
                 SEGMENT = 2;
              else if ( opcode == 0x36 )
                 SEGMENT = 3;
              else if ( opcode == 0x3e )
                 SEGMENT = 4;

              sbyte
            sas_inc_buf(op,1);
              opcode_ptr = op;
              opcode = opcode_ptr->OPCODE;
              did_prefix = 1;
              }
           if ( !did_prefix )
              strcat(out_line, "    ");

           (*CPUOPS[opcode_ptr->OPCODE])();      /* call opcode function */
        }
        return segoff;
    }

/*****************************************************************/

cpu_addr dasm_op;
reg dasm_pseudo;

LOCAL void get_char_w IFN1(
int, nr_words)  /* number of words of data to dump */
   {
   reg ea,disp;
   MODR_M addr_mode;

   /* EA calculation and logical to physical mapping for
      word instructions (w=1) */

   temp_char[0] = '\0';
   addr_mode.X = op->SECOND_BYTE;

   /* First act on the mod value in the instruction */

   switch ( addr_mode.field.mod )
      {
   case 0:
      if ( addr_mode.field.r_m == 6 )
         {  /* Direct addr */
         ea.byte.low = op->THIRD_BYTE;
         ea.byte.high = op->FOURTH_BYTE;
         place_34
         sprintf(temp_char,"[%04x]",ea.X);
            sas_inc_buf(op,2);
         disp_length = 2;
         goto DFLTDS;
         }
      else
         {
         disp.X = 0;
         sprintf(temp_char, "[%s]",address[addr_mode.field.r_m]);
         }
      break;

   case 1:
      /* one byte displacement in inst. */
      disp.X = (char) op->THIRD_BYTE;
      place_3
            sas_inc_buf(op,1);
      disp_length = 1;
      if ( disp.X == 0 )
         sprintf(temp_char, "[%s]",address[addr_mode.field.r_m]);
      else
        {
        if ((IS8)disp.X < 0)
          sprintf(temp_char,"[%s-%04x]",address[addr_mode.field.r_m], 0-(IS8)disp.X);
        else
          sprintf(temp_char,"[%s+%04x]",address[addr_mode.field.r_m], disp.X);
        }
      break;

   case 2:
      /* two byte displacement in inst. */
      disp.byte.low = op->THIRD_BYTE;
      disp.byte.high = op->FOURTH_BYTE;
      place_34
            sas_inc_buf(op,2);
      disp_length = 2;
      if ( disp.X == 0 )
         sprintf(temp_char, "[%s]",address[addr_mode.field.r_m]);
      else
         sprintf(temp_char,"[%s+%04x]",address[addr_mode.field.r_m], disp.X);
      break;

   case 3:
      /* Register */
      strcpy(temp_char, reg16name[addr_mode.field.r_m]);
      return;
      }

   /* Now act on the r/m (here called r_m) field */

   switch ( addr_mode.field.r_m )
      {
   case 0:   /* Based index addr */
      ea.X = getBX() + getSI() + disp.X;
      goto DFLTDS;
   case 1:   /* Based index addr */
      ea.X = getBX() + getDI() + disp.X;
      goto DFLTDS;
   case 2:   /* Based index addr */
      ea.X = getBP() + getSI() + disp.X;
      goto DFLTSS;
   case 3:   /* Based index addr */
      ea.X = getBP() + getDI() + disp.X;
      goto DFLTSS;
   case 4:   /* Index addr */
      ea.X = getSI() + disp.X;
      goto DFLTDS;
   case 5:   /* Index addr */
      ea.X = getDI() + disp.X;
      goto DFLTDS;
   case 6:   /* Base addr */
      ea.X = getBP() + disp.X;
      goto DFLTSS;
   case 7:   /* Based index addr */
      ea.X = getBX() + disp.X;
      goto DFLTDS;
      }

DFLTDS :    /* Map logical to physical with the DS segment
               register by default */
   {
   switch ( SEGMENT )
      {
   case 0:    /* Default - here DS */
   case 4:    /* Overkill, they overrided DS with DS */
      dasm_op.all = effective_addr(getDS(), ea.X);
      break;

   case 1:    /* ES */
      dasm_op.all = effective_addr(getES(), ea.X);
      break;

   case 2:    /* CS */
      dasm_op.all = effective_addr(getCS(), ea.X);
      break;

   case 3:    /* SS */
      dasm_op.all = effective_addr(getSS(), ea.X);
      break;
      }
   goto ENDEA;
   }

DFLTSS :    /* Map logical to physical with the SS segment
               register by default */
            /* NOTE coded seperately to the DLFTDS case so
               that all default references are found as the first
               item in the switch statement */
   {
   switch ( SEGMENT )
      {
   case 0:    /* Default - here SS */
   case 3:    /* Overkill, they overrided SS with SS */
      dasm_op.all = effective_addr(getSS(), ea.X);
      break;

   case 1:    /* ES */
      dasm_op.all = effective_addr(getES(), ea.X);
      break;

   case 2:    /* CS */
      dasm_op.all = effective_addr(getCS(), ea.X);
      break;

   case 4:    /* DS */
      dasm_op.all = effective_addr(getDS(), ea.X);
      break;
      }
   }

ENDEA :

   /* show data to be accessed */
   while ( nr_words )
      {
      show_word(dasm_op.all);
      dasm_op.all += 2;
      nr_words--;
      }
   return;
   }

/*****************************************************************/

DASMBYTE dasm_pseudo_byte;

LOCAL void get_char_b IFN0()
   {
   reg ea,disp;
   MODR_M addr_mode;

   /* EA calculation and logical to physical mapping for
     byte instructions (w=0) */

   temp_char[0] = '\0';
   addr_mode.X = op->SECOND_BYTE;

   /* First act on the mod value in the instruction */

   switch ( addr_mode.field.mod )
      {
   case 0:
      if ( addr_mode.field.r_m == 6 )
         {  /* Direct addr */
         ea.byte.low = op->THIRD_BYTE;
         ea.byte.high = op->FOURTH_BYTE;
         place_34
         sprintf(temp_char,"[%04x]",ea.X);
            sas_inc_buf(op,2);
         disp_length = 2;
         goto DFLTDS;
         }
      else
         {
         disp.X = 0;
         sprintf(temp_char, "[%s]",address[addr_mode.field.r_m]);
         }
      break;

   case 1:
      /* one byte displacement in inst. */
      disp.X = (char) op->THIRD_BYTE;
      place_3
            sas_inc_buf(op,1);
      disp_length = 1;
      if ( disp.X == 0 )
         sprintf(temp_char, "[%s]",address[addr_mode.field.r_m]);
      else
        {
        if ((IS8)disp.X < 0)
          sprintf(temp_char,"[%s-%04x]",address[addr_mode.field.r_m], 0-(IS8)disp.X);
        else
          sprintf(temp_char,"[%s+%04x]",address[addr_mode.field.r_m], disp.X);
        }
      break;

   case 2:
      /* two byte displacement in inst. */
      disp.byte.low = op->THIRD_BYTE;
      disp.byte.high = op->FOURTH_BYTE;
      place_34
            sas_inc_buf(op,2);
      disp_length = 2;
      if ( disp.X == 0 )
         sprintf(temp_char, "[%s]",address[addr_mode.field.r_m]);
      else
         sprintf(temp_char,"[%s+%04x]",address[addr_mode.field.r_m], disp.X);
      break;

   case 3:
      /* Register */
      strcpy(temp_char, reg8name[addr_mode.field.r_m]);
      return;
      }

   /* Now act on the r/m (here called r_m) field */

   switch ( addr_mode.field.r_m )
      {
   case 0:   /* Based index addr */
      ea.X = getBX() + getSI() + disp.X;
      goto DFLTDS;
   case 1:   /* Based index addr */
      ea.X = getBX() + getDI() + disp.X;
      goto DFLTDS;
   case 2:   /* Based index addr */
      ea.X = getBP() + getSI() + disp.X;
      goto DFLTSS;
   case 3:   /* Based index addr */
      ea.X = getBP() + getDI() + disp.X;
      goto DFLTSS;
   case 4:   /* Index addr */
      ea.X = getSI() + disp.X;
      goto DFLTDS;
   case 5:   /* Index addr */
      ea.X = getDI() + disp.X;
      goto DFLTDS;
   case 6:   /* Base addr */
      ea.X = getBP() + disp.X;
      goto DFLTSS;
   case 7:   /* Based index addr */
      ea.X = getBX() + disp.X;
      goto DFLTDS;
      }

DFLTDS :    /* Map logical to physical with the DS segment
               register by default */
   {
   switch ( SEGMENT )
      {
   case 0:    /* Default - here DS */
      dasm_op.all = effective_addr(getDS(), ea.X);
      break;

   case 1:    /* ES */
      dasm_op.all = effective_addr(getES(), ea.X);
      break;

   case 2:    /* CS */
      dasm_op.all = effective_addr(getCS(), ea.X);
      break;

   case 3:    /* SS */
      dasm_op.all = effective_addr(getSS(), ea.X);
      break;

   case 4:    /* Overkill, they overrided DS with DS */
      dasm_op.all = effective_addr(getDS(), ea.X);
      break;
      }
   goto ENDEA;
   }

DFLTSS :    /* Map logical to physical with the SS segment
               register by default */
            /* NOTE coded seperately to the DLFTDS case so
               that all default references are found as the first
               item in the switch statement */
   {
   switch ( SEGMENT )
      {
   case 0:    /* Default - here SS */
   case 3:    /* Overkill, they overrided SS with SS */
      dasm_op.all = effective_addr(getSS(), ea.X);
      break;

   case 1:    /* ES */
      dasm_op.all = effective_addr(getES(), ea.X);
      break;

   case 2:    /* CS */
      dasm_op.all = effective_addr(getCS(), ea.X);
      break;

   case 4:    /* DS */
      dasm_op.all = effective_addr(getDS(), ea.X);
      break;
      }
   }

ENDEA :

   /* show data to be accessed */
   show_byte(dasm_op.all);
   return;
   }


/*******************************************************************/

LOCAL void place_byte IFN2(int, posn, half_word, value)
{
        out_line[posn] = table[(int)(value & 0xf0) >> 4];
        out_line[posn+1] = table[value & 0xf];
}

/* Dump address and value of a WORD memory operand */

LOCAL void show_word IFN1(sys_addr,address)
   {
   word value;
   char temp[80];

   sas_loadw(address, &value);
   sprintf(temp, " (%06x=%04x)", address, value);
   strcat(temp_char,temp);
   }

/* Dump address and value of a BYTE memory operand */
LOCAL void show_byte IFN1(sys_addr,address)
   {
   half_word value;
   char temp[80];
   int i;

   sas_load(address,&value);
   sprintf(temp, " (%06x=", address);
   strcat(temp_char,temp);
   i = strlen(temp_char);
   temp_char[i] = table[(int)(value & 0xf0) >> 4];
   temp_char[i+1] = table[value & 0xf];
   temp_char[i+2] = '\0';
   strcat(temp_char, ")");
   }

/* Convert EA address to Physical address */
/*  -- where DS is default segment */
LOCAL void form_ds_addr IFN2(word,ea,sys_addr *,phys)
   {
   switch ( SEGMENT )
      {
   case 0:    /* Default - here DS */
   case 4:    /* Overkill, they overrided DS with DS */
      *phys = effective_addr(getDS(), ea);
      break;

   case 1:    /* ES */
      *phys = effective_addr(getES(), ea);
      break;

   case 2:    /* CS */
      *phys = effective_addr(getCS(), ea);
      break;

   case 3:    /* SS */
      *phys = effective_addr(getSS(), ea);
      break;
      }
   }
#endif /* PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\debuggng.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * debugging info
 */

/* SccsID = @(#)debugging.c	1.3 08/10/92 Copyright Insignia Solutions Ltd.*/

#ifndef	PROD

#ifdef	EGG
char	mode_strings[][20] = {
	"EGA_HI_SP",
	"EGA_HI_SP_WR",
	"EGA_MED_SP",
	"EGA_MED_SP_WR",
	"EGA_LO_SP",
	"EGA_LO_SP_WR",
	"EGA_HI",
	"EGA_HI_WR",
	"EGA_MED",
	"EGA_MED_WR",
	"EGA_LO",
	"EGA_LO_WR",
	"EGA_HI_FUN",
	"EGA_MED_FUN",
	"EGA_LO_FUN",
	"EGA_TEXT_40",
	"EGA_TEXT_40_WR",
	"EGA_TEXT_40_SP",
	"EGA_TEXT_40_SP_WR",
	"CGA_TEXT_40",
	"CGA_TEXT_40_WR",
	"CGA_TEXT_40_SP",
	"CGA_TEXT_40_SP_WR",
	"TEXT_40_FUN",
	"EGA_TEXT_80",
	"EGA_TEXT_80_WR",
	"EGA_TEXT_80_SP",
	"EGA_TEXT_80_SP_WR",
	"CGA_TEXT_80",
	"CGA_TEXT_80_WR",
	"CGA_TEXT_80_SP",
	"CGA_TEXT_80_SP_WR",
	"TEXT_80_FUN",
	"CGA_HI",
	"CGA_HI_FUN",
	"CGA_MED",
	"CGA_MED_FUN",
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\pigyoda.c ===
/*[
 *	Name:		pigyoda.c
 *
 *	Author:	William Charnell
 *
 *	Created:	May 1991
 *
 *	Sccs ID:	@(#)pigyoda.c	1.9 06/30/94
 *
 *	Purpose:	This module contains the yoda interface routines for
 *			an application pigger.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

/* Standard Includes */
#include "insignia.h"
#include "host_def.h"

/* System Includes */
#include <stdio.h>
#include <ctype.h>

/* SoftPC Includes */
#include "xt.h"
#include "bios.h"
#include "sas.h"
#include "trace.h"

#ifdef PIG

IMPORT LONG pig_verbose;
IMPORT LONG sync_count, sync_count_target;
IMPORT LONG counting_syncs;
IMPORT LONG vidchecking;

#ifdef ANSI
IMPORT VOID set_flags_ignore(char *);
#else
IMPORT VOID set_flags_ignore();
#endif
IMPORT VOID enable_pig();
IMPORT VOID disable_pig();
IMPORT VOID show_before();
IMPORT VOID show_C_after();
IMPORT VOID show_A_after();
IMPORT VOID show_execed();
IMPORT VOID show_mem();
IMPORT VOID show_pig_stats();
IMPORT VOID watch_mem();
IMPORT VOID test_pig_results();

extern void dump_execed IPT1( FILE *, fptr );

/**/

typedef struct {
	char 		name[20];
	void		(*func)();
	char 		help[100];
} cmdstruct;

/**/

LOCAL LONG quit_pig_yoda;

/* vbls for the 'more' function */
#define LINECOUNT_LIMIT 20
LOCAL SHORT linecount;

LOCAL char temp_str[80];
LOCAL char whitespc[] = { '\t',' ',',','\0'  };
LOCAL char pig_cmd[80], cmd[40], lhs[40], rhs[40],extra[80];

/**/

LOCAL void do_quit()
{
	quit_pig_yoda = TRUE;
}

LOCAL void set_pig_vb(lhs)
char *lhs;
{
	pig_verbose = atoi(lhs);
}

LOCAL void do_zsc()
{
	sync_count = 0;
}

LOCAL void do_bsc(lhs)
char *lhs;
{
	sync_count_target = atoi(lhs);
	counting_syncs = TRUE;
}

LOCAL void do_psc()
{
	fprintf(trace_file,"sync count = %d\n",sync_count);
	if (counting_syncs)
	{
		fprintf(trace_file,"sync count target = %d\n",sync_count_target);
	}
}

LOCAL void do_cst()
{
	counting_syncs = FALSE;
}

LOCAL void do_vid(lhs)
char *lhs;
{
	LONG found = FALSE;

	if (lhs[0] == '\0')
	{
		vidchecking = !vidchecking;
		found = TRUE;
	}
	if (strcmp(lhs,"on")==0)
	{
		vidchecking = TRUE;
		found = TRUE;
	}
	if (strcmp(lhs,"off")==0)
	{
		vidchecking = FALSE;
		found = TRUE;
	}
	if (!found)
		printf("parameter '%s' not understood\n",lhs);
	printf("video checking is now ");
	if (vidchecking)
		printf("ON\n");
	else
		printf("OFF\n");
}

LOCAL void
dump_script IFN1( char *, fname )
{
	FILE *fptr;

	if( fptr = fopen( fname, "w" ))
	{
		dump_execed( fptr );
		fclose( fptr );
	}
	else
	{
		printf( "Couldn't open file %s\n", fname );
	}
}


/* forward decl of help func */

LOCAL void do_pig_help();

cmdstruct	commands[] =
{
{"quit",do_quit,		"			 - return to yoda"},
{"q",do_quit,			"			 - synonym for quit"},
{"c",do_quit,			"			 - synonym for quit"},
{"help",do_pig_help,		"			 - display instructions"},
{"h",do_pig_help,		"			 - synonym for help"},
{"on",enable_pig,		"			 - start pigging"},
{"off",disable_pig,		"			 - stop pigging"},
{"verbose",set_pig_vb,		"	<verbose>	 - set verbose level"},
{"v",set_pig_vb,		"	<verbose>	 - synonyn for verbose"},
{"fignore",set_flags_ignore,	"	<flags>		 - set the flags ignore state"},
{"f",set_flags_ignore,		"	<flags>		 - synonyn for fignore"},
{"zsc",do_zsc,			"			 - zero the sync count"},
{"bsc",do_bsc,			"	<count>		 - break after <count> syncs"},
{"psc",do_psc,			"			 - print current sync count"},
{"sb",show_before,		"			 - show 'before' cpu state"},
{"sca",show_C_after,		"			 - show cpu state after C CPU"},
{"saa",show_A_after,		"			 - show_cpu_state after Asm CPU"},
{"sc",show_execed,		"			 - show code for last sync"},
{"sm",show_mem,			"			 - show mem for last sync"},
{"cst",do_cst,			"			 - clear the sync target number"},
{"vid",do_vid,			"	<on|off>	 - set video checking on or off or toggle state"},
{"smstats",show_pig_stats,	"			 - show stats for pig memory useage"},
{"wmem",watch_mem,		"	<off|start,len>	- watch host memory location(s)"},
{"ds",dump_script,		"	<file name>	- dump iPig script" },
{"test",test_pig_results,	"			- show test failures again" },
{"",do_quit,""}
};

char *helpstr[] =
{
"\n",
"	valid values of  <verbose> are:\n",
"		0		= quiet\n",
"		1		= code stream only\n",
"		2		= memory changes only\n",
"		3(or above)	= full verbose\n",
"\n",
"	valid values of <flags> are:\n",
"		all	= 	ignore all flags\n",
"		none	=	test all flags\n",
"\n",
""
};

/*
 * more
 *
 * This routine controls the display of a large quantity of output, usually
 * the 'help' display.
 */

SHORT more()
{
      if ((linecount++)>LINECOUNT_LIMIT)
      {
            if (trace_file == stdout)
            {
                  fprintf(trace_file,"hit return to continue\n");
                  gets(temp_str);
                  linecount=0;
                  if ((strcmp(temp_str,"q")==0) || (strcmp(temp_str,"quit")==0))
                        return TRUE;
            }
      }
      return FALSE;
}

LOCAL void do_pig_help()
{
      cmdstruct *sptr;
      SHORT i,quithelp;
      
      linecount=0;
      quithelp =FALSE;
      sptr= commands;
      while ((sptr->name[0] != '\0') && !quithelp)
      {
            fprintf(trace_file,"%8s%s\n",sptr->name,sptr->help);
            sptr++;
            quithelp=more();
      }
      i=0;
      while ((*helpstr[i] != '\0') && (!quithelp))
      {
            fprintf(trace_file,helpstr[i++]);
            quithelp=more();
      }

}

getNextToken(posp,buf,dest)
USHORT *posp;
char *buf, *dest;
{
      SHORT len, numopen, numcls, wholetoken, maxlen, cnt;
      char *cptr;

      /* first get rid of any leading whitespace (incl commas) */
      *posp += strspn(&buf[*posp],whitespc);
      
      /* find the length of the next token up to the next white space. */
      /* NB. this may not be the whole token if there is a '(' in it */
      len = strcspn(&buf[*posp],whitespc);

      maxlen = strlen(&buf[*posp]);
      wholetoken = FALSE;
      while (!wholetoken && (len < maxlen))
      {     
            numopen = numcls = 0;
            cptr = &buf[*posp];
            cnt=0;
            while ((*cptr != '\0') && (cnt++ < len))
            {
                  if (*cptr++ == '(')
                        numopen++;
            }
            cptr = &buf[*posp];
            cnt=0;
            while ((*cptr != '\0') && (cnt++ < len))
            {
                  if (*cptr++ == ')')
                        numcls++;
            }
            if (numopen == numcls)
                  wholetoken = TRUE;
            else
            {
                  len += strcspn(&buf[*posp +len],")") + 1;
            }
      }
      strncpy(dest,&buf[*posp],len);
      dest[len] = '\0';
      *posp += len;
}
 
tokenise_pig_cmd(str,cmd,lhs,rhs,rest)
char *str, *cmd, *lhs, *rhs, *rest;
{
	SHORT pos;

	pos = 0;
	getNextToken(&pos,str,cmd);
	getNextToken(&pos,str,lhs);
	getNextToken(&pos,str,rhs);
	strcpy(rest,&str[pos]);
}

LONG searchCommandTable(cmd_table)
cmdstruct *cmd_table;
{
	cmdstruct *sptr;
	void (*func_ptr)();
	LONG found = FALSE;

	sptr = cmd_table;
	while ((sptr->name[0])!='\0')
	{
		if (strcmp(cmd,sptr->name)==0)
		{
			func_ptr=sptr->func;
			(*func_ptr)(lhs, rhs, extra);
			found = TRUE;
			break;
		}
		sptr++;
	}
	return (found);
}

void pig_yoda()
{

	quit_pig_yoda = FALSE;

	while (!quit_pig_yoda)
	{
		printf("PIG> ");
		fflush(stdout);
		gets(pig_cmd);
		tokenise_pig_cmd(pig_cmd,cmd,lhs,rhs,extra);
		if (!searchCommandTable(&commands[0]))
		{
			printf("command '%s' not found\n",cmd);
			printf("type 'h' or 'help' for a list of commands\n");
		}
	}

}

#endif /* PIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\ega_dump.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

 	(see /vpc/1.0/Master/src/hdrREADME for help)

REVISION HISTORY	:
First version		: 22 Aug 1988, J.Roper`

SOURCE FILE NAME	: ega_dump.c

PURPOSE			: dump the EGA global varaibles stored in structures in an intelligent manner

SccsID = "@(#)ega_dump.c	1.12 3/9/94 Copyright Insignia Solutions Ltd."
		
[3.1 INTERMODULE IMPORTS]						*/


/* [3.1.1 #INCLUDES]                                                    */


#include	<stdio.h>
#include	TypesH
#include	FCntlH

#ifdef	EGG
#ifndef	PROD

#include	"xt.h"
#include	"sas.h"
#include	"ios.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"debug.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"gfx_upd.h"
#include	"egagraph.h"

/* [3.1.2 DECLARATIONS]                                                 */

extern	char	*host_find_symb_name();

/*
 * =======================================================================
 * Local static functions
 * =======================================================================
 */
#ifdef	ANSI
static	void	dump_graph_display_state(void);
#else
static	void	dump_graph_display_state();
#endif	/* ANSI */

#define	get_boolean_value(x)		(x) ? "YES" : "NO"

#define	dump_graph_hex(name)		printf("name = %x ", EGA_GRAPH.name)
#define	dump_graph_int(name)		printf("name = %d ", EGA_GRAPH.name)
#define	dump_graph_bool(name)		printf("name = %s ", get_boolean_value(EGA_GRAPH.name))
#define	dump_display_bool(name)		printf("name = %s ", get_boolean_value(PCDisplay.name))
#define	dump_graph_9_bits(name)		printf("name = %d ", EGA_GRAPH.name.as_word)
#define	dump_graph_ptrs(name)		if ( EGA_GRAPH.name == NULL ) \
						printf("name = null "); \
					else { \
						host_find_symb_name(EGA_GRAPH.name,sym_name);\
						printf("name = %s " sym_name ); \
					}
#define	dump_graph_index_ptr(name,i)	if ( EGA_GRAPH.name[i] == NULL ) {\
						printf("name[%d] = null ", i); \
					} \
					else {\
						host_find_symb_name(EGA_GRAPH.name[i],sym_name);\
						printf("name[%d] = %s ", i, sym_name); \
					}

#define	dump_graph_index_int(name,i)	if ( EGA_GRAPH.name[i] == NULL ) {\
						printf("name[%d] = null ", i); \
					} \
					else {\
						printf("name[%d] = %d ", i, EGA_GRAPH.name[i] ); \
					}

#define	dump_graph_int2(n1,n2)		dump_graph_int(n1);dump_graph_int(n2);newline
#define	dump_graph_bool2(n1,n2)		dump_graph_bool(n1);dump_graph_bool(n2);newline
#define	dump_graph_int3(n1,n2,n3)	dump_graph_int(n1);dump_graph_int(n2);dump_graph_int(n3);newline
#define	dump_graph_int4(n1,n2,n3,n4)	dump_graph_int(n1);dump_graph_int(n2);dump_graph_int(n3);dump_graph_int(n4);newline
#define	dump_graph_9_bits2(n1,n2)	dump_graph_9_bits(n1);dump_graph_9_bits(n2);newline

void	dump_EGA_GRAPH()
{
#ifndef NEC_98
	/* char sym_name[80]; */

	dump_display_bool(mode_change_required);
	dump_graph_int(actual_offset_per_line);
	dump_graph_9_bits(screen_split);
	dump_graph_int(colours_used);
	dump_graph_hex(plane_mask);
	newline;
	dump_graph_bool2(intensity,attrib_font_select);
/*
	these take too long (linear search of symbol table)

	dump_graph_index_ptr(regen_ptr,0);
	dump_graph_index_ptr(regen_ptr,1);
	dump_graph_index_ptr(regen_ptr,2);
	dump_graph_index_ptr(regen_ptr,3);
*/
	dump_graph_index_int(regen_ptr,0);
	dump_graph_index_int(regen_ptr,1);
	dump_graph_index_int(regen_ptr,2);
	dump_graph_index_int(regen_ptr,3);
	newline;
	dump_graph_display_state();
#endif // !NEC_98
}

#define	dump_graph_disp_bool(name)	printf("name = %s ", get_boolean_value(EGA_GRAPH.display_state.as_bfld.name) )

static	void	dump_graph_display_state()
{
	dump_graph_disp_bool(cga_mem_bank);
	dump_graph_disp_bool(graph_shift_reg);
	dump_graph_disp_bool(chained);
	newline;
	dump_graph_disp_bool(double_pix_wid);
	dump_graph_disp_bool(ht_of_200_scan_lines);
	dump_graph_disp_bool(split_screen_used);
	dump_graph_disp_bool(screen_can_wrap);
	newline;
}

#if defined(NEC_98)
#define dump_disp_hex(name)             printf("name = %x ", NEC98Display.name) 
#define dump_disp_int(name)             printf("name = %d ", NEC98Display.name) 
#define dump_disp_bool(name)            printf("name = %s ", get_boolean_value(NEC98Display.name)) 
#define dump_disp_9_bits(name)          printf("name = %d ", NEC98Display.name.as_word) 
#define dump_disp_ptrs(name)            if ( NEC98Display.name == NULL ) \
                                                printf("name = null "); \
                                        else { \
                                                host_find_symb_name(NEC98Display.name,sym_name);\
                                                printf("name = %s ", sym_name ); \
                                        }                       
#define dump_disp_index_ptr(name,i)     if ( NEC98Display.name[i] == NULL ) {\
                                                printf("name[%d] = null ", i); \
                                        } \
                                        else {\
                                                host_find_symb_name(NEC98Display.name[i],sym_name);\
                                                printf("name[%d] = %s ", i, sym_name); \
                                        }                       
#else  // !NEC_98

#define	dump_disp_hex(name)		printf("name = %x ", PCDisplay.name)
#define	dump_disp_int(name)		printf("name = %d ", PCDisplay.name)
#define	dump_disp_bool(name)		printf("name = %s ", get_boolean_value(PCDisplay.name))
#define	dump_disp_9_bits(name)		printf("name = %d ", PCDisplay.name.as_word)
#define	dump_disp_ptrs(name)		if ( PCDisplay.name == NULL ) \
						printf("name = null "); \
					else { \
						host_find_symb_name(PCDisplay.name,sym_name);\
						printf("name = %s ", sym_name ); \
					}
#define	dump_disp_index_ptr(name,i)	if ( PCDisplay.name[i] == NULL ) {\
						printf("name[%d] = null ", i); \
					} \
					else {\
						host_find_symb_name(PCDisplay.name[i],sym_name);\
						printf("name[%d] = %s ", i, sym_name); \
					}
#endif // !NEC_98

#define	dump_disp_int2(n1,n2)		dump_disp_int(n1);dump_disp_int(n2);newline
#define	dump_disp_int3(n1,n2,n3)	dump_disp_int(n1);dump_disp_int(n2);dump_disp_int(n3);newline
#define	dump_disp_int4(n1,n2,n3,n4)	dump_disp_int(n1);dump_disp_int(n2);dump_disp_int(n3);dump_disp_int(n4);newline

void	dump_Display	IFN0()
{
/*	char	sym_name[80];*/

	dump_disp_int4(bytes_per_line,chars_per_line,char_width,char_height);
	dump_disp_int4(pix_width,pix_char_width,pc_pix_height,host_pix_height);
	dump_disp_hex(screen_start);
	dump_disp_9_bits(screen_height);
	dump_disp_int2(screen_length,display_disabled);
	dump_disp_int4(cursor_start,cursor_height,cursor_start1,cursor_height1);
	dump_disp_int3(cur_x,cur_y,offset_per_line);
/*
	this takes too long, so print out number
	dump_disp_ptrs(screen_ptr);
*/
	dump_disp_int(screen_ptr);
	newline;
}

void	dump_EGA_CPU	IFN0()
{
#ifndef NEC_98
	/* table to output planes nicely. */

	static char bin_table[][5] = {
	"0000", "0001", "0010", "0011",
	"0100", "0101", "0110", "0111",
	"1000", "1001", "1010", "1011",
	"1100", "1101", "1110", "1111",
	};

	printf("rame=%d wmode=%d rot=%d s/r=%s s/re=%s ",
		EGA_CPU.ram_enabled,EGA_CPU.write_mode,
		getVideorotate(),bin_table[EGA_CPU.set_reset],
		bin_table[EGA_CPU.sr_enable]);
	printf("sr=%d func=%d bp=%d pe=%d\n",
		write_state.sr,write_state.func,write_state.bp,
		write_state.pe);
	printf("EGA memory is %#x->%#x plane offset is %#x\n",
		gvi_pc_low_regen,gvi_pc_high_regen,getVideowplane());
	printf("set/reset value: %#x sr_nmask: %#x sr_masked_val: %#x\n",
		EGA_CPU.sr_value, getVideosr_nmask(), getVideosr_masked_val());
	printf("bit_prot=%#x,data_and=%#x,data_xor=%#x,latch_xor=%#x\n",
		getVideobit_prot_mask(),getVideodata_and_mask(),
		getVideodata_xor_mask(),getVideolatch_xor_mask());

	printf("handlers are of type %d\n", EGA_CPU.saved_mode_chain);
#endif // !NEC_98
}

static	char	names[4][11] = {"plane0.dat",
				"plane1.dat",
				"plane2.dat",
				"plane3.dat"
			      };
static	byte	*pl[4];

void	dump_ega_planes()
{
	assert0(NO, "dump_ega_planes unimplemented for 3.0\n");
}

void	read_ega_planes()
{
	assert0(NO, "read_ega_planes unimplemented for 3.0\n");
}

#endif	/* PROD */
#endif	/* EGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\btrace.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Buffer Trace function
 *
 * Description	: This function will output a trace to the trace buffer
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)btrace.c	1.10 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_ERROR.seg"
#endif



/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#include StringH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "trace.h"

#ifndef PROD
IMPORT word dasm IPT5(char *, i_output_stream, word, i_atomicsegover,
	word, i_segreg, word, i_segoff, int, i_nInstr);
#define TRACE_BUF_SIZE 16384
static char trace_buffer[TRACE_BUF_SIZE];
static int trace_pointer = 0;

void print_back_trace()
{
	printf("%s", trace_buffer);
}

void file_back_trace( filename )
char    *filename ;
{
        FILE *fp ;

        if ( (fp = fopen( filename, "w" )) == NULL ) {
            printf( "cannot open file %s\n", filename );
        }
        else {
            fprintf( fp, "%s\n", trace_buffer );
            fprintf( fp, "\n" );        /* flush into file */
            fclose( fp );
        }
}

#ifdef ANSI
void put_in_trace_buffer (char str[])
#else
void put_in_trace_buffer (str)
char str[];
#endif
{
int i,j;

	while ((trace_pointer+strlen(str)) >= TRACE_BUF_SIZE) {
		i=0; j=0;
		while(i < TRACE_BUF_SIZE && j < 10) {
			if (trace_buffer[i] == '\n') j++;
			i++;
		}
		memcpy(&trace_buffer[0], &trace_buffer[i], TRACE_BUF_SIZE - i);
		trace_pointer = trace_pointer - i;
	}
	memcpy(&trace_buffer[trace_pointer], &str[0], strlen(str) + 1);
	trace_pointer += strlen(str);
}


void btrace(dump_info)
int  dump_info;
{
    word temp;
    char trace_file[512];
#ifdef DELTA
    extern      host_addr       last_destination_address ;
    host_addr    last_dest;
#endif /* DELTA */

    sys_addr i;
    /*
     * Dump the error message
     */


    /*
     * Now dump what has been asked for
     */

    if (dump_info & DUMP_CSIP) {
			sprintf(trace_file,"%-04x:%-04x ", getCS(), getIP() );
			put_in_trace_buffer(trace_file);
    }

    if (dump_info & DUMP_REG)
    {
	sprintf(trace_file,"AX:%-04x BX:%-04x CX:%-04x DX:%-04x SP:%-04x BP:%-04x SI:%-04x DI:%-04x ",
		       getAX(), getBX(), getCX(), getDX(),
		       getSP(), getBP(), getSI(), getDI());
	put_in_trace_buffer(trace_file);
	sprintf(trace_file,"DS:%-04x ES:%-04x SS:%-04x CS:%-04x IP:%-04x\n",
		getDS(), getES(), getSS(), getCS(), getIP());
	put_in_trace_buffer(trace_file);
    }


    if (dump_info & DUMP_INST)
    {

#ifdef DELTA
      last_dest = get_byte_addr(last_destination_address);
      if ( dump_info & LAST_DEST )
      {
        sprintf( trace_file, "\nlast_destination_address was %d (%x)\n",
                                                last_destination_address, last_dest );
        put_in_trace_buffer(trace_file);
      }
#endif /* DELTA */

      dasm(trace_file, 0, getCS(), getIP(), 1);
      put_in_trace_buffer(trace_file);
    }

    if (dump_info & DUMP_CODE)
    {
	sprintf(trace_file,"Code dump: Last 16 words\n\n");
	put_in_trace_buffer(trace_file);
 	i = getIP() - 31;
   	sprintf(trace_file, "%x:  ", i);
	put_in_trace_buffer(trace_file);
	for(; i < (sys_addr)(getIP() - 15); i+=2)
        {
	    sas_loadw(effective_addr(getCS(), i), &temp);
	    sprintf(trace_file, "%-6x", temp);
	    put_in_trace_buffer(trace_file);
	}
   	sprintf(trace_file, "\n%x:  ", i);
        put_in_trace_buffer(trace_file);
	for(; i <= getIP(); i+=2)
	{
	    sas_loadw(effective_addr(getCS(), i), &temp);
	    sprintf(trace_file, "%-6x", temp);
	    put_in_trace_buffer(trace_file);
	}
	sprintf(trace_file,"\n\n");
	put_in_trace_buffer(trace_file);
    }


   if (dump_info & DUMP_FLAGS)
      {
      sprintf(trace_file,
      "CF:%-2dPF:%-2dAF:%-2dZF:%-2dSF:%-2dTF:%-2dIF:%-2dDF:%-2dOF:%-2d\n",
      getCF(),
      getPF(),
      getAF(),
      getZF(),
      getSF(),
      getTF(),
      getIF(),
      getDF(),
      getOF());
      put_in_trace_buffer(trace_file);
      }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\dasm386\decode.c ===
/*[

decode.c

LOCAL CHAR SccsID[]="@(#)decode.c	1.9 10/11/94 Copyright Insignia Solutions Ltd.";

Normal operation is to decode as per a 486 processor. By setting a
define 'CPU_286' it can be made to decode as per a 286/287 processor.

Decode Intel instruction stream.
--------------------------------

Intel instructions are composed as follows:-

    =================================================================
    |Inst  |Address|Operand|Segment|Opcode|Modrm|SIB| Disp  | Immed |
    |Prefix|Size   |Size   |Prefix |      |     |   |       |       |
    |      |Prefix |Prefix |       |      |     |   |       |       |
    =================================================================
    | 0,1  |  0,1  |  0,1  |  0,1  | 1,2  | 0,1 |0,1|0,1,2,4|0,1,2,4|
    =================================================================

Inst Prefix         = F0,F2,F3(,F1).
Address Size Prefix = 67.
Operand Size Prefix = 66.
Segment Prefix      = 26,2E,36,3E,64,65.

The maximum size of an instruction is 15 bytes.

Dis-assembly entails finding the four main parts of an instruction:-

   1) The prefix bytes.

   2) The opcode bytes.

   3) The addressing bytes.

   4) The immediate data.


Each Intel instruction is considered here to be of the form:-

	    INST arg1,arg2

In some instructions arg1 and arg2 may be null, in other instructions
arg2 may be null, and in yet other instructions arg2 may hold an
encoding of Intel arguments arg2,arg3.

Information on each Intel instruction is held in an OPCODE_RECORD, this
has three fields, the instruction identifier, the arg1 type and the arg2
type. Further each Intel instruction is categorised by 'type', this type
indicates how the arguments are to be treated (as src or dest) and this
'type' is used to produce the standard decoded form:-

	    INST arg1,arg2,arg3

with an indication for each argument of its read/write (ie src/dest)
addressability.

The Intel instructions fall into the following 'types':-

	 ---------------------------------------------------
	 | Id  | Intel assembler      | arg1 | arg2 | arg3 |
	 |-----|----------------------|------|------|------|
	 | T0  | INST                 |  --  |  --  |  --  |
	 | T1  | INST dst/src         |  rw  |  --  |  --  |
	 | T2  | INST src             |  r-  |  --  |  --  |
	 | T3  | INST dst             |  -w  |  --  |  --  |
	 | T4  | INST dst,src         |  -w  |  r-  |  --  |
	 | T5  | INST dst/src,src     |  rw  |  r-  |  --  |
	 | T6  | INST src,src         |  r-  |  r-  |  --  |
	 | T7  | INST dst,src,src     |  -w  |  r-  |  r-  |
	 | T8  | INST dst/src,dst/src |  rw  |  rw  |  --  |
	 | T9  | INST dst/src,src,src |  rw  |  r-  |  r-  |
	 ---------------------------------------------------
	 | TA  | INST dst,addr        |  -w  |  --  |  --  |
	 | TB  | INST addr            |  --  |  --  |  --  |
	 ---------------------------------------------------

	 TA is actually mapped to T4, - so addr acts like a src.
	 TB is actually mapped to T2, - so addr acts like a src.

The instruction identifier can be of two types, either a pseudo-
instruction, (denoted as P_) or an Intel instruction (denoted as I_).
Pseudo-instructions imply more work is required to completely decode the
Intel instruction. There are two groups of pseudo-instructions, Intel
prefix bytes which appear before the Opcode proper, and 'rules' which
encode how to further decode the Intel instruction. All rules are
indicated as P_RULEx; note P_RULE1 does not appear, its the obvious rule
of accessing the data table.

]*/

#include "insignia.h"
#include "host_def.h"

#include "xt.h"
#include "decode.h"
#include "d_inst.h"	/* All possible types of decoded instruction */
#include "d_oper.h"	/* All possible types of decoded operands */

#define GET_INST_BYTE(f, z)		(f(z++))
#define SKIP_INST_BYTE(z)		(z++)
#define INST_BYTE(f, z)			(f(z))
#define INST_OFFSET_BYTE(f, z,o)	(f((z)+(o)))
#define NOTE_INST_LOCN(z)		(z)
#define CALC_INST_LEN(z,l)		((z)-(l))

/*
   The Intel instruction 'types'.
 */
#define T0 (UTINY)0
#define T1 (UTINY)1
#define T2 (UTINY)2
#define T3 (UTINY)3
#define T4 (UTINY)4
#define T5 (UTINY)5
#define T6 (UTINY)6
#define T7 (UTINY)7
#define T8 (UTINY)8
#define T9 (UTINY)9
#define TA T4
#define TB T0

LOCAL UTINY aa_rules[10][3] =
   {
   /* arg1, arg2 , arg3 */
   { AA_  , AA_  , AA_  }, /* T0 */
   { AA_RW, AA_  , AA_  }, /* T1 */
   { AA_R , AA_  , AA_  }, /* T2 */
   { AA_W , AA_  , AA_  }, /* T3 */
   { AA_W , AA_R , AA_  }, /* T4 */
   { AA_RW, AA_R , AA_  }, /* T5 */
   { AA_R , AA_R , AA_  }, /* T6 */
   { AA_W , AA_R , AA_R }, /* T7 */
   { AA_RW, AA_RW, AA_  }, /* T8 */
   { AA_RW, AA_R , AA_R }  /* T9 */
   };

/*
   The pseudo instructions (rules).
 */
#define P_RULE2		(USHORT)400
#define P_RULE3		(USHORT)401
#define P_RULE4		(USHORT)402
#define P_RULE5		(USHORT)403
#define P_RULE6		(USHORT)404
#define P_RULE7		(USHORT)405
#define P_RULE8		(USHORT)406

#define MAX_PSEUDO P_RULE8

/*
   Intel Prefix bytes.
 */
#define P_AO		(USHORT)407
#define P_CS		(USHORT)408
#define P_DS		(USHORT)409
#define P_ES		(USHORT)410
#define P_FS		(USHORT)411
#define P_GS		(USHORT)412
#define P_LOCK		(USHORT)413
#define P_OO		(USHORT)414
#define P_REPE		(USHORT)415
#define P_REPNE		(USHORT)416
#define P_SS		(USHORT)417
#define P_F1		(USHORT)418

/*
   Intel operand types.
   --------------------

   See "d_oper.h" for explanation of identifier format.

   Locally known formats (the meaning may be different to the external
   format):-

      A Direct address (seg:offset) in instruction stream.

      B Stack (Block?) reference.

      E modR/M byte selects general register or memory address.

      F A fixed register is implied within the opcode.

      G The 'reg' field of the modR/M byte selects a general register.

      H The low 3 bits (2-0) of the last opcode byte select a general
	register.

      I The instruction contains immediate data.

      J The instruction contains a relative offset.

      L The 'reg' field of the modR/M byte selects a segment register.
	But CS is not a legal value.

      M The modR/M byte may only refer to memory.

      N The 'reg' field of the modR/M byte selects a segment register.

      O Offset of memory operand directly encoded in instruction.

      P The 2 bits (4-3) of the last opcode byte select a segment
	register.

      Q The 3 bits (5-3) of the last opcode byte select a segment
	register.

      R The 'mode' and 'r/m' fields of the modR/M byte must select a
	general register.

      T The operand is a test register.

      X String source operand.

      Y String destination operand.

      Z Implicit addressing form of 'xlat' instruction.

   Locally known types (additional to the external types):-

      x byte sign extended to word.

      y byte sign extended to double word.

      0 fixed value of zero.

      1 fixed value of one.

      3 fixed value of three.

      t co-processor stack top.

      q push onto co-processor stack top(queue?).

      n co-processor register relative to stack top('ndex?).


 */
#define A_Hb	(UTINY)  50
#define A_Hw	(UTINY)  51
#define A_Hd	(UTINY)  52
#define A_Gb	(UTINY)  53
#define A_Gw	(UTINY)  54
#define A_Gd	(UTINY)  55
#define A_Pw	(UTINY)  56
#define A_Qw	(UTINY)  57
#define A_Nw	(UTINY)  58
#define A_Fal	(UTINY)  59
#define A_Fcl	(UTINY)  60
#define A_Fax	(UTINY)  61
#define A_Fdx	(UTINY)  62
#define A_Feax	(UTINY)  63
#define A_Eb	(UTINY)  64
#define A_Ew	(UTINY)  65
#define A_Ed	(UTINY)  66
#define A_Ib	(UTINY)  67
#define A_Iw	(UTINY)  68
#define A_Id	(UTINY)  69
#define A_Iy	(UTINY)  70
#define A_Ix	(UTINY)  71
#define A_I0	(UTINY)  72
#define A_I1	(UTINY)  73
#define A_I3	(UTINY)  74
#define A_Jb	(UTINY)  75
#define A_Jw	(UTINY)  76
#define A_Jd	(UTINY)  77
#define A_Ob	(UTINY)  78
#define A_Ow	(UTINY)  79
#define A_Od	(UTINY)  80
#define A_Z	(UTINY)  81
#define A_Aw	(UTINY)  82
#define A_Ad	(UTINY)  83
#define A_Vt	(UTINY)  84
#define A_Vq	(UTINY)  85
#define A_Vn	(UTINY)  86
#define A_V1	(UTINY)  87
#define A_Xb	(UTINY)  88
#define A_Xw	(UTINY)  89
#define A_Xd	(UTINY)  90
#define A_Yb	(UTINY)  91
#define A_Yw	(UTINY)  92
#define A_Yd	(UTINY)  93
#define A_Lw	(UTINY)  94

#define A_Ex	(UTINY)  95
#define A_Fcx	(UTINY)  96
#define A_Fecx	(UTINY)  97
#define A_Iv	(UTINY)  98
#define A_Iz	(UTINY)  99

#define A_Jb2	(UTINY)  100

#define MAX_NORMAL A_Jb2

/*
   Operand rules to encode two arguments in one table entry.
 */
#define A_EwIw	(UTINY) 100
#define A_EwIx	(UTINY) 101
#define A_EdId	(UTINY) 102
#define A_EdIy	(UTINY) 103
#define A_GwCL	(UTINY) 104
#define A_GwIb	(UTINY) 105
#define A_GdCL	(UTINY) 106
#define A_GdIb	(UTINY) 107
#define A_EwIz	(UTINY) 108
#define A_EwIv	(UTINY) 109

#define A_Bop3b	(UTINY) 110

typedef struct
   {
   USHORT inst_id;
   UTINY  arg1_type;
   UTINY  arg2_type;
   } OPCODE_RECORD;

typedef struct
   {
   UTINY inst_type;
   OPCODE_RECORD record[2];
   } OPCODE_INFO;

/*
   A couple of macros to make filling in the opcode information a
   bit easier. One sets up duplicate entries for those instructions
   which are independant of Operand Size. The other is a quick form
   for bad opcodes.
 */
#define OI(x,y,z) {{x,y,z},{x,y,z}}

#define BAD_OPCODE T0,OI(I_ZBADOP   , A_    , A_    )

/*
   Information for each Intel instruction.
 */
LOCAL OPCODE_INFO opcode_info[] =
  {
   /* 00 00     */{T5,OI(I_ADD8     , A_Eb  , A_Gb  )},
   /* 01 01     */{T5, {{I_ADD16    , A_Ew  , A_Gw  },{I_ADD32    , A_Ed  , A_Gd  }}},
   /* 02 02     */{T5,OI(I_ADD8     , A_Gb  , A_Eb  )},
   /* 03 03     */{T5, {{I_ADD16    , A_Gw  , A_Ew  },{I_ADD32    , A_Gd  , A_Ed  }}},
   /* 04 04     */{T5,OI(I_ADD8     , A_Fal , A_Ib  )},
   /* 05 05     */{T5, {{I_ADD16    , A_Fax , A_Iw  },{I_ADD32    , A_Feax, A_Id  }}},
   /* 06 06     */{T2,OI(I_PUSH16   , A_Pw  , A_    )},
   /* 07 07     */{T3,OI(I_POP_SR   , A_Pw  , A_    )},
   /* 08 08     */{T5,OI(I_OR8      , A_Eb  , A_Gb  )},
   /* 09 09     */{T5, {{I_OR16     , A_Ew  , A_Gw  },{I_OR32     , A_Ed  , A_Gd  }}},
   /* 0a 0a     */{T5,OI(I_OR8      , A_Gb  , A_Eb  )},
   /* 0b 0b     */{T5, {{I_OR16     , A_Gw  , A_Ew  },{I_OR32     , A_Gd  , A_Ed  }}},
   /* 0c 0c     */{T5,OI(I_OR8      , A_Fal , A_Ib  )},
   /* 0d 0d     */{T5, {{I_OR16     , A_Fax , A_Iw  },{I_OR32     , A_Feax, A_Id  }}},
   /* 0e 0e     */{T2,OI(I_PUSH16   , A_Pw  , A_    )},
   /* 0f 0f     */{T0,OI(P_RULE3    , 0x1   , 0x00  )},

   /* 10 10     */{T5,OI(I_ADC8     , A_Eb  , A_Gb  )},
   /* 11 11     */{T5, {{I_ADC16    , A_Ew  , A_Gw  },{I_ADC32    , A_Ed  , A_Gd  }}},
   /* 12 12     */{T5,OI(I_ADC8     , A_Gb  , A_Eb  )},
   /* 13 13     */{T5, {{I_ADC16    , A_Gw  , A_Ew  },{I_ADC32    , A_Gd  , A_Ed  }}},
   /* 14 14     */{T5,OI(I_ADC8     , A_Fal , A_Ib  )},
   /* 15 15     */{T5, {{I_ADC16    , A_Fax , A_Iw  },{I_ADC32    , A_Feax, A_Id  }}},
   /* 16 16     */{T2,OI(I_PUSH16   , A_Pw  , A_    )},
   /* 17 17     */{T3,OI(I_POP_SR   , A_Pw  , A_    )},
   /* 18 18     */{T5,OI(I_SBB8     , A_Eb  , A_Gb  )},
   /* 19 19     */{T5, {{I_SBB16    , A_Ew  , A_Gw  },{I_SBB32    , A_Ed  , A_Gd  }}},
   /* 1a 1a     */{T5,OI(I_SBB8     , A_Gb  , A_Eb  )},
   /* 1b 1b     */{T5, {{I_SBB16    , A_Gw  , A_Ew  },{I_SBB32    , A_Gd  , A_Ed  }}},
   /* 1c 1c     */{T5,OI(I_SBB8     , A_Fal , A_Ib  )},
   /* 1d 1d     */{T5, {{I_SBB16    , A_Fax , A_Iw  },{I_SBB32    , A_Feax, A_Id  }}},
   /* 1e 1e     */{T2,OI(I_PUSH16   , A_Pw  , A_    )},
   /* 1f 1f     */{T3,OI(I_POP_SR   , A_Pw  , A_    )},

   /* 20 20     */{T5,OI(I_AND8     , A_Eb  , A_Gb  )},
   /* 21 21     */{T5, {{I_AND16    , A_Ew  , A_Gw  },{I_AND32    , A_Ed  , A_Gd  }}},
   /* 22 22     */{T5,OI(I_AND8     , A_Gb  , A_Eb  )},
   /* 23 23     */{T5, {{I_AND16    , A_Gw  , A_Ew  },{I_AND32    , A_Gd  , A_Ed  }}},
   /* 24 24     */{T5,OI(I_AND8     , A_Fal , A_Ib  )},
   /* 25 25     */{T5, {{I_AND16    , A_Fax , A_Iw  },{I_AND32    , A_Feax, A_Id  }}},
   /* 26 26     */{T0,OI(P_ES       , A_    , A_    )},
   /* 27 27     */{T0,OI(I_DAA      , A_    , A_    )},
   /* 28 28     */{T5,OI(I_SUB8     , A_Eb  , A_Gb  )},
   /* 29 29     */{T5, {{I_SUB16    , A_Ew  , A_Gw  },{I_SUB32    , A_Ed  , A_Gd  }}},
   /* 2a 2a     */{T5,OI(I_SUB8     , A_Gb  , A_Eb  )},
   /* 2b 2b     */{T5, {{I_SUB16    , A_Gw  , A_Ew  },{I_SUB32    , A_Gd  , A_Ed  }}},
   /* 2c 2c     */{T5,OI(I_SUB8     , A_Fal , A_Ib  )},
   /* 2d 2d     */{T5, {{I_SUB16    , A_Fax , A_Iw  },{I_SUB32    , A_Feax, A_Id  }}},
   /* 2e 2e     */{T0,OI(P_CS       , A_    , A_    )},
   /* 2f 2f     */{T0,OI(I_DAS      , A_    , A_    )},

   /* 30 30     */{T5,OI(I_XOR8     , A_Eb  , A_Gb  )},
   /* 31 31     */{T5, {{I_XOR16    , A_Ew  , A_Gw  },{I_XOR32    , A_Ed  , A_Gd  }}},
   /* 32 32     */{T5,OI(I_XOR8     , A_Gb  , A_Eb  )},
   /* 33 33     */{T5, {{I_XOR16    , A_Gw  , A_Ew  },{I_XOR32    , A_Gd  , A_Ed  }}},
   /* 34 34     */{T5,OI(I_XOR8     , A_Fal , A_Ib  )},
   /* 35 35     */{T5, {{I_XOR16    , A_Fax , A_Iw  },{I_XOR32    , A_Feax, A_Id  }}},
   /* 36 36     */{T0,OI(P_SS       , A_    , A_    )},
   /* 37 37     */{T0,OI(I_AAA      , A_    , A_    )},
   /* 38 38     */{T6,OI(I_CMP8     , A_Eb  , A_Gb  )},
   /* 39 39     */{T6, {{I_CMP16    , A_Ew  , A_Gw  },{I_CMP32    , A_Ed  , A_Gd  }}},
   /* 3a 3a     */{T6,OI(I_CMP8     , A_Gb  , A_Eb  )},
   /* 3b 3b     */{T6, {{I_CMP16    , A_Gw  , A_Ew  },{I_CMP32    , A_Gd  , A_Ed  }}},
   /* 3c 3c     */{T6,OI(I_CMP8     , A_Fal , A_Ib  )},
   /* 3d 3d     */{T6, {{I_CMP16    , A_Fax , A_Iw  },{I_CMP32    , A_Feax, A_Id  }}},
   /* 3e 3e     */{T0,OI(P_DS       , A_    , A_    )},
   /* 3f 3f     */{T0,OI(I_AAS      , A_    , A_    )},

   /* 40 40     */{T1, {{I_INC16    , A_Hw  , A_    },{I_INC32    , A_Hd  , A_    }}},
   /* 41 41     */{T1, {{I_INC16    , A_Hw  , A_    },{I_INC32    , A_Hd  , A_    }}},
   /* 42 42     */{T1, {{I_INC16    , A_Hw  , A_    },{I_INC32    , A_Hd  , A_    }}},
   /* 43 43     */{T1, {{I_INC16    , A_Hw  , A_    },{I_INC32    , A_Hd  , A_    }}},
   /* 44 44     */{T1, {{I_INC16    , A_Hw  , A_    },{I_INC32    , A_Hd  , A_    }}},
   /* 45 45     */{T1, {{I_INC16    , A_Hw  , A_    },{I_INC32    , A_Hd  , A_    }}},
   /* 46 46     */{T1, {{I_INC16    , A_Hw  , A_    },{I_INC32    , A_Hd  , A_    }}},
   /* 47 47     */{T1, {{I_INC16    , A_Hw  , A_    },{I_INC32    , A_Hd  , A_    }}},
   /* 48 48     */{T1, {{I_DEC16    , A_Hw  , A_    },{I_DEC32    , A_Hd  , A_    }}},
   /* 49 49     */{T1, {{I_DEC16    , A_Hw  , A_    },{I_DEC32    , A_Hd  , A_    }}},
   /* 4a 4a     */{T1, {{I_DEC16    , A_Hw  , A_    },{I_DEC32    , A_Hd  , A_    }}},
   /* 4b 4b     */{T1, {{I_DEC16    , A_Hw  , A_    },{I_DEC32    , A_Hd  , A_    }}},
   /* 4c 4c     */{T1, {{I_DEC16    , A_Hw  , A_    },{I_DEC32    , A_Hd  , A_    }}},
   /* 4d 4d     */{T1, {{I_DEC16    , A_Hw  , A_    },{I_DEC32    , A_Hd  , A_    }}},
   /* 4e 4e     */{T1, {{I_DEC16    , A_Hw  , A_    },{I_DEC32    , A_Hd  , A_    }}},
   /* 4f 4f     */{T1, {{I_DEC16    , A_Hw  , A_    },{I_DEC32    , A_Hd  , A_    }}},

   /* 50 50     */{T2, {{I_PUSH16   , A_Hw  , A_    },{I_PUSH32   , A_Hd  , A_    }}},
   /* 51 51     */{T2, {{I_PUSH16   , A_Hw  , A_    },{I_PUSH32   , A_Hd  , A_    }}},
   /* 52 52     */{T2, {{I_PUSH16   , A_Hw  , A_    },{I_PUSH32   , A_Hd  , A_    }}},
   /* 53 53     */{T2, {{I_PUSH16   , A_Hw  , A_    },{I_PUSH32   , A_Hd  , A_    }}},
   /* 54 54     */{T2, {{I_PUSH16   , A_Hw  , A_    },{I_PUSH32   , A_Hd  , A_    }}},
   /* 55 55     */{T2, {{I_PUSH16   , A_Hw  , A_    },{I_PUSH32   , A_Hd  , A_    }}},
   /* 56 56     */{T2, {{I_PUSH16   , A_Hw  , A_    },{I_PUSH32   , A_Hd  , A_    }}},
   /* 57 57     */{T2, {{I_PUSH16   , A_Hw  , A_    },{I_PUSH32   , A_Hd  , A_    }}},
   /* 58 58     */{T3, {{I_POP16    , A_Hw  , A_    },{I_POP32    , A_Hd  , A_    }}},
   /* 59 59     */{T3, {{I_POP16    , A_Hw  , A_    },{I_POP32    , A_Hd  , A_    }}},
   /* 5a 5a     */{T3, {{I_POP16    , A_Hw  , A_    },{I_POP32    , A_Hd  , A_    }}},
   /* 5b 5b     */{T3, {{I_POP16    , A_Hw  , A_    },{I_POP32    , A_Hd  , A_    }}},
   /* 5c 5c     */{T3, {{I_POP16    , A_Hw  , A_    },{I_POP32    , A_Hd  , A_    }}},
   /* 5d 5d     */{T3, {{I_POP16    , A_Hw  , A_    },{I_POP32    , A_Hd  , A_    }}},
   /* 5e 5e     */{T3, {{I_POP16    , A_Hw  , A_    },{I_POP32    , A_Hd  , A_    }}},
   /* 5f 5f     */{T3, {{I_POP16    , A_Hw  , A_    },{I_POP32    , A_Hd  , A_    }}},

   /* 60 60     */{T0, {{I_PUSHA    , A_    , A_    },{I_PUSHAD   , A_    , A_    }}},
   /* 61 61     */{T0, {{I_POPA     , A_    , A_    },{I_POPAD    , A_    , A_    }}},
   /* 62 62     */{T6, {{I_BOUND16  , A_Gw  , A_Ma16},{I_BOUND32  , A_Gd  , A_Ma32}}},
   /* 63 63     */{T5,OI(I_ARPL     , A_Ew  , A_Gw  )},
#ifdef CPU_286
   /* 64 64     */{BAD_OPCODE},
   /* 65 65     */{BAD_OPCODE},
   /* 66 66     */{BAD_OPCODE},
   /* 67 67     */{BAD_OPCODE},
#else
   /* 64 64     */{T0,OI(P_FS       , A_    , A_    )},
   /* 65 65     */{T0,OI(P_GS       , A_    , A_    )},
   /* 66 66     */{T0,OI(P_OO       , A_    , A_    )},
   /* 67 67     */{T0,OI(P_AO       , A_    , A_    )},
#endif /* CPU_286 */
   /* 68 68     */{T2, {{I_PUSH16   , A_Iw  , A_    },{I_PUSH32   , A_Id  , A_    }}},
   /* 69 69     */{T7, {{I_IMUL16T3 , A_Gw  , A_EwIw},{I_IMUL32T3 , A_Gd  , A_EdId}}},
   /* 6a 6a     */{T2, {{I_PUSH16   , A_Ix  , A_    },{I_PUSH32   , A_Iy  , A_    }}},
   /* 6b 6b     */{T7, {{I_IMUL16T3 , A_Gw  , A_EwIx},{I_IMUL32T3 , A_Gd  , A_EdIy}}},
   /* 6c 6c     */{T0,OI(P_RULE6    , 0x3   , 0x68  )},
   /* 6d 6d     */{T0,OI(P_RULE6    , 0x3   , 0x6b  )},
   /* 6e 6e     */{T0,OI(P_RULE6    , 0x3   , 0x6e  )},
   /* 6f 6f     */{T0,OI(P_RULE6    , 0x3   , 0x71  )},

   /* 70 70     */{T2, {{I_JO16     , A_Jb2  , A_    },{I_JO32     , A_Jb  , A_    }}},
   /* 71 71     */{T2, {{I_JNO16    , A_Jb2  , A_    },{I_JNO32    , A_Jb  , A_    }}},
   /* 72 72     */{T2, {{I_JB16     , A_Jb2  , A_    },{I_JB32     , A_Jb  , A_    }}},
   /* 73 73     */{T2, {{I_JNB16    , A_Jb2  , A_    },{I_JNB32    , A_Jb  , A_    }}},
   /* 74 74     */{T2, {{I_JZ16     , A_Jb2  , A_    },{I_JZ32     , A_Jb  , A_    }}},
   /* 75 75     */{T2, {{I_JNZ16    , A_Jb2  , A_    },{I_JNZ32    , A_Jb  , A_    }}},
   /* 76 76     */{T2, {{I_JBE16    , A_Jb2  , A_    },{I_JBE32    , A_Jb  , A_    }}},
   /* 77 77     */{T2, {{I_JNBE16   , A_Jb2  , A_    },{I_JNBE32   , A_Jb  , A_    }}},
   /* 78 78     */{T2, {{I_JS16     , A_Jb2  , A_    },{I_JS32     , A_Jb  , A_    }}},
   /* 79 79     */{T2, {{I_JNS16    , A_Jb2  , A_    },{I_JNS32    , A_Jb  , A_    }}},
   /* 7a 7a     */{T2, {{I_JP16     , A_Jb2  , A_    },{I_JP32     , A_Jb  , A_    }}},
   /* 7b 7b     */{T2, {{I_JNP16    , A_Jb2  , A_    },{I_JNP32    , A_Jb  , A_    }}},
   /* 7c 7c     */{T2, {{I_JL16     , A_Jb2  , A_    },{I_JL32     , A_Jb  , A_    }}},
   /* 7d 7d     */{T2, {{I_JNL16    , A_Jb2  , A_    },{I_JNL32    , A_Jb  , A_    }}},
   /* 7e 7e     */{T2, {{I_JLE16    , A_Jb2  , A_    },{I_JLE32    , A_Jb  , A_    }}},
   /* 7f 7f     */{T2, {{I_JNLE16   , A_Jb2  , A_    },{I_JNLE32   , A_Jb  , A_    }}},

   /* 80 80     */{T0,OI(P_RULE2    , 0x2   , 0x00  )},
   /* 81 81     */{T0,OI(P_RULE2    , 0x2   , 0x08  )},
   /* 82 82     */{T0,OI(P_RULE2    , 0x2   , 0x00  )},
   /* 83 83     */{T0,OI(P_RULE2    , 0x2   , 0x10  )},
   /* 84 84     */{T6,OI(I_TEST8    , A_Eb  , A_Gb  )},
   /* 85 85     */{T6, {{I_TEST16   , A_Ew  , A_Gw  },{I_TEST32   , A_Ed  , A_Gd  }}},
   /* 86 86     */{T8,OI(I_XCHG8    , A_Eb  , A_Gb  )},
   /* 87 87     */{T8, {{I_XCHG16   , A_Ew  , A_Gw  },{I_XCHG32   , A_Ed  , A_Gd  }}},
   /* 88 88     */{T4,OI(I_MOV8     , A_Eb  , A_Gb  )},
   /* 89 89     */{T4, {{I_MOV16    , A_Ew  , A_Gw  },{I_MOV32    , A_Ed  , A_Gd  }}},
   /* 8a 8a     */{T4,OI(I_MOV8     , A_Gb  , A_Eb  )},
   /* 8b 8b     */{T4, {{I_MOV16    , A_Gw  , A_Ew  },{I_MOV32    , A_Gd  , A_Ed  }}},

#ifdef NO_CHIP_BUG
   /* 8c 8c     */{T4,OI(I_MOV16    , A_Ew  , A_Nw  )},
#else
   /* 8c 8c     */{T4, {{I_MOV16    , A_Ew  , A_Nw  },{I_MOV32    , A_Ex  , A_Nw  }}},
#endif /* NO_CHIP_BUG */

   /* 8d 8d     */{TA, {{I_LEA      , A_Gw  , A_M   },{I_LEA      , A_Gd  , A_M   }}},
   /* 8e 8e     */{T4,OI(I_MOV_SR   , A_Lw  , A_Ew  )},
   /* 8f 8f     */{T0,OI(P_RULE2    , 0x2   , 0x18  )},

   /* 90 90     */{T0,OI(I_NOP      , A_    , A_    )},
   /* 91 91     */{T8, {{I_XCHG16   , A_Fax , A_Hw  },{I_XCHG32   , A_Feax, A_Hd  }}},
   /* 92 92     */{T8, {{I_XCHG16   , A_Fax , A_Hw  },{I_XCHG32   , A_Feax, A_Hd  }}},
   /* 93 93     */{T8, {{I_XCHG16   , A_Fax , A_Hw  },{I_XCHG32   , A_Feax, A_Hd  }}},
   /* 94 94     */{T8, {{I_XCHG16   , A_Fax , A_Hw  },{I_XCHG32   , A_Feax, A_Hd  }}},
   /* 95 95     */{T8, {{I_XCHG16   , A_Fax , A_Hw  },{I_XCHG32   , A_Feax, A_Hd  }}},
   /* 96 96     */{T8, {{I_XCHG16   , A_Fax , A_Hw  },{I_XCHG32   , A_Feax, A_Hd  }}},
   /* 97 97     */{T8, {{I_XCHG16   , A_Fax , A_Hw  },{I_XCHG32   , A_Feax, A_Hd  }}},
   /* 98 98     */{T0, {{I_CBW      , A_    , A_    },{I_CWDE     , A_    , A_    }}},
   /* 99 99     */{T0, {{I_CWD      , A_    , A_    },{I_CDQ      , A_    , A_    }}},
   /* 9a 9a     */{T2, {{I_CALLF16  , A_Aw  , A_    },{I_CALLF32  , A_Ad  , A_    }}},
   /* 9b 9b     */{T0,OI(I_WAIT     , A_    , A_    )},
   /* 9c 9c     */{T0, {{I_PUSHF    , A_    , A_    },{I_PUSHFD   , A_    , A_    }}},
   /* 9d 9d     */{T0, {{I_POPF     , A_    , A_    },{I_POPFD    , A_    , A_    }}},
   /* 9e 9e     */{T0,OI(I_SAHF     , A_    , A_    )},
   /* 9f 9f     */{T0,OI(I_LAHF     , A_    , A_    )},

   /* a0 a0     */{T4,OI(I_MOV8     , A_Fal , A_Ob  )},
   /* a1 a1     */{T4, {{I_MOV16    , A_Fax , A_Ow  },{I_MOV32    , A_Feax, A_Od  }}},
   /* a2 a2     */{T4,OI(I_MOV8     , A_Ob  , A_Fal )},
   /* a3 a3     */{T4, {{I_MOV16    , A_Ow  , A_Fax },{I_MOV32    , A_Od  , A_Feax}}},
   /* a4 a4     */{T0,OI(P_RULE6    , 0x3   , 0x74  )},
   /* a5 a5     */{T0,OI(P_RULE6    , 0x3   , 0x77  )},
   /* a6 a6     */{T0,OI(P_RULE6    , 0x3   , 0x7a  )},
   /* a7 a7     */{T0,OI(P_RULE6    , 0x3   , 0x7d  )},
   /* a8 a8     */{T6,OI(I_TEST8    , A_Fal , A_Ib  )},
   /* a9 a9     */{T6, {{I_TEST16   , A_Fax , A_Iw  },{I_TEST32   , A_Feax, A_Id  }}},
   /* aa aa     */{T0,OI(P_RULE6    , 0x3   , 0x80  )},
   /* ab ab     */{T0,OI(P_RULE6    , 0x3   , 0x83  )},
   /* ac ac     */{T0,OI(P_RULE6    , 0x3   , 0x86  )},
   /* ad ad     */{T0,OI(P_RULE6    , 0x3   , 0x89  )},
   /* ae ae     */{T0,OI(P_RULE6    , 0x3   , 0x8c  )},
   /* af af     */{T0,OI(P_RULE6    , 0x3   , 0x8f  )},

   /* b0 b0     */{T4,OI(I_MOV8     , A_Hb  , A_Ib  )},
   /* b1 b1     */{T4,OI(I_MOV8     , A_Hb  , A_Ib  )},
   /* b2 b2     */{T4,OI(I_MOV8     , A_Hb  , A_Ib  )},
   /* b3 b3     */{T4,OI(I_MOV8     , A_Hb  , A_Ib  )},
   /* b4 b4     */{T4,OI(I_MOV8     , A_Hb  , A_Ib  )},
   /* b5 b5     */{T4,OI(I_MOV8     , A_Hb  , A_Ib  )},
   /* b6 b6     */{T4,OI(I_MOV8     , A_Hb  , A_Ib  )},
   /* b7 b7     */{T4,OI(I_MOV8     , A_Hb  , A_Ib  )},
   /* b8 b8     */{T4, {{I_MOV16    , A_Hw  , A_Iw  },{I_MOV32    , A_Hd  , A_Id  }}},
   /* b9 b9     */{T4, {{I_MOV16    , A_Hw  , A_Iw  },{I_MOV32    , A_Hd  , A_Id  }}},
   /* ba ba     */{T4, {{I_MOV16    , A_Hw  , A_Iw  },{I_MOV32    , A_Hd  , A_Id  }}},
   /* bb bb     */{T4, {{I_MOV16    , A_Hw  , A_Iw  },{I_MOV32    , A_Hd  , A_Id  }}},
   /* bc bc     */{T4, {{I_MOV16    , A_Hw  , A_Iw  },{I_MOV32    , A_Hd  , A_Id  }}},
   /* bd bd     */{T4, {{I_MOV16    , A_Hw  , A_Iw  },{I_MOV32    , A_Hd  , A_Id  }}},
   /* be be     */{T4, {{I_MOV16    , A_Hw  , A_Iw  },{I_MOV32    , A_Hd  , A_Id  }}},
   /* bf bf     */{T4, {{I_MOV16    , A_Hw  , A_Iw  },{I_MOV32    , A_Hd  , A_Id  }}},

   /* c0 c0     */{T0,OI(P_RULE2    , 0x2   , 0x20  )},
   /* c1 c1     */{T0,OI(P_RULE2    , 0x2   , 0x28  )},
   /* c2 c2     */{T2, {{I_RETN16   , A_Iw  , A_    },{I_RETN32   , A_Iw  , A_    }}},
   /* c3 c3     */{T2, {{I_RETN16   , A_I0  , A_    },{I_RETN32   , A_I0  , A_    }}},
   /* c4 c4     */{T0,OI(P_RULE7    , 0x3   , 0x98  )},
   /* c5 c5     */{T4, {{I_LDS      , A_Gw  , A_Mp16},{I_LDS      , A_Gd  , A_Mp32}}},
   /* c6 c6     */{T0,OI(P_RULE2    , 0x2   , 0x30  )},
   /* c7 c7     */{T0,OI(P_RULE2    , 0x2   , 0x38  )},
   /* c8 c8     */{T6, {{I_ENTER16  , A_Iw  , A_Ib  },{I_ENTER32  , A_Iw  , A_Ib  }}},
   /* c9 c9     */{T0, {{I_LEAVE16  , A_    , A_    },{I_LEAVE32  , A_    , A_    }}},
   /* ca ca     */{T2, {{I_RETF16   , A_Iw  , A_    },{I_RETF32   , A_Iw  , A_    }}},
   /* cb cb     */{T2, {{I_RETF16   , A_I0  , A_    },{I_RETF32   , A_I0  , A_    }}},
   /* cc cc     */{T2,OI(I_INT3     , A_I3  , A_    )},
   /* cd cd     */{T2,OI(I_INT      , A_Ib  , A_    )},
   /* ce ce     */{T0,OI(I_INTO     , A_    , A_    )},
   /* cf cf     */{T0, {{I_IRET     , A_    , A_    },{I_IRETD    , A_    , A_    }}},

   /* d0 d0     */{T0,OI(P_RULE2    , 0x2   , 0x40  )},
   /* d1 d1     */{T0,OI(P_RULE2    , 0x2   , 0x48  )},
   /* d2 d2     */{T0,OI(P_RULE2    , 0x2   , 0x50  )},
   /* d3 d3     */{T0,OI(P_RULE2    , 0x2   , 0x58  )},
   /* d4 d4     */{T2,OI(I_AAM      , A_Ib  , A_    )},
   /* d5 d5     */{T2,OI(I_AAD      , A_Ib  , A_    )},
   /* d6 d6     */{T2,OI(I_ZBOP     , A_Ib  , A_    )},
   /* d7 d7     */{T2,OI(I_XLAT     , A_Z   , A_    )},
   /* d8 d8     */{T0,OI(P_RULE4    , 0x2   , 0xa0  )},
   /* d9 d9     */{T0,OI(P_RULE4    , 0x2   , 0xb0  )},
   /* da da     */{T0,OI(P_RULE4    , 0x2   , 0xc0  )},
   /* db db     */{T0,OI(P_RULE4    , 0x2   , 0xd0  )},
   /* dc dc     */{T0,OI(P_RULE4    , 0x2   , 0xe0  )},
   /* dd dd     */{T0,OI(P_RULE4    , 0x2   , 0xf0  )},
   /* de de     */{T0,OI(P_RULE4    , 0x3   , 0x00  )},
   /* df df     */{T0,OI(P_RULE4    , 0x3   , 0x10  )},

   /* e0 e0     */{T2,OI(P_RULE8    , 0x3   , 0x9a  )},
   /* e1 e1     */{T2,OI(P_RULE8    , 0x3   , 0x9c  )},
   /* e2 e2     */{T2,OI(P_RULE8    , 0x3   , 0x9e  )},
   /* e3 e3     */{T2,OI(P_RULE8    , 0x3   , 0xa0  )},
   /* e4 e4     */{T4,OI(I_IN8      , A_Fal , A_Ib  )},
   /* e5 e5     */{T4, {{I_IN16     , A_Fax , A_Ib  },{I_IN32     , A_Feax, A_Ib  }}},
   /* e6 e6     */{T6,OI(I_OUT8     , A_Ib  , A_Fal )},
   /* e7 e7     */{T6, {{I_OUT16    , A_Ib  , A_Fax },{I_OUT32    , A_Ib  , A_Feax}}},
   /* e8 e8     */{T2, {{I_CALLR16  , A_Jw  , A_    },{I_CALLR32  , A_Jd  , A_    }}},
   /* e9 e9     */{T2, {{I_JMPR16   , A_Jw  , A_    },{I_JMPR32   , A_Jd  , A_    }}},
   /* ea ea     */{T2, {{I_JMPF16   , A_Aw  , A_    },{I_JMPF32   , A_Ad  , A_    }}},
   /* eb eb     */{T2, {{I_JMPR16   , A_Jb  , A_    },{I_JMPR32   , A_Jb  , A_    }}},
   /* ec ec     */{T4,OI(I_IN8      , A_Fal , A_Fdx )},
   /* ed ed     */{T4, {{I_IN16     , A_Fax , A_Fdx },{I_IN32     , A_Feax, A_Fdx }}},
   /* ee ee     */{T6,OI(I_OUT8     , A_Fdx , A_Fal )},
   /* ef ef     */{T6, {{I_OUT16    , A_Fdx , A_Fax },{I_OUT32    , A_Fdx , A_Feax}}},

#ifdef CPU_286
   /* f0 f0     */{T0,OI(I_LOCK     , A_    , A_    )},
#else
   /* f0 f0     */{T0,OI(P_LOCK     , A_    , A_    )},
#endif /* CPU_286 */
   /* f1 f1     */{T0,OI(P_F1       , A_    , A_    )},
   /* f2 f2     */{T0,OI(P_REPNE    , A_    , A_    )},
   /* f3 f3     */{T0,OI(P_REPE     , A_    , A_    )},
   /* f4 f4     */{T0,OI(I_HLT      , A_    , A_    )},
   /* f5 f5     */{T0,OI(I_CMC      , A_    , A_    )},
   /* f6 f6     */{T0,OI(P_RULE2    , 0x2   , 0x60  )},
   /* f7 f7     */{T0,OI(P_RULE2    , 0x2   , 0x68  )},
   /* f8 f8     */{T0,OI(I_CLC      , A_    , A_    )},
   /* f9 f9     */{T0,OI(I_STC      , A_    , A_    )},
   /* fa fa     */{T0,OI(I_CLI      , A_    , A_    )},
   /* fb fb     */{T0,OI(I_STI      , A_    , A_    )},
   /* fc fc     */{T0,OI(I_CLD      , A_    , A_    )},
   /* fd fd     */{T0,OI(I_STD      , A_    , A_    )},
   /* fe fe     */{T0,OI(P_RULE2    , 0x2   , 0x70  )},
   /* ff ff     */{T0,OI(P_RULE2    , 0x2   , 0x78  )},

   /*100 0f/00  */{T0,OI(P_RULE2    , 0x2   , 0x80  )},
   /*101 0f/01  */{T0,OI(P_RULE2    , 0x2   , 0x88  )},
   /*102 0f/02  */{T5, {{I_LAR      , A_Gw  , A_Ew  },{I_LAR      , A_Gd  , A_Ew  }}},
   /*103 0f/03  */{T5, {{I_LSL      , A_Gw  , A_Ew  },{I_LSL      , A_Gd  , A_Ew  }}},
   /*104 0f/04  */{BAD_OPCODE},
#ifdef CPU_286
   /*105 0f/05  */{T0,OI(I_LOADALL  , A_    , A_    )},
#else
   /*105 0f/05  */{BAD_OPCODE},
#endif /* CPU_286 */
   /*106 0f/06  */{T0,OI(I_CLTS     , A_    , A_    )},
#ifdef CPU_286
   /*105 0f/07  */{BAD_OPCODE},
   /*105 0f/08  */{BAD_OPCODE},
   /*105 0f/09  */{BAD_OPCODE},
#else
   /*107 0f/07  */{T0,OI(I_ZRSRVD   , A_    , A_    )},
   /*108 0f/08  */{T0,OI(I_INVD     , A_    , A_    )},
   /*109 0f/09  */{T0,OI(I_WBINVD   , A_    , A_    )},
#endif /* CPU_286 */
   /*10a 0f/0a  */{BAD_OPCODE},
   /*10b 0f/0b  */{BAD_OPCODE},
   /*10c 0f/0c  */{BAD_OPCODE},
   /*10d 0f/0d  */{BAD_OPCODE},
   /*10e 0f/0e  */{BAD_OPCODE},
#ifdef PIG
   /*10f 0f/0f  */{T0,OI(I_ZZEXIT   , A_    , A_    )},
#else
   /*10f 0f/0f  */{BAD_OPCODE},
#endif /* PIG */

#ifdef CPU_286
   /*110 0f/10  */{BAD_OPCODE},
   /*111 0f/11  */{BAD_OPCODE},
   /*112 0f/12  */{BAD_OPCODE},
   /*113 0f/13  */{BAD_OPCODE},
#else
   /*110 0f/10  */{T0,OI(I_ZRSRVD   , A_    , A_    )},
   /*111 0f/11  */{T0,OI(I_ZRSRVD   , A_    , A_    )},
   /*112 0f/12  */{T0,OI(I_ZRSRVD   , A_    , A_    )},
   /*113 0f/13  */{T0,OI(I_ZRSRVD   , A_    , A_    )},
#endif /* CPU_286 */
   /*114 0f/14  */{BAD_OPCODE},
   /*115 0f/15  */{BAD_OPCODE},
   /*116 0f/16  */{BAD_OPCODE},
   /*117 0f/17  */{BAD_OPCODE},
   /*118 0f/18  */{BAD_OPCODE},
   /*119 0f/19  */{BAD_OPCODE},
   /*11a 0f/1a  */{BAD_OPCODE},
   /*11b 0f/1b  */{BAD_OPCODE},
   /*11c 0f/1c  */{BAD_OPCODE},
   /*11d 0f/1d  */{BAD_OPCODE},
   /*11e 0f/1e  */{BAD_OPCODE},
   /*11f 0f/1f  */{BAD_OPCODE},

#ifdef CPU_286
   /*120 0f/20  */{BAD_OPCODE},
   /*121 0f/21  */{BAD_OPCODE},
   /*122 0f/22  */{BAD_OPCODE},
   /*123 0f/23  */{BAD_OPCODE},
   /*124 0f/24  */{BAD_OPCODE},
   /*125 0f/25  */{BAD_OPCODE},
   /*126 0f/26  */{BAD_OPCODE},
#else
   /*120 0f/20  */{T4,OI(I_MOV_CR   , A_Rd  , A_Cd  )},
   /*121 0f/21  */{T4,OI(I_MOV_DR   , A_Rd  , A_Dd  )},
   /*122 0f/22  */{T4,OI(I_MOV_CR   , A_Cd  , A_Rd  )},
   /*123 0f/23  */{T4,OI(I_MOV_DR   , A_Dd  , A_Rd  )},
   /*124 0f/24  */{T4,OI(I_MOV_TR   , A_Rd  , A_Td  )},
   /*125 0f/25  */{BAD_OPCODE},
   /*126 0f/26  */{T4,OI(I_MOV_TR   , A_Td  , A_Rd  )},
#endif /* CPU_286 */
   /*127 0f/27  */{BAD_OPCODE},
   /*128 0f/28  */{BAD_OPCODE},
   /*129 0f/29  */{BAD_OPCODE},
   /*12a 0f/2a  */{BAD_OPCODE},
   /*12b 0f/2b  */{BAD_OPCODE},
   /*12c 0f/2c  */{BAD_OPCODE},
   /*12d 0f/2d  */{BAD_OPCODE},
   /*12e 0f/2e  */{BAD_OPCODE},
   /*12f 0f/2f  */{BAD_OPCODE},

   /*130 0f/30  */{BAD_OPCODE},
   /*131 0f/31  */{BAD_OPCODE},
   /*132 0f/32  */{BAD_OPCODE},
   /*133 0f/33  */{BAD_OPCODE},
   /*134 0f/34  */{BAD_OPCODE},
   /*135 0f/35  */{BAD_OPCODE},
   /*136 0f/36  */{BAD_OPCODE},
   /*137 0f/37  */{BAD_OPCODE},
   /*138 0f/38  */{BAD_OPCODE},
   /*139 0f/39  */{BAD_OPCODE},
   /*13a 0f/3a  */{BAD_OPCODE},
   /*13b 0f/3b  */{BAD_OPCODE},
   /*13c 0f/3c  */{BAD_OPCODE},
   /*13d 0f/3d  */{BAD_OPCODE},
   /*13e 0f/3e  */{BAD_OPCODE},
   /*13f 0f/3f  */{BAD_OPCODE},

   /*140 0f/40  */{BAD_OPCODE},
   /*141 0f/41  */{BAD_OPCODE},
   /*142 0f/42  */{BAD_OPCODE},
   /*143 0f/43  */{BAD_OPCODE},
   /*144 0f/44  */{BAD_OPCODE},
   /*145 0f/45  */{BAD_OPCODE},
   /*146 0f/46  */{BAD_OPCODE},
   /*147 0f/47  */{BAD_OPCODE},
   /*148 0f/48  */{BAD_OPCODE},
   /*149 0f/49  */{BAD_OPCODE},
   /*14a 0f/4a  */{BAD_OPCODE},
   /*14b 0f/4b  */{BAD_OPCODE},
   /*14c 0f/4c  */{BAD_OPCODE},
   /*14d 0f/4d  */{BAD_OPCODE},
   /*14e 0f/4e  */{BAD_OPCODE},
   /*14f 0f/4f  */{BAD_OPCODE},

   /*150 0f/50  */{BAD_OPCODE},
   /*151 0f/51  */{BAD_OPCODE},
   /*152 0f/52  */{BAD_OPCODE},
   /*153 0f/53  */{BAD_OPCODE},
   /*154 0f/54  */{BAD_OPCODE},
   /*155 0f/55  */{BAD_OPCODE},
   /*156 0f/56  */{BAD_OPCODE},
   /*157 0f/57  */{BAD_OPCODE},
   /*158 0f/58  */{BAD_OPCODE},
   /*159 0f/59  */{BAD_OPCODE},
   /*15a 0f/5a  */{BAD_OPCODE},
   /*15b 0f/5b  */{BAD_OPCODE},
   /*15c 0f/5c  */{BAD_OPCODE},
   /*15d 0f/5d  */{BAD_OPCODE},
   /*15e 0f/5e  */{BAD_OPCODE},
   /*15f 0f/5f  */{BAD_OPCODE},

   /*160 0f/60  */{BAD_OPCODE},
   /*161 0f/61  */{BAD_OPCODE},
   /*162 0f/62  */{BAD_OPCODE},
   /*163 0f/63  */{BAD_OPCODE},
   /*164 0f/64  */{BAD_OPCODE},
   /*165 0f/65  */{BAD_OPCODE},
   /*166 0f/66  */{BAD_OPCODE},
   /*167 0f/67  */{BAD_OPCODE},
   /*168 0f/68  */{BAD_OPCODE},
   /*169 0f/69  */{BAD_OPCODE},
   /*16a 0f/6a  */{BAD_OPCODE},
   /*16b 0f/6b  */{BAD_OPCODE},
   /*16c 0f/6c  */{BAD_OPCODE},
   /*16d 0f/6d  */{BAD_OPCODE},
   /*16e 0f/6e  */{BAD_OPCODE},
   /*16f 0f/6f  */{BAD_OPCODE},

   /*170 0f/70  */{BAD_OPCODE},
   /*171 0f/71  */{BAD_OPCODE},
   /*172 0f/72  */{BAD_OPCODE},
   /*173 0f/73  */{BAD_OPCODE},
   /*174 0f/74  */{BAD_OPCODE},
   /*175 0f/75  */{BAD_OPCODE},
   /*176 0f/76  */{BAD_OPCODE},
   /*177 0f/77  */{BAD_OPCODE},
   /*178 0f/78  */{BAD_OPCODE},
   /*179 0f/79  */{BAD_OPCODE},
   /*17a 0f/7a  */{BAD_OPCODE},
   /*17b 0f/7b  */{BAD_OPCODE},
   /*17c 0f/7c  */{BAD_OPCODE},
   /*17d 0f/7d  */{BAD_OPCODE},
   /*17e 0f/7e  */{BAD_OPCODE},
   /*17f 0f/7f  */{BAD_OPCODE},

#ifdef CPU_286
   /*180 0f/80  */{BAD_OPCODE},
   /*181 0f/81  */{BAD_OPCODE},
   /*182 0f/82  */{BAD_OPCODE},
   /*183 0f/83  */{BAD_OPCODE},
   /*184 0f/84  */{BAD_OPCODE},
   /*185 0f/85  */{BAD_OPCODE},
   /*186 0f/86  */{BAD_OPCODE},
   /*187 0f/87  */{BAD_OPCODE},
   /*188 0f/88  */{BAD_OPCODE},
   /*189 0f/89  */{BAD_OPCODE},
   /*18a 0f/8a  */{BAD_OPCODE},
   /*18b 0f/8b  */{BAD_OPCODE},
   /*18c 0f/8c  */{BAD_OPCODE},
   /*18d 0f/8d  */{BAD_OPCODE},
   /*18e 0f/8e  */{BAD_OPCODE},
   /*18f 0f/8f  */{BAD_OPCODE},

   /*190 0f/90  */{BAD_OPCODE},
   /*191 0f/91  */{BAD_OPCODE},
   /*192 0f/92  */{BAD_OPCODE},
   /*193 0f/93  */{BAD_OPCODE},
   /*194 0f/94  */{BAD_OPCODE},
   /*195 0f/95  */{BAD_OPCODE},
   /*196 0f/96  */{BAD_OPCODE},
   /*197 0f/97  */{BAD_OPCODE},
   /*198 0f/98  */{BAD_OPCODE},
   /*199 0f/99  */{BAD_OPCODE},
   /*19a 0f/9a  */{BAD_OPCODE},
   /*19b 0f/9b  */{BAD_OPCODE},
   /*19c 0f/9c  */{BAD_OPCODE},
   /*19d 0f/9d  */{BAD_OPCODE},
   /*19e 0f/9e  */{BAD_OPCODE},
   /*19f 0f/9f  */{BAD_OPCODE},

   /*1a0 0f/a0  */{BAD_OPCODE},
   /*1a1 0f/a1  */{BAD_OPCODE},
   /*1a2 0f/a2  */{BAD_OPCODE},
   /*1a3 0f/a3  */{BAD_OPCODE},
   /*1a4 0f/a4  */{BAD_OPCODE},
   /*1a5 0f/a5  */{BAD_OPCODE},
   /*1a6 0f/a6  */{BAD_OPCODE},
   /*1a7 0f/a7  */{BAD_OPCODE},
   /*1a8 0f/a8  */{BAD_OPCODE},
   /*1a9 0f/a9  */{BAD_OPCODE},
   /*1aa 0f/aa  */{BAD_OPCODE},
   /*1ab 0f/ab  */{BAD_OPCODE},
   /*1ac 0f/ac  */{BAD_OPCODE},
   /*1ad 0f/ad  */{BAD_OPCODE},
   /*1aa 0f/ae  */{BAD_OPCODE},
   /*1af 0f/af  */{BAD_OPCODE},

   /*1b0 0f/b0  */{BAD_OPCODE},
   /*1b1 0f/b1  */{BAD_OPCODE},
   /*1b2 0f/b2  */{BAD_OPCODE},
   /*1b3 0f/b3  */{BAD_OPCODE},
   /*1b4 0f/b4  */{BAD_OPCODE},
   /*1b5 0f/b5  */{BAD_OPCODE},
   /*1b6 0f/b6  */{BAD_OPCODE},
   /*1b7 0f/b7  */{BAD_OPCODE},
   /*1b8 0f/b8  */{BAD_OPCODE},
   /*1b9 0f/b9  */{BAD_OPCODE},
   /*1ba 0f/ba  */{BAD_OPCODE},
   /*1bb 0f/bb  */{BAD_OPCODE},
   /*1bc 0f/bc  */{BAD_OPCODE},
   /*1bd 0f/bd  */{BAD_OPCODE},
   /*1be 0f/be  */{BAD_OPCODE},
   /*1bf 0f/bf  */{BAD_OPCODE},

   /*1c0 0f/c0  */{BAD_OPCODE},
   /*1c1 0f/c1  */{BAD_OPCODE},
   /*1c2 0f/c2  */{BAD_OPCODE},
   /*1c3 0f/c3  */{BAD_OPCODE},
   /*1c4 0f/c4  */{BAD_OPCODE},
   /*1c5 0f/c5  */{BAD_OPCODE},
   /*1c6 0f/c6  */{BAD_OPCODE},
   /*1c7 0f/c7  */{BAD_OPCODE},
   /*1c8 0f/c8  */{BAD_OPCODE},
   /*1c9 0f/c9  */{BAD_OPCODE},
   /*1ca 0f/ca  */{BAD_OPCODE},
   /*1cb 0f/cb  */{BAD_OPCODE},
   /*1cc 0f/cc  */{BAD_OPCODE},
   /*1cd 0f/cd  */{BAD_OPCODE},
   /*1ce 0f/ce  */{BAD_OPCODE},
   /*1cf 0f/cf  */{BAD_OPCODE},
#else
   /*180 0f/80  */{T2, {{I_JO16     , A_Jw  , A_    },{I_JO32     , A_Jd  , A_    }}},
   /*181 0f/81  */{T2, {{I_JNO16    , A_Jw  , A_    },{I_JNO32    , A_Jd  , A_    }}},
   /*182 0f/82  */{T2, {{I_JB16     , A_Jw  , A_    },{I_JB32     , A_Jd  , A_    }}},
   /*183 0f/83  */{T2, {{I_JNB16    , A_Jw  , A_    },{I_JNB32    , A_Jd  , A_    }}},
   /*184 0f/84  */{T2, {{I_JZ16     , A_Jw  , A_    },{I_JZ32     , A_Jd  , A_    }}},
   /*185 0f/85  */{T2, {{I_JNZ16    , A_Jw  , A_    },{I_JNZ32    , A_Jd  , A_    }}},
   /*186 0f/86  */{T2, {{I_JBE16    , A_Jw  , A_    },{I_JBE32    , A_Jd  , A_    }}},
   /*187 0f/87  */{T2, {{I_JNBE16   , A_Jw  , A_    },{I_JNBE32   , A_Jd  , A_    }}},
   /*188 0f/88  */{T2, {{I_JS16     , A_Jw  , A_    },{I_JS32     , A_Jd  , A_    }}},
   /*189 0f/89  */{T2, {{I_JNS16    , A_Jw  , A_    },{I_JNS32    , A_Jd  , A_    }}},
   /*18a 0f/8a  */{T2, {{I_JP16     , A_Jw  , A_    },{I_JP32     , A_Jd  , A_    }}},
   /*18b 0f/8b  */{T2, {{I_JNP16    , A_Jw  , A_    },{I_JNP32    , A_Jd  , A_    }}},
   /*18c 0f/8c  */{T2, {{I_JL16     , A_Jw  , A_    },{I_JL32     , A_Jd  , A_    }}},
   /*18d 0f/8d  */{T2, {{I_JNL16    , A_Jw  , A_    },{I_JNL32    , A_Jd  , A_    }}},
   /*18e 0f/8e  */{T2, {{I_JLE16    , A_Jw  , A_    },{I_JLE32    , A_Jd  , A_    }}},
   /*18f 0f/8f  */{T2, {{I_JNLE16   , A_Jw  , A_    },{I_JNLE32   , A_Jd  , A_    }}},

   /*190 0f/90  */{T3,OI(I_SETO     , A_Eb  , A_    )},
   /*191 0f/91  */{T3,OI(I_SETNO    , A_Eb  , A_    )},
   /*192 0f/92  */{T3,OI(I_SETB     , A_Eb  , A_    )},
   /*193 0f/93  */{T3,OI(I_SETNB    , A_Eb  , A_    )},
   /*194 0f/94  */{T3,OI(I_SETZ     , A_Eb  , A_    )},
   /*195 0f/95  */{T3,OI(I_SETNZ    , A_Eb  , A_    )},
   /*196 0f/96  */{T3,OI(I_SETBE    , A_Eb  , A_    )},
   /*197 0f/97  */{T3,OI(I_SETNBE   , A_Eb  , A_    )},
   /*198 0f/98  */{T3,OI(I_SETS     , A_Eb  , A_    )},
   /*199 0f/99  */{T3,OI(I_SETNS    , A_Eb  , A_    )},
   /*19a 0f/9a  */{T3,OI(I_SETP     , A_Eb  , A_    )},
   /*19b 0f/9b  */{T3,OI(I_SETNP    , A_Eb  , A_    )},
   /*19c 0f/9c  */{T3,OI(I_SETL     , A_Eb  , A_    )},
   /*19d 0f/9d  */{T3,OI(I_SETNL    , A_Eb  , A_    )},
   /*19e 0f/9e  */{T3,OI(I_SETLE    , A_Eb  , A_    )},
   /*19f 0f/9f  */{T3,OI(I_SETNLE   , A_Eb  , A_    )},

   /*1a0 0f/a0  */{T2,OI(I_PUSH16   , A_Qw  , A_    )},
   /*1a1 0f/a1  */{T3,OI(I_POP_SR   , A_Qw  , A_    )},
   /*1a2 0f/a2  */{BAD_OPCODE},
   /*1a3 0f/a3  */{T6, {{I_BT16     , A_Ew  , A_Gw  },{I_BT32     , A_Ed  , A_Gd  }}},
   /*1a4 0f/a4  */{T9, {{I_SHLD16   , A_Ew  , A_GwIb},{I_SHLD32   , A_Ed  , A_GdIb}}},
   /*1a5 0f/a5  */{T9, {{I_SHLD16   , A_Ew  , A_GwCL},{I_SHLD32   , A_Ed  , A_GdCL}}},
   /*1a6 0f/a6  */{BAD_OPCODE},
   /*1a7 0f/a7  */{BAD_OPCODE},
   /*1a8 0f/a8  */{T2,OI(I_PUSH16   , A_Qw  , A_    )},
   /*1a9 0f/a9  */{T3,OI(I_POP_SR   , A_Qw  , A_    )},
   /*1aa 0f/aa  */{BAD_OPCODE},
   /*1ab 0f/ab  */{T5, {{I_BTS16    , A_Ew  , A_Gw  },{I_BTS32    , A_Ed  , A_Gd  }}},
   /*1ac 0f/ac  */{T9, {{I_SHRD16   , A_Ew  , A_GwIb},{I_SHRD32   , A_Ed  , A_GdIb}}},
   /*1ad 0f/ad  */{T9, {{I_SHRD16   , A_Ew  , A_GwCL},{I_SHRD32   , A_Ed  , A_GdCL}}},
   /*1aa 0f/ae  */{BAD_OPCODE},
   /*1af 0f/af  */{T5, {{I_IMUL16T2 , A_Gw  , A_Ew  },{I_IMUL32T2 , A_Gd  , A_Ed  }}},

   /*1b0 0f/b0  */{T5,OI(I_CMPXCHG8 , A_Eb  , A_Gb  )},
   /*1b1 0f/b1  */{T5, {{I_CMPXCHG16, A_Ew  , A_Gw  },{I_CMPXCHG32, A_Ed  , A_Gd  }}},
   /*1b2 0f/b2  */{T4, {{I_LSS      , A_Gw  , A_Mp16},{I_LSS      , A_Gd  , A_Mp32}}},
   /*1b3 0f/b3  */{T5, {{I_BTR16    , A_Ew  , A_Gw  },{I_BTR32    , A_Ed  , A_Gd  }}},
   /*1b4 0f/b4  */{T4, {{I_LFS      , A_Gw  , A_Mp16},{I_LFS      , A_Gd  , A_Mp32}}},
   /*1b5 0f/b5  */{T4, {{I_LGS      , A_Gw  , A_Mp16},{I_LGS      , A_Gd  , A_Mp32}}},
   /*1b6 0f/b6  */{T4, {{I_MOVZX8   , A_Gw  , A_Eb  },{I_MOVZX8   , A_Gd  , A_Eb  }}},
   /*1b7 0f/b7  */{T4,OI(I_MOVZX16  , A_Gd  , A_Ew  )},
   /*1b8 0f/b8  */{BAD_OPCODE},
   /*1b9 0f/b9  */{BAD_OPCODE},
   /*1ba 0f/ba  */{T0,OI(P_RULE2    , 0x2   , 0x90  )},
   /*1bb 0f/bb  */{T5, {{I_BTC16    , A_Ew  , A_Gw  },{I_BTC32    , A_Ed  , A_Gd  }}},
   /*1bc 0f/bc  */{T4, {{I_BSF16    , A_Gw  , A_Ew  },{I_BSF32    , A_Gd  , A_Ed  }}},
   /*1bd 0f/bd  */{T4, {{I_BSR16    , A_Gw  , A_Ew  },{I_BSR32    , A_Gd  , A_Ed  }}},
   /*1be 0f/be  */{T4, {{I_MOVSX8   , A_Gw  , A_Eb  },{I_MOVSX8   , A_Gd  , A_Eb  }}},
   /*1bf 0f/bf  */{T4,OI(I_MOVSX16  , A_Gd  , A_Ew  )},

   /*1c0 0f/c0  */{T8,OI(I_XADD8    , A_Eb  , A_Gb  )},
   /*1c1 0f/c1  */{T8, {{I_XADD16   , A_Ew  , A_Gw  },{I_XADD32   , A_Ed  , A_Gd  }}},
   /*1c2 0f/c2  */{BAD_OPCODE},
   /*1c3 0f/c3  */{BAD_OPCODE},
   /*1c4 0f/c4  */{BAD_OPCODE},
   /*1c5 0f/c5  */{BAD_OPCODE},
   /*1c6 0f/c6  */{BAD_OPCODE},
   /*1c7 0f/c7  */{BAD_OPCODE},
   /*1c8 0f/c8  */{T1,OI(I_BSWAP    , A_Hd  , A_    )},
   /*1c9 0f/c9  */{T1,OI(I_BSWAP    , A_Hd  , A_    )},
   /*1ca 0f/ca  */{T1,OI(I_BSWAP    , A_Hd  , A_    )},
   /*1cb 0f/cb  */{T1,OI(I_BSWAP    , A_Hd  , A_    )},
   /*1cc 0f/cc  */{T1,OI(I_BSWAP    , A_Hd  , A_    )},
   /*1cd 0f/cd  */{T1,OI(I_BSWAP    , A_Hd  , A_    )},
   /*1ce 0f/ce  */{T1,OI(I_BSWAP    , A_Hd  , A_    )},
   /*1cf 0f/cf  */{T1,OI(I_BSWAP    , A_Hd  , A_    )},
#endif /* CPU_286 */

   /*1d0 0f/d0  */{BAD_OPCODE},
   /*1d1 0f/d1  */{BAD_OPCODE},
   /*1d2 0f/d2  */{BAD_OPCODE},
   /*1d3 0f/d3  */{BAD_OPCODE},
   /*1d4 0f/d4  */{BAD_OPCODE},
   /*1d5 0f/d5  */{BAD_OPCODE},
   /*1d6 0f/d6  */{BAD_OPCODE},
   /*1d7 0f/d7  */{BAD_OPCODE},
   /*1d8 0f/d8  */{BAD_OPCODE},
   /*1d9 0f/d9  */{BAD_OPCODE},
   /*1da 0f/da  */{BAD_OPCODE},
   /*1db 0f/db  */{BAD_OPCODE},
   /*1dc 0f/dc  */{BAD_OPCODE},
   /*1dd 0f/dd  */{BAD_OPCODE},
   /*1de 0f/de  */{BAD_OPCODE},
   /*1df 0f/df  */{BAD_OPCODE},

   /*1e0 0f/e0  */{BAD_OPCODE},
   /*1e1 0f/e1  */{BAD_OPCODE},
   /*1e2 0f/e2  */{BAD_OPCODE},
   /*1e3 0f/e3  */{BAD_OPCODE},
   /*1e4 0f/e4  */{BAD_OPCODE},
   /*1e5 0f/e5  */{BAD_OPCODE},
   /*1e6 0f/e6  */{BAD_OPCODE},
   /*1e7 0f/e7  */{BAD_OPCODE},
   /*1e8 0f/e8  */{BAD_OPCODE},
   /*1e9 0f/e9  */{BAD_OPCODE},
   /*1ea 0f/ea  */{BAD_OPCODE},
   /*1eb 0f/eb  */{BAD_OPCODE},
   /*1ec 0f/ec  */{BAD_OPCODE},
   /*1ed 0f/ed  */{BAD_OPCODE},
   /*1ee 0f/ee  */{BAD_OPCODE},
   /*1ef 0f/ef  */{BAD_OPCODE},

   /*1f0 0f/f0  */{BAD_OPCODE},
   /*1f1 0f/f1  */{BAD_OPCODE},
   /*1f2 0f/f2  */{BAD_OPCODE},
   /*1f3 0f/f3  */{BAD_OPCODE},
   /*1f4 0f/f4  */{BAD_OPCODE},
   /*1f5 0f/f5  */{BAD_OPCODE},
   /*1f6 0f/f6  */{BAD_OPCODE},
   /*1f7 0f/f7  */{BAD_OPCODE},
   /*1f8 0f/f8  */{BAD_OPCODE},
   /*1f9 0f/f9  */{BAD_OPCODE},
   /*1fa 0f/fa  */{BAD_OPCODE},
   /*1fb 0f/fb  */{BAD_OPCODE},
   /*1fc 0f/fc  */{BAD_OPCODE},
   /*1fd 0f/fd  */{BAD_OPCODE},
   /*1fe 0f/fe  */{BAD_OPCODE},
   /*1ff 0f/ff  */{BAD_OPCODE},

   /*200 80/0   */{T5,OI(I_ADD8     , A_Eb  , A_Ib  )},
   /*201 80/1   */{T5,OI(I_OR8      , A_Eb  , A_Ib  )},
   /*202 80/2   */{T5,OI(I_ADC8     , A_Eb  , A_Ib  )},
   /*203 80/3   */{T5,OI(I_SBB8     , A_Eb  , A_Ib  )},
   /*204 80/4   */{T5,OI(I_AND8     , A_Eb  , A_Ib  )},
   /*205 80/5   */{T5,OI(I_SUB8     , A_Eb  , A_Ib  )},
   /*206 80/6   */{T5,OI(I_XOR8     , A_Eb  , A_Ib  )},
   /*207 80/7   */{T6,OI(I_CMP8     , A_Eb  , A_Ib  )},

   /*208 81/0   */{T5, {{I_ADD16    , A_Ew  , A_Iw  },{I_ADD32    , A_Ed  , A_Id  }}},
   /*209 81/1   */{T5, {{I_OR16     , A_Ew  , A_Iw  },{I_OR32     , A_Ed  , A_Id  }}},
   /*20a 81/2   */{T5, {{I_ADC16    , A_Ew  , A_Iw  },{I_ADC32    , A_Ed  , A_Id  }}},
   /*20b 81/3   */{T5, {{I_SBB16    , A_Ew  , A_Iw  },{I_SBB32    , A_Ed  , A_Id  }}},
   /*20c 81/4   */{T5, {{I_AND16    , A_Ew  , A_Iw  },{I_AND32    , A_Ed  , A_Id  }}},
   /*20d 81/5   */{T5, {{I_SUB16    , A_Ew  , A_Iw  },{I_SUB32    , A_Ed  , A_Id  }}},
   /*20e 81/6   */{T5, {{I_XOR16    , A_Ew  , A_Iw  },{I_XOR32    , A_Ed  , A_Id  }}},
   /*20f 81/7   */{T6, {{I_CMP16    , A_Ew  , A_Iw  },{I_CMP32    , A_Ed  , A_Id  }}},

   /*210 83/0   */{T5, {{I_ADD16    , A_Ew  , A_Ix  },{I_ADD32    , A_Ed  , A_Iy  }}},
   /*211 83/1   */{T5, {{I_OR16     , A_Ew  , A_Ix  },{I_OR32     , A_Ed  , A_Iy  }}},
   /*212 83/2   */{T5, {{I_ADC16    , A_Ew  , A_Ix  },{I_ADC32    , A_Ed  , A_Iy  }}},
   /*213 83/3   */{T5, {{I_SBB16    , A_Ew  , A_Ix  },{I_SBB32    , A_Ed  , A_Iy  }}},
   /*214 83/4   */{T5, {{I_AND16    , A_Ew  , A_Ix  },{I_AND32    , A_Ed  , A_Iy  }}},
   /*215 83/5   */{T5, {{I_SUB16    , A_Ew  , A_Ix  },{I_SUB32    , A_Ed  , A_Iy  }}},
   /*216 83/6   */{T5, {{I_XOR16    , A_Ew  , A_Ix  },{I_XOR32    , A_Ed  , A_Iy  }}},
   /*217 83/7   */{T6, {{I_CMP16    , A_Ew  , A_Ix  },{I_CMP32    , A_Ed  , A_Iy  }}},

   /*218 8f/0   */{T3, {{I_POP16    , A_Ew  , A_    },{I_POP32    , A_Ed  , A_    }}},
   /*219 8f/1   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*21a 8f/2   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*21b 8f/3   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*21c 8f/4   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*21d 8f/5   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*21e 8f/6   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*21f 8f/7   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},

   /*220 c0/0   */{T5,OI(I_ROL8     , A_Eb  , A_Ib  )},
   /*221 c0/1   */{T5,OI(I_ROR8     , A_Eb  , A_Ib  )},
   /*222 c0/2   */{T5,OI(I_RCL8     , A_Eb  , A_Ib  )},
   /*223 c0/3   */{T5,OI(I_RCR8     , A_Eb  , A_Ib  )},
   /*224 c0/4   */{T5,OI(I_SHL8     , A_Eb  , A_Ib  )},
   /*225 c0/5   */{T5,OI(I_SHR8     , A_Eb  , A_Ib  )},
   /*226 c0/6   */{T5,OI(I_SHL8     , A_Eb  , A_Ib  )},
   /*227 c0/7   */{T5,OI(I_SAR8     , A_Eb  , A_Ib  )},

   /*228 c1/0   */{T5, {{I_ROL16    , A_Ew  , A_Ib  },{I_ROL32    , A_Ed  , A_Ib  }}},
   /*229 c1/1   */{T5, {{I_ROR16    , A_Ew  , A_Ib  },{I_ROR32    , A_Ed  , A_Ib  }}},
   /*22a c1/2   */{T5, {{I_RCL16    , A_Ew  , A_Ib  },{I_RCL32    , A_Ed  , A_Ib  }}},
   /*22b c1/3   */{T5, {{I_RCR16    , A_Ew  , A_Ib  },{I_RCR32    , A_Ed  , A_Ib  }}},
   /*22c c1/4   */{T5, {{I_SHL16    , A_Ew  , A_Ib  },{I_SHL32    , A_Ed  , A_Ib  }}},
   /*22d c1/5   */{T5, {{I_SHR16    , A_Ew  , A_Ib  },{I_SHR32    , A_Ed  , A_Ib  }}},
   /*22e c1/6   */{T5, {{I_SHL16    , A_Ew  , A_Ib  },{I_SHL32    , A_Ed  , A_Ib  }}},
   /*22f c1/7   */{T5, {{I_SAR16    , A_Ew  , A_Ib  },{I_SAR32    , A_Ed  , A_Ib  }}},

   /*230 c6/0   */{T4,OI(I_MOV8     , A_Eb  , A_Ib  )},
   /*231 c6/1   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*232 c6/2   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*233 c6/3   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*234 c6/4   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*235 c6/5   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*236 c6/6   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*237 c6/7   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},

   /*238 c7/0   */{T4, {{I_MOV16    , A_Ew  , A_Iw  },{I_MOV32    , A_Ed  , A_Id  }}},
   /*239 c7/1   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*23a c7/2   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*23b c7/3   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*23c c7/4   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*23d c7/5   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*23e c7/6   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*23f c7/7   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},

   /*240 d0/0   */{T5,OI(I_ROL8     , A_Eb  , A_I1  )},
   /*241 d0/1   */{T5,OI(I_ROR8     , A_Eb  , A_I1  )},
   /*242 d0/2   */{T5,OI(I_RCL8     , A_Eb  , A_I1  )},
   /*243 d0/3   */{T5,OI(I_RCR8     , A_Eb  , A_I1  )},
   /*244 d0/4   */{T5,OI(I_SHL8     , A_Eb  , A_I1  )},
   /*245 d0/5   */{T5,OI(I_SHR8     , A_Eb  , A_I1  )},
   /*246 d0/6   */{T5,OI(I_SHL8     , A_Eb  , A_I1  )},
   /*247 d0/7   */{T5,OI(I_SAR8     , A_Eb  , A_I1  )},

   /*248 d1/0   */{T5, {{I_ROL16    , A_Ew  , A_I1  },{I_ROL32    , A_Ed  , A_I1  }}},
   /*249 d1/1   */{T5, {{I_ROR16    , A_Ew  , A_I1  },{I_ROR32    , A_Ed  , A_I1  }}},
   /*24a d1/2   */{T5, {{I_RCL16    , A_Ew  , A_I1  },{I_RCL32    , A_Ed  , A_I1  }}},
   /*24b d1/3   */{T5, {{I_RCR16    , A_Ew  , A_I1  },{I_RCR32    , A_Ed  , A_I1  }}},
   /*24c d1/4   */{T5, {{I_SHL16    , A_Ew  , A_I1  },{I_SHL32    , A_Ed  , A_I1  }}},
   /*24d d1/5   */{T5, {{I_SHR16    , A_Ew  , A_I1  },{I_SHR32    , A_Ed  , A_I1  }}},
   /*24e d1/6   */{T5, {{I_SHL16    , A_Ew  , A_I1  },{I_SHL32    , A_Ed  , A_I1  }}},
   /*24f d1/7   */{T5, {{I_SAR16    , A_Ew  , A_I1  },{I_SAR32    , A_Ed  , A_I1  }}},

   /*250 d2/0   */{T5,OI(I_ROL8     , A_Eb  , A_Fcl )},
   /*251 d2/1   */{T5,OI(I_ROR8     , A_Eb  , A_Fcl )},
   /*252 d2/2   */{T5,OI(I_RCL8     , A_Eb  , A_Fcl )},
   /*253 d2/3   */{T5,OI(I_RCR8     , A_Eb  , A_Fcl )},
   /*254 d2/4   */{T5,OI(I_SHL8     , A_Eb  , A_Fcl )},
   /*255 d2/5   */{T5,OI(I_SHR8     , A_Eb  , A_Fcl )},
   /*256 d2/6   */{T5,OI(I_SHL8     , A_Eb  , A_Fcl )},
   /*257 d2/7   */{T5,OI(I_SAR8     , A_Eb  , A_Fcl )},

   /*258 d3/0   */{T5, {{I_ROL16    , A_Ew  , A_Fcl },{I_ROL32    , A_Ed  , A_Fcl }}},
   /*259 d3/1   */{T5, {{I_ROR16    , A_Ew  , A_Fcl },{I_ROR32    , A_Ed  , A_Fcl }}},
   /*25a d3/2   */{T5, {{I_RCL16    , A_Ew  , A_Fcl },{I_RCL32    , A_Ed  , A_Fcl }}},
   /*25b d3/3   */{T5, {{I_RCR16    , A_Ew  , A_Fcl },{I_RCR32    , A_Ed  , A_Fcl }}},
   /*25c d3/4   */{T5, {{I_SHL16    , A_Ew  , A_Fcl },{I_SHL32    , A_Ed  , A_Fcl }}},
   /*25d d3/5   */{T5, {{I_SHR16    , A_Ew  , A_Fcl },{I_SHR32    , A_Ed  , A_Fcl }}},
   /*25e d3/6   */{T5, {{I_SHL16    , A_Ew  , A_Fcl },{I_SHL32    , A_Ed  , A_Fcl }}},
   /*25f d3/7   */{T5, {{I_SAR16    , A_Ew  , A_Fcl },{I_SAR32    , A_Ed  , A_Fcl }}},

   /*260 f6/0   */{T6,OI(I_TEST8    , A_Eb  , A_Ib  )},
   /*261 f6/1   */{T6,OI(I_TEST8    , A_Eb  , A_Ib  )},
   /*262 f6/2   */{T1,OI(I_NOT8     , A_Eb  , A_    )},
   /*263 f6/3   */{T1,OI(I_NEG8     , A_Eb  , A_    )},
   /*264 f6/4   */{T5,OI(I_MUL8     , A_Fal , A_Eb  )},
   /*265 f6/5   */{T5,OI(I_IMUL8    , A_Fal , A_Eb  )},
   /*266 f6/6   */{T2,OI(I_DIV8     , A_Eb  , A_    )},
   /*267 f6/7   */{T2,OI(I_IDIV8    , A_Eb  , A_    )},

   /*268 f7/0   */{T6, {{I_TEST16   , A_Ew  , A_Iw  },{I_TEST32   , A_Ed  , A_Id  }}},
   /*269 f7/1   */{T6, {{I_TEST16   , A_Ew  , A_Iw  },{I_TEST32   , A_Ed  , A_Id  }}},
   /*26a f7/2   */{T1, {{I_NOT16    , A_Ew  , A_    },{I_NOT32    , A_Ed  , A_    }}},
   /*26b f7/3   */{T1, {{I_NEG16    , A_Ew  , A_    },{I_NEG32    , A_Ed  , A_    }}},
   /*26c f7/4   */{T5, {{I_MUL16    , A_Fax , A_Ew  },{I_MUL32    , A_Feax, A_Ed  }}},
   /*26d f7/5   */{T5, {{I_IMUL16   , A_Fax , A_Ew  },{I_IMUL32   , A_Feax, A_Ed  }}},
   /*26e f7/6   */{T2, {{I_DIV16    , A_Ew  , A_    },{I_DIV32    , A_Ed  , A_    }}},
   /*26f f7/7   */{T2, {{I_IDIV16   , A_Ew  , A_    },{I_IDIV32   , A_Ed  , A_    }}},

   /*270 fe/0   */{T1,OI(I_INC8     , A_Eb  , A_    )},
   /*271 fe/1   */{T1,OI(I_DEC8     , A_Eb  , A_    )},
   /*272 fe/2   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*273 fe/3   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*274 fe/4   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*275 fe/5   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*276 fe/6   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},
   /*277 fe/7   */{T0,OI(I_ZBADOP   , A_Eb  , A_    )},

   /*278 ff/0   */{T1, {{I_INC16    , A_Ew  , A_    },{I_INC32    , A_Ed  , A_    }}},
   /*279 ff/1   */{T1, {{I_DEC16    , A_Ew  , A_    },{I_DEC32    , A_Ed  , A_    }}},
   /*27a ff/2   */{T2, {{I_CALLN16  , A_Ew  , A_    },{I_CALLN32  , A_Ed  , A_    }}},
   /*27b ff/3   */{T2, {{I_CALLF16  , A_Mp16, A_    },{I_CALLF32  , A_Mp32, A_    }}},
   /*27c ff/4   */{T2, {{I_JMPN     , A_Ew  , A_    },{I_JMPN     , A_Ed  , A_    }}},
   /*27d ff/5   */{T2, {{I_JMPF16   , A_Mp16, A_    },{I_JMPF32   , A_Mp32, A_    }}},
   /*27e ff/6   */{T2, {{I_PUSH16   , A_Ew  , A_    },{I_PUSH32   , A_Ed  , A_    }}},
   /*27f ff/7   */{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},

   /*280 0f/00/0*/{T3,OI(I_SLDT     , A_Ew  , A_    )},
   /*281 0f/00/1*/{T3,OI(I_STR      , A_Ew  , A_    )},
   /*282 0f/00/2*/{T2,OI(I_LLDT     , A_Ew  , A_    )},
   /*283 0f/00/3*/{T2,OI(I_LTR      , A_Ew  , A_    )},
   /*284 0f/00/4*/{T2,OI(I_VERR     , A_Ew  , A_    )},
   /*285 0f/00/5*/{T2,OI(I_VERW     , A_Ew  , A_    )},
   /*286 0f/00/6*/{T0,OI(I_ZBADOP   , A_Ew  , A_    )},
   /*287 0f/00/7*/{T0,OI(I_ZBADOP   , A_Ew  , A_    )},

   /*288 0f/01/0*/{T3, {{I_SGDT16   , A_Ms  , A_    },{I_SGDT32   , A_Ms  , A_    }}},
   /*289 0f/01/1*/{T3, {{I_SIDT16   , A_Ms  , A_    },{I_SIDT32   , A_Ms  , A_    }}},
   /*28a 0f/01/2*/{T2, {{I_LGDT16   , A_Ms  , A_    },{I_LGDT32   , A_Ms  , A_    }}},
   /*28b 0f/01/3*/{T2, {{I_LIDT16   , A_Ms  , A_    },{I_LIDT32   , A_Ms  , A_    }}},
   /*28c 0f/01/4*/{T3,OI(I_SMSW     , A_Ew  , A_    )},
   /*28d 0f/01/5*/{T0,OI(I_ZBADOP   , A_Ew  , A_    )},
   /*28e 0f/01/6*/{T2,OI(I_LMSW     , A_Ew  , A_    )},
#ifdef CPU_286
   /*28f 0f/01/7*/{T0,OI(I_ZBADOP   , A_Ew  , A_    )},
#else
   /*28f 0f/01/7*/{TB,OI(I_INVLPG   , A_M   , A_    )},
#endif /* CPU_286 */

   /*290 0f/ba/0*/{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*291 0f/ba/1*/{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*292 0f/ba/2*/{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*293 0f/ba/3*/{T0, {{I_ZBADOP   , A_Ew  , A_    },{I_ZBADOP   , A_Ed  , A_    }}},
   /*294 0f/ba/4*/{T6, {{I_BT16     , A_Ew  , A_Ib  },{I_BT32     , A_Ed  , A_Ib  }}},
   /*295 0f/ba/5*/{T5, {{I_BTS16    , A_Ew  , A_Ib  },{I_BTS32    , A_Ed  , A_Ib  }}},
   /*296 0f/ba/6*/{T5, {{I_BTR16    , A_Ew  , A_Ib  },{I_BTR32    , A_Ed  , A_Ib  }}},
   /*297 0f/ba/7*/{T5, {{I_BTC16    , A_Ew  , A_Ib  },{I_BTC32    , A_Ed  , A_Ib  }}},

   /*298 PAD    */{BAD_OPCODE},
   /*299 PAD    */{BAD_OPCODE},
   /*29a PAD    */{BAD_OPCODE},
   /*29b PAD    */{BAD_OPCODE},
   /*29c PAD    */{BAD_OPCODE},
   /*29d PAD    */{BAD_OPCODE},
   /*29e PAD    */{BAD_OPCODE},
   /*29f PAD    */{BAD_OPCODE},

   /*2a0 d8/0   */{T5,OI(I_FADD     , A_Vt  , A_Mr32)},
   /*2a1 d8/1   */{T5,OI(I_FMUL     , A_Vt  , A_Mr32)},
   /*2a2 d8/2   */{T5,OI(I_FCOM     , A_Vt  , A_Mr32)},
   /*2a3 d8/3   */{T5,OI(I_FCOMP    , A_Vt  , A_Mr32)},
   /*2a4 d8/4   */{T5,OI(I_FSUB     , A_Vt  , A_Mr32)},
   /*2a5 d8/5   */{T5,OI(I_FSUBR    , A_Vt  , A_Mr32)},
   /*2a6 d8/6   */{T5,OI(I_FDIV     , A_Vt  , A_Mr32)},
   /*2a7 d8/7   */{T5,OI(I_FDIVR    , A_Vt  , A_Mr32)},

   /*2a8 d8/m3/0*/{T5,OI(I_FADD     , A_Vt  , A_Vn  )},
   /*2a9 d8/m3/1*/{T5,OI(I_FMUL     , A_Vt  , A_Vn  )},
   /*2aa d8/m3/2*/{T5,OI(I_FCOM     , A_Vt  , A_Vn  )},
   /*2ab d8/m3/3*/{T5,OI(I_FCOMP    , A_Vt  , A_Vn  )},
   /*2ac d8/m3/4*/{T5,OI(I_FSUB     , A_Vt  , A_Vn  )},
   /*2ad d8/m3/5*/{T5,OI(I_FSUBR    , A_Vt  , A_Vn  )},
   /*2ae d8/m3/6*/{T5,OI(I_FDIV     , A_Vt  , A_Vn  )},
   /*2af d8/m3/7*/{T5,OI(I_FDIVR    , A_Vt  , A_Vn  )},

   /*2b0 d9/0   */{T4,OI(I_FLD      , A_Vq  , A_Mr32)},
   /*2b1 d9/1   */{T2,OI(I_ZFRSRVD  , A_M   , A_    )},
   /*2b2 d9/2   */{T4,OI(I_FST      , A_Mr32, A_Vt  )},
   /*2b3 d9/3   */{T4,OI(I_FSTP     , A_Mr32, A_Vt  )},
   /*2b4 d9/4   */{T2, {{I_FLDENV16 , A_M14 , A_    },{I_FLDENV32 , A_M28 , A_    }}},
   /*2b5 d9/5   */{T2,OI(I_FLDCW    , A_Mw  , A_    )},
   /*2b6 d9/6   */{T3, {{I_FSTENV16 , A_M14 , A_    },{I_FSTENV32 , A_M28 , A_    }}},
   /*2b7 d9/7   */{T3,OI(I_FSTCW    , A_Mw  , A_    )},

   /*2b8 d9/m3/0*/{T4,OI(I_FLD      , A_Vq  , A_Vn  )},
   /*2b9 d9/m3/1*/{T8,OI(I_FXCH     , A_Vt  , A_Vn  )},
   /*2ba d9/m3/2*/{T0,OI(P_RULE5    , 0x3   , 0x20  )},
   /*2bb d9/m3/3*/{T4,OI(I_FSTP     , A_Vn  , A_Vt  )},
   /*2bc d9/m3/4*/{T0,OI(P_RULE5    , 0x3   , 0x28  )},
   /*2bd d9/m3/5*/{T0,OI(P_RULE5    , 0x3   , 0x30  )},
   /*2be d9/m3/6*/{T0,OI(P_RULE5    , 0x3   , 0x38  )},
   /*2bf d9/m3/7*/{T0,OI(P_RULE5    , 0x3   , 0x40  )},

   /*2c0 da/0   */{T5,OI(I_FIADD    , A_Vt  , A_Mi32)},
   /*2c1 da/1   */{T5,OI(I_FIMUL    , A_Vt  , A_Mi32)},
   /*2c2 da/2   */{T5,OI(I_FICOM    , A_Vt  , A_Mi32)},
   /*2c3 da/3   */{T5,OI(I_FICOMP   , A_Vt  , A_Mi32)},
   /*2c4 da/4   */{T5,OI(I_FISUB    , A_Vt  , A_Mi32)},
   /*2c5 da/5   */{T5,OI(I_FISUBR   , A_Vt  , A_Mi32)},
   /*2c6 da/6   */{T5,OI(I_FIDIV    , A_Vt  , A_Mi32)},
   /*2c7 da/7   */{T5,OI(I_FIDIVR   , A_Vt  , A_Mi32)},

   /*2c8 da/m3/0*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2c9 da/m3/1*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2ca da/m3/2*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2cb da/m3/3*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2cc da/m3/4*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2cd da/m3/5*/{T0,OI(P_RULE5    , 0x3   , 0x48  )},
   /*2ce da/m3/6*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2cf da/m3/7*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*2d0 db/0   */{T4,OI(I_FILD     , A_Vq  , A_Mi32)},
   /*2d1 db/1   */{T2,OI(I_ZFRSRVD  , A_M   , A_    )},
   /*2d2 db/2   */{T4,OI(I_FIST     , A_Mi32, A_Vt  )},
   /*2d3 db/3   */{T4,OI(I_FISTP    , A_Mi32, A_Vt  )},
   /*2d4 db/4   */{T2,OI(I_ZFRSRVD  , A_M   , A_    )},
   /*2d5 db/5   */{T4,OI(I_FLD      , A_Vq  , A_Mr80)},
   /*2d6 db/6   */{T2,OI(I_ZFRSRVD  , A_M   , A_    )},
   /*2d7 db/7   */{T4,OI(I_FSTP     , A_Mr80, A_Vt  )},

   /*2d8 db/m3/0*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2d9 db/m3/1*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2da db/m3/2*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2db db/m3/3*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2dc db/m3/4*/{T0,OI(P_RULE5    , 0x3   , 0x50  )},
   /*2dd db/m3/5*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2de db/m3/6*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2df db/m3/7*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*2e0 dc/0   */{T5,OI(I_FADD     , A_Vt  , A_Mr64)},
   /*2e1 dc/1   */{T5,OI(I_FMUL     , A_Vt  , A_Mr64)},
   /*2e2 dc/2   */{T5,OI(I_FCOM     , A_Vt  , A_Mr64)},
   /*2e3 dc/3   */{T5,OI(I_FCOMP    , A_Vt  , A_Mr64)},
   /*2e4 dc/4   */{T5,OI(I_FSUB     , A_Vt  , A_Mr64)},
   /*2e5 dc/5   */{T5,OI(I_FSUBR    , A_Vt  , A_Mr64)},
   /*2e6 dc/6   */{T5,OI(I_FDIV     , A_Vt  , A_Mr64)},
   /*2e7 dc/7   */{T5,OI(I_FDIVR    , A_Vt  , A_Mr64)},

   /*2e8 dc/m3/0*/{T5,OI(I_FADD     , A_Vn  , A_Vt  )},
   /*2e9 dc/m3/1*/{T5,OI(I_FMUL     , A_Vn  , A_Vt  )},
   /*2ea dc/m3/2*/{T5,OI(I_FCOM     , A_Vt  , A_Vn  )},
   /*2eb dc/m3/3*/{T5,OI(I_FCOMP    , A_Vt  , A_Vn  )},
   /*2ec dc/m3/4*/{T5,OI(I_FSUBR    , A_Vn  , A_Vt  )},
   /*2ed dc/m3/5*/{T5,OI(I_FSUB     , A_Vn  , A_Vt  )},
   /*2ee dc/m3/6*/{T5,OI(I_FDIVR    , A_Vn  , A_Vt  )},
   /*2ef dc/m3/7*/{T5,OI(I_FDIV     , A_Vn  , A_Vt  )},

   /*2f0 dd/0   */{T4,OI(I_FLD      , A_Vq  , A_Mr64)},
   /*2f1 dd/1   */{T2,OI(I_ZFRSRVD  , A_M   , A_    )},
   /*2f2 dd/2   */{T4,OI(I_FST      , A_Mr64, A_Vt  )},
   /*2f3 dd/3   */{T4,OI(I_FSTP     , A_Mr64, A_Vt  )},
   /*2f4 dd/4   */{T2, {{I_FRSTOR16 , A_M94 , A_    },{I_FRSTOR32 , A_M108, A_    }}},
   /*2f5 dd/5   */{T2,OI(I_ZFRSRVD  , A_M   , A_    )},
   /*2f6 dd/6   */{T3, {{I_FSAVE16  , A_M94 , A_    },{I_FSAVE32  , A_M108, A_    }}},
   /*2f7 dd/7   */{T3,OI(I_FSTSW    , A_Mw  , A_    )},

   /*2f8 dd/m3/0*/{T2,OI(I_FFREE    , A_Vn  , A_    )},
   /*2f9 dd/m3/1*/{T8,OI(I_FXCH     , A_Vt  , A_Vn  )},
   /*2fa dd/m3/2*/{T4,OI(I_FST      , A_Vn  , A_Vt  )},
   /*2fb dd/m3/3*/{T4,OI(I_FSTP     , A_Vn  , A_Vt  )},
#ifdef CPU_286
   /*2fc dd/m3/4*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2fd dd/m3/5*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
#else
   /*2fc dd/m3/4*/{T6,OI(I_FUCOM    , A_Vn  , A_Vt  )},
   /*2fd dd/m3/5*/{T6,OI(I_FUCOMP   , A_Vn  , A_Vt  )},
#endif /* CPU_286 */
   /*2fe dd/m3/6*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*2ff dd/m3/7*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*300 de/0   */{T5,OI(I_FIADD    , A_Vt  , A_Mi16)},
   /*301 de/1   */{T5,OI(I_FIMUL    , A_Vt  , A_Mi16)},
   /*302 de/2   */{T5,OI(I_FICOM    , A_Vt  , A_Mi16)},
   /*303 de/3   */{T5,OI(I_FICOMP   , A_Vt  , A_Mi16)},
   /*304 de/4   */{T5,OI(I_FISUB    , A_Vt  , A_Mi16)},
   /*305 de/5   */{T5,OI(I_FISUBR   , A_Vt  , A_Mi16)},
   /*306 de/6   */{T5,OI(I_FIDIV    , A_Vt  , A_Mi16)},
   /*307 de/7   */{T5,OI(I_FIDIVR   , A_Vt  , A_Mi16)},

   /*308 de/m3/0*/{T5,OI(I_FADDP    , A_Vn  , A_Vt  )},
   /*309 de/m3/1*/{T5,OI(I_FMULP    , A_Vn  , A_Vt  )},
   /*30a de/m3/2*/{T5,OI(I_FCOMP    , A_Vt  , A_Vn  )},
   /*30b de/m3/3*/{T0,OI(P_RULE5    , 0x3   , 0x58  )},
   /*30c de/m3/4*/{T5,OI(I_FSUBRP   , A_Vn  , A_Vt  )},
   /*30d de/m3/5*/{T5,OI(I_FSUBP    , A_Vn  , A_Vt  )},
   /*30e de/m3/6*/{T5,OI(I_FDIVRP   , A_Vn  , A_Vt  )},
   /*30f de/m3/7*/{T5,OI(I_FDIVP    , A_Vn  , A_Vt  )},

   /*310 df/0   */{T4,OI(I_FILD     , A_Vq  , A_Mi16)},
   /*311 df/1   */{T2,OI(I_ZFRSRVD  , A_M   , A_    )},
   /*312 df/2   */{T4,OI(I_FIST     , A_Mi16, A_Vt  )},
   /*313 df/3   */{T4,OI(I_FISTP    , A_Mi16, A_Vt  )},
   /*314 df/4   */{T4,OI(I_FBLD     , A_Vq  , A_Mi80)},
   /*315 df/5   */{T4,OI(I_FILD     , A_Vq  , A_Mi64)},
   /*316 df/6   */{T4,OI(I_FBSTP    , A_Mi80, A_Vt  )},
   /*317 df/7   */{T4,OI(I_FISTP    , A_Mi64, A_Vt  )},

   /*318 df/m3/0*/{T2,OI(I_FFREEP   , A_Vn  , A_    )},
   /*319 df/m3/1*/{T8,OI(I_FXCH     , A_Vt  , A_Vn  )},
   /*31a df/m3/2*/{T4,OI(I_FSTP     , A_Vn  , A_Vt  )},
   /*31b df/m3/3*/{T4,OI(I_FSTP     , A_Vn  , A_Vt  )},
   /*31c df/m3/4*/{T0,OI(P_RULE5    , 0x3   , 0x60  )},
   /*31d df/m3/5*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*31e df/m3/6*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*31f df/m3/7*/{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*320 d9/d0  */{T0,OI(I_FNOP     , A_    , A_    )},
   /*321 d9/d1  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*322 d9/d2  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*323 d9/d3  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*324 d9/d4  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*325 d9/d5  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*326 d9/d6  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*327 d9/d7  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*328 d9/e0  */{T1,OI(I_FCHS     , A_Vt  , A_    )},
   /*329 d9/e1  */{T1,OI(I_FABS     , A_Vt  , A_    )},
   /*32a d9/e2  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*32b d9/e3  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*32c d9/e4  */{T2,OI(I_FTST     , A_Vt  , A_    )},
   /*32d d9/e5  */{T2,OI(I_FXAM     , A_Vt  , A_    )},
   /*32e d9/e6  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*32f d9/e7  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*330 d9/e8  */{T3,OI(I_FLD1     , A_Vq  , A_    )},
   /*331 d9/e9  */{T3,OI(I_FLDL2T   , A_Vq  , A_    )},
   /*332 d9/ea  */{T3,OI(I_FLDL2E   , A_Vq  , A_    )},
   /*333 d9/eb  */{T3,OI(I_FLDPI    , A_Vq  , A_    )},
   /*334 d9/ec  */{T3,OI(I_FLDLG2   , A_Vq  , A_    )},
   /*335 d9/ed  */{T3,OI(I_FLDLN2   , A_Vq  , A_    )},
   /*336 d9/ee  */{T3,OI(I_FLDZ     , A_Vq  , A_    )},
   /*337 d9/ef  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*338 d9/f0  */{T1,OI(I_F2XM1    , A_Vt  , A_    )},
   /*339 d9/f1  */{T5,OI(I_FYL2X    , A_Vt  , A_V1  )},
   /*33a d9/f2  */{T4,OI(I_FPTAN    , A_Vq  , A_Vt  )},
   /*33b d9/f3  */{T5,OI(I_FPATAN   , A_Vt  , A_V1  )},
   /*33c d9/f4  */{T4,OI(I_FXTRACT  , A_Vq  , A_Vt  )},
#ifdef CPU_286
   /*33d d9/f5  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
#else
   /*33d d9/f5  */{T5,OI(I_FPREM1   , A_Vt  , A_V1  )},
#endif /* CPU_286 */
   /*33e d9/f6  */{T0,OI(I_FDECSTP  , A_    , A_    )},
   /*33f d9/f7  */{T0,OI(I_FINCSTP  , A_    , A_    )},

   /*340 d9/f8  */{T5,OI(I_FPREM    , A_Vt  , A_V1  )},
   /*341 d9/f9  */{T5,OI(I_FYL2XP1  , A_Vt  , A_V1  )},
   /*342 d9/fa  */{T1,OI(I_FSQRT    , A_Vt  , A_    )},
#ifdef CPU_286
   /*343 d9/fb  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
#else
   /*343 d9/fb  */{T4,OI(I_FSINCOS  , A_Vq  , A_Vt  )},
#endif /* CPU_286 */
   /*344 d9/fc  */{T1,OI(I_FRNDINT  , A_Vt  , A_    )},
   /*345 d9/fd  */{T5,OI(I_FSCALE   , A_Vt  , A_V1  )},
#ifdef CPU_286
   /*346 d9/fe  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*347 d9/ff  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
#else
   /*346 d9/fe  */{T1,OI(I_FSIN     , A_Vt  , A_    )},
   /*347 d9/ff  */{T1,OI(I_FCOS     , A_Vt  , A_    )},
#endif /* CPU_286 */

   /*348 da/e8  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
#ifdef CPU_286
   /*349 da/e9  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
#else
   /*349 da/e9  */{T6,OI(I_FUCOMPP  , A_Vt  , A_V1  )},
#endif /* CPU_286 */
   /*34a da/ea  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*34b da/eb  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*34c da/ec  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*34d da/ed  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*34e da/ee  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*34f da/ef  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*350 db/e0  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*351 db/e1  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*352 db/e2  */{T0,OI(I_FCLEX    , A_    , A_    )},
   /*353 db/e3  */{T0,OI(I_FINIT    , A_    , A_    )},

#ifdef NPX_287
   /*354 db/e4  */{T0,OI(I_FSETPM   , A_    , A_    )},
#else
   /*354 db/e4  */{T0,OI(I_FNOP     , A_    , A_    )},
#endif /* NPX_287 */

   /*355 db/e5  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*356 db/e6  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*357 db/e7  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*358 de/d8  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*359 de/d9  */{T6,OI(I_FCOMPP   , A_Vt  , A_V1  )},
   /*35a de/da  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*35b de/db  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*35c de/dc  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*35d de/dd  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*35e de/de  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*35f de/df  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*360 df/e0  */{T3,OI(I_FSTSW    , A_Fax , A_    )},
   /*361 df/e1  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*362 df/e2  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*363 df/e3  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*364 df/e4  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*365 df/e5  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*366 df/e6  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},
   /*367 df/e7  */{T0,OI(I_ZFRSRVD  , A_    , A_    )},

   /*368    6c  */{T4,OI(I_INSB     , A_Yb  , A_Fdx )},
   /*369 f2/6c  */{T4,OI(I_R_INSB   , A_Yb  , A_Fdx )},
   /*36a f3/6c  */{T4,OI(I_R_INSB   , A_Yb  , A_Fdx )},
   /*36b    6d  */{T4, {{I_INSW     , A_Yw  , A_Fdx },{I_INSD     , A_Yd  , A_Fdx }}},
   /*36c f2/6d  */{T4, {{I_R_INSW   , A_Yw  , A_Fdx },{I_R_INSD   , A_Yd  , A_Fdx }}},
   /*36d f3/6d  */{T4, {{I_R_INSW   , A_Yw  , A_Fdx },{I_R_INSD   , A_Yd  , A_Fdx }}},

   /*36e    6e  */{T6,OI(I_OUTSB    , A_Fdx , A_Xb  )},
   /*36f f2/6e  */{T6,OI(I_R_OUTSB  , A_Fdx , A_Xb  )},
   /*370 f3/6e  */{T6,OI(I_R_OUTSB  , A_Fdx , A_Xb  )},
   /*371    6f  */{T6, {{I_OUTSW    , A_Fdx , A_Xw  },{I_OUTSD    , A_Fdx , A_Xd  }}},
   /*372 f2/6f  */{T6, {{I_R_OUTSW  , A_Fdx , A_Xw  },{I_R_OUTSD  , A_Fdx , A_Xd  }}},
   /*373 f3/6f  */{T6, {{I_R_OUTSW  , A_Fdx , A_Xw  },{I_R_OUTSD  , A_Fdx , A_Xd  }}},

   /*374    a4  */{T4,OI(I_MOVSB    , A_Yb  , A_Xb  )},
   /*375 f2/a4  */{T4,OI(I_R_MOVSB  , A_Yb  , A_Xb  )},
   /*376 f3/a4  */{T4,OI(I_R_MOVSB  , A_Yb  , A_Xb  )},
   /*377    a5  */{T4, {{I_MOVSW    , A_Yw  , A_Xw  },{I_MOVSD    , A_Yd  , A_Xd  }}},
   /*378 f2/a5  */{T4, {{I_R_MOVSW  , A_Yw  , A_Xw  },{I_R_MOVSD  , A_Yd  , A_Xd  }}},
   /*379 f3/a5  */{T4, {{I_R_MOVSW  , A_Yw  , A_Xw  },{I_R_MOVSD  , A_Yd  , A_Xd  }}},

   /*37a    a6  */{T6,OI(I_CMPSB    , A_Xb  , A_Yb  )},
   /*37b f2/a6  */{T6,OI(I_RNE_CMPSB, A_Xb  , A_Yb  )},
   /*37c f3/a6  */{T6,OI(I_RE_CMPSB , A_Xb  , A_Yb  )},
   /*37d    a7  */{T6, {{I_CMPSW    , A_Xw  , A_Yw  },{I_CMPSD    , A_Xd  , A_Yd  }}},
   /*37e f2/a7  */{T6, {{I_RNE_CMPSW, A_Xw  , A_Yw  },{I_RNE_CMPSD, A_Xd  , A_Yd  }}},
   /*37f f3/a7  */{T6, {{I_RE_CMPSW , A_Xw  , A_Yw  },{I_RE_CMPSD , A_Xd  , A_Yd  }}},

   /*380    aa  */{T4,OI(I_STOSB    , A_Yb  , A_Fal )},
   /*381 f2/aa  */{T4,OI(I_R_STOSB  , A_Yb  , A_Fal )},
   /*382 f3/aa  */{T4,OI(I_R_STOSB  , A_Yb  , A_Fal )},
   /*383    ab  */{T4, {{I_STOSW    , A_Yw  , A_Fax },{I_STOSD    , A_Yd  , A_Feax}}},
   /*384 f2/ab  */{T4, {{I_R_STOSW  , A_Yw  , A_Fax },{I_R_STOSD  , A_Yd  , A_Feax}}},
   /*385 f3/ab  */{T4, {{I_R_STOSW  , A_Yw  , A_Fax },{I_R_STOSD  , A_Yd  , A_Feax}}},

   /*386    ac  */{T4,OI(I_LODSB    , A_Fal , A_Xb  )},
   /*387 f2/ac  */{T4,OI(I_R_LODSB  , A_Fal , A_Xb  )},
   /*388 f3/ac  */{T4,OI(I_R_LODSB  , A_Fal , A_Xb  )},
   /*389    ad  */{T4, {{I_LODSW    , A_Fax , A_Xw  },{I_LODSD    , A_Feax, A_Xd  }}},
   /*38a f2/ad  */{T4, {{I_R_LODSW  , A_Fax , A_Xw  },{I_R_LODSD  , A_Feax, A_Xd  }}},
   /*38b f3/ad  */{T4, {{I_R_LODSW  , A_Fax , A_Xw  },{I_R_LODSD  , A_Feax, A_Xd  }}},

   /*38c    ae  */{T6,OI(I_SCASB    , A_Fal , A_Yb  )},
   /*38d f2/ae  */{T6,OI(I_RNE_SCASB, A_Fal , A_Yb  )},
   /*38e f3/ae  */{T6,OI(I_RE_SCASB , A_Fal , A_Yb  )},
   /*38f    af  */{T6, {{I_SCASW    , A_Fax , A_Yw  },{I_SCASD    , A_Feax, A_Yd  }}},
   /*390 f2/af  */{T6, {{I_RNE_SCASW, A_Fax , A_Yw  },{I_RNE_SCASD, A_Feax, A_Yd  }}},
   /*391 f3/af  */{T6, {{I_RE_SCASW , A_Fax , A_Yw  },{I_RE_SCASD , A_Feax, A_Yd  }}},

   /*392 PAD    */{BAD_OPCODE},
   /*393 PAD    */{BAD_OPCODE},

   /*394 c4/BOP */{T6,OI(I_ZBOP     , A_Ib  , A_Bop3b )},
   /*395 c4/BOP */{T6,OI(I_ZBOP     , A_Ib  , A_Iw    )},
   /*396 c4/BOP */{T6,OI(I_ZBOP     , A_Ib  , A_Ib    )},
   /*397 c4/BOP */{T2,OI(I_ZBOP     , A_Ib  , A_      )},
   /*398 c4/LES */{T4, {{I_LES      , A_Gw  , A_Mp16},{I_LES      , A_Gd  , A_Mp32}}},
   /*399 PAD    */{BAD_OPCODE},

   /*39a e0 e0     */{T2, {{I_LOOPNE16 , A_Fcx , A_Jb  },{I_LOOPNE32 , A_Fcx , A_Jb  }}},
   /*39b e0 e0     */{T2, {{I_LOOPNE16 , A_Fecx , A_Jb  },{I_LOOPNE32 , A_Fecx , A_Jb  }}},
   /*39c e1 e1     */{T2, {{I_LOOPE16  , A_Fcx , A_Jb  },{I_LOOPE32  , A_Fcx , A_Jb  }}},
   /*39d e1 e1     */{T2, {{I_LOOPE16  , A_Fecx , A_Jb  },{I_LOOPE32  , A_Fecx , A_Jb  }}},
   /*39e e2 e2     */{T2, {{I_LOOP16   , A_Fcx , A_Jb  },{I_LOOP32   , A_Fcx , A_Jb  }}},
   /*39f e2 e2     */{T2, {{I_LOOP16   , A_Fecx , A_Jb  },{I_LOOP32   , A_Fecx , A_Jb  }}},
   /*3a0 e3 e3     */{T2, {{I_JCXZ     , A_Fcx , A_Jb  },{I_JECXZ    , A_Fcx , A_Jb  }}},
   /*3a1 e3 e3     */{T2, {{I_JCXZ     , A_Fecx , A_Jb  },{I_JECXZ    , A_Fecx , A_Jb  }}}

   };

#undef BAD_OPCODE
#undef OI

/*
   Define Maximum valid segment register in a 3-bit 'reg' field.
 */
#ifdef SPC386

#define MAX_VALID_SEG 5

#else

#define MAX_VALID_SEG 3

#endif /* SPC386 */

/*
   Information for each Intel memory addressing mode.
 */

/*    - displacement info. */
#define D_NO	(UTINY)0
#define D_S8	(UTINY)1
#define D_S16	(UTINY)2
#define D_Z16	(UTINY)3
#define D_32	(UTINY)4

LOCAL UTINY addr_disp[2][3][8] =
   {
   /* 16-bit addr */
   { {D_NO , D_NO , D_NO , D_NO , D_NO , D_NO , D_Z16, D_NO },
     {D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 },
     {D_S16, D_S16, D_S16, D_S16, D_S16, D_S16, D_S16, D_S16} },
   /* 32-bit addr */
   { {D_NO , D_NO , D_NO , D_NO , D_NO , D_32 , D_NO , D_NO },
     {D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 , D_S8 },
     {D_32 , D_32 , D_32 , D_32 , D_32 , D_32 , D_32 , D_32 } }
   };

/*    - default segment info. */
LOCAL ULONG addr_default_segment[2][3][8] =
   {
   /* 16-bit addr */
   { {A_DS , A_DS , A_SS , A_SS , A_DS , A_DS , A_DS , A_DS },
     {A_DS , A_DS , A_SS , A_SS , A_DS , A_DS , A_SS , A_DS },
     {A_DS , A_DS , A_SS , A_SS , A_DS , A_DS , A_SS , A_DS } },
   /* 32-bit addr */
   { {A_DS , A_DS , A_DS , A_DS , A_SS , A_DS , A_DS , A_DS },
     {A_DS , A_DS , A_DS , A_DS , A_SS , A_SS , A_DS , A_DS },
     {A_DS , A_DS , A_DS , A_DS , A_SS , A_SS , A_DS , A_DS } }
   };

/*    - addressing type info. */
/* Table fillers - never actually referenced */
#define A_3204	(USHORT)0
#define A_3214	(USHORT)0
#define A_3224	(USHORT)0

LOCAL USHORT addr_maintype[3][3][8] =
   {
   /* 16-bit addr */
   { {A_1600, A_1601, A_1602, A_1603, A_1604, A_1605, A_1606, A_1607},
     {A_1610, A_1611, A_1612, A_1613, A_1614, A_1615, A_1616, A_1617},
     {A_1620, A_1621, A_1622, A_1623, A_1624, A_1625, A_1626, A_1627} },
   /* 32-bit addr, no SIB */
   { {A_3200, A_3201, A_3202, A_3203, A_3204, A_3205, A_3206, A_3207},
     {A_3210, A_3211, A_3212, A_3213, A_3214, A_3215, A_3216, A_3217},
     {A_3220, A_3221, A_3222, A_3223, A_3224, A_3225, A_3226, A_3227} },
   /* 32-bit addr, with SIB */
   { {A_32S00, A_32S01, A_32S02, A_32S03, A_32S04, A_32S05, A_32S06, A_32S07},
     {A_32S10, A_32S11, A_32S12, A_32S13, A_32S14, A_32S15, A_32S16, A_32S17},
     {A_32S20, A_32S21, A_32S22, A_32S23, A_32S24, A_32S25, A_32S26, A_32S27} }
   };

/*    - addressing sub type info. */
LOCAL UTINY addr_subtype[4][8] =
   {
   {A_SI00, A_SI01, A_SI02, A_SI03, A_SI04, A_SI05, A_SI06, A_SI07},
   {A_SI10, A_SI11, A_SI12, A_SI13, A_SI14, A_SI15, A_SI16, A_SI17},
   {A_SI20, A_SI21, A_SI22, A_SI23, A_SI24, A_SI25, A_SI26, A_SI27},
   {A_SI30, A_SI31, A_SI32, A_SI33, A_SI34, A_SI35, A_SI36, A_SI37}
   };

/*
   The allowable types of segment override.
   See also "d_oper.h" for segment register names.
 */
#define SEG_CLR (ULONG)7

/*
   The (additional) allowable types of address override.
 */
#define ADDR_32SIB	(UTINY)2

/*
   The allowable types of repeat prefix.
 */
#define REP_CLR (UTINY)0
#define REP_NE  (UTINY)1
#define REP_E   (UTINY)2

/*
   Shift's and Mask's required to access addressing components.
 */
#define SHIFT_543   3   /* shift for bits 5-3 */
#define SHIFT_76    6   /* shift for bits 7-6 */
#define MASK_10   0x3   /* mask for bits 1-0 */
#define MASK_210  0x7   /* mask for bits 2-0 */

/*
   Macros to access varies addressing fields.
 */
#define GET_MODE(x)  ((x) >> SHIFT_76 & MASK_10)
#define GET_R_M(x)   ((x) & MASK_210)
#define GET_XXX(x)   ((x) >> SHIFT_543 & MASK_210)
#define GET_REG(x)   ((x) >> SHIFT_543 & MASK_210)
#define GET_SEG(x)   ((x) >> SHIFT_543 & MASK_210)
#define GET_EEE(x)   ((x) >> SHIFT_543 & MASK_210)
#define GET_SEG3(x)  ((x) >> SHIFT_543 & MASK_210)
#define GET_SEG2(x)  ((x) >> SHIFT_543 & MASK_10)
#define GET_SS(x)    ((x) >> SHIFT_76 & MASK_10)
#define GET_INDEX(x) ((x) >> SHIFT_543 & MASK_210)
#define GET_BASE(x)  ((x) & MASK_210)
#define GET_LOW3(x)  ((x) & MASK_210)

/*
   Procedure to flip (invert) current status of a two-way choice
 */
#define FLIP(c, o, x, y) \
   if ( o == x )         \
      c = y;             \
   else                  \
      c = x

/*
   Procedure to extract new opcode from operand arguments.
 */
#define XREF() ((USHORT)arg[0] << 8 | arg[1])

/*
   =====================================================================
   EXECUTION STARTS HERE.
   =====================================================================
 */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Decode Intel opcode stream into INST arg1,arg2,arg3 form.          */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
GLOBAL void
decode IFN4 (
	LIN_ADDR, p,		/* pntr to Intel opcode stream */
	DECODED_INST *, d_inst,	/* pntr to decoded instruction structure */
	SIZE_SPECIFIER, default_size, /* Default operand_size OP_16 or OP_32 */
	read_byte_proc, f)	/* like sas_hw_at() or equivalent to read
				 * a byte from p, but will return -1 if
				 * unable to return a byte.
				 */
{

   UTINY address_default;  /* Default address size */
   UTINY operand_default;  /* Default operand size */

   /* Per instruction prefix varients */
   ULONG segment_override;
   UTINY address_size;
   UTINY operand_size;
   UTINY repeat;

   USHORT inst;		/* Working copy of instruction identifier */
   UTINY  inst_type;	/* Working copy of instruction type */
   UTINY  arg[3];	/* Working copy of operand types */

   USHORT opcode;
   UTINY decoding;	/* Working copy of addressing byte(s) */

   DECODED_ARG *d_arg;  /* current decoded argument */

   LIN_ADDR start_of_inst;   /* pntr to start of opcode stream */
   LIN_ADDR start_of_addr;   /* pntr to start of addressing bytes */

   /* Variables used in memory address decoding */
   UTINY mode;        /* Working copy of 'mode' field */
   UTINY r_m;         /* Working copy of 'R/M' field */
   USHORT maintype;   /* Working copy of decoded address type */
   UTINY subtype;     /* Working copy of decoded address sub type */
   ULONG disp;        /* Working copy of displacement */
   ULONG immed;       /* Working copy of immediate operands */

   INT i;

   /*
      Initialisation.
    */
   if ( default_size == SIXTEEN_BIT )
      {
      address_default = ADDR_16;
      operand_default = OP_16;
      }
   else   /* assume OP_32 */
      {
      address_default = ADDR_32;
      operand_default = OP_32;
      }

   arg[2] = A_;
   start_of_inst = NOTE_INST_LOCN(p);

   /*
      First handle prefix bytes.
    */
   segment_override = SEG_CLR;
   address_size = address_default;
   operand_size = operand_default;
   repeat = REP_CLR;

   while ( (inst = opcode_info[INST_BYTE(f,p)].record[operand_size].inst_id) > MAX_PSEUDO )
      {
      switch ( inst )
	 {
      case P_AO:    FLIP(address_size, address_default, ADDR_16, ADDR_32);  break;
      case P_OO:    FLIP(operand_size, operand_default, OP_16, OP_32);      break;

      case P_CS:    segment_override = A_CS;  break;
      case P_DS:    segment_override = A_DS;  break;
      case P_ES:    segment_override = A_ES;  break;
      case P_FS:    segment_override = A_FS;  break;
      case P_GS:    segment_override = A_GS;  break;
      case P_SS:    segment_override = A_SS;  break;

      case P_REPE:  repeat = REP_E;   break;
      case P_REPNE: repeat = REP_NE;  break;

      case P_LOCK:  /* doesn't require action */  break;
      case P_F1:    /* doesn't require action */  break;

         /*
          * Could be a garbaged read from memory that doesn't exist -
          * stop it at once!
          */
      default:	
	 d_inst->inst_id = I_ZBADOP;
	 d_inst->prefix_sz = (UTINY)(p - start_of_inst);
         d_inst->inst_sz = (UTINY)(p - start_of_inst + 1);
         return;
	 }
      p++;
      }

   /*
      Now handle the opcode.
    */
   d_inst->operand_size = operand_size;
   d_inst->address_size = address_size;
   d_inst->prefix_sz = (UTINY)(p-start_of_inst);
   opcode = (USHORT)INST_BYTE(f,p);

   while ( 1 )
      {
      /* RULE 1 */
      inst_type = opcode_info[opcode].inst_type;
      inst = opcode_info[opcode].record[operand_size].inst_id;
      arg[0] = opcode_info[opcode].record[operand_size].arg1_type;
      arg[1] = opcode_info[opcode].record[operand_size].arg2_type;

      if ( inst > MAX_DECODED_INST )
	 {
	 /* invoke an instruction decoding rule. */
	 switch ( inst )
	    {
	 case P_RULE2:
	    /*
	       The instruction is further decoded by the 'xxx' field of
	       the following Addressing Byte.
	     */
	    opcode = XREF() + GET_XXX(INST_OFFSET_BYTE(f,p,1));
	    break;
	
	 case P_RULE3:
	    /*
	       The instruction is further decoded by a second Opcode
	       Byte.
	     */
	    p++;   /* move onto second Opcode byte */
	    opcode = (USHORT)(XREF() + INST_BYTE(f,p));   /* form pseudo opcode */
	    break;
	
	 case P_RULE4:
	    /*
	       The instruction is further decoded by the 'xxx' field and
	       'mode' field of the following Addressing Byte.
	     */
	    opcode = XREF() + GET_XXX(INST_OFFSET_BYTE(f,p,1));
	    if ( GET_MODE(INST_OFFSET_BYTE(f,p,1)) == 3 )
	       {
	       p++;  /* move onto second Opcode byte */
	       opcode += 8;
	       }
	    break;

	 case P_RULE5:
	    /*
	       The instruction is further decoded by the 'r_m' field of
	       the Addressing Byte.
	     */
	    opcode = XREF() + GET_R_M(INST_BYTE(f,p));
	    break;
	
	 case P_RULE6:
	    /*
	       The instruction is further decoded by the absence or
	       presence of a repeat prefix.
	     */
	    opcode = XREF() + repeat;
	    /* Kill any repeat prefix after use */
	    repeat = REP_CLR;

	    break;

	 case P_RULE7:
	    /*
	       The instruction is further decoded by the 'mode' field and 'r_m'
	       field of the following Addressing Byte. The instruction is either an LES or
	       a BOP.
	       BOP c4 c4 take no argument
	       BOP c4 c5 take a 1 byte argument
	       BOP c4 c6 take a 2 byte argument
	       BOP c4 c7 take a 3 byte argument
	     */
	    opcode = XREF();
	    if ((INST_OFFSET_BYTE(f,p,1) & 0xfc) == 0xc4)
	       {
	       /* this is a BOP -- notice this SUBTRACTS from opcode! */
	       opcode -= 1 + (INST_OFFSET_BYTE(f,p,1) & 0x3);
	       p++;  /* move over second Opcode byte */
	       }
	    break;

	 case P_RULE8:
	    /*
	       The instruction is further decoded by applying the
	       addressing size over-ride.
	     */
	    opcode = XREF() + address_size;
	    break;

	    }
	 continue;
	 }

      /* Intel instruction found */
      p++;
      break;
      }

   /*
      At this point we can handle redundant repeat prefix bytes.
      Because all instructions that can have a valid repeat prefix
      byte consume this byte any instance of the repeat prefix
      being set at this point indicates it was applied to an
      instruction which does not take the repeat prefix.
    */
   ;   /* quietly ignore them */

   /* save info related to instruction */
   d_inst->inst_id = inst;
   start_of_addr = NOTE_INST_LOCN(p);

   /*
      Finally handle arguments (ie addressing and immediate fields).
    */

   /* decode up to three arguments */
   for ( i = 0; i < 3; i++ )
      {
      /* look first for special encoding */
      if ( arg[i] > MAX_NORMAL )
	 {
	 /* decode compressed argument */
	 switch ( arg[i] )
	    {
	 case A_EwIw: arg[i] = A_Ew; arg[i+1] = A_Iw;  break;
	 case A_EwIx: arg[i] = A_Ew; arg[i+1] = A_Ix;  break;
	 case A_EdId: arg[i] = A_Ed; arg[i+1] = A_Id;  break;
	 case A_EdIy: arg[i] = A_Ed; arg[i+1] = A_Iy;  break;
	 case A_GwCL: arg[i] = A_Gw; arg[i+1] = A_Fcl; break;
	 case A_GwIb: arg[i] = A_Gw; arg[i+1] = A_Ib;  break;
	 case A_GdCL: arg[i] = A_Gd; arg[i+1] = A_Fcl; break;
	 case A_GdIb: arg[i] = A_Gd; arg[i+1] = A_Ib;  break;
	 case A_EwIz: arg[i] = A_Ew; arg[i+1] = A_Iz;  break;
	 case A_EwIv: arg[i] = A_Ew; arg[i+1] = A_Iv;  break;
	    }
	 }

      /* now action processing rule for operand */
      d_arg = &d_inst->args[i];

      /* determine addressability */
      d_arg->addressability = aa_rules[inst_type][i];

      switch ( arg[i] )
	 {
      case A_:   /* No argument */
	 d_arg->arg_type = A_;
	 break;

      /* GENERAL REGISTER ENCODINGS ==================================*/

      case A_Hb:   /* low 3 bits of last opcode
		      denotes byte register */
	 d_arg->arg_type = A_Rb;
	 d_arg->identifier = GET_LOW3(INST_OFFSET_BYTE(f,start_of_addr, -1));
	 break;

      case A_Hw:   /* low 3 bits of last opcode
		      denotes word register */
	 d_arg->arg_type = A_Rw;
	 d_arg->identifier = GET_LOW3(INST_OFFSET_BYTE(f,start_of_addr, -1));
	 break;

      case A_Hd:   /* low 3 bits of last opcode
		      denotes double word register */
	 d_arg->arg_type = A_Rd;
	 d_arg->identifier = GET_LOW3(INST_OFFSET_BYTE(f,start_of_addr, -1));
	 break;

      case A_Gb:   /* 'reg' field of modR/M byte
		      denotes byte register */
	 d_arg->arg_type = A_Rb;
	 d_arg->identifier = GET_REG(GET_INST_BYTE(f,start_of_addr));
	 break;

      case A_Gw:   /* 'reg' field of modR/M byte
		      denotes word register */
	 d_arg->arg_type = A_Rw;
	 d_arg->identifier = GET_REG(GET_INST_BYTE(f,start_of_addr));
	 break;

      case A_Gd:   /* 'reg' field of modR/M byte
		      denotes double word register */
	 d_arg->arg_type = A_Rd;
	 d_arg->identifier = GET_REG(GET_INST_BYTE(f,start_of_addr));
	 break;

      case A_Fal:   /* fixed register, AL */
	 d_arg->arg_type = A_Rb;
	 d_arg->identifier = A_AL;
	 break;

      case A_Fcl:   /* fixed register, CL */
	 d_arg->arg_type = A_Rb;
	 d_arg->identifier = A_CL;
	 break;

      case A_Fax:   /* fixed register, AX */
	 d_arg->arg_type = A_Rw;
	 d_arg->identifier = A_AX;
	 break;

      case A_Fcx:   /* fixed register, CX */
	 d_arg->arg_type = A_Rw;
	 d_arg->identifier = A_CX;
	 break;

      case A_Fdx:   /* fixed register, DX */
	 d_arg->arg_type = A_Rw;
	 d_arg->identifier = A_DX;
	 break;

      case A_Feax:   /* fixed register, EAX */
	 d_arg->arg_type = A_Rd;
	 d_arg->identifier = A_EAX;
	 break;

      case A_Fecx:   /* fixed register, ECX */
	 d_arg->arg_type = A_Rd;
	 d_arg->identifier = A_ECX;
	 break;

      /* SEGMENT REGISTER ENCODINGS ==================================*/

      case A_Pw:   /* two bits(4-3) of last opcode byte
		      denotes segment register */
	 d_arg->arg_type = A_Sw;
	 d_arg->identifier = GET_SEG2(INST_OFFSET_BYTE(f,start_of_addr, -1));
	 break;

      case A_Qw:   /* three bits(5-3) of last opcode byte
		      denotes segment register */
	 d_arg->arg_type = A_Sw;
	 d_arg->identifier = GET_SEG3(INST_OFFSET_BYTE(f,start_of_addr, -1));
	 break;

      case A_Lw:   /* 'reg' field of modR/M byte
		      denotes segment register (CS not valid) */
	 decoding = GET_SEG(GET_INST_BYTE(f,start_of_addr));
	 if ( decoding > MAX_VALID_SEG || decoding == 1 )
	    {
	    /* CS access not allowed -- force a bad op. */
	    d_inst->inst_id = I_ZBADOP;
	    break;
	    }
	 d_arg->arg_type = A_Sw;
	 d_arg->identifier = decoding;
	 break;

      case A_Nw:   /* 'reg' field of modR/M byte
		      denotes segment register */
	 decoding = GET_SEG(GET_INST_BYTE(f,start_of_addr));
	 if ( decoding > MAX_VALID_SEG )
	    {
	    /* CS access not allowed -- force a bad op. */
	    d_inst->inst_id = I_ZBADOP;
	    break;
	    }
	 d_arg->arg_type = A_Sw;
	 d_arg->identifier = decoding;
	 break;

      /* CONTROL/DEBUG/TEST REGISTER ENCODINGS =======================*/

      case A_Cd:   /* 'reg' field of modR/M byte
		      denotes control register */
	 d_arg->arg_type = A_Cd;
	 d_arg->identifier = GET_EEE(GET_INST_BYTE(f,start_of_addr));
	 break;

      case A_Dd:   /* 'reg' field of modR/M byte
		      denotes debug register */
	 d_arg->arg_type = A_Dd;
	 d_arg->identifier = GET_EEE(GET_INST_BYTE(f,start_of_addr));
	 break;

      case A_Td:   /* 'reg' field of modR/M byte
		      denotes test register */
	 d_arg->arg_type = A_Td;
	 d_arg->identifier = GET_EEE(GET_INST_BYTE(f,start_of_addr));
	 break;

      /* MEMORY ADDRESSING ENCODINGS =================================*/

      case A_Rd:   /* ('mode') and 'r/m' fields must refer to
		      a double word register */
	 d_arg->arg_type = A_Rd;
	 decoding = (UTINY)INST_BYTE(f,p);
#ifdef INTEL_BOOK_NOT_OS2
	 if ( GET_MODE(decoding) != 3 )
	    {
	    /* memory access not allowed -- force a bad op. */
	    d_inst->inst_id = I_ZBADOP;
	    d_arg->arg_type = A_;
	    break;
	    }
#endif /* INTEL_BOOK_NOT_OS2 */
	 p++;
	 d_arg->identifier = GET_R_M(decoding);
	 break;

      case A_M:   /* 'mode' and 'r/m' fields of modR/M byte
		     must denote memory address */
      case A_Ms:
      case A_Mw:
      case A_Ma16:
      case A_Ma32:
      case A_Mp16:
      case A_Mp32:
	 decoding = (UTINY)INST_BYTE(f,p);   /* peek at modR/M byte */
	 if ( GET_MODE(decoding) == 3 )
	    {
	    /* register access not allowed -- force a bad op. */
	    p++;   /* allow for errant modR/M byte */
	    d_inst->inst_id = I_ZBADOP;
#ifdef OLDPIG
	    if ( INST_OFFSET_BYTE(f,p, -2) == 0xc5 &&
		 INST_OFFSET_BYTE(f,p, -1) == 0xc5 )
	       d_inst->inst_id = I_ZZEXIT;
#endif /* OLDPIG */
	    break;
	    }
	
	 /* otherwise handle just like 'E' case */
	
      case A_Eb:   /* 'mode' and 'r/m' fields of modR/M byte
		      denote general register or memory address */
      case A_Ew:
      case A_Ed:
      case A_Ex:
      case A_Mi16:
      case A_Mi32:
      case A_Mi64:
      case A_Mi80:
      case A_Mr32:
      case A_Mr64:
      case A_Mr80:
      case A_M14:
      case A_M28:
      case A_M94:
      case A_M108:
	 decoding = (UTINY)GET_INST_BYTE(f,p);   /* get modR/M byte */
	 mode = GET_MODE(decoding);
	 r_m  = GET_R_M(decoding);

	 if ( mode == 3 )
	    {
	    /* register addressing */
	    switch ( arg[i] )
	       {
	    case A_Eb: d_arg->arg_type = A_Rb; break;
	    case A_Ew: d_arg->arg_type = A_Rw; break;
	    case A_Ed: d_arg->arg_type = A_Rd; break;
	    case A_Ex: d_arg->arg_type = A_Rd; break;
	       }
	    d_arg->identifier = r_m;
	    }
	 else
	    {
	    /* memory addressing */
	    switch ( arg[i] )
	       {
	    case A_Eb:   d_arg->arg_type = A_Mb;   break;
	    case A_Ew:   d_arg->arg_type = A_Mw;   break;
	    case A_Ed:   d_arg->arg_type = A_Md;   break;
	    case A_Ex:   d_arg->arg_type = A_Mw;   break;

	    case A_M:
	    case A_Ms:
	    case A_Mw:
	    case A_Ma16:
	    case A_Ma32:
	    case A_Mp16:
	    case A_Mp32:
	    case A_Mi16:
	    case A_Mi32:
	    case A_Mi64:
	    case A_Mi80:
	    case A_Mr32:
	    case A_Mr64:
	    case A_Mr80:
	    case A_M14:
	    case A_M28:
	    case A_M94:
	    case A_M108:
	       d_arg->arg_type = arg[i];
	       break;
	       }

	    /* check for presence of SIB byte */
	    if ( address_size == ADDR_32 && r_m == 4 )
	       {
	       /* process SIB byte */
	       decoding = (UTINY)GET_INST_BYTE(f,p);   /* get SIB byte */

	       /* subvert the original r_m value with the base value,
		  then addressing mode, displacements and default
		  segments all fall out in the wash */
	       r_m = GET_BASE(decoding);

	       /* determine decoded type */
	       subtype = addr_subtype[GET_SS(decoding)][GET_INDEX(decoding)];
	       maintype = addr_maintype[ADDR_32SIB][mode][r_m];
	       }
	    else
	       {
	       /* no SIB byte */
	       subtype = A_SINO;
	       maintype = addr_maintype[address_size][mode][r_m];
	       }

	    /* encode type and sub type */
	    d_arg->identifier = maintype;
	    d_arg->sub_id = subtype;

	    /* encode segment register */
	    if ( segment_override == SEG_CLR )
	       segment_override = addr_default_segment[address_size][mode][r_m];
	
	    d_arg->arg_values[0] = segment_override;

	    /* encode displacement */
	    switch ( addr_disp[address_size][mode][r_m] )
	       {
	    case D_NO:    /* No displacement */
	       disp = 0;
	       break;

	    case D_S8:    /* Sign extend Intel byte */
	       disp = GET_INST_BYTE(f,p);
	       if ( disp & 0x80 )
		  disp |= 0xffffff00;
	       break;

	    case D_S16:   /* Sign extend Intel word */
	       disp = GET_INST_BYTE(f,p);
	       disp |= (ULONG)GET_INST_BYTE(f,p) << 8;
	       if ( disp & 0x8000 )
		  disp |= 0xffff0000;
	       break;

	    case D_Z16:   /* Zero extend Intel word */
	       disp = GET_INST_BYTE(f,p);
	       disp |= (ULONG)GET_INST_BYTE(f,p) << 8;
	       break;

	    case D_32:    /* Intel double word */
	       disp = GET_INST_BYTE(f,p);
	       disp |= (ULONG)GET_INST_BYTE(f,p) << 8;
	       disp |= (ULONG)GET_INST_BYTE(f,p) << 16;
	       disp |= (ULONG)GET_INST_BYTE(f,p) << 24;
	       break;
	       }

	    d_arg->arg_values[1] = disp;
	    }
	 break;

      case A_Ob:   /* offset encoded in instruction stream */
      case A_Ow:
      case A_Od:
	 /* encode segment register */
	 if ( segment_override == SEG_CLR )
	    segment_override = A_DS;
	
	 d_arg->arg_values[0] = segment_override;

	 /* encode type and displacement */
	 switch ( address_size )
	    {
	 case ADDR_16:
	    disp = GET_INST_BYTE(f,p);
	    disp |= (ULONG)GET_INST_BYTE(f,p) << 8;
	    d_arg->identifier = A_MOFFS16;
	    break;

	 case ADDR_32:
	    disp = GET_INST_BYTE(f,p);
	    disp |= (ULONG)GET_INST_BYTE(f,p) << 8;
	    disp |= (ULONG)GET_INST_BYTE(f,p) << 16;
	    disp |= (ULONG)GET_INST_BYTE(f,p) << 24;
	    d_arg->identifier = A_MOFFS32;
	    break;
	    }
	 d_arg->arg_values[1] = disp;

	 /* encode sub type */
	 d_arg->sub_id = A_SINO;

	 /* determine external 'name' */
	 switch ( arg[i] )
	    {
	 case A_Ob: d_arg->arg_type = A_Mb; break;
	 case A_Ow: d_arg->arg_type = A_Mw; break;
	 case A_Od: d_arg->arg_type = A_Md; break;
	    }
	 break;

      case A_Z:   /* 'xlat' addressing form */
	 /* encode type and sub type */
	 if ( address_size == ADDR_16 )
	    maintype = A_16XLT;
	 else
	    maintype = A_32XLT;
	 d_arg->identifier = maintype;
	 d_arg->sub_id = A_SINO;

	 /* encode segment register */
	 if ( segment_override == SEG_CLR )
	    segment_override = A_DS;
	
	 d_arg->arg_values[0] = segment_override;

	 /* encode displacement */
	 d_arg->arg_values[1] = 0;

	 d_arg->arg_type = A_Mb;
	 break;

      case A_Xb:   /* string source addressing */
      case A_Xw:
      case A_Xd:
	 /* encode type and sub type */
	 if ( address_size == ADDR_16 )
	    maintype = A_16STSRC;
	 else
	    maintype = A_32STSRC;
	 d_arg->identifier = maintype;
	 d_arg->sub_id = A_SINO;

	 /* encode segment register */
	 if ( segment_override == SEG_CLR )
	    segment_override = A_DS;
	
	 d_arg->arg_values[0] = segment_override;

	 /* encode displacement */
	 d_arg->arg_values[1] = 0;

	 /* determine external type */
	 switch ( arg[i] )
	    {
	 case A_Xb: d_arg->arg_type = A_Mb; break;
	 case A_Xw: d_arg->arg_type = A_Mw; break;
	 case A_Xd: d_arg->arg_type = A_Md; break;
	    }
	 break;

      case A_Yb:   /* string destination addressing */
      case A_Yw:
      case A_Yd:
	 /* encode type and sub type */
	 if ( address_size == ADDR_16 )
	    maintype = A_16STDST;
	 else
	    maintype = A_32STDST;
	 d_arg->identifier = maintype;
	 d_arg->sub_id = A_SINO;

	 /* encode segment register */
	 d_arg->arg_values[0] = A_ES;

	 /* encode displacement */
	 d_arg->arg_values[1] = 0;

	 /* determine external type */
	 switch ( arg[i] )
	    {
	 case A_Yb: d_arg->arg_type = A_Mb; break;
	 case A_Yw: d_arg->arg_type = A_Mw; break;
	 case A_Yd: d_arg->arg_type = A_Md; break;
	    }
	 break;

      /* IMMEDIATE/RELATIVE OFFSET ENCODINGS =========================*/

      case A_I0:   /* immediate(0) implied within instruction */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMC;
	 d_arg->arg_values[0] = 0;
	 break;

      case A_I1:   /* immediate(1) implied within instruction */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMC;
	 d_arg->arg_values[0] = 1;
	 break;

      case A_I3:   /* immediate(3) implied within instruction */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMC;
	 d_arg->arg_values[0] = 3;
	 break;

      case A_Ib:   /* immediate byte */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMB;
	 d_arg->arg_values[0] = GET_INST_BYTE(f,p);
	 break;

      case A_Iv:   /* immediate word, printed as double */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMD;
	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Iw:   /* immediate word */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMW;
	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Id:   /* immediate double word */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMD;
	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 16;
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 24;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Iz:   /* immediate byte sign extended to word, printed as double */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMDB;
	 immed = GET_INST_BYTE(f,p);
	 if ( immed & 0x80 )
	    immed |= 0xff00;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Iy:   /* immediate byte sign extended to double word */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMDB;
	 immed = GET_INST_BYTE(f,p);
	 if ( immed & 0x80 )
	    immed |= 0xffffff00;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Ix:   /* immediate byte sign extended to word */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMWB;
	 immed = GET_INST_BYTE(f,p);
	 if ( immed & 0x80 )
	    immed |= 0xff00;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Bop3b:   /* BOP argument: 3 bytes in double */
	 d_arg->arg_type = A_I;
	 d_arg->identifier = A_IMMD;
	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 16;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Jb:   /* relative offset byte sign extended to double word */
	 d_arg->arg_type = A_J;
	 immed = GET_INST_BYTE(f,p);
	 if ( immed & 0x80 )
	    immed |= 0xffffff00;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Jb2:   /* like A_Jb, but might be a "Jcc .+3; JMPN dest" pair
		     * which both the EDL and CCPUs treat as a single instruction.
		     * Be careful that the Jcc .+03 is not adjacent to a page boundary.
		     */
	 d_arg->arg_type = A_J;
	 immed = GET_INST_BYTE(f,p);
	 if ( immed & 0x80 )
	    immed |= 0xffffff00;
	 if ( ( immed == 3 ) && (( p & 0xfff) != 0x000) )
	 {
	    LIN_ADDR pj = p;
	    IU32 jmpn = GET_INST_BYTE(f,pj);

	    if (jmpn == 0xe9)
	    {
	       immed = GET_INST_BYTE(f,pj);
	       immed |= ((ULONG)GET_INST_BYTE(f,pj) << 8);
	       if ( immed & 0x8000 )
	          immed |= 0xffff0000;
	       p = pj;
	       switch(d_inst->inst_id)
	       {
	       case I_JO16:	d_inst->inst_id = I_JNO16;  break;
	       case I_JNO16:	d_inst->inst_id = I_JO16;   break;
	       case I_JB16:	d_inst->inst_id = I_JNB16;  break;
	       case I_JNB16:	d_inst->inst_id = I_JB16;   break;
	       case I_JZ16:	d_inst->inst_id = I_JNZ16;  break;
	       case I_JNZ16:	d_inst->inst_id = I_JZ16;   break;
	       case I_JBE16:	d_inst->inst_id = I_JNBE16; break;
	       case I_JNBE16:	d_inst->inst_id = I_JBE16;  break;
	       case I_JS16:	d_inst->inst_id = I_JNS16;  break;
	       case I_JNS16:	d_inst->inst_id = I_JS16;   break;
	       case I_JP16:	d_inst->inst_id = I_JNP16;  break;
	       case I_JNP16:	d_inst->inst_id = I_JP16;   break;
	       case I_JL16:	d_inst->inst_id = I_JNL16;  break;
	       case I_JNL16:	d_inst->inst_id = I_JL16;   break;
	       case I_JLE16:	d_inst->inst_id = I_JNLE16; break;
	       case I_JNLE16:	d_inst->inst_id = I_JLE16;  break;
	       default: 	/* can never happen */	    break;
	       }
	    }
	 }
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Jw:   /* relative offset word sign extended to double word */
	 d_arg->arg_type = A_J;
	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 if ( immed & 0x8000 )
	    immed |= 0xffff0000;
	 d_arg->arg_values[0] = immed;
	 break;

      case A_Jd:   /* relative offset double word */
	 d_arg->arg_type = A_J;
	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 16;
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 24;
	 d_arg->arg_values[0] = immed;
	 break;

      /* DIRECT ADDRESS ENCODINGS ====================================*/

      case A_Aw:   /* direct address <off16><seg> in instruction stream */
	 d_arg->arg_type = A_K;

	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 d_arg->arg_values[0] = immed;

	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 d_arg->arg_values[1] = immed;
	 break;

      case A_Ad:   /* direct address <off32><seg> in instruction stream */
	 d_arg->arg_type = A_K;

	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 16;
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 24;
	 d_arg->arg_values[0] = immed;

	 immed = GET_INST_BYTE(f,p);
	 immed |= (ULONG)GET_INST_BYTE(f,p) << 8;
	 d_arg->arg_values[1] = immed;
	 break;

      /* CO-PROCESSOR REGISTER STACK ENCODINGS =======================*/

      case A_Vt:   /* stack top */
	 d_arg->arg_type = A_V;
	 d_arg->identifier = A_ST;
	 d_arg->arg_values[0] = 0;
	 break;

      case A_Vq:   /* push onto stack top */
	 d_arg->arg_type = A_V;
	 d_arg->identifier = A_STP;
	 d_arg->arg_values[0] = 0;
	 break;

      case A_Vn:   /* stack register relative to stack top */
	 d_arg->arg_type = A_V;
	 d_arg->identifier = A_STI;
	 d_arg->arg_values[0] = GET_LOW3(INST_OFFSET_BYTE(f,start_of_addr, -1));
	 break;

      case A_V1:   /* stack register(1) relative to stack top */
	 d_arg->arg_type = A_V;
	 d_arg->identifier = A_STI;
	 d_arg->arg_values[0] = 1;
	 break;
	 } /* end switch */
      } /* end for */

   d_inst->inst_sz = (UTINY)(p - start_of_inst);
   } /* end 'decode' */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\profile.c ===
/*[
*************************************************************************

	Name:		profile.c
	Author:		Simon Frost
	Created:	September 1993
	Derived from:	Original
	Sccs ID:	@(#)profile.c	1.19 01/31/95
	Purpose:	Support for Profiling system

	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.

*************************************************************************
]*/

/*(
 * Glossary:
 * EOI - Event of Interest
 * SOI - Section of Interest (between two events)
 * Raw Data Buffer - captures minimum data from event when triggered.
 * Raw Data Buffer flush - process the buffer when full or time available
 *			 to summarise in EOI & SOI lists.
 )*/

/*
 * NB: heap unfriendly in places - could get several structs at a go.
 */


#include "insignia.h"
#include "host_def.h"

#include <stdio.h>
#include StringH

#include CpuH
#include "debug.h"
#include "trace.h"
#include "profile.h"

#ifdef PROFILE		/* Don't want this all the time */

#include TimeH		/* clock_t and clock() */
#include <stdlib.h>	/* provides prototype for getenv() */

/***** DEFINES *****/
#define EOIHEADS 16
#define EOIHASH EOIHEADS-1

#define RAWDATAENTRIES 10000	/* # of EOI entries in raw data buffer */

#define INITIALENABLESIZE	1024L  /* start enable count */

#define LISTSORTINCR	5000L	/* trigger point for list sorting */

#define USECASFLOAT	((DOUBLE)1000000.0)

/***** GLOBALS *****/

GLOBAL EOI_BUFFER_FORMAT *ProfileRawData = (EOI_BUFFER_FORMAT *)0;
						/* Pointer to Raw Data Buffer */
GLOBAL EOI_BUFFER_FORMAT *MaxProfileData;	/* Buffer Full pointer */
GLOBAL EOI_BUFFER_FORMAT **AddProfileData;	/* Address in GDP of current position in buffer */
GLOBAL IU8 *EOIEnable;				/* Pointer to EOI enable table */
GLOBAL EOINODE_PTR *EOIDir;			/* Directory of EOIs by handle */
GLOBAL IBOOL	CollectingMaxMin = FALSE;	/* sanity check data collection*/
GLOBAL IBOOL Profiling_enabled = TRUE;		/* Disable conventional profiling
						 *   used with SIGPROF / PROD lcif */

	/* Profiling hooks in C Code */
/* extern EOIHANDLE cleanupFromWhereAmI_START,
		 cleanupFromWhereAmI_END;	* FmDebug.c *
*/

/***** LOCAL DATA ****/
LOCAL SOIHANDLE MaxSOI = 0L;			/* Creation of handles for New ?OIs */
LOCAL EOIHANDLE MaxEOI = INITIALENABLESIZE;
LOCAL EOIHANDLE CurMaxEOI = 0L;

LOCAL EOINODE_PTR EventsOfInterest = EOIPTRNULL;      /* Head of EOI list */
LOCAL EOINODE_PTR LastEOI = EOIPTRNULL;		/* Last EOI changed */
LOCAL EOINODE_PTR LastAuto = EOIPTRNULL;	/* Last AutoSOI 'hot' EOI */
LOCAL SOINODE_PTR SectionsOfInterest = SOIPTRNULL;	/* Head of SOI list */
LOCAL SOINODE_PTR LastSOI = SOIPTRNULL;		/* current end of SOI list */
LOCAL GRAPHLIST_PTR EventGraph = GRAPHPTRNULL;	/* Head of event graph list */
LOCAL GRAPHLIST_PTR LastGraph = GRAPHPTRNULL;	/* Previous event graph node */

LOCAL PROF_TIMESTAMP ProfFlushTime = {0L, 0L};	/* time spent in flush routine*/
LOCAL PROF_TIMESTAMP BufStartTime = {0L, 0L};	/* FIX overflowing timestamps */
LOCAL ISM32 ProfFlushCount = 0;			/* # flush routine called */
LOCAL EOIHANDLE elapsed_time_start, elapsed_time_end;
LOCAL IU8 start_time[26];
LOCAL clock_t elapsed_t_start, elapsed_t_resettable;
LOCAL DOUBLE TicksPerSec;

#ifndef macintosh

/* For Unix ports, use the times() system call to obtain info
 * on how much of the processor time was spent elsewhere in
 * the system.
 */
#include <sys/times.h>		/* for times() and struct tms */
#include UnistdH		/* for sysconf() and _SC_CLK_TICK */

LOCAL struct tms process_t_start, process_t_resettable;

#define host_times(x)	times(x)

#else  /* macintosh */

/* Macintosh doesn't have processes or process times, but we do have
 * clock() which provides a value of type clock_t.
 */
#define host_times(x)	clock()

#endif /* !macintosh */

/***** LOCAL FN ****/
LOCAL void listSort IPT1 (SORTSTRUCT_PTR, head);
LOCAL EOINODE_PTR findEOI IPT1 (EOIHANDLE, findHandle);
LOCAL SOINODE_PTR findSOI IPT1 (SOIHANDLE, findHandle);
LOCAL EOINODE_PTR addEOI IPT3 (EOIHANDLE, newhandle, char, *tag, IU8, attrib);
LOCAL IBOOL updateEOI IPT1 (IUH, **rawdata);
LOCAL void addSOIlinktoEOIs IPT3 (EOIHANDLE, soistart, EOIHANDLE, soiend, SOINODE_PTR, soiptr);
LOCAL void printEOIGuts IPT5 (FILE, *stream, EOINODE_PTR, eoin, DOUBLE, ftotal, IBOOL, parg, IBOOL, report);
LOCAL void spaces IPT2(FILE, *stream, ISM32, curindent);
LOCAL EOINODE_PTR addAutoSOI IPT4 (EOINODE_PTR, from, EOIARG_PTR, fromArg,
				       PROF_TIMEPTR, fromTime, EOINODE_PTR, to);
LOCAL void getPredefinedEOIs IPT0();
LOCAL void updateSOIstarts IPT1(PROF_TIMEPTR, startflush);

/* Here lieth code... */

void  sdbsucks()
{
}
/*(
=============================== findEOI =============================

PURPOSE: Find an event in the EventsOfInterest list.

INPUT: findHandle: handle of EOI to find

OUTPUT: Return pointer to EOI node requested or Null if not found.

=========================================================================
)*/

LOCAL EOINODE_PTR
findEOI IFN1 (EOIHANDLE, findHandle)
{
    return( *(EOIDir + findHandle) );
}

/*(
=============================== findSOI =============================

PURPOSE: Find an event in the EventsOfInterest list.

INPUT: findHandle: handle of SOI to find

OUTPUT: Return pointer to SOI node requested or Null if not found.

=========================================================================
)*/

LOCAL SOINODE_PTR
findSOI IFN1 (SOIHANDLE, findHandle)
{
    SOINODE_PTR soin;	/* list walker */

    soin = SectionsOfInterest;			/* head of list */

    while(soin != SOIPTRNULL)			/* list null terminated */
    {
	if (soin->handle == findHandle)
	    break;
	soin = soin->next;
    }
    return(soin);		/* return pointer to found node or Null */
}

/*(
============================ addAutoSOI ============================

PURPOSE: Add a SOI entry for an Auto SOI connection. May be '2nd level'
	 i.e. distinguished by arg so can't use Associate fn.

INPUT: from: EOI node that starts SOI.
       fromArg: Arg node in 'from' that starts SOI. (say 'cheese')
       fromTime: Timestamp from previous Auto EOI.
       to: EOI node that ends SOI.

OUTPUT: 

=========================================================================
)*/

LOCAL EOINODE_PTR
addAutoSOI IFN4 (EOINODE_PTR, from, EOIARG_PTR, fromArg, PROF_TIMEPTR, fromTime, EOINODE_PTR, to)
{
    SOILIST_PTR soilist, *nlist;	/* list walkers */
    SOINODE_PTR newsoi;		/* pointer to new Soi node */

    /* mark EOIs as valid for SOI updates */
    from->flags |= EOI_HAS_SOI;
    to->flags |= EOI_HAS_SOI;

    if (SectionsOfInterest == SOIPTRNULL)
    {
	SectionsOfInterest = (SOINODE_PTR)host_malloc(sizeof(SOINODE));
	if (SectionsOfInterest == SOIPTRNULL)
	{
	    assert0(NO, "Profiler:addAutoSOI - Out of Memory");
	    return;
	}
	newsoi = SectionsOfInterest;
    }
    else
    {

	/* LastSOI points at current last elem in SOI list */
	if (LastSOI == SOIPTRNULL || LastSOI->next != SOIPTRNULL)	/* sanity check BUGBUG */
	{
	    if (LastSOI == SOIPTRNULL)
	    {
		assert0(NO, "addAutoSOI, LastSOI NULL");
	    }
	    else
	    {
		assert1(NO, "addAutoSOI, LastSOI-Next wrong (%#x)", LastSOI->next);
	    }
	}
	LastSOI->next = (SOINODE_PTR)host_malloc(sizeof(SOINODE));
	if (LastSOI->next == SOIPTRNULL)
	{
	    assert0(NO, "Profiler:addAutoSOI - Out of Memory");
	    return;
	}
	newsoi = LastSOI->next;
    }

    newsoi->handle = MaxSOI++;	/* new handle */
    newsoi->startEOI = from->handle;
    newsoi->endEOI = to->handle;
    newsoi->startArg = fromArg;
    newsoi->endArg = to->lastArg;
    newsoi->startCount = newsoi->endCount = 1L;
    newsoi->soistart.data[0] = fromTime->data[0];
    newsoi->soistart.data[1] = fromTime->data[1];
    newsoi->discardCount = 0L;
    newsoi->bigtime = 0.0;
    newsoi->bigmax = 0.0;
    newsoi->next = SOIPTRNULL;
    newsoi->flags = SOI_AUTOSOI;
    newsoi->time = HostProfUSecs(HostTimestampDiff(fromTime, &to->timestamp));
    newsoi->mintime = newsoi->maxtime = newsoi->time;

    LastSOI = newsoi;			/* update SOI end list */

    /* now make link to soi from starting EOI */
    if (fromArg == ARGPTRNULL)
	nlist = &from->startsoi;	/* first level entry */
    else
	nlist = &fromArg->startsoi;	/* extra level (arg) entry */
    
    if (*nlist == SLISTNULL)		/* no entries */
    {
	*nlist = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (*nlist == SLISTNULL)
	{
	    assert0(NO, "Profiler:addAutoSOI - Out of Memory");
	    return;
	}
	soilist = *nlist;	/* point to new node */
	soilist->next = SLISTNULL;
    }
    else				/* follow list & add to end */
    {
	soilist = *nlist;
	while (soilist->next != SLISTNULL)
	     soilist = soilist->next;
	soilist->next = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (soilist->next == SLISTNULL)
	{
	    assert0(NO, "Profiler:addAutoSOI - Out of Memory");
	    return;
	}
	soilist = soilist->next;	/* point to new node */
	soilist->next = SLISTNULL;
    }
    soilist->soiLink = newsoi;		/* make link */

    /* now repeat for 'end' case */
    if (to->lastArg == ARGPTRNULL)
	nlist = &to->endsoi;		/* first level entry */
    else
	nlist = &to->lastArg->endsoi;	/* extra level (arg) entry */
    
    if (*nlist == SLISTNULL)		/* no entries */
    {
	*nlist = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (*nlist == SLISTNULL)
	{
	    assert0(NO, "Profiler:addAutoSOI - Out of Memory");
	    return;
	}
	soilist = *nlist;	/* point to new node */
	soilist->next = SLISTNULL;
    }
    else				/* follow list & add to end */
    {
	soilist = *nlist;
	while (soilist->next != SLISTNULL)
	     soilist = soilist->next;
	soilist->next = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (soilist->next == SLISTNULL)
	{
	    assert0(NO, "Profiler:addAutoSOI - Out of Memory");
	    return;
	}
	soilist = soilist->next;	/* point to new node */
	soilist->next = SLISTNULL;
    }
    soilist->soiLink = newsoi;		/* make link */
}

/*(
============================ findOrMakeArgPtr ===========================

PURPOSE: Find an existing arg entry for an EOI or create one if not found.

INPUT: eoi: pointer to eoi node.
       value: search value.

OUTPUT: pointer to arg node.

=========================================================================
)*/

LOCAL EOIARG_PTR
findOrMakeArgPtr IFN2(EOINODE_PTR, eoi, IUM32, value)
{
    EOIARG_PTR	argPtr, lastArg;
    SOILIST_PTR argsois;

    argPtr = eoi->args;
    /* any args there yet ? */
    if (argPtr == ARGPTRNULL)
    {
	argPtr = (EOIARG_PTR)host_malloc(sizeof(EOIARG));
	if (argPtr == ARGPTRNULL)
	{
	    fprintf(trace_file, "Profiler:findOrMakeArgPtr - Out of memory\n");
	    return(ARGPTRNULL);
	}
	eoi->args = eoi->lastArg = argPtr;
	argPtr->back = argPtr->next = ARGPTRNULL;
	argPtr->value = value;
	argPtr->count = 0;
	argPtr->graph = GRAPHPTRNULL;
	argPtr->startsoi = argPtr->endsoi = SLISTNULL;
    }
    else
    {
	/* check for value existing at moment */
	do {
		if (argPtr->value == value)
			break;

		lastArg = argPtr;
		argPtr = argPtr->next;
	} while (argPtr != ARGPTRNULL);

	/* value found ? */
	if (argPtr == ARGPTRNULL)
	{
		/* add new value */
		argPtr = (EOIARG_PTR)host_malloc(sizeof(EOIARG));
		if (argPtr == ARGPTRNULL)
		{
		    fprintf(trace_file, "Profiler:findOrMakeArgPtr - Out of memory\n");
		    return(ARGPTRNULL);
		}
		lastArg->next = argPtr;
		argPtr->back = lastArg;
		argPtr->next = ARGPTRNULL;
		argPtr->value = value;
		argPtr->count = 0;
		argPtr->graph = GRAPHPTRNULL;
		argPtr->startsoi = argPtr->endsoi = SLISTNULL;
	}
    }
    return(argPtr);
}


/*(
============================ getPredefinedEOIs ===========================

PURPOSE: Read in predefined EOIs & SOIs from profile init file. These
	 are the EOIs that have been set up during EDL translation.

INPUT: None.

OUTPUT: None.

=========================================================================
)*/

LOCAL void
getPredefinedEOIs IFN0()
{
    FILE *initFp;		/* file pointer to init file */
    char buf[1024];		/* working space */
    char *tag;			/* point to tags in file */
    char *ptr;			/* working pointer */
    IU8 flags;			/* flags values in file */
    EOIHANDLE eoinum, soiend;   /* EOI parameters in file */

    if ((initFp = fopen(HostProfInitName(), "r")) == (FILE *)0)
    {
	fprintf(stderr, "WARNING: No initialisation file found for predefined profile EOIs.\n");
	return;		/* no init file, no predefines */
    }

    /* process file, one line at a time */
    while(fgets(buf, sizeof(buf), initFp) != (char *)0)
    {
	if (buf[0] == '#')	/* comment line */
	   continue;

	/* EOI format: EOI:number:tag:flags */
	if (strncmp(&buf[0], "EOI:", 4) == 0)
	{
	    eoinum = (EOIHANDLE)atol(&buf[4]);	/* should stop at : */
	    if (!eoinum)
		continue;			/* EOI in C not EDL */

	    tag = strchr(&buf[4], (int)':');	/* find tag */
	    if (tag == (char *)0)
	    {
		fprintf(stderr, "Ignoring request '%s': bad syntax\n", &buf[0]);
		continue;
	    }
	    tag++;	/* start of tag */

	    ptr = strchr(tag, (int)':');	/* find end of tag (at :) */
	    if (ptr == (char *)0)
	    {
		fprintf(stderr, "Ignoring request '%s': bad syntax\n", &buf[0]);
		continue;
	    }
	    *ptr = '\0';		/* terminate tag */
	    flags = (IU8)atoi(++ptr);	/* get flags */

	    if (eoinum >= MaxEOI)	/* oops - enable table full. Grow it */
	    {
		MaxEOI = eoinum + INITIALENABLESIZE;
		/* ASSUMES host_realloc is non destructive */
		EOIEnable = (IU8 *)host_realloc(EOIEnable, MaxEOI);
		if (EOIEnable == (IU8 *)0)
		{
    		    assert0(NO, "profiler:getPredefinedEOIs:Out of Memory");
    		    return;
		}
		EOIDir = (EOINODE_PTR *)host_realloc(EOIDir, MaxEOI * sizeof(EOINODE_PTR) );
		if (EOIDir == (EOINODE_PTR *)0 )
		{
    		    assert0(NO, "profiler:getPredefinedEOIs:Out of Memory");
    		    return;
		}
		/* pointer may have changed, update GDP */
		setEOIEnableAddr(EOIEnable);
	    }

	    if (eoinum > CurMaxEOI)
		CurMaxEOI = eoinum;

	    addEOI(eoinum, tag, flags);	/* add the EOI */
printf("adding EOI %d:%s:%d\n",eoinum, tag, flags);
	    continue;
	}

	/* SOI format: SOI:EOI#:EOI# */
	if (strncmp(&buf[0], "SOI:", 4) == 0)
	{
	    /* get first number (start beyond '(' */
	    eoinum = (EOIHANDLE)atol(&buf[4]);	/* should stop at ':' */
	    /* find second number */
	    ptr = strchr(&buf[4], (int)':');
	    if (ptr == (char *)0)	/* tampering? */
	    {
		fprintf(stderr, "Ignoring request '%s': bad syntax\n", &buf[0]);
		continue;
	    }
	    /* get second number */
	    soiend = (EOIHANDLE)atol(++ptr);
	    /* make SOI */
	    AssociateAsSOI(eoinum, soiend);
printf("adding SOI %d:%d\n",eoinum, soiend);
	}
    }

    fclose(initFp);
}

/*(
=============================== addEOI =============================

PURPOSE: Add an event to the EventsOfInterest list.

INPUT: newhandle: handle of new EOI
       tag: some 'human form' identifier for the new EOI
       attrib: flag for EOI attribute settings.

OUTPUT: pointer to new node for 'instant' access.

=========================================================================
)*/

LOCAL EOINODE_PTR
addEOI IFN3 (EOIHANDLE, newhandle, char *, tag, IU8, attrib)
{
    EOINODE_PTR lastEoin, eoin;	/* list walker */

    /* first event added is special case. */
    if (EventsOfInterest == EOIPTRNULL)
    {
	/* add first node */
	EventsOfInterest = (EOINODE_PTR)host_malloc(sizeof(EOINODE));
	if (EventsOfInterest == EOIPTRNULL)
	{
	    assert0(NO, "Profiler:addEOI - Out of memory")
	    return(EOIPTRNULL);
	}
	eoin = EventsOfInterest;
	lastEoin = EOIPTRNULL;
    }
    else       /* search down list */
    {
	lastEoin = eoin = EventsOfInterest;
	do {
#ifndef PROD
	    if (eoin->handle == newhandle)	/* sanity check */
	    {
		assert1(NO, "profiler:addEOI - adding previously added handle %ld",newhandle);
	    }
#endif /* PROD */
	    lastEoin = eoin;
	    eoin = eoin->next;
	} while (eoin != EOIPTRNULL);

	if (eoin == EventsOfInterest)    /* insert at head of list */
	{
	    EventsOfInterest = (EOINODE_PTR)host_malloc(sizeof(EOINODE));
	    if (EventsOfInterest == EOIPTRNULL)
	    {
		assert0(NO, "Profiler:addEOI - Out of memory")
		return(EOIPTRNULL);
	    }

	    EventsOfInterest->next = eoin;
	    eoin = EventsOfInterest;     /* new node for common init code */
	}
	else	       /* add new node to list */
	{
	    lastEoin->next  = (EOINODE_PTR)host_malloc(sizeof(EOINODE));
	    if (lastEoin->next == EOIPTRNULL)
	    {
		assert0(NO, "Profiler:addEOI - Out of memory")
		return(EOIPTRNULL);
	    }
	    lastEoin->next->next = eoin;
	    eoin = lastEoin->next;     /* new node for common init code */
	}

    }
    eoin->args = ARGPTRNULL;       /* not interested */
    eoin->lastArg = ARGPTRNULL;
    eoin->handle = newhandle;
    eoin->count = 0L;
    eoin->back = lastEoin;
    eoin->next = EOIPTRNULL;
    eoin->tag = (char *)host_malloc(strlen((char *)tag)+1);
    if (eoin->tag == (char *)0)
    {
	assert0(NO, "Profiler: addEOI - Out of Memory");
	eoin->tag = tag;
    }
    else
	strcpy((char *)eoin->tag, tag);
    eoin->timestamp.data[0] = 0L;
    eoin->timestamp.data[1] = 0L;
    eoin->graph = GRAPHPTRNULL;
    eoin->flags = (IU16)attrib;

    /* mark whether EOI enabled in GDP & store global enable/disable there */
    if ((attrib & EOI_AUTOSOI) == 0)	/* any point suppressing timestamps? */
    {
	attrib &= ENABLE_MASK;		/* strip all save enable/disable info */
	attrib |= EOI_NOTIME;		/* turned off if SOI'ed */
    }
    else
	attrib &= ENABLE_MASK;		/* strip all save enable/disable info*/

    *(EOIEnable + newhandle) = attrib;
    *(EOIDir + newhandle) = eoin;

    eoin->startsoi = eoin->endsoi = SLISTNULL;
    eoin->argsoiends = SOIARGENDNULL;

    return(eoin);       /* return pointer to new node for immediate update */
}

/*(
=============================== updateEOI =============================

PURPOSE: Update the information for a given EOI. This routine called 
	 from the 'raw data buffer' flushing routine.

INPUT: rawdata: pointer into raw buffer for this EOI.

OUTPUT: returns FALSE if will exceed buffer end.
	rawdata modified to point to next EOI

=========================================================================
)*/

LOCAL IBOOL
updateEOI IFN1 (IUH **, rawdata)
{
    EOIHANDLE handle;			/* EOI from raw buf */
    PROF_TIMESTAMP time;		/* time from raw buf */
    EOINODE_PTR eoin;			/* EOI list walker */
    EOIARG_PTR argn, lastArgn;		/* EOI arg list walker */
    SOILIST_PTR soilist;		/* SOI list walker */
    SOINODE_PTR soin;			/* SOI list walker */
    IUH eoiarg;			/* arg from raw buf */
    GRAPHLIST_PTR graphn, lastgr, predgr;	/* graph list walkers */
    EOINODE_PTR autoS, autoE;		/* auto SOI initialisers */
    EOIARG_PTR autoA;			/*  "    "     "	 */
    PROF_TIMEPTR diffstamp;		/* pointer to timestamp diff result */
    DOUBLE diffres;			/* timestamp diff in usecs */
    IBOOL newvalue = FALSE;		/* not seen this arg value before */
    SOIARGENDS_PTR endsoiargs;		/* erg SOI ender list walker */

   /* These copies are needed for AutoSOIs otherwise self-self EOI 
    * connections are formed with the wrong data.
    */
    SAVED EOIARG_PTR lastAutoArg = ARGPTRNULL; /* auto SOI arg spec */
    SAVED PROF_TIMESTAMP AutoTime = { 0L, 0L }; /* auto SOI timestamp */

    handle = *(*rawdata)++;		/* Get EOI handle */

    eoin = *(EOIDir + handle);

    /* update event stats */
    eoin->count++;

    /* timestamps only in data buffer if EOI SOI associated. Need to do
     * this now before (potential) arg read below.
     */
    if ((eoin->flags & (EOI_HAS_SOI|EOI_AUTOSOI)) != 0)
    {
	eoin->timestamp.data[0] = *(*rawdata)++;       /* Get timestamp */
	eoin->timestamp.data[1] = *(*rawdata)++;
    }

    argn = ARGPTRNULL;		/* used below as 'last arg' - Null if no args */

    /* EOI interested in arguments? */
    if ((eoin->flags & EOI_KEEP_ARGS) == EOI_KEEP_ARGS)
    {
	eoiarg = *(*rawdata)++;		/* optional argument in buffer */
	if (eoin->args == ARGPTRNULL)    /* wants args but hasnt seen any */
	{
	    argn = eoin->args = (EOIARG_PTR)host_malloc(sizeof(EOIARG));
	    if (argn == ARGPTRNULL)
	    {
		assert0(NO, "profiler: updateEOI - Out of memory");
		return(FALSE);
	    }
	    argn->value = eoiarg;
	    argn->count = 1;
	    argn->next = ARGPTRNULL;
	    argn->back = ARGPTRNULL;
	    argn->graph = GRAPHPTRNULL;
	    argn->startsoi = SLISTNULL;
	    argn->endsoi = SLISTNULL;
	    newvalue = TRUE;
	    /*eoin->lastArg = argn;*/
	}
	else 		/* find out if this value known */
	{
	    if (eoin->lastArg->value == eoiarg)   /* same value as last time? */
	    {
		eoin->lastArg->count++;
		argn = eoin->lastArg;
	    }
	    else			/* find it or add it */
	    {
		lastArgn = argn = eoin->args;
		do {
		    if (argn->value == eoiarg)  /* found */
		    {
			argn->count++;
			/*eoin->lastArg = argn; */
	
			/* if this has been updated 'a lot', try to move it up list */
			if ((argn->count % LISTSORTINCR) == 0L)
			    if (argn != eoin->args)   /* not already at head */
				listSort((SORTSTRUCT_PTR)&eoin->args);
			break;
		    }
		    lastArgn = argn;
		    argn = argn->next;
		} while (argn != ARGPTRNULL);
		if (argn == ARGPTRNULL)		/* new */
		{
		    lastArgn->next= (EOIARG_PTR)host_malloc(sizeof(EOIARG));
		    if (lastArgn->next == ARGPTRNULL)
		    {
			assert0(NO, "profiler: updateEOI - Out of memory");
			return(FALSE);
		    }
		    lastArgn->next->next = argn;	/* init new arg elem */
	    	    argn = lastArgn->next;
		    argn->count = 1;
		    argn->value = eoiarg;
	    	    argn->next = ARGPTRNULL;
		    argn->graph = GRAPHPTRNULL;
	    	    argn->back = lastArgn;
		    argn->startsoi = SLISTNULL;
		    argn->endsoi = SLISTNULL;
		    newvalue = TRUE;
	    	    /* eoin->lastArg = argn; */
		}
	    }
	}

	/* if arg level SOI with 'same value' connections, have to make
	 * new SOI for new values.
	 */
	if (newvalue && ((eoin->flags & EOI_NEW_ARGS_START_SOI) != 0))
	{
		endsoiargs = eoin->argsoiends;
		while(endsoiargs != SOIARGENDNULL)
		{
			AssociateAsArgSOI(handle, endsoiargs->endEOI,
					  eoiarg, eoiarg,
					  FALSE);
			endsoiargs = endsoiargs->next;
		}
			
	}
    }

    /* does EOI want preceeding events graphed? */
    /* or if not, should we make a connection as previous event does */
    if ((eoin->flags & EOI_KEEP_GRAPH) != 0 || (LastEOI != EOIPTRNULL && ((LastEOI->flags & EOI_KEEP_GRAPH) != 0)))
    {
	/* first event has no predecessor, or first graphing item */
	if (LastEOI == EOIPTRNULL || EventGraph == GRAPHPTRNULL)
	{
	    EventGraph = (GRAPHLIST_PTR)host_malloc(sizeof(GRAPHLIST));
	    if (EventGraph == GRAPHPTRNULL)
	    {
		assert0(NO, "Profiler: updateEOI - Out of Memory");
		return(FALSE);
	    }
	    EventGraph->graphEOI = eoin;	/* pointer back to EOI node */
	    EventGraph->graphArg = eoin->lastArg;  /* & to arg if relevant */
	    EventGraph->next = GRAPHPTRNULL;
	    EventGraph->succ1 = GRAPHPTRNULL;
	    EventGraph->succ2 = GRAPHPTRNULL;
	    EventGraph->extra = GRAPHPTRNULL;
	    EventGraph->state = 0;
	    EventGraph->numsucc = 0L;
	    EventGraph->numpred = 0L;
	    EventGraph->indent = 0L;
	    /* now get pointer back from eoi node to graph */
	    if (EventGraph->graphArg == ARGPTRNULL)  /* args saved ? */
		EventGraph->graphEOI->graph = EventGraph;
	    else
		EventGraph->graphArg->graph = EventGraph;
	    LastGraph = EventGraph;
	}
	else 	/* update or add graph entry, make connection from last */
	{
	    /* Check if there is already a connection from last event to this */

	    /* Does the last EOI hold a graph node? May not if it doesn't have
	     * a 'keep graph' attribute. We should include it though as it's
	     * part of the execution flow & might therefore be important to
	     * know. The graph attribute won't be set on that mode & so no other
	     * routes will be known, but it will show up for this link of the
	     * graph.
	     */
	    if (LastEOI->args == ARGPTRNULL)
		lastgr = LastEOI->graph;
	    else
		lastgr = LastEOI->lastArg->graph;

	    /* do we need new graph node? */
	    if (lastgr == GRAPHPTRNULL)
	    {
		/* add to end of list */
		LastGraph->next = (GRAPHLIST_PTR)host_malloc(sizeof(GRAPHLIST));
		if (LastGraph->next == GRAPHPTRNULL)
		{
		    assert0(NO, "Profiler: updateEOI - Out of Memory");
		    return(FALSE);
		}
		graphn = LastGraph->next;
		graphn->graphEOI = LastEOI;	/* pointer back to EOI node */
		graphn->graphArg = LastEOI->args;   /* & to arg if relevant */
		graphn->next = GRAPHPTRNULL;
		graphn->succ1 = GRAPHPTRNULL;
		graphn->succ2 = GRAPHPTRNULL;
		graphn->extra = GRAPHPTRNULL;
		graphn->state = 0;
		graphn->numsucc = 0L;
		graphn->numpred = 0L;
		graphn->indent = 0L;
		LastGraph = graphn;
		/* now get pointer back from eoi node to graph */
		if (LastEOI->args == ARGPTRNULL)  /* args saved ? */
		    LastEOI->graph = graphn;
		else
		    LastEOI->lastArg->graph = graphn;
	    }

	    /* does pointer already exist? */
	    graphn = GRAPHPTRNULL;
	    if (argn != ARGPTRNULL && argn->graph != GRAPHPTRNULL)
		graphn = argn->graph;
	    else
		if (eoin->graph != GRAPHPTRNULL)
		{
		    graphn = eoin->graph;
		}
	    if (graphn == GRAPHPTRNULL)	/* need new node */
	    {
		/* 'next' pointer is purely scaffolding, not graph related */
		LastGraph->next = (GRAPHLIST_PTR)host_malloc(sizeof(GRAPHLIST));
		if (LastGraph->next == GRAPHPTRNULL)
		{
			assert0(NO, "Profiler: updateEOI - Out of Memory");
			return(FALSE);
		}
		graphn = LastGraph->next;
		graphn->graphEOI = eoin;	/* pointer back to EOI node */
		graphn->graphArg = argn;	/* & to arg if relevant */
		graphn->next = GRAPHPTRNULL;
		graphn->succ1 = GRAPHPTRNULL;
		graphn->succ2 = GRAPHPTRNULL;
		graphn->extra = GRAPHPTRNULL;
		graphn->state = 0;
		graphn->numsucc = 0L;
		graphn->numpred = 0L;
		graphn->indent = 0L;
		LastGraph = graphn;
		/* now get pointer back from eoi node to graph */
		if (graphn->graphArg == ARGPTRNULL)  /* args saved ? */
		    graphn->graphEOI->graph = graphn;
		else
		    graphn->graphArg->graph = graphn;
	    }

	    if (LastEOI->args == ARGPTRNULL)
		lastgr = LastEOI->graph;
	    else
		lastgr = LastEOI->lastArg->graph;

	    /* graphn points at 'this' node */

	    predgr = lastgr;   /* hold first level in case decending down xtra*/

	    /* look through connections in turn. If null, make connection.
	     * if connection matches, increment counter & bail out
	     */
	    do {
		/* succ1 connection first */
		if (lastgr->succ1 == GRAPHPTRNULL)    /* no connection - make one */
		{
		    lastgr->succ1 = graphn;
		    lastgr->succ1Count = 1;
		    predgr->numsucc++;
		    graphn->numpred++;
		    break;
		}
		else
		    if (lastgr->succ1 == graphn)    /* connection exists */
		    {
			lastgr->succ1Count++;
			break;
		    }
		    else
			/* succ1 didn't get there - try succ2 */
			if (lastgr->succ2 == GRAPHPTRNULL)  /* emptry slot */
			{
			    lastgr->succ2 = graphn;
			    lastgr->succ2Count = 1;
			    predgr->numsucc++;
			    graphn->numpred++;
			    break;
			}
			else
			    if (lastgr->succ2 == graphn)   /* match */
			    {
				lastgr->succ2Count++;
				break;
			    }
			    else
				/* walk down to or create extra level */
				if (lastgr->extra == GRAPHPTRNULL)
				{
				    lastgr->extra = (GRAPHLIST_PTR)host_malloc(sizeof(GRAPHLIST));
				    if (lastgr->extra == GRAPHPTRNULL)
				    {
		    			assert0(NO, "Profiler: updateEOI - Out of Memory");
		    			return(FALSE);
				    }
				    lastgr = lastgr->extra;
				    /* copy id from top level */
				    lastgr->graphEOI = predgr->graphEOI;
				    lastgr->graphArg = predgr->graphArg;
				    lastgr->succ1 = lastgr->succ2 = lastgr->extra = GRAPHPTRNULL;
				    lastgr->state = 0;
				}
				else
				    lastgr = lastgr->extra;
	    } while (lastgr != GRAPHPTRNULL);
	}
    }

    LastEOI = eoin;	/* save this event to be next EOI's predecessor */
    eoin->lastArg = argn; /* and update it's last arg ptr (or Null) */

    autoS = autoE = EOIPTRNULL;		/* no new Auto yet */

    /* Should we form automatic SOI from last event to this */
    if ((eoin->flags & EOI_AUTOSOI) == EOI_AUTOSOI)
    {
	if (LastAuto != EOIPTRNULL)
	{
	/* search the 'start' SOI list of last EOI to see if SOI ends here */

	    if (lastAutoArg != ARGPTRNULL)	/* search in arg list */
	    {
		soilist = lastAutoArg->startsoi;
		if (soilist == SLISTNULL)	/* can't be - no SOIs at last */
		{
		    autoS = LastAuto;	/* prepare new Auto SOI */
		    autoA = lastAutoArg;
		    autoE = eoin;
		}
		else	/* search current set */
		{
		    do {
			if (soilist->soiLink->endEOI == handle)
			{
			    /* first levels match - compare 2nd */
			    if (soilist->soiLink->endArg == eoin->lastArg)
				break;
			}
			soilist = soilist->next;
		    } while (soilist != SLISTNULL);	/* look at each link*/

		    if (soilist == SLISTNULL)	/* not found */
		    {
			autoS = LastAuto;	/* prepare new Auto SOI */
			autoA = lastAutoArg;
			autoE = eoin;
		    }
		}
	    }
	    else	/* look for non arg case */
	    {
		soilist = LastAuto->startsoi;
		if (soilist == SLISTNULL)	/* can't be - no SOIs at last */
		{
		    autoS = LastAuto;	/* prepare new Auto SOI */
		    autoA = lastAutoArg;
		    autoE = eoin;
		}
		else	/* search current set */
		{
		    do {
			if (soilist->soiLink->endEOI == handle)   /* found */
			    break;
			soilist = soilist->next;
		    } while (soilist != SLISTNULL);	/* look at each link*/

		    if (soilist == SLISTNULL)	/* not found */
		    {
			autoS = LastAuto;	/* prepare new Auto SOI */
			autoA = lastAutoArg;
			autoE = eoin;
		    }
		}
	    }
	}
	LastAuto = eoin;
	lastAutoArg = eoin->lastArg;
    }	/* end of AutoSOI generation */

    /* do we need to check for SOI updates? */
    if ((eoin->flags & EOI_HAS_SOI) == EOI_HAS_SOI)
    {
	/* update SOIs which this event is part of (start/end).
	 * Do ends first as if point back to self, then get 0 elapsed
	 * time otherwise
	 */
	/* 'ends' first. update counter and elapsed time */
	soilist = eoin->endsoi;
	while (soilist != SLISTNULL)
	{
	    soin = soilist->soiLink;
	    /* Don't update if end hasn't had a start */
	    if (soin->startCount > soin->endCount)
	    {
		diffstamp = HostTimestampDiff(&soin->soistart, &eoin->timestamp);
		diffres = HostProfUSecs(diffstamp);
		if (diffres > 100.0 * soin->mintime)
		{
		    if (soin->endCount) /* ie all but first */
		    {
			soin->bigtime += diffres;
			soin->discardCount++;
			if (diffres > soin->bigmax)
			    soin->bigmax = diffres;
		    }
		    else
		    {
			soin->time += diffres;
			soin->mintime = soin->maxtime = diffres;
		    }
		}
		else
		{
		    soin->time += diffres;
		    if (diffres < soin->mintime)
			soin->mintime = diffres;
		    else if (diffres > soin->maxtime)
			soin->maxtime = diffres;
		}
		soin->endCount++;
	    }
	    soilist = soilist->next;    /* next node */
	}

	/* repeat for Arg level */
	if (eoin->lastArg != ARGPTRNULL)
	{
	    soilist = eoin->lastArg->endsoi;
	    while (soilist != SLISTNULL)
	    {
	        soin = soilist->soiLink;
	        /* Don't update if end hasn't had a start */
	        if (soin->startCount > soin->endCount)
	        {
		    diffstamp = HostTimestampDiff(&soin->soistart, &eoin->timestamp);
		    diffres = HostProfUSecs(diffstamp);
		    if (diffres > 100.0 * soin->mintime)
		    {
			if (soin->endCount)
			{
			    soin->bigtime += diffres;
			    soin->discardCount++;
			    if (diffres > soin->bigmax)
			        soin->bigmax = diffres;
			}
			else
			{
			    soin->time += diffres;
			    soin->mintime = soin->maxtime = diffres;
			}
		    }
		    else
		    {
			soin->time += diffres;
			if (diffres < soin->mintime)
			    soin->mintime = diffres;
			else if (diffres > soin->maxtime)
			    soin->maxtime = diffres;
		    }
		    soin->endCount++;
	        }
	        soilist = soilist->next;    /* next node */
	    }
	}

	/* 'starts' next. Update counter and timestamp */

	/* EOI level first */
	soilist = eoin->startsoi;
	while (soilist != SLISTNULL)
	{
	    soin = soilist->soiLink;
	    soin->startCount++;
	    soin->soistart.data[0] = eoin->timestamp.data[0];
	    soin->soistart.data[1] = eoin->timestamp.data[1];
	    soilist = soilist->next;    /* next node */
	}

	/* now repeat for extra (Arg level */
	if (eoin->lastArg != ARGPTRNULL)
	{
	    soilist = eoin->lastArg->startsoi;
	    while (soilist != SLISTNULL)
	    {
	        soin = soilist->soiLink;
	        soin->startCount++;
	        soin->soistart.data[0] = eoin->timestamp.data[0];
	        soin->soistart.data[1] = eoin->timestamp.data[1];
	        soilist = soilist->next;    /* next node */
	    }
	}
    }

    /* Now SOIs processed, set up any links for new AutoSOIs */
    if (autoS != EOIPTRNULL)
	addAutoSOI(autoS, autoA, &AutoTime, autoE);

    /* now can copy new 'last' auto timestamp */
    if ((eoin->flags & EOI_AUTOSOI) == EOI_AUTOSOI)
    {
	AutoTime.data[0] = eoin->timestamp.data[0];
	AutoTime.data[1] = eoin->timestamp.data[1];
    }

    return(TRUE);	/* did that one OK */
}


/*(
=============================== listSort =============================

PURPOSE: Sort any list of SORTSTRUCT structures which have a common header.
	 The elements are sorted into decreasing 'count' order on the
	 assumption that the greater counts will continue to be requested as
	 frequently and therefore should be at the head of the list to reduce
	 search time. Based on exchange sort as gives best performance trade
	 off in sorting unsorted lists and already sorted lists (the latter
	 being quite likely).

INPUT: head: head of list to sort

OUTPUT: None

=========================================================================
)*/

LOCAL void
listSort IFN1 (SORTSTRUCT_PTR, head)
{
    SORTSTRUCT current, check, this, tmp;	/* list walker */
    IBOOL swap;					/* ordering change indicator */

    if (*head == (SORTSTRUCT)0)		/* sanity check */
	return;

    current = *head;
    do {
	check = current;

	this = check->next;
	swap = FALSE;

	while(this != (SORTSTRUCT)0)	/* check this list elem against rest */
	{
	    if (this->count > check->count)
	    {
		check = this;		/* swap current with 'biggest' */
		swap = TRUE;
	    }
	    this = this->next;
	}
	if (swap)		   /* swap current & check */
	{
	    if (current->next == check)   /* adjacent elements, current first */
	    {
		current->next = check->next;
		if (current->next != (SORTSTRUCT)0)  /* now last element */
		    current->next->back = current;
		check->next = current;
		check->back = current->back;
		current->back = check;
		if (check->back != (SORTSTRUCT)0)   /* now head of list */
		    check->back->next = check;
		else
		    *head = check;
	    }
	    else				/* intermediate element(s) */
	    {
		current->next->back = check;
		tmp = check->next;
		if (tmp != (SORTSTRUCT)0)	/* swap with end of list? */
		    check->next->back = current;
		check->next = current->next;
		current->next = tmp;
		check->back->next = current;
		tmp = current->back;
		if (tmp != (SORTSTRUCT)0)		/* head of list */
		    current->back->next = check;
		else
		    *head = check;
		current->back = check->back;
		check->back = tmp;
	    }
	}
	current = check->next;		/* check is where current was */
    } while(current != (SORTSTRUCT)0);
}

/*(
============================ addSOIlinktoEOI ===============================

PURPOSE: add to the list of SOIs for which these events are triggers.

INPUT: soistart: EOI handle of starting event
       soiend: EOI handle of ending event
       soiptr: pointer to SOI node

OUTPUT: None

=========================================================================
)*/

LOCAL void
addSOIlinktoEOIs IFN3 (EOIHANDLE, soistart, EOIHANDLE, soiend,
							SOINODE_PTR, soiptr)
{
    EOINODE_PTR seoin, eeoin;	/* start & end eoi ptrs */
    SOILIST_PTR soil;		/* list walker */
    IU8 *notime;	/* used to enable timestamp collection in enable list */

    if (soistart == soiend)	/* get EOI nodes for handles */
    {
	seoin = eeoin = findEOI(soistart);
    }
    else
    {
	seoin = findEOI(soistart);
	if (seoin == EOIPTRNULL)
	{
		fprintf(trace_file, "Can't find start EOI %d\n",soistart);
		return;
	}
	eeoin = findEOI(soiend);
	if (eeoin == EOIPTRNULL)
	{
		fprintf(trace_file, "Can't find end EOI %d\n",soiend);
		return;
	}
    }

    /* check for timestamp enabling before adding SOIs */
    if (seoin->startsoi == SLISTNULL && seoin->endsoi == SLISTNULL)
    {
	ProcessProfBuffer();  /* flush existing entries w/o timestamps*/
	notime = EOIEnable + soistart;
	*notime &= ~EOI_NOTIME;
    }
    if (eeoin->startsoi == SLISTNULL && eeoin->endsoi == SLISTNULL)
    {
	ProcessProfBuffer();  /* flush existing entries w/o timestamps*/
	notime = EOIEnable + soiend;
	*notime &= ~EOI_NOTIME;
    }

    /* mark EOIs as valid for SOI updates */
    seoin->flags |= EOI_HAS_SOI;
    eeoin->flags |= EOI_HAS_SOI;

    /* add to (end of) start list */
    if (seoin->startsoi == SLISTNULL)   /* first starter */
    {
	seoin->startsoi = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (seoin->startsoi == SLISTNULL)
	{
	    assert0(NO, "Profiler:AddSOIlinktoEOI - Out of Memory");
	    return;
	}
	seoin->startsoi->soiLink = soiptr;
	seoin->startsoi->next = SLISTNULL;
    }
    else
    {
	soil = seoin->startsoi;    /* search list */
	while (soil->next != SLISTNULL)    /* BUGBUG sanity check?? */
	    soil = soil->next;

	/* Add new SOI pointer to end of list */
	soil->next = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (soil->next == SLISTNULL)
	{
	    assert0(NO, "Profiler:AddSOIlinktoEOI - Out of Memory");
	    return;
	}
	soil->next->soiLink = soiptr;
	soil->next->next = SLISTNULL;
    }

    /* now end SOI */
    if (eeoin->endsoi == SLISTNULL)   /* first ender */
    {
	eeoin->endsoi = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (eeoin->endsoi == SLISTNULL)
	{
	    assert0(NO, "Profiler:AddSOIlinktoEOI - Out of Memory");
	    return;
	}
	eeoin->endsoi->soiLink = soiptr;
	eeoin->endsoi->next = SLISTNULL;
    }
    else	/* end of current */
    {
	soil = eeoin->endsoi;    /* search list */
	while (soil->next != SLISTNULL)    /* BUGBUG sanity check?? */
	    soil = soil->next;

	/* Add new SOI pointer to end of list */
	soil->next = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (soil->next == SLISTNULL)
	{
	    assert0(NO, "Profiler:AddSOIlinktoEOI - Out of Memory");
	    return;
	}
	soil->next->soiLink = soiptr;
	soil->next->next = SLISTNULL;
    }

}

/*(
======================== printEOIGuts ===========================

PURPOSE: Print the information from inside an EOI node

INPUT: stream: output file stream
       eoin: pointer to EOI node
       ftotal: double total count for forming percentages.
       parg: print arg list
       report: add pretty printing or simple o/p.

OUTPUT:

=========================================================================
)*/

LOCAL void
printEOIGuts IFN5 (FILE *, stream, EOINODE_PTR, eoin, DOUBLE, ftotal,
						IBOOL, parg, IBOOL, report)
{
    EOIARG_PTR argn;		/* list walker */
    DOUBLE fsubtot;		/* total count of times args seen */

    if (report)
    {
	if (ftotal == 0.0)	/* don't show percentage calcn */
	    fprintf(stream, "%-40s %10d\n", eoin->tag, eoin->count);
	else
	    fprintf(stream, "%-40s %10d   %6.2f\n", eoin->tag, eoin->count, ((DOUBLE)eoin->count/ftotal)*100.0);
    }
    else	/* simple style */
	fprintf(stream, "%s %d\n", eoin->tag, eoin->count);

    if (eoin->count)	/* get total for %ages */
	fsubtot = (DOUBLE)eoin->count;
    else
	fsubtot = 1.0;

    /* show arg breakdown if requested */
    if (parg)
    {
	/* any args recorded? */
	if (eoin->args != ARGPTRNULL)
	{
	    if (report)
		fprintf(stream, "    Arg        Count      %%	Tot. %%\n");

	    /* sort argument list */
	    listSort((SORTSTRUCT_PTR) &eoin->args);

	    argn = eoin->args;
	    if (report)		/* already shown EOI, now args with % */
	    {
		while (argn)	/* show argument elements */
		{
		    fprintf(stream, "   %-8#x %8ld   %6.2f	%6.2f\n",
				argn->value, argn->count,
				((DOUBLE)argn->count/fsubtot)*100.0,
				((DOUBLE)argn->count/ftotal)*100.0);
		    argn = argn->next;
		}
	    }
	    else		/* simple o/p for graphing */
	    {
		while (argn)	/* show argument elements */
		{
		    fprintf(stream, "%s(%ld) %ld\n", eoin->tag, argn->value, argn->count);
		    argn = argn->next;
		}
	    }
	}
    }
}

/*(
======================== updateSOIstarts ===========================

PURPOSE: To find all SOIs which have been started but not finished and
	move on their start timestamps by the amount of the flush delay.

INPUT: startflush: time flush started.

OUTPUT:

=========================================================================
)*/
LOCAL void
updateSOIstarts IFN1(PROF_TIMEPTR, startflush)
{
    SOINODE_PTR soin;	/* list walker */
    PROF_TIMESTAMP now; /* timestamp at current node */
    PROF_TIMEPTR tdelta; /* pointer to time diff */

    soin = SectionsOfInterest;

    HostWriteTimestamp(&now);	/* do this once so error constant */
    now.data[0] = BufStartTime.data[0];
    if (now.data[1] < BufStartTime.data[1] )
	now.data[0]++;

    tdelta = HostTimestampDiff(startflush, &now);

    while(soin != SOIPTRNULL)
    {
	/* update non-ended SOIs start time by flush time */
	if (soin->startCount > soin->endCount)
	{
		HostSlipTimestamp(&soin->soistart, tdelta);
	/*
		fprintf( quickhack, "\t\t\t\t" );
		HostPrintTimestampFine( quickhack, tdelta );
		fprintf( quickhack, "\n" );
	*/
	}
	soin = soin->next;
    }
}

/*(
======================== spaces ===========================

PURPOSE: Print some number of spaces on stream

INPUT: stream: output file stream

OUTPUT:

=========================================================================
)*/
LOCAL void
spaces IFN2(FILE *, stream, ISM32, curindent)
{
    while(curindent--)
	fputc(' ', stream);		/* errrm... thats it */
}

/*(
=============================== NewEOI =============================

PURPOSE: Create a new Event of Interest

INPUT: tag: some 'human form' identifier for the new EOI
       attrib: flag for EOI attribute settings.

OUTPUT: Returns handle of new EOI

=========================================================================
)*/

GLOBAL EOIHANDLE
NewEOI IFN2 (char *, tag, IU8, attrib)
{
    FILE *initFp;		/* file pointer to init file */
    char buf[1024];		/* working space */
    char *tag2;			/* point to tags in file */
    char *ptr;			/* working pointer */
    IU8 flags;			/* flags values in file */
    EOIHANDLE eoinum;		/* EOI parameters in file */

    if (!Profiling_enabled)
    {
	fprintf( stderr, "EOI not created. Profiling disabled\n" );
	return ( (EOIHANDLE) -1 );
    }

    if (CurMaxEOI == MaxEOI)	/* oops - enable table full. Grow it */
    {
	MaxEOI += INITIALENABLESIZE;	/* add plenty of room */

	/* ASSUMES host_realloc is non destructive */
	EOIEnable = (IU8 *)host_realloc(EOIEnable, MaxEOI);
	if (EOIEnable == (IU8 *)0)
	{
	    assert0(NO, "profiler:NewEOI:Out of Memory");
	    return(-1);
	}
	EOIDir = (EOINODE_PTR *)host_realloc(EOIDir, MaxEOI * sizeof(EOINODE_PTR) );
	if (EOIDir == (EOINODE_PTR *)0 )
	{
	    assert0(NO, "profiler:NewEOI:Out of Memory");
	    return(-1);
	}
	/* pointer may have changed, update GDP */
	setEOIEnableAddr(EOIEnable);
    }
    CurMaxEOI++;   /* definitely room */


    if ((initFp = fopen(HostProfInitName(), "r")) == (FILE *)0)
    {
	(void)addEOI(CurMaxEOI, tag, attrib);	/* No init file, enable all */
#ifndef PROD
	printf( "Adding EOI %d (%s) for C (No init file)\n", CurMaxEOI, tag );
#endif
	return(CurMaxEOI);		/* return new handle */
    }

    /* process file, one line at a time */
    while(fgets(buf, sizeof(buf), initFp) != (char *)0)
    {
	if (buf[0] == '#')	/* comment line */
	   continue;

	/* EOI format: EOI:number:tag:flags */
	if (strncmp(&buf[0], "EOI:", 4) == 0)
	{
	    eoinum = (EOIHANDLE)atol(&buf[4]);	/* should stop at : */
	    if (eoinum)
		continue;			/* EOI in EDL not C */

	    tag2 = strchr(&buf[4], (int)':');	/* find tag */
	    if (tag2 == (char *)0)
	    {
		fprintf(stderr, "Ignoring request '%s': bad syntax\n", &buf[0]);
		continue;
	    }
	    tag2++;	/* start of tag */

	    ptr = strchr(tag2, (int)':');	/* find end of tag (at :) */
	    if (ptr == (char *)0)
	    {
		fprintf(stderr, "Ignoring request '%s': bad syntax\n", &buf[0]);
		continue;
	    }
	    *ptr = '\0';		/* terminate tag */

	    flags = (IU8)atoi(++ptr) | attrib;	/* get flags */

	    if (!strcmp(tag, tag2) )
	    {
		(void)addEOI(CurMaxEOI, tag, flags);
#ifndef PROD
		printf( "Adding C EOI %d (%s), found in init file\n", CurMaxEOI, tag );
#endif
		return(CurMaxEOI);
	    }
	}
    }

    (void)addEOI(CurMaxEOI, tag, attrib | EOI_DISABLED);
#ifndef PROD
    printf( "Adding disabled C EOI %d (%s), not found\n", CurMaxEOI, tag );
#endif
    return(CurMaxEOI);		/* return new handle */
}

/*(
============================ AssociateAsSOI ===============================

PURPOSE: specify two EOIs as start and end events of (new) SOI

INPUT: startEOI: start event handle
       endEOI: end event handle

OUTPUT: New SOI handle

=========================================================================
)*/

GLOBAL SOIHANDLE
AssociateAsSOI IFN2 (EOIHANDLE, startEOI, EOIHANDLE, endEOI)
{
  /*
   * Add a new element to end of the SOI list. The frequent access to the
   * data will be via pointers embedded in the relevant EOI elements and
   * so don't care about any ordering of SOI list. Will need to search EOI
   * list with handle to get access to the pointers.
   */
    SOINODE_PTR soin, lastSoin;	/* list walker */

    if (!Profiling_enabled)
    {
	fprintf( stderr, "SOI not created. Profiling disabled\n" );
	return ( (SOIHANDLE) -1 );
    }

    /* sanity check */
    if (startEOI == endEOI)
    {
	assert1(NO, "Profiler:AssociateAsSOI - Can't have same start & end EOIs (%ld)", startEOI);
	return(-1);
    }

    /* first event added is special case. */
    if (SectionsOfInterest == SOIPTRNULL)
    {
	/* add first node */
	SectionsOfInterest = (SOINODE_PTR)host_malloc(sizeof(SOINODE));
	if (SectionsOfInterest == SOIPTRNULL)
	{
	    assert0(NO, "Profiler:AssociateAsSOI - Out of memory")
	    return(-1);
	}
	soin = SectionsOfInterest;
    }
    else
    {
	soin = LastSOI;
	soin->next = (SOINODE_PTR)host_malloc(sizeof(SOINODE));
	if (soin->next == SOIPTRNULL)
	{
	    assert0(NO, "Profiler:AssociateAsSOI - Out of memory")
	    return(-1);
	}
	soin = soin->next;
    }

    soin->handle = MaxSOI++;	/* new handle */
    soin->startEOI = startEOI;
    soin->endEOI = endEOI;
    soin->startArg = soin->endArg = ARGPTRNULL;
    soin->startCount = soin->endCount = soin->discardCount = 0L;
    soin->soistart.data[0] = 0L;
    soin->soistart.data[1] = 0L;
    soin->next = SOIPTRNULL;
    soin->flags = SOI_DEFAULTS;
    soin->time = 0.0;
    soin->bigtime = 0.0;
    soin->maxtime = 0.0;
    soin->mintime = 0.0;
    soin->bigmax = 0.0;

    /* add a pointer to this SOI to the start/end lists of the relevant EOIs */
    addSOIlinktoEOIs(startEOI, endEOI, soin);

    /* end of SOI list has moved */
    LastSOI = soin;

    /* return new handle */
    return(soin->handle);
}

/*(
============================ AssociateAsArgSOI ===============================

PURPOSE: specify two EOIs and optionally two arg values as start and end events
	of (new) SOI. Alternatively if 'sameArg' is true, automatically create
	SOIs between EOIs with 'same value' arguments.

INPUT: startEOI: start event handle
       endEOI: end event handle
       startArg: startArg
       endArg: endArg
       sameArgs: FALSE if start/endArg valid, otherwise TRUE for auto generation

OUTPUT: New SOI handle

=========================================================================
)*/

GLOBAL SOIHANDLE
AssociateAsArgSOI IFN5 (EOIHANDLE, startEOI, EOIHANDLE, endEOI,
			IUM32, startArg, IUM32, endArg, IBOOL, sameArgs)
{
  /*
   * Add a new element to end of the SOI list. The frequent access to the
   * data will be via pointers embedded in the relevant EOI elements and
   * so don't care about any ordering of SOI list. Will need to search EOI
   * list with handle to get access to the pointers.
   */
    SOINODE_PTR soin, lastSoin;	/* list walker */
    EOINODE_PTR startPtr, endPtr;
    SOIARGENDS_PTR addEnds, prevEnds;
    EOIARG_PTR	argPtr, lastArg;
    SOILIST_PTR argsois;

    if (!Profiling_enabled)
    {
	fprintf( stderr, "SOI not created. Profiling disabled\n" );
	return ( (SOIHANDLE) -1 );
    }

    startPtr = findEOI(startEOI);
    if (startPtr == EOIPTRNULL)
    {
	fprintf(trace_file, "Profiler:AssociateAsArgSOI - start EOI %ld not found\n", startEOI);
	return(-1);
    }
    if ((startPtr->flags & EOI_KEEP_ARGS) == 0)
    {
	fprintf(trace_file, "Error: AssociateAsArgSOI - start arg not marked for flag collection\n");
	return(-1);
    }

    endPtr = findEOI(endEOI);
    if (endPtr == EOIPTRNULL)
    {
	fprintf(trace_file, "Profiler:AssociateAsArgSOI - end EOI %ld not found\n", endEOI);
	return(-1);
    }
    if ((endPtr->flags & EOI_KEEP_ARGS) == 0)
    {
	fprintf(trace_file, "Error: AssociateAsArgSOI - end arg not marked for flag collection\n");
	return(-1);
    }

    /* enable arg collection for start & end EOIs */
    *(EOIEnable + startEOI) &= ~EOI_NOTIME;
    *(EOIEnable + endEOI) &= ~EOI_NOTIME;

    startPtr->flags |= EOI_HAS_SOI;
    endPtr->flags |= EOI_HAS_SOI;

    if (sameArgs)	/* won't be adding SOI yet, just info when args appear */
    {
	/* mark 'same value' collection */
	startPtr->flags |= EOI_NEW_ARGS_START_SOI;
	addEnds = startPtr->argsoiends;
	if (addEnds == SOIARGENDNULL)
	{
		/* first in list */
		addEnds = (SOIARGENDS_PTR)host_malloc(sizeof(SOIARGENDS));
		if (addEnds == SOIARGENDNULL)
			goto nomem;
		startPtr->argsoiends = addEnds;
	}
	else
	{
		/* add new node to end of list */
		do {
			prevEnds = addEnds;
			addEnds = addEnds->next;
		} while (addEnds != SOIARGENDNULL);
		addEnds = (SOIARGENDS_PTR)host_malloc(sizeof(SOIARGENDS));
		if (addEnds == SOIARGENDNULL)
			goto nomem;
		prevEnds->next = addEnds;
	}
	addEnds->endEOI = endEOI;
	addEnds->next = SOIARGENDNULL;
	
	return(0);	/* hmmm, can't get SOI handle here ... */
    }

    /* first event added is special case. */
    if (SectionsOfInterest == SOIPTRNULL)
    {
	/* add first node */
	SectionsOfInterest = (SOINODE_PTR)host_malloc(sizeof(SOINODE));
	if (SectionsOfInterest == SOIPTRNULL)
		goto nomem;
	soin = SectionsOfInterest;
    }
    else
    {
	soin = LastSOI;
	soin->next = (SOINODE_PTR)host_malloc(sizeof(SOINODE));
	if (soin->next == SOIPTRNULL)
		goto nomem;
	soin = soin->next;
    }

    /* get pointer to (or more probably create) arg entries for start & end EOIs */
    argPtr = findOrMakeArgPtr(startPtr, startArg);

    if (argPtr == ARGPTRNULL)
	return(-1);

    /* argPtr points to new or existing arg val - link to startArg */
    soin->startArg = argPtr;
    /* and link soin to argPtr start */
    argsois = argPtr->startsoi;

    if (argsois == SLISTNULL)	/* list empty */
    {
	argsois = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (argsois == SLISTNULL)
		goto nomem;
	argPtr->startsoi = argsois;
    }
    else	/* add to end of lust */
    {
	while (argsois->next != SLISTNULL)
		argsois = argsois->next;
	argsois->next = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (argsois->next == SLISTNULL)
		goto nomem;
	argsois = argsois->next;
    }
    argsois->next = SLISTNULL;
    argsois->soiLink = soin;	/* connect to new soi */

    argPtr = findOrMakeArgPtr(endPtr, endArg);

    if (argPtr == ARGPTRNULL)
	return(-1);

    /* argPtr points to new or existing arg val - link to endArg */
    soin->endArg = argPtr;
    /* and link soin to argPtr end */
    argsois = argPtr->endsoi;

    if (argsois == SLISTNULL)	/* list empty */
    {
	argsois = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (argsois == SLISTNULL)
		goto nomem;
	argPtr->endsoi = argsois;
    }
    else	/* add to end of lust */
    {
	while (argsois->next != SLISTNULL)
		argsois = argsois->next;
	argsois->next = (SOILIST_PTR)host_malloc(sizeof(SOILIST));
	if (argsois->next == SLISTNULL)
		goto nomem;
	argsois = argsois->next;
    }
    argsois->next = SLISTNULL;
    argsois->soiLink = soin;	/* connect to new soi */

    soin->handle = MaxSOI++;	/* new handle */
    soin->startEOI = startEOI;
    soin->endEOI = endEOI;
    soin->startCount = soin->endCount = soin->discardCount = 0L;
    soin->soistart.data[0] = 0L;
    soin->soistart.data[1] = 0L;
    soin->next = SOIPTRNULL;
    soin->flags = SOI_FROMARG;
    soin->time = 0.0;
    soin->bigtime = 0.0;
    soin->maxtime = 0.0;
    soin->mintime = 0.0;
    soin->bigmax = 0.0;

    /* end of SOI list has moved */
    LastSOI = soin;

    /* return new handle */
    return(soin->handle);

nomem:	/* collect all 8 cases of same error together */
    fprintf(trace_file, "Profiler:AssociateAsArgSOI - Out of memory\n");
    return(-1);
}

/*(

============================== AtEOIPoint ==============================

PURPOSE: Call from C on event trigger. Write data to raw data buffer.

INPUT: handle: EOI handle of triggered event.

OUTPUT: None

=========================================================================
)*/

GLOBAL void
AtEOIPoint IFN1 (EOIHANDLE, handle)
{
    IUH *curRawBuf;			/* pointer into raw data buf */
    IU8 timenab, enable;		/* enable vals */

    if (ProfileRawData == (EOI_BUFFER_FORMAT *)0)
    {
	fprintf(stderr, "AtEOIPoint %d called before initialised\n", handle );
	return;
    }

    /* Check whether this EOI enabled */
    timenab = *(EOIEnable + handle);

    enable = timenab & ~EOI_NOTIME;	/* remove time from enable stuff */
    if (enable != EOI_DEFAULTS)		/* i.e. enabled, no triggers */
    {
	if (enable & EOI_HOSTHOOK)	/* call host trigger & return */
	{
	    HostProfHook();
	    return;
	}
	if (enable & EOI_ENABLE_ALL)	/* trigger - turn all events on */
	    EnableAllEOIs();
	else
	    if (enable & EOI_DISABLE_ALL)    /* trigger - turn all events off */
	    {
		DisableAllEOIs();
		return;
	    }
	    else			/* DISABLED other valid legal setting */
	    {
		/* sanity check */
		assert1((enable & EOI_DISABLED), "AtEOIPoint: Invalid enable flag %x", enable);
		return;	/* EOI disabled so return */
	    }
    }

    /* get current raw buffer pointer */
    curRawBuf = (IUH *)*AddProfileData;

    /* write out handle */
    *curRawBuf++ = handle;

    /* check if timestamps required */
    if ((timenab & EOI_NOTIME) == 0)
    {
	/* write out timestamp */
	HostWriteTimestamp((PROF_TIMEPTR)curRawBuf);
	curRawBuf += 2;
    }

    *AddProfileData = (EOI_BUFFER_FORMAT *)curRawBuf;   /* write back new ptr to GDP */

    /* check buffer not full */
    if (curRawBuf >= (IUH *)MaxProfileData)
	ProcessProfBuffer();
}

/*(

============================= AtEOIPointArg ============================

PURPOSE: Call from C on event trigger. Write data to raw data buffer.
	 Triffikly similar to AtEOIPoint but has 'arg' bit added.

INPUT: handle: EOI handle of triggered event.
       arg: IUH argument value to be written

OUTPUT: None

=========================================================================
)*/

GLOBAL void
AtEOIPointArg IFN2 (EOIHANDLE, handle, IUH, arg)
{
    IUH *curRawBuf;			/* pointer into raw data buf */
    IU8 timenab, enable;		/* enable val */

    if (ProfileRawData == (EOI_BUFFER_FORMAT *)0)
    {
	fprintf(stderr, "AtEOIPoint %d called before initialised\n", handle );
	return;
    }

    /* Check whether this EOI enabled */
    timenab = *(EOIEnable + handle);

    enable = timenab & ~EOI_NOTIME;	/* remove time from enable stuff */
    if (enable != EOI_DEFAULTS)		/* i.e. enabled, no triggers */
    {
	if (enable & EOI_HOSTHOOK)	/* call host trigger & return */
	{
	    HostProfArgHook(arg);
	    return;
	}
	if (enable & EOI_ENABLE_ALL)	/* trigger - turn all events on */
	    EnableAllEOIs();
	else
	    if (enable & EOI_DISABLE_ALL)    /* trigger - turn all events off */
	    {
		DisableAllEOIs();
		return;
	    }
	    else			/* DISABLED other valid legal setting */
	    {
		/* sanity check */
		assert1((enable & EOI_DISABLED), "AtEOIPoint: Invalid enable flag %x", enable);
		return;	/* EOI disabled so return */
	    }
    }

    /* get current raw buffer pointer */
    curRawBuf = (IUH *)*AddProfileData;

    /* write out handle */
    *curRawBuf++ = handle;

    /* check if timestamps required */
    if ((timenab & EOI_NOTIME) == 0)
    {
	/* write out timestamp */
	HostWriteTimestamp((PROF_TIMEPTR)curRawBuf);
	curRawBuf += 2;
    }

    /* write out arg */
    *curRawBuf++ = arg;

    *AddProfileData = (EOI_BUFFER_FORMAT *)curRawBuf;   /* write back new ptr to GDP */
    
    /* check buffer not full */
    if (curRawBuf >= (IUH *)MaxProfileData)
	ProcessProfBuffer();
}

/*(

============================ ProcessProfBuffer ============================

PURPOSE: Run through the raw data buffer and update EOIs

INPUT: None.

OUTPUT: None

=========================================================================
)*/

GLOBAL void
ProcessProfBuffer IFN0 ()
{
    PROF_TIMESTAMP startFlush, endFlush;	/* time taken for flush */
    IUH *rawptr;				/* buffer ptr */
    SAVED IBOOL inppb = FALSE;			/* re-entrancy firewall */

    if (inppb)
    {
	fprintf(stderr, "Warning: preventing reentrant attempt to flush profiling info\n");
	return;
    }
    inppb = TRUE;
    HostEnterProfCritSec();	/* critical section buffer access if needed */

    ProfFlushCount++;			/* # flush routine called */

    HostWriteTimestamp(&startFlush);    /* time this flush */

    /* Process the buffer one Raw data slot at a time. As the slots
     * can be of different sizes (arg / non-arg), let the update 
     * routine move the pointer on for us.
     */
    rawptr = (IUH *)ProfileRawData;
    while(rawptr < (IUH *)*AddProfileData)
	if (!updateEOI(&rawptr))
	    break;

    setAddProfileDataPtr(ProfileRawData);
    AddProfileData = getAddProfileDataAddr();

    updateSOIstarts(&startFlush);	/* compensate for flush time */

    HostWriteTimestamp(&endFlush);      /* stop flush timing */
    HostAddTimestamps(&ProfFlushTime, HostTimestampDiff(&startFlush, &endFlush));
    inppb = FALSE;
    HostLeaveProfCritSec();
}

/*(
=============================== GetEOIName ============================

PURPOSE: Get the name (tag) associated with a given EOI

INPUT: handle: EOI handle to fetch.

OUTPUT: tag from that EOI or Null if not found.

=========================================================================
)*/

GLOBAL char *
GetEOIName IFN1 (EOIHANDLE, handle)
{
    EOINODE_PTR srch;		/* search ptr */

    srch = findEOI(handle);	/* lookup EOI node in list */

    if (srch == EOIPTRNULL)	/* Null return means 'not found' */
	return((char *)0);
    else
	return(srch->tag);	/* name in tag field */
}

/*(
============================ DisableEOI =============================

PURPOSE: Turn off a given EOI. Set 'Disabled' flag in enable table entry.

INPUT: handle: EOIHANDLE to be disabled

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
DisableEOI IFN1(EOIHANDLE, handle)
{
    IU8 *enptr;		/* pointer into enable buffer */

    enptr = EOIEnable + handle;
    *enptr |= EOI_DISABLED;	/* set 'disabled' bit */
}

/*(
============================ DisableAllEOIs =============================

PURPOSE: Turn off all EOIs. Run through enable list, adding 'Disabled' 
	 flag.

INPUT: None.

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
DisableAllEOIs IFN0()
{
   IU8 *enptr;		/* pointer into enable buffer */
   ISM32 pool;		/* loop counter */

   enptr = EOIEnable;	/* start of enable buffer */

   for (pool = 0; pool < CurMaxEOI; pool++)
	*enptr++ |= EOI_DISABLED;	/* set 'disabled' bit */
}

/*(
============================ EnableEOI =============================

PURPOSE: Turn on a given EOI. Remove 'Disabled' flag from entry in enable table.

INPUT: handle: EOIHANDLE to be enabled

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
EnableEOI IFN1(EOIHANDLE, handle)
{
    IU8 *enptr;		/* pointer into enable buffer */

    enptr = EOIEnable + handle;
    *enptr &= ~EOI_DISABLED;	/* clear 'disabled' bit */
}

/*(
============================ EnableAllEOIs =============================

PURPOSE: Turn on all EOIs. Run through enable list, removing 'Disabled'
	 flag.

INPUT: None.

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
EnableAllEOIs IFN0()
{
   IU8 *enptr;		/* pointer into enable buffer */
   ISM32 pool;		/* loop counter */

   enptr = EOIEnable;	/* start of enable buffer */

   for (pool = 0; pool < CurMaxEOI; pool++)
	*enptr++ &= ~EOI_DISABLED;	/* clear 'disabled' bit */
}


/*(
========================== SetEOIAsHostTrigger ===========================

PURPOSE: Turn on the host trigger flag for EOI in enable table.

INPUT: handle: EOIHANDLE to be set

OUTPUT: None.

========================================================================
)*/

GLOBAL void
SetEOIAsHostTrigger IFN1(EOIHANDLE, handle)
{
    IU8 *enptr;		/* pointer into enable buffer */

    enptr = EOIEnable + handle;
    *enptr |= EOI_HOSTHOOK;	/* set 'host hook' bit */
}

/*(
======================== ClearEOIAsHostTrigger ===========================

PURPOSE: Turn off the host trigger flag for EOI in enable table.

INPUT: handle: EOIHANDLE to be cleared

OUTPUT: None.

========================================================================
)*/

GLOBAL void
ClearEOIAsHostTrigger IFN1(EOIHANDLE, handle)
{
    IU8 *enptr;		/* pointer into enable buffer */

    enptr = EOIEnable + handle;
    *enptr &= ~EOI_HOSTHOOK;		/* clear 'host hook' bit */
}


/*(
========================== SetEOIAutoSOI ===========================

PURPOSE: Turn on the AutoSOI attribute for EOI.

INPUT: handle: EOIHANDLE to be set

OUTPUT: None.

========================================================================
)*/

GLOBAL void
SetEOIAutoSOI IFN1(EOIHANDLE, handle)
{
    IU8 *enptr;		/* pointer into enable buffer */
    EOINODE_PTR eoin;	/* node for handle */

    eoin = findEOI(handle);
    if (eoin == EOIPTRNULL)
    {
	assert1(NO, "SetEOIAutoSOI - bad handle %d", handle);
	return;
    }

    /* if not already SOI'ed in some way then need to enable timestamps */
    if ((eoin->flags & (EOI_AUTOSOI|EOI_HAS_SOI)) == 0)
    {
	ProcessProfBuffer();	/* flush non timestamp versions */
	enptr = EOIEnable + handle;
	*enptr &= ~EOI_NOTIME;	/* allow timestamp collection */
    }
    eoin->flags |= EOI_AUTOSOI;
}

/*(
========================== ClearEOIAutoSOI ===========================

PURPOSE: Turn off the AutoSOI attribute for EOI.

INPUT: handle: EOIHANDLE to be set

OUTPUT: None.

========================================================================
)*/

GLOBAL void
ClearEOIAutoSOI IFN1(EOIHANDLE, handle)
{
    IU8 *enptr;		/* pointer into enable buffer */
    EOINODE_PTR eoin;	/* node for handle */

    eoin = findEOI(handle);	/* get pointer to node for handle */
    if (eoin == EOIPTRNULL)
    {
	assert1(NO, "ClearEOIAutoSOI - bad handle %d", handle);
	return;
    }

    /* keep SOIs made to date, but don't create any more */
    eoin->flags &= ~EOI_AUTOSOI;
}

/*(
=============================== ResetEOI ============================

PURPOSE: Reset EOI counters

INPUT: handle: EOI handle to reset.

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
ResetEOI IFN1 (EOIHANDLE, handle)
{
    EOINODE_PTR srch;			/* search ptr */
    EOIARG_PTR argnp, lastArgnp;	/* arg list walkers */

    srch = findEOI(handle);	/* lookup EOI node in list */

    if (srch == EOIPTRNULL)	/* Null return means 'not found' */
    {
	assert1(NO, "Profiler:ResetEOI - handle %ld not found", handle);
    }
    else
    {
	srch->count = 0L;		/* reset counters */
	srch->timestamp.data[0] = 0L;
	srch->timestamp.data[1] = 0L;
	srch->lastArg = ARGPTRNULL;
	srch->graph = GRAPHPTRNULL;
	argnp = srch->args;
	if (argnp != ARGPTRNULL)  /* args to free */
	{
	    do {			/* run through list freeing elements */
		lastArgnp = argnp;
		argnp = argnp->next;
		host_free(lastArgnp);		/* ignore return! */
	    } while (argnp != ARGPTRNULL);
	    srch->args = ARGPTRNULL;	/* set ready for new args */
	}
    }
}

/*(
=============================== ResetAllEOIs ============================

PURPOSE: Reset all EOI counters

INPUT: None.

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
ResetAllEOIs IFN0 ( )
{
    EOINODE_PTR srch;			/* search ptr */
    EOIARG_PTR argnp, lastArgnp;	/* arg list walkers */

    srch = EventsOfInterest;			/* head of list */

    while(srch != EOIPTRNULL)			/* list null terminated */
    {
	srch->count = 0L;		/* reset counters */
	srch->timestamp.data[0] = 0L;
	srch->timestamp.data[1] = 0L;
	srch->lastArg = ARGPTRNULL;
	srch->graph = GRAPHPTRNULL;
	argnp = srch->args;
	if (argnp != ARGPTRNULL)  /* args to free */
	{
	    do {			/* run through list freeing elements */
		lastArgnp = argnp;
		argnp = argnp->next;
		host_free(lastArgnp);		/* ignore return! */
	    } while (argnp != ARGPTRNULL);
	    srch->args = ARGPTRNULL;	/* set ready for new args */
	}
	srch = srch->next;
    }
    LastEOI  = EOIPTRNULL;
    LastAuto = EOIPTRNULL;
}

/*(
=============================== ResetAllSOIs ============================

PURPOSE: Reset all SOI counters

INPUT: None.

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
ResetAllSOIs IFN0 ( )
{
    SOINODE_PTR srch, lastSrch;			/* search ptr */
    EOIARG_PTR argnp, lastArgnp;	/* arg list walkers */
    IBOOL into_autos = FALSE;

    srch = SectionsOfInterest;			/* head of list */

    while(srch != SOIPTRNULL)			/* list null terminated */
    {
	srch->startCount = srch->endCount = srch->discardCount =
	srch->soistart.data[0] = srch->soistart.data[1] = 0L;
	srch->time = 0.0;
	srch->mintime = 0.0;
	srch->maxtime = 0.0;
	srch->bigtime = 0.0;
	srch->bigmax = 0.0;

	argnp = srch->startArg;
	if (argnp != ARGPTRNULL)  /* args to free */
	{
	    do {			/* run through list freeing elements */
		lastArgnp = argnp;
		argnp = argnp->next;
		host_free(lastArgnp);		/* ignore return! */
	    } while (argnp != ARGPTRNULL);
	    srch->startArg = ARGPTRNULL;	/* set ready for new args */
	}
	argnp = srch->endArg;
	if (argnp != ARGPTRNULL)  /* args to free */
	{
	    do {			/* run through list freeing elements */
		lastArgnp = argnp;
		argnp = argnp->next;
		host_free(lastArgnp);		/* ignore return! */
	    } while (argnp != ARGPTRNULL);
	    srch->endArg = ARGPTRNULL;	/* set ready for new args */
	}
	if (into_autos)
	{
	    lastSrch = srch;
	    srch = srch->next;
	    host_free(lastSrch);	    
	}
	else if ((srch->flags & (SOI_AUTOSOI|SOI_FROMARG)) != 0)
	{
	    lastSrch->next = SOIPTRNULL;
	    MaxSOI = lastSrch->handle + 1;
	    LastSOI = lastSrch;
	    into_autos = TRUE;
	    lastSrch = srch;
	    srch = srch->next;
	    host_free(lastSrch);
	}
	else
	{
	    lastSrch = srch;
	    srch = srch->next;
	}
    }
}

/*(
=============================== ResetAllGraphData ========================

PURPOSE: Reset all Graph Data

INPUT: None.

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
ResetAllGraphData IFN0 ( )
{
    GRAPHLIST_PTR this, last;		/* graph list walkers */

    this = EventGraph;			/* head of list */

    while(this != GRAPHPTRNULL)			/* list null terminated */
    {
		last = this;
		this = last->next;
		host_free(last);
    }
    EventGraph = LastGraph = GRAPHPTRNULL;	/* set ready for new graph */
}

/*(
======================== GenerateAllProfileInfo ===========================

PURPOSE: General catch all for reporting. Dumps all EOI, SOI & Graph info.

INPUT: stream: output file stream

OUTPUT:

=========================================================================
)*/

GLOBAL void GenerateAllProfileInfo IFN1(FILE *, stream)
{
    time_t now;
    clock_t elapsed_now;
    
    ProcessProfBuffer();		/* flush raw data */
    time(&now);

    fprintf( stream, "SoftPC start time %24.24s, current time %8.8s\n\n",
				start_time, ctime(&now)+11 );
#ifdef macintosh

    elapsed_now = clock();
    fprintf( stream, "Total   Elapsed = %8.2fs\n",
		(elapsed_now - elapsed_t_start) / TicksPerSec );
    fprintf( stream, "Section Elapsed = %8.2fs\n\n",
		(elapsed_now - elapsed_t_resettable) / TicksPerSec );

#else  /* macintosh */
    {
    	struct tms c_t;
   	elapsed_now = times(&c_t);
    
   	fprintf( stream, " Total  CPU times: %8.2fs (User), %8.2fs (System),\n",
		(c_t.tms_utime - process_t_start.tms_utime) / TicksPerSec,
		(c_t.tms_stime - process_t_start.tms_stime) / TicksPerSec );
	fprintf( stream, "\t\t   %8.2fs, %8.2fs (Children's).   ",
		(c_t.tms_cutime - process_t_start.tms_cutime) / TicksPerSec,
		(c_t.tms_cstime - process_t_start.tms_cstime) / TicksPerSec );
	fprintf( stream, "Elapsed = %8.2fs\n",
		(elapsed_now - elapsed_t_start) / TicksPerSec );
	fprintf( stream, "Section CPU times: %8.2fs (User), %8.2fs (System),\n",
		(c_t.tms_utime - process_t_resettable.tms_utime) / TicksPerSec,
		(c_t.tms_stime - process_t_resettable.tms_stime) / TicksPerSec );
	fprintf( stream, "\t\t   %8.2fs, %8.2fs (Children's).   ",
		(c_t.tms_cutime - process_t_resettable.tms_cutime) / TicksPerSec,
		(c_t.tms_cstime - process_t_resettable.tms_cstime) / TicksPerSec );
	fprintf( stream, "Elapsed = %8.2fs\n\n",
		(elapsed_now - elapsed_t_resettable) / TicksPerSec );
    }
#endif /* macintosh */

    CollateFrequencyList(stream, TRUE);
    CollateSequenceGraph(stream);
    SummariseAllSequences(stream);

    fprintf(stream, "\nRaw Data Processing overhead ");
    HostPrintTimestamp(stream, &ProfFlushTime);
    fprintf(stream, " in %d calls\n", ProfFlushCount);
}

/*(
======================== CollateFrequencyList  ===========================

PURPOSE: Output a sorted list of the most frequently encountered EOIs,
	 together with counts.

INPUT: stream: output file stream
       reportstyle: bool to determine whether output formatted (TRUE) or
       left simple for input to graphing package (FALSE).

OUTPUT:

=========================================================================
)*/

GLOBAL void
CollateFrequencyList IFN2 (FILE *, stream, IBOOL, reportstyle)
{
    EOINODE_PTR eoin;		/* list walker */
    IUM32 tot = 0L;		/* total count of events */
    DOUBLE ftot;		/* ...as float */

    /* Get EOI list sorted into count order */
    listSort((SORTSTRUCT_PTR) &EventsOfInterest);

    if (reportstyle)
    {
	fprintf(stream, "EOI Frequency List\n\n");
	fprintf(stream, "    EOI                                       Count      %%\n");
    }

    /* total counts for %age printouts */
    eoin = EventsOfInterest;
    while(eoin)
    {
	tot += eoin->count;
	eoin = eoin->next;
    }

    if (tot == 0L)
	tot = 1;

    /* required as floating */
    ftot = (DOUBLE)tot;

    /* walk list & print out info from each node */
    eoin = EventsOfInterest;
    while(eoin != EOIPTRNULL)
    {
	/* Don't report on disabled EOIs with zero counts. This means
	   that EOIs in C which are not currently of interest do not
	   produce Wads of data that obscure data from EOIs that are
	   of interest. Means that EOIs may be liberally sprinkled in
	   C code without getting in the way. */
        if ( ( !((eoin->flags) & EOI_DISABLED) || eoin->count) )
	    printEOIGuts(stream, eoin, ftot, TRUE, reportstyle);
	eoin = eoin->next;
    }
}

/*(
======================== CollateSequenceGraph  ===========================

PURPOSE: Use information in graph list to show call flow information

INPUT: stream: output file stream

OUTPUT:

=========================================================================
)*/

GLOBAL void
CollateSequenceGraph IFN1 (FILE *, stream)
{
    GRAPHLIST_PTR graphn, gr, succ;		/* list walkers */
    IUM32 succCount;			/* holder for successor count */
    ISM32 curindent = 0L;		/* report printing indent */
    IBOOL goodstart = TRUE;		/* loop terminator */
    IBOOL samelevel = FALSE;		/* new level in tree  or already seen */
    IU8 walked;				/* masked state per node */

#ifdef DEBUGGING_PROF 	/* for seq graph */
graphn = EventGraph;
while (graphn)
{
    printf("Node %s @ %x arg %x succ1 %x succ2 %x xtra %x\n",graphn->graphEOI->tag, graphn, graphn->graphArg, graphn->succ1, graphn->succ2, graphn->extra);
	gr = graphn->extra;
	while (gr != GRAPHPTRNULL)
	{
		printf("    succ1 %x succ2 %x ext %x\n", gr->succ1, gr->succ2, gr->extra);
		gr = gr->extra;
	}
    graphn = graphn->next;
}
#endif /* DEBUGGING_PROF for seq graph */

    if (EventGraph == GRAPHPTRNULL)
    {
	fprintf(stream, "No Graphing Information found\n");
	return;
    }

    fprintf(stream, "\nSequence Graph\n\n");
    while (goodstart)	/* actually for ever - bomb out in middle  */
    {
	/* first have to clear 'printed' flags in top level nodes */
	graphn = EventGraph;
	while (graphn != GRAPHPTRNULL)
	{
	    graphn->state &= ~GR_PRINTED;
	    graphn = graphn->next;
	}

	/* now search for tree header */
	graphn = EventGraph;
	do {
	    /* find first node with untrodden successors */
	    gr = graphn;

	    /* gr checks all successors */
	    do {
		walked = gr->state & GR_TRAMPLED;
		if (walked == 0)		/* nothing walked - any valid successors? */
		{
		    if (gr->succ1 != GRAPHPTRNULL || gr->succ2 != GRAPHPTRNULL)
			break;
		}
		else
		    if (walked == GR_SUCC1_TROD)     /* succ1 trod - 2 valid? */
		    {
			if (gr->succ2 != GRAPHPTRNULL)
			    break;
		    }
		    else
			if (walked == GR_SUCC2_TROD)  /* succ2 trod - 1 valid*/
			{
			    /* this case may not be possible... */
			    if (gr->succ2 != GRAPHPTRNULL)
				break;
			}
			/* must be TRAMPLED otherwise */
		gr = gr->extra;
	    } while (gr != GRAPHPTRNULL);

	    /* no valid successors found for this node, try next */
	    if (gr == GRAPHPTRNULL)
		graphn = graphn->next;
	} while (gr == GRAPHPTRNULL && graphn != GRAPHPTRNULL);

	/* if no nodes with valid successors, we must have finished */
	if (graphn == GRAPHPTRNULL)
	{
	    fprintf(stream, "\n\n");	/* last newline */
	    break;
	}

	/* graphn points at valid node. gr points at (extra?) node with succ */
	curindent = graphn->indent;	/* either 0 or prev indent */
    
	samelevel = FALSE; 	/* first node obviously on new level */

	do {	/* tree from this node */

	    if (!samelevel)		/* true when new node only */
	    {
		/* do graph indent */
		spaces(stream, curindent);

		/* store indent in case revisited */
		graphn->indent = curindent;

		/* print node details */
		if (graphn->graphArg == ARGPTRNULL)		/* arg involved? */
		    fprintf(stream, "%s: ", graphn->graphEOI->tag);
		else
		    fprintf(stream, "%s(%#lx): ", graphn->graphEOI->tag, graphn->graphArg->value);
	    }

	    /* now find a valid successor pointer */
	    gr = graphn;
	    do {
		if ((gr->state & GR_TRAMPLED) != GR_TRAMPLED)
		    break;
		else
		    gr = gr->extra;
	    } while (gr != GRAPHPTRNULL);
	    
	    if (gr == GRAPHPTRNULL)	/* as far as we go for this tree */
	    {
		if (samelevel)		/* tree will need nl to terminate */
		    fprintf(stream, "\n");
		break;
	    }
	    else
	    {
		/* gr is graph node with one or more successor still valid */
		if ((gr->state & GR_SUCC1_TROD) == 0)
		{
		    gr->state |= GR_SUCC1_TROD;   /* succ trodden locally */
		    graphn->state |= GR_PRINTED;  /* print on main node */
		    succ = gr->succ1;
		    succCount = gr->succ1Count;
		}
		else			/* must be succ2 that is valid */
		{
		    gr->state |= GR_SUCC2_TROD;
		    graphn->state |= GR_PRINTED;
		    succ = gr->succ2;
		    succCount = gr->succ2Count;
		}

		if (succ == GRAPHPTRNULL)	/* safety stop here */
		{
		    if (samelevel)		/* tree terminate nl */
			fprintf(stream, "\n");
		    else 
			/* also need newline if dangling graph node from forced
			 * connection without keep graph attr
			 */
			if (gr->succ1 == GRAPHPTRNULL && gr->succ2 == GRAPHPTRNULL)
			    fprintf(stream, "\n");
		    break;
		}

		/* has successor been printed this pass? */
		/* If so then express it as a '->' alternative on same line */
		/* If not then express it as indented new node */
		if ((succ->state & GR_PRINTED) == 0)
		{
		    fprintf(stream, " \\/[%ld]\n",succCount);
		    curindent++;
		    gr = succ;	/* for next iteration */
		    samelevel = FALSE;
		}
		else
		{
		    /* leave gr where it is to look for next successor */
		    if (succ->graphArg == ARGPTRNULL)	/* arg involved? */
			fprintf(stream, "  -> %s:[%ld] ",succ->graphEOI->tag, succCount);
		    else
			fprintf(stream, "  -> %s(%#lx):[%ld] ",succ->graphEOI->tag, succ->graphArg->value, succCount);
		    samelevel = TRUE;
		}
	    }
	    graphn = gr;
	} while (gr != GRAPHPTRNULL);   /* end of this tree */
    }	/* look for next tree head */


    /* Clear all trampled and printed bits ready for next time */
    graphn = EventGraph;
    while (graphn != GRAPHPTRNULL)
    {
	graphn->state = 0;
	gr = graphn->extra;
	while (gr != GRAPHPTRNULL)
	{
	    gr->state = 0;
	    gr = gr->extra;
	}
	graphn = graphn->next;
    }

}

/*(
========================== SummariseEvent =============================

PURPOSE: print to stream all information known about a given EOI
	
INPUT: stream: output file stream
       handle: handle of EOI to summarise

OUTPUT:

=========================================================================
)*/

GLOBAL void
SummariseEvent IFN2 (FILE *, stream, EOIHANDLE, handle)
{
    EOINODE_PTR eoin;		/* list walker */

    eoin = findEOI(handle);

    fprintf(stream, "Summary of Event Information for handle %ld\n", handle);
    fprintf(stream, "  EOI			Count\n");
    if (eoin != EOIPTRNULL)
	printEOIGuts(stream, eoin, 0.0, TRUE, TRUE);
    else
	fprintf(stream, "Profiler:SummariseEvent - EOI handle %ld unknown", handle);
}

/*(
========================== SummariseSequence =============================

PURPOSE: print to stream all information known about a given SOI
	
INPUT: stream: output file stream
       handle: handle of SOI to summarise

OUTPUT:

=========================================================================
)*/

GLOBAL void
SummariseSequence IFN2 (FILE *, stream, SOIHANDLE, handle)
{
    SOINODE_PTR soin;	/* list walker */
    DOUBLE tottime;	/* bigtimes + regular times */

    soin = findSOI(handle);

    if (soin != SOIPTRNULL)
    {
	fprintf( stream, "%4ld ", handle );
	if (soin->startCount == soin->endCount)
	    fprintf(stream, "    ----- %9ld", soin->startCount);
	else
	    fprintf(stream, "%9ld %9ld", soin->startCount, soin->endCount );
	if (soin->time > USECASFLOAT)
		fprintf(stream, "     %2.5lfS ", soin->time / USECASFLOAT);
	else
		fprintf(stream, " %10.2lfuS ", soin->time);
	if (soin->endCount)
	    fprintf( stream, " (%8.2lfuS)  ",
		soin->time / (soin->endCount - soin->discardCount));
        else
            fprintf( stream, "               " );

	/* STF - idea - how about subtracting max & min from total times???? */
	if (CollectingMaxMin)
	{
	    fprintf(stream, "Max: %10.2lfuS ", soin->maxtime);
	    fprintf(stream, "Min: %8.2lfuS", soin->mintime);
	}

	if (soin->startArg == ARGPTRNULL)	/* primary level start SOI */
	    fprintf(stream, "\tEOIs %s\n",
			GetEOIName(soin->startEOI));
	else			/* extra level - includes args */
	    fprintf(stream, "\tEOIs %s(%#x)\n",
			GetEOIName(soin->startEOI), soin->startArg->value);

        fprintf(stream, "     %9ld          ", soin->discardCount );
	tottime = soin->bigtime+soin->time;
	if (tottime > USECASFLOAT)
		fprintf(stream, "     %2.5lfS ", tottime / USECASFLOAT);
	else
		fprintf(stream, " %10.2lfuS ", tottime);
	if (soin->endCount)
	    fprintf( stream, " (%8.2lfuS)  ", tottime/soin->endCount);
        else
            fprintf( stream, "               " );
        if (CollectingMaxMin)
	    fprintf(stream, "     %10.2lfuS                ", soin->bigmax);
	if (soin->endArg == ARGPTRNULL)		/* primary level end EOI */
	    fprintf(stream, "\t &   %s\n", GetEOIName(soin->endEOI));
	else
	    fprintf(stream, "\t &   %s(%#x)\n", GetEOIName(soin->endEOI), soin->endArg->value);
    }
    else
	fprintf(stream, "Profiler:SummariseSequence - SOI handle %ld unknown", handle);
}

/*(
========================== OrderedSequencePrint =============================

PURPOSE: print to stream ordered (by time) list of all SOIs between 
	 start & end EOIs.

INPUT:  stream: output file stream
	startEOI, endEOI: handles defining SOI of interest.

OUTPUT: Hopefully useful SOI data.

=========================================================================
)*/

GLOBAL void
OrderedSequencePrint IFN3(SOIHANDLE, startEOI, SOIHANDLE, endEOI, FILE *, stream)
{
	SOINODE_PTR soin;	/* list walker */
	DOUBLE thistime;
	IU32 loop, maxseq;
	struct ordsoi {
		struct ordsoi *next;
		struct ordsoi *prev;
		SOINODE_PTR soi;
		DOUBLE time;
	} *ordlist, *hol, *seed, *tol, *thisnode, *srch;
#define ORDNULL  (struct ordsoi *)0
     
	maxseq = MaxSOI + 1;
	ordlist = (struct ordsoi *)host_malloc(maxseq * sizeof(struct ordsoi));
	if (ordlist == (struct ordsoi *)0)
	{
		fprintf(stderr, "OrderedSequencePrint: out of memory\n");
		return;
	}
	fprintf(stream, "\nSummary of Sections between EOIs %d & %d\n\n", startEOI, endEOI);
	for (loop = 1; loop < maxseq; loop ++)
	{
		ordlist[loop].soi = SOIPTRNULL;
	  /*
		ordlist[loop].next = &ordlist[loop + 1];
		ordlist[loop].prev = &ordlist[loop - 1];
	  */
	}
	ordlist[0].prev = ORDNULL;
	ordlist[loop - 1].next = ORDNULL;

	ordlist[0].time = 500.0;	/* seed */
	ordlist[0].soi = SOIPTRNULL;

	hol = seed = tol = ordlist;	/* head & tail move, middle stays */
	loop = 0;
	soin = SectionsOfInterest;
	while (soin != SOIPTRNULL)
	{
		if (soin->startEOI == startEOI && soin->endEOI == endEOI)
		{
			loop ++;	/* next storage node */
			thisnode = &ordlist[loop];
			thistime = soin->time + soin->bigtime;

			thisnode->time = thistime;
			thisnode->soi = soin;

			if (thistime >= hol->time)
			{
				/* insert at head of list */
				thisnode->prev = hol->prev;
				hol->prev = thisnode;
				thisnode->next = hol;
				hol = thisnode;
			}
			else
			{
				if (thistime <= tol->time)
				{
					/* add to end of list */
					thisnode->prev = tol;
					thisnode->next = tol->next;
					tol->next = thisnode;
					tol = thisnode;
				}
				else
				{
					if (thistime <= seed->time)
					{
						/* search fwd from seed */

						srch = seed->next;
						while(srch != tol && thistime <= srch->time)
							srch = srch->next;
						if (srch != tol)	/* insert */
						{
							thisnode->prev = srch->prev;
							srch->prev->next = thisnode;
							srch->prev = thisnode;
							thisnode->next = srch;
						}
						else	/* tol - new tol? */
						{
							if (thistime <= tol->time)
							{
								/* add to end - new tol */
								thisnode->prev = tol;
								thisnode->next = tol->next;
								tol->next = thisnode;
								tol = thisnode;
							}
							else
							{
								/* insert before tol */
								thisnode->prev = tol->prev;
								tol->prev->next = thisnode;
								tol->prev = thisnode;
								thisnode->next = tol;
							}
						}
					}
					else
					{	/* search bwd from seed */

						srch = seed->prev;
						while(srch != hol && thistime >= srch->time)
							srch = srch->prev;
						if (srch != hol)	/* insert */
						{
							thisnode->prev = srch;
							thisnode->next = srch->next;
							srch->next->prev = thisnode;
							srch->next = thisnode;
						}
						else	/* at hol */
						{
							if (thistime >= hol->time)
							{	/* add before - new hol */

								thisnode->next = hol;
								thisnode->prev = hol->prev;
								hol->prev = thisnode;
								hol = thisnode;
							}
							else
							{	/* insert after hol */

								thisnode->next = hol->next;
								hol->next->prev = thisnode;
								hol->next = thisnode;
								thisnode->prev = hol;
							}
						}
					}
				}
			}
			
		}
		soin = soin->next;
	}


	/* should now have a list, sorted by time - print it */
	while(hol != tol)
	{
		if (hol->soi != SOIPTRNULL)
			SummariseSequence(stream, hol->soi->handle);

		hol = hol->next;
	}
	host_free(ordlist);
}

/*(
========================== SummariseAllSequences =============================

PURPOSE: print to stream all information known about SOIs

INPUT: stream: output file stream

OUTPUT: None.

=========================================================================
)*/

GLOBAL void
SummariseAllSequences IFN1 (FILE *, stream)
{
    SOINODE_PTR soin;	/* list walker */
    EOINODE_PTR stEOI, endEOI;

    soin = SectionsOfInterest;

    fprintf(stream, "\nSummary of All Sections of Interest\n\n");
    while(soin != SOIPTRNULL)
    {
	/* Don't report on SOIs where start and end EOIs are disabled
	   and startCount and endCount are both zero */
	stEOI = endEOI = EventsOfInterest;
	while(stEOI->handle != soin->startEOI) stEOI = stEOI->next;
	while(endEOI->handle != soin->endEOI) endEOI = endEOI->next;
	if ( ( !( (stEOI->flags)  & EOI_DISABLED) ||
	       !( (endEOI->flags) & EOI_DISABLED) ||
	       soin->startCount || soin->endCount ) )
	    SummariseSequence(stream, soin->handle);
	soin = soin->next;
    }
}

/*(
=============================== dump_profile ============================

PURPOSE: dump all the profiling system data to a file.

INPUT: None.

=========================================================================
)*/

GLOBAL void
dump_profile IFN0 ()
{
	char filename[80], *test;
	FILE *prof_dump;
	
	if (!Profiling_enabled)
	{
		fprintf( stderr, "Dump not done. Profiling disabled\n" );
		return;
	}

	if ( (test = getenv("PROFILE_OUTPUT_FILE") ) == NULL )
		strcpy( filename, "profile_data.out" );
	  else
		strcpy( filename, test );
	if ( (prof_dump = fopen( filename, "a" )) == NULL)
	{
		fprintf( stderr, "Can't open file %s for profile data\n",
				filename );
		return;
	}
	
	fprintf(stderr, "Dumping profile data to file %s ...", filename );
	fflush(stderr);
	AtEOIPoint( elapsed_time_end );
	AtEOIPoint( elapsed_time_start );
	GenerateAllProfileInfo( prof_dump );
	fprintf(prof_dump, "\n\n==============================================================================\n\n\n" );
	fclose(prof_dump);
	fprintf(stderr, " Done\n");
	return;
}

/*(
=============================== reset_profile ============================

PURPOSE: reset all the profiling system data.

INPUT: None.

=========================================================================
)*/

GLOBAL void
reset_profile IFN0 ()
{
	if (!Profiling_enabled)
	{
		fprintf( stderr, "Reset not done. Profiling disabled\n" );
		return;
	}

	fprintf(stderr, "Resetting profiling system  ..." );
	fflush(stderr);

	ResetAllSOIs();
	ResetAllEOIs();

	ResetAllGraphData();

	ProfFlushTime.data[0] = 
	ProfFlushTime.data[1] = 0L;	/* time spent in flush routine */
	ProfFlushCount = 0;		/* # flush routine called */

	elapsed_t_resettable = host_times( &process_t_resettable );
	fprintf(stderr, " Done\n" );
	AtEOIPoint( elapsed_time_start );

	return;
}


/*(
=============================== ProfileInit ============================

PURPOSE: initialise the variables of the profiling system.

INPUT: None.

OUTPUT: None

=========================================================================
)*/

GLOBAL void
ProfileInit IFN0 ()
{
    IHPE bufalign;		/* buffer allocation & alignment pointer */
    time_t now;

    if ( !(IBOOL)GetSadInfo("ProfilingInUse") )
    {
	fprintf( stderr, "LCIF not profiled - profiling disabled\n" );
	Profiling_enabled = FALSE;
	return;
    }

    /* get buffer for raw event data */
    ProfileRawData = (EOI_BUFFER_FORMAT *)host_malloc(RAWDATAENTRIES * sizeof(EOI_BUFFER_FORMAT)+ sizeof(IUH));

    /* check for success */
    if (ProfileRawData == (EOI_BUFFER_FORMAT *)0)
    {
	assert0(NO, "Profiler:ProfileInit - Out of Memory\n");
	return;
    }

    /* ensure buffer aligned for IUH writes */
    bufalign  = (IHPE)ProfileRawData & (sizeof(IUH)-1);
    if (bufalign != 0L)
    {
	bufalign = (IHPE)ProfileRawData + (sizeof(IUH) - bufalign);
	ProfileRawData = (EOI_BUFFER_FORMAT *)bufalign;
    }

    /* global variables set for buffer control (leave alignment buffer 
     * as buffer entries of different sizes).
     */
    MaxProfileData = ProfileRawData + RAWDATAENTRIES - 1;

    /* Prepare EOI enable table - start with 1024 entries and allow to grow */
    EOIEnable = (IU8 *)host_malloc(INITIALENABLESIZE);
    if (EOIEnable == (IU8 *)0)
    {
	assert0(NO, "Profiler:ProfileInit - Out of Memory\n");
	return;
    }
    
    /* Prepare EOI directory table - start with 1024 entries and allow to grow */
    EOIDir = (EOINODE_PTR *)host_malloc(INITIALENABLESIZE * sizeof(EOINODE_PTR) );
    if (EOIDir == (EOINODE_PTR *)0 )
    {
	assert0(NO, "Profiler:ProfileInit - Out of Memory\n");
	return;
    }
    
    /*
     * write buffer variables to GDP for CPU access. Current pointer must
     * be stored there but have global C pointer to access pointer.
     */
    setEOIEnableAddr(EOIEnable);
    setMaxProfileDataAddr(MaxProfileData);
    setAddProfileDataPtr(ProfileRawData);
    AddProfileData = getAddProfileDataAddr();
    HostWriteTimestamp(&BufStartTime);
    HostProfInit();     /* host specific profile initialisation */

    getPredefinedEOIs();	/* get EOIs & SOIs defined in EDL translation */

    if (getenv("PROFDOMAX") != 0)
	CollectingMaxMin = TRUE;

    /* Hooks in C Code need EOIs to be created here */
    elapsed_time_start = NewEOI( "ElapsedTime_START", EOI_DEFAULTS);
    elapsed_time_end   = NewEOI( "ElapsedTime_END", EOI_DEFAULTS);
    /* end of C Code EOIs */
    
    /* Set up C Code SOIs here */
    AssociateAsSOI( elapsed_time_start, elapsed_time_end );
    /* end of C Code SOIs */
    
    /* set up data for process timings */
    time(&now);
    strcpy( (char *)&start_time[0], ctime(&now) );

    elapsed_t_start = elapsed_t_resettable = host_times( &process_t_start );

#ifdef macintosh

    TicksPerSec = (DOUBLE)CLOCKS_PER_SEC;

#else  /* macintosh */

    process_t_resettable.tms_utime  =  process_t_start.tms_utime;
    process_t_resettable.tms_stime  =  process_t_start.tms_stime;
    process_t_resettable.tms_cutime =  process_t_start.tms_cutime;
    process_t_resettable.tms_cstime =  process_t_start.tms_cstime;

    TicksPerSec = (DOUBLE)sysconf(_SC_CLK_TCK);

#endif /* macintosh */

    AtEOIPoint( elapsed_time_start );
}

#else /* PROFILE */
GLOBAL void EnableAllEOIs IFN0() { ; }
GLOBAL void DisableAllEOIs IFN0() { ; }
GLOBAL void ProcessProfBuffer IFN0() { ; }
#endif /* PROFILE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=debug
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=                ..\debuggng.c    \
                        ..\ega_dump.c    \
                        ..\btrace.c      \
                        ..\trace.c       \
                        ..\profile.c     \
                        ..\pigyoda.c     \
                        ..\yoda.c

i386_SOURCES=		..\dasm.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\fdisk.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * INSIGNIA (SUB)MODULE SPECIFICATION -----------------------------
 *
 *
 * THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE CUSTOMER, THE
 * CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST NOT BE DISCLOSED TO ANY
 * OTHER PARTIES  WITHOUT THE EXPRESS AUTHORISATION FROM THE DIRECTORS OF
 * INSIGNIA SOLUTIONS LTD.
 *
 *
 * DOCUMENT 		:
 *
 * RELATED DOCS		: WD2010-05 datasheet WD11C00C-22 (RMAC) eng.spec
 * (Intel 82062 ... very similar to WD2010) IBM PC XT286 tech.ref
 *
 * DESIGNER		: Jerry Kramskoy
 *
 * REVISION HISTORY	: First version		: 14-Sep-88.
 *
 * SUBMODULE NAME		: fdisk
 *
 * SOURCE FILE NAME	: fdisk.c
 *
 * PURPOSE			: emulate fixed disk controller and sector buffer
 * manager components of AT dual card.
 *
 * SccsID = @(#)fdisk.c	1.35 08/31/93 Copyright Insignia Solutions Ltd.
 *
 *
 * [1.INTERMODULE INTERFACE SPECIFICATION]
 *
 * [1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]
 *
 * INCLUDE FILE : fdisk.gi
 *
 * [1.1    INTERMODULE EXPORTS]
 *
 * PROCEDURES() :	fdisk_inb((io_addr)port, (unsigned char *)value)
 * (uchar)fdisk_read_dir((io_addr)port, (unsigned char *)value) (void)
 * fdisk_outb((io_addr)port, (unsigned char )value)
 * fdisk_inw((io_addr)port, (unsigned short *)value) (void)
 * fdisk_outw((io_addr)port,(unsigned short)value) (void)
 * (void) fdisk_reset() (int)  fdisk_physattach((int)driveno, (char
 * *)name) (void) fdisk_physdetach((int)driveno) (void) fdisk_ioattach()
 * (void) fdisk_iodetach()
 *
 * DATA 	     :	none
 *
 * -------------------------------------------------------------------------
 * [1.2 DATATYPES FOR [1.1] (if not basic C types)]
 *
 * STRUCTURES/TYPEDEFS/ENUMS:
 *
 * -------------------------------------------------------------------------
 * [1.3 INTERMODULE IMPORTS] (not o/s objects or standard libs)
 *
 * PROCEDURES() : 	none
 *
 * DATA 	     : 	none
 *
 * -------------------------------------------------------------------------
 *
 * [1.4 DESCRIPTION OF INTERMODULE INTERFACE]
 *
 * [1.4.1 IMPORTED OBJECTS]
 *
 * FILES ACCESSED    :	disk image file(s) for C: (and D:)
 *
 * DEVICES ACCESSED  :	none
 *
 * SIGNALS CAUGHT	  :	none
 *
 * SIGNALS ISSUED	  :	none
 *
 *
 * [1.4.2 EXPORTED OBJECTS]
 * =========================================================================
 * PROCEDURE	  : 	fdisk_inb((io_addr)port, (unsigned char *)value)
 * fdisk_outb((io_addr)port, (unsigned char)value)
 *
 * PURPOSE		  : 	i/o space read (write) of a taskfile register these
 * should be byte accesses.
 *
 * fdisk_inw((io_addr)port, (unsigned short *)value) fdisk_outw((io_addr)port,
 * (unsigned short)value)
 *
 * PURPOSE		  : 	i/o space read (write) of next index into sector
 * buffer. (for port 1f0). Not normal usage for accessing taskfile.
 *
 *
 * PARAMETERS
 *
 * port	  : 	the i/o address to read. Taskfile addresses are (hex): (1f0)
 * -	data register (see fdisk_inw) 1f1	-	error register 1f2
 * -	sector count register 1f3	-	sector number register 1f4
 * -	cylinder low register 1f5	-	cylinder high register 1f6
 * -	drive/head register 1f7	-	status register
 *
 * value	  :	(pointer to) byte (short) to receive the value contained in
 * the specified register.
 *
 * GLOBALS		  :	none.
 *
 * RETURNED VALUE	  : 	copy of returned value (inb, inw)
 *
 * DESCRIPTION	  : 	this procedure returns the contents of the specified
 * register, having called any active state machine (which may update the
 * status). Each disk command has a corresponding state machine, which gets
 * initialised when the command is issued, and subsequently called as the
 * command progresses. Only those commands involving data transfer between
 * the host (cpu) and the adaptor can cause multiple calls to the state
 * machine
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 * =========================================================================
 * PROCEDURE	  : 	(unsigned char) fdisk_read_dir((io_addr)port,
 * (unsigned char *)value)
 *
 * PURPOSE		  : 	return the value of the 7 bits in the fixed disk
 * register pertinent to the fixed disk. (cooperates with floppy)
 *
 * PARAMETERS	  :	as per fdisk_inb()
 *
 * GLOBALS		  :	the taskfile
 *
 * RETURNED VALUE	  : 	value of digital input register (at port 0x3f7)
 *
 * DESCRIPTION	  : 	obvious
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 *
 * =========================================================================
 * PROCEDURE	  : 	fdisk_ioattach() fdisk_iodetach()
 *
 * PURPOSE		  : 	attach/detach the fixed disk components to the
 * io-subsytem. plug/unplug the configured drives to the disk controller (if
 * any). Patches drive parameter block table entries 0 and 1 in system ROM.
 *
 * PARAMETERS	  :	none
 *
 * GLOBALS		  :	the drive structure [fd, wiredup members]
 *
 * RETURNED VALUE	  : 	none
 *
 * DESCRIPTION	  : 	attaches/detaches to ios as usual. For the drive(s),
 * the drive structure is used to see whether the disk image(s) are opened or
 * non-existent. Based on existence, drive structure indicates plugged
 * in/unplugged. On attach, disk parameter block table entries 1 and 2 (entry
 * 1 for drive type 1 is used for the C drive (drive 0), and entry 2 for
 * drive type 2 is used for the D drive (drive 1)) are edited to reflect the
 * #.of cylinders available.
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 * =========================================================================
 * PROCEDURE	  : 	fdisk_physattach(driveno, name)
 * fdisk_physdetach(driveno)
 *
 * PURPOSE		  : 	validate and attach host resource(s) for drive(s)
 * /detach host resource(s).
 *
 * PARAMETERS	  : driveno		-	0 (drive 0 (C:)) or	1
 * (drive 1 (D:)) name		-	pointer to string for hard disk file
 * name. If null string, then the indicated drive is taken to not exist.
 *
 * GLOBALS		  :	the drive structure [fd, maxcyl members]
 *
 * RETURNED VALUE	  : 	none
 *
 * DESCRIPTION	  : 	for attaching, use host validation procedure to
 * validate and open the specified drive image (if not the null string, else
 * mark as no drive available). Use the #.of cylinders returned by the
 * validation to set the max.cylinder number (= #.cyls - 1) into the drive
 * structure for the drive.
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 *
 * =========================================================================
 * PROCEDURE	  : 	fdisk_reset()
 *
 * PURPOSE		  : 	power up the disk subsystem.
 *
 * PARAMETERS	  :	none
 *
 * GLOBALS		  :	the taskfile
 *
 * RETURNED VALUE	  : 	none
 *
 * DESCRIPTION	  : 	sets registers etc. to their powered-up, pre-POST
 * values.
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 *
 *
 * =========================================================================
 * [3.INTERMODULE INTERFACE DECLARATIONS]
 * =========================================================================
 *
 * [3.1 INTERMODULE IMPORTS]
 */
IMPORT	int	soft_reset;

/* [3.1.1 #INCLUDES]                                                    */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_HDA.seg"
#endif

#include <stdio.h>
#include TypesH
#include StringH
#include "xt.h"
#include "trace.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "ios.h"
#include "ica.h"
#include "dsktrace.h"
#include "debug.h"
#include "sas.h"
#include "quick_ev.h"

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						 */
#include "fdisk.h"


/*
 * 5.MODULE INTERNALS   :   (not visible externally, global internally)]
 *
 * [5.1 LOCAL DECLARATIONS]
 */

/* [5.1.1 #DEFINES]							 */

/*
 * task file ports (9 registers accessed via 7 ports)
 */
#define TFBASE		0x1f0

#define	TFERROR		0x1f1
#define	TFPCMP		0x1f1
#define	TFSCOUNT	0x1f2
#define	TFSNUM		0x1f3
#define	TFCYLLO		0x1f4
#define	TFCYLHI		0x1f5
#define	TFDRVHD		0x1f6
#define	TFSTATUS	0x1f7
#define	TFCMD		0x1f7

/*
 * task file indices ... the 7 ports map out to 9 registers (by using the
 * read/write io signal) arbitrarily set the write precomp register and the
 * command registers at indices 8 and 9
 */
#define	WDERROR		1
#define	WDSCOUNT	2
#define	WDSNUM		3
#define	WDCYLLO		4
#define	WDCYLHI		5
#define	WDDRVHD		6
#define	WDSTAT		7
#define	WDPCMP		8
#define	WDCMD		9

/*
 * wd2010 command register bits.
 */
#define WDCMD_I 0x08
#define WDCMD_M 0x04
#define WDCMD_L 0x02
#define WDCMD_T 0x01

/*
 * command decoding constants, where bits 7-4 of command are non-unique
 */
#define	DIAG_OR_PARMS	9
#define	DIAG		0
#define	PARMS		1

/*
 * wd2010 status register bits
 */
#define	WDSTATBUSY		0x80
#define	WDSTATDRDY		0x40
#define	WDSTATWFAULT		0x20
#define	WDSTATSEEKCOMPLETE	0x10
#define	WDSTATDRQ		0x08
#define	WDSTATDC		0x04
#define	WDSTATCIP		0x02
#define	WDSTATERROR		0x01

/*
 * wd2010 error register bits (bits 0,1,6,7 never get set for this emulation
 * ... since these reflect bad ECC etc.)
 */
#define	WDERRNOID		0x10
#define	WDERRABORT		0x04

/*
 * io signal
 */
#define	IOREAD		0
#define	IOWRITE		~IOREAD

/*
 * interrupt line value
 */
#define	IRQDEASSERT	0
#define	IRQCLEAR	1
#define 	IRQASSERT	~IRQDEASSERT

/*
 * state control for disk commands
 */
#define	START		1	/* new command		 */
#define	CONTINUE	2	/* command in progress	 */
#define	BRDY		3	/* sector buffer ready 	 */
#define	BCR		4	/* clear sector buffer counter */

#define	IDMISMATCH	~0	/* bad seek		 */

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			 */

/*
 * following describes the disk geometry for a drive, and the file descriptor
 * for the disk image.
 */
typedef struct _drvinfo
{
	long            driveid;
	long            physattached;
	long            maxhead;
	long            maxcyl;
	long            maxsect;
	long            nsecspertrack;
	long            nbytespercyl;
	long            nbytespertrack;
	long            wiredup;
	long            curoffset;
}               drvinfo_;


/* [5.1.3 PROCEDURE() DECLARATIONS]					 */

#ifdef ANSI
static void     restore(int);
static void     seek(int);
static void     rsector(int);
static void     wsector(int);
static void     format(int);
static void     rverify(int);
static void     diagnose(int);
static void     setparams(int);
static void     bad(int);
static void     irq(int);
static void     rmac(unsigned short *, int);
static long     dosearchid(void);
static void     doseek(void);
static int      disktobuffer(long);
static int      buffertodisk(long);
#else
static void     restore();
static void     seek();
static void     rsector();
static void     wsector();
static void     format();
static void     rverify();
static void     diagnose();
static void     setparams();
static void     bad();
static void     irq();
static void     rmac();
static long     dosearchid();
static void     doseek();
static int      disktobuffer();
static int      buffertodisk();
#endif				/* ANSI */

/*
 * -----------------------------------------------------------------------
 * [5.2 LOCAL DEFINITIONS]
 *
 * [5.2.1 INTERNAL DATA DEFINITIONS
 */

/*
 * dual card can support 2 drives max.
 */
static drvinfo_ drives[2];

/*
 * pointer to the currently selected drive. (gets set up whenever the
 * drive/head register in the taskfile gets written to)
 */
static drvinfo_ *pseldrv;

/*
 * the fixed disk register (write only, 0x3f6)
 */
static unsigned char fixeddiskreg;

/*
 * the digital input register .. reflects state of head and drive selected
 */
static unsigned char digipreg;

/*
 * the wd2010 taskfile (element [0] is pad byte) ... 9 registers + dummy to
 * allow direct table indexing
 */
LOCAL unsigned char taskfile[10];

/*
 * command dispatch ... based on bits 7-4 of command register as index.
 */
LOCAL void     (*dispatch[]) IPT1(int, state) =
{
	bad,
	restore,
	rsector,
	wsector,
	rverify,
	format,
	bad,
	seek,
	bad,
	bad,			/* further decoded	 */
	bad,
	bad,
	bad,
	bad,
	bad,
	bad,
};

/*
 * if a command is in progress, this points to the state machine for that
 * command
 */
LOCAL void     (*activecmd) IPT1(int, state);

/*
 * sector buffer variables
 */
static unsigned char sectindx;
static unsigned short sectbuffer[256];

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				 */

/*
 * ==========================================================================
 * FUNCTION	:	dosearchid() PURPOSE		:	simulate
 * searching for <cyl,hd,sec> id field. If out of range for configured
 * geometry, return failure, else return appropriate file offset into disk
 * image. N.B This assumes that ALL TRACKS have been FORMATTED WITH SECTOR
 * ID's 1-#.sectors per track). EXTERNAL OBJECTS:	drive info for
 * selected drive; taskfile. RETURN VALUE	:	-1 if bad parameters
 * for command else file offset (from byte 0) into hard disk image. INPUT
 * PARAMS	: RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL long
dosearchid IFN0()
{
	long            head;
	long            cylinder;
	long            sector;

	/*
	 * head ok? (heads numbered from 0 - maxhead)
	 */
	head = taskfile[WDDRVHD] & 0xf;

	if (head > 7 && !(fixeddiskreg & 0x8))
		return IDMISMATCH;

	if (head > pseldrv->maxhead)
		return IDMISMATCH;

	/*
	 * sector ok? (assumes all tracks have been formatted with sector ids
	 * 1 - nsecspertrack which is DOS standard)
	 */
	sector = taskfile[WDSNUM];

	if (sector > pseldrv->nsecspertrack || sector <= 0)
		return IDMISMATCH;

	/*
	 * cylinder ok? (we've imposed an artificial limit on the maximum
	 * cylinder number based upon the file size)
	 */
	cylinder = ((unsigned long) taskfile[WDCYLHI] << 8) +
		(unsigned long) taskfile[WDCYLLO];
	if (cylinder > pseldrv->maxcyl)
		return IDMISMATCH;

	return (cylinder * pseldrv->nbytespercyl + head *
		pseldrv->nbytespertrack + (sector - 1L) * 512L);
}

/*
 * ==========================================================================
 * FUNCTION	:	updateposregs() PURPOSE		:	update the
 * sector count and number registers. if this produces a track or cylinder
 * transfer, then update the head/cylinder registers. This is a guestimate of
 * what the WD1015 micro is doing when it handles these situations, and
 * programs the WD2010. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
updateposregs IFN0()
{
	(taskfile[WDSCOUNT])--;
	if (++taskfile[WDSNUM] > pseldrv->nsecspertrack)
	{
		int             head;
		int             cylinder;

		/*
		 * start at sector 1 of next track
		 */
		taskfile[WDSNUM] = 1;
		head = taskfile[WDDRVHD] & 0xf;
		if (++head > pseldrv->maxhead)
		{

			/*
			 * need to select next cylinder and use head 0.
			 */
			taskfile[WDDRVHD] &= 0xf0;

			cylinder = ((unsigned int) taskfile[WDCYLHI] << 8) + taskfile[WDCYLLO];
			taskfile[WDCYLLO] = (++cylinder) & 0xff;
			taskfile[WDCYLHI] = cylinder >> 8;
		} else
		{

			/*
			 * select next head to read next track
			 */
			taskfile[WDDRVHD] &= 0xf0;
			taskfile[WDDRVHD] |= head;
			if (head > 7)
				fixeddiskreg |= 8;
		}
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	doseek() PURPOSE		:	'seek' to
 * requested cylinder. if requested drive not wired up, then drive will not
 * be ready. (and seek will be incomplete). If cylinder exceeds max. get
 * drive ready and seek complete, but will get 'id not found' when the track
 * gets accessed. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
doseek IFN0()
{

	/*
	 * the drive ready status will be set up when the drive/head register
	 * gets written to. here, just set the seek complete bit in the
	 * status register appropriately
	 */
	if (taskfile[WDSTAT] & WDSTATDRDY)
	{
		dt0(DHW | HWXINFO, 0, "\t\t+SC\n")
		taskfile[WDSTAT] |= WDSTATSEEKCOMPLETE;
	} else
	{
		dt0(DHW | HWXINFO, 0, "\t\t-SC\n")
			taskfile[WDSTAT] &= ~WDSTATSEEKCOMPLETE;
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	restore() PURPOSE		: EXTERNAL OBJECTS:
 * RETURN VALUE	: INPUT  PARAMS	:	state	-	START or CONTINUE
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
restore IFN1(int, state)
{
	UNUSED(state);
	dt0(DHW | HWXINFO, 0, "\tRESTORE cmd\n")
		doseek();
	if (!(taskfile[WDSTAT] & WDSTATDRDY))
	{
		taskfile[WDSTAT] |= WDSTATERROR;
		taskfile[WDERROR] = WDERRABORT;
		dt0(DHW | HWXINFO, 0, "\t\t+ERROR,err=abort\n")
	}
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	seek() PURPOSE		:	emulate seek command.
 * Just sets up appropriate status changes (error condition possibly)
 * EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:	state	-
 * START or CONTINUE RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
seek IFN1(int, state)
{
	UNUSED(state);
	dt0(DHW | HWXINFO, 0, "\tSEEK cmd\n")

		doseek();

	/*
	 * if drive not ready, error
	 */
	if (!(taskfile[WDSTAT] & WDSTATDRDY))
	{
		dt0(DHW | HWXINFO, 0, "\t\t+ERROR,err=abort\n")
			taskfile[WDSTAT] |= WDSTATERROR;
		taskfile[WDERROR] = WDERRABORT;
	}
	/*
	 * deassert 'busy' and 'command in progress'; reset the sector buffer
	 * counter; issue interrupt
	 */
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	rsector() PURPOSE		:	emulate read
 * command. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:	state
 * -	START or CONTINUE or BRDY RETURN PARAMS   :
 * ==========================================================================
 */

LOCAL void
fdisk_pause IFN1(long, junk)
{
	UNUSED(junk);
	(*activecmd) (CONTINUE);
}

LOCAL void
rsector IFN1(int, state)
{
	static int      s;
	long            offset;

	if (state == START)
	{
		dt0(DHW | HWXINFO, 0, "\tREAD cmd\n")
			s = 0;
	}
	while (1)
		switch (s)
		{
		case 0:
			doseek();
			if (!(taskfile[WDSTAT] & WDSTATDRDY))
			{
				dt0(DHW | HWXINFO, 0, "\t\t(drv not ready)set err=abort\n")
					taskfile[WDERROR] |= WDERRABORT;
				s = 3;
				continue;
			}
			s = 1;
		case 1:
			if ((offset = dosearchid()) == IDMISMATCH)
			{
				dt0(DHW | HWXINFO, 0, "\t\tset err=abort,noid\n")
					taskfile[WDERROR] = WDERRNOID | WDERRABORT;
				s = 3;
				continue;

			}
			s = 2;
		case 2:
			rmac((unsigned short *) 0, BCR);

			/*
			 * disk controller transfers disk data to sector
			 * buffer
			 */
			if (!disktobuffer(offset))
			{
				dt0(DHW | HWXINFO, 0, "\t\tset err=abort,noid\n")
					taskfile[WDERROR] = WDERRNOID | WDERRABORT;
				s = 3;
				continue;

			}
			rmac((unsigned short *) 0, BCR);
			updateposregs();

			/*
			 * at this point, tell the host to unload the sector
			 * buffer, and wait for BRDY signal from sector
			 * buffer when unloaded. (this will occur once host
			 * has done 256 inw's or equivalent)
			 */
			taskfile[WDSTAT] |= WDSTATDRQ;
			taskfile[WDSTAT] &= ~WDSTATBUSY;
			dt0(DHW | HWXINFO, 0, "\t\t+DRQ -BUSY\n")

				if (taskfile[WDSCOUNT]
			/* && (taskfile[WDCMD] & WDCMD_M) ??? M=1 case ??? */
				)
			{
				/* more sectors to come */
				irq(IRQASSERT);
				s = 30;
			} else
			{
				/* last sector done */
				irq(IRQASSERT);
				s = 31;
			}
			return;
		case 3:

			/*
			 * flag error in status register
			 */
			taskfile[WDSTAT] |= WDSTATERROR;
			taskfile[WDSTAT] |= WDSTATDRQ;
			taskfile[WDSTAT] &= ~WDSTATBUSY;
			dt0(DHW | HWXINFO, 0, "\t\t+DRQ +ERROR -BUSY\n")
				irq(IRQASSERT);
			s = 31;
			return;
		case 30:

			/*
			 * wait for buffer ready signal from sector buffer
			 */
			if (state == BRDY)
			{
				taskfile[WDSTAT] &= ~WDSTATDRQ;
				taskfile[WDSTAT] |= WDSTATBUSY;
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ +BUSY\n")
					irq(IRQDEASSERT);
				/*
				 * Give CPU chance to run while we find the
				 * next disk sector. In particular the BIOS
				 * can read the disk status register before
				 * we raise the next interrupt. This is
				 * crucial as reading the disk status
				 * register deasserts the interrupt.
				 */
				add_q_event_i(fdisk_pause, HOST_FDISK_DELAY_1, 0);
				s = 32;
			}
			return;
		case 31:
			if (state == BRDY)
			{
				taskfile[WDSTAT] &= ~WDSTATDRQ;
				taskfile[WDSTAT] &= ~WDSTATCIP;
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ -CIP\n")
					irq(IRQDEASSERT);
				rmac((unsigned short *) 0, BCR);
			}
			return;
		case 32:
			s = 1;
			continue;
		}
}

/*
 * ==========================================================================
 * FUNCTION	:	wsector() PURPOSE		:	handle the
 * 'write' command. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:
 * state	-	START or CONTINUE or BRDY RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
wsector IFN1(int, state)
{
	static int      s;
	long            offset;

	if (state == START)
	{
		dt0(DHW | HWXINFO, 0, "\tWRITE cmd\n")
			s = 0;
	}
	while (1)
		switch (s)
		{
		case 0:

			/*
			 * tell host to fill sector buffer
			 */
			dt0(DHW | HWXINFO, 0, "\t\t+DRQ\n")
				taskfile[WDSTAT] |= WDSTATDRQ;
			s = 1;
			return;
		case 1:

			/*
			 * wait for sector buffer to be filled by host (don't
			 * issue IRQ first time around)
			 */
			if (state == BRDY)
			{
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ\n")
					taskfile[WDSTAT] &= ~WDSTATDRQ;
				s = 2;
				continue;
			}
			return;
		case 2:

			/*
			 * check drive is ready, and can find sector to write
			 * to.
			 */
			doseek();
			if (!(taskfile[WDSTAT] & WDSTATDRDY))
			{
				dt0(DHW | HWXINFO, 0, "\t\t(drv not ready)err=abort\n")
					taskfile[WDERROR] |= WDERRABORT;
				s = 10;
				continue;
			} else
			{
				if ((offset = dosearchid()) == IDMISMATCH)
				{
					dt0(DHW | HWXINFO, 0, "\t\terr=abort,noid\n")
						taskfile[WDERROR] = WDERRNOID | WDERRABORT;
					s = 10;
					continue;

				}
				s = 3;
				continue;
			}
		case 3:
			rmac((unsigned short *) 0, BCR);

			/*
			 * disk controller transfers sector buffer to disk
			 */
			if (!buffertodisk(offset))
			{

				/*
				 * any errors we report as missing ID
				 */
				dt0(DHW | HWXINFO, 0, "\t\terr=abort,noid\n")
					taskfile[WDERROR] = WDERRNOID | WDERRABORT;
				s = 10;
				continue;

			}
			rmac((unsigned short *) 0, BCR);
			updateposregs();
			if (taskfile[WDSCOUNT])
			{

				/*
				 * more to go ... tell host to fill sector
				 * buffer again
				 */
				dt0(DHW | HWXINFO, 0, "\t\t+DRQ\n")
					taskfile[WDSTAT] |= WDSTATDRQ;
				irq(IRQASSERT);
				s = 4;
				return;
			} else
				/*
				 * all done
				 */
				s = 11;
			continue;
		case 4:

			/*
			 * wait for sector buffer to be filled by host
			 */
			if (state == BRDY)
			{
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ\n")
					taskfile[WDSTAT] &= ~WDSTATDRQ;

				/*
				 * prepare for next sector
				 */
				s = 2;
				continue;
			}
			return;
		case 10:
			dt0(DHW | HWXINFO, 0, "\t\tset ERROR\n")
				taskfile[WDSTAT] |= WDSTATERROR;
		case 11:
			dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
			taskfile[WDSTAT] &= ~WDSTATBUSY;
			taskfile[WDSTAT] &= ~WDSTATCIP;
			irq(IRQASSERT);
			rmac((unsigned short *) 0, BCR);
			return;
		}
}

/*
 * ==========================================================================
 * FUNCTION	:	format() PURPOSE		:	handle the
 * 'format' command. almost a 'dummy' command, but needs to make host write
 * to sector buffer. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:
 * state	-	START or CONTINUE or BRDY RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
format IFN1(int, state)
{
	static int      s;

	if (state == START)
	{
		dt0(DHW | HWXINFO, 0, "\tFORMAT cmd\n")
			s = 0;
	}
	while (1)
		switch (s)
		{
		case 0:

			/*
			 * initialise sector buffer tell application to write
			 * to sector buffer
			 */
			rmac((unsigned short *) 0, BCR);
			dt0(DHW | HWXINFO, 0, "\t\t+DRQ\n")
				taskfile[WDSTAT] |= WDSTATDRQ;
			s = 1;
			return;
		case 1:

			/*
			 * wait for sector buffer to fill
			 */
			if (state == BRDY)
			{

				/*
				 * no more data, thanks.
				 */
				doseek();
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ\n")
					taskfile[WDSTAT] &= ~WDSTATDRQ;
				if (!(taskfile[WDSTAT] & WDSTATDRDY))
				{

					/*
					 * formatting thin air!
					 */
					s = 2;
					continue;
				} else
				{
					int             cylinder;

					cylinder = ((unsigned int) taskfile[WDCYLHI] << 8)
						+ taskfile[WDCYLLO];
					if (cylinder > pseldrv->maxcyl)

						/*
						 * formatting the spindle!
						 */
						s = 2;
					else
						s = 3;
					continue;
				}
			}
			return;
		case 2:
			dt0(DHW | HWXINFO, 0, "\t\t+ERROR,err=abort")
				taskfile[WDERROR] |= WDERRABORT;
			taskfile[WDSTAT] |= WDSTATERROR;
			s = 3;
		case 3:
			irq(IRQASSERT);
			dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP")
				taskfile[WDSTAT] &= ~WDSTATBUSY;
			taskfile[WDSTAT] &= ~WDSTATCIP;
			rmac((unsigned short *) 0, BCR);
			return;
		}
}

/*
 * ==========================================================================
 * FUNCTION	:	rverify() PURPOSE		:	handle the
 * 'read verify' command. .. basically a dummy command. EXTERNAL OBJECTS:
 * RETURN VALUE	: INPUT  PARAMS	:	state	-	START or CONTINUE
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
rverify IFN1(int, state)
{

	UNUSED(state);
	/*
	 * if drive not ready, error
	 */
	dt0(DHW | HWXINFO, 0, "\tREAD VERIFY cmd\n")
		doseek();
	if (!(taskfile[WDSTAT] & WDSTATDRDY))
	{
		dt0(DHW | HWXINFO, 0, "\t\t+ERROR,err=abort\n")
			taskfile[WDSTAT] |= WDSTATERROR;
		taskfile[WDERROR] = WDERRABORT;
	}
	/*
	 * deassert 'busy' and 'command in progress'; reset the sector buffer
	 * counter; issue interrupt
	 */
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	diagnose() PURPOSE		:	handle the
 * 'diagnostics' command. EXTERNAL OBJECTS: RETURN VALUE	: INPUT
 * PARAMS	:	state	-	START or CONTINUE RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
diagnose IFN1(int, state)
{
	UNUSED(state);
	dt0(DHW | HWXINFO, 0, "\tDIAGNOSTICS cmd\n")

	/*
	 * flag diagnostics as successful
	 */
		dt0(DHW | HWXINFO, 0, "\t\terr=1\n")
		taskfile[WDERROR] = 1;

	/*
	 * deassert 'busy' and 'command in progress'; reset the sector buffer
	 * counter; issue interrupt
	 */
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	setparams() PURPOSE		:	handle the
 * 'set parameters' command. EXTERNAL OBJECTS:	task file. drives. RETURN
 * VALUE	: INPUT  PARAMS	:	state	-	START or CONTINUE
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
setparams IFN1(int, state)
{

	UNUSED(state);
	
	dt0(DHW | HWXINFO, 0, "\tSET PARAMETERS cmd\n")

	/*
	 * legal head values are 0 to (nheads-1)
	 */
		pseldrv->maxhead = taskfile[WDDRVHD] & 0xf;

	/*
	 * legal sector ids are 1 to nsecspertrack
	 */
	pseldrv->nsecspertrack = taskfile[WDSCOUNT];

	/*
	 * calculate some geometry constants ... the dual card is set up for
	 * 512 byte sectors.
	 */
	pseldrv->nbytespertrack = pseldrv->nsecspertrack * 512L;
	pseldrv->nbytespercyl = pseldrv->nbytespertrack * (pseldrv->maxhead + 1L);


	/*
	 * deassert 'busy' and 'command in progress'; reset the sector buffer
	 * counter; issue interrupt
	 */
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY,-CIP,+SC\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	taskfile[WDSTAT] |= WDSTATSEEKCOMPLETE;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	bad() PURPOSE		:	handle unrecognised
 * disk commands EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:	state
 * -	START or CONTINUE RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
bad IFN1(int, state)
{
	UNUSED(state);
	
	dt0(DHW | HWXINFO, 0, "\tBAD cmd\n")

		taskfile[WDSTAT] |= WDSTATERROR;
	taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	taskfile[WDERROR] = WDERRABORT;
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP +ERROR;err=abort\n")
		rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	wd2010() PURPOSE		:	main
 * procedure for the disk controller component of the dual card. This does
 * NOT handle sector buffer accesses. EXTERNAL OBJECTS:	taskfile,sectbuf.
 * RETURN VALUE	: INPUT  PARAMS	:	taskindx	-	index into
 * taskfile value		-	pointer to byte value io
 * 	IOREAD or IOWRITE RETURN PARAMS   :	*value		-	set
 * if IOWRITE
 * ==========================================================================
 */
LOCAL void
wd2010 IFN3(int, taskindx, half_word *, value, int, io)
{

	/*
	 * ignore any task file writes if command in progress (unless new
	 * command)
	 */
	if ((taskfile[WDSTAT] & WDSTATCIP) &&
	    io == IOWRITE && taskindx != WDCMD)
	{
		dt0(DHW | HWXINFO, 0, "\tcommand in progress .. write ignored\n")
			return;
	}
	if (io == IOREAD)
	{

		/*
		 * deassert the interrupt request line.
		 */
		if (taskindx == WDSTAT)
			irq(IRQDEASSERT);

		/*
		 * if a command is in progress, then use this poll as an
		 * excuse to kick the controller again.
		 */
		if (taskfile[WDSTAT] & WDSTATCIP)
			(*activecmd) (CONTINUE);



		/*
		 * for the status register, return the WD2010 status. The
		 * real maccoy actually returns the RMAC's status which
		 * differs from the WD2010 in usage of bit 1. For the WD2010,
		 * this is the 'command in progress' status. For the RMAC,
		 * this is derived from the Index signal returned from the
		 * drive. Since this gives the appearance of being randomish,
		 * (unless being explicitly examined over a long period of
		 * time), just use the WD2010 value.
		 */
		*value = taskfile[taskindx];

		return;
	}
	/*
	 * must be writing to task file and no command is in progress.
	 */
	taskfile[taskindx] = *value;
	if (taskindx == WDCMD)
	{
		int             cmd, drdy;

		/*
		 * deassert interrupt request, clear error register, set
		 * 'command in progress' and busy. maintain same status of
		 * drive ready signal.
		 */
		irq(IRQDEASSERT);
		taskfile[WDERROR] = 0;
		drdy = taskfile[WDSTAT] & WDSTATDRDY;
		if (drdy)
		{
			dt0(DHW | HWXINFO, 0, "\t\t+CIP -WF -SC -DRQ -DC -ERROR +BUSY +DRDY\n")
		} else
		{
			dt0(DHW | HWXINFO, 0, "\t\t+CIP -WF -SC -DRQ -DC -ERROR +BUSY -DRDY\n")
		}
		taskfile[WDSTAT] = WDSTATCIP | WDSTATBUSY | drdy;

		/*
		 * decode the command
		 */
		cmd = *value >> 4;
		if (cmd == DIAG_OR_PARMS)
		{
			if ((*value & 0xf) == DIAG)
				activecmd = diagnose;
			else if ((*value & 0xf) == PARMS)
				activecmd = setparams;
			else
				activecmd = bad;
		} else
			activecmd = dispatch[cmd];

		/*
		 * and start the command off
		 */
		(*activecmd) (START);
	} else if (taskindx == WDDRVHD)
	{

		/*
		 * digital input register reflects head select lines
		 */
		digipreg = (taskfile[WDDRVHD] & 0xf) >> 2;

		if (taskfile[WDDRVHD] & 0x10)
		{

			/*
			 * drive 1 selected
			 */
			digipreg |= 2;

			/*
			 * second drive selected. does it exist?
			 */
			if (!drives[1].wiredup)
			{
				/* no */
				pseldrv = (drvinfo_ *) 0;
				taskfile[WDSTAT] &= ~WDSTATDRDY;
				dt0(DHW | HWXINFO, 0, "\t\t-DRDY\n")
			} else
			{
				/* yes */
				pseldrv = &drives[1];
				taskfile[WDSTAT] |= WDSTATDRDY;
				dt0(DHW | HWXINFO, 0, "\t\t+DRDY\n")
			}
		} else
		{

			/*
			 * first drive selected
			 */

			/*
			 * drive 1 selected
			 */
			digipreg |= 1;

			if (!drives[0].wiredup)
			{
				/* no */
				pseldrv = (drvinfo_ *) 0;
				taskfile[WDSTAT] &= ~WDSTATDRDY;
				dt0(DHW | HWXINFO, 0, "\t\t-DRDY\n")
			} else
			{
				/* yes */
				pseldrv = drives;
				taskfile[WDSTAT] |= WDSTATDRDY;
				dt0(DHW | HWXINFO, 0, "\t\t+DRDY\n")
			}
		}
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	irq() PURPOSE		:	assert/deassert the
 * fixed disk interrupt line EXTERNAL OBJECTS: RETURN VALUE	: INPUT
 * PARAMS	:	line	-	IRQCLEAR,IRQASSERT or IRQDEASSERT
 * RETURN PARAMS   :
 * ==========================================================================
 */

void disk_int_call_back IFN1(long, junk)
{
	UNUSED(junk);
	ica_hw_interrupt (1,6,1);
}

LOCAL void
irq IFN1(int, line)
{
	static int      intrq = IRQDEASSERT;
	switch (line)
	{
	case IRQCLEAR:
		dt0(DHW | INTRUPT, 0, "\t\t** -IRQ\n")
			intrq = IRQDEASSERT;
		break;
	case IRQASSERT:
		if (intrq != IRQASSERT)
		{
			dt0(DHW | INTRUPT, 0, "\t\t** +IRQ\n")

				intrq = IRQASSERT;

			/*
			 * check interrupts not masked out
			 */
			if (!(fixeddiskreg & 2))
				add_q_event_i (disk_int_call_back, HOST_FDISK_DELAY_2, 0);
		}
		break;
	case IRQDEASSERT:
		if (intrq == IRQASSERT)
		{
			dt0(DHW | INTRUPT, 0, "\t\t** -IRQ\n")

				intrq = IRQDEASSERT;

			/* JOKER always wants to deassert the real ICA line */
#ifndef	JOKER
			if (!(fixeddiskreg & 2))
#endif
				ica_clear_int(1, 6);
		}
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	rmac() PURPOSE		:	emulate the buffer
 * manager and controller (WD11C00C-22 (RMAC)) which looks after the sector
 * buffer. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:	value
 * -	pointer to short to write/read with buffer. sig	-	READ,WRITE or
 * BCR (BCR resets the buffer index .. simulates the BCR pulse) RETURN PARAMS
 * :
 * ==========================================================================
 */
LOCAL void
rmac IFN2(USHORT *, value, int, sig)
{

	switch (sig)
	{
	case BCR:
		dt0(DHW | HWXINFO, 0, "\t\tBCR raised to sector buffer\n")
			sectindx = 0;
		return;
	case IOWRITE:
		sectbuffer[sectindx] = *value;
		break;
	case IOREAD:
		*value = sectbuffer[sectindx];
	}
	if (!++sectindx)
	{
		if (activecmd)
		{
			dt0(DHW | HWXINFO, 0, "\t\t++sector buffer raises BRDY\n")
				(*activecmd) (BRDY);
		}
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	disktobuffer() PURPOSE		:	read a sector
 * from disk image into sector buffer EXTERNAL OBJECTS:	drive structure
 * RETURN VALUE    :	0 	-	error reading file ~0	-	ok.
 * INPUT  PARAMS	:	offset	-	file offset (from 0)
 * ==========================================================================
 */
#define ONESECTOR	1

LOCAL int
disktobuffer IFN1(long, offset)
{
	dt1(DHW | HWXINFO,0,
	    "\t\tdisk data(offset %lx(hex)) -> sector buffer\n", offset)
		return host_fdisk_rd(pseldrv->driveid, offset, ONESECTOR, (char *) sectbuffer);
}

/*
 * ==========================================================================
 * FUNCTION	:	buffertodisk() PURPOSE		:	write the
 * sector buffer to disk image EXTERNAL OBJECTS:	drive structure
 * RETURN VALUE    :	0 	-	error reading file ~0	-	ok.
 * INPUT  PARAMS	:	offset	-	file offset (from 0)
 * ==========================================================================
 */
LOCAL int
buffertodisk IFN1(long, offset)
{
	dt1(DHW | HWXINFO,0,
	    "\t\tsector buffer -> disk (offset %lx(hex))\n", offset)

		return host_fdisk_wt(pseldrv->driveid, offset, ONESECTOR, (char *) sectbuffer);
}

/*
 * 7.INTERMODULE INTERFACE IMPLEMENTATION :
 *
 * [7.1 INTERMODULE DATA DEFINITIONS]
 */
/*
 * [7.2 INTERMODULE PROCEDURE DEFINITIONS]
 */

GLOBAL UTINY fdisk_read_dir IFN2(io_addr, port, UTINY *,value)
{
		switch (port)
	{
	case 0x3f7:
		*value = digipreg;
		dt1(DHW | PORTIO, 0, "read of DIR returns %x(hex)\n", (unsigned) *value)
			break;
	default:
		break;
	}
		return *value;
}

GLOBAL VOID fdisk_inb IFN2(io_addr, port, UTINY *,value)
{
	dt0(DHW, 0, "(\n")

	if (taskfile[WDSTAT] & WDSTATBUSY)
	{
		/* Controller is busy. Return status register contents. */
		*value = taskfile[WDSTAT];
		dt1(DHW | PORTIO, 0, "inb on port %x(hex) - controller busy\n", port)

		/*
		 * deassert the interrupt request line.
		 */
		if ((port - TFBASE) == WDSTAT)
			irq(IRQDEASSERT);

	}
	else
		switch (port)
		{
			case TFBASE:

				/*
		 		 * sector buffer must be accessed only in 16 bit quantities
		 		 */
#ifndef PROD
				printf("(fdisk_inb()) inb on sector buffer ignored!\n");
#endif
				break;
			default:
				dt1(DHW | PORTIO, 0, "inb on port %x(hex)\n", port)

				wd2010(port - TFBASE, value, IOREAD);

				dt1(DHW | PORTIO, 0, "returns %x(hex)\n", (unsigned) *value)
		}
	dt0(DHW, 0, ")\n")
}

GLOBAL VOID fdisk_inw IFN2(io_addr, port, USHORT *, value)
{
#ifdef	JOKER
	/* This is the only way JOKER talks to disks, since
	** Ade's fast disk bios is currently infeasible.
	** Hence, speed is of interest here!
	*/
	if (port == TFBASE)
	{
		/* For speed, JOKER doesn't bother with calling rmac(IOREAD). */

		*value = HostWordToIntelWord(sectbuffer[sectindx]);

		if (!++sectindx)	/* sectindx is a byte value -- wraparound? */
		{
			if (activecmd)
			{
				(*activecmd) (BRDY);
			}
		}
	}

#else	/* JOKER */

#ifdef BIGEND
	unsigned short  temp;
#endif
		switch (port)
	{
	case TFBASE:

#ifdef LITTLEND
			rmac(value, IOREAD);
#endif

#ifdef BIGEND
		rmac(&temp, IOREAD);
		*value = ((temp << 8) & 0xff00) | (temp >> 8);
#endif

#if 0
		dt1(DHW | PORTIO, 0, "inw on sector buffer returns %x(hex)\n", *value)
#else
		dt1(DHW | PORTIO, INW_TRACE_HNDL, "inw on sector buffer", *value)
#endif
			break;
	default:
		/*
		 * task file registers must be accessed as byte quantities
		 */
		dt1(DHW | PORTIO, 0, "inw on port %x(hex) ignored!\n",
		    (unsigned) port)
			break;
	}
#endif	/* JOKER */
}


GLOBAL VOID fdisk_outb IFN2(io_addr, port, UTINY, value)
{
#ifndef NEC_98
	dt0(DHW, 0, "(\n")
		switch (port)
	{
	case TFBASE:

		/*
		 * byte access to sector buffer is not a good idea
		 */
#ifndef PROD
		printf("(disk_outb()) outb to sector buffer ignored\n!");
#endif
		break;
	case TFPCMP:
		dt2(DHW | PORTIO, 0, "outb to port %x(hex),val %x(hex)\n",
		    (unsigned) port, (unsigned) value)

			wd2010(WDPCMP, &value, IOWRITE);

		dt0(DHW | PORTIO, 0, "\n")
			break;
	case TFCMD:
		dt2(DHW | PORTIO, 0, "outb to port %x(hex),val %x(hex)\n",
		    (unsigned) port, (unsigned) value)

			wd2010(WDCMD, &value, IOWRITE);

		dt0(DHW | PORTIO, 0, "\n")
			break;
	case DISKETTE_FDISK_REG:

		/*
		 * Fixed disk register
		 */
		dt2(DHW | PORTIO, 0, "outb to port %x(hex),val %x(hex)\n",
		    (unsigned) port, (unsigned) value)

			if ((fixeddiskreg & 0x4) && !(value & 0x4))
			{
				/* Turn reset off */
				taskfile[WDSTAT] = WDSTATDRDY | WDSTATSEEKCOMPLETE;
				/* Error register in diagnostic mode */
				taskfile[WDERROR] = 0x01; /* No errors */
				/* Reset rest of taskfile */
				taskfile[WDSCOUNT] = taskfile[WDSNUM] = 0x01;
				taskfile[WDCYLLO] = taskfile[WDCYLHI] = taskfile[WDDRVHD] = 0;
			}

			fixeddiskreg = value;

			if (fixeddiskreg & 0x4)
			{
				/* Enable reset fixed disk function */
				taskfile[WDSTAT] = WDSTATBUSY | WDSTATDC | WDSTATERROR;
			}
		break;
	default:
		dt2(DHW | PORTIO, 0, "outb to port %x(hex),val %x(hex)\n",
		    (unsigned) port, (unsigned) value)

			wd2010(port - TFBASE, &value, IOWRITE);
		dt0(DHW | PORTIO, 0, "\n")
	}
	dt0(DHW, 0, ")\n")
#endif // !NEC_98
}

GLOBAL VOID fdisk_outw IFN2(io_addr, port, USHORT, value)
{
#ifdef BIGEND
	unsigned short  temp;
#endif
		switch (port)
	{
	case TFBASE:
#if 0
		dt1(DHW | PORTIO, 0, "outw to sector buffer, val %x(hex)\n",
		    (unsigned) value)
#else
		dt1(DHW | PORTIO, OUTW_TRACE_HNDL, "outw to sector buffer",
		    (unsigned) value)
#endif

#ifdef LITTLEND
			rmac(&value, IOWRITE);
#endif

#ifdef BIGEND
		temp = ((value << 8) & 0xff00) | (value >> 8);
		rmac(&temp, IOWRITE);
#endif

			break;
	default:
		/*
		 * task file registers must be accessed as byte quantities
		 */
		dt1(DHW | PORTIO, 0, "outw to port %x(hex) ignored!\n",
		    (unsigned) port)
			break;
	}
}

GLOBAL VOID fdisk_ioattach IFN0()
{
#ifndef NEC_98
	unsigned short  ncyls;
	unsigned char   nheads;
	unsigned char   nsects;
	io_addr         p;

	/*
	 * attach to io subsystem
	 */
	io_define_in_routines (HDA_ADAPTOR, fdisk_inb,  fdisk_inw,  0, 0);
	io_define_out_routines(HDA_ADAPTOR, fdisk_outb, fdisk_outw, 0, 0);
	/*
	 * attach taskfile
	 */
	for (p = DISK_PORT_START; p <= DISK_PORT_END; p++)
		io_connect_port(p, HDA_ADAPTOR, IO_READ_WRITE);

	/*
	 * attach Fixed disk register
	 */
	io_connect_port(DISKETTE_FDISK_REG, HDA_ADAPTOR, IO_WRITE);

	if (drives[0].physattached)
	{

		/*
		 * indicate drive is wired up to controller
		 */
		drives[0].wiredup = ~0;

		/*
		 * patch 'ROM' table for drive type 0 with appropriate number
		 * of cylinders
		 */
		ncyls = (unsigned short)(drives[0].maxcyl + 1);
		nheads = (unsigned char)(drives[0].maxhead + 1);
		nsects = (unsigned char)(drives[0].maxsect + 1);
#ifdef REAL_ROM
		host_write_enable((DPB0 & (~0xfff)), (DPB0 & (~0xfff)) + 0x1000);
#endif
		patch_rom(DPB0, (unsigned char) (ncyls & 0xff));
		patch_rom(DPB0+1, (unsigned char) (ncyls >> 8));
		patch_rom(DPB0+2, nheads);
		patch_rom(DPB0+0xe, nsects);
#ifdef REAL_ROM
		host_write_protect((DPB0 & (~0xfff)), (DPB0 & (~0xfff)) + 0x1000);
#endif
		dt1(DHW | IOAD, 0, "drive 0 wiredup, total cyls %d\n",
		    (unsigned) ncyls)
	}
	if (drives[1].physattached)
	{

		/*
		 * indicate drive is wired up to controller
		 */
		drives[1].wiredup = ~0;

		/*
		 * patch 'ROM' table for drive type 0 with appropriate number
		 * of cylinders
		 */
		ncyls = (unsigned short)(drives[1].maxcyl + 1);
		nheads = (unsigned char)(drives[1].maxhead + 1);
		nsects = (unsigned char)(drives[1].maxsect + 1);
#ifdef REAL_ROM
		host_write_enable((DPB1 & (~0xfff)), (DPB1 & (~0xfff)) + 0x1000);
#endif
		patch_rom(DPB1, (unsigned char)(ncyls & 0xff));
		patch_rom(DPB1 + 1, (unsigned char)((ncyls >> 8)));
		patch_rom(DPB1+2, nheads);
		patch_rom(DPB1+0xe, nsects);
#ifdef REAL_ROM
		host_write_protect((DPB1 & (~0xfff)), (DPB1 & (~0xfff)) + 0x1000);
#endif
		dt1(DHW | IOAD, 0, "drive 1 wiredup, total cyls %d\n",
		    (unsigned) ncyls)
	}
#endif // !NEC_98
}

GLOBAL VOID fdisk_iodetach IFN0()
{
#ifndef NEC_98
	io_addr         p;

	/*
	 * detach from io subsystem
	 */
	for (p = DISK_PORT_START; p <= DISK_PORT_END; p++)
		io_disconnect_port(p, HDA_ADAPTOR);

	io_disconnect_port(DISKETTE_FDISK_REG, HDA_ADAPTOR);

	if (drives[0].physattached)
	{

		/*
		 * indicate not wired up ... reset table in ROM to indicate
		 * 'bad drive type'
		 */
		drives[0].wiredup = 0;
#ifdef REAL_ROM
		host_write_enable((DPB0 & (~0xfff)), (DPB0 & (~0xfff)) + 0x1000);
#endif
		patch_rom(DPB0, 0);
		patch_rom(DPB0 + 1, 0);
		patch_rom(DPB0 + 2, 0);
		patch_rom(DPB0 + 0xe, 0);
#ifdef REAL_ROM
		host_write_protect((DPB0 & (~0xfff)), (DPB0 & (~0xfff)) + 0x1000);
#endif
		dt0(DHW | IOAD, 0, "drive 0 unplugged\n")
	}
	if (drives[1].physattached)
	{

		/*
		 * indicate not wired up ... reset table in ROM to indicate
		 * 'bad drive type'
		 */
		drives[1].wiredup = 0;
#ifdef REAL_ROM
		host_write_enable((DPB1 & (~0xfff)), (DPB1 & (~0xfff)) + 0x1000);
#endif
		patch_rom(DPB1, 0);
		patch_rom(DPB1 + 1, 0);
		patch_rom(DPB1 + 2, 0);
		patch_rom(DPB1 + 0xe, 0);
#ifdef REAL_ROM
		host_write_protect((DPB1 & (~0xfff)), (DPB1 & (~0xfff)) + 0x1000);
#endif
		dt0(DHW | IOAD, 0, "drive 1 unplugged\n")
	}
#endif // !NEC_98
}

GLOBAL VOID fdisk_physattach IFN1(int,driveno)
{
	int             invalid = 0;
	int             ncyls;
	int             nheads;
	int             nsects;

	drives[driveno].driveid = driveno;
	drives[driveno].physattached = 0;

	if (!*((CHAR *) config_inquire((IU8)(C_HARD_DISK1_NAME + driveno), NULL)))
		return;

	/*
	 * configuration specifies a disk image file ... validate it
	 */
	 host_fdisk_get_params(driveno, &ncyls, &nheads, &nsects);

	/*
	 * set maximum available cylinder value (this is
	 * artificial. The real controller on an AT does not
	 * have this knowledge ... it fails on ID matching if
	 * it seeks to a non-existent cylinder
	 */
	drives[driveno].nsecspertrack = nsects;
	drives[driveno].nbytespertrack = nsects * 512L;
	drives[driveno].nbytespercyl = drives[driveno].nbytespertrack * nheads;
	drives[driveno].maxcyl = --ncyls;
	drives[driveno].maxhead = --nheads;
	drives[driveno].maxsect = --nsects;
	drives[driveno].physattached = ~0;

	fast_disk_bios_attach(driveno);
}

#ifdef macintosh

GLOBAL VOID fdisk_physdetach IFN1(int,driveno)
{
	if (drives[driveno].physattached)
	{
		host_fdisk_close(driveno);

		drives[driveno].physattached = 0;

		fast_disk_bios_detach (driveno);

		dt0(DHW|PAD, 0, "drive %d closed\n")
	}
}
#endif /* macintosh */

GLOBAL VOID fdisk_reset IFN0()
{
	taskfile[WDERROR] = 0;
	taskfile[WDSCOUNT] = 0;
	taskfile[WDSNUM] = 0;
	taskfile[WDCYLLO] = 0;
	taskfile[WDCYLHI] = 0;
	taskfile[WDDRVHD] = 0;

	/*
	 * show drive 1 selected ... head 0 selected
	 */
	digipreg = 1;

	/*
	 * show drive is ready if available
	 */
	if (drives[0].wiredup)
	{
		taskfile[WDSTAT] = WDSTATDRDY | WDSTATSEEKCOMPLETE;

		/*
		 * reposition file pointer for drive 0 at beginning of file
		 */
		host_fdisk_seek0(0);
	} else
		taskfile[WDSTAT] = 0;

	if (drives[1].wiredup)

		/*
		 * reposition file pointer for drive 1 at beginning of file
		 */
	host_fdisk_seek0(1);

	/*
	 * initialise sector buffer
	 */
	rmac((unsigned short *) 0, BCR);
}


GLOBAL VOID hda_init IFN0()
{
	fdisk_iodetach();
	fast_disk_bios_detach(0);
	fast_disk_bios_detach(1);

	fdisk_physattach(0);
	fdisk_physattach(1);
	fdisk_ioattach();
	fdisk_reset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\trace.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: Trace function
 *
 * Description	: This function will output a trace to the log device.
 *		  The device is set up in the main function module.  Options
 *		  are provided to VPC memory/register data.
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 * SccsID	: @(#)trace.c	1.36 06/02/95
 *
 * (c)Copyright Insignia Solutions Ltd., 1990-1994. All rights reserved.
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_ERROR.seg"
#endif

/*
 *    O/S include files.
 */
#include <stdlib.h>
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#define CPU_PRIVATE	/* Request the CPU private interface as well */
#include CpuH
#undef CPU_PRIVATE
#include "sas.h"
#include "gvi.h"
#include "trace.h"

#ifdef CPU_40_STYLE
FORWARD CHAR *host_get_287_reg_as_string IPT2(IU32, reg_num, BOOL, in_hex);
FORWARD IU32 get_287_tag_word IPT0();
FORWARD IU32 get_287_control_word IPT0();
FORWARD IU32 get_287_status_word IPT0();
FORWARD IU32 get_287_sp IPT0();
#endif

FILE *trace_file;

#ifndef PROD
#ifdef SPC386
#include "decode.h"
#define DASM_INTERNAL
#include <dasm.h>
#else /* SPC386 */
IMPORT word dasm IPT5(char *, i_output_stream, word, i_atomicsegover,
	word, i_segreg, word, i_segoff, int, i_nInstr);
#endif /* SPC386 */
int disk_trace = 0;		/* value of 1 indicates temp disk trace */
static int trace_state = 0;
#endif /* nPROD */

static int trace_start = 0;

GLOBAL IU32 io_verbose = 0;
GLOBAL IU32 sub_io_verbose = 0;

#ifdef RDCHK
#include "egacpu.h"

void get_lar()

{
#ifndef PROD
#ifndef NEC_98
	printf( "There's no such thing as the last_address_read anymore.\n" );
	printf( "Perhaps you'd like the latches instead: %x\n", getVideolatches() );
#endif // !NEC_98
#endif
}

#endif

#if !defined(PROD) && defined(SPC386)

LOCAL IS32 read_from_la IFN1(LIN_ADDR, addr)
{
	return (IS32)sas_hw_at(addr);
}

/*
 *********************   dump386Registers  **********************************
 *
 * This functions dumps the CPU registers to the indicated file, taking
 * account of code and stack segment sizes.
 */
LOCAL void
dump386Registers IFN2(FILE *, fp, IUM32, dump_info)
{
	IBOOL is32BitCS = FALSE;
	IBOOL is32BitSS = FALSE;
	IU32 offset;
	IUM32 i;
	sys_addr desc_addr;	/* the descriptor's address */
	IU16 temp;

	if (getPE() && !getVM()) {
		/*
		 * Is it a 16 or 32 bit code segment?
		 */
	
		is32BitCS = CsIsBig(getCS());	
	
		/*
		 * Is it a 16 or 32 bit stack segment? (i.e do we use ESP or SP)
		 * (The test is the same as for a big CS!)
		 */
	
		is32BitSS = CsIsBig(getSS());	
	}

	if (dump_info & DUMP_REG)
	{
		if (is32BitSS || is32BitCS
		    || (getEAX() & 0xFFFF0000)
		    || (getEBX() & 0xFFFF0000)
		    || (getECX() & 0xFFFF0000)
		    || (getEDX() & 0xFFFF0000)
		    || (getEIP() & 0xFFFF0000)
		    || (getEDI() & 0xFFFF0000)
		    || (getESI() & 0xFFFF0000)
		    || (getEBP() & 0xFFFF0000)
		    || (getESP() & 0xFFFF0000)) {
			fprintf(fp, "EAX:%000008x EBX:%000008x ECX:%000008x EDX:%000008x\n",
			  		getEAX(), getEBX(), getECX(), getEDX());
			fprintf(fp, "ESP:%000008x EBP:%000008x ESI:%000008x EDI:%000008x\n",
			   		getESP(), getEBP(), getESI(), getEDI());
			fprintf(fp, "DS:%04x ES:%04x FS:%04x GS:%04x %sSS:%04x %sCS:%04x EIP:%08x\n",
				getDS(), getES(), getFS(), getGS(),
				is32BitSS ? "Big-" : "",  getSS(),
				is32BitCS ? "32-"  : "",  getCS(), getEIP());
		} else {
			fprintf(fp,"AX:%04x BX:%04x CX:%04x DX:%04x",
			  		getAX(), getBX(), getCX(), getDX());
			fprintf(fp, " SP:%04x", getSP());
			fprintf(fp, " BP:%04x SI:%04x DI:%04x\n",
			   		getBP(), getSI(), getDI());
			fprintf(fp,"DS:%04x ES:%04x FS:%04x GS:%04x SS:%04x CS:%04x IP:%04x\n",
				getDS(), getES(), getFS(), getGS(), getSS(), getCS(), getIP());
		}
	}

	if (dump_info & DUMP_INST)
	{
		char buff[256];
		char *fmt, *newline;
		IU32 eip = GetInstructionPointer();

		/* We use the internal dasm so that we can disassemble
		 * instructions at (CS_BASE+eip) rather than
		 * effective_addr(getCS(), getEIP()), since the latter
		 * produces garbage just after changing the PE bit.
		 */
		if ( eip & 0xffff0000 )
		{
			fmt = "%04x:%08x ";
			newline = "\n              ";
		}
		else
		{
			fmt = "%04x:%04x ";
			newline = "\n          ";
		}
		(void)dasm_internal(buff,
			    getCS(),
			    eip,
			    is32BitCS ? THIRTY_TWO_BIT : SIXTEEN_BIT,
			    getCS_BASE() + eip,
			    read_from_la,
			    fmt,
			    newline);
		fprintf (fp, "%s", buff);
	}

	if (dump_info & DUMP_CODE) {
		IU32 cs_base = getCS_BASE();

		fprintf(fp,"Code dump: Last 16 words\n\n");
	 	i = GetInstructionPointer() - 31;
		if (is32BitCS)
	   		fprintf(fp, "%08x:  ", i);
		else
	   		fprintf(fp, "%04x:  ", i);
		for(; i < getIP() - 15; i+=2)
			{
			sas_loadw((cs_base + i), &temp);
			fprintf(fp, "  %04x", temp);
		}
	   	fprintf(fp, "\n%x:  ", i);
		for(; i <= GetInstructionPointer(); i+=2)
		{
			sas_loadw((cs_base + i), &temp);
			fprintf(fp, " %04x", temp);
		}
		fprintf(fp,"\n\n");
	}


#ifdef	SPC486
	if (dump_info & DUMP_FLAGS)
	{
		fprintf(fp, "C:%1d P:%1d A:%1d Z:%1d S:%1d T:%1d I:%1d D:%1d O:%1d\n",
		getCF(), getPF(), getAF(), getZF(), getSF(),
		getTF(), getIF(), getDF(), getOF());

		fprintf(fp, "NT:%1d IOPL:%1d WP:%1d NE:%1d ET:%1d TS:%1d EM:%1d MP:%1d PE:%1d CPL:%1d PG:%1d VM:%1d\n",
		getNT(), getIOPL(), getWP(), getNE(), getET(), getTS(), getEM(), getMP(), getPE(),
		getCPL(), getPG(),
		getVM());
	}
#else	/* SPC486 */
	if (dump_info & DUMP_FLAGS)
	{
		fprintf(fp,
		"C:%1d P:%1d A:%1d Z:%1d S:%1d T:%1d I:%1d D:%1d O:%1d\nNT:%1d IOPL:%1d TS:%1d EM:%1d MP:%1d PE:%1d CPL:%1d PG:%1d VM:%1d\n",
		getCF(), getPF(), getAF(), getZF(), getSF(),
		getTF(), getIF(), getDF(), getOF(),
		getNT(), getIOPL(), getTS(), getEM(), getMP(), getPE(),
		getCPL(), getPG(),
		getVM()
		);
	}
#endif	/* SPC486 */
}
#endif /* !PROD && SPC386 */

void trace(error_msg, dump_info)
char *error_msg;
int  dump_info;
{
#ifndef PROD
    word temp;
    half_word tempb;
    sys_addr i,j;

    if (disk_trace != trace_state)	/* change of state */
    {
	if (disk_trace == 1)
	{
	    /* start of disk tracing */

	    if (trace_file == stdout)
	    {
	        trace_file = fopen("disk_trace", "a");
	        trace_state = 1;
	    }
	    else
		disk_trace = 0;
	}
	else
	{
	    fclose(trace_file);
	    trace_file = stdout;
	    trace_state = 0;
	}
    }

    if (trace_start > 0) {
	trace_start--;
	return;
    }


#if	defined(CPU_40_STYLE) && !defined(CCPU)
    EnterDebug("Trace");
#endif	/* CPU_40_STYLE && !CCPU */

    /*
     * Dump the error message
     */

    fprintf(trace_file, "*** Trace point *** : %s\n", error_msg);

    /*
     * Now dump what has been asked for
     */

#if defined(NPX) && !(defined(NTVDM) && defined(MONITOR))
#ifdef CPU_40_STYLE
    if (dump_info & DUMP_NPX)
    {
 	IU32	i;
	IU32	npx_reg;
 	IS32	last;
	IBOOL	any_empty = FALSE;
 	IU32	stat287	= get_287_status_word();
 	IU32	cntl287	= get_287_control_word();
 	IU32	sp287	= get_287_sp();
 	IU32	tag287	= get_287_tag_word();

 	fprintf(trace_file, "NPX Status:%04x Control:%04x ST:%d 287Tag:%04x\n", stat287, cntl287, sp287, tag287);
 	fprintf(trace_file, "NPX Stack: ");

	last = -1;

	npx_reg  = stat287>>11;
	npx_reg &= 7;

 	for (i=0;i<8;i++)
	{
		if ( ((tag287 >> (2*npx_reg))&3) == 3 )
		{
			if ( last+1 == i )
				fprintf(trace_file, "%cST(%d)", any_empty?',':' ', i);
			any_empty = TRUE;
		}
		else
		{
			if ( last+2 < i )
				fprintf(trace_file, "-ST(%d)", i-1);
			last = i;
		}
		npx_reg = (npx_reg+1)&7;
	}
	if ( last < 6 )
		fprintf(trace_file, "-ST(7)");

	fprintf(trace_file, any_empty ? " empty\n" : "\n");

	npx_reg  = stat287>>11;
	npx_reg &= 7;

 	for (i=0;i<8;i++)
	{
	  if ( ((tag287 >> (2*npx_reg))&3) != 3 )
		  fprintf(trace_file, "ST(%d): %s\n", i, host_get_287_reg_as_string(i, FALSE));
	  npx_reg = (npx_reg+1)&7;
	}
 	fprintf(trace_file, "\n");
    }
#else	/* CPU_40_STYLE */
    if (dump_info & DUMP_NPX)
    {
 	int	i;
	extern  CHAR   *host_get_287_reg_as_string IPT2(int, reg_no, BOOL, in_hex);
 	extern	int	get_287_sp();
 	extern	word	get_287_tag_word IPT0();
 	extern	ULONG	get_287_control_word();
 	extern	ULONG	get_287_status_word();
 	int	stat287	= get_287_status_word();
 	int	cntl287	= get_287_control_word();
 	int	sp287	= get_287_sp();
 	int	tag287	= get_287_tag_word();

 	fprintf(trace_file, "NPX Status:%04x Control:%04x ST:%d 287Tag:%04x\n", stat287, cntl287, sp287, tag287);
 	fprintf(trace_file, "NPX Stack: ");
 	for (i=0;i<8;i++)
	  fprintf(trace_file, " %10s", host_get_287_reg_as_string(i, FALSE));
 	fprintf(trace_file, "\n");
    }
#endif	/* CPU_40_STYLE */
#endif /* NPX && YODA */

#ifdef SPC386
		dump386Registers(trace_file, (IUM32)dump_info);
#else
    if (dump_info & DUMP_REG)
    {
	fprintf(trace_file,"AX:%04x BX:%04x CX:%04x DX:%04x SP:%04x BP:%04x SI:%04x DI:%04x ",
		       getAX(), getBX(), getCX(), getDX(),
		       getSP(), getBP(), getSI(), getDI());
	fprintf(trace_file,"DS:%04x ES:%04x SS:%04x CS:%04x IP:%04x\n",
		getDS(), getES(), getSS(), getCS(), getIP());
    }

    if (dump_info & DUMP_INST)
    {
      dasm((char *)0, 0, getCS(), getIP(), 1);
    }

    if (dump_info & DUMP_CODE)
    {
	fprintf(trace_file,"Code dump: Last 16 words\n\n");
 	i = getIP() - 31;
   	fprintf(trace_file, "%04x:  ", i);
	for(; i < (sys_addr)(getIP() - 15); i+=2)
        {
	    sas_loadw(effective_addr(getCS(), i), &temp);
	    fprintf(trace_file, "  %04x", temp);
	}
   	fprintf(trace_file, "\n%x:  ", i);
	for(; i <= getIP(); i+=2)
	{
	    sas_loadw(effective_addr(getCS(), i), &temp);
	    fprintf(trace_file, " %04x", temp);
	}
	fprintf(trace_file,"\n\n");
    }


   if (dump_info & DUMP_FLAGS)
      {
#ifdef PM
      fprintf(trace_file,
      "C:%1d P:%1d A:%1d Z:%1d S:%1d T:%1d I:%1d D:%1d O:%1d NT:%1d IOPL:%1d TS:%1d EM:%1d MP:%1d PE:%1d CPL:%1d\n",
      getCF(), getPF(), getAF(), getZF(), getSF(),
      getTF(), getIF(), getDF(), getOF(),
      getNT(), getIOPL(), getTS(), getEM(), getMP(), getPE(), getCPL()
             );
#else
      fprintf(trace_file,
      "CF:%1d PF:%1d AF:%1d ZF:%1d SF:%1d TF:%1d IF:%1d DF:%1d OF:%1d\n",
      getCF(), getPF(), getAF(), getZF(), getSF(),
      getTF(), getIF(), getDF(), getOF()
             );
#endif /* PM */
      }
#endif /* SPC386 else*/

    if (dump_info & DUMP_SCREEN)
    {
#ifdef SFELLOW
	printf("Screen dump not supported on Stringfellows\n");
#else /* SFELLOW */
	fprintf(trace_file,"Screen dump:\n\n");
	i = gvi_pc_low_regen;
   	while (i <= gvi_pc_high_regen)
	{
	    fprintf(trace_file,"%4x:  ", (word)(i - gvi_pc_low_regen));
	    for(j=0; j<16; j++)
	    {
		sas_load(i+j, &tempb);
		fprintf(trace_file, "%-3x", tempb);
 	    }
	    fprintf(trace_file,"   ");
	    for(j=0; j<16; j++)
	    {
		sas_load(i+j, &tempb);
		if (tempb < 0x20)
		    tempb = '.';
		fprintf(trace_file, "%c", tempb);
 	    }
	    fprintf(trace_file, "\n");
	    i += 16;
	}
	fprintf(trace_file, "\n");
#endif /* SFELLOW */
    }
#if	defined(CPU_40_STYLE) && !defined(CCPU)
    LeaveDebug();
#endif	/* CPU_40_STYLE && !CCPU */

#else	/* PROD */
	UNUSED(error_msg);
	UNUSED(dump_info);
#endif	/* PROD */
}

void trace_init()
{
#if !defined(PROD) || defined(HUNTER)

  char *trace_env, *start;

  trace_env = host_getenv("TRACE");

/*
 * Set up the trace file
 *------------------------*/

  if (trace_env == NULL)
    trace_file = stdout;
  else
  {
    trace_file = fopen(trace_env, "w");
    if (trace_file == NULL)
      trace_file = stdout;

    start = host_getenv("TRACE_START");
    if(start == NULL)
      trace_start = 0;
    else
      trace_start = atoi(start);
  }
#endif /* !PROD || HUNTER */
}

/* Get the code for 4.0 style CPUs */
#ifndef PROD
#ifdef CPU_40_STYLE
#if defined(NPX)
GLOBAL	IU32	get_287_sp IFN0()
{
#ifdef CCPU
	IMPORT IU32 getNpxStatusReg IPT0();
	IU32    stat287 = getNpxStatusReg();
#else
	IMPORT IU32 a_getNpxStatusReg IPT0();
	IU32    stat287 = a_getNpxStatusReg();
#endif
	return((stat287&0x3800) >> 11);
}

GLOBAL	IU32	get_287_control_word IFN0()
{
#ifdef CCPU
	IMPORT IU32 getNpxControlReg IPT0();
	return(getNpxControlReg());
#else
	IMPORT IU32 a_getNpxControlReg IPT0();
	return(a_getNpxControlReg());
#endif
}

GLOBAL	IU32	get_287_status_word IFN0()
{
#ifdef CCPU
	IMPORT IU32 getNpxStatusReg IPT0();
	return(getNpxStatusReg());
#else
	IMPORT IU32 a_getNpxStatusReg IPT0();
	return(a_getNpxStatusReg());
#endif
}

GLOBAL	IU32	get_287_tag_word IFN0()
{
#ifdef CCPU
	IMPORT IU32 getNpxTagwordReg IPT0();
	return(getNpxTagwordReg());
#else
	IMPORT IU32 a_getNpxTagwordReg IPT0();
	return(a_getNpxTagwordReg());
#endif
}

GLOBAL CHAR *host_get_287_reg_as_string IFN2(IU32, reg_num, BOOL, in_hex)
{
SAVED	CHAR    dumpStore[80];

#ifdef CCPU
	IMPORT CHAR *getNpxStackReg IPT2(IU32, reg_num, CHAR *, dumpStore);
	return(getNpxStackReg(reg_num, dumpStore));
#else
	IMPORT CHAR *a_getNpxStackReg IPT2(IU32, reg_num, CHAR *, dumpStore);
	return(a_getNpxStackReg(reg_num, dumpStore));
#endif
}
#endif	/* NPX */
#endif	/* CPU_40_STYLE */	
#endif /* !PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\diskbios.c ===
#include "insignia.h"
#include "host_def.h"

/*
*               diskbios.c
*
*       The fast disk bios & disk post routine plus some disk debugging routines
*
*       This file combine the old diskbios.c & fast_dbios.c it is designed to
*       sit alongside fdisk.c but doesn't interact with it.
*
*       Post & debugging from the old diskbios by Jerry Kramskoy
*       Fast disk bios by Ade Brownlow
*
*       NB: This file does not comply with all of Insignias standards.
*/

#ifdef SCCSID
static char     SccsID[] = "@(#)diskbios.c      1.36 04/12/95 Copyright Insignia Solutions Inc.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "AT_STUFF.seg"
#endif

/* includes */
#include <stdio.h>
#include TypesH
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "gmi.h"
#include "trace.h"
#include "fdisk.h"
#include "cmos.h"
#include "ica.h"
#include "error.h"
#include "config.h"
#include "dsktrace.h"
#include "idetect.h"
#include "debug.h"

/* disk status BIOS variable location */
#define DISK_STATUS1 0x474

/* id mismatch return */
#define IDMISMATCH      1

/* status byte values */
#define STATUS_RECORD_NOT_FOUND 0x04
#define STATUS_BAD_COMMAND 0x01
#define STATUS_NO_ERROR 0xe0
#define STATUS_DMA_BOUNDRY 0x09
#define STATUS_ERROR 0x01
#define STATUS_CLEAR 0x00
#define STATUS_INIT_FAIL 0x07

/* error conditions */
#define ERROR_NO_ID 0x10
#define ERROR_COMMAND_ABORT 0x04
#define ERROR_CLEAR 0x00
#define ERROR_READ_ONLY_MEDIA 0x03 /* this is really only for floppies but it has the desired effect on DOS */

/* command parameters structure */
/* use ints to allow the compiler to chose the fastest type */
typedef struct _com
{
        int drive;
        int sectors;
        int head;
        int cylinder_low;
        int cylinder_high;
        int start_sector;
        int xfersegment;
        int xferoffset;
} command_params;

/* this structure holds information about each drive */
typedef struct _dt
{
        int connected;
} drivetable;

/* disk parameter block ...... */
typedef struct _dpb
{
        unsigned short cyls;
        UTINY heads;
        UTINY sectors;
} dpb_block;

/********************************************************/
/* local globals */
LOCAL drivetable drivetab[2];
LOCAL command_params com;
LOCAL dpb_block dpb[2];

/* again allow compiler choice of types 16 bit ints are large enough */
LOCAL int maxsectors, maxoffset;
LOCAL int tfstatus;

#ifndef PROD
/*
* disk trace control variable; global only for use by Yoda.
*/
GLOBAL IU32 disktraceinfo;
#endif

/*
* non-zero if drive 1 does not exist
*/
LOCAL int drive1notwiredup;


/********************************************************/
/* support functionallity */

void disk_post IPT0();
LOCAL void hd_reset IPT2(int, drive, int, diag);

LOCAL UTINY rerror IPT0();
LOCAL void werror IPT1(UTINY, error);
LOCAL int check_drive IPT1(int, drive);
LOCAL long dosearchid IPT0();
LOCAL int checkdatalimit IPT0();
LOCAL void getdpb IPT1(int, drive);
LOCAL void wstatus IPT1(UTINY, value);
LOCAL UTINY rcmos IPT1(int, index);
LOCAL void wcmos IPT2(int, index, UTINY, value);
LOCAL UTINY rstatus IPT0();
LOCAL void disk_reset IPT0();
LOCAL void return_status IPT0();
LOCAL void disk_read IPT0();
LOCAL void disk_write IPT0();
LOCAL void disk_verify IPT0();
LOCAL void format IPT0();
LOCAL void badcmd IPT0();
LOCAL void get_drive_params IPT0();
LOCAL void init_drive IPT0();
LOCAL void disk_seek IPT0();
LOCAL void test_ready IPT0();
LOCAL void recalibrate IPT0();
LOCAL void diagnostics IPT0();
LOCAL void read_dasd IPT0();
LOCAL void enable_disk_interrupts IPT0();

LOCAL void hd_reset IPT2(int, drive, int, diag);

/********************************************************/
/* POST & DEBUG defines*/

/*
 * define the disk interrupt vector generated by the PIC
 */
#define IVTDISKINTRUPT          0x1d8   /* 4 * 0x76 */

 /*
  * value to send to fixed disk register (3f6) to enable head select 3 (thus
  * enabling head addresses of 8-0xf)
  */
#define ENABLE_HD_SEL_3         8       /* enable head 3, + enable fixed disk * interrupts */

 /*
  * BIOS variables Interrupt vectors
  */
#define IVT13                   0x4c    /* 4 * 0x13 */
#define IVT40                   0x100   /* 4 * 0x40 */
#define IVT41                   0x104   /* 4 * 0x41 */
#define IVT46                   0x118   /* 4 * 0x46 */

 /*
  * BIOS data area (segment 40h)
  */
#define HF_NUM                  0x475
#define HF_STATUS               0x48c
#define HF_INT_FLAG             0x48e

/*
PROCEDURE         :     disk_post()

PURPOSE           :     called during POST to establish the number
                        of drives available, and to set the disk
                        subsystem up prior to booting DOS. Should be
                        called after configuration has been processed
                        for hard disk(s) (if any)

PARAMETERS        :     none

GLOBALS           :

RETURNED VALUE    :     none

DESCRIPTION       :     reads the CMOS to see if any disks.
                        sets up IVT entries so that INT 13h
                        routes to hard disk BIOS rather than floppy
                        disk BIOS. sets INT 40h to route to floppy.
                        sets INT 'DISKINTRUPT' to route to disk interrupt service
                        routine. sets INT 41h to point to disk parameter
                        block (dpb) for fixed drive 0, and INT 46h to
                        point to the dpb for fixed drive 1 (or to same as
                        INT 41h if no drive 1). sets drive parameters for
                        the drive(s).

*/

void disk_post IFN0()
{
        UTINY diag;
        UTINY disks;
        UTINY ndisks;
#if !(defined(NTVDM) && defined(MONITOR))
        USHORT diskette_offset;
        USHORT diskette_seg;
#endif /* !(NTVDM && MONITOR) */
        int i;

        /*
         * read diagnostic byte of CMOS
         */
         diag = rcmos (CMOS_DIAG);

#if !(defined(NTVDM) && defined(MONITOR))
        /* We don't want this section if running on NTVDM MONITOR */

         drive1notwiredup = ~0;

        /*
         * set up IVT entries
         */

         dt0 (DBIOS | CALL, 0, "disk_post() stealing IVT's\n")

         diskette_offset = sas_w_at(IVT13);
         diskette_seg = sas_w_at(IVT13 + 2);
         sas_storew (IVT13, DISKIO_OFFSET);
         sas_storew (IVT13 + 2, SYSROM_SEG);
         sas_storew (IVT40, diskette_offset);
         sas_storew (IVT40 + 2, diskette_seg);
         sas_storew (IVT41, DPB0_OFFSET);
         sas_storew (IVT41 + 2, SYSROMORG_SEG);
         sas_storew (IVT46, DPB0_OFFSET);
         sas_storew (IVT46 + 2, SYSROMORG_SEG);
         sas_storew (IVTDISKINTRUPT, DISKISR_OFFSET);
         sas_storew (IVTDISKINTRUPT + 2, SYSROM_SEG);

         enable_disk_interrupts ();

        /*
         * clear BIOS status variable
         */
         wstatus (0);

        /*
         * if CMOS is bad, go no further
         */
        if (diag & (BAD_BAT + BAD_CKSUM))
                 return;

        /*
         * initially show ok to IPL off drive C
         */
         wcmos (CMOS_DIAG, diag & ~HF_FAIL);

#endif  /* !(NTVDM && MONITOR) */

#ifdef NTVDM    /* True for all NT VDMs */
        /*
         * Microsoft NT VDM specfic change:
         * Fake up no hard disks in CMOS and consequently BIOS RAM
         * because we don't want apps accessing the real hard disk
         * under NT.
         *
         */
        wcmos(CMOS_DISK, (half_word) (NO_HARD_C | NO_HARD_D));

#endif  /* NTVDM */

        /*
         * read cmos disk byte for configured drives. Note we don't
         * support extended drive types. We always use types 1 and 2
         * (or 0 if no drive) for drives C and D respectively
         */
         disks = rcmos (CMOS_DISK);

        if (disks & 0xf0)
        {
                ndisks = 1;
                if (disks & 0xf)
                {

                        /*
                         * BIOS happy to accept drive 1 if CMOS
                         * indicates it
                         */
                        drive1notwiredup = 0;
                        ndisks++;
                        sas_storew (IVT46, DPB1_OFFSET);
                        sas_storew (IVT46 + 2, SYSROMORG_SEG);
                }

                /*
                 * set BIOS variable indicating the number of drives
                 * configured according to the CMOS
                 */
                 sas_store (HF_NUM, ndisks);

                /*
                 * reset the drive(s)
                 */
                for (i = 0; i < ndisks; i++)
                        hd_reset (i, diag);
        }
        else
        {
                sas_store (HF_NUM, 0);
                wcmos (CMOS_DIAG, (UTINY)(diag | HF_FAIL));
        }
}


/*
FUNCTION        :       hd_reset(drive)
PURPOSE         :       set drive parameters for drive, and
                        recalibrate it. If the drive is not
                        attached to the disk controller, then
                        an error will be returned by the controller
                        (Drive not ready). If an error occurs on
                        drive 0, then set the CMOS to forbid IPL
                        from the hard disk.
EXTERNAL OBJECTS:
RETURN VALUE    :
INPUT  PARAMS   :       drive   -       0       (drive C)
                                   or   1       (drive D)
*/
LOCAL void hd_reset IFN2(int, drive, int, diag)
{

        /*
         * set up drive id
         */
        setDL ((UCHAR)(0x80 + drive));

        /*
         * set the drive parameters
         */
        setAH (0x9);
        disk_io ();

        /*
         * recalibrate the drive
         */
        setAH (0x11);
        disk_io ();

        if (getCF () && !drive)
                wcmos (CMOS_DIAG, (UTINY)(diag | HF_FAIL));
}

#ifndef PROD
/*
FUNCTION        :       relevant()
PURPOSE         :       filter out unwanted tracing as requested by the
                        disk trace flag.
INPUT PARAMS    :
        i               encoded flag indicating type of tracing information
                        asking to be output
*/
LOCAL BOOL relevant IFN1(IU32, i)
{
        if ((i & disktraceinfo) == i)
                return ~0;
        else
                return 0;
}

LOCAL BOOL storing_trace = FALSE;
LOCAL int stored_trace_hndl, stored_trace_count = 0;

#ifdef macintosh
GLOBAL  int     *stored_trace_data;
#else
LOCAL int stored_trace_data[1024];
#endif
LOCAL int stored_tr_dptr = 0;
LOCAL int stored_infoid;
LOCAL char stored_tr_string[80];

void unload_stored_trace IFN1(int, hndl)
{
        int i,linecount;

        if (stored_infoid & DBIOS)
                fprintf (trace_file, "DBIOS:");

        if (stored_infoid & DHW)
                fprintf (trace_file, "DHW  :");

        switch (hndl)
        {
        case INW_TRACE_HNDL:
        case OUTW_TRACE_HNDL:
                if (stored_trace_count == 1)
                {
                        fprintf (trace_file, "%s : 0x%04x\n",stored_tr_string,stored_trace_data[0]);
                }
                else
                {
                        fprintf (trace_file, "%d lots of %s : \n",
                                stored_trace_count,stored_tr_string);
                        linecount = 8;
                        for (i=0;i<stored_trace_count;i++)
                        {
                                if (linecount >= 8)
                                {
                                        fprintf(trace_file, "\n");
                                        if (stored_infoid & DBIOS)
                                                fprintf (trace_file, "DBIOS:");

                                        if (stored_infoid & DHW)
                                                fprintf (trace_file, "DHW  :");
                                        linecount = 0;
                                }
                                fprintf(trace_file, "0x%04x ",stored_trace_data[i]);
                                linecount++;
                        }
                        fprintf(trace_file, "\n");
                }
                break;
        default:
                /* unknown handle */
                break;
        }
        stored_tr_dptr = 0;
        stored_trace_count = 0;
}

void add_to_stored_trace IFN1(int, data)
{
        stored_trace_data[stored_tr_dptr++]=data;
}

#ifdef ANSI
void disktrace (int infoid, int nargs, int hndl, char *fmt, unsigned long a1,
                unsigned long a2, unsigned long a3, unsigned long a4,
                unsigned long a5)
#else
void disktrace (infoid, nargs, hndl, fmt, a1, a2, a3, a4, a5)
int infoid;
int nargs;
int hndl;
char *fmt;
unsigned long a1;
unsigned long a2;
unsigned long a3;
unsigned long a4;
unsigned long a5;
#endif  /* ANSI */
{


        if (relevant (infoid))
        {
                switch(hndl)
                {
                case INW_TRACE_HNDL:
                case OUTW_TRACE_HNDL:
                        if (storing_trace && (stored_trace_hndl != hndl))
                                unload_stored_trace(stored_trace_hndl);
                        if (!storing_trace)
                        {
                                storing_trace = TRUE;
                                stored_trace_hndl = hndl;
                                strncpy(stored_tr_string, fmt,sizeof(stored_tr_string));
                                stored_tr_string[sizeof(stored_tr_string)-1] = '\0';
                                stored_infoid = infoid;
                        }
                        add_to_stored_trace(a1);
                        stored_trace_count++;
                        return;
                default:
                case 0:
                        if (storing_trace)
                                unload_stored_trace(stored_trace_hndl);
                        storing_trace = FALSE;
                        break;
                }

                if (infoid & DBIOS)
                        fprintf (trace_file, "DBIOS:");

                if (infoid & DHW)
                        fprintf (trace_file, "DHW  :");

                switch (nargs)
                {
                        case 0:
                                fprintf (trace_file, fmt);
                                break;
                        case 1:
                                fprintf (trace_file, fmt, a1);
                                break;
                        case 2:
                                fprintf (trace_file, fmt, a1, a2);
                                break;
                        case 3:
                                fprintf (trace_file, fmt, a1, a2, a3);
                                break;
                        case 4:
                                fprintf (trace_file, fmt, a1, a2, a3, a4);
                                break;
                        case 5:
                                fprintf (trace_file, fmt, a1, a2, a3, a4, a5);
                                break;
                }
        }
}


void setdisktrace IFN0()
{
        char l[30];
        int value;

/* make the compiler happy */
        value = 0;

        printf ("select disk trace mask\n");
        printf ("\tcmnd info\t%x\n",CMDINFO);
        printf ("\texec info\t%x\n",XINFO);
        printf ("\texec status\t%x\n",XSTAT);
        printf ("\tphys.att\t%x\n",PAD);
        printf ("\tio-att\t\t%x\n",IOAD);
        printf ("\tportio\t\t%x\n",PORTIO);
        printf ("\tints\t\t%x\n",INTRUPT);
        printf ("\thw xinfo\t%x\n",HWXINFO);
        printf ("\tdata dump\t%x\n",DDATA);
        printf ("\tPhys IO\t\t%x\n",PHYSIO);
        printf ("\thardware\t\t%x\n",DHW);
        printf ("\tbios\t\t%x\n",DBIOS);
#ifdef WDCTRL_BOP
        printf ("\twdctrl\t\t%x\n",WDCTRL);
#endif /* WDCTRL_BOP
        printf (" .. ? ");
         gets (l);
         sscanf (l, "%x", &value);

        /*
         * automatically select BIOS entry,exit tracing if BIOS
         * tracing selected
         */
        if (value & DBIOS)
                 value |= CALL;
         disktraceinfo = value;
}
#endif                          /* nPROD */


/********************************************************/
/* BIOS mainline and functions */

#ifdef ANSI
LOCAL void (*disk_func[]) (void) =
#else
LOCAL void (*disk_func[]) () =
#endif
{
        disk_reset,             /* 0x00 */
        return_status,          /* 0x01 */
        disk_read,              /* 0x02 */
        disk_write,             /* 0x03 */
        disk_verify,            /* 0x04 */
        format,                 /* 0x05 */
        badcmd,                 /* 0x06 */
        badcmd,                 /* 0x07 */
        get_drive_params,       /* 0x08 */
        init_drive,             /* 0x09 */
        disk_read,              /* 0x0a */
        disk_write,             /* 0x0b */
        disk_seek,              /* 0x0c */
        disk_reset,             /* 0x0d */
        badcmd,                 /* 0x0e */
        badcmd,                 /* 0x0f */
        test_ready,             /* 0x10 */
        recalibrate,            /* 0x11 */
        badcmd,                 /* 0x12 */
        badcmd,                 /* 0x13 */
        diagnostics,            /* 0x14 */
        read_dasd,              /* 0x15 */
        /* 0x16 - 0x19 are all floppy commands */
};

#ifndef PROD
static char *BIOSnames[] =
{
        "reset disk (AH=0)",
        "read last status (AH=1)",
        "read sectors (AH=2)",
        "write sectors (AH=3)",
        "verify sectors (AH=4)",
        "format track (AH=5)",
        "unused (AH=6)",
        "unused (AH=7)",
        "return current drive parameters (AH=8)",
        "set drive geometry for controller (AH=9)",
        "read long (AH=0xa)",
        "write long (AH=0xb)",
        "seek (AH=0xc)",
        "alternate disk reset (AH=0xd)",
        "unused (AH=0xe)",
        "unused (AH=0xf)",
        "test drive ready (AH=0x10)",
        "recalibrate (AH=0x11)",
        "unused (AH=0x12)",
        "unused (AH=0x13)",
        "diagnostics (AH=0x14)",
        "read dasd type (AH=0x15)"
};
#endif /* nPROD */

/* Fixed disk BIOS mainline */
void disk_io IFN0()
{
        register int BIOS_command;
#ifndef PROD
        int ax,bx,cx,dx,es;
#endif

        IDLE_disk();


        /* what function to perform ? */
        /* what command ?? */
        BIOS_command = getAH ();

#ifndef PROD

        ax = getAX();
        bx = getBX();
        cx = getCX();
        dx = getDX();
        es = getES();

        dt5(DBIOS, 0, "<ax %x bx %x cx %x dx %x es %x\n", ax,bx,cx,dx,es)

        if (BIOS_command > 0x15)
                dt1(DBIOS|CALL, 0, "bad BIOS call (AH=%x)\n", BIOS_command)
        else
                dt1(DBIOS|CALL, 0, "BIOS call = %s\n",
                                (unsigned long)BIOSnames[BIOS_command])

#endif /* PROD */

        /* clear up the status before we kick off */
        /* but only if this is NOT a read status command */
        if (BIOS_command != 0x01)
                wstatus (STATUS_CLEAR);

        /* setup our command structure from the remaining registers */
        com.drive = getDL () & 0x7f;
        com.sectors = getAL ();
        com.head = getDH () & 0xf;
        com.cylinder_low = getCH ();
        com.cylinder_high = (getCL () & 0xc0) >> 6;
        com.start_sector = getCL () & 0x3f;
        com.xfersegment = getES () + ((getBX ()) >> 4);
        com.xferoffset = getBX () & 0x0f;

        /* DMA boundary check */
        if (BIOS_command == 0x0a || BIOS_command == 0x0b)
        {
                maxsectors = 127;
                maxoffset = 4;
        }
        else
        {
                maxsectors = 128;
                maxoffset = 0;
        }

        /* call our function if sensible ie the drive requested exists */
        /* and the BIOS command is in a sensible range */
        if (check_drive (com.drive)
            && BIOS_command < 0x16 && BIOS_command >= 0x00)
        {
                /* call it */
                (*disk_func[BIOS_command]) ();
        }
        else
        {
                badcmd ();
        }

        /* setup the applications return */
        if (BIOS_command != 0x15)
                setAH (rstatus ());
        if (rstatus ())
        {
                /*
                 * Command has failed - set the carry flag.  We also
                 * do some tracing if the command is not 'status'.  The
                 * latter is excluded as it is sometimes used as a 'poll'
                 * of a device.
                 */
#ifndef PROD
                if (BIOS_command != 8) {
                        assert0 (NO,"FAST DISK COMMAND FAILED \n");
                        assert1 (NO,"STATUS %x   ", rstatus ());
                        assert1 (NO,"BIOS_command %x \n", BIOS_command);
                }
#endif /* PROD */
                setCF (1);      /* cmd fails */
        }
        else
                setCF (0);      /* cmd ok */
        dt2(DBIOS|CALL, 0, "CF=%c, status=%x(hex)\n",
                getCF()?'T':'F',(unsigned)rstatus())
}

/*0x?? badcommand catch all */
LOCAL void badcmd IFN0()
{
        wstatus (STATUS_BAD_COMMAND);
}

/*0x00 reset the hard disk system */
LOCAL void disk_reset IFN0()
{
        register int i;

        /* interupts on */
        enable_disk_interrupts ();

        /* do reset for the attached drives */
        for (i = 0; i < 2; i++)
        {
                if (drivetab[i].connected)
                {
                        host_fdisk_seek0 (i);

                        com.drive = i;
                        init_drive ();
                }
        }
        wstatus (STATUS_CLEAR);
}

/*0x01 send back the status byte */
LOCAL void return_status IFN0()
{
        setAL (rstatus ());
        dt1(DBIOS|CMDINFO, 0, "\treturned status = %x\n", (unsigned)rstatus())
        wstatus (STATUS_CLEAR);
}

#ifdef  ERROR
#undef  ERROR
#endif

#define ERROR()         {\
                                                werror (ERROR_NO_ID | ERROR_COMMAND_ABORT); \
                                                wstatus (STATUS_ERROR); \
                                                return;\
                                        }

/*0x02 disk read sector(s) */
LOCAL void disk_read IFN0()
{
        long offset;
        host_addr inbuf;
        sys_addr pdata;

        /* find offset into the hd file */
        if ((offset = dosearchid ()) == IDMISMATCH)
                ERROR();

        dt3(DBIOS|CMDINFO, 0, "\t%d sectors to read, \n\tbuffer at [%x:%x]\n", com.sectors, (unsigned)getES(), (unsigned) getBX())

        if (checkdatalimit ())
        {
            sas_store(HF_INT_FLAG, 0);

                /* read to where ? */
                pdata = effective_addr (getES (), getBX ());

                if (!(inbuf = (host_addr)sas_transbuf_address (pdata, com.sectors*512L)))
                {
                        assert0 (NO,"No BUFFER in disk_read");
                        ERROR();
                }

                dt1(DBIOS|XINFO,0, "\t\trd buffer from card -> memory (offset %x)\n", pdata );

                if (!host_fdisk_rd (com.drive, offset, com.sectors,(char *) inbuf))
                        ERROR();

                /* now store what we read */
                sas_stores_from_transbuf (pdata, inbuf, com.sectors*512L);
        }
        else
        {
                /* status set by function */
                ERROR();
        }
        wstatus (STATUS_CLEAR);
        setAL ((unsigned char) com.sectors);
}

/*0x03 disk write sector(s) */
LOCAL void disk_write IFN0()
{
        long offset;
        host_addr outbuf;
        sys_addr pdata;

        /* check for read_only disk */
        if (!config_get_active((IU8)(C_HARD_DISK1_NAME + com.drive)))
        {
                werror (ERROR_READ_ONLY_MEDIA); /* floppy write prot */
                wstatus (STATUS_ERROR);
                return;
        }

        /* find offset into the hd file */
        if ((offset = dosearchid ()) == IDMISMATCH)
                ERROR();

        /* check for segment wrap around */
        if (checkdatalimit ())
        {
                sas_store(HF_INT_FLAG, 0);

                /* write from where */
                pdata = effective_addr (getES (), getBX ());

                /* get the transfer buffer */
                if (!(outbuf = (host_addr)sas_transbuf_address (pdata, com.sectors*512L)))
                {
                        assert0 (NO,"No BUFFER in disk_write\n");
                        ERROR();
                }

                /* load our stuff to the transfer buffer */
                sas_loads_to_transbuf (pdata, outbuf, com.sectors*512L);

                if (!host_fdisk_wt (com.drive, offset, com.sectors, (char *)outbuf))
                        ERROR();
        }
        else
        {
                ERROR();
        }
        wstatus (STATUS_CLEAR);
        setAL ((unsigned char) com.sectors);
}

/*0x04 disk verify sector */
LOCAL void disk_verify IFN0()
{
        /* this is a dummy really */
        wstatus (STATUS_CLEAR);
}

/*0x05 format track  is this EVER used ?? */
LOCAL void format IFN0()
{
        register int i = 0;

        /* 17 sectors/track */
        while (i < 17)
        {
                /* one sector at a time */
                com.sectors = 1;

                /* start at this sector */
                com.start_sector = i;

                /* write to disk */
                disk_write ();

                if (rstatus ())
                {
                        /* we have failed */
                        return;
                }

                i++;            /* next sector */
        }
}

/*0x06-0x07 bad commands */

/*0x08 get drive parameters */
LOCAL void get_drive_params IFN0()
{
        /* valid drive or what ?? */
        if (check_drive (com.drive))
        {
                long maxcylinder = 0;

                getdpb (com.drive);

                /* how many drives are there */
                if (drivetab[1].connected)
                        setDL (2);
                else
                        setDL (1);

                /* number of heads 0 - max */
                setDH ((UCHAR)(dpb[com.drive].heads - 1));

                /* number of cylinders is max addressable - 0th - diagnostic */
                maxcylinder = dpb[com.drive].cyls - 2;
                setCH ((UCHAR)(maxcylinder & 0xff));
                setCL ((UCHAR) (dpb[com.drive].sectors | ((maxcylinder >> 8) << 6)));

                /* we are happy */
                wstatus (STATUS_CLEAR);
                setAX (0);
        }
        else
        {
                /* oooooooops */
                wstatus (STATUS_INIT_FAIL);
                setAX (STATUS_INIT_FAIL);
                setDX (0);
                setCX (0);
        }
}

/*0x09 initialise drives */
LOCAL void init_drive IFN0()
{
        /* another dummy really */
        getdpb (com.drive);
        if (drivetab[com.drive].connected)
                wstatus (STATUS_CLEAR);
        else
                wstatus (STATUS_INIT_FAIL);
}

/*0x0a read long mapped to 0x02 */
/*0x0b write long mapped to 0x03 */
/*0x0c seek */
LOCAL void disk_seek IFN0()
{
        /* don't do anything physical here just do a search and set result */

        com.sectors = 1;        /* Awful frig to stop false fails */

        if (dosearchid () == IDMISMATCH)
                ERROR();

        /* no problem */
        wstatus (STATUS_CLEAR);
}

/*0x0d reset disk system mapped to 0x00*/
/*0x0e-0x0f bad commands */
/*0x10 give drive status */
LOCAL void test_ready IFN0()
{
        register half_word status;

        /* read our status, check for a fault if there is a fault */
        /* then fix the status and tell them we failed */
        /* the only fault possible is an error state */
        status = rstatus ();
        if (status & STATUS_ERROR)
        {
                /* read the error status */
                status = rerror ();
                if (status & ERROR_NO_ID)
                {
                        wstatus (STATUS_RECORD_NOT_FOUND);
                }
                else
                {
                        if (status & ERROR_COMMAND_ABORT)
                        {
                                wstatus (STATUS_BAD_COMMAND);
                                dt1(DBIOS|CMDINFO, 0, "\tdrive %d not ready\n", com.drive)
                        }
                        else
                        {
                                wstatus (STATUS_NO_ERROR);
                                dt1(DBIOS|CMDINFO, 0, "\tdrive %d ready\n", com.drive)
                        }
                }
        }
        else
        {
                wstatus (STATUS_CLEAR);
                dt1(DBIOS|CMDINFO, 0, "\tdrive %d ready\n", com.drive)
        }
}

/*0x11 recalibrate */
LOCAL void recalibrate IFN0()
{
        if (!drivetab[com.drive].connected)
                wstatus (STATUS_ERROR);
        else
                wstatus (STATUS_CLEAR);
        host_fdisk_seek0 (com.drive);
}

/*0x12-0x13 bad commands */
/*0x14 controller internal diagnostic */
LOCAL void diagnostics IFN0()
{
        /* return the controller ok  - what controller */
        setAH (0);
        wstatus (STATUS_CLEAR);
        dt0(DBIOS|CMDINFO, 0, "\tcontroller diags.ok\n")
}

/*0x15 get disk type */
LOCAL void read_dasd IFN0()
{
        register int blocks;

        wstatus (STATUS_CLEAR);
        if ((!drivetab[com.drive].connected) && com.drive > 0)
        {
                /* drive not availiable */
                setAX (0);

                /* no blocks */
                setCX (0);
                setDX (0);
                setCF (0);
                dt0(DBIOS|CMDINFO, 0, "\tdrive 1 not available\n")
                return;
        }

        /* get physical address of disk param block for drive */
        getdpb (com.drive);

        /* set the number of blocks */
        blocks = (dpb[com.drive].cyls - 1) * dpb[com.drive].heads * dpb[com.drive].sectors;
        setCX ((UCHAR)(blocks / 256));
        setDX ((UCHAR)(blocks % 256));

        /* fixed disk exists */
        setAH (3);
        setCF (0);
        dt2(DBIOS|CMDINFO, 0, "\tdrive (%d) has %d blocks available\n", com.drive, blocks)
}

/*0x16 - 0x19 handled by floppy controller */

/********************************************************/
/* Support functions */

/* read the status register */
LOCAL UTINY rstatus IFN0()
{
        UTINY disk_stat;

        /* read the BIOS variable */
        disk_stat = sas_hw_at(DISK_STATUS1);
        return (disk_stat);
}

/* write the status register */
LOCAL void wstatus IFN1(UTINY,value)
{
        /* set BIOS var */
        sas_store (DISK_STATUS1, value);
}

LOCAL UTINY rcmos IFN1(int, index)
{
        UTINY value;

        cmos_outb (CMOS_PORT, (UTINY)index);
        cmos_inb (CMOS_DATA, &value);
        return value;
}

LOCAL void wcmos IFN2(int,index,UTINY,value)
{
        cmos_outb (CMOS_PORT, (UTINY)index);
        cmos_outb (CMOS_DATA, value);
}

/* get the disk parameter block for a given drive */
LOCAL void getdpb IFN1(int, drive)
{
        sys_addr ivt;
        sys_addr pdpb;
        unsigned short offset;
        unsigned short segment;

        /* choose apropriate vector */
        if (!drive)
                ivt = IVT41;
        else
                ivt = IVT46;

        /* read IVT to get address of disk parameter block */
        offset = sas_w_at(ivt);
        segment = sas_w_at(ivt + 2);
        pdpb = effective_addr ((unsigned short) segment, offset);

        /* read the relevant params */
        dpb[drive].cyls = sas_w_at(pdpb);
        dpb[drive].heads = sas_hw_at(pdpb + 2);
        dpb[drive].sectors = sas_hw_at(pdpb + 14);
}

/* detect segment overflow when reading/writing disk */
LOCAL int checkdatalimit IFN0()
{
        if (com.sectors > maxsectors)
        {
                wstatus (STATUS_DMA_BOUNDRY);
                dt1(DBIOS|XINFO, 0, "\t\ttoo many sectors (%d(dec))to transfer\n",
com.sectors)
                return (0);
        }
        else
        {
                if (com.sectors == maxsectors)
                {
                        if (com.xferoffset > maxoffset)
                        {
                                dt2(DBIOS|XINFO, 0, "\t\tat max.sectors(%d(dec)), bad offset(%x(hex)) for transfer\n", com.sectors, com.xferoffset)
                                wstatus (STATUS_DMA_BOUNDRY);
                                return (0);
                        }
                }
        }
        return (1);
}

/* simulate search on hard disk for cyl,hd,sec id field */
LOCAL long dosearchid IFN0()
{
        long maxhead, cylinder, bytes_per_cyl, bytes_per_track;

        maxhead = (dpb[com.drive].heads-1) & 0xf;

        /* head ok? (heads numbered from 0 - maxhead) */
        if (com.head > maxhead)
        {
                return (IDMISMATCH);
        }

        /*
         * sector ok? (assumes all tracks have been formatted with sector ids
         * 1 - nsecspertrack which is DOS standard)
         */
        if (com.start_sector == 0 ||
                com.start_sector > dpb[com.drive].sectors ||
                com.sectors <= 0)
        {
                return (IDMISMATCH);
        }

        /* set up the correct cylinder */
        cylinder = (((unsigned long) com.cylinder_high) << 8) +
            (unsigned long) com.cylinder_low;

        /*
         * cylinder ok? (we've imposed an artificial limit on the maximum
         * cylinder number based upon the file size)
         */
        if (cylinder >= dpb[com.drive].cyls)
        {
                return (IDMISMATCH);
        }

        bytes_per_track = dpb[com.drive].sectors * 512L;
        bytes_per_cyl = bytes_per_track * (maxhead + 1);

        return (cylinder * bytes_per_cyl + com.head *
            bytes_per_track + (com.start_sector - 1L) * 512L);
}

/* check the drive is valid for the command */
LOCAL int check_drive IFN1(int, drive)
{
        if (!drive)
                return (1);
        if ((drive > 1) || (drive == 1 && !drivetab[1].connected))
        {
                badcmd ();
                return (0);
        }
        return (1);
}

/* write to the error flag */
LOCAL UTINY error_register;
LOCAL void werror IFN1(UTINY,error)
{
        error_register = error;
}

/* read the error register */
LOCAL UTINY rerror IFN0()
{
        return (error_register);
}

#define INTB01  (io_addr)0xa1
#define INTA01  (io_addr)0x21
LOCAL void enable_disk_interrupts IFN0()
{
         UTINY value;

         inb (INTB01, &value);
         value &= 0xbf;
         outb (INTB01, value);
         inb (INTA01, &value);
         value &= 0xfb;
         outb (INTA01, value);
}

/********************************************************/
/* the following are called by fdisk_physattach and detach and just initialise this */
/* cut down BIOS */

/* tell the turbo bios a drive is attached */
GLOBAL void fast_disk_bios_attach IFN1(int, drive)
{
        drivetab[drive].connected = 1;
}

/* tell the turbo bios a drive is unattached */
GLOBAL void fast_disk_bios_detach IFN1(int, drive)
{
        drivetab[drive].connected = 0;
}


#ifdef WDCTRL_BOP

/* ===================================== wdctrl_bop ===========================
 * PURPOSE:
 *              BOP to allow fast (32-bit) disk access in Windows
 *
 *              based on disk_read and disk_write
 *
 * INPUT:
 *              Intel registers set up as:
 *                      EAX     Start sector
 *                      ECX     Number of sectors
 *                      DS:EBX  intel buffer address (just EBX in flat mode)
 *                      DL      drive (80h or 81h)
 *                      DH      command (BDC_READ or BDC_WRITE)
 *
 *
 * OUTPUT:
 *              CF      set if error, clear on success
 * ============================================================================
 */

#define BDC_READ        0       /* read n sectors, called in flat memory model */
#define BDC_WRITE       1       /* write n sectors, called in flat memory model */
#define WDCTRL_TEST     0xff    /* read n sectors, called during real mode init */

GLOBAL void wdctrl_bop IFN0()
{

        IUM16   command;

        IDLE_disk();

        /* what command ?? */
        command = getDH();

#ifndef PROD
        /* #ifndef PROD so the tests don't occur in PROD version */
        {
                IUM32   cs = getCS();
                IUM32   eip = getEIP();

                if (command == BDC_READ)
                {
                        dt2(WDCTRL, 0, "WDCTRL READ: called from %04x:%08x\n",
                                        cs, eip);
                }
                else if (command == BDC_WRITE)
                {
                        dt2(WDCTRL, 0, "WDCTRL WRITE: called from %04x:%08x\n",
                                        cs, eip);
                }
                else
                {
                        dt3(WDCTRL, 0, "WDCTRL command %d: called from %04x:%08x\n",
                                        command, cs, eip);
                }
        }
#endif

        /* clear up the status before we kick off */
        wstatus (STATUS_CLEAR);

        /* setup our command structure from the remaining registers */
        com.drive = getDL () & 0x7f;
        com.sectors = getECX ();
        com.start_sector = getEAX ();
        com.xferoffset = getEBX();

        dt4(WDCTRL, 0, "WDCTRL: drive=%d   start_sector=%d   num sectors=%d   xfer addr %08x\n",
                        com.drive, com.start_sector, com.sectors,
                        com.xferoffset);

        maxsectors = 128;
        maxoffset = 0;

        /* call our function if sensible ie the drive requested exists */
        /* and the BIOS command is in a sensible range */
        if (check_drive (com.drive) &&
                command >= BDC_READ && command <= BDC_WRITE)
        {
                long offset;
                host_addr buf;
                IU8     *phys_addr;

                /* check for segment overflow and that we aren't writing to
                 * a read-only disk
                 */
                if (checkdatalimit () &&
                        ((command == BDC_READ) ||
                                config_get_active(C_HARD_DISK1_NAME + com.drive)))
                {
                        sas_store(HF_INT_FLAG, 0);

                        /* Convert sector to offset in file */
                        offset = com.start_sector * 512L;

                        if (!(buf = (host_addr)sas_transbuf_address (com.xferoffset, com.sectors*512L)))
                        {
                                assert0 (NO,"No BUFFER in wdctrl_bop");
                                ERROR();
                        }

                        if (command == BDC_READ)
                        {
                                if (!host_fdisk_rd (com.drive, offset, com.sectors, (char *) buf))
                                {
                                        ERROR();
                                }
                                /* now store what we read into intel memory */
                                sas_stores_from_transbuf(com.xferoffset, buf, com.sectors*512L);
                        }
                        else /* BDC_WRITE */
                        {
                                /* load our stuff from intel memory to the transfer buffer */
                                sas_loads_to_transbuf (com.xferoffset, buf, com.sectors*512L);
                                if (!host_fdisk_wt (com.drive, offset, com.sectors, (char *)buf))
                                {
                                        ERROR();
                                }
                        }
                }
                else /* checkdatalimit failed */
                {
                        /* status set by function */
                        ERROR();
                }
                wstatus (STATUS_CLEAR);
                setAL ((unsigned char) com.sectors);
        }
        else if (command == WDCTRL_TEST)
        {
                /* This path used by wdrminit.asm to check bop is there and is
                 * reading data OK.
                 */
                long offset;
                host_addr buf;
                sys_addr pdata;

                /* check for segment overflow and that we aren't writing to
                 * a read-only disk
                 */
                if (checkdatalimit ())
                {
                        sas_store(HF_INT_FLAG, 0);

                        /* read/write where ? */
                        com.xfersegment = getDS();
                        dt2(WDCTRL, 0, "WDCTRL: addr %04:%08x\n",
                                        com.xfersegment, com.xferoffset);

                        pdata = effective_addr (com.xfersegment, com.xferoffset);

                        /* Convert sector to offset in file */
                        offset = com.start_sector * 512L;

                        if (!(buf = (host_addr)sas_transbuf_address (pdata, com.sectors*512L)))
                        {
                                assert0 (NO,"No BUFFER in wdctrl_bop");
                                ERROR();
                        }

                        if (!host_fdisk_rd (com.drive, offset, com.sectors, (char *) buf))
                        {
                                ERROR();
                        }
                        /* now store what we read */
                        sas_stores_from_transbuf (pdata, buf, com.sectors*512L);
                }
                else /* checkdatalimit failed */
                {
                        /* status set by function */
                        ERROR();
                }
                wstatus (STATUS_CLEAR);
                setAL ((unsigned char) com.sectors);
        }
#ifndef PROD
/* These are for debugging scatter gather - I never had one and don't know
 * if the intel side is correct...
 */
else if (command == 4)
{
        /* Just to let me know we've got a scatter/gather loop */
        dt0(WDCTRL, 0, "wdctrl_bop: scatter gather detected ********\n");
        force_yoda();
        return;
}
else if (command == 5)
{
        /* Just to let me know we've got a scatter/gather loop */
        dt0(WDCTRL, 0, "wdctrl_bop: scatter gather processing ********\n");
        force_yoda();
        return;
}
/*
 * end of debugging commands
 */
#endif  /* PROD */
        else
        {
                badcmd ();
        }

        setAH (rstatus ());

        if (rstatus ())
        {
                /*
                 * Command has failed - set the carry flag.  We also
                 * do some tracing if the command is not 'status'.  The
                 * latter is excluded as it is sometimes used as a 'poll'
                 * of a device.
                 */
#ifndef PROD
                assert0 (NO,"FAST DISK COMMAND FAILED \n");
                assert1 (NO,"STATUS %x   ", rstatus ());
                assert1 (NO,"command %x \n", command);
#endif /* PROD */
                setCF (1);      /* cmd fails */
        }
        else
        {
                setCF (0);      /* cmd ok */
        }

        dt2(WDCTRL, 0, "CF=%c, status=%x(hex)\n",
                getCF()?'1':'0',(unsigned)rstatus());
}
#endif  /* WDCTRL_BOP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\fla.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 2.0
 *
 * Title	: Floppy Disk Adaptor Emulator
 *
 * Description	: The following functions are defined in this module:
 *
 *		  fla_init()		Initialise the fla
 *		  fla_inb()		Read byte from port
 *		  fla_outb()		Write byte to port
 *
 *		  The actual interface to the device that is acting as
 *		  a floppy diskette (ie virtual file, slave PC or device
 *		  driver for real diskette) is handled by the GFI layer.
 *		  Hence the job of the FLA is to package up the command
 *		  and pass it to GFI and simulate the result phase once
 *		  GFI has executed the command.
 *
 *		  This module provides the Bios and CPU with an emulation
 *		  of the entire Diskette Adaptor Card including the
 *		  Intel 8272A FDC and the Digital Ouput Register.
 *
 * Author	: Henry Nash / Jim Hatfield
 *
 * Notes	: For a detailed description of the IBM Floppy Disk Adaptor
 *		  and the INTEL Controller chip refer to the following
 *		  documents:
 *
 *		  - IBM PC/XT Technical Reference Manual
 *				(Section 1-109 Diskette Adaptor)
 *		  - INTEL Microsystems Components Handbook
 *				(Section 6-478 FDC 8272A)
 *
 *		  The interaction of the Sense Interrupt Status command with
 *		  the Recalibrate and Seek commands and with chip reset is
 *		  very complex. The FDC chip does NOT behave as its spec sheets
 *		  say in some situations. We do the best we can here. If all
 *		  Seek and Recalibrate commands on a drive are followed by
 *		  Sense Interrupt Status before any other command to that
 *		  drive then all should be OK.
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)fla.c	1.18 07/06/94 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "ica.h"
#include "ios.h"
#include "fla.h"
#include "config.h"
#include "gfi.h"
#include "trace.h"
#include "debug.h"
#include "fdisk.h"
#include "quick_ev.h"

/*
 * ============================================================================
 * Global data
 * ============================================================================
 */

/*
 * The flag indicating that the FLA is busy and cannot accept asynchronous
 * commands (eg motor off).
 */

boolean fla_busy = TRUE;	/* busy until initialised */
boolean fla_ndma = FALSE;

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/*
 * Static forward declarations.
 */
static void fdc_ndma_bufmgr_wt IPT1(half_word, value);
static void fla_atomicxqt IPT0();
static void fla_ndmaxqt IPT0();
static void fla_ndma_bump_sectid IPT0();

/*
 * The command and result blocks that are used to communicate to the GFI
 * layer. The result block is filled in by gfi during the execution phase.
 */

static FDC_CMD_BLOCK    fdc_command_block[MAX_COMMAND_LEN];
static FDC_RESULT_BLOCK fdc_result_block[MAX_RESULT_LEN];

#define FDC_INVALID_CMD	0x80			/* Status after bad command */
#define FDC_NORMAL_TERMINATION 0

/*
 * The FLA supports the FDC status register.
 */

static half_word fdc_status;			

/*
 * The FLA holds the current active (if any) command in the following byte.
 * This is used as an index into the FDC command data structure.
 */

static half_word fdc_current_command;

/*
 * The FLA has an output interrupt line which is gated by a bit in the DOR.
 */

static half_word fdc_int_line;

/*
 * The FLA knows when a Sense Interrupt Status is permitted.
 */

static struct {
	half_word full;			/* Slot occupied	*/
	half_word res[2];		/* Result phase		*/
	      } fdc_sis_slot[4];	/* One for each drive	*/

/*
 * The FLA is responsible for maintaining the command and result phases
 * of the FDC.  Two variables hold the current pointer into the stack
 * of command and result registers.
 */

static half_word fdc_command_count;
static half_word fdc_result_count;

/*
 * The FLA will emulate non-DMA 8088 <==> FDC data transfers, but only allow DMA mode
 * transfers to actually be sent to the GFI (potentially the back end of the SCSI might
 * re-map this again).
 * The following variable reflects whether the FDC has been put into non-DMA mode
 * from the 8088 program's point of view
 */


/* The following sector buffer is used for non_dma transfers */

#ifdef macintosh
char *fla_ndma_buffer; /* so that host_init can 'see' it to malloc() it. */
#else
static char fla_ndma_buffer[8192];
#endif
static int fla_ndma_buffer_count;
static int fla_ndma_sector_size;

/*
 * The FLA stores the IBM Digital Output Register internally
 */

#ifdef BIT_ORDER1
typedef union {
	 	half_word all;
		struct {
			 HALF_WORD_BIT_FIELD motor_3_on:1;
			 HALF_WORD_BIT_FIELD motor_2_on:1;
			 HALF_WORD_BIT_FIELD motor_1_on:1;
			 HALF_WORD_BIT_FIELD motor_0_on:1;
			 HALF_WORD_BIT_FIELD interrupts_enabled:1;
			 HALF_WORD_BIT_FIELD not_reset:1;
			 HALF_WORD_BIT_FIELD drive_select:2;
		       } bits;
	      } DOR;
#endif

#ifdef BIT_ORDER2
typedef union {
	 	half_word all;
		struct {
			 HALF_WORD_BIT_FIELD drive_select:2;
			 HALF_WORD_BIT_FIELD not_reset:1;
			 HALF_WORD_BIT_FIELD interrupts_enabled:1;
			 HALF_WORD_BIT_FIELD motor_0_on:1;
			 HALF_WORD_BIT_FIELD motor_1_on:1;
			 HALF_WORD_BIT_FIELD motor_2_on:1;
			 HALF_WORD_BIT_FIELD motor_3_on:1;
		       } bits;
	      } DOR;
#endif

DOR dor;
static IU8 drive_selected = 0;	/* Device last used. */
		
/* Centralised handling of connection to ICA, so that very slow
 * CPUs can find out if there is a floppy interrupt pending (see
 * wait_int() in floppy.c). There is some confusion in the code anyway,
 * because the fdc_int_line would appear to be the wire from the
 * fdc to the ica, but the code doesn't quite manage to use it in
 * this way.
 */

GLOBAL IBOOL fdc_interrupt_pending = FALSE;

LOCAL void fla_clear_int IFN0()
{
	/* if (fdc_int_line && dor.bits.interrupts_enabled) */

	if (fdc_interrupt_pending) {
		ica_clear_int(0, CPU_DISKETTE_INT);
	}

	fdc_int_line = 0;
	fdc_interrupt_pending = FALSE;
}

LOCAL void fla_hw_interrupt IFN0()
{
	ica_hw_interrupt(0, CPU_DISKETTE_INT, 1);
	fdc_interrupt_pending = TRUE;

	/* We would like to set fdc_int_line in this routine,
	 * but this wouldn't match the existing code. In particular
	 * there are calls which don't seem to include setting the
	 * fdc_int_line, and a call which sets up a quick_event to
	 * interrupt the ICA but which sets the fdc_int_line
	 * immediately.
	 */
}

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

/* This procedure is called from the host specific rfloppy routines
 * as an equivalent to dma_enquire, when the intel program has selected
 * non-dma mode for the FDC (via the SPECIFY command)
 */

void fla_ndma_enquire IFN1(int *,transfer_count)
{
	*transfer_count = fla_ndma_buffer_count;
}

/* This procedure is called from the host specific rfloppy routines
 * when it wants to transfer diskette data read from the diskette to
 * the 'non-dma buffer' (equivalent of dma_request). The Intel program will be fed from this non-dma buffer.
 */

void fla_ndma_req_wt IFN2(char *,buf,int,n)
{
	char *p = fla_ndma_buffer;

	fla_ndma_buffer_count = n;
	while(n--)
		*p++ = *buf++;
}

/* This procedure is called from the host specific rfloppy routines
 * when it wants data destined for the diskette
 */

void fla_ndma_req_rd IFN2(char *,buf,int,n)
{
	char *p = fla_ndma_buffer;

	while (n--)
		*buf++ = *p++;
}


void fla_inb IFN2(io_addr, port, half_word *,value)
{
#ifndef NEC_98


    note_trace0_no_nl(FLA_VERBOSE, "fla_inb() ");
    fla_busy = TRUE;

    if (port == DISKETTE_STATUS_REG)
    {
	*value = fdc_status;

	/*
	 * After a read of this register assert the RQM bit,
	 * unless the 'not_reset' line is held low!
	 */

	if (dor.bits.not_reset)
	    fdc_status |= FDC_RQM;
    }
    else
    if (port == DISKETTE_DATA_REG)
    {
	/*
	 * Make sure the 'not reset' line in the DOR is high
	 */

	if (!dor.bits.not_reset)
	{
            note_trace0_no_nl(FLA_VERBOSE, "<chip frozen!>");
	    *value = 0;
	    return;
	}

	/*
	 * Make sure that the RQM bit is up
	 */

	if (!(fdc_status & FDC_RQM))
	{
            note_trace0_no_nl(FLA_VERBOSE, "<no RQM!>");
	    *value = 0;
	    return;
	}

	/*
	 * Make sure that the DIO bit is up
	 */

	if (!(fdc_status & FDC_DIO))
	{
            note_trace0_no_nl(FLA_VERBOSE, "<no DIO!>");
	    *value = 0;
	    return;
	}

	/*
	 * The first byte of the result phase will clear the INT line
	 */

	if (fdc_result_count == 0)
		fla_clear_int();

	/*
	 * Read the result bytes out of the result block one at a time.
	 */

	*value = fdc_result_block[fdc_result_count++];

	if (fdc_result_count >= gfi_fdc_description[fdc_current_command].result_bytes)
	{
	    /*
	     * End of result phase - clear BUSY and DIO bits of status reg
	     */

	    fdc_status     &= ~FDC_BUSY;
	    fdc_status     &= ~FDC_DIO;
	    fdc_result_count    = 0;
	}

	/*
	 * After a read of the data register de-assert the RQM bit
	 */

	fdc_status &= ~FDC_RQM;
    }

    else if (port == DISKETTE_DIR_REG)
    {
	/*
	 * On the DUAL card, the bottom 7 bits of this register are
	 * supplied by the fixed disk adapter ...
	 */
	fdisk_read_dir(port, value);

	/*
	 * ... the top bit comes from the floppy disk adapter
	 */
	if (gfi_change(drive_selected))
	    *value |= DIR_DISKETTE_CHANGE;
	else
	    *value &= ~DIR_DISKETTE_CHANGE;
    }
    else if (port == DISKETTE_ID_REG)
    {
	/*
	** Do we have a Dual Card ?
	** This is an important question for the floppy BIOS.
	** If a Dual Card exists then the BIOS will do data rate changes
	** supporting hi and lo density media, without a Dual Card the BIOS
	** assumes that lo density media is always present.
	** I imagine this is because a "real" PC has limited floppy device
	** options and a hi density 3.5 inch unit will only exist with a
	** dual card.
	** This is not the case for SoftPC, any combination of floppy devices
	** seems to be quite OK.
	** I will try pretending we have a Dual Card whenever a high denisty
	** unit is present on A or B.
	*/
	switch( gfi_drive_type(0) ){
		case GFI_DRIVE_TYPE_12:
		case GFI_DRIVE_TYPE_144:
		case GFI_DRIVE_TYPE_288:
			*value = DUAL_CARD_ID; break;
		case GFI_DRIVE_TYPE_360:
		case GFI_DRIVE_TYPE_720:
		case GFI_DRIVE_TYPE_NULL:
			switch( gfi_drive_type(1) ){
				case GFI_DRIVE_TYPE_12:
				case GFI_DRIVE_TYPE_144:
				case GFI_DRIVE_TYPE_288:
					*value = DUAL_CARD_ID; break;
				case GFI_DRIVE_TYPE_360:
				case GFI_DRIVE_TYPE_720:
				case GFI_DRIVE_TYPE_NULL:
	    				*value = 0; break;
				default:
					always_trace0("ERROR: bad drive type");
					break;
			}
			break;
		default:
			always_trace0( "ERROR: Bad drive type." );
			break;
	}
#ifndef PROD
	if( *value==DUAL_CARD_ID ){
		note_trace0( FLA_VERBOSE, "Dual Card\n" );
	}else{
		note_trace0( FLA_VERBOSE, "No Dual Card\n" );
	}
#endif
    }
    else
    {
	*value = 0;
        note_trace0_no_nl(FLA_VERBOSE, "<unknown port>");
    }

    note_trace2(FLA_VERBOSE, " port %x, returning %x", port, *value);
    fla_busy = FALSE;


#endif // !NEC_98
}


void fla_outb IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
    int i;
    DOR new_dor;


    note_trace2_no_nl(FLA_VERBOSE, "fla_outb(): port %x, value %x ", port, value);
    fla_busy = TRUE;



    if (port == DISKETTE_STATUS_REG)
    {
        note_trace0(FLA_VERBOSE, "<write on status reg>");
    }

    else if (port == DISKETTE_DCR_REG)
    {
		/*
		** Send the specified data rate to the floppy using the new
		** style gfi_high() function that now has a data rate parameter.
		*/
		note_trace2( FLA_VERBOSE,
		             "fla_outb:DCR:port=%x value=%x set data rate",
		             port, value );
		gfi_high(dor.bits.drive_select, value);
    }
    else if (port == DISKETTE_DATA_REG)
    {
	/*
	 * Make sure the 'not reset' line in the DOR is high
	 */

	if (!dor.bits.not_reset)
	{
            note_trace0_no_nl(FLA_VERBOSE, "<chip frozen!>");
	    return;
	}

	/*
	 * Make sure that the RQM bit is up
	 */

	if (!(fdc_status & FDC_RQM))
	{
            note_trace0_no_nl(FLA_VERBOSE, "<no RQM!>");
	    return;
	}

	/*
	 * Make sure that the DIO bit is down
	 */

	if (fdc_status & FDC_DIO)
	{
            note_trace0_no_nl(FLA_VERBOSE, "<DIO set!>");
	    return;
	}

        note_trace0(FLA_VERBOSE, "");

	/*
	 * Output to the data register: must be programming up a command or issuing
	 * a data byte for a non-dma disk write.
	 * If the BUSY flag isn't set then it's the first byte.
     	 */

	if (!(fdc_status & FDC_BUSY))
	{
	    fdc_current_command = value & FDC_COMMAND_MASK;
	    fdc_command_count   = 0;
	    fdc_status         |= FDC_BUSY;
	}

	if (!(fdc_status & FDC_NDMA))
	/* programming up a command
	 */
	{
	    if (gfi_fdc_description[fdc_current_command].cmd_bytes == 0)
	    {
	        /*
    	         * Invalid command or Sense Int Status.
	         * If Sense Int Status, try to find some result phase data,
	         * else treat as an invalid command. In either case go
	         * straight into the result phase.
	         * Sense Int Status also clears Drive Busy bits and the INT line.
	         */

	        if (fdc_current_command == FDC_SENSE_INT_STATUS)
	        {
		    for (i = 0; i < 4; i++)
		        if (fdc_sis_slot[i].full)
		    	    break;

		    if (i < 4)	/* Found one!	*/
		    {
		        fdc_sis_slot[i].full = 0;
		        fdc_result_block[0] = fdc_sis_slot[i].res[0];
		        fdc_result_block[1] = fdc_sis_slot[i].res[1];

		    	fla_clear_int();		/* Clear INT line */

		        fdc_status &= ~(1 << i);	/* Clear Drive Busy */
		    }
		    else
		    {
		        fdc_command_block[0] = 0;
		        fdc_result_block[0]  = FDC_INVALID_CMD;
		    }
	        }
	        else
	        {
		    fdc_command_block[0] = 0;
		    fdc_result_block[0]  = FDC_INVALID_CMD;
	        }

	        fdc_status     |= FDC_DIO;
	    }
	    else
	    {
	        fdc_command_block[fdc_command_count++] = value;
	        if (fdc_command_count >= gfi_fdc_description[fdc_current_command].cmd_bytes)
	        {
	        /* n.b; the field 'dma_required' is a misnomer ... it
	         * strictly should be 'data_required'
	         */
                    if (!(gfi_fdc_description[fdc_current_command].dma_required))
		        fla_atomicxqt();
	            else
	            {
		        if (!fla_ndma)
		    	    fla_atomicxqt();
		        else
			    fla_ndmaxqt();
                    }
	        }
	    }
	}
	else
	/* receiving a non-dma data byte
	 */
	{
	    /* pass written byte to buffer manager
	     */
	    fdc_ndma_bufmgr_wt (value);
	    if (!fdc_int_line && dor.bits.interrupts_enabled)
                fla_hw_interrupt();
	}


	/*
	 * On write of the data register de-assert the RQM bit
	 */

	fdc_status &= ~FDC_RQM;
    }

    else
    if (port == DISKETTE_DOR_REG)
    {
        note_trace0(FLA_VERBOSE, "");

  	new_dor.all = value;
	if (!new_dor.bits.not_reset)
	{
	    dor.all = new_dor.all;
	    dor.bits.motor_0_on = 0;
	    dor.bits.motor_1_on = 0;
	    dor.bits.motor_2_on = 0;
	    dor.bits.motor_3_on = 0;
	    fdc_status         &= ~FDC_RQM;
	    fdc_int_line        = 0;
	}
	else
	{
	    if (!dor.bits.not_reset && new_dor.bits.not_reset)
	    {
	        /*
	         * Reset the FLA and GFI (and hence the real device).
	         * It is assumed that GFI reset will stop all drive motors.
		 * After the reset check to see if we need to turn any drive on.
		 *
		 * Note that reset effectively has a result phase since GFI
		 * will execute a Sense Interrupt Status command after it.
	         */
		
		gfi_reset(fdc_result_block, new_dor.bits.drive_select);

		fdc_status = FDC_RQM;
		fdc_command_count = 0;
		fdc_result_count  = 0;

		for (i = 0; i < 4; i++)
		{
		    fdc_sis_slot[i].full   = 1;
		    fdc_sis_slot[i].res[0] = 0xC0 + i;	/* Empirically	*/
		    fdc_sis_slot[i].res[1] = 0;
		}

		fdc_int_line      = 1;
	    }

	    /*
	     * There are three ways in which an interrupt may be generated:
	     *
	     * 1) The not_reset line goes low to high when the enable_ints
	     *	  line is high.
	     *
	     * 2) The enable_ints line goes low to high when the INT line
	     *	  is high.
	     *
	     * 3) Both of the above!
	     */

	    if ((!dor.bits.not_reset && new_dor.bits.not_reset && new_dor.bits.interrupts_enabled)
	      ||(fdc_int_line && !dor.bits.interrupts_enabled && new_dor.bits.interrupts_enabled))
		    fla_hw_interrupt();

	    /*
	     * If any drive motor bits have changed then issue GFI calls
	     */

	    if (!dor.bits.motor_0_on && new_dor.bits.motor_0_on)
	        gfi_drive_on(0);
	    else
	    if (dor.bits.motor_0_on && !new_dor.bits.motor_0_on)
	        gfi_drive_off(0);

	    if (!dor.bits.motor_1_on && new_dor.bits.motor_1_on)
	        gfi_drive_on(1);
	    else
	    if (dor.bits.motor_1_on && !new_dor.bits.motor_1_on)
	        gfi_drive_off(1);

	    if (!dor.bits.motor_2_on && new_dor.bits.motor_2_on)
	        gfi_drive_on(2);
	    else
	    if (dor.bits.motor_2_on && !new_dor.bits.motor_2_on)
	        gfi_drive_off(2);

	    if (!dor.bits.motor_3_on && new_dor.bits.motor_3_on)
	        gfi_drive_on(3);
	    else
	    if (dor.bits.motor_3_on && !new_dor.bits.motor_3_on)
	        gfi_drive_off(3);

	    /* Only store drive_select if actively used. */
	    if (new_dor.bits.motor_0_on || new_dor.bits.motor_1_on)
	    {
		drive_selected = new_dor.bits.drive_select;
	    }
	    dor.all = new_dor.all;	
	}
    }

#ifndef PROD
    else
        note_trace0(FLA_VERBOSE, "<unknown port>");
#endif

    fla_busy = FALSE;


#endif // !NEC_98
}


void trap_ndma IFN0()
{
        if (get_type_cmd(fdc_command_block) == FDC_SPECIFY)
        {
            if (get_c6_ND(fdc_command_block))
            {

                fla_ndma = TRUE;
                put_c6_ND(fdc_command_block, 0);
                note_trace0(FLA_VERBOSE, "DISABLING NON_DMA FDC REQ>");
            }
            else
                fla_ndma = FALSE;
        }
}

LOCAL	void fla_int_call_back IFN1(long,junk)
{
	UNUSED(junk);
	fla_hw_interrupt();
}

#ifdef NTVDM

void fdc_command_completed (UTINY drive, half_word fdc_command)
{

    if (gfi_fdc_description[fdc_command].int_required) {
	if (!fdc_int_line && dor.bits.interrupts_enabled)
	    add_q_event_i(fla_int_call_back, HOST_FLA_DELAY, 0);
	fdc_int_line = 1;
    }

    /*
     * If the command issued was Seek or Recalibrate, save
     * the GFI result phase ready for Sense Int Status.
     * Set the Drive Busy line (cleared by SIS).
     * Any other command clears the SIS slot.
     */

    if (fdc_command == FDC_SEEK || fdc_command == FDC_RECALIBRATE) {
	fdc_sis_slot[drive].full = 1;
	fdc_sis_slot[drive].res[0] = fdc_result_block[0];
	fdc_sis_slot[drive].res[1] = fdc_result_block[1];
	fdc_status |= (1 << drive);
    }
    else
	fdc_sis_slot[drive].full = 0;

    /*
     * If there is no result phase then go back to READY.
     */

    if (gfi_fdc_description[fdc_command].result_bytes == 0)
	fdc_status &= ~FDC_BUSY;
    else
	fdc_status |= FDC_DIO;
}

/*
 * This routine will 'automatically' execute the current FDC command.
 * The GFI layer will actually perform the command/execution/result phases
 * and return any result block. The Intel program.
 */

static void fla_atomicxqt IFN0()
{
	int ret_stat;
	UTINY drive;

	/*
	 * Call GFI to execute the command
	 */
	drive = get_type_drive(fdc_command_block);
	trap_ndma();

	ret_stat = gfi_fdc_command(fdc_command_block, fdc_result_block);
	if (ret_stat != SUCCESS)
	{
	    /*
	     * GFI failed due to timeout or protocol error - so we will
	     * fake up a real timeout by not generating an interrupt.
	     */
/* we created a new thread to simulate the fdc while something is wrong.
 * here we don't want to turn the busy signal off until we have a reset
 *	    fdc_status	   &= ~FDC_BUSY;
 *	    fdc_status	   &= ~FDC_DIO;
 */
            note_trace1(FLA_VERBOSE, "fla_outb(): <gfi returns error %x>",
                        ret_stat);
	}
	else
	    fdc_command_completed(drive, fdc_current_command);
}

#else    /* NTVDM */

/*
 * This routine will 'automatically' execute the current FDC command.
 * The GFI layer will actually perform the command/execution/result phases
 * and return any result block. The Intel program.
 */

static void fla_atomicxqt IFN0()
{
	int ret_stat;
	int drive;

	/*
	 * Call GFI to execute the command
	 */

	trap_ndma();

	ret_stat = gfi_fdc_command(fdc_command_block, fdc_result_block);
	if (ret_stat != SUCCESS)
	{
	    /*
	     * GFI failed due to timeout or protocol error - so we will
	     * fake up a real timeout by not generating an interrupt.
	     */

	    fdc_status     &= ~FDC_BUSY;
	    fdc_status     &= ~FDC_DIO;

            note_trace1(FLA_VERBOSE, "fla_outb(): <gfi returns error %x>",
                        ret_stat);
	}
	else
	{
	    /*
	     * Command was successful, generate an interrupt if enabled.
	     */

	    if (gfi_fdc_description[fdc_current_command].int_required)
	    {
		if (!fdc_int_line && dor.bits.interrupts_enabled) {
			add_q_event_i(fla_int_call_back, HOST_FLA_DELAY, 0);
		}
		fdc_int_line = 1;
	    }

	    /*
	     * If the command issued was Seek or Recalibrate, save
	     * the GFI result phase ready for Sense Int Status.
	     * Set the Drive Busy line (cleared by SIS).
	     * Any other command clears the SIS slot.
	     */

	    drive = get_type_drive(fdc_command_block);

	    if (fdc_current_command == FDC_SEEK || fdc_current_command == FDC_RECALIBRATE)
	    {
		fdc_sis_slot[drive].full = 1;
		fdc_sis_slot[drive].res[0] = fdc_result_block[0];
		fdc_sis_slot[drive].res[1] = fdc_result_block[1];
		fdc_status |= (1 << drive);
	    }
	    else
		fdc_sis_slot[drive].full = 0;

    	    /*
     	     * If there is no result phase then go back to READY.
	     */

	    if (gfi_fdc_description[fdc_current_command].result_bytes == 0)
		fdc_status &= ~FDC_BUSY;
	    else
		fdc_status |= FDC_DIO;
	}
}
#endif    /* NTVDM */


static void fdc_request_write_data_to_cpu IFN0()
{
	if (!fdc_int_line && dor.bits.interrupts_enabled)
            fla_hw_interrupt();
}


static void fdc_request_read_data_from_cpu IFN0()
{
	if (!fdc_int_line && dor.bits.interrupts_enabled)
            fla_hw_interrupt();
}


/* Prepare for processor data requests.
 * i.e; based upon the current command, establish the minimum number of bytes
 * likely to be involved in a transfer, based upon the N parameter.
 * Set the fla_ndma_byte_count global appropriately. Set the ndma buffer
 * count to zero, forcing a real command read to occur the first time
 * the Intel program tries to read/write data to the FDC during its
 * non-dma execution phase.
 * Issue the first interrupt, and set FDC status register to mirror this
 * and set non-dma bit in status register
 */

static void fla_ndmaxqt IFN0()
{
	int n;
        static int fla_ndma_sectsize[] = {128,256,512,1024,2048,4096,8192};

        note_trace0(FLA_VERBOSE, "DOING FLA_NDMAXQT");

        /* set the non-dma bit in the status register ...
         * this clears at the end of the execution phase
         */

        fdc_status |= FDC_NDMA;

        fla_ndma_buffer_count = 0;

        switch (gfi_fdc_description[fdc_current_command].cmd_class)
        {
        case 0:         /* sector read(s)                               */

                n = get_c0_N(fdc_command_block);
                if (n)
                        fla_ndma_sector_size = fla_ndma_sectsize[n];
                else
                        fla_ndma_sector_size = get_c0_DTL(fdc_command_block);

                /* kick of the execution phase by issuing
                 * an interrupt
                 */

                fdc_request_write_data_to_cpu();

                break;

        case 1:         /* sector write(s)                              */

                n = get_c0_N(fdc_command_block);
                if (n)
                        fla_ndma_sector_size = fla_ndma_sectsize[n];
                else
                        fla_ndma_sector_size = get_c0_DTL(fdc_command_block);


                /* kick of the execution phase by issuing
                 * an interrupt
                 */

                fdc_request_read_data_from_cpu();

                break;

        case 2:         /* track read                                   */
                always_trace0("\n FLA ... non-dma read track unimplemented");
                break;

        case 3:         /* format track                                 */
                always_trace0("\n FLA ... non-dma format unimplemented");
                break;

        default:
                always_trace0("\n FLA ... unexpected command for non-dma");
        }
}


/*
 * peek a quick look at the 'first' sector involved in this current
 * FDC command, to establish whether abnormal termination would have occurred * with the non-DMA transfer, and flag accordingly
 */

void fla_ndma_sector_peep IFN1(int *,all_clear)
/* all_clear ----->                = 0 --> time out
                                 * = 1 --> sector good
                                 * = 2 --> abnormal termination
                                 */
{
        int true_command, status;

        /* build a 'read data' command using all current command
         * parameters.
         */

        true_command = get_type_cmd(fdc_command_block);
        put_type_cmd(fdc_command_block, FDC_READ_DATA);

        status = gfi_fdc_command(fdc_command_block, fdc_result_block);

	fla_ndma_buffer_count = 0;

        /* repair the command block
         */

        put_type_cmd(fdc_command_block, true_command);

        *all_clear = 0;

        if (status == SUCCESS)
        {
                if (get_r1_ST0_int_code(fdc_result_block) == FDC_NORMAL_TERMINATION)
                        *all_clear = 1;
                else
                        *all_clear = 2;
        }

}

/* This routine emulates the execution phase for sector writes
 * ... Here we buffer up data destined for the diskette on a
 * 'per sector' basis (the 'sector' size being determined by the
 * 'N' parameter (or possibly the 'DTL' parameter (if N=0)) specified
 * within the FDC command block. If the buffer is empty, the equivalent
 * read command is issued to the GFI layer, mainly to determine whether
 * the sector is kosher.
 */

static void fdc_ndma_bufmgr_wt IFN1(half_word, value)
{
	int status;
	int all_clear;

        note_trace1(FLA_VERBOSE,
                    "FDC_NDMA_BUFMGR_WT called .. buffered byte = %x",
                    (unsigned int) value);

	/*
	 * empty buffer!! if so, read the sector first to see if it exists, etc.
	 */

	if (fla_ndma_buffer_count == 0)
	{
		fla_ndma_sector_peep(&all_clear);
		switch (all_clear)
		{
		case 0:		/* FDC dead */
			fdc_status &= ~FDC_BUSY;
			fdc_status &= ~FDC_DIO;
			return;
		case 1:		/* FDC cooking */
			/* ... increment the sector id (as the controller
			 * would do given half a chance!!
			 */
			fla_ndma_bump_sectid();
			break;
		case 2: 	/* FDC does not like command parameters
				 * if it doesn't ... neither do i !!
				 */
			if (!fdc_int_line && dor.bits.interrupts_enabled)
			    fla_hw_interrupt();
			fdc_status &= ~FDC_NDMA;
			fdc_status |= FDC_DIO;
			return;
		}
	}

	/* is there room in the buffer ? ... flush out if not
	 * and recurse.
	 */

	if (fla_ndma_buffer_count == fla_ndma_sector_size)
	{
		/* do the command ... the GFI layler will call 'fla_ndma_req_rd'
		 * to get the data in this full buffer
		 */

		status = gfi_fdc_command(fdc_command_block, fdc_result_block);

		/* reset the buffer */

		fla_ndma_buffer_count = 0;

		if (status != SUCCESS)
		{
			fdc_status &= ~FDC_BUSY;
			fdc_status &= ~FDC_DIO;
		}
		else
		{
			if (get_r1_ST0_int_code(fdc_result_block) == FDC_NORMAL_TERMINATION)
			fdc_ndma_bufmgr_wt(value);
			else
			{
				if (!fdc_int_line && dor.bits.interrupts_enabled)
				    fla_hw_interrupt();
				fdc_status &= ~FDC_NDMA;
				fdc_status |= FDC_DIO;
			}
		}
	}
	else
		fla_ndma_buffer[fla_ndma_buffer_count++] = value;

}


static void fla_ndma_bump_sectid IFN0()
{
	int i;

	i = get_c0_sector(fdc_command_block) + 1;
	put_c0_sector(fdc_command_block, ((unsigned char)i));
}

static void fla_ndma_unbump_sectid IFN0()
{
	int i;

	i = get_c0_sector(fdc_command_block) - 1;
	put_c0_sector(fdc_command_block, ((unsigned char)i));
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * function will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void fla_init IFN0()
{
#ifndef NEC_98
    io_addr i;

    note_trace0(FLA_VERBOSE, "fla_init() called");

    /*
     * Set up the IO chip select logic for this adaptor
     * Assume that the DOR comes up with all bits zero.
     */

    io_define_inb(FLA_ADAPTOR, fla_inb);
    io_define_outb(FLA_ADAPTOR, fla_outb);

    /*
     * For the DUAL card, one of the registers must be left
     * for the hard disk adapter to connect to
     */

    for(i = DISKETTE_PORT_START; i <= DISKETTE_PORT_END; i++)
    {
	if (i != DISKETTE_FDISK_REG)
	    io_connect_port(i, FLA_ADAPTOR, IO_READ_WRITE);
    }

    fla_busy = TRUE;

    fdc_status        = 0;
    fdc_command_count = 0;
    fdc_result_count  = 0;
    fdc_int_line      = 0;
    dor.all           = 0;

    fla_ndma = FALSE;
    fla_busy = FALSE;
#endif // !NEC_98
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\debug\yoda.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: yoda.c
 *
 * Description	: The Debugger of a Jedi Master
 *
 * Author	: Obi wan (ben) Kneobi
 *
 * Notes	: May the force be with you.
 *
 */

#include <stdio.h>
#include StringH
#include "xt.h"
#include "yoda.h"


#undef  STATISTICS
#undef COMPRESSED_TRACE
#undef  HOST_EXTENSION
#define BREAKPOINTS

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "YODA.seg"
#endif

#ifdef SCCSID
static char SccsID[]="@(#)yoda.c	1.100 07/06/95 Copyright Insignia Solutions Ltd.";
#endif

/*
 * The following dummies are necessary to make the production version
 * link.
 */

#ifdef PROD

int     vader = 0;
#ifdef force_yoda
#undef force_yoda
#endif

void force_yoda()
{
}
#ifdef NONPROD_CPU

/* this allows a non-prod CPU to be linked into a PROD build
 * handy for pre-release demo versions if you don't fancy doing a
 * full PROD cpu+vid just to keep management happy....
 */
int  do_condition_checks = 0;
#undef check_I
void check_I IFN0()
{
}
#endif /* NONPROD_CPU */
#ifdef DELTA
void delta_check_I()
{
}
#endif /* DELTA */
#endif /* PROD */

#ifdef	YODA
/*
 * O/S includes
 */
#include <stdlib.h>
#include <stdio.h>
#include TypesH
#include StringH
#include <ctype.h>
#ifndef PROD
#if defined(BSD4_2) || defined(SYSTEMV)
#include <signal.h>
#endif /* BSD4_2 or SYSTEMV */

/*
 * SoftPC includes
 */
#include "xt.h"
#define CPU_PRIVATE
#include CpuH
#include "trace.h"
#include "sas.h"
#include "bios.h"
#include "ios.h"
#include "error.h"
#include "config.h"
#include "gfi.h"
#include "gmi.h"
#include "gvi.h"
#include "video.h"
#include "dsktrace.h"
#include "idetect.h"
#include "cmos.h"
#include "quick_ev.h"
#include "gfx_upd.h"
#ifndef SFELLOW
#include "host_gfx.h"
#ifdef NEXT /* until someone sorts out the host_timeval interface */
#include "timeval.h"
#include "host_hfx.h"
#include "hfx.h"
#else /* ifdef NEXT */
#include "host_hfx.h"
#include "hfx.h"
#include "timeval.h"
#endif /* ifdef NEXT else */
#endif /* !SFELLOW */


typedef enum {
	br_regAX,
	br_regBX,
	br_regCX,
	br_regDX,
	br_regCS,
	br_regDS,
	br_regES,
	br_regSS,
	br_regSI,
	br_regDI,
	br_regSP,
	br_regBP,
#ifdef SPC386
	br_regEAX,
	br_regEBX,
	br_regECX,
	br_regEDX,
	br_regFS,
	br_regGS,
	br_regESI,
	br_regEDI,
	br_regESP,
	br_regEBP,
#endif /* SPC386 */
	br_regAH,
	br_regBH,
	br_regCH,
	br_regDH,
	br_regAL,
	br_regBL,
	br_regCL,
	br_regDL
}BR_REG ;

typedef struct {
	BR_REG regnum;
	char regname[10];
	SIZE_SPECIFIER size;
} BR_REGDESC;

typedef struct br_regentry {
	BR_REG regnum;
	USHORT minval;
	USHORT maxval;
	struct br_regentry *next;
	USHORT handle;
} BR_REGENTRY;

BR_REGDESC br_regdescs[br_regDL+1];

#define NUM_BR_ENTRIES 40

BR_REGENTRY br_regs[NUM_BR_ENTRIES], *free_br_regs, *head_br_regs = NULL;

static BOOL br_structs_initted = FALSE;

GLOBAL IBOOL In_yoda=FALSE;

#if defined(SYSTEMV) || defined(POSIX_SIGNALS)
#define MUST_BLOCK_TIMERS
#endif

#ifdef MUST_BLOCK_TIMERS
int     timer_blocked = 0;
#endif /* MUST_BLOCK_TIMERS */

#ifdef	EGG
#include "egagraph.h"
#endif	/* EGG */

#ifndef CPU_30_STYLE
#define CPU_YODA_INT 0

LOCAL VOID cpu_interrupt IFN2(int,x,int,y)
{
	UNUSED(x);
	UNUSED(y);
	cpu_interrupt_map |= CPU_YODA_EXCEPTION_MASK;
	host_cpu_interrupt();
}
#endif


#define	sizeoftable(tab)	(sizeof(tab)/sizeof(tab[0]))

/*
 * Add in defualt define for host_tolower().
 */
#ifndef host_tolower
#define host_tolower(x) tolower(x)
#endif /* host_tolower */

/*
 * Define value seen in <len> parameter to yoda commands that take
 * <intel-addr> argument if no <len> value is entered.
 * The value chosen is very, very big, so the chances of any poor user
 * actually choosing that value are very, very small!
 */
#define YODA_LEN_UNSPECIFIED	(~(LIN_ADDR)0 >> 1)


/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *
 * William Roberts 20/8/92
 *
 * Attempt to rationalise so that "s" really does step, without
 * any problems about luke or yint+slow
 *
 * There are 3 cases:
 * 			    A3CPU			    others
 *
 *    fast yoda:	do_condition_checks = 0		yint = 0
 *    medium yoda?:	(N/A)				yint = 1, fast = 1
 *    slow yoda:	do_condition_checks = 1		yint = 1, fast = 0
 *			&& getenv("YODA") != NULL
 *
 * The A3CPU has already built the threads by this time, so it is too
 * late to select slow_yoda f the environment variable is not set...
 *
 * Fast yoda is really about trace printouts etc. You have to hit ^C
 * to get into it, then start use it to examine things.
 *
 * Slow Yoda is needed for stepping, breakpoints etc. It causes the CPU
 * to examine things at every instruction.
 *
 * Medium Yoda means "don't clear CPU_YODA_EXCEPTION when stepping".
 */

/*
 * luke variable for fast yoda
 */
int luke  = 0;
int	do_condition_checks = 0;

/* pre A3CPU fast yoda stuff */
int yint = 0;
int fast = 1;	/* start interrupt yoda as fast by default */

static int chewy = 0;		/* Up the Empire! */
static int env_check = 0;	/* Is Luke in trouble? */

int slow_needed = 0;
char *slow_reason = "why slow is required";

#ifdef GISP_SVGA
LOCAL int	NoYodaThanks = FALSE;
#endif	/* GISP_SVGA */


LOCAL LIN_ADDR eff_addr IFN2(IU16, seg, IU32, off)
{
	if (seg == 0)
		return (off);
	return (effective_addr(seg, off));
}


LOCAL YODA_CMD_RETURN do_fast IPT6(char *, str, char *, com, IS32, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop);
LOCAL YODA_CMD_RETURN do_slow IPT6(char *, str, char *, com, IS32, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop);
LOCAL YODA_CMD_RETURN do_h IPT6(char *, str, char *, com, IS32, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop);

LOCAL YODA_CMD_RETURN go_slow IFN0()
{
#if defined(A3CPU) && !defined(GISP_CPU)
	if (env_check == 1) {
	    printf("Sorry, you must do 'setenv YODA TRUE' before starting an A3CPU\n");
	    printf("Fast YODA: breakpoint-based features are not available\n");
	    return(YODA_LOOP);
	}
#endif /* A3CPU && !GISP_CPU */
	if (fast) {
		printf("Switching to Slow YODA...\n");
		yint = 1; fast = 0; do_condition_checks = 1;
#if defined(CPU_40_STYLE) && !defined(CCPU)
		Nano_slow_yoda(); /* Check that Nano will give us check_I's */
#endif	/* CPU_40_STYLE && !CCPU */
	}
#if	defined(A2CPU) || defined(GISP_CPU)
	/* raise a YODA interrupt in the CPU */
	cpu_interrupt (CPU_YODA_INT, 0);
#else
	/* others already check do_condition_checks */
#endif /* A2CPU || GISP_CPU */

	return(YODA_RETURN_AND_REPEAT);
}
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */



#ifdef DELTA
extern void examine_delta_data_structs();
extern void print_last_dest();
#endif /* DELTA */

/* vader is referenced by delta.o */
int     vader = 0;

int disable_timer = 0;


#define MAX_TABLE 0x100
#define MAX_TABLE_BREAK_WORDS 10

#ifdef macintosh
#define MAX_BREAK_WORD_RANGE 0x100
#else
#define MAX_BREAK_WORD_RANGE 0xFFF
#endif

typedef struct {
	IU16 cs;
	LIN_ADDR ip;
	LIN_ADDR len;
	LIN_ADDR start_addr;
	LIN_ADDR end_addr;
	LIN_ADDR stop;
	long temp;
	long valid;
	} BPTS;

typedef struct {
	IU16 cs;
	LIN_ADDR ip;
	IUH data_addr;
	word old_value[ MAX_BREAK_WORD_RANGE ];
	LIN_ADDR stop;
	LIN_ADDR len;
	} DATA_BPTS;

extern int disk_trace, verbose;
extern int intr(), yoda_intr IPT1(int, signo);
extern int timer_int_enabled;

int trace_type = DUMP_FLAGS | DUMP_REG | DUMP_INST;
#define INTEL_OPCODES 256
#define INSIGNIA_OPCODES 2
#define NR_ADDRS 256
#define INST_MIX_LENGTH ((INTEL_OPCODES+INSIGNIA_OPCODES)*NR_ADDRS)
/* inst_mix array declared below */
long inst_mix_count = 0;

static	long	big_dump=0; /* compress trace will dump all regs or just cs and ip */
static  long    ct_no_rom = 0;	/* non-zero means exclude ROM from 'ct' */
static	long	ct_delta_info=0; /* compress trace can dump an extra field when in a frag */

static	int	bse_seg = -1;
static	int	last_seg = -1;


/*
** Status variables for 80286/8087/80287 break and trace.
*/
static int b286_1=0, b286_2=0;		/* status of break on 80286 instructions, see the "b286-1" and "b286-2" commmands */
static int b286_1_stop=0, b286_2_stop=0;	/* 0=trace 1=break to yoda */
static int bNPX=0, bNPX_stop=0;

/* I/O streams */
FILE *out_stream = NULL;
FILE *in_stream = NULL;

GLOBAL int yoda_confirm IFN1(char *, question)
{
	char str [81];

#ifndef SFELLOW
	if (in_stream != stdin) return TRUE;
#endif /* SFELLOW */

	fputs(question, stdout);
	fflush(stdout);
	
	if (fgets (str, 80, in_stream) &&
		(str[0] == 'y' || str[0] == 'Y')) {
		return TRUE;	/* to be on the safe side */
	}
	return FALSE;
}
	
/*
 * Define file pointers for automatic file compare
 */
FILE   *compress_stream = 0;
FILE   *compress_npx = 0;
FILE   *compare_stream = 0;
IUH	compress_break = 0;
IUH	compare_break = 0;
IUH	compare_skip = 0;

/*
 * EOR
 */
int disk_inst = 0;

int int_breakpoint = 0;

int inst_break_count = 0;
BPTS inst[MAX_TABLE];

int host_address_break_count = 0;
DATA_BPTS host_addresses[MAX_TABLE_BREAK_WORDS];

int data_words_break_count = 0;
DATA_BPTS data_words[MAX_TABLE_BREAK_WORDS];

int data_bytes_break_count = 0;
BPTS data_bytes[MAX_TABLE];

int opcode_break_count = 0;
typedef struct {
	IU32	op;
	IU32	mask;
	IU32	stop;
} OPCODE_BREAK;
OPCODE_BREAK opcode_breaks[MAX_TABLE];

/*
** TF break stuff used by "btf"
*/
int tf_break_enabled = 0;

/*
** interrupt break stuff used by "bintx"
*/
int int_break_count = 0;
IU8 int_breaks[MAX_TABLE][2];

int access_break_count = 0;
long access_breaks[MAX_TABLE];

int step_count = -1;
int disable_bkpt = 0;

int refresh_screen = 0;

#ifdef DELTA
static int delta_prompt = 0;
#endif /* DELTA */

static short back_trace_flags = 0;
static IUH ct_line_num;

#ifdef	CPU_40_STYLE
enum pla_type { pla_type_empty,
		pla_type_rm_code,
		pla_type_pm_small_code,
		pla_type_pm_big_code,
		pla_type_simulate,
		pla_type_unsimulate,
		pla_type_bop_done,
		pla_type_intack,
		pla_type_pig_force,
		pla_type_nano_enter,
		pla_type_nano_leave
};
#ifndef	CCPU
#include <gdpvar.h>
#endif /* CCPU */
#endif	/* CPU_40_STYLE */

#define PLA_SIZE	(64*1024)

/* ----- Assorted BIG arrays, which the Mac needs to obtain using
 * ----- malloc
 */

#ifndef	macintosh

unsigned long 	inst_mix[INST_MIX_LENGTH];
word 		last_cs[PLA_SIZE];
LIN_ADDR 	last_ip[PLA_SIZE];

#ifdef	CPU_40_STYLE
enum pla_type 	last_type[PLA_SIZE];
#endif	/* CPU_40_STYLE */

#else /* !macintosh */

#include	<Memory.h>	/* for _NewPtrClear */

unsigned long 	*inst_mix;
word 		*last_cs;
LIN_ADDR 	*last_ip;

#ifdef	CPU_40_STYLE
enum pla_type 	*last_type;
#endif

GLOBAL void mac_yoda_init IFN0()
{
	/* These values should be initialised to zero */
		
#define ALLOCATE_ARRAY(type, name, size) \
	name = (type *)NewPtrClear((size)*sizeof(*name));
	
	ALLOCATE_ARRAY(  unsigned long, inst_mix, INST_MIX_LENGTH);
	ALLOCATE_ARRAY(  word,		last_cs,  PLA_SIZE);
	ALLOCATE_ARRAY(  LIN_ADDR, 	last_ip,  PLA_SIZE);

#ifdef	CPU_40_STYLE
	ALLOCATE_ARRAY(  enum pla_type, last_type,PLA_SIZE);
#endif	/* CPU_40_STYLE */
}

#endif	/* macintosh */

int	pla_ptr=0;

GLOBAL void set_last_address IFN2( word, cs, LIN_ADDR, ip)
{
    /*
     * Update the last address stamp
     */
#ifdef	CPU_40_STYLE
    /* We need to know if the CS is "big", this is expensive to calculate
     * every instruction, and almost impossible to deduce at print time
     * (e.g. after changing from V86 mode)
     * We compromise, by recording CsIsBig() when CS changes, and
     * accept the (small) loop-hole where a V86 (i.e. small) CS has
     * the same value as the PM, large, handler to which the V86code traps.
     */
    SAVED IU32 previous_cs = 0xFFFFFFFF;
    SAVED enum pla_type cs_code_kind;

    if (cs != previous_cs)
    {
	    if (getPE() && (getVM() == 0))
	    {
		    if (CsIsBig(cs))
			    cs_code_kind = pla_type_pm_big_code;
		    else
			    cs_code_kind = pla_type_pm_small_code;
	    }
	    else
		    cs_code_kind = pla_type_rm_code;
	    previous_cs = cs;
    }
    last_type[pla_ptr] = cs_code_kind;
#endif	/* CPU_40_STYLE */

    last_cs[pla_ptr] = cs;
    last_ip[pla_ptr] = ip;
    if (++pla_ptr==PLA_SIZE)
    {
		pla_ptr = 0;
    }
}

#ifdef	CPU_40_STYLE
GLOBAL void set_last_bop_done IFN1( word, number )
{
    /*
     * Update the last address stamp with BOP marker
     */

    last_cs[pla_ptr] = 0;
    last_ip[pla_ptr] = number;
    last_type[pla_ptr] = pla_type_bop_done;
    if (++pla_ptr==PLA_SIZE)
    {
		pla_ptr = 0;
    }
}
#endif	/* CPU_40_STYLE */

#ifdef	CPU_40_STYLE
GLOBAL void set_last_simulate IFN2(int, nesting_level, IBOOL, is_simulate)
{
    /*
     * Update the last address stamp  with (UN)SIMULATE marker
     */

    last_cs[pla_ptr] = 0;
    last_ip[pla_ptr] = nesting_level;
    last_type[pla_ptr] = is_simulate ? pla_type_simulate: pla_type_unsimulate;
    if (++pla_ptr==PLA_SIZE)
    {
		pla_ptr = 0;
    }
}
#endif	/* CPU_40_STYLE */

#ifdef	CPU_40_STYLE
GLOBAL void set_last_intack IFN1( word, line )
{
    /*
     * Update the last address stamp with INTACK line
     */

    last_cs[pla_ptr] = 0;
    last_ip[pla_ptr] = line;
    last_type[pla_ptr] = pla_type_intack;
    if (++pla_ptr==PLA_SIZE)
    {
		pla_ptr = 0;
    }
}
#endif	/* CPU_40_STYLE */

#ifdef	CPU_40_STYLE
GLOBAL void set_last_pig_force IFN0()
{
    /*
     * Update the last address stamp with PIG FORCE marker
     */

    last_cs[pla_ptr] = 0;
    last_ip[pla_ptr] = 0;
    last_type[pla_ptr] = pla_type_pig_force;
    if (++pla_ptr==PLA_SIZE)
    {
		pla_ptr = 0;
    }
}


GLOBAL void set_last_nano_enter IFN0()
{
    /*
     * Update the last address stamp with Nano enter marker
     */

    last_cs[pla_ptr] = 0;
    last_ip[pla_ptr] = 0;
    last_type[pla_ptr] = pla_type_nano_enter;
    if (++pla_ptr==PLA_SIZE)
    {
		pla_ptr = 0;
    }
}


GLOBAL void set_last_nano_leave IFN0()
{
    /*
     * Update the last address stamp with Nano leave marker
     */

    last_cs[pla_ptr] = 0;
    last_ip[pla_ptr] = 0;
    last_type[pla_ptr] = pla_type_nano_leave;
    if (++pla_ptr==PLA_SIZE)
    {
		pla_ptr = 0;
    }
}
#endif	/* CPU_40_STYLE */


host_addr	host_dest_addr;		/* address just written to by cpu */

/* Register Break Point Support */
typedef struct
   {
   int reg;
   int value;
   int stop;
   } REG_BKPT;

#define MAX_REG_BKPT 5

int reg_break_count = 0;

REG_BKPT reg_bkpt[MAX_REG_BKPT];


#if	defined(GENERIC_NPX) && !defined(CPU_40_STYLE)
IMPORT CHAR *NPXDebugPtr, *NPXDebugBase;
IMPORT	ULONG	*NPXFreq;

#define	MAX_NPX_OPCODE	(sizeoftable(NPXOpcodes))

static char *NPXOpcodes[] = {
	"Unimplemented",
	"Fadd_from_reg",
	"Fadd_to_reg",
	"Faddp_to_reg",
	"Fadd_sr",
	"Fadd_lr",
	"Fmul_from_reg",
	"Fmul_to_reg",
	"Fmulp_to_reg",
	"Fmul_sr",
	"Fmul_lr",
	"Fcom_reg",
	"Fcomp_reg",
	"Fcom_sr",
	"Fcom_lr",
	"Fcomp_sr",
	"Fcomp_lr",
	"Fsub_from_reg",
	"Fsub_to_reg",
	"Fsubp_reg",
	"Fsub_sr",
	"Fsub_lr",
	"Fsubr_from_reg",
	"Fsubr_to_reg",
	"Fsubrp_reg",
	"Fsubr_sr",
	"Fsubr_lr",
	"Fdiv_from_reg",
	"Fdiv_to_reg",
	"Fdivp_reg",
	"Fdiv_sr",
	"Fdiv_lr",
	"Fdivr_from_reg",
	"Fdivr_to_reg",
	"Fdivrp_reg",
	"Fdivr_sr",
	"Fdivr_lr",
	"Fld_reg",
	"Fld_sr",
	"Fld_lr",
	"Fld_tr",
	"Fst_reg",
	"Fst_sr",
	"Fst_lr",
	"Fstp_reg",
	"Fstp_sr",
	"Fstp_lr",
	"Fstp_tr",
	"Fxch",
	"Fiadd_si",
	"Fiadd_wi",
	"Fimul_si",
	"Fimul_wi",
	"Ficom_si",
	"Ficom_wi",
	"Ficomp_si",
	"Ficomp_wi",
	"Fisub_si",
	"Fisub_wi",
	"Fisubr_si",
	"Fisubr_wi",
	"Fidiv_si",
	"Fidiv_wi",
	"Fidivr_si",
	"Fidivr_wi",
	"Fild_si",
	"Fild_wi",
	"Fild_li",
	"Fist_si",
	"Fist_wi",
	"Fistp_si",
	"Fistp_wi",
	"Fistp_li",
	"Ffree",
	"Ffreep",
	"Fbld",
	"Fbstp",
	"Fldcw",
	"Fstenv",
	"Fstcw",
	"Fnop",
	"Fchs",
	"Fabs",
	"Ftst",
	"Fxam",
	"Fld1",
	"Fldl2t",
	"Fldl2e",
	"Fldpi",
	"Fldlg2",
	"Fldln2",
	"Fldz",
	"F2xm1",
	"Fyl2x",
	"Fptan",
	"Fpatan",
	"Fxtract",
	"Fdecstp",
	"Fincstp",
	"Fprem",
	"Fyl2xp1",
	"Fsqrt",
	"Frndint",
	"Fscale",
	"Fclex",
	"Finit",
	"Frstor",
	"Fsave",
	"Fstsw",
	"Fcompp",
	"Fstswax",
	"Fldenv"
};
#endif	/* GENERIC_NPX && !CPU_40_STYLE */

#ifdef PM
#ifdef SPC386
struct VMM_services {
	char *name;
	IU16 value;
};
static struct VMM_services VMM_services[] = {
  { "Get_VMM_Version", 0x00 },		{ "Get_Cur_VM_Handle", 0x01 },
  { "Test_Cur_VM_Handle", 0x02 },	{ "Get_Sys_VM_Handle", 0x03 },
  { "Test_Sys_VM_Handle", 0x04 },	{ "Validate_VM_Handle", 0x05 },
  { "Get_VMM_Reenter_Count", 0x06 },	{ "Begin_Reentrant_Execution", 0x07 },
  { "End_Reentrant_Execution", 0x08 },	{ "Install_V86_Break_Point", 0x09 },
  { "Remove_V86_Break_Point", 0x0a },	{ "Allocate_V86_Call_Back", 0x0b },
  { "Allocate_PM_Call_Back", 0x0c },	{ "Call_When_VM_Returns", 0x0d },
  { "Schedule_Global_Event", 0x0e },	{ "Schedule_VM_Event", 0x0f },
  { "Call_Global_Event", 0x10 },	{ "Call_VM_Event", 0x11 },
  { "Cancel_Global_Event", 0x12 },	{ "Cancel_VM_Event", 0x13 },
  { "Call_Priority_VM_Event", 0x14 },	{ "Cancel_Priority_VM_Event", 0x15 },
  { "Get_NMI_Handler_Addr", 0x16 },	{ "Set_NMI_Handler_Addr", 0x17 },
  { "Hook_NMI_Event", 0x18 },		{ "Call_When_VM_Ints_Enabled", 0x19 },
  { "Enable_VM_Ints", 0x1a },		{ "Disable_VM_Ints", 0x1b },
  { "Map_Flat", 0x1c },			{ "Map_Lin_To_VM_Addr", 0x1d },
  { "Adjust_Exec_Priority", 0x1e },	{ "Begin_Critical_Section", 0x1f },
  { "End_Critical_Section", 0x20 },	{ "End_Crit_And_Suspend", 0x21 },
  { "Claim_Critical_Section", 0x22 },	{ "Release_Critical_Section", 0x23 },
  { "Call_When_Not_Critical", 0x24 },	{ "Create_Semaphore", 0x25 },
  { "Destroy_Semaphore", 0x26 },	{ "Wait_Semaphore", 0x27 },
  { "Signal_Semaphore", 0x28 },		{ "Get_Crit_Section_Status", 0x29 },
  { "Call_When_Task_Switched", 0x2a },	{ "Suspend_VM", 0x2b },
  { "Resume_VM", 0x2c },		{ "No_Fail_Resume_VM", 0x2d },
  { "Nuke_VM", 0x2e },			{ "Crash_Cur_VM", 0x2f },
  { "Get_Execution_Focus", 0x30 },	{ "Set_Execution_Focus", 0x31 },
  { "Get_Time_Slice_Priority", 0x32 },	{ "Set_Time_Slice_Priority", 0x33 },
  { "Get_Time_Slice_Granularity", 0x34 },{ "Set_Time_Slice_Granularity", 0x35 },
  { "Get_Time_Slice_Info", 0x36 },	{ "Adjust_Execution_Time", 0x37 },
  { "Release_Time_Slice", 0x38 },	{ "Wake_Up_VM", 0x39 },
  { "Call_When_Idle", 0x3a },		{ "Get_Next_VM_Handle", 0x3b },
  { "Set_Global_Time_Out", 0x3c },	{ "Set_VM_Time_Out", 0x3d },
  { "Cancel_Time_Out", 0x3e },		{ "Get_System_Time", 0x3f },
  { "Get_VM_Exec_Time", 0x40 },		{ "Hook_V86_Int_Chain", 0x41 },
  { "Get_V86_Int_Vector", 0x42 },	{ "Set_V86_Int_Vector", 0x43 },
  { "Get_PM_Int_Vector", 0x44 },	{ "Set_PM_Int_Vector", 0x45 },
  { "Simulate_Int", 0x46 },		{ "Simulate_Iret", 0x47 },
  { "Simulate_Far_Call", 0x48 },	{ "Simulate_Far_Jmp", 0x49 },
  { "Simulate_Far_Ret", 0x4a },		{ "Simulate_Far_Ret_N", 0x4b },
  { "Build_Int_Stack_Frame", 0x4c },	{ "Simulate_Push", 0x4d },
  { "Simulate_Pop", 0x4e },		{ "_HeapAllocate", 0x4f },
  { "_HeapReAllocate", 0x50 },		{ "_HeapFree", 0x51 },
  { "_HeapGetSize", 0x52 },		{ "_PageAllocate", 0x53 },
  { "_PageReAllocate", 0x54 },		{ "_PageFree", 0x55 },
  { "_PageLock", 0x56 },		{ "_PageUnLock", 0x57 },
  { "_PageGetSizeAddr", 0x58 },		{ "_PageGetAllocInfo", 0x59 },
  { "_GetFreePageCount", 0x5a },	{ "_GetSysPageCount", 0x5b },
  { "_GetVMPgCount", 0x5c },		{ "_MapIntoV86", 0x5d },
  { "_PhysIntoV86", 0x5e },		{ "_TestGlobalV86Mem", 0x5f },
  { "_ModifyPageBits", 0x60 },		{ "_CopyPageTable", 0x61 },
  { "_LinMapIntoV86", 0x62 },		{ "_LinPageLock", 0x63 },
  { "_LinPageUnLock", 0x64 },		{ "_SetResetV86Pageable", 0x65 },
  { "_GetV86PageableArray", 0x66 },	{ "_PageCheckLinRange", 0x67 },
  { "_PageOutDirtyPages", 0x68 },	{ "_PageDiscardPages", 0x69 },
  { "_GetNulPageHandle", 0x6a },	{ "_GetFirstV86Page", 0x6b },
  { "_MapPhysToLinear", 0x6c },		{ "_GetAppFlatDSAlias", 0x6d },
  { "_SelectorMapFlat", 0x6e },		{ "_GetDemandPageInfo", 0x6f },
  { "_GetSetPageOutCount", 0x70 },	{ "Hook_V86_Page", 0x71 },
  { "_Assign_Device_V86_Pages", 0x72 },	{ "_DeAssign_Device_V86_Pages", 0x73 },
  { "_Get_Device_V86_Pages_Array", 0x74 },{ "MMGR_SetNULPageAddr", 0x75 },
  { "_Allocate_GDT_Selector", 0x76 },	{ "_Free_GDT_Selector", 0x77 },
  { "_Allocate_LDT_Selector", 0x78 },	{ "_Free_LDT_Selector", 0x79 },
  { "_BuildDescriptorDWORDs", 0x7a },	{ "_GetDescriptor", 0x7b },
  { "_SetDescriptor", 0x7c },		{ "_MMGR_Toggle_HMA", 0x7d },
  { "Get_Fault_Hook_Addrs", 0x7e },	{ "Hook_V86_Fault", 0x7f },
  { "Hook_PM_Fault", 0x80 },		{ "Hook_VMM_Fault", 0x81 },
  { "Begin_Nest_V86_Exec", 0x82 },	{ "Begin_Nest_Exec", 0x83 },
  { "Exec_Int", 0x84 },			{ "Resume_Exec", 0x85 },
  { "End_Nest_Exec", 0x86 },		{ "Allocate_PM_App_CB_Area", 0x87 },
  { "Get_Cur_PM_App_CB", 0x88 },	{ "Set_V86_Exec_Mode", 0x89 },
  { "Set_PM_Exec_Mode", 0x8a },		{ "Begin_Use_Locked_PM_Stack", 0x8b },
  { "End_Use_Locked_PM_Stack", 0x8c },	{ "Save_Client_State", 0x8d },
  { "Restore_Client_State", 0x8e },	{ "Exec_VxD_Int", 0x8f },
  { "Hook_Device_Service", 0x90 },	{ "Hook_Device_V86_API", 0x91 },
  { "Hook_Device_PM_API", 0x92 },	{ "System_Control", 0x93 },
  { "Simulate_IO", 0x94 },		{ "Install_Mult_IO_Handlers", 0x95 },
  { "Install_IO_Handler", 0x96 },	{ "Enable_Global_Trapping", 0x97 },
  { "Enable_Local_Trapping", 0x98 },	{ "Disable_Global_Trapping", 0x99 },
  { "Disable_Local_Trapping", 0x9a },	{ "List_Create", 0x9b },
  { "List_Destroy", 0x9c },		{ "List_Allocate", 0x9d },
  { "List_Attach", 0x9e },		{ "List_Attach_Tail", 0x9f },
  { "List_Insert", 0xa0 },		{ "List_Remove", 0xa1 },
  { "List_Deallocate", 0xa2 },		{ "List_Get_First", 0xa3 },
  { "List_Get_Next", 0xa4 },		{ "List_Remove_First", 0xa5 },
  { "_AddInstanceItem", 0xa6 },		{ "_Allocate_Device_CB_Area", 0xa7 },
  { "_Allocate_Global_V86_Data_Area", 0xa8 },{ "_Allocate_Temp_V86_Data_Area", 0xa9 },
  { "_Free_Temp_V86_Data_Area", 0xaa },	{ "Get_Profile_Decimal_Int", 0xab },
  { "Convert_Decimal_String", 0xac },	{ "Get_Profile_Fixed_Point", 0xad },
  { "Convert_Fixed_Point_String", 0xae },{ "Get_Profile_Hex_Int", 0xaf },
  { "Convert_Hex_String", 0xb0 },	{ "Get_Profile_Boolean", 0xb1 },
  { "Convert_Boolean_String", 0xb2 },	{ "Get_Profile_String", 0xb3 },
  { "Get_Next_Profile_String", 0xb4 },	{ "Get_Environment_String", 0xb5 },
  { "Get_Exec_Path", 0xb6 },		{ "Get_Config_Directory", 0xb7 },
  { "OpenFile", 0xb8 },			{ "Get_PSP_Segment", 0xb9 },
  { "GetDOSVectors", 0xba },		{ "Get_Machine_Info", 0xbb },
  { "GetSet_HMA_Info", 0xbc },		{ "Set_System_Exit_Code", 0xbd },
  { "Fatal_Error_Handler", 0xbe },	{ "Fatal_Memory_Error", 0xbf },
  { "Update_System_Clock", 0xc0 },	{ "Test_Debug_Installed", 0xc1 },
  { "Out_Debug_String", 0xc2 },		{ "Out_Debug_Chr", 0xc3 },
  { "In_Debug_Chr", 0xc4 },		{ "Debug_Convert_Hex_Binary", 0xc5 },
  { "Debug_Convert_Hex_Decimal", 0xc6 },{ "Debug_Test_Valid_Handle", 0xc7 },
  { "Validate_Client_Ptr", 0xc8 },	{ "Test_Reenter", 0xc9 },
  { "Queue_Debug_String", 0xca },	{ "Log_Proc_Call", 0xcb },
  { "Debug_Test_Cur_VM", 0xcc },	{ "Get_PM_Int_Type", 0xcd },
  { "Set_PM_Int_Type", 0xce },		{ "Get_Last_Updated_System_Time", 0xcf },
  { "Get_Last_Updated_VM_Exec_Time", 0xd0 },{ "Test_DBCS_Lead_Byte", 0xd1 },
  { "_AddFreePhysPage", 0xd2 },		{ "_PageResetHandlePAddr", 0xd3 },
  { "_SetLastV86Page", 0xd4 },		{ "_GetLastV86Page", 0xd5 },
  { "_MapFreePhysReg", 0xd6 },		{ "_UnmapFreePhysReg", 0xd7 },
  { "_XchgFreePhysReg", 0xd8 },		{ "_SetFreePhysRegCalBk", 0xd9 },
  { "Get_Next_Arena", 0xda },		{ "Get_Name_Of_Ugly_TSR", 0xdb },
  { "Get_Debug_Options", 0xdc },	{ "Set_Physical_HMA_Alias", 0xdd },
  { "_GetGlblRng0V86IntBase", 0xde },	{ "_Add_Global_V86_Data_Area", 0xdf },
  { "GetSetDetailedVMError", 0xe0 },	{ "Is_Debug_Chr", 0xe1 },
  { "Clear_Mono_Screen", 0xe2 },	{ "Out_Mono_Chr", 0xe3 },
  { "Out_Mono_String", 0xe4 },		{ "Set_Mono_Cur_Pos", 0xe5 },
  { "Get_Mono_Cur_Pos", 0xe6 },		{ "Get_Mono_Chr", 0xe7 },
  { "Locate_Byte_In_ROM", 0xe8 },	{ "Hook_Invalid_Page_Fault", 0xe9 },
  { "Unhook_Invalid_Page_Fault", 0xea },{ "Set_Delete_On_Exit_File", 0xeb },
  { "Close_VM", 0xec },			{ "Enable_Touch_1st_Meg", 0xed },
  { "Disable_Touch_1st_Meg", 0xee },	{ "Install_Exception_Handler", 0xef },
  { "Remove_Exception_Handler", 0xf0 },	{ "Get_Crit_Status_No_Block", 0xf1 },
  { NULL, 0 }
};

static char *segment_names[] =
   {
   "INVALID",
   "286_AVAILABLE_TSS",
   "LDT_SEGMENT",
   "286_BUSY_TSS",
   "286_CALL_GATE",
   "TASK_GATE",
   "286_INTERRUPT_GATE",
   "286_TRAP_GATE",
   "INVALID",
   "386_AVAILABLE_TSS",
   "INVALID",
   "386_BUSY_TSS",
   "386_CALL_GATE",
   "INVALID",
   "386_INTERRUPT_GATE",
   "386_TRAP_GATE",
   "EXPANDUP_READONLY_DATA",
   "EXPANDUP_READONLY_DATA",
   "EXPANDUP_WRITEABLE_DATA",
   "EXPANDUP_WRITEABLE_DATA",
   "EXPANDDOWN_READONLY_DATA",
   "EXPANDDOWN_READONLY_DATA",
   "EXPANDDOWN_WRITEABLE_DATA",
   "EXPANDDOWN_WRITEABLE_DATA",
   "NONCONFORM_NOREAD_CODE",
   "NONCONFORM_NOREAD_CODE",
   "NONCONFORM_READABLE_CODE",
   "NONCONFORM_READABLE_CODE",
   "CONFORM_NOREAD_CODE",
   "CONFORM_NOREAD_CODE",
   "CONFORM_READABLE_CODE",
   "CONFORM_READABLE_CODE"
   };
#else
static char *segment_names[] =
   {
   "INVALID",
   "AVAILABLE_TSS",
   "LDT_SEGMENT",
   "BUSY_TSS",
   "CALL_GATE",
   "TASK_GATE",
   "INTERRUPT_GATE",
   "TRAP_GATE",
   "INVALID",
   "INVALID",
   "INVALID",
   "INVALID",
   "INVALID",
   "INVALID",
   "INVALID",
   "INVALID",
   "EXPANDUP_READONLY_DATA",
   "EXPANDUP_READONLY_DATA",
   "EXPANDUP_WRITEABLE_DATA",
   "EXPANDUP_WRITEABLE_DATA",
   "EXPANDDOWN_READONLY_DATA",
   "EXPANDDOWN_READONLY_DATA",
   "EXPANDDOWN_WRITEABLE_DATA",
   "EXPANDDOWN_WRITEABLE_DATA",
   "NONCONFORM_NOREAD_CODE",
   "NONCONFORM_NOREAD_CODE",
   "NONCONFORM_READABLE_CODE",
   "NONCONFORM_READABLE_CODE",
   "CONFORM_NOREAD_CODE",
   "CONFORM_NOREAD_CODE",
   "CONFORM_READABLE_CODE",
   "CONFORM_READABLE_CODE"
   };
#endif /* SPC386 */

static int descr_trace = 0x3f;

#endif /* PM */

static int low_trace_limit = 0x0;
static int high_trace_limit = 0x400000;

#ifdef SFELLOW
LOCAL char SfNotImp[] = "This function is not implemented on Stringfellows.\n";
#endif /* SFELLOW */

#ifdef SPC386
#define DASM_INTERNAL
#include <dasm.h>
#else /* SPC386 */
IMPORT word dasm IPT5(char *, i_output_stream, word, i_atomicsegover, word, i_segreg, word, i_segoff, int, i_nInstr);
#endif /* SPC386 */

/*
 * ==========================================================================
 * Imported functions
 * ==========================================================================
 */

IMPORT VOID host_yoda_help_extensions IPT0();
IMPORT int  host_force_yoda_extensions IPT5(char *,com, long,cs, long,ip, long,len, char *, str);
IMPORT int  host_yoda_check_I_extensions IPT0();
IMPORT int  btrace IPT1(int, flags);
IMPORT void axe_ticks IPT1(int, ticks);
IMPORT void dump_Display IPT0();
IMPORT void dump_EGA_CPU IPT0();
IMPORT void dump_ega_planes IPT0();
IMPORT void read_ega_planes IPT0();
IMPORT void set_hfx_severity IPT0();
IMPORT void com_debug IPT0();
#ifdef DPMI
IMPORT void set_dpmi_severity IPT0();
#endif /* DPMI */
IMPORT void com_debug IPT0();
#ifndef GISP_CPU
#ifdef A3CPU
IMPORT void D2DmpBinaryImage IPT1(LONG, csbase24);
IMPORT void IH_dump_frag_hist IPT1(ULONG, n);
IMPORT void D2ForceTraceInit IPT0();
#endif
#endif /* GISP_CPU */
/*
 * ==========================================================================
 * Local functions
 * ==========================================================================
 */

LOCAL void	set_reg_break IPT3(char*, regstr, IU32,minv, IU32,maxv);
LOCAL void	show_phys_addr IPT1(LIN_ADDR, lin);
LOCAL void	guess_lin_phys IPT1(PHY_ADDR, phys);
LOCAL void	guess_lin_pte  IPT1(PHY_ADDR, pte_addr);
LOCAL void	dump_page_table IPT2(IS32, cs, IS32, len);
GLOBAL void	da_block IPT3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len) ;
LOCAL	void	dump_bytes IPT3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len);
LOCAL	void	dump_words IPT3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len);
LOCAL	void	dump_dwords IPT3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len);

#ifdef ANSI
LOCAL	void	clear_reg_break(char*);
LOCAL	void	print_reg_break();
LOCAL	BOOL	check_reg_break();
LOCAL	void	set_inst_break(IU16, LIN_ADDR, LIN_ADDR, LIN_ADDR, long);
LOCAL	void	dump_phys_bytes(IS32, IS32);
LOCAL	void	print_inst_break(void);
LOCAL	void	set_data_break_words(LIN_ADDR,LIN_ADDR,LIN_ADDR);
LOCAL	void	set_host_address_break(LIN_ADDR, LIN_ADDR, LIN_ADDR);
LOCAL	void	print_host_address_breaks(void);
LOCAL	void	print_data_break_words();
LOCAL	void	set_opcode_break(IU32, IU32);
LOCAL	void	set_int_break(IU8, IU8);
LOCAL	void	print_int_break(void);
LOCAL	void	print_opcode_break(void);
LOCAL	void	set_access_break(int);
LOCAL	void	print_access_break(void);
LOCAL	void	print_inst_mix(int);
LOCAL	void	cga_test(void);
LOCAL	void	do_back_trace(void);
LOCAL	void	add_inst_mix(void);
#ifdef NPX
LOCAL	void	do_compress_npx(FILE *);
#endif
#else	/* ANSI */
LOCAL	void	clear_reg_break();
LOCAL	void	print_reg_break();
LOCAL	BOOL	check_reg_break();
LOCAL	void	set_inst_break();
LOCAL	void	dump_phys_bytes();
LOCAL	void	print_inst_break();
LOCAL	void	set_data_break_words();
LOCAL	void	set_host_address_break();
LOCAL	void	print_host_address_breaks();
LOCAL	void	print_data_break_words();
LOCAL	void	set_opcode_break();
LOCAL	void	set_int_break();
LOCAL	void	print_int_break();
LOCAL	void	print_opcode_break();
LOCAL	void	set_access_break();
LOCAL	void	print_access_break();
LOCAL	void	print_inst_mix();
LOCAL	void	cga_test();
LOCAL	void	do_back_trace();
LOCAL	void	add_inst_mix();
#ifdef NPX
LOCAL	void	do_compress_npx();
#endif
#endif

LOCAL dump_descr IPT2(LIN_ADDR, address, IUM32, num);

/*
 *	YODA COMMAND HANDLERS
 *	=====================
 */

#ifdef GISP_SVGA

/* Allow us to turn Yoda "off" - this is so that if SoftPC is running full
screen a force_yoda() won't leave you wanting to type c into a window you can't
get at */
LOCAL YODA_COMMAND(doNoYoda)
{
	char		* NotStr;

	if( !NoYodaThanks )
	{
		stop = yoda_confirm("Are you really sure that you want to turn yoda off?");

		if( stop )
		{
			NoYodaThanks = TRUE;
		}
	}
	else
	{
		NoYodaThanks = FALSE;
	}

	if( NoYodaThanks )
	{
		printf( "On your head be it....call doNoYoda() from your debugger\nor set the global variable noYodaThanks FALSE to re-enable yoda\n" );
	}
	else
	{
		printf( "Yoda re-enabled\n" );
	}

	return 0;
}

#endif /* GISP_SVGA */
/*(
 *========================== do_pmt ==================================
 * do_pmt
 *
 * Purpose
 *    This routine prints a map of the different memory types across the
 *    whole of M.
 *
 * Input
 *    Is not used.
 *
 * Outputs
 *    None.
 *
 * Description
 *    We step through each 4K page in turn, printing out a new line every
 *    time the memory type changes.
 *
)*/

LOCAL YODA_COMMAND(do_pmt)
{
	PHY_ADDR currPage;
	PHY_ADDR endOfM;
	IU8 currType = SAS_MAX_TYPE + 1;      /*cause type at addr 0 to print*/
	IU8 newType;

	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	currPage = 0;
	endOfM = sas_memory_size();

	while (currPage < endOfM) {
		newType = sas_memory_type(currPage);
		if (newType != currType) {
			currType = newType;
			printf("\t0x%.08x   %.80s\n", currPage,
				SAS_TYPE_TO_STRING(newType));
		}
		currPage += 0x1000;
	}
	printf("\t0x%.08x   END OF MEMORY\n", endOfM);
	return(YODA_LOOP);
}


#if	defined(GENERIC_NPX) && !defined(CPU_40_STYLE)
LOCAL YODA_COMMAND(do_NPXdisp)
{
	CHAR *myNPXPtr = NPXDebugPtr;

	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	while (cs--) {
		fprintf(trace_file,"%s\n", NPXOpcodes[*--myNPXPtr]);
		if (myNPXPtr < NPXDebugBase)
			myNPXPtr = NPXDebugBase + 0x1000;
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_NPXfreq)
{
	ULONG *myNPXPtr = NPXFreq;
	int	i;
	ULONG count;

	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);
	UNUSED(cs);

	for (i=0;i<MAX_NPX_OPCODE;i++) {
		if ((count = *myNPXPtr++))
			fprintf(trace_file,"%s\t=\t%d\n", NPXOpcodes[i],count);
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_resetNPXfreq)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);
	UNUSED(cs);

	printf("Resetting NPX frequency information\n");
	memset((char *)NPXFreq,0,0x101*sizeof(ULONG));
	return(YODA_LOOP);
}
#endif	/* GENERIC_NPX && !CPU_40_STYLE */


#ifdef PM
LOCAL YODA_COMMAND(do_pm)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

        /* Set Protected Mode */
        setPE(1);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_dump_phys)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(stop);

        /* Dump physical address*/
	dump_phys_bytes(cs, len ? len : 32);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_show_phys_addr)
   {
   UNUSED(str); UNUSED(com); UNUSED(ip); UNUSED(len); UNUSED(stop);

   show_phys_addr((LIN_ADDR)cs);
   return(YODA_LOOP);
   }

LOCAL YODA_COMMAND(do_phys)
{
	LIN_ADDR lin;

	UNUSED(str);
	UNUSED(com);
	UNUSED(len);
	UNUSED(stop);

        /* Print physical address*/
	lin = eff_addr(cs,ip);
	if (getPG())
		show_phys_addr(lin);
	else
		fprintf(trace_file, "LinearAddress %08x\n", lin);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_guess_lin_phys)
   {
   UNUSED(str); UNUSED(com); UNUSED(ip); UNUSED(len); UNUSED(stop);

   guess_lin_phys((PHY_ADDR)cs);
   return(YODA_LOOP);
   }

LOCAL YODA_COMMAND(do_guess_lin_pte)
   {
   UNUSED(str); UNUSED(com); UNUSED(ip); UNUSED(len); UNUSED(stop);

   guess_lin_pte((IU32)cs);
   return(YODA_LOOP);
   }

LOCAL YODA_COMMAND(do_dump_page_table)
   {
   UNUSED(str); UNUSED(com); UNUSED(ip); UNUSED(stop);

   dump_page_table(cs, len);
   return(YODA_LOOP);
   }

LOCAL YODA_COMMAND(do_rtc)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
        /* Re-initialise rtc */
	printf("Re-initialising rtc\n");
	rtc_init();
	q_event_init();
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ica)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	ica_dump(0);
	ica_dump(1);
#endif /* SFELLOW */
	return(YODA_LOOP);
}

#ifdef	LIM
LOCAL YODA_COMMAND(do_zaplim)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

        /* ZAP LIM */
        sas_disconnect_memory(0xd0000,0xf0000);
	return(YODA_LOOP);
}
#endif	/* LIM */

LOCAL YODA_COMMAND(do_rm)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

        /* Set Real Mode */
        setPE(0);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pg)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

        /* Set paging Mode on/off */
        setPG(cs);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pgdt)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(len);
	UNUSED(stop);

        /* Print Global Descriptor Table Register */
        ip = (getGDT_LIMIT() + 1) / 8;  /* calc number descrs */
        fprintf(trace_file, "BASE: %6x LIMIT:%4x ENTRIES:%4x\n",
                getGDT_BASE(), getGDT_LIMIT(), ip);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pidt)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(len);
	UNUSED(stop);

        /* Print Interrupt Descriptor Table Register */
        ip = (getIDT_LIMIT() + 1) / 8;  /* calc number descrs */
        fprintf(trace_file, "BASE: %6x LIMIT:%4x ENTRIES:%4x\n",
                getIDT_BASE(), getIDT_LIMIT(), ip);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ptr)
{
	LIN_ADDR addr;
	DESCR entry;
	char *what;

	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

        /* Print Task Register */

	if (cs == 0)
	{
		cs = getTR_SELECTOR();
		fprintf(trace_file, "SELECTOR:%4x BASE: %6x LIMIT:%4x\n",
			cs, getTR_BASE(), getTR_LIMIT());
		if ( selector_outside_table(cs, &addr) )
		{
			fprintf(trace_file, "Bad TR selector\n");
			return(YODA_LOOP);
		}
	}
	else
	{
		if ( selector_outside_table(cs, &addr) )
		{
			fprintf(trace_file, "Bad selector\n");
			return(YODA_LOOP);
		}
	}

	read_descriptor(addr, &entry);
	addr = entry.base;
	switch (entry.AR & 0x9f)
	{
	case 0x81: what = "286 AVALIABLE"; break;
	case 0x83: what = "286 BUSY"; break;
	case 0x89: what = "386 AVALIABLE"; break;
	case 0x8b: what = "386 BUSY"; break;
	default:
		fprintf(trace_file, "Bad TSS selector\n");
		return(YODA_LOOP);
	}
	fprintf(trace_file, "TSS descriptor in memory is %s\n", what);
	fprintf(trace_file, "TSS segment at %08x:\n", addr);
	if (entry.AR & 0x08)
	{
		/* 386 style TSS */
		
		fprintf(trace_file, "%-9s:     %04x\n",	"old TSS",	sas_w_at  (addr + 0x00));
		fprintf(trace_file, "%-9s: %08x\n",	"ESP0",		sas_dw_at (addr + 0x04));
		fprintf(trace_file, "%-9s:     %04x\n",	"SS0",		sas_w_at  (addr + 0x08));
		fprintf(trace_file, "%-9s: %08x\n",	"ESP1",		sas_dw_at (addr + 0x0C));
		fprintf(trace_file, "%-9s:     %04x\n",	"SS1",		sas_w_at  (addr + 0x10));
		fprintf(trace_file, "%-9s: %08x\n",	"ESP2",		sas_dw_at (addr + 0x14));
		fprintf(trace_file, "%-9s:     %04x\n",	"SS2",		sas_w_at  (addr + 0x18));
		fprintf(trace_file, "%-9s: %08x\n",	"PDBR",		sas_dw_at (addr + 0x1C));
		fprintf(trace_file, "%-9s: %08x\n",	"EIP",		sas_dw_at (addr + 0x20));
		fprintf(trace_file, "%-9s: %08x\n",	"EFLAGS",	sas_dw_at (addr + 0x24));
		fprintf(trace_file, "%-9s: %08x\n",	"EAX",		sas_dw_at (addr + 0x28));
		fprintf(trace_file, "%-9s: %08x\n",	"ECX",		sas_dw_at (addr + 0x2c));
		fprintf(trace_file, "%-9s: %08x\n",	"EDX",		sas_dw_at (addr + 0x30));
		fprintf(trace_file, "%-9s: %08x\n",	"EBX",		sas_dw_at (addr + 0x34));
		fprintf(trace_file, "%-9s: %08x\n",	"ESP",		sas_dw_at (addr + 0x38));
		fprintf(trace_file, "%-9s: %08x\n",	"EBP",		sas_dw_at (addr + 0x3c));
		fprintf(trace_file, "%-9s: %08x\n",	"ESI",		sas_dw_at (addr + 0x40));
		fprintf(trace_file, "%-9s: %08x\n",	"EDI",		sas_dw_at (addr + 0x44));
		fprintf(trace_file, "%-9s:     %04x\n",	"ES",		sas_w_at  (addr + 0x48));
		fprintf(trace_file, "%-9s:     %04x\n",	"CS",		sas_w_at  (addr + 0x4c));
		fprintf(trace_file, "%-9s:     %04x\n",	"SS",		sas_w_at  (addr + 0x50));
		fprintf(trace_file, "%-9s:     %04x\n",	"DS",		sas_w_at  (addr + 0x54));
		fprintf(trace_file, "%-9s:     %04x\n",	"FS",		sas_w_at  (addr + 0x58));
		fprintf(trace_file, "%-9s:     %04x\n",	"GS",		sas_w_at  (addr + 0x5c));
		fprintf(trace_file, "%-9s:     %04x\n",	"LDT",		sas_w_at  (addr + 0x60));
		fprintf(trace_file, "%-9s:       %02x\n", "Trap",	sas_hw_at (addr + 0x64));
	}
	else
	{
		/* 286 style TSS */
		fprintf(trace_file, "%-9s: %04x\n", "old TSS",	sas_w_at (addr +  0));
		fprintf(trace_file, "%-9s: %04x\n", "SP0",	sas_w_at (addr +  2));
		fprintf(trace_file, "%-9s: %04x\n", "SS0",	sas_w_at (addr +  4));
		fprintf(trace_file, "%-9s: %04x\n", "SP1",	sas_w_at (addr +  6));
		fprintf(trace_file, "%-9s: %04x\n", "SS1",	sas_w_at (addr +  8));
		fprintf(trace_file, "%-9s: %04x\n", "SP2",	sas_w_at (addr + 10));
		fprintf(trace_file, "%-9s: %04x\n", "SS2",	sas_w_at (addr + 12));
		fprintf(trace_file, "%-9s: %04x\n", "IP",	sas_w_at (addr + 14));
		fprintf(trace_file, "%-9s: %04x\n", "FLAGS",	sas_w_at (addr + 16));
		fprintf(trace_file, "%-9s: %04x\n", "AX",	sas_w_at (addr + 18));
		fprintf(trace_file, "%-9s: %04x\n", "CX",	sas_w_at (addr + 20));
		fprintf(trace_file, "%-9s: %04x\n", "DX",	sas_w_at (addr + 22));
		fprintf(trace_file, "%-9s: %04x\n", "BX",	sas_w_at (addr + 24));
		fprintf(trace_file, "%-9s: %04x\n", "SP",	sas_w_at (addr + 26));
		fprintf(trace_file, "%-9s: %04x\n", "BP",	sas_w_at (addr + 28));
		fprintf(trace_file, "%-9s: %04x\n", "SI",	sas_w_at (addr + 30));
		fprintf(trace_file, "%-9s: %04x\n", "DI",	sas_w_at (addr + 32));
		fprintf(trace_file, "%-9s: %04x\n", "ES",	sas_w_at (addr + 34));
		fprintf(trace_file, "%-9s: %04x\n", "CS",	sas_w_at (addr + 36));
		fprintf(trace_file, "%-9s: %04x\n", "SS",	sas_w_at (addr + 38));
		fprintf(trace_file, "%-9s: %04x\n", "DS",	sas_w_at (addr + 40));
		fprintf(trace_file, "%-9s: %04x\n", "LDT",	sas_w_at (addr + 42));
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pldt)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(len);
	UNUSED(stop);

        /* Print Local Descriptor Table Register */
        ip = (getLDT_LIMIT() + 1) / 8;  /* calc number descrs */
        fprintf(trace_file, "SELECTOR:%4x BASE: %6x LIMIT:%4x ENTRIES:%4x\n",
                getLDT_SELECTOR(), getLDT_BASE(), getLDT_LIMIT(), ip);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_par)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SPC386
	    fprintf(trace_file, "CS: BASE:%08x LIMIT:%08x AR:%04x\n",
	       getCS_BASE(), getCS_LIMIT(), getCS_AR());
	    fprintf(trace_file, "SS: BASE:%08x LIMIT:%08x AR:%04x\n",
	       getSS_BASE(), getSS_LIMIT(), getSS_AR());
	    fprintf(trace_file, "DS: BASE:%08x LIMIT:%08x AR:%04x\n",
	       getDS_BASE(), getDS_LIMIT(), getDS_AR());
	    fprintf(trace_file, "ES: BASE:%08x LIMIT:%08x AR:%04x\n",
	       getES_BASE(), getES_LIMIT(), getES_AR());
	    fprintf(trace_file, "FS: BASE:%08x LIMIT:%08x AR:%04x\n",
	       getFS_BASE(), getFS_LIMIT(), getFS_AR());
	    fprintf(trace_file, "GS: BASE:%08x LIMIT:%08x AR:%04x\n",
	       getGS_BASE(), getGS_LIMIT(), getGS_AR());
#else /* SPC386 */
#ifdef CPU_30_STYLE
	fprintf(trace_file, "3.0 CPU doesn't support this yet!\n");
#else
        fprintf(trace_file, "CS: %d DS: %d ES: %d SS: %d\n",
                             ALC_CS, ALC_DS, ALC_ES, ALC_SS);
#endif /* CPU_30_STYLE */
#endif /* SPC386 */							
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pdtrc)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if ( cs == 0 )
        {
        	descr_trace = 0x3f;
        	fprintf(stderr, " 0x01 - INVALID\n");
        	fprintf(stderr, " 0x02 - SPECIAL\n");
        	fprintf(stderr, " 0x04 - CALL GATE\n");
        	fprintf(stderr, " 0x08 - INTERRUPT/TRAP/TASK GATE\n");
        	fprintf(stderr, " 0x10 - DATA\n");
        	fprintf(stderr, " 0x20 - CODE\n");
        }
        else
        	descr_trace = cs;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pseg)
{
#ifndef CPU_30_STYLE
	/* Print Segment Registers */
	cs = (getCS_AR() & 0x60) >> 5;      /*  dpl */
	ip = (getCS_AR() & 0x1f);           /*  super */
	fprintf(trace_file, "CS:: SELECTOR:%4x DPL:%1d TYPE:%25s BASE: %6x LIMIT:%4x\n",
	        getCS_SELECTOR(), cs, segment_names[ip], getCS_BASE(), getCS_LIMIT());
	cs = (getSS_AR() & 0x60) >> 5;      /*  dpl */
	ip = (getSS_AR() & 0x1f);           /*  super */
	fprintf(trace_file, "SS:: SELECTOR:%4x DPL:%1d TYPE:%25s BASE: %6x LIMIT:%4x\n",
	        getSS_SELECTOR(), cs, segment_names[ip], getSS_BASE(), getSS_LIMIT());
	cs = (getDS_AR() & 0x60) >> 5;      /*  dpl */
	ip = (getDS_AR() & 0x1f);           /*  super */
	fprintf(trace_file, "DS:: SELECTOR:%4x DPL:%1d TYPE:%25s BASE: %6x LIMIT:%4x\n",
	        getDS_SELECTOR(), cs, segment_names[ip], getDS_BASE(), getDS_LIMIT());
	cs = (getES_AR() & 0x60) >> 5;      /*  dpl */
	ip = (getES_AR() & 0x1f);           /*  super */
	fprintf(trace_file, "ES:: SELECTOR:%4x DPL:%1d TYPE:%25s BASE: %6x LIMIT:%4x\n",
	        getES_SELECTOR(), cs, segment_names[ip], getES_BASE(), getES_LIMIT());
#else
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	fprintf(trace_file, "Function not supported anymore\n");
#endif
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pd)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(len);
	UNUSED(stop);

	/* Print Descriptor */
	if ( ip == 0 )   /* 2nd arg defaults to 1 */
		ip = 1;
	dump_descr((LIN_ADDR)cs, (IUM32)ip);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pdseg)
{
	double_word ip_as_double_word = ip;
	UNUSED(str);
	UNUSED(com);
	UNUSED(len);
	UNUSED(stop);

	/* Print Descriptor of a given selector */
	if ( selector_outside_table(cs, &ip_as_double_word) )
	{
		fprintf(trace_file, "Bad selector\n");
	}
	else
	{
		cs = ip_as_double_word;
		ip = 1;
		dump_descr((LIN_ADDR)cs, (IUM32)ip);
	}
	return(YODA_LOOP);
}

#endif
#ifdef MUST_BLOCK_TIMERS
LOCAL YODA_COMMAND(do_blt)
{
	if ( timer_blocked) {
		printf("\nTimer already blocked\n");
	}
	else {
		timer_blocked=1;
		printf("\nTimer blocked\n");
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ubt)
{
	if ( !timer_blocked) {
		printf("\nTimer not blocked\n");
	}
	else {
		timer_blocked=0;
		printf("\nTimer unblocked\n");
	}
	return(YODA_LOOP);
}
#endif /* MUST_BLOCK_TIMERS */

#ifdef BSD4_2
LOCAL YODA_COMMAND(do_bs)
{
	int oldmask;

	if ( cs > 0 && cs < 32 )
		oldmask = sigblock( 1 << ( cs - 1 ) );
	else
		printf("\nInvalid signal no. ( <= 0x0 or >= 0x20 )\n");
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_us)
{
	int oldmask;

	if ( cs > 0 && cs < 32 )
		{
			oldmask = sigblock(0);
			if ( (oldmask & (1 << (cs -1))) != 0 )
			{
				oldmask ^= (1 << ( cs - 1));
				oldmask = sigsetmask(oldmask);
			}
			else
				printf("signal not currently blocked\n");
		}
	else
		printf("Invalid signal no. ( <= 0x0 or >= 0x20 )\n");
	return(YODA_LOOP);
}
#endif /* BSD4_2 */

#if defined(CPU_40_STYLE) && !defined (SFELLOW) && !defined (NTVDM)
extern IBOOL DoingVDDStuff;
extern IBOOL enableDebugVDD;

LOCAL YODA_COMMAND(do_vdd)
{
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	DoingVDDStuff = (cs == 0)?FALSE:TRUE;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_debug_vdd)
{
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	enableDebugVDD = (cs == 0)?FALSE:TRUE;
	return(YODA_LOOP);
}
#endif /* CPU_40_STYLE && !SFELLOW */

LOCAL YODA_COMMAND(do_tf)
{
	char newtrace[100];

	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	newtrace[0] = '\0';
	sscanf(str, "%s %s", com, newtrace);
	if ((trace_file != stderr) && (trace_file != stdout))
	    fclose(trace_file);
	if (newtrace[0] == '\0')
	    trace_file = stdout;
	else {
	    if ((trace_file = fopen(newtrace, "w")) == NULL) {
		printf("couldnt open %s\n", newtrace);
		trace_file = stdout;
	    }
	}
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_read)
{
	char newfile [100];

	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	newfile [0] = '\0';

	sscanf (str, "%s %s", com, newfile);

	/* if already reading a script close it */
	if (in_stream != stdin)
		fclose (in_stream);

	/* do we have a new pathname */
	if (newfile [0])
	{
		/* try to open it */
		if (in_stream = fopen (newfile, "r"))
		{
			printf ("Reading '%s'\n", newfile);
		}
		else
		{
			/* oops - provide useful error message */
			perror (newfile);

			/* return to reading stdin */
			in_stream = stdin;
		}
	}
	else
	{
		puts ("No pathname supplied, reading stdin");
	}
#endif /* SFELLOW */
	return (YODA_LOOP);
}

LOCAL YODA_COMMAND(do_toff)
{
#ifdef SFELLOW
        IU8 value;

        inb(0x21, &value);
        outb(0x21, value | 0x1);
#else /* SFELLOW */
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	timer_int_enabled = 0;
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ton)
{
#ifdef SFELLOW
        IU8 value;

        inb(0x21, &value);
        outb(0x21, value & 0xfe);
#else /* SFELLOW */
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	timer_int_enabled = 1;
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_toff2)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	if (chewy) {
		printf("Take care!\nThe power of the force is strong, and it can do evil as well as good.\n");
	}
	axe_ticks( -1 );
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ton2)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	axe_ticks( 0 );
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_query)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	trace("", trace_type);
	return(YODA_LOOP);
}

#ifdef GISP_CPU
LOCAL YODA_COMMAND(do_hgps)
{
	IMPORT VOID Hg_print_stats IPT0();
	Hg_print_stats();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_hgcs)
{
	IMPORT VOID Hg_clear_stats IPT0();
	Hg_clear_stats();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_vex)
{
	IMPORT IBOOL show_exceptions;
	show_exceptions = !show_exceptions;
	printf ("Verbose exceptions now %sabled.\n", (show_exceptions ? "en" : "dis"));
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_bex)
{
	IMPORT IBOOL trap_exceptions;
	trap_exceptions = !trap_exceptions;
	printf ("Break on faults now %sabled.\n", (trap_exceptions ? "en" : "dis"));
	return(YODA_LOOP);
}
#endif /* GISP_CPU */
#ifdef A3CPU
#ifndef GISP_CPU
LOCAL YODA_COMMAND(do_dcs)
{
	long temp1, temp2, temp3;
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	temp1 = -1;
	sscanf(str, "%s %lx:%lx %lx", com, &temp1, &temp2, &temp3);
	if (temp1 != -1)
	{
		D2DmpBinaryImage((LONG)temp1);
		printf ("Use the dfih command to dump the instruction history for a fragment.\n");
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_dfih)
{
	unsigned long temp1, temp2, temp3;
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	temp1 = -1;
	sscanf(str, "%s %i:%lx %lx", com, &temp1, &temp2, &temp3);
	if (temp1 != -1)
	{
		IH_dump_frag_hist((ULONG)temp1);
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_d2)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	D2ForceTraceInit();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_d2threshold)
{
	IMPORT D2LowerThreshold, D2UpperThreshold;

	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	sscanf(str, "%s %lx lx", com,&D2LowerThreshold,&D2UpperThreshold);
	return(YODA_LOOP);
}
#endif /* GISP_CPU */
#endif /* A3CPU */

LOCAL YODA_COMMAND(do_u)
{
	char com_args[100];

	SAVED IBOOL first_time = TRUE;
	SAVED IU32 last_dasm_cs, last_dasm_ip;
	SAVED IU16 entryCs;
	SAVED IU32 entryIp;

	UNUSED(stop);

	/*
	 * We treat the special case of a blank argument as "continue
	 * from where we were last time" rather than CS:IP=0:0 which the
	 * address processing will have assumed. We do this unless this is
	 * the first time that we have been called in which case a blank
	 * command line means current CS:IP (which we need to get for
	 * ourselves.
	 *
	 * However, if the processor cs and ip has moved on from the last
	 * time we did a 'u', we assume that the user would probably prefer
	 * a 'u' from there, rather than following on.
	 */
	if (sscanf(str, "%*s %s", com_args) != 1) {
		/*
		 * Blank command line ..
		 */
		if (first_time) {
			last_dasm_cs = getCS();
			last_dasm_ip = GetInstructionPointer();
			entryIp = last_dasm_ip;
			entryCs = last_dasm_cs;
			first_time = FALSE;
		} else if ((entryIp != GetInstructionPointer())
				|| (entryCs != getCS()))
		{
			entryIp = GetInstructionPointer();
			entryCs = getCS();
			last_dasm_ip = entryIp;
			last_dasm_cs = entryCs;
		}
		cs = last_dasm_cs;
		ip = last_dasm_ip;
	} else {
		last_dasm_cs = cs;
		last_dasm_ip = ip;
		first_time = FALSE;
	}
	if ((len == 0) || (len == YODA_LEN_UNSPECIFIED))
		len = 0x10;
	disable_bkpt = 1;

#ifdef SPC386
	{
		char buff[256];
		IBOOL size = CsIsBig(cs) ? THIRTY_TWO_BIT: SIXTEEN_BIT;

		while (len-- > 0){
			last_dasm_ip += dasm(buff, (word)cs, (IU32)last_dasm_ip, size);
			fprintf (trace_file, "%s", buff);
		}
	}
#else /* SPC386 */
	last_dasm_ip = dasm((char *)0,(word)0,(word)cs, (word)ip, (word)len);
#endif /* SPC386 */
	disable_bkpt = 0;
	return(YODA_LOOP_AND_REPEAT);
}

#ifdef DELTA
LOCAL YODA_COMMAND(do_del)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	examine_delta_data_structs(stdout,stdin);
	return(YODA_LOOP);
}
#endif /* DELTA */

LOCAL YODA_COMMAND(do_j)
{
	LIN_ADDR nextip;

	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(stop);

	disable_bkpt = 1;
	if (len == YODA_LEN_UNSPECIFIED)
		len = 1;

#ifdef SPC386
	nextip = GetInstructionPointer();
	while (len-- > 0){
		nextip += dasm((char *)-1, (word)getCS(), getEIP(), 0);
	}
#else /* SPC386 */
	nextip = dasm((char *)-1,(word)1,(word)getCS(), (word)getIP(), (word)len);
#endif /* SPC386 */
	disable_bkpt = 0;
	set_inst_break(getCS(), nextip, 1, 1, 1);
	disable_timer = 0;

	return(go_slow());
}

LOCAL YODA_COMMAND(do_ctnpx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	compress_npx = fopen("comp_npx","w");
	printf("compress_npx is %x\n",compress_npx);
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_r)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	disable_bkpt = 1;
	trace("", DUMP_FLAGS | DUMP_REG);
	disable_bkpt = 0;
	return(YODA_LOOP);
}

#ifdef	NPX
LOCAL YODA_COMMAND(do_287r)
{	
#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	extern ULONG get_287_status_word IPT0();
	extern ULONG get_287_control_word IPT0();
	extern ULONG get_287_sp IPT0();

	ULONG sw287 = get_287_status_word () | ((get_287_sp() & 0x7) << 11);
	ULONG cw287 = get_287_control_word ();
	int cc287;

	static char *precision_cntrl[] =
		{"24bit", "RESERVED(?) precision", "53bit", "64bit"};
	static char *rounding_cntrl[] =
		{"round to nearest/even",
		 "round down (towards -Inf)",
		 "round up (towards +Inf)",
		 "chop (towards zero)"};

	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	/* Decode 80287 control word */

	printf ("NPX Control [%04lx]: %s, %s, %s\n", cw287,
		precision_cntrl[(cw287 >> 8) & 0x3],
		rounding_cntrl[(cw287 >> 10) & 0x3],
		cw287 & 0x1000 ? "affine infinity" : "projective infinity");
		
	if (cw287 & 0x3f) {
		printf ("Masked Exceptions: ");
		if (cw287 & 0x01) printf ("INVALID ");
		if (cw287 & 0x02) printf ("DENORMAL ");
		if (cw287 & 0x04) printf ("ZERO-DIVIDE ");
		if (cw287 & 0x08) printf ("OVERFLOW ");
		if (cw287 & 0x10) printf ("UNDERFLOW ");
		if (cw287 & 0x20) printf ("PRECISION ");
		printf ("\n");
	} else
		printf ("No exceptions masked\n");

	/* Decode 80287 status word */

	printf ("NPX Status [%04lx]: stack bottom = ST(%d), ", sw287,
		(sw287 >> 11) & 0x7);

	cc287 = (sw287 >> 8) & 0x7;
	if (sw287 & 0x4000)
		cc287 |= 0x80;

	printf ("condition code = %1x, ", cc287);

	printf ("%s\n", sw287 & 0x8000 ? "BUSY" : "not busy");

	if (sw287 & 0x3f) {
		printf ("Exceptions flagged (ES=%d): ", sw287 & 0x80 ? 1 : 0);
		if (sw287 & 0x01) printf ("INVALID ");
		if (sw287 & 0x02) printf ("DENORMAL ");
		if (sw287 & 0x04) printf ("ZERO-DIVIDE ");
		if (sw287 & 0x08) printf ("OVERFLOW ");
		if (sw287 & 0x10) printf ("UNDERFLOW ");
		if (sw287 & 0x20) printf ("PRECISION ");
		printf ("\n");
	} else
		printf ("No exceptions flagged (ES=%d)\n",
			sw287 & 0x80 ? 1 : 0);

	/*
	 * Dump out the rest of the stack etc ..
	 */
	do_compress_npx(stdout);
#endif /* SFELLOW */
	return(YODA_LOOP);
}
#endif	/* NPX */

LOCAL YODA_COMMAND(do_inb)
{
	half_word tempbyte;
	int portNo;

	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	sscanf(str,"%*s %x", &portNo);
	inb(portNo,&tempbyte);
	printf("port %04lx contains %02x\n", cs, tempbyte);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_inw)
{
	IU16 tempword;
	int portNo;

	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	sscanf(str,"%*s %x", &portNo);
	inw(portNo, &tempword);
	printf("port %04lx contains %04x\n", cs, tempword);
	return(YODA_LOOP);
}

#ifdef SPC386
LOCAL YODA_COMMAND(do_ind)
{
	IU32 templong;
	int portNo;

	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	sscanf(str,"%*s %x", &portNo);
	ind(portNo, &templong);
	printf("port %04lx contains %08x\n", cs, templong);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_outb)
{
	int portNo, value;
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	sscanf(str,"%*s %x %x", &portNo, &value);
	outb(portNo,(half_word)value);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_outw)
{
	int portNo, value;
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	sscanf(str,"%*s %x %x", &portNo, &value);
	outw(portNo, (IU16)value);
	return(YODA_LOOP);
}

#ifdef SPC386
LOCAL YODA_COMMAND(do_outd)
{
	int portNo;
	IU32 value;
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	sscanf(str,"%*s %x %x", &portNo, &value);
	outd(portNo, value);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_luke)
{
	if (fast) {
	    return do_slow(str, com, cs, ip, len, stop);
	}
	return do_fast(str, com, cs, ip, len, stop);
}

LOCAL YODA_COMMAND(do_fff)
{
  UNUSED(str);
  UNUSED(com);
  UNUSED(cs);
  UNUSED(ip);
  UNUSED(stop);
#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
#endif /* SFELLOW */
}

#if !defined(REAL_VGA) && !defined(SFELLOW)
LOCAL YODA_COMMAND(do_time_Display)
{
	int i;
	float elapsed;
	struct host_timezone dummy;
	struct host_timeval tstart,tend;

	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if( !cs ) cs=100;		/* fairly long time by default */
	
	host_clear_screen();	/* Indicate start for hand timing */
	host_gettimeofday(&tstart, &dummy);
	for(i=0; i<cs; i++)
	{
		screen_refresh_required();		/* Force full screen repaint */
		(*update_alg.calc_update)();	/* and do it */
	}
	host_gettimeofday(&tend, &dummy);
	host_clear_screen();	/* Indicate end for hand timing */

	/* Now restore the original image */
	screen_refresh_required();
	(*update_alg.calc_update)();

	/* And print out the results */
	elapsed = tend.tv_sec - tstart.tv_sec + (float)(tend.tv_usec - tstart.tv_usec)/1000000.0;
	printf("%d repaints of BIOS mode %d took %f seconds\n",cs,sas_hw_at_no_check(vd_video_mode),elapsed);
	printf("%f seconds per refresh\n",elapsed/cs);
	
	return(YODA_LOOP);
}
#ifdef	EGG
LOCAL YODA_COMMAND(do_dump_Display)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	dump_Display();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_dump_EGA_GRAPH)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	dump_EGA_GRAPH();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_dump_EGA_CPU)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	dump_EGA_CPU();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_dump_planes)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	dump_ega_planes();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_read_planes)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	read_ega_planes();
	return(YODA_LOOP);
}
#endif /* EGG */
#endif /* not REAL_VGA and not SFELLOW */

LOCAL YODA_COMMAND(do_db)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(stop);

	if (len == YODA_LEN_UNSPECIFIED)
		len = 1;

	dump_bytes((IU16)cs, ip, (len > 0) ? len : 1);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_dw)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(stop);

	if (len == YODA_LEN_UNSPECIFIED)
		len = 1;

	dump_words((IU16)cs, ip, (len > 0) ? len : 1);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_dd)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(stop);

	if (len == YODA_LEN_UNSPECIFIED)
		len = 1;

	dump_dwords((IU16)cs, ip, (len > 0) ? len : 1);
	return(YODA_LOOP);
}

static int last_da_cs;
static int last_da_ip;

LOCAL YODA_COMMAND(do_da)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(stop);

	da_block((IU16)cs, ip, len);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_t)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (cs)
	  trace_type = cs;
	else
	{
	  trace_type = DUMP_FLAGS | DUMP_REG | DUMP_INST;
	  if (bNPX)
	    trace_type |= DUMP_NPX;
	}
	verbose = 1;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_it)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (cs == 0L)
	    io_verbose = 0L;
	else
	{
	    io_verbose = cs;
	    if (io_verbose & HFX_VERBOSE)
#ifdef SFELLOW
		printf("HFX_VERBOSE is not implemented on Stringfellows.\n");
#else /* SFELLOW */
		set_hfx_severity();
#endif /* SFELLOW */

	    if (io_verbose & HDA_VERBOSE)
#ifdef SFELLOW
		printf("HDA_VERBOSE is not implemented on Stringfellows.\n");
#else /* SFELLOW */
		setdisktrace();
#endif /* SFELLOW */
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_sit)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (cs == 0L)
	    sub_io_verbose = 0L;
	else
	{
	    sub_io_verbose = cs;
#ifdef DPMI
	    if (sub_io_verbose & DPMI_VERBOSE)
		set_dpmi_severity();
#endif /* DPMI */
	}
	return(YODA_LOOP);
}


LOCAL YODA_COMMAND(do_dt)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	disk_trace = 1;
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_trace)
{
	static char* titles[] =
	{"Primary trace flags:\n",
	 "\n\nDisk BIOS subsidiary trace flags (enabled by primary hda flag):\n",
	 "\n\nFSA subsidiary trace flags (enabled by primary hfx flag):\n"};

	static struct trace_flag_t {
		char *name;
		IU32 mask;
		IU32 *addr;
		int title_id;
	}
	 trace_flags[] =
	{
	 {"general",	GENERAL_VERBOSE,	&io_verbose,		1},
	 {"timer",	TIMER_VERBOSE,		&io_verbose,		0},
	 {"ica",	ICA_VERBOSE,		&io_verbose,		0},
	 {"cga",	CGA_VERBOSE, 		&io_verbose,		0},
	 {"fla",	FLA_VERBOSE,		&io_verbose,		0},
	 {"hda",	HDA_VERBOSE,		&io_verbose,		0},
	 {"rs232",	RS232_VERBOSE,		&io_verbose,		0},
	 {"printer",	PRINTER_VERBOSE,	&io_verbose,		0},
	 {"ppi",	PPI_VERBOSE,		&io_verbose,		0},
	 {"dma",	DMA_VERBOSE,		&io_verbose,		0},
	 {"gfi",	GFI_VERBOSE,		&io_verbose,		0},
	 {"mouse",	MOUSE_VERBOSE,		&io_verbose,		0},
	 {"mda",	MDA_VERBOSE,		&io_verbose,		0},
	 {"ica_lock",	ICA_VERBOSE,		&io_verbose,		0},
	 {"diskbios",	DISKBIOS_VERBOSE,	&io_verbose,		0},
	 {"ega_ports",	EGA_PORTS_VERBOSE,	&io_verbose,		0},
	 {"ega_write",	EGA_WRITE_VERBOSE,	&io_verbose,		0},
	 {"ega_read",	EGA_READ_VERBOSE,	&io_verbose,		0},
	 {"ega_display",EGA_DISPLAY_VERBOSE,	&io_verbose,		0},
	 {"ega_routine",EGA_ROUTINE_ENTRY,	&io_verbose,		0},
	 {"flopbios",	FLOPBIOS_VERBOSE,	&io_verbose,		0},
	 {"at_kyb",	AT_KBD_VERBOSE,		&io_verbose,		0},
	 {"bios_kb",	BIOS_KB_VERBOSE,	&io_verbose,		0},
	 {"cmos",	CMOS_VERBOSE,		&io_verbose,		0},
	 {"hunter",	HUNTER_VERBOSE,		&io_verbose,		0},
	 {"pty",	PTY_VERBOSE,		&io_verbose,		0},
	 {"gen_drvr",	GEN_DRVR_VERBOSE,	&io_verbose,		0},
#if defined(HERC)
	 {"herc",	HERC_VERBOSE,		&io_verbose,		0},
#endif
	 {"ipc",	IPC_VERBOSE,		&io_verbose,		0},
	 {"lim",	LIM_VERBOSE,		&io_verbose,		0},
	 {"hfx",	HFX_VERBOSE,		&io_verbose,		0},
	 {"net",	NET_VERBOSE,		&io_verbose,		0},
	 {"map",	MAP_VERBOSE,		&sub_io_verbose,	0},
	 {"cursor",	CURSOR_VERBOSE,		&sub_io_verbose,	0},
	 {"nhfx",	NHFX_VERBOSE,		&sub_io_verbose,	0},
	 {"cdrom",	CDROM_VERBOSE,		&sub_io_verbose,	0},
	 {"cga_host",	CGA_HOST_VERBOSE,	&sub_io_verbose,	0},
	 {"ega_host",	EGA_HOST_VERBOSE,	&sub_io_verbose,	0},
	 {"q_event",	Q_EVENT_VERBOSE,	&sub_io_verbose,	0},
	 {"worm",	WORM_VERBOSE,		&sub_io_verbose,	0},
	 {"worm_vbose", WORM_VERY_VERBOSE,	&sub_io_verbose,	0},
	 {"herc_host",	HERC_HOST_VERBOSE,	&sub_io_verbose,	0},
	 {"gore",	GORE_VERBOSE,		&sub_io_verbose,	0},
	 {"gore_err",	GORE_ERR_VERBOSE,	&sub_io_verbose,	0},
	 {"glue",	GLUE_VERBOSE,		&sub_io_verbose,	0},
	 {"sas",	SAS_VERBOSE,		&sub_io_verbose,	0},
	 {"ios",	IOS_VERBOSE,		&sub_io_verbose,	0},
	 {"scsi",	SCSI_VERBOSE,		&sub_io_verbose,	0},
	 {"swin",	SWIN_VERBOSE,		&sub_io_verbose,	0},
	 {"mswdvr",	MSW_VERBOSE,		&sub_io_verbose,	0},
	 {"api",	API_VERBOSE,		&sub_io_verbose,	0},
	 {"hda_call",	CALL,			&disktraceinfo,		2},
	 {"hda_cmdinfo",CMDINFO,		&disktraceinfo,		0},
	 {"hda_xinfo",	XINFO,			&disktraceinfo,		0},
	 {"hda_xstat",	XSTAT,			&disktraceinfo,		0},
	 {"hda_pad",	PAD,			&disktraceinfo,		0},
	 {"hda_ioad",	IOAD,			&disktraceinfo,		0},
	 {"hda_portio",	PORTIO,			&disktraceinfo,		0},
	 {"hda_intrupt",INTRUPT,		&disktraceinfo,		0},
	 {"hda_hwxinfo",HWXINFO,		&disktraceinfo,		0},
	 {"hda_ddata",	DDATA,			&disktraceinfo,		0},
	 {"hda_physio",	PHYSIO,			&disktraceinfo,		0},
	 {"hda_dhw",	DHW,			&disktraceinfo,		0},
	 {"hda_dbios",	DBIOS,			&disktraceinfo,		0},
#ifdef WDCTRL_BOP
	 {"hda_wdctrl",	WDCTRL,			&disktraceinfo,		0},
#endif /* WDCTRL */
#ifdef HFX
	 {"hfx_input",	DEBUG_INPUT,		&severity,		3},
	 {"hfx_reg",	DEBUG_REG,		&severity,		0},
	 {"hfx_func",	DEBUG_FUNC,		&severity,		0},
	 {"hfx_host",	DEBUG_HOST,		&severity,		0},
	 {"hfx_init",	DEBUG_INIT,		&severity,		0}
#endif /* HFX */
	};

	static int n_flags = sizeof(trace_flags)/sizeof(struct trace_flag_t);
	int n, n_found, negate;
	IU32 mask;
	char *flag_name;

        UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
        UNUSED(len);
        UNUSED(stop);

	/*
	 * strip off command and get first flag name
	 */
	n_found = 0;
	(void) strtok (str, " \t");

	while (flag_name = strtok(NULL, " \t")) {
		/*
		 * Pick out symbolic flag name and see whther is is being set
		 * or reset.
	 	 */
		n_found += 1;
		negate = (flag_name[0] == '-');
		if (negate)
			flag_name += 1;

		/*
	 	 * Find flag and twiddle bits as appropriate.
	 	 */
		for (n = 0; n < n_flags; n++)
			if (!strcmp(flag_name, trace_flags[n].name)) {
				if (negate)
					*trace_flags[n].addr &=
						~trace_flags[n].mask;
				else
					*trace_flags[n].addr |=
						trace_flags[n].mask;
				break;
			}

		/*
	 	 * Handle special cases of all & none. -all is none and -none
		 * is all.
	 	 */
		if (n == n_flags) {
			mask = 1;
			if (!strcmp(flag_name, "none"))
				mask = 0;
			else if (!strcmp(flag_name, "all"))
				mask = ~0;
			else {
				printf ("Unknown trace flag: '%s'\n",
					flag_name);
				n_found -= 1;
			}

			if (mask != 1)		/* YUK ! */
#ifdef SFELLOW
				io_verbose    = sub_io_verbose
#else /* SFELLOW */
#ifdef HFX
				io_verbose    = sub_io_verbose =
				disktraceinfo = severity
#else /* HFX */
				io_verbose    = sub_io_verbose =
				disktraceinfo
#endif /* HFX */
#endif /* SFELLOW */
					      = negate ? ~mask : mask;
		}
	}

	/*
	 * Print current trace flags if no recognised flags passed in command.
	 * (or empty command line).
	 */
	if (n_found == 0) {
		int items = 0;
		for (n = 0; n < n_flags; n++) {
			if (trace_flags[n].title_id) {
			    printf ("%s", titles[trace_flags[n].title_id-1]);
			    items = 0;
			}
			if (!(items % 4))
				printf ("\n");
			printf ("%14s: %-2s", trace_flags[n].name,
				*trace_flags[n].addr & trace_flags[n].mask ?
				"ON" : "-");
			items += 1;
		}
		printf ("\n\n");
	}

	return(YODA_LOOP);
}

#ifdef CPU_40_STYLE
LOCAL IBOOL check_trace_environment IFN1(char *, cmd)
{
#ifdef SYNCH_TIMERS
	if (getenv("InitialJumpCounter") == NULL)
	{
		printf("Must have done \"setenv InitialJumpCounter ...\" to use %s\n", cmd);
		return FALSE;
	}
	if (getenv("DisableQuickTickRecal") == NULL)
	{
		printf("Must have done \"setenv DisableQuickTickRecal ...\" to use %s\n", cmd);
		return FALSE;
	}
	if (getenv("DEFAULT_QTIMER_RATE") == NULL)
	{
		printf("Must have done \"setenv DisableQuickTickRecal ...\" to use %s\n", cmd);
		return FALSE;
	}
	return TRUE;
#else	/* !SYNCH_TIMERS */

	printf("%s command is only available if the SoftPC has been built with -DSYNCH_TIMERS\n");
	return FALSE;

#endif	/* SYNCH_TIMERS */
}
#endif /* CPU_40_STYLE */

#ifdef CPU_40_STYLE
LOCAL void ct_initialise IPT0();

LOCAL YODA_COMMAND(do_ct)
{
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(str);
	UNUSED(com);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	if (!check_trace_environment("ct"))
		return(YODA_LOOP);

	if ((compress_stream = fopen("compress", "w")) != NULL){
		printf ("'compress' has been opened and will contain the compressed trace.\n");
	}else{
		printf ("Couldn't open 'compress' for output; no compressed trace will be generated.\n");
	}
	ct_initialise();
	if (cs != 0)
	{
		compress_break = strtol(str + 2, (char **)0, 10);
		printf("Will break after producing %ld. instructions\n", compress_break);
	}
#endif /* SFELLOW */
	return(YODA_LOOP);
}
#endif /* CPU_40_STYLE */

#ifdef CPU_40_STYLE
LOCAL YODA_COMMAND(do_ttOFF)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	compare_stream = (FILE *)0;
	compare_break = 0;
	compare_skip = 0;
	big_dump = 0;
	ct_delta_info = 0;
	printf( "Compare trace is OFF\n" );
	return(YODA_LOOP);
}
#endif /* CPU_40_STYLE */

#ifdef CPU_40_STYLE
LOCAL YODA_COMMAND(do_tt)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(len);
	UNUSED(stop);
	UNUSED(cs);
	UNUSED(ip);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	if (!check_trace_environment("tt"))
		return(YODA_LOOP);

	ct_initialise();

	if ((compare_stream = fopen("compare", "r")) != NULL)
	{
		printf ("'compare' has been opened to read the compressed trace.\n");
	}
	else
	{
		printf ("Couldn't open 'compare' for input; no compressed trace will be tested.\n");
	}
	if (ip != 0)
	{
		char *p = strchr(&str[2], ':');
		IUH n = 0;

		if (p)
			n = strtol(p + 1, (char **)0, 10);
		if (n)
		{
			compare_skip = n;
			printf("Will skip first  %ld. instructions\n", compare_skip);
		}
		else
			printf("Bad skip value in %s\n", str);
	}
	if (cs != 0)
	{
		compare_break = strtol(&str[2], (char **)0, 10);
	}
	if (compare_skip && (compare_break <= compare_skip))
		compare_break = compare_skip + 1;
	if (compare_break)
		printf("Will break after %ld. instructions\n", compare_break);

#endif /* SFELLOW */
	return(YODA_LOOP);
}
#endif /* CPU_40_STYLE */

#ifdef CPU_40_STYLE
LOCAL YODA_COMMAND(do_ctOFF)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (compress_stream)
		fclose(compress_stream);
	compress_stream = (FILE *)0;

	printf( "Compress trace is OFF\n" );
	return(YODA_LOOP);
}
#endif /* CPU_40_STYLE */

LOCAL YODA_COMMAND(do_nt)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	disk_trace = verbose = io_verbose = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_c)
{
	disable_timer = 0;

	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	/* Are you going fast, even though you could go slow and
	 * you seem to need to go slow?
	 */
	if (env_check != 2 && slow_needed && fast) {
		fputs(slow_reason, stdout);
		return go_slow();
	}
	/* otherwise we assume that you know what you are doing... */

	return(YODA_RETURN);
}

LOCAL YODA_COMMAND(do_bi)
{
	UNUSED(str);
	UNUSED(com);

	if (len == YODA_LEN_UNSPECIFIED)
		len = 1;
	set_inst_break((IU16)cs, ip, (len > 0) ? len : 1, stop, 0);
	(void)go_slow();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_br)
{
	char regstr[20], *str2;
	long minv,maxv;

	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	strtok(str," \t");	/* get rid of command */
	strcpy(regstr,strtok(NULL," \t")); /* get register name */
	minv = strtol(strtok(NULL," \t"),NULL,16); /* get min value */
	str2 = strtok(NULL," \t"); /* get max value (or null if absent) */
	if (str2 ==NULL)
		maxv = minv;
	else
		maxv = strtol(str2,NULL,16);
	set_reg_break(regstr, (IU32)minv, (IU32)maxv);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cr)
{
	char handle[20], *strp;
	
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	strtok(str," \t"); /* get rid of command */
	strp = strtok(NULL," \t");
	if (strp == NULL)
		strcpy(handle,"all");
	else
		strcpy(handle, strp);
	clear_reg_break(handle);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pr)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	print_reg_break();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_bint)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	int_breakpoint = 1;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cint)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	int_breakpoint = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pi)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	print_inst_break();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_bw)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(stop);

	set_data_break_words((LIN_ADDR)cs, ip, len );
	(void)go_slow();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_bh)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);

	set_host_address_break((LIN_ADDR)cs, len, stop);
	(void)go_slow();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ph)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	print_host_address_breaks();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pw)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	print_data_break_words();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_bo)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(stop);

	set_opcode_break(cs, len); /* for len read stop */
	(void)go_slow();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_vmm_call)
{
	struct VMM_services *vmm_ptr;
	char service_name[100], *p;
	long stop_code;
	long service_number;

	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(stop);

	sscanf(str, "%s %100s %l", com, service_name, &stop_code);

	if (service_name[0] == '?')
	{
		for (vmm_ptr = VMM_services; vmm_ptr->name; vmm_ptr++)
		{
			fprintf(trace_file, "VMM Call %s, index %d.\n",
				vmm_ptr->name, vmm_ptr->value);
		}
		return (YODA_LOOP);
	}

	service_number = strtol(service_name, &p, 0);
	if (service_name == p)
	{
		/* Name supplied, find the number */
		service_number = -1;
		for (vmm_ptr = VMM_services; vmm_ptr->name; vmm_ptr++)
		{
			if (strcmp(service_name, vmm_ptr->name) == 0)
				break;
		}
		if (vmm_ptr->name)
			service_number = vmm_ptr->value;
	}
	else
	{
		/* Number supplied, find the name */
		for (vmm_ptr = VMM_services; vmm_ptr->name; vmm_ptr++)
		{
			if (vmm_ptr->value == service_number)
			{
				strcpy(service_name, vmm_ptr->name);
				break;
			}
		}
	}
	if (service_number < 0)
	{
		printf("Unknown VMM Call service \"%s\"\n", service_name);
	}
	else
	{
		if (service_number >= 0x100)
			set_opcode_break(0xCD200000 | (service_number & 0xffff), stop_code);
		else
			set_opcode_break(0xCD2000 | service_number, stop_code);
		printf("Break on VMM Call service \"%s\"\n", service_name);
		(void)go_slow();
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_btf)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	/*
	** break on TF=1.
	*/
	tf_break_enabled = 1;
	printf( "break on TF=1 enabled.\n");
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ptf)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	printf( "break on TF=1 %sabled.\n", (tf_break_enabled ? "en" : "dis"));
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ctf)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	tf_break_enabled = 0;
	printf( "break on TF=1 disabled.\n");
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_bintx)
{
	long temp1, temp2;
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(com);
	UNUSED(len);
	UNUSED(stop);

	/*
	** break on specified interrupt with specified AH value.
	*/
	sscanf(str,"%*s %lx %lx", &temp1, &temp2);
	printf( "int=%lx AH=%lx\n", temp1, temp2 );
	set_int_break( (IU8)temp1, (IU8)temp2 );
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pintx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	print_int_break();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cintx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	int_break_count = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_bse)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	bse_seg = cs;
	last_seg = getCS();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cse)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	bse_seg = -1;
	last_seg = -1;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pse)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (bse_seg != -1){
		printf ("Break on entry to segment 0x%04x.\n", bse_seg);
	}else{
		printf ("Break on segment entry not active.\n");
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_b286_1)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	/*
	** Break on 80286 specific opcodes.
	*/
	b286_1 = 1;
	b286_1_stop = cs;
	if( b286_1_stop )
		printf( "BREAK " );
	else
		printf( "TRACE " );
	printf( "enabled upon 80286 instructions that do not exist on 8088.\n" );
	set_opcode_break( 0x60 , 1); /* push all */
	set_opcode_break( 0x61 , 1); /* pop all */
	set_opcode_break( 0x62 , 1); /* bound */
	set_opcode_break( 0x63 , 1); /* arpl */
	set_opcode_break( 0x64 , 1); /* illegal */
	set_opcode_break( 0x65 , 1); /* illegal */
	set_opcode_break( 0x66 , 1); /* illegal */
	set_opcode_break( 0x67 , 1); /* illegal */
	set_opcode_break( 0x68 , 1); /* push imm w */
	set_opcode_break( 0x69 , 1); /* imul imm w */
	set_opcode_break( 0x6a , 1); /* push imm b */
	set_opcode_break( 0x6b , 1); /* imul imm b */
	set_opcode_break( 0x6c , 1); /* ins b */
	set_opcode_break( 0x6d , 1); /* ins w */
	set_opcode_break( 0x6e , 1); /* outs b*/
	set_opcode_break( 0x6f , 1); /* outs w */
	set_opcode_break( 0xc0 , 1); /* shift imm b */
	set_opcode_break( 0xc1 , 1); /* shift imm w */
	set_opcode_break( 0xc8 , 1); /* enter */
	set_opcode_break( 0xc9 , 1); /* leave */
	set_opcode_break( 0x0f , 1); /* protected mode prefix */
	set_opcode_break( 0xf36c , 1); /* rep prefix for ins and outs */
	set_opcode_break( 0xf36d , 1); /* rep prefix for ins and outs */
	set_opcode_break( 0xf36e , 1); /* rep prefix for ins and outs */
	set_opcode_break( 0xf36f , 1); /* rep prefix for ins and outs */
	set_opcode_break( 0x54 , 1); /* push sp, should not really be in this section but is rarely used */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_b286_2)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	b286_2 = 1;
	b286_2_stop = cs;
	if( b286_2_stop )
		printf( "BREAK " );
	else
		printf( "TRACE " );
	printf( "enabled upon 80286 instructions that behave differently to 8088.\n" );
	printf( "PushF is not done because there are so many of them\n" );
	printf( "If you want to break on PushF do a bo 9c\n" );
	set_opcode_break( 0x54 , 1); /* push sp */
	set_opcode_break( 0xd2 , 1); /* shift / rotate */
	set_opcode_break( 0xd3 , 1); /* shift / rotate */
	set_opcode_break( 0xf6 , 1); /* idiv */
	set_opcode_break( 0xf7 , 1); /* idiv */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cNPX)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	/*
	** clear break/trace on 8087/80287 instructions.
	** The Numeric Coprocesseor Extention.
	*/
	bNPX = 0;
	bNPX_stop = 0;
	trace_type &= ~DUMP_NPX;
	printf( "BREAK/TRACE disabled for NPX instructions\n" );
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_tNPX)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	/*
	** trace on 8087/80287 instructions.
	** The Numeric Coprocesseor Extention.
	*/
	bNPX = 1;
	bNPX_stop = 0;
	trace_type |= DUMP_NPX;
	printf( "TRACE enabled for NPX instructions\n" );
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_bNPX)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	/*
	** break on 8087/80287 instructions.
	** The Numeric Coprocesseor Extention.
	*/
	bNPX = 1;
	bNPX_stop = 1;
	trace_type |= DUMP_NPX;
	printf( "BREAK enabled for NPX instructions\n" );
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_po)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);
	print_opcode_break();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ba)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	set_access_break(cs);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pa)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	print_access_break();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ci)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	inst_break_count = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ch)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	host_address_break_count = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cw)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	data_words_break_count = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_co)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	opcode_break_count = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ca)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	access_break_count = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_eric)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	inst_mix_count = 1;
	if (cs == 1)
	{
	    out_stream = fopen("inst_mix", "a");
	    disk_inst = 1;
	}
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_nic)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	inst_mix_count = 0;
	if (disk_inst == 1)
	{
	    print_inst_mix(0);
	    fclose(out_stream);
	    out_stream = stdout;
	    disk_inst = 0;
	    printf("Instruction mix results dumped to file\n");
	}
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_pic)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	print_inst_mix(cs);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cic)
{
	int temp;

	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	for(temp=0; temp<256; temp++)
	{
	    inst_mix[temp] = 0;
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ax)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setAX((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_eax)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setEAX((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_bx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setBX((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_ebx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setEBX((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_cx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setCX((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_ecx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setECX((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_if)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setIF((IU16)cs);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ip)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setIP((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_eip)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setEIP((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_dx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setDX((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_edx)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setEDX((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_si)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setSI((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_esi)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setESI((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_di)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setDI((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_edi)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setEDI((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_bp)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setBP((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_ebp)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setEBP((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_sp)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setSP((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_esp)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setESP((IU32)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_es)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setES((IU16)cs);
	return(YODA_LOOP);
}

#ifdef	SPC386
LOCAL YODA_COMMAND(do_fs)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setFS((IU16)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

#ifdef	SPC386
LOCAL YODA_COMMAND(do_gs)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setGS((IU16)cs);
	return(YODA_LOOP);
}
#endif	/* SPC386 */

LOCAL YODA_COMMAND(do_ss)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	printf("Powerful is the force of the ss command,\nFar too powerful for an untrained jeda such as you.\nUse the sseg command must you.\n");
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_sseg)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setSS((IU16)cs);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_ds)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setDS((IU16)cs);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cs)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	setCS((IU16)cs);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_byte)
{
	LIN_ADDR temp;

	UNUSED(str);
	UNUSED(com);
	UNUSED(stop);

	if (len == YODA_LEN_UNSPECIFIED) {
		printf ("Must specify <value>\n");
		return(YODA_LOOP);
	}
	temp = eff_addr( (IU16)cs, ip );
	sas_store (temp, len);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_word)
{
	LIN_ADDR temp;

	UNUSED(str);
	UNUSED(com);
	UNUSED(stop);

	if (len == YODA_LEN_UNSPECIFIED) {
		printf ("Must specify <value>\n");
		return(YODA_LOOP);
	}
	temp = eff_addr( (IU16)cs, ip );
	sas_store (temp, len & 0xff);
	sas_store (temp+1, (len >> 8) & 0xff);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_s)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	disable_bkpt = 1;
	if (cs == 0)
	    step_count = 1;
	else
	    step_count = cs;
	disable_timer = 0;

	return(go_slow());
}

#ifdef	CPU_40_STYLE
GLOBAL IBOOL effective_lin_addr IFN5(IBOOL, pe,
			   IBOOL, vm,
			   IU16, seg,
			   IU32, off,
			   LIN_ADDR *, linaddr_p)
{
	LIN_ADDR descr_addr;
	DESCR entry;

	if (!pe || vm) {
		*linaddr_p = ((LIN_ADDR)seg << 4) + off;
		return TRUE;
	} else {
#if defined(SWIN_CPU_OPTS) || defined(CPU_40_STYLE)
		LIN_ADDR base;

		if (Cpu_find_dcache_entry( seg, &base ))
		{
			/* Cache Hit!! */
			*linaddr_p = base + off;
			return TRUE;
		}
#endif /* SWIN_CPU_OPTS or CPU_40_STYLE*/

		if ( !selector_outside_table(seg, &descr_addr) ) {
			read_descriptor(descr_addr, &entry);
			*linaddr_p = entry.base + off;
			return TRUE;
		}
      	}
	return FALSE;
}


LOCAL IS32 read_from_la IFN1(LIN_ADDR, addr)
{
	return (IS32)Sas.Sas_hw_at(addr);
}

LOCAL void yoda_dasm IFN5(IBOOL, code_size,
			  IBOOL, pe_not_vm,
			  char *, buff,
			  IU16, cs,
			  LIN_ADDR, eip)
{
	LIN_ADDR la;
	char *fmt, *newline;

	if ( eip & 0xffff0000 )
	{
		fmt = "%04x:%08x ";
		newline = "\n              ";
	}
	else
	{
		fmt = "%04x:%04x ";
		newline = "\n          ";
	}
	if (effective_lin_addr( pe_not_vm, FALSE, cs, eip, &la))
	{
		(void)dasm_internal(buff,
			    cs,
			    eip,
			    code_size,
			    la,
			    read_from_la,
			    fmt,
			    newline);
	}
	else
	{
		sprintf(buff, fmt, cs, eip);
		strcat(buff, "<<Unable to decode CS:EIP>>\n");
	}
}

LOCAL void
print_pla IFN3(IU16, cs, LIN_ADDR, ip, enum pla_type, what)
{
	char buff[256];

	switch (what)
	{
	case pla_type_empty:
		break;
#ifdef	CPU_40_STYLE
	case pla_type_rm_code:
		yoda_dasm(SIXTEEN_BIT, FALSE, buff, cs, ip);
		fprintf (trace_file, "%s", buff);
		break;
	case pla_type_pm_small_code:
		yoda_dasm(SIXTEEN_BIT, TRUE, buff, cs, ip);
		fprintf (trace_file, "%s", buff);
		break;
	case pla_type_pm_big_code:
		yoda_dasm(THIRTY_TWO_BIT, TRUE, buff, cs, ip);
		fprintf (trace_file, "%s", buff);
		break;
#else	/* CPU_40_STYLE */
	case pla_type_code:
		(void)dasm(buff,
			   (word)cs,
			   ip,
			   CsIsBig(cs) ? THIRTY_TWO_BIT: SIXTEEN_BIT);
		fprintf (trace_file, "%s", buff);
		break;
#endif	/* CPU_40_STYLE */
	case pla_type_bop_done:
		fprintf(trace_file, "---- %16s ---- BOP %02x completed\n", "", ip);
		break;
	case pla_type_simulate:
		fprintf(trace_file, "---- %16s ---- SIMULATE   level %d\n", "", ip);
		break;
	case pla_type_unsimulate:
		fprintf(trace_file, "---- %16s ---- UNSIMULATE level %d\n", "", ip);
		break;
	case pla_type_intack:
		fprintf(trace_file, "---- %16s ---- INTACK line %d\n", "", ip);
		break;
	case pla_type_pig_force:
		fprintf(trace_file, "---- %16s ---- PIG FORCED\n", "");
		break;
	case pla_type_nano_enter:
		fprintf(trace_file, "---- %16s ---- Entering NANO\n", "");
		break;
	case pla_type_nano_leave:
		fprintf(trace_file, "---- %16s ---- Leaving  NANO\n", "");
		break;
	default:
		fprintf(trace_file,
			"%04x:%08x *** Bad pla type %d\n",
			cs, ip, what);
		break;
	}
}
#else /* CPU_40_STYLE */
LOCAL void
print_pla IFN2(IU16, cs, LIN_ADDR, ip)
{
	fprintf(trace_file, "Last address = %04x:%04x\n", cs, ip);
}
#endif /* CPU_40_STYLE */

LOCAL YODA_COMMAND(do_pla)
{
	LIN_ADDR	i;
	LIN_ADDR	pla_length;

	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (cs)
		pla_length = (LIN_ADDR)cs;
	else
		pla_length = 100;	/* default */

	if (pla_length > PLA_SIZE)
		pla_length = PLA_SIZE;

	/* Print the end of the buffer if necessary. */
	for (i = PLA_SIZE - (pla_length - pla_ptr); i < PLA_SIZE; i++)
#ifdef	CPU_40_STYLE
		print_pla(last_cs[i], last_ip[i], last_type[i]);
#else
		print_pla(last_cs[i], last_ip[i]);
#endif

	/* Print the start of the buffer. */
	if (pla_length > pla_ptr)
		i = 0;
	else
		i = pla_ptr - pla_length;

	for ( ; i < pla_ptr; i++)
#ifdef	CPU_40_STYLE
		print_pla(last_cs[i], last_ip[i], last_type[i]);
#else
		print_pla(last_cs[i], last_ip[i]);
#endif

	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cgat)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	cga_test();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(old_times_sake)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (chewy) {
		printf("Remember --- you must FEEL the force...\n");
	}
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_fast)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (!fast) {
	    printf("Switching to Fast YODA...\n");
	}
	yint = 0; fast = 1; do_condition_checks = 0;
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_slow)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	(void)go_slow();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_q)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);

#ifdef SFELLOW
	printf("Welcome to the Hotel California.\n");
	printf("You can check out any time you like, but you can never leave...\n");
#else /* SFELLOW */
	if (*com == 'Q') {
		terminate();	/* no saving throw - requested by Wayne */
	} else {
		stop = yoda_confirm("Are you sure that you want to quit? ");
		if (stop) {
			if (chewy) {
				printf("\nMind what you have learned....\n");
				printf("Serve you it can !!!\n");
				printf("MAY THE FORCE BE WITH YOU\n\n");
				terminate();
			}
			terminate();
		}
	}
#endif /* SFELLOW */
	return(YODA_LOOP);
}


LOCAL YODA_COMMAND(do_bt)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	/* back trace set up and dump */
	do_back_trace();
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_idle)
{
#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	char tempstr1[10],tempstr2[10];

	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	sscanf(str,"%s %s",tempstr1,tempstr2);
	/* enable/disable idle detect */
	if ((strcmp(tempstr2,"ON")==0) || (strcmp(tempstr2,"on")==0))
	{
		idle_ctl(1);
		return(YODA_LOOP);
	}

	if ((strcmp(tempstr2,"OFF")==0) || (strcmp(tempstr2,"off")==0))
	{
		idle_ctl(0);
		return(YODA_LOOP);
	}

	printf("unrecognised string '%s'\n",tempstr2);
#endif /* SFELLOW */
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cdebug)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	com_debug();
#endif /* SFELLOW */
	return (YODA_LOOP);
}

LOCAL void do_screen_refresh IFN0()
{
#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
	extern host_timer_event();

	host_mark_screen_refresh();
	host_flush_screen();

	host_timer_event();
#endif /* SFELLOW */
}

YODA_CMD_RETURN do_rfrsh IFN6(char *, str, char *, com, IS32, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	do_screen_refresh();
	refresh_screen = !refresh_screen;
	return (YODA_LOOP);
}

#ifdef	EGA_DUMP

/*
 * add check point to ega dump file so that different activities can be
 * delimited
 */

LOCAL	int	do_dumpcp IFN0()
{
	dump_add_checkpoint();
	return(YODA_LOOP);
}
#endif	/* EGA_DUMP */

LOCAL YODA_COMMAND(do_chewy)
{
	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	chewy = (chewy? 0 : 1);
	return(YODA_LOOP);
}

#ifndef GISP_CPU
#ifdef A3CPU
LOCAL YODA_COMMAND(do_3c)
{
	extern void	Mgr_yoda();

	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	Mgr_yoda();
	return(YODA_LOOP);
}
#endif
#endif /* GISP_CPU */

#if	defined(CPU_40_STYLE) && !defined(CCPU)
LOCAL YODA_COMMAND(do_4c)
{
	extern void	FmDebug IPT1(IUH, hook);

	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	FmDebug(0);
	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_imdst)
{
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

#ifdef SFELLOW

	UNUSED(cs);
	printf(SfNotImp);

#else /* SFELLOW */

	IntelMsgDest = cs & 3;
	printf("Intel messages to trace output %s\n", IntelMsgDest & IM_DST_TRACE?"ON":"OFF");
	printf("Intel messages to ring buffer %s\n", IntelMsgDest & IM_DST_RING?"ON":"OFF");

#endif /* SFELLOW */

	return(YODA_LOOP);
}
#endif /* CPU_40_STYLE && !CCPU */

#ifdef PIG
LOCAL YODA_COMMAND(do_pig)
{
	extern void pig_yoda();

	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	pig_yoda();
	return(YODA_LOOP);
}
#endif

#ifdef SYNCH_TIMERS
LOCAL YODA_COMMAND(do_qtrate)
{
	extern IU32 Q_timer_restart_val;
	extern IU32 Q_timer_microsecs;
	extern void IdealTimeInit();
	UNUSED(str);
	UNUSED(com);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	if (cs == 0)
	{
		printf("quick timer rate is 0x%x (%d)\n", Q_timer_restart_val, Q_timer_restart_val);
	}
	else
	{
		printf("setting quick timer rate to 0x%x (%d)\n", cs, cs);
		Q_timer_restart_val = cs;
		Q_timer_microsecs = cs;
		IdealTimeInit();
	}
	return(YODA_LOOP);
}
#endif	/* SYNCH_TIMERS */

#ifdef PROFILE
LOCAL YODA_COMMAND(doDumpProfiling)
{
	extern void GenerateAllProfileInfo();

	UNUSED(str);
	UNUSED(com);
	UNUSED(cs);
	UNUSED(ip);
	UNUSED(len);
	UNUSED(stop);

	GenerateAllProfileInfo(trace_file);
	return(YODA_LOOP);
}
#endif	/* PROFILE */

#ifdef CPU_40_STYLE

#define N_DATA_BREAKPOINTS	4

struct {
	IBOOL	active;
	IBOOL	write;
	IU8	dataSz;
	IU32	linAddr;
} dataBreakpoint[N_DATA_BREAKPOINTS];

IU32 dataSzLut[] = {0x0,0x0,0x4,0x0,0xC};
char *sizeString[] = {"BAD0", "byte", "word", "BAD3", "dbl."};

VOID
printDataBreakPoints IFN1 (
	IU32,	hitMask
)
{
	IU32	i;
	IBOOL	doneOne = FALSE;

	for (i=0; i<N_DATA_BREAKPOINTS; i++)
	{
		if (dataBreakpoint[i].active)
		{
			if (!doneOne)
			{
				fprintf (trace_file, "#   Access  LinAddr\n");
				fprintf (trace_file, "-------------------\n");
				doneOne = TRUE;
			}
			fprintf (trace_file, "%d:  %s %s 0x%08x  %s\n", i,
				dataBreakpoint[i].write?"WT":"RW",
				sizeString[dataBreakpoint[i].dataSz],
				dataBreakpoint[i].linAddr,
				(hitMask&(1<<i))?"<====TRIGGERED":"");
		}
	}
	if (doneOne)
	{
		fprintf (trace_file, "--------------------\n");
	}else{
		fprintf (trace_file, "No Data Breakpoints Active.\n");
	}
}

/*
 * data_debug_exception - this function is called by the EDL CPU when a
 * data debug exception goes off and the snaffleDataDebugExcpn flag is set
 * indicating that yoda is driving the debug registers.
 */
VOID
data_debug_exception IFN0()
{
	fprintf (trace_file, "data_debug_exception occurred... debug status reg = 0x%08x\n", getDREG6());

	printDataBreakPoints (getDREG6());

	moveToDebugRegister (6, getDREG6()&(~0xF));

	force_yoda();
}

VOID
add_debug_breakpoint IFN3 (
	IBOOL,		write,
	IU8,		dataSz,
	IU32,		linAddr
)
{
	IU32	i, debugControl;

	for (i=0; i<N_DATA_BREAKPOINTS; i++)
	{
		if (!dataBreakpoint[i].active)
		{
			dataBreakpoint[i].active  = TRUE;
			dataBreakpoint[i].write   = write;
			dataBreakpoint[i].dataSz  = dataSz;
			dataBreakpoint[i].linAddr = linAddr;

			moveToDebugRegister (i, linAddr);

			debugControl = getDREG7();

			debugControl &= ~((0xF << ((4*i) + 16)) | (0x3 << (2*i)));

			debugControl |= (0x2 << (2*i));

			debugControl |= (((dataSzLut[dataSz])|(write?0x1:0x3)) << ((4*i) + 16));

			moveToDebugRegister (7, debugControl);
			setSnaffleDataDebugExcpn (TRUE);

			return;
		}
	}

	fprintf (stderr, "Only %d data breakpoints available... sorry!\n", N_DATA_BREAKPOINTS);
}

LOCAL YODA_COMMAND(do_pdb)
{
	UNUSED(com); UNUSED(str); UNUSED(cs); UNUSED(ip); UNUSED(len); UNUSED(stop);

	printDataBreakPoints (0);

	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_cdb)
{
	IU32 i;
	IBOOL stillActive = FALSE;

	UNUSED(com); UNUSED(str);  UNUSED(ip); UNUSED(len); UNUSED(stop);

	dataBreakpoint[cs].active = FALSE;

	for (i=0; i<N_DATA_BREAKPOINTS; i++)
	{
		stillActive |= dataBreakpoint[i].active;
	}

	setSnaffleDataDebugExcpn (stillActive);

	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_blrb)
{
	UNUSED(com); UNUSED(str); UNUSED(ip); UNUSED(len); UNUSED(stop);

	add_debug_breakpoint (FALSE, 1, cs);

	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_blrw)
{
	UNUSED(com); UNUSED(str); UNUSED(ip); UNUSED(len); UNUSED(stop);

	add_debug_breakpoint (FALSE, 2, cs);

	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_blrd)
{
	UNUSED(com); UNUSED(str); UNUSED(ip); UNUSED(len); UNUSED(stop);

	add_debug_breakpoint (FALSE, 4, cs);

	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_blwb)
{
	UNUSED(com); UNUSED(str); UNUSED(ip); UNUSED(len); UNUSED(stop);

	add_debug_breakpoint (TRUE, 1, cs);

	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_blww)
{
	UNUSED(com); UNUSED(str); UNUSED(ip); UNUSED(len); UNUSED(stop);

	add_debug_breakpoint (TRUE, 2, cs);

	return(YODA_LOOP);
}

LOCAL YODA_COMMAND(do_blwd)
{
	UNUSED(com); UNUSED(str); UNUSED(ip); UNUSED(len); UNUSED(stop);

	add_debug_breakpoint (TRUE, 4, cs);

	return(YODA_LOOP);
}

#endif /* CPU_40_STYLE */

/*
 *	YODA COMMAND TABLE
 *	==================
 */

static struct
{
	char *name;
	YODA_CMD_RETURN (*function) IPT6(char *, str, char *, com, IS32, cs,
				LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop);
	IBOOL decode_iaddr;
	char *args;
	char *comment;
} yoda_command[] =
{
#ifdef MUST_BLOCK_TIMERS
{ "blt", 	do_blt, 	FALSE, NULL, "Block the timer signal" },
{ "ubt", 	do_ubt, 	FALSE, NULL, "Unblock the timer signal" },
#endif /* MUST_BLOCK_TIMERS */

#ifdef BSD4_2
{ "bs", 	do_bs, 		FALSE, "<signo>", "Block signal <signo>" },
{ "us", 	do_us, 		FALSE, "<signo>", "Unblock signal <signo>" },
#endif /* BSD4_2 */

{ "tf", 	do_tf, 		FALSE, "<filename>", "Re-direct trace output" },
{ "read", 	do_read, 	FALSE, "<filename>", "Take commands from file" },
{ "toff", 	do_toff, 	FALSE, NULL, "Disable HW timer interrupts (may be turned on by application)" },
{ "ton", 	do_ton, 	FALSE, NULL, "Enable HW timer interrupts" },
{ "toff2", 	do_toff2, 	FALSE, NULL, "Stop HW timer interrupts" },
{ "ton2", 	do_ton2, 	FALSE, NULL, "Restart HW timer interrupts" },
{ "?", 		do_query, 	FALSE, NULL, "Where am I?" },
{ "u", 		do_u, 		TRUE,  "<len>", "Unassemble memory" },

#ifdef	DELTA
{ "del", 	do_del, 	FALSE, NULL, "Go to delta debugger" },
#endif /* DELTA */

{ "j", 		do_j, 		FALSE, NULL, "Jump over call or int" },
{ "ctnpx", 	do_ctnpx, 	FALSE, NULL, "Compress trace npx" },
{ "r", 		do_r, 		FALSE, NULL, "Print 286 registers" },

#ifdef	NPX
{ "287r", 	do_287r, 	FALSE, NULL, "Print 287 registers" },
#endif	/* NPX */

{ "inb", 	do_inb,		FALSE, "<port>", "display the contents of a port" },
{ "outb", 	do_outb, 	FALSE, "<port> <val>", "change the contents of a port" },
{ "inw", 	do_inw,		FALSE, "<port>", "display the contents of a 16 bit port" },
{ "outw", 	do_outw, 	FALSE, "<port> <val>", "change the contents of a 16 bit port" },
#ifdef SPC386
{ "ind", 	do_ind,		FALSE, "<port>", "display the contents of a 32 bit port" },
{ "outd", 	do_outd, 	FALSE, "<port> <val>", "change the contents of a 32 bit port" },
#endif	/* SPC386 */
{ "i", 		do_inb,		FALSE, "<port>", "alias for inb" },
{ "o", 		do_outb, 	FALSE, "<port> <val>", "alias for outb" },
{ "luke", 	do_luke, 	FALSE, NULL, "Switch between fast/slow yoda" },
{ "fff",	do_fff,		FALSE, NULL, "Find, and fix fault"},

#if !defined(REAL_VGA) && !defined(SFELLOW)
{ "time_Display", do_time_Display,
				FALSE, "<count>", "Time current screen refresh" },

#ifdef	EGG
{ "dump_Display", do_dump_Display,
				FALSE, NULL, "Dump general display variables" },
{ "dump_EGA_GRAPH", do_dump_EGA_GRAPH,
				FALSE, NULL, "Dump EGA specific display variables" },
{ "dump_EGA_CPU", do_dump_EGA_CPU,
				FALSE, NULL, "Dump EGA/CPU interface variables" },
{ "dump_planes", do_dump_planes,
				FALSE, NULL, "Dump EGA planes" },
{ "read_planes", do_read_planes,
				FALSE, NULL, "Read EGA planes" },
#endif /* EGG */
#endif /* !REAL_VGA && !SFELLOW */

{ "db", 	do_db, 		TRUE,  "<len>", "Display bytes" },
{ "dw", 	do_dw, 		TRUE,  "<len>", "Display words" },
#ifdef SPC386
{ "dd", 	do_dd, 		TRUE,  "<len>", "Display dwords" },
#endif	/* SPC386 */
{ "da", 	do_da, 		TRUE,  "<len>", "Display in hex/ascii" },
{ "t", 		do_t, 		FALSE, NULL, "Trace all CPU instructions" },
{ "it", 	do_it, 		FALSE, "<val>", "Set trace bits (use trace!)" },
{ "sit", 	do_sit, 	FALSE, "<val>", "Set subsidiary trace bits (use trace!)" },
{ "trace",	do_trace, 	FALSE, "[-]<flag_name> [...]", "Set/reset trace flag(s)" },
{ "dt", 	do_dt, 		FALSE, NULL, "Set disk verbose tracing" },
#ifdef CPU_40_STYLE
{ "ct",		do_ct, 		FALSE, "<type> <del>", "Create compressed trace file" },
{ "ttOFF", 	do_ttOFF, 	FALSE, NULL, "Switch compare trace off" },
{ "tt", 	do_tt, 		FALSE, NULL, "test  Compressed trace file" },
{ "ctOFF", 	do_ctOFF, 	FALSE, NULL, "Switch compress trace off" },
#endif /* CPU_40_STYLE */
{ "nt", 	do_nt, 		FALSE, NULL, "Disable all tracing" },
{ "c", 		do_c, 		FALSE, NULL, "Continue execution" },
{ "bint", 	do_bint, 	FALSE, NULL, "Break on interrupt" },
{ "cint", 	do_cint, 	FALSE, NULL, "Clear break on interrupt" },
{ "bintx", 	do_bintx, 	FALSE, "<int> <ah>", "Break on interrupt <int> when ah = <ah>" },
{ "pintx", 	do_pintx, 	FALSE, NULL, "print intx breakpoints" },
{ "cintx", 	do_cintx, 	FALSE, NULL, "clear intx breakpoints" },
{ "br", 	do_br, 		FALSE, "<reg> <min> <max>", "Break on register value" },
{ "cr", 	do_cr, 		FALSE, "<handle>|'all'", "Clear register value breakpoint(s)" },
{ "pr", 	do_pr, 		FALSE, NULL, "Print register value breakpoints" },
{ "bse", 	do_bse, 	FALSE, NULL, "Break on segment entry" },
{ "cse", 	do_cse, 	FALSE, NULL, "Clear segment entry breakpoints" },
{ "pse", 	do_pse, 	FALSE, NULL, "Print segment entry breakpoints" },
{ "btf", 	do_btf, 	FALSE, NULL, "Break on trap flag set" },
{ "ptf", 	do_ptf, 	FALSE, NULL, "Print trap flag breakpoint" },
{ "ctf", 	do_ctf, 	FALSE, NULL, "Clear trap flag breakpoint" },
{ "b286-1",	do_b286_1, 	FALSE, "<type>", "Break/trace on new 80286 opcodes" },
{ "b286-2",	do_b286_2, 	FALSE, "<type>", "Break/trace on other 80286 opcodes" },
{ "bNPX", 	do_bNPX, 	FALSE, NULL, "Break on NPX opcodes, 8087/80287" },
{ "tNPX", 	do_tNPX, 	FALSE, NULL, "Trace on NPX opcodes, 8087/80287" },
{ "cNPX", 	do_cNPX, 	FALSE, NULL, "Clear break/trace NPX opcodes, 8087/80287" },
{ "ba", 	do_ba, 		FALSE, "<port>", "Break on port access" },
{ "bh", 	do_bh, 		FALSE, "<hostadd> <len> <type>", "Break on host address change" },
{ "bi", 	do_bi, 		TRUE,  "<len> <type>", "Break at address/instruction" },
{ "bo", 	do_bo, 		FALSE, "<opcode> <type>", "Break on opcode of 8, 16, 24, or 32 bits" },
{ "vmm_call", 	do_vmm_call, 	FALSE, "<service> <stop>", "Break Windows VMM Call -- ? for service names" },
{ "bw", 	do_bw, 		FALSE, "<sysadd> <len> <type>", "Break on word change" },
{ "pa", 	do_pa, 		FALSE, NULL, "Print a breakpoints" },
{ "ph", 	do_ph, 		FALSE, NULL, "Print h breakpoints" },
{ "pi", 	do_pi, 		FALSE, NULL, "Print i breakpoints" },
{ "po", 	do_po, 		FALSE, NULL, "Print o breakpoints" },
{ "pw", 	do_pw, 		FALSE, NULL, "Print w breakpoints" },
{ "ca", 	do_ca, 		FALSE, NULL, "Clear a breakpoints" },
{ "ch", 	do_ch, 		FALSE, NULL, "Clear h breakpoints" },
{ "ci", 	do_ci, 		FALSE, NULL, "Clear i breakpoints" },
{ "co", 	do_co, 		FALSE, NULL, "Clear o breakpoints" },
{ "cw", 	do_cw, 		FALSE, NULL, "Clear w breakpoints" },
{ "eric", 	do_eric, 	FALSE, NULL, "Enable reduced instruction counting" },
{ "nic", 	do_nic, 	FALSE, NULL, "Disable instruction counting" },
{ "pic", 	do_pic, 	FALSE, NULL, "Print instruction mix" },
{ "cic", 	do_cic, 	FALSE, NULL, "" },
{ "ax", 	do_ax, 		FALSE, "<value>", "Set AX to <value>" },
{ "bx", 	do_bx, 		FALSE, "<value>", "Set BX to <value>" },
{ "cx", 	do_cx, 		FALSE, "<value>", "Set CX to <value>" },
{ "dx", 	do_dx, 		FALSE, "<value>", "Set DX to <value>" },
{ "si", 	do_si, 		FALSE, "<value>", "Set SI to <value>" },
{ "di", 	do_di, 		FALSE, "<value>", "Set DI to <value>" },
{ "bp", 	do_bp, 		FALSE, "<value>", "Set BP to <value>" },
{ "sp", 	do_sp, 		FALSE, "<value>", "Set SP to <value>" },
{ "if", 	do_if, 		FALSE, "<value>", "Set IF to <value>" },
{ "ip", 	do_ip, 		FALSE, "<value>", "Set IP to <value>" },
#ifdef	SPC386
{ "eax", 	do_eax,		FALSE, "<value>", "Set EAX to <value>" },
{ "ebx", 	do_ebx,		FALSE, "<value>", "Set EBX to <value>" },
{ "ecx", 	do_ecx,		FALSE, "<value>", "Set ECX to <value>" },
{ "edx", 	do_edx,		FALSE, "<value>", "Set EDX to <value>" },
{ "esi", 	do_esi,		FALSE, "<value>", "Set ESI to <value>" },
{ "edi", 	do_edi,		FALSE, "<value>", "Set EDI to <value>" },
{ "ebp", 	do_ebp,		FALSE, "<value>", "Set EBP to <value>" },
{ "esp", 	do_esp,		FALSE, "<value>", "Set ESP to <value>" },
{ "eip", 	do_eip,		FALSE, "<value>", "Set EIP to <value>" },
#endif	/* SPC386 */
{ "cs", 	do_cs, 		FALSE, "<value>", "Set CS to <value>" },
{ "ds", 	do_ds, 		FALSE, "<value>", "Set DS to <value>" },
{ "es", 	do_es, 		FALSE, "<value>", "Set ES to <value>" },
{ "ss", 	do_ss, 		FALSE, NULL, NULL },	/* backwards compatibility */
#ifdef	SPC386
{ "fs", 	do_fs, 		FALSE, "<value>", "Set FS to <value>" },
{ "gs", 	do_gs, 		FALSE, "<value>", "Set GS to <value>" },
#endif	/* SPC386 */
{ "sseg", 	do_sseg, 	FALSE, "<value>", "Set SS to value" },
{ "byte", 	do_byte, 	TRUE,  "<value>", "Set byte memory location to value" },
{ "word", 	do_word, 	TRUE,  "<value>", "Set word memory location to value" },
{ "s", 		do_s, 		FALSE, "<len>", "Single step <len> instructions" },
{ "pla", 	do_pla, 	FALSE, "<len>", "Print addresses of previous instructions" },
{ "cgat", 	do_cgat, 	FALSE, NULL, "CGA tester" },
{ "yint", 	old_times_sake, FALSE, NULL, "Enable pseudo-int driven yoda" },
{ "nyint", 	do_fast, 	FALSE, NULL, NULL },
{ "quit", 	do_q, 		FALSE, NULL, "Quit (with confirmation)" },
{ "q",		do_q, 		FALSE, NULL, NULL },
{ "Q",		do_q,		FALSE, NULL, "Quit (without confirmation)" },
{ "help",	do_h,		FALSE, NULL, "Help!" },
{ "h",		do_h,		FALSE, NULL, NULL},
{ "jeddi",	do_chewy,	FALSE, NULL, NULL},
{ "bt",		do_bt,		FALSE, NULL, "Back trace mode" },
{ "idle",	do_idle,	FALSE, "<ON|OFF>", "Turn idle detect on/off" },
{ "fast",	do_fast,	FALSE, NULL, "Fast yoda (no breakpoints)" },
{ "slow",	do_slow,	FALSE, NULL, "Slow yoda" },
{ "cd",		do_cdebug,	FALSE, NULL, "COM1 register debugger"},

#ifdef	EGA_DUMP
{ "dumpcp", 	do_dumpcp, 	FALSE, NULL, "Add check point to EGA dump trace" },
#endif	/* EGA_DUMP */

#ifdef GISP_CPU
{ "hgps",	do_hgps,	FALSE, NULL, "Print GISP CPU stats" },
{ "hgcs",	do_hgcs,	FALSE, NULL, "Clear GISP CPU stats" },
{ "vex",	do_vex,		FALSE, NULL, "Toggle verbose faults" },
{ "bex",	do_bex,		FALSE, NULL, "Toggle break on faults" },
#endif	/* GISP_CPU */

#ifdef SYNCH_TIMERS
{ "qtrate",	do_qtrate,	FALSE, "<rate>", "set quick timer rate" },
#endif
#ifdef A3CPU
#ifndef GISP_CPU
{ "d2", 	do_d2,		FALSE, NULL, "Force D2 interact" },
{ "dcs", 	do_dcs, 	FALSE, "<seg>", "Dump binary in code segment to 'csegbin'" },
{ "dfih", 	do_dfih, 	FALSE, "<fragnr>", "Dump fragment history to 'fih_nnnn'" },
{ "th",     do_d2threshold,	FALSE, "<lower> <upper>", "Set delta2 thresholds" },
#endif /* GISP_CPU */
#endif /* A3CPU */

#ifdef PM
{ "pm", 	do_pm,		FALSE, NULL, "Set protected mode" },
#ifdef	LIM
{ "zaplim", 	do_zaplim, 	FALSE, NULL, "Zap LIM" },
#endif	/* :IM */
{ "rm", 	do_rm, 		FALSE, NULL, "Set real mode" },
{ "pg", 	do_pg, 		FALSE, NULL, "Set paging mode 1 (enabled) or 0 (disabled)" },
{ "pgdt", 	do_pgdt,	FALSE, NULL, "Print global descriptor table" },
{ "pidt", 	do_pidt,	FALSE, NULL, "Print interrupt descriptor table" },
{ "ptr", 	do_ptr,		FALSE, NULL, "Print task register" },
{ "pldt", 	do_pldt,	FALSE, NULL, "Print local descriptor table reg." },
{ "par", 	do_par,		FALSE, NULL, "" },
{ "pseg", 	do_pseg,	FALSE, NULL, "Print segment registers" },
{ "pd", 	do_pd,		FALSE, "<phys-addr>:<num>", "Print descriptor(s)" },
{ "pdseg", 	do_pdseg,	FALSE, NULL, "Print descriptor of selector" },
{ "phys", 	do_phys,	TRUE,  NULL, "Print physical address" },
{ "dphys", 	do_dump_phys,	FALSE, "<phys-addr> <len>", "Dump from physical address" },
{ "spa", 	do_show_phys_addr,	FALSE, "<lin-addr>", "Show physical address from linear" },
{ "gla", 	do_guess_lin_phys,	FALSE, "<phys-addr>", "Guess linear address from physical" },
{ "gpte", 	do_guess_lin_pte,	FALSE, "<pte-addr>", "Guess linear address from pte address" },
{ "dpt", 	do_dump_page_table,	FALSE, "<phys-addr> <entry>", "Dump all or specific entry from Page Table" },
{ "rtc", 	do_rtc,		FALSE, NULL, "Re-initialise the rtc" },
{ "ica", 	do_ica,		FALSE, NULL, "Show status of ica" },
#endif
#ifdef CPU_40_STYLE
{ "blrb", 	do_blrb,		FALSE, NULL, "Break on linear read byte" },
{ "blrw", 	do_blrw,		FALSE, NULL, "Break on linear read word" },
{ "blrd", 	do_blrd,		FALSE, NULL, "Break on linear read double" },
{ "blwb", 	do_blwb,		FALSE, NULL, "Break on linear write byte" },
{ "blww", 	do_blww,		FALSE, NULL, "Break on linear write word" },
{ "blwd", 	do_blwd,		FALSE, NULL, "Break on linear write double" },
{ "pdb", 	do_pdb,			FALSE, NULL, "Print data breakpoints" },
{ "cdb", 	do_cdb,			FALSE, NULL, "Clear data breakpoint" },
#endif /* CPU_40_STYLE */

#if defined(CPU_40_STYLE) && !defined (SFELLOW) && !defined(NTVDM)
{ "vdd", 	do_vdd,		FALSE,	"0 or 1",	"Turn Windows VDD trapping off or on" },
{ "debug_vdd", 	do_debug_vdd,	FALSE,	"0 or 1",	"Turn Windows VDD debugging off or on" },
#endif /* CPU_40_STYLE && !SFELLOW && !NTVDM*/

{ "rfrsh", 	do_rfrsh,	FALSE, NULL, "Toggle Yoda screen refresh" },

#ifndef GISP_CPU
#ifdef A3CPU
{ "3c", 	do_3c,		FALSE, NULL, "3.0 CPU interface" },
#endif
#endif /* GISP_CPU */

#if	defined(CPU_40_STYLE) && !defined(CCPU)
{ "4c", 	do_4c,		FALSE, NULL, "4.0 CPU interface" },
{ "imdst",	do_imdst,	FALSE, "[0|1|2|3]",	"Direct Intel debug message output (trace=bit0, ring=bit1)" },
#endif /* CPU_40_STYLE && !CCPU */

#ifdef PIG
{ "pig",	do_pig,		FALSE, NULL, "Pig interface" },
#endif

#if	defined(GENERIC_NPX) && !defined(CPU_40_STYLE)
{ "NPXdisp",	do_NPXdisp, 	FALSE, "<len>", "Display last <len> NPX instructions" },
{ "NPXfreq",	do_NPXfreq,	FALSE, NULL, "Display frequency of NPX instructions" },
{ "resetNPXfreq", do_resetNPXfreq, FALSE, NULL, "Reset frequency of NPX instructions" },
#endif	/* GENERIC_NPX && !CPU_40_STYLE */

#ifdef MSWDVR_DEBUG
{ "mswdvr_debug", do_mswdvr_debug, FALSE, "<0|1|2|3>", "Set MSWDVR debug verbosity"},
#endif /* MSWDVR_DEBUG */

#ifdef GISP_SVGA
{ "noyoda",	doNoYoda,	FALSE, NULL, "Toggle force_yoda on/off" },
#endif		/* GISP_SVGA */
#ifdef PROFILE
{ "pinfo",	doDumpProfiling,FALSE, NULL, "Dump all profiling info collected" },
#endif	/* PROFILE */
{ "pmt",	do_pmt,		FALSE, NULL, "Print map of SAS memory types"}
};

LOCAL YODA_COMMAND(do_h)
{
  int i;
  char args[50];

  UNUSED(str);
  UNUSED(com);
  UNUSED(cs);
  UNUSED(ip);
  UNUSED(stop);
  UNUSED(len);

  if (chewy) printf("Master Yoda's commands are:\n\n");

  for(i = 0; i < sizeoftable(yoda_command); ) {
    args[0] = 0;
    if (yoda_command[i].decode_iaddr)
	strcpy (args, "<intel-addr> ");
    strcat (args, yoda_command[i].args ? yoda_command[i].args : "");
    printf("%14s %-20s - %s\n", yoda_command[i].name, args,
			yoda_command[i].comment?yoda_command[i].comment:"");
    if (++i%20 == 0)
	if (!yoda_confirm("-- continue? -- ")) return(YODA_LOOP);
  }

  host_yoda_help_extensions();

  printf("\nAll data input is treated as hex\n");
  printf("  <type> is the type of breakpoint : 1 - stop at, 0 - trace only.\n");
  printf("  <reg> is the symbol for a 16 bit register ie: ax, sp, etc ...\n");
  printf("  <intel-addr> examples: ffe, f000:45, ds:BX, si+8, BX+DI+1, es:[SI-2], etc ...\n\t& all combinations thereof.\n");
  return(YODA_LOOP);
}

#ifdef PCLABS_STATS
int stats_counter;
#endif

/*
 * Convert string to lowercase in-situ. We assume that tolower() doesn't
 * corrupt non-upper case characters (which is assumed elsewhere in the
 * base code.
 */
LOCAL void string_tolower IFN1 (char *, s)
{
	while (*s) {
		*s = host_tolower(*s);
		s++;
	}
}

/*
 * Decode the offset portion of an Intel address expression.
 */
LOCAL IBOOL decode_offset IFN3(char *, coffset, IU32 *, offset, IS32 *, seg)
{
	int n;
	IS32 const_offset;	/* constant hex offset		*/
	IS32 ireg_offset;	/* value of index reg offset	*/
	unsigned long iaddr16b;
	char sign, junk, morejunk;
	char cbase[50], ireg[2], *pbase = coffset;
	IBOOL retVal = FALSE;
	SAVED IBOOL cold = TRUE;

	/*
	 * Data required to decode segment offset register names and
	 * get default segment value.
	 */
	static struct DECODE_SEGOFFSET {
		char *reg_name;
		word (*get_offset_val) IPT0();
		word (*get_segreg_val) IPT0();
	}
	decode_segoffset[] =
	{
		{"bx", NULL, NULL},
		{"si", NULL, NULL},
		{"di", NULL, NULL},
		{"sp", NULL, NULL},
		{"bp", NULL, NULL},
		{"ip", NULL, NULL}
	};

#ifdef SPC386
	/*
	 * Note that there have to be the same number of extended
	 * register decodes as standard register decodes, or the search
	 * function will break!
	 */

	static struct DECODE_SEGOFFSET2 {
		char *reg_name;
		IU32 (*get_offset_val) IPT0();
		word (*get_segreg_val) IPT0();
	}
	decode_segoffset2[] =
	{
		{"ebx", NULL, NULL},
		{"esi", NULL, NULL},
		{"edi", NULL, NULL},
		{"esp", NULL, NULL},
		{"ebp", NULL, NULL},
		{"eip", NULL, NULL}
	};
#endif /* SPC386 */

	if( cold )
	{
#ifdef CCPU
		decode_segoffset[0].get_offset_val = c_getBX;
		decode_segoffset[0].get_segreg_val = c_getDS;
		decode_segoffset[1].get_offset_val = c_getSI;
		decode_segoffset[1].get_segreg_val = c_getDS;
		decode_segoffset[2].get_offset_val = c_getDI;
		decode_segoffset[2].get_segreg_val = c_getDS;
		decode_segoffset[3].get_offset_val = c_getSP;
		decode_segoffset[3].get_segreg_val = c_getSS;
		decode_segoffset[4].get_offset_val = c_getBP;
		decode_segoffset[4].get_segreg_val = c_getSS;
		decode_segoffset[5].get_offset_val = c_getIP;
		decode_segoffset[5].get_segreg_val = c_getCS;
#ifdef SPC386
		decode_segoffset2[0].get_offset_val = c_getEBX;
		decode_segoffset2[0].get_segreg_val = c_getDS;
		decode_segoffset2[1].get_offset_val = c_getESI;
		decode_segoffset2[1].get_segreg_val = c_getDS;
		decode_segoffset2[2].get_offset_val = c_getEDI;
		decode_segoffset2[2].get_segreg_val = c_getDS;
		decode_segoffset2[3].get_offset_val = c_getESP;
		decode_segoffset2[3].get_segreg_val = c_getSS;
		decode_segoffset2[4].get_offset_val = c_getEBP;
		decode_segoffset2[4].get_segreg_val = c_getSS;
		decode_segoffset2[5].get_offset_val = c_getEIP;
		decode_segoffset2[5].get_segreg_val = c_getCS;
#endif /* SPC386 */
#else  /* !CCPU */
#ifdef CPU_40_STYLE
		decode_segoffset[0].get_offset_val = Cpu.GetBX;
		decode_segoffset[0].get_segreg_val = Cpu.GetDS;
		decode_segoffset[1].get_offset_val = Cpu.GetSI;
		decode_segoffset[1].get_segreg_val = Cpu.GetDS;
		decode_segoffset[2].get_offset_val = Cpu.GetDI;
		decode_segoffset[2].get_segreg_val = Cpu.GetDS;
		decode_segoffset[3].get_offset_val = Cpu.GetSP;
		decode_segoffset[3].get_segreg_val = Cpu.GetSS;
		decode_segoffset[4].get_offset_val = Cpu.GetBP;
		decode_segoffset[4].get_segreg_val = Cpu.GetSS;
		decode_segoffset[5].get_offset_val = Cpu.GetIP;
		decode_segoffset[5].get_segreg_val = Cpu.GetCS;
		decode_segoffset2[0].get_offset_val = Cpu.GetEBX;
		decode_segoffset2[0].get_segreg_val = Cpu.GetDS;
		decode_segoffset2[1].get_offset_val = Cpu.GetESI;
		decode_segoffset2[1].get_segreg_val = Cpu.GetDS;
		decode_segoffset2[2].get_offset_val = Cpu.GetEDI;
		decode_segoffset2[2].get_segreg_val = Cpu.GetDS;
		decode_segoffset2[3].get_offset_val = Cpu.GetESP;
		decode_segoffset2[3].get_segreg_val = Cpu.GetSS;
		decode_segoffset2[4].get_offset_val = Cpu.GetEBP;
		decode_segoffset2[4].get_segreg_val = Cpu.GetSS;
		decode_segoffset2[5].get_offset_val = Cpu.GetEIP;
		decode_segoffset2[5].get_segreg_val = Cpu.GetCS;
#else  /* !CPU_40_STYLE */
		decode_segoffset[0].get_offset_val = getBX;
		decode_segoffset[0].get_segreg_val = getDS;
		decode_segoffset[1].get_offset_val = getSI;
		decode_segoffset[1].get_segreg_val = getDS;
		decode_segoffset[2].get_offset_val = getDI;
		decode_segoffset[2].get_segreg_val = getDS;
		decode_segoffset[3].get_offset_val = getSP;
		decode_segoffset[3].get_segreg_val = getSS;
		decode_segoffset[4].get_offset_val = getBP;
		decode_segoffset[4].get_segreg_val = getSS;
		decode_segoffset[5].get_offset_val = getIP;
		decode_segoffset[5].get_segreg_val = getCS;
#ifdef SPC386
		decode_segoffset2[0].get_offset_val = getEBX;
		decode_segoffset2[0].get_segreg_val = getDS;
		decode_segoffset2[1].get_offset_val = getESI;
		decode_segoffset2[1].get_segreg_val = getDS;
		decode_segoffset2[2].get_offset_val = getEDI;
		decode_segoffset2[2].get_segreg_val = getDS;
		decode_segoffset2[3].get_offset_val = getESP;
		decode_segoffset2[3].get_segreg_val = getSS;
		decode_segoffset2[4].get_offset_val = getEBP;
		decode_segoffset2[4].get_segreg_val = getSS;
		decode_segoffset2[5].get_offset_val = getEIP;
		decode_segoffset2[5].get_segreg_val = getCS;
#endif /* SPC386 */
#endif /* !CPU_40_STYLE */
#endif /* !CCPU */
		cold = FALSE;
	}

	/*
	 * Decode character string that represents offset into segment.
	 * This can either be numeric address, register name, and in
	 * either case with optional addition/subtraction of constant
	 * hex number or SI/DI register. Return -1 for invalid offset.
	 */

	*offset = *seg = -1;

	/*
	 * Throw away any [..] around the offset; this lets us cut/paste
	 * addresses from the disassember listing. Then convert to lower
	 * case for the same reason.
	 */
	if (sscanf(coffset, "[%[^]]%c%c", cbase, &junk, &morejunk) == 2)
		strcpy(coffset, cbase);

	string_tolower(coffset);

	/*
	 * Determine any additional constant value or register that is
	 * being added/subtracted to base of offset.
	 */

	const_offset = ireg_offset = 0;

	if (sscanf(coffset, "%[^+-]%c%lx%c", cbase, &sign,
					&const_offset, &junk) == 3) {
		pbase = cbase;
		if (sign == '-')
			const_offset = -const_offset;

	} else if (((n = sscanf(coffset, "%[^+]+%c%c%c%lx%c", cbase, &ireg[0],
				&ireg[1], &sign, &const_offset, &junk)) >= 3) &&
		   ((ireg[0] == 's') || (ireg[0] == 'd')) &&
		   (ireg[1] == 'i')) {
		/*
		 * We allow SI/DI to be added to any offset base. Note that
		 * this allows things like ip+di but theres no point in
		 * prohibiting naff addresses like this. We also allow things
		 * like bp+si+4 (yuk).
		 */
		if ((n == 3) || (n == 5)) {
			pbase = cbase;
			
			/*
			 * Get index register value ..
			 */
			if (ireg[0] == 'd')
				ireg_offset = getDI();
			if (ireg[0] == 's')
				ireg_offset = getSI();

			/*
			 * Get any additional constant if present; resetting
			 * pbase to coffset if the format is wrong effectively
			 * throws the expression out as invalid.
			 */
			if (n == 5) {
				if (sign == '-')
					const_offset = -const_offset;
				else if (sign != '+')
					pbase = coffset;
			}
		}
	}

	/*
	 * Decode the base of the offset.
	 */
	if (sscanf(pbase, "%lx%c", &iaddr16b, &junk) == 1) {
		/*
		 * Simple numeric offset, we use DS as the default
		 * segment register in this case.
		 */
#ifdef SPC386
		*offset = iaddr16b;
#else
		*offset = iaddr16b & 0xffff;
#endif
		*seg  = getDS();
		retVal = TRUE;

	} else {
		/*
		 * Should be symbolic register name; decode it.
		 */
		ISM8 n;
		for (n = 0; n < sizeof(decode_segoffset)/
				sizeof(struct DECODE_SEGOFFSET); n++) {
			if (!strcmp(pbase, decode_segoffset[n].reg_name)) {
				*offset = decode_segoffset[n].get_offset_val();
				*seg  = decode_segoffset[n].get_segreg_val();
				retVal = TRUE;
				break;
			}
#ifdef SPC386
			if (!strcmp(pbase, decode_segoffset2[n].reg_name)) {
				*offset = decode_segoffset2[n].get_offset_val();
				*seg  = decode_segoffset2[n].get_segreg_val();
				retVal = TRUE;
				break;
			}
#endif /* SPC386 */
		}
	}

	/*
	 * Add/subtract any constant supplied to offset, and return the
	 * default segment that applies to this offset.
	 */
	if (retVal)
#ifdef SPC386
		*offset = (*offset + ireg_offset + const_offset);
#else
		*offset = (*offset + ireg_offset + const_offset) & 0xffff;
#endif

	return(retVal);
}

/*
 * Decode a full Intel address expression.
 */
LOCAL IBOOL decode_iaddr_ok IFN3 (char *, iaddr, IS32 *, seg, LIN_ADDR *, offset)
{
	char junk;
	char cseg[50], coffset[50];
	IU32 iaddr16b;
	IS32 dummy;
	SAVED IBOOL cold = TRUE;

	/*
	 * Data required to decode segment register names.
	 */
	static struct DECODE_SEGREG {
		char *reg_name;
		word (*get_segreg_val) IPT0();
	}
	 decode_segreg[] =
	{
		{"cs", NULL},
		{"ds", NULL},
		{"ss", NULL},
		{"es", NULL}
#ifdef SPC386
		,{"fs", NULL},
		{"gs", NULL}
#endif /* SPC 386 */
	};

	if( cold )
	{
#ifdef CCPU
		decode_segreg[0].get_segreg_val = c_getCS;
		decode_segreg[1].get_segreg_val = c_getDS;
		decode_segreg[2].get_segreg_val = c_getSS;
		decode_segreg[3].get_segreg_val = c_getES;
#ifdef SPC386
		decode_segreg[4].get_segreg_val = c_getFS;
		decode_segreg[5].get_segreg_val = c_getGS;
#endif /* SPC386 */
#else  /* !CCPU */
#ifdef CPU_40_STYLE
		decode_segreg[0].get_segreg_val = Cpu.GetCS;
		decode_segreg[1].get_segreg_val = Cpu.GetDS;
		decode_segreg[2].get_segreg_val = Cpu.GetSS;
		decode_segreg[3].get_segreg_val = Cpu.GetES;
		decode_segreg[4].get_segreg_val = Cpu.GetFS;
		decode_segreg[5].get_segreg_val = Cpu.GetGS;
#else  /* !CPU_40_STYLE */
		decode_segreg[0].get_segreg_val = getCS;
		decode_segreg[1].get_segreg_val = getDS;
		decode_segreg[2].get_segreg_val = getSS;
		decode_segreg[3].get_segreg_val = getES;
#ifdef SPC386
		decode_segreg[4].get_segreg_val = getFS;
		decode_segreg[5].get_segreg_val = getGS;
#endif /* SPC386 */
#endif /* !CPU_40_STYLE */
#endif /* !CCPU */
		cold = FALSE;
	}

	/*
	 * Decode intel address string that has been given to command.
	 * If the address is not understood then return in one or both
	 * of the cs:ip fields.
	 */

	if (iaddr[0] == 0) {

		/*
		 * Blank command line means 0:0. This is naff but is
		 * required to make the "da" command work as it used to which
		 * I can't be bothered to change at the moment. CS:IP would
		 * be a more sensible option.
		 */
		*seg = *offset = 0;
		return(TRUE);

	} else if (!strcmp(iaddr, ".")) {

		/*
		 * Address of just "." means CS:IP.
		 */
		*seg    = getCS();
		*offset = GetInstructionPointer();
		return(TRUE);

	} else if (sscanf(iaddr, "%[^:]:%s", cseg, coffset) == 2) {

		/*
		 * Address given in segment/offset format; decode it.
		 * First do the segment; either simple numeric or
		 * assembler name (CS, DS etc).
		 */
		if (sscanf(cseg, "%lx%c", &iaddr16b, &junk) == 1) {
#ifdef SPC386
			*seg = iaddr16b;
#else
			*seg = iaddr16b & 0xffff;
#endif
		} else {
			ISM8 n;
			
			string_tolower(cseg);
			for (n = 0; n < sizeof(decode_segreg)/
					sizeof(struct DECODE_SEGREG); n++)
				if (!strcmp(cseg, decode_segreg[n].reg_name))
				    *seg = decode_segreg[n].get_segreg_val();
		}

		/*
		 * Decode the offset into segment.
		 */
		return(decode_offset (coffset, offset, &dummy));

	} else {
		/*
		 * This is probably just an offset expressed as BX, SI-2 or
		 * the like, so decode it and setup the default segment.
		 */
		return(decode_offset (iaddr, offset, seg));
	}
}

LOCAL YODA_CMD_RETURN do_force_yoda_command IFN5(char *, str, char *, com, char *, iaddr, LIN_ADDR, len, LIN_ADDR, stop)
{
	int i, retvalue = YODA_HELP;
	unsigned long temp1, temp2;

	IS32 cs;
	LIN_ADDR ip;

	for (i = 0; i < sizeoftable(yoda_command); i++) {
		if (strcmp(yoda_command[i].name, com) == 0) {
			/*
			 * Decode any Intel address expected by the command.
			 * Different stuff done for commands that
			 * understand new generic address parsing.
			 */
			if (yoda_command[i].decode_iaddr) {
				/*
				 * Decode Intel address ..
				 */
				if (!decode_iaddr_ok(iaddr, &cs, &ip)) {
				    printf ("Bad <intel-addr> expression\n");
				    return(YODA_LOOP);
				}
			} else {
				/*
				 * Either doesn't want address at all or wants
				 * it old style; this is how it used to be
				 * for everyone ...
				 */
				if (len == YODA_LEN_UNSPECIFIED)
					len = 1;
				temp1 = temp2 = 0;
				sscanf (iaddr, "%lx:%lx", &temp1, &temp2);
				cs = temp1;
				ip = temp2;
			}

			/*
			 * Go do the command ...
			 */
			retvalue = (*yoda_command[i].function)(str,
						com, cs, ip, len, stop);
			break;
		}
	}

	return(retvalue);
}


LOCAL IBOOL entry_pending = FALSE;

#ifdef	CPU_40_STYLE
/* The EDL CPU prefers to be entered via an interrupt, but this
 * may not always work. So if the UIF button is used twice before
 * we get into yoda, the second is treated as a force.
 *
 * If we are running a Prod-in-a-Pig LCIF then a single button select
 * does a force_yoda().
 */

GLOBAL VOID Enter_yoda IFN0()
{
#ifdef	PIG
	GLOBAL IHP GetSadInfo IPT1(char *, name);

	/* Check to see if LCIF has been built with Pig capability */

	if (!(IBOOL)GetSadInfo("PigSupported"))
	{
		fprintf(stderr, "*** LCIF has not been built with Pig support\n");
		entry_pending = TRUE;
	}
#endif	/* PIG */

	if (entry_pending)
	{
		printf("Forced entry to yoda...\n");
		force_yoda();
	}
	else
	{
		entry_pending = TRUE;
		cpu_interrupt(CPU_SAD_INT, 0);
	}
}
#endif	/* CPU_40_STYLE */

#if defined(CPU_40_STYLE) && !defined(CCPU)
/* Use the integrated command line reader from FmDebug.c */

GLOBAL IBOOL GetCpuCmdLine IPT4(char *, buff, int, size, FILE *, stream, char *, who);

#else	/* CPU_40_STYLE && !CCPU */

GLOBAL IBOOL GetCpuCmdLine IFN4(char *, buff, int, size, FILE *, stream, char *, who)
{
	char prompt[256], *p;
	int i;

	if (stream == stdin)
	{
		strcpy(prompt, who);
		strcat(prompt, "> ");
		fprintf(stdout, prompt);
	}
	fflush(stdout);
	fflush(trace_file);
	if (fgets(buff, size, stream) != NULL)
	{
		p = strchr(buff, '\n');
		if (p != NULL)
			*p = '\0';
		return TRUE;
	}
	return FALSE;
}
#endif	/* CPU_40_STYLE && !CCPU */

GLOBAL IBOOL AlreadyInYoda = FALSE;

void force_yoda IFN0()
{
	IS32 cs;
	LIN_ADDR ip, len, stop;
	long temp1, temp2;		/* used in calls to scanf */
	char str [84];		/* input string buffer */
	char com [16];		/* command name buffer */
	char iaddr[50];		/* first parameter/ intel address buffer */
	char slen[20];
	char junk;		/* for decoding the cmd line */
	int n_args;
	char *prompt;
	SAVED IBOOL firstTime = TRUE;
	SAVED char repeat_command [sizeof(str)];/* copy of previous input string buffer */
#ifdef SFELLOW
	IU32 oldEE;
#endif /* SFELLOW */

	entry_pending = FALSE;

#ifdef PCLABS_STATS
	return;
#endif
#ifdef 	GISP_SVGA
	if( NoYodaThanks )
	{
		
		return;
	}
#endif	/* GISP_SVGA */

#if	defined(CPU_40_STYLE) && !defined(CCPU)

	EnterDebug("Yoda");
	prompt = "";

#else	/* CPU_40_STYLE && !CCPU */

	if (AlreadyInYoda) {
		printf("Recursive call to force_yoda() disallowed!\n");
		return;
	} else {
		AlreadyInYoda = TRUE;
	}
	prompt = "yoda";

#endif	/* CPU_40_STYLE && !CCPU  */

#ifdef SFELLOW
        oldEE = DisableEE();
#endif /* SFELLOW */

	if (firstTime) {
		firstTime = FALSE;
		if (host_getenv("QUIET_YODA"))
		{
			chewy = 0;
		} else {
			chewy = 1;
#if !defined(macintosh) && !defined(SFELLOW)
			(void)srand(time(NULL));
#endif /* !macintosh && !SFELLOW */
#if defined(SPC386) && !defined(GISP_CPU)
			printf("\nRemember, not everything is as it seems!  An experienced Jedi will know\nthe difference between the physical world and the logical world at all times.\n\n");
#endif /* SPC386 & !GISP_CPU */

		if (in_stream == NULL)
			in_stream = stdin;

		if (out_stream == NULL)
			out_stream = stdout;

		}
	}
#ifdef A3CPU
	/* The A3CPU thread generation has already happened, and if
	 * the YODA environment variable was not defined then you
	 * aren't going to be able to use the YODA_INTERRUPT system
	 */
#ifndef SFELLOW
	if (env_check == 0) {
		env_check = (host_getenv("YODA") == NULL)? 1: 2;
	    if (env_check == 1) {
	        printf("Slow YODA not available (no breakpoint-based features)\n");
	        printf("If you want Slow YODA facilities, you must do\n");
	        printf("'setenv YODA TRUE' before starting an A3 CPU.\n");
	    }
	}
#endif /* !SFELLOW */
#endif /* A3CPU */


#ifdef MUST_BLOCK_TIMERS
	if( !timer_blocked )
        host_block_timer();
#endif /* MUST_BLOCK_TIMERS */

   	disable_timer = 1;
	disable_bkpt = 1;
	if (compare_stream)
		printf("Compare line number %d.\n", ct_line_num);
	trace("", trace_type);
	disable_bkpt = 0;

	while(1)
	{
		if (refresh_screen)
			do_screen_refresh();

#ifdef SFELLOW
		if (! GetCpuCmdLine(str, 80, stdin, prompt))
		{
                        /* if read fails on stdin */
                        perror("failed to read from stdin");
                        continue;
		}
#else /* SFELLOW */
		if (! GetCpuCmdLine(str, 80, in_stream, prompt))
		{
			/* if read fails on file */
			if (in_stream == stdin) {
				perror("failed to read from stdin");
			} else
			{
				/* close script */
				fclose (in_stream);
	
				/* return to stdin */
				in_stream = stdin;
	
				/* tell user his script has finished */
				puts ("(eof)");
	
				continue;
			}
		}

		/* if reading a script echo the command */
		if (in_stream != stdin) {
			puts(str);
		} else if (str[0] == '\0') {
			/*
			 * If no command is specified then copy previous
			 * command (if it was repeatable)
			 */
			strcpy(str, repeat_command);
		}
#endif /* SFELLOW */
	
		/*
		 * Setup default command arguments and do initial command
		 * line decoding.
		 */
	
		com[0] = 0;
	
		temp1 = 1;
		len  = YODA_LEN_UNSPECIFIED;
	
		/*
		 * the lengths here relate to the buffer sizes of com, iaddr and slen
		 * [BCN 2582]
		 */
		n_args = sscanf (str, "%15s %49s %19s %lx", com, iaddr, slen, &temp1);
		stop = temp1;
		if (n_args < 2)
			iaddr[0] = 0;
	
		if (n_args >= 3) {
			/*
			 * The <len> parameter was provided; this is supposed to
			 * be numeric but we accept (SR), (LR), (TR), (WI), (SI),
			 * (LI) and (PD) to allow NPX addresses to be cut/pasted
			 * directly out of the dissasembler. They equate to the
			 * size in bytes of the corresponding data item.
			 * Useful for pasting into, for example, the "db" command.
			 */
			string_tolower(slen);
			if (sscanf(slen, "%lx%c", &temp1, &junk) == 1) {
				if (temp1 == YODA_LEN_UNSPECIFIED) {
					printf("That length only by a master be used may, given you 1 I have\n");
					len = 1;
				} else {
					len = temp1;
				}
			} else {
				if (!strcmp(slen, "(wi)"))
					len = 2;
				else if (!strcmp(slen, "(sr)") || !strcmp(slen, "(si)"))
					len = 4;
				else if (!strcmp(slen, "(lr)") || !strcmp(slen, "(li)"))
					len = 8;
				else if (!strcmp(slen, "(tr)") || !strcmp(slen, "(pd)"))
					len = 12;
				else
					len = YODA_LEN_UNSPECIFIED;
			}
		}
	
		repeat_command[0] = '\0'; /* Default is dont-repeat on null command */
		/*
		 * Do the command & take action on the return code ...
		 */
		switch (do_force_yoda_command(str, com, iaddr, len, stop))
		{
		case YODA_RETURN_AND_REPEAT:
			/* Remember this command, when it completes a null command will
			 * do this command again. I.e. "s", followed by <return> will
			 * do "s" twice.
			 */
			strcpy(repeat_command, str);
			/* Fall through */
		case YODA_RETURN:
#ifdef MUST_BLOCK_TIMERS
			if( !timer_blocked )
				host_release_timer();
#endif /* MUST_BLOCK_TIMERS */
			In_yoda = FALSE;
			AlreadyInYoda = FALSE;

#ifdef SFELLOW
			RestoreEE(oldEE);
#endif /* SFELLOW */

#if defined(CPU_40_STYLE) && !defined(CCPU)
			LeaveDebug();
#endif /* CPU_40_STYLE && !CCPU */
			return;
		case YODA_HELP:
			/*
			 * Following assignment & scanf is the way that all yoda
			 * commands used to get their arguments; the host extensions
			 * will still always get the old stuff. AJO 29/8/93.
			 */
			if (len == YODA_LEN_UNSPECIFIED)
				len = 1;			/* old default */
			temp1 = temp2 = 0;
			sscanf(iaddr, "%lx:%lx", &temp1, &temp2);
			cs = temp1;
			ip = temp2;
	
			if (    (host_force_yoda_extensions(com,cs,ip,len,str)!=0)
			      && (strcmp(com,"") != 0))
			{
				printf ("Unknown command '%s'\n", com);
				if (chewy) {
					printf ("Use the 'h' command if you must.\n");
					printf ("Remember - a jedi's strength FLOWS through his fingers\n");
				}
			}
			/* Fall through (we dont care!) */
		case YODA_LOOP_AND_REPEAT:
			/* Remember this command, when it completes a null command will
			 * do this command again. I.e. "u", followed by <return> will
			 * do "u" twice.
			 */
			strcpy(repeat_command, str);
			/* Fall through */
		case YODA_LOOP:
		default:
			break;
		}
	}

	/*
	 * Should never get here.
	 */
}

#ifdef PM
LOCAL dump_descr IFN2(LIN_ADDR, address, IUM32, num)
/* address of first descriptor to dump */
/* number of descriptors to dump */
{
   int i;
   int output_type;
   char *output_name;
   int p;		/* Bits of descriptor */
   int a;		/* ... */
   int dpl;		/* ... */
   half_word AR;	/* ... */
   word limit;		/* ... */
   word low_base;	/* ... */
   half_word high_base;	/* ... */
   word high_limit;	/* ... */
   sys_addr base;
   int scroll;
   sys_addr tlimit;

   scroll = 0;
   for ( i = 0; i < (num * 8); i+=8, address += 8, scroll++ )
      {
	if (scroll == 20) {
		if (!yoda_confirm("-- more descriptors? -- "))
			break;
		scroll = 0;
	}
      AR = sas_hw_at(address+5);		/* get access rights */
      p = (AR & 0x80) >> 7;		/* hence P(Present) */
      dpl = (AR & 0x60) >> 5;		/* and DPL */
      AR = AR & 0x1f;			/* and super type */
      a = AR & 0x1;			/* and A(Accessed) */
      limit = sas_w_at(address);		/* 1st word of descr */
      low_base = sas_w_at(address+2);	/* 2nd word of descr */
      high_base = sas_hw_at(address+4);		/* 5th byte of descr */
#ifdef SPC386
      high_limit = sas_w_at(address+6);	/* 4th word of descr */
#else /* SPC386 */
      high_limit = 0;
#endif /* SPC386 */

      output_name = segment_names[AR];

      /* find output format */
      switch ( (int)AR )
	 {
      case 0x00:   /* INVALID */
      case 0x08:
      case 0x0a:
      case 0x0d:
	 output_type = 2;
	 break;

#ifdef SPC386
      case 0x09:
      case 0x0b:
	 output_type = 1;
	 break;
      case 0x0c:
	 output_type = 8;
	 break;
      case 0x0e:
      case 0x0f:
	 output_type = 9;
	 break;
#else /* SPC386 */
      case 0x09:
      case 0x0b:
      case 0x0c:
      case 0x0e:
      case 0x0f:
	 output_type = 2;
	 break;
#endif /* SPC386 */

      case 0x01:   /* SPECIAL */
      case 0x02:
      case 0x03:
	 output_type = 1;
	 break;

      case 0x04:   /* CONTROL */
	 output_type = 4;
	 break;

      case 0x05:   /* CONTROL */
	 output_type = 5;
	 break;

      case 0x06:   /* CONTROL */
      case 0x07:
	 output_type = 3;
	 break;

      case 0x10:   /* DATA */
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x14:
      case 0x15:
      case 0x16:
      case 0x17:
	 output_type = 6;
	 break;

      case 0x18:   /* CODE */
      case 0x19:
      case 0x1a:
      case 0x1b:
      case 0x1c:
      case 0x1d:
      case 0x1e:
      case 0x1f:
	 output_type = 7;
	 break;
	 }

      switch ( output_type )
	 {
      case 1:
	 if ( descr_trace & 0x02 )
#ifdef SPC386
	    {
	    base = ((high_limit & 0xff00) << 16) |
		   (high_base << 16 ) |
		   low_base;
	    tlimit = ((high_limit & 0xf) << 16) | limit;
	    if ( high_limit & 0x80 )
	       tlimit = tlimit << 12 | 0xfff;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s BASE:%08x LIMIT:%08x\n",
	       i, p, dpl, output_name, base, tlimit);
	    }
#else /* SPC386 */
	    {
	    base = ((sys_addr)high_base << 16 ) | low_base;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s BASE:%6x LIMIT:%4x\n",
	       i, p, dpl, output_name, base, limit);
	    }
#endif /* SPC386 */
	 break;

      case 2:
	 if ( descr_trace & 0x01 )
	    {
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s\n",
	       i, p, dpl, output_name);
	    }
	 break;

      case 3:
	 if ( descr_trace & 0x08 )
	    {
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s SELECTOR:%4x OFFSET:%4x\n",
	       i, p, dpl, output_name, low_base, limit);
	    }
	 break;

      case 4:
	 if ( descr_trace & 0x04 )
	    {
	    high_base = high_base & 0x1f;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s SELECTOR:%4x OFFSET:%4x WD:%2x\n",
	       i, p, dpl, output_name, low_base, limit, high_base);
	    }
	 break;

      case 5:
	 if ( descr_trace & 0x08 )
	    {
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s TSS SELECTOR:%4x\n",
	       i, p, dpl, output_name, low_base);
	    }
	 break;

      case 6:
	 if ( descr_trace & 0x10 )
	    {
	    base = ((high_limit & 0xff00) << 16) |
		   (high_base << 16 ) |
		   low_base;
	    tlimit = ((high_limit & 0xf) << 16) | limit;
	    if ( high_limit & 0x80 )
	       tlimit = tlimit << 12 | 0xfff;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d %s TYPE:%25s BASE:%08x LIMIT:%08x A:%1d\n",
	       i, p, dpl, (high_limit & 0x40) ? "Big": "   ", output_name, base, tlimit, a);
	    }
	 break;

      case 7:
	 if ( descr_trace & 0x20 )
	    {
	    base = ((high_limit & 0xff00) << 16) |
		   (high_base << 16 ) |
		   low_base;
	    tlimit = ((high_limit & 0xf) << 16) | limit;
	    if ( high_limit & 0x80 )
	       tlimit = tlimit << 12 | 0xfff;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d %s TYPE:%25s BASE:%08x LIMIT:%08x A:%1d\n",
	       i, p, dpl, (high_limit & 0x40) ? "Big": "   ", output_name, base, tlimit, a);
	    }
	 break;

      case 8:
	 if ( descr_trace & 0x04 )
	    {
	    high_base = high_base & 0xf;
	    tlimit = (high_limit << 16) | limit;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s SELECTOR:%04x OFFSET:%08x DW:%2x\n",
	       i, p, dpl, output_name, low_base, tlimit, high_base);
	    }
	 break;

      case 9:
	 if ( descr_trace & 0x08 )
	    {
	    tlimit = (high_limit << 16) | limit;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s SELECTOR:%04x OFFSET:%08x\n",
	       i, p, dpl, output_name, low_base, tlimit);
	    }
	 break;
	 }
      }
   }
#endif /* PM */

/*
   Dump Readable String.
 */
dump_string IFN4(IU16, selector, LIN_ADDR, offset, LIN_ADDR, len, long, mode)

#ifdef DOCUMENTATION
long selector;   /* Selector:Offset to start address for dump */
long offset;     /*                    "                      */
long len;        /* Nr. bytes to dump */
long mode;       /* =1 Simple byte string dump */
                 /* =2 Dump every other byte starting with first */
                 /* =3 Dump every other byte starting with second */
#endif	/* DOCUMENTATION */

   {
   int i;
   int pc = 0;
   half_word value;
   LIN_ADDR addr;

   addr = eff_addr(selector, offset);

   for ( i = 0; i < len; i++ )
      {
      /* Get next byte to be shown */
      switch ( mode )
	 {
      case 1:
	 value = sas_hw_at(addr+i);
	 break;

      case 2:
	 value = sas_hw_at(addr+i);
	 i++;
	 break;

      case 3:
	 i++;
	 value = sas_hw_at(addr+i);
	 break;
	 }

      /* Filter out the unprintable */
      if ( iscntrl(value) )
	 value = '.';

      /* Print it */
      fprintf(trace_file, "%c", value);
      /* With a line feed every eighty characters */
      if ( ++pc == 80 )
	 {
	 fprintf(trace_file, "\n");
	 pc = 0;
	 }
      }

   /* Print final line feed if needed */
   if ( pc )
      fprintf(trace_file, "\n");
   }


/* Do pretty printing for page table entry */
LOCAL void dump_page_table_entries IFN3(int, first_index, int, last_index, IU32, entry)
{
	if (first_index == last_index)
		fprintf(trace_file, "%03x      %08x ", first_index, entry);
	else
		fprintf(trace_file, "%03x..%03x %08x ", first_index, last_index, entry);

	if ( entry & 1 )
	{
		/* Present */
		fprintf(trace_file, "%08x %c %c %c %c.\n",
			entry & 0xfffff000,
			(entry & 0x40) ? 'D' : ' ',
			(entry & 0x20) ? 'A' : ' ',
			(entry & 0x04) ? 'U' : 'S',
			(entry & 0x02) ? 'W' : 'R');
	}
#ifndef	CCPU
	else if ((((entry >> 9) & 7) == 6) && Sas.IsPageInstanceData(entry))
	{
		/* Not Present, but Windows instance data */
		fprintf(trace_file, "Not Present, Instance data\n");
	}
#endif /* CCPU */
	else
	{
		/* Not Present */
		fprintf(trace_file, "Not Present.\n");
	}
}


LOCAL void dump_page_table IFN2(
   IS32, cs,	/* Physical address to dump table from */
   IS32, len	/* Entry Number (0-3ff) to dump, else dump all */
)
{
#ifdef CPU_40_STYLE
	PHY_ADDR addr;
	int start, end;
	int i;
	IU32 entry;
	
	/* Special case tell them Page Directory Base Register contents */
	if ( cs == 0 )
	{
		fprintf(trace_file,
			"Page Directory Base Register = %08x.\n", getCR3());
		return;
	}
	
	if ( len < 0 || len > 1023  )
	{
		/* dump whole table */
		start = 0;
		end = 1024;
		addr = (PHY_ADDR)cs;
	}
	else
	{
		/* dump just one entry */
		start = len;
		end = len + 1;
		addr = (PHY_ADDR)(cs + (start * 4));
	}
	
	disable_bkpt = 1;
	
	i = start;
	while (i < end)
	{
		IU32 next_entry;
		PHY_ADDR next_addr;
		IU32 next_i;

		/* Get next Page Table Entry */
		entry = sas_PR32(addr);
		next_addr = addr+4;
		for (next_i = i+1; next_i < end;)
		{
			next_entry = sas_PR32(next_addr);
			if (next_entry != entry)
				break;
			next_addr += 4;
			next_i++;
		}
		if (next_i < end)
		{
			/* We exited early, entry at next_i is different */
			dump_page_table_entries(i, next_i - 1, entry);
			i = next_i;
			addr = next_addr;
		}
		else
		{
			dump_page_table_entries(i, end - 1, entry);
			break;
		}
	}
	
	disable_bkpt = 0;
#endif /* CPU_40_STYLE */
}

LOCAL void show_phys_addr IFN1(LIN_ADDR, lin)
{
	IU32 dir, tbl;
	PHY_ADDR addr, pde, pte;
	/* Split linear address (lin) into DIR, TBL and OFFSET components */
	
	dir = (lin >> 22) & 0x3ff;
	tbl = (lin >> 12) & 0x3ff;
	fprintf(trace_file,
		"LinearAddress %08x => Directory %03x Table %03x Offset %03x.\n",
		lin,
		dir,
		tbl,
		lin & 0xfff);
#ifdef	CPU_40_STYLE
	addr = (getCR3() & ~0x3ff) + (dir * 4);
	disable_bkpt = 1;
	pde = sas_PR32(addr);
	disable_bkpt = 0;
	fprintf(trace_file, "  Directory entry @ %08p ", addr);
	dump_page_table_entries(dir, dir, pde);
	if (pde & 1)
	{
		addr = (pde & ~0xfff) + (tbl * 4);
		disable_bkpt = 1;
		pte = sas_PR32(addr);
		disable_bkpt = 0;
		fprintf(trace_file, "  Table entry     @ %08p ", addr);
		dump_page_table_entries(tbl, tbl, pte);
		if (pte & 1)
		{
			fprintf(trace_file, "  Final Physical Address %08x\n", (pte & ~0xfff) + (lin & 0xfff));
		}
	}
#endif /* CPU_40_STYLE */
}

LOCAL void guess_lin_phys IFN1(PHY_ADDR, phys)
{
	IU32 dir, tbl, pdbr;
	PHY_ADDR addr, pde, pte;
	int nPrinted = 0;
	/* Guess linear address(es) from given phys address */

	fprintf(trace_file,
		"Phys addr @ %08x could be linear address(es)\n",
		phys);
#ifdef	CPU_40_STYLE
	pdbr = getCR3() & ~0xFFF;
	for (dir = 0; dir <= 0x3ff; dir++)
	{
		addr = pdbr + (dir * 4);

		disable_bkpt = 1;
		pde = sas_PR32(addr);
		disable_bkpt = 0;
		if (pde & 1)
		{
			for (tbl = 0; tbl <= 0x3ff; tbl++)
			{
				addr = (pde & ~0xfff) + (tbl * 4);
				disable_bkpt = 1;
				pte = sas_PR32(addr);
				disable_bkpt = 0;
				if ((pte & 1) && ((pte ^ phys) <= 0xfff))
				{
					fprintf(trace_file, "%08x ",
						(dir << 22) + (tbl << 12) + (phys & 0xFFF));
					if (nPrinted++ == 8)
					{
						fprintf(trace_file, "\n");
						nPrinted = 0;
					}
				}
			}
		}
	}
	if (nPrinted)
	{
		fprintf(trace_file, "\n");
	}
#endif /* CPU_40_STYLE */
}

LOCAL void guess_lin_pte IFN1(PHY_ADDR, pte_addr)
{
	IU32 dir, tbl, pdbr;
	PHY_ADDR addr, pde, pte;
	int nPrinted = 0;
	/* Guess linear address(es) from given PTE address */
	
	fprintf(trace_file,
		"PTE @ %08x could be defining linear address(es)\n",
		pte_addr);
#ifdef	CPU_40_STYLE
	pdbr = getCR3() & ~0xFFF;
	for (dir = 0; dir <= 0x3ff; dir++)
	{
		addr = pdbr + (dir * 4);

		disable_bkpt = 1;
		pde = sas_PR32(addr);
		disable_bkpt = 0;
		if ((pde & 1) && ((pde ^ pte_addr) <= 0xfff))
		{
			fprintf(trace_file, "%05x000 ", (dir << 10) + ((pte_addr & 0xFFF) >> 2));
			if (nPrinted++ == 8)
			{
				fprintf(trace_file, "\n");
				nPrinted = 0;
			}
		}
	}
	if (nPrinted)
	{
		fprintf(trace_file, "\n");
	}
#endif /* CPU_40_STYLE */
}

LOCAL	void	dump_phys_bytes IFN2(IS32, cs, IS32, len)
   {
#ifdef CPU_40_STYLE
   int i, j, x, y;

   if (len < 0)
      len = 1;

   x = len % 16;
   y = len / 16;

   for (i=0;i<y;i++)
      {
      fprintf(trace_file,"%08lx:", cs);
      for (j=0;j<16;j++)
	 {
	 fprintf(trace_file," %02x", sas_PR8((PHY_ADDR)(cs + j)));
	 }
      fprintf(trace_file,"\n");
      cs += 16;
      }

   if(x != 0)
      fprintf(trace_file,"%08lx:", cs);

   for (j=0;j<x;j++)
      {
      fprintf(trace_file," %02x", sas_PR8((PHY_ADDR)(cs + j)));
      }
   fprintf(trace_file,"\n");
#endif /* CPU_40_STYLE */
   }

LOCAL	void	dump_bytes IFN3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len)
{
half_word val[MAX_TABLE];
int i, j, k, x, y;
	if ((len == 0) || (len == YODA_LEN_UNSPECIFIED))
		return;
	if(len > MAX_TABLE)
		len = MAX_TABLE;
	disable_bkpt = 1;
	sas_loads(eff_addr(cs,ip), val, len);
	disable_bkpt = 0;
	x = len % 16;
	y = len / 16;
	k = 0;
	for (i=0;i<y;i++) {
		fprintf(trace_file,"%04lx:%04lx", cs, ip);
		for (j=0;j<16;j++)
			fprintf(trace_file," %02x", val[k++]);
		fprintf(trace_file,"\n");
		ip += 16;
	}
	if(x != 0)
		fprintf(trace_file,"%04lx:%04lx", cs, ip);
	for (i=0;i<x;i++)
		fprintf(trace_file," %02x", val[k++]);
	fprintf(trace_file,"\n");
}

LOCAL	void	dump_words IFN3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len)
{
int i;
word val;

	disable_bkpt = 1;
	for (i=0;i<len;i++) {
		if (i%8 == 0) fprintf(trace_file,"%04lx:%04lx", cs, ip);
		val = sas_w_at(eff_addr(cs,ip));
		ip += 2;
		fprintf(trace_file," %04x", val);
		if (i%8 == 7) fprintf(trace_file,"\n");
	}
	if (i%8 != 7) fprintf(trace_file,"\n");
	disable_bkpt = 0;
}

LOCAL	void	dump_dwords IFN3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len)
{
int i;
IU32 val;

	disable_bkpt = 1;
	for (i=0;i<len;i++) {
		if (i%8 == 0) fprintf(trace_file,"%04lx:%04lx", cs, ip);
		val = sas_dw_at(eff_addr(cs,ip));
		ip += 4;
		fprintf(trace_file," %08x", val);
		if (i%8 == 7) fprintf(trace_file,"\n");
	}
	if (i%8 != 7) fprintf(trace_file,"\n");
	disable_bkpt = 0;
}

LOCAL void init_br_regentry IFN3(BR_REG, regst, char *, str, SIZE_SPECIFIER, size)
{
	br_regdescs[regst].regnum = regst;
	strcpy(br_regdescs[regst].regname, str);
	br_regdescs[regst].size = size;
}

LOCAL void init_br_structs IFN0()
{
	int loop;

	init_br_regentry(br_regAX,"AX",SIXTEEN_BIT);
	init_br_regentry(br_regBX,"BX",SIXTEEN_BIT);
	init_br_regentry(br_regCX,"CX",SIXTEEN_BIT);
	init_br_regentry(br_regDX,"DX",SIXTEEN_BIT);
	init_br_regentry(br_regCS,"CS",SIXTEEN_BIT);
	init_br_regentry(br_regDS,"DS",SIXTEEN_BIT);
	init_br_regentry(br_regES,"ES",SIXTEEN_BIT);
	init_br_regentry(br_regSS,"SS",SIXTEEN_BIT);
	init_br_regentry(br_regSI,"SI",SIXTEEN_BIT);
	init_br_regentry(br_regDI,"DI",SIXTEEN_BIT);
	init_br_regentry(br_regSP,"SP",SIXTEEN_BIT);
	init_br_regentry(br_regBP,"BP",SIXTEEN_BIT);
#ifdef SPC386
	init_br_regentry(br_regEAX,"EAX",THIRTY_TWO_BIT);
	init_br_regentry(br_regEBX,"EBX",THIRTY_TWO_BIT);
	init_br_regentry(br_regECX,"ECX",THIRTY_TWO_BIT);
	init_br_regentry(br_regEDX,"EDX",THIRTY_TWO_BIT);
	init_br_regentry(br_regFS,"FS",SIXTEEN_BIT);
	init_br_regentry(br_regGS,"GS",SIXTEEN_BIT);
	init_br_regentry(br_regESI,"ESI",THIRTY_TWO_BIT);
	init_br_regentry(br_regEDI,"EDI",THIRTY_TWO_BIT);
	init_br_regentry(br_regESP,"ESP",THIRTY_TWO_BIT);
	init_br_regentry(br_regEBP,"EBP",THIRTY_TWO_BIT);
#endif
	init_br_regentry(br_regAH,"AH",EIGHT_BIT);
	init_br_regentry(br_regBH,"BH",EIGHT_BIT);
	init_br_regentry(br_regCH,"CH",EIGHT_BIT);
	init_br_regentry(br_regDH,"DH",EIGHT_BIT);
	init_br_regentry(br_regAL,"AL",EIGHT_BIT);
	init_br_regentry(br_regBL,"BL",EIGHT_BIT);
	init_br_regentry(br_regCL,"CL",EIGHT_BIT);
	init_br_regentry(br_regDL,"DL",EIGHT_BIT);

	free_br_regs = &br_regs[0];
	head_br_regs = NULL;

	for (loop=0;loop<(NUM_BR_ENTRIES-1);loop++)
	{
		br_regs[loop].next = &br_regs[loop+1];
		br_regs[loop].handle = loop;
	}
	br_regs[NUM_BR_ENTRIES-1].next = NULL;
	br_structs_initted = TRUE;
}

LOCAL void	set_reg_break IFN3(char*, regstr, IU32,minv, IU32,maxv)
{
	BOOL found;
	BR_REGENTRY *brp;
	USHORT regn;

	if (!br_structs_initted)
		init_br_structs();

	if (free_br_regs == NULL)
	{
		printf("We have run out of register breakpoint entries, try deleting some.\n");
		return;
	}

	found = FALSE;
	regn = 0;
	while (!found && (regn <= br_regDL))
	{
		if (strcmp(br_regdescs[regn].regname,regstr) == 0)
			found = TRUE;
		else
			regn++;
	}

	if (!found)
	{
		printf("unknown register '%s'\n",regstr);
		return;
	}

	brp = free_br_regs;
	free_br_regs = free_br_regs->next;

	brp->next = head_br_regs;
	head_br_regs = brp;

	switch(br_regdescs[regn].size) {
	case EIGHT_BIT :
		brp->minval = minv & 0xff;
		brp->maxval = maxv & 0xff;
		break;

	case SIXTEEN_BIT :
		brp->minval = minv & 0xffff;
		brp->maxval = maxv & 0xffff;
		break;

	case THIRTY_TWO_BIT :
		brp->minval = minv & 0xff;
		brp->maxval = maxv & 0xff;
		break;
	}


	brp->regnum = br_regdescs[regn].regnum;
}

LOCAL	void	clear_reg_break IFN1(char *, regstr)
{
	BOOL found;
	BR_REGENTRY *brp, *last_brp;
	BR_REG regn;
	USHORT dhandle;

	if (strcmp(regstr,"all")==0)
	{
		init_br_structs();
		return;
	}
	
	dhandle = atoi(regstr);

	if (!br_structs_initted || (head_br_regs == NULL))
	{
		printf("no reg breakpoints to clear\n");
		init_br_structs();
		return;
	}

	found = FALSE;
	regn = 0;
	while (!found && (regn <= br_regDL))
	{
		if (strcmp(br_regdescs[regn].regname,regstr) == 0)
			found = TRUE;
		else
			regn++;
	}

	if (found)
	{
		printf("clearing all breakpoints for register '%s'\n",regstr);
		brp = head_br_regs;
		last_brp = NULL;
		while(brp != NULL)
		{
			if (brp->regnum == regn)
			{
				if (last_brp == NULL)
					head_br_regs = brp->next;
				else
					last_brp->next = brp->next;
				brp->next = free_br_regs;
				free_br_regs = brp;
			}
			else
			{
				last_brp = brp;
				brp = brp->next;
			}
		}
	}
	else
	{
		brp = head_br_regs;
		last_brp = NULL;
		while(!found && (brp != NULL))
		{
			if (brp->handle == dhandle)
				found = TRUE;
			else
			{
				last_brp = brp;
				brp = brp->next;
			}
		}
	
		if (!found)
		{
			printf("breakpoint handle %d is not currently active\n",dhandle);
			return;
		}
	
		if (last_brp == NULL)
			head_br_regs = brp->next;
		else
			last_brp->next = brp->next;
		brp->next = free_br_regs;
		free_br_regs = brp;
	}
}

LOCAL	void	print_reg_break IFN0()
{
	BR_REGENTRY *brp;

	if (!br_structs_initted)
	{
		printf("no reg breakpoints to print\n");
		init_br_structs();
		return;
	}

	brp = head_br_regs;
	while(brp != NULL)
	{
		printf("%d:	break if %s is ",brp->handle, br_regdescs[brp->regnum].regname);

		if (brp->minval == brp->maxval)
		{
			printf("%#x\n",brp->minval);
		}
		else
		{
			printf("between %#x and %#x\n",brp->minval,brp->maxval);
		}
		brp = brp->next;
	}
}

LOCAL	BOOL	check_reg_break IFN0()
{
	BR_REGENTRY *brp;
	USHORT val;

	if (!br_structs_initted)
	{
		init_br_structs();
		return(FALSE);
	}

	brp = head_br_regs;
	while(brp != NULL)
	{
		switch(brp->regnum)
		{
		case br_regAX:
			val = getAX();
			break;
		case br_regBX:
			val = getBX();
			break;
		case br_regCX:
			val = getCX();
			break;
		case br_regDX:
			val = getDX();
			break;
		case br_regCS:
			val = getCS();
			break;
		case br_regDS:
			val = getDS();
			break;
		case br_regES:
			val = getES();
			break;
		case br_regSS:
			val = getSS();
			break;
		case br_regSI:
			val = getSI();
			break;
		case br_regDI:
			val = getDI();
			break;
		case br_regSP:
			val = getSP();
			break;
		case br_regBP:
			val = getBP();
			break;
		case br_regAH:
			val = getAH();
			break;
		case br_regBH:
			val = getBH();
			break;
		case br_regCH:
			val = getCH();
			break;
		case br_regDH:
			val = getDH();
			break;
		case br_regAL:
			val = getAL();
			break;
		case br_regBL:
			val = getBL();
			break;
		case br_regCL:
			val = getCL();
			break;
		case br_regDL:
			val = getDL();
			break;
#ifdef SPC386
		case br_regEAX:
			val = getEAX();
			break;
		case br_regEBX:
			val = getEBX();
			break;
		case br_regECX:
			val = getECX();
			break;
		case br_regEDX:
			val = getEDX();
			break;
		case br_regFS:
			val = getFS();
			break;
		case br_regGS:
			val = getGS();
			break;
		case br_regESI:
			val = getESI();
			break;
		case br_regEDI:
			val = getEDI();
			break;
		case br_regESP:
			val = getESP();
			break;
		case br_regEBP:
			val = getEBP();
			break;

#endif /* SPC386 */
		}
		if ((val >= brp->minval) && (val <= brp->maxval))
		{
			printf("register `%s` contains %x !!\n",br_regdescs[brp->regnum].regname,val);
			return(TRUE);
		}
		brp = brp->next;
	}
	return(FALSE);
}

LOCAL	void	set_inst_break IFN5(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop,long, temp)
{
    BPTS *ptr, *freeslot;
    unsigned int i;

    /* Scan used slots for vacant slot */
    for (ptr = freeslot = (BPTS *)0, i = inst_break_count; i--;)
    {
	if (inst[i].valid)
	{
	    /* What if a break range encloses this trace address ? */
	    if (inst[i].cs == cs && inst[i].ip == ip)
		return;
	}
	else
	    /* Keep a record of earliest vacant slot */
	    ptr = inst + i;
    }

    if (!ptr)
    {
	/* No match and no freed slot try for a new one */
	if (inst_break_count >= MAX_TABLE)
	{
	    printf("Location watch table full !!!\n");
	    return;
	}

	/* Next unused slot */
	ptr = inst + inst_break_count++;
    }

    ptr->cs = cs;
    ptr->ip = ip;
    ptr->len = len;
    ptr->start_addr = eff_addr(cs,ip);
    ptr->end_addr = ptr->start_addr + len - 1;
    ptr->stop = stop;	
    ptr->temp = temp;
    ptr->valid = 1;
}

/* Tim did this
set_data_break_bytes IFN4(IS32, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop)
{
BPTS *ptr;
	if(data_bytes_break_count >= MAX_TABLE) {
		printf("Location watch table full !!!\n");
		return;
	}
	ptr = &data_bytes[data_bytes_break_count++];
	ptr->cs = cs;
	ptr->ip = ip;
	if (len==0)
		len=1;
	ptr->len = len;
	ptr->start_addr = eff_addr(cs,ip);
	ptr->end_addr = ptr->start_addr + len - 1;
	ptr->stop = stop;	
}
*/

/*
 * set_opcode_break
 *
 * Consider the two byte opcode 0f ab.  The user will have typed 0fab,
 * but when we do our compare against the instruction stream, the 0f will
 * come first, and hence be the LS byte.  Hence we need to swap things.
 * This is nothing to do with host-endianness or BACK_M!
 * This code may not be the prettiest, but I think it's safe.
 */

LOCAL	void	set_opcode_break IFN2(IU32, opcode, IU32, stop)
{
	if(opcode_break_count >= MAX_TABLE) {
		printf("Opcode breakpoint watch table full !!!\n");
		return;
	}
	if (opcode <= 0xff) {
		opcode_breaks[opcode_break_count].mask = 0xff;
		opcode_breaks[opcode_break_count].op = opcode;
	} else if (opcode <= 0xffff) {
		opcode_breaks[opcode_break_count].mask = 0xffff;
		opcode_breaks[opcode_break_count].op =
			((opcode & 0xff00) >> 8) +
			((opcode & 0xff) << 8);
	} else if (opcode <= 0xffffff) {
		opcode_breaks[opcode_break_count].mask = 0xffffff;
		opcode_breaks[opcode_break_count].op =
			((opcode & 0xff0000) >> 16) +
			((opcode & 0xff00)) +
			((opcode & 0xff) << 16);
	} else if (opcode <= 0xffffffff) {
		opcode_breaks[opcode_break_count].mask = 0xffffffff;
		opcode_breaks[opcode_break_count].op =
			((opcode & 0xff000000) >> 24) +
			((opcode & 0xff0000) >> 8) +
			((opcode & 0xff00) << 8) +
			((opcode & 0xff) << 24);
	}
	if (stop)
	    opcode_breaks[opcode_break_count].stop = 1;
	else
	if ((opcode_breaks[opcode_break_count].op & 0xff) == 0xcd)
	    opcode_breaks[opcode_break_count].stop = 2;
	else
	    opcode_breaks[opcode_break_count].stop = 0;
	opcode_break_count++;
}

/*
** called by yoda command bintx <int> <ah>
** set up interrupt number and ah value to break upon
*/
LOCAL	void	set_int_break IFN2(IU8, interrupt_number, IU8, ah )
{
	printf( "Interrupt breakpoint: INT:%lx AH:%lx\n", interrupt_number, ah );
	if(int_break_count >= MAX_TABLE) {
		printf("Interrupt breakpoint watch table full !!!\n");
		return;
	}
	int_breaks[int_break_count][0] = interrupt_number;
	int_breaks[int_break_count][1] = ah;
printf( "i_b[%x] [0]=%lx [1]=%lx\n",
int_break_count, int_breaks[int_break_count][0], int_breaks[int_break_count][1] );
	++int_break_count;
}

LOCAL	void	set_access_break IFN1(int, port)
{
        if(access_break_count >= MAX_TABLE) {
                printf("Access breakpoint table full !!!\n");
                return;
        }
        access_breaks[access_break_count++] = port;
}

/*
** Break on write to specified address range
** Currently allow only one of these breaks as have to store the complete data range.
*/
LOCAL	void	set_host_address_break IFN3(LIN_ADDR, cs, LIN_ADDR, len, LIN_ADDR, stop)

#ifdef DOCUMENTATION
long cs;		/* start address */
long len;		/* length to check */
long stop;		/* stop or trace when changed */
#endif	/* DOCUMENTATION */

{
DATA_BPTS *ptr;
int i;
IU8 *old, *now;

	if(host_address_break_count >= MAX_TABLE_BREAK_WORDS) {
		printf("BREAK on HOST ADDRESS change table full !!\n" );
		return;
	}
	if( len > MAX_BREAK_WORD_RANGE ){
		printf( "Range too big. More training you require.\n" );
		return;
	}
	ptr = &host_addresses[host_address_break_count++];
	ptr->cs = cs;
	ptr->ip = 0;
	ptr->stop = stop;
	ptr->len = len;

	/*
	 * saves Host address and data, will look for a change after every instruction
	 */

	ptr->data_addr = cs;
	now = (IU8 *)ptr->data_addr;
	old = (IU8 *)&ptr->old_value[0];
	for( i=0; i<len; i++ ){
		old[ i ] = now[ i ];
	}
	printf( "Break on host address change set from %lx length %x\n", ptr->data_addr, ptr->len );
}

/*
** Break on write to specified address range
** Currently allow only one of these breaks as have to store the complete data range.
*/
LOCAL	void	set_data_break_words IFN3(LIN_ADDR, cs, LIN_ADDR, len, LIN_ADDR, stop)

#ifdef DOCUMENTATION
long cs;		/* start address */
long len;		/* length to check */
long stop;		/* stop or trace when changed */
#endif	/* DOCUMENTATION */

{
DATA_BPTS *ptr;
int i;

	if(data_words_break_count >= MAX_TABLE_BREAK_WORDS) {
		printf("BREAK on WORD CHANGE table full !!\n" );
		return;
	}
	if( len > MAX_BREAK_WORD_RANGE ){
		printf( "Range too big. More training you require.\n" );
		return;
	}
	ptr = &data_words[data_words_break_count++];
	ptr->stop = stop;
	if (len==0)
		len=1;
	ptr->len = len;

	/*
	 * saves Intel 32-bit address and data, will look for a change after every instruction
	 */

	ptr->data_addr = cs;
	ptr->cs = cs;
	for( i=0; i<len; i++ ){
		ptr->old_value[i] = sas_w_at( (ptr->data_addr)+(i * 2) ) ;
	}
	printf( "Break on word change set from %lx length %lx\n", ptr->data_addr, ptr->len );
}

LOCAL	void	print_inst_break IFN0()
{
int i;
BPTS *ptr;

	for (i=0;i<inst_break_count;i++) {
		ptr = &inst[i];
		printf("%04lx:%04lx+%04lx %lx\n", ptr->cs, ptr->ip, ptr->len,
			ptr->stop);
	}
}

print_data_break_bytes IFN0()
{
int i;
BPTS *ptr;

	for (i=0;i<data_bytes_break_count;i++) {
		ptr = &data_bytes[i];
		printf("%04lx:%04lx+%04lx %lx\n", ptr->cs, ptr->ip, ptr->len,
			ptr->stop);
	}
}

LOCAL	void	print_host_address_breaks IFN0()
{
int i;
DATA_BPTS *ptr;

	for (i=0;i<host_address_break_count;i++) {
		int j;
		IU8 *old;

		ptr = &host_addresses[i];
		old = (IU8 *)&ptr->old_value[0];
		printf("host address change break Len=%04lx", ptr->len );
		for (j = 0; j < ptr->len; j++)
		{
			if ((j & 0x1f) == 0)
				printf("\n\t%08p:", ptr->data_addr + j);
			printf(" %02x", old[ j ]);
		}
		printf("\n");
	}
}

LOCAL	void	print_data_break_words IFN0()
{
int i;
DATA_BPTS *ptr;

	for (i=0;i<data_words_break_count;i++) {
		ptr = &data_words[i];
		printf("Word change break %08lx Len=%04lx\n", ptr->data_addr, ptr->len);
	}
}

LOCAL	void	print_opcode_break IFN0()
{
int i;

	printf("Note instruction streams are reversed\n");
	for (i=0;i<opcode_break_count;i++)
		printf("%04lx\n", opcode_breaks[i].op);
}

/*
** prints the intx break points set by the "bintx" command
*/
LOCAL	void	print_int_break IFN0()
{
	int i;
	for( i=0; i < int_break_count; i++ )
		printf( "int:%lx AH:%lx\n", int_breaks[i][0], int_breaks[i][1] );
}

LOCAL	void	print_access_break IFN0()
{
int i;

	for(i=0;i<access_break_count;i++)
		printf("%04x\n", access_breaks[i]);
}

valid_for_compress IFN2(word, cs, word, ip)
{
	double_word ea;

	ea = ((((double_word)cs)<<4)+((double_word)ip));
	if (ct_no_rom){
		return ((ea < 0xF0000) || (ea >= 0x100000) );
	}else{
		return (1);
	}
}

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
#ifdef CCPU
#define GLOBAL_PigSynchCount	PigSynchCount
extern IUH PigSynchCount;
#endif	/* !CCPU */
#endif /* CPU_40_STYLE && SYNCH_TIMERS */

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
LOCAL void ct_get_regs IFN1(IU32 *, regs)
{
	/* Pseudo-hex digits 0 1 2 3 4 5 6 7 8 9 : ; < = > ?  */
	/*   represent       0 1 2 3 4 5 6 7 8 9 A B C D E F  */

					/* +ve -ve */
	/* already written EIP */	/*  `   @  */
	/* already written CS  */	/*  a   A  */
	*regs++ = getDS();		/*  b   B  */
	*regs++ = getES();		/*  c   C  */
	*regs++ = getSS();		/*  d   D  */
	*regs++ = getTR_SELECTOR();	/*  e   E  */
	*regs++ = getLDT_SELECTOR();	/*  f   F  */
	*regs++ = getGDT_BASE();	/*  g   G  */
	*regs++ = getIDT_BASE();	/*  h   H  */
	*regs++ = getEAX();		/*  i   I  */
	*regs++ = getEBX();		/*  j   J  */
	*regs++ = getECX();		/*  k   K  */
	*regs++ = getEDX();		/*  l   L  */
	*regs++ = getESI();		/*  m   M  */
	*regs++ = getEDI();		/*  n   N  */
	*regs++ = getESP();		/*  o   O  */
	*regs++ = getEBP();		/*  p   P  */
	*regs++ = getCR0();		/*  q   R  */
	*regs++ = getFS();		/*  r   R  */
	*regs++ = getGS();		/*  s   S  */
	*regs++ = getCR3(); /* PDBR */	/*  t   T  */
	*regs++ = getCR2(); /* PFLA */	/*  u   U  */
	*regs++ = GLOBAL_PigSynchCount;	/*  w   W  */
	*regs++ = host_q_ev_get_count();/*  x   X  */
	*regs++ = getEFLAGS() & 0xFFFFF72A;/*   Y  */
					/*  z   Z  */
					/*  {   [  */
					/*  |   \  */
					/*  }   ]  */
					/*  ~   ^  */
}
#endif /* CPU_40_STYLE && SYNCH_TIMERS */

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
LOCAL IBOOL ct_show_reg_diffs IFN4(FILE *, f, IU32 *, good_regs, IU32 *, bad_regs, IU32 *, old_regs)
{
	IBOOL problem = FALSE;
#define test4(name)				\
    {						\
	if (*good_regs != *bad_regs)		\
	{					\
		fprintf(f, "Register %-6s: should be     %04x is     %04x", name, *good_regs, *bad_regs);	\
		if (*bad_regs == *old_regs)	\
			fprintf(f, " (did not change)\n");	\
		else				\
			fprintf(f, " (previous value was %04x)\n", *old_regs);	\
		problem = TRUE;			\
	}					\
	good_regs++;				\
	bad_regs++;				\
	old_regs++;				\
    }
#define test8(name)				\
    {						\
	if (*good_regs != *bad_regs)		\
	{					\
		fprintf(f, "Register %-6s: should be %08x is %08x", name, *good_regs, *bad_regs);	\
		if (*bad_regs == *old_regs)	\
			fprintf(f, " (did not change)\n");	\
		else				\
			fprintf(f, " (previous value was %08x)\n", *old_regs);	\
		problem = TRUE;			\
	}					\
	good_regs++;				\
	bad_regs++;				\
	old_regs++;				\
    }

	/* The order of the items is defined by ct_get_regs() */
	test8("EIP");
	test4("CS");
	test4("DS");
	test4("ES");
	test4("SS");
	test4("TR");
	test4("LDT");
	test8("GDT_BASE");
	test8("IDT_BASE");
	test8("EAX");
	test8("EBX");
	test8("ECX");
	test8("EDX");
	test8("ESI");
	test8("EDI");
	test8("ESP");
	test8("EBP");
	test8("CR0");

	test4("FS");
	test4("GS");
	test8("PDBR");
	test8("PFLA");
	test8("Synchs");
	test8("QevCtr");
	test8("FLAGS&");
	return (problem);
}
#endif /* CPU_40_STYLE && SYNCH_TIMERS */


#define MAX_REGS ('`' - '@')
LOCAL IU32 *ct_next, *ct_last;

LOCAL void ct_initialise IFN0()
{
#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
	SAVED IU32 regs_a[MAX_REGS], regs_b[MAX_REGS];
	int i;

	for (i = 0; i < MAX_REGS; i++)
	{
		regs_a[i] = regs_b[i] = 0;
	}
	ct_next = regs_b;
	ct_last = regs_a;
	ct_line_num = 0;
#endif /* CPU_40_STYLE && SYNCH_TIMERS */
}

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
LOCAL void ct_make_line IFN3(char *, line, IU32 *, old, IU32 *, new)
{
	IUH diff;
	int i;

	for (i = 0; i < MAX_REGS; i++, old++, new++)
	{
		if (*new == *old)
			continue;
		if (*new > *old)
		{
			if (i == 0)
				; /* This is the usual optimised case -- we use '\n' */
			else
				*line++ = '`' + i;
			diff = *new - *old;
		}
		else
		{
			*line++ = '@' + i;
			diff = *old - *new;
		}
		while (diff)
		{
			/* Dump line as "human" readable pseudo-hex
			 * -- i.e. we dont care that this is backwards
			 */
			*line++ = (diff & 0xf) + '0';
			diff >>= 4;
		}
	}
	*line++ = '\n';
	*line = '\0';
}
#endif /* CPU_40_STYLE && SYNCH_TIMERS */


/* This is the decryption algorithm for the gobblygook produced by the function
 * above. Trust us, it will reconstruct the register set so they can be printed
 * if an error occurs!
 */
#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
LOCAL void ct_read_line IFN3(char *, line, IU32 *, old, IU32 *, new)
{
	IUH diff;
	int i;

	for (i = 0; i < MAX_REGS; i++, old++, new++)
	{
		IBOOL pos;
		IUH val;  /* MUST be unsigned */
		int shift;

		*new = *old;

		if ((*line == '\n') || (*line == 0))
			continue; /* All the rest are the same */

		if ((i == 0) && ((*line - '0') <= 0xF))
		{
			/* A special optimisation for the most common case IP+... */

			pos = TRUE;
			/* Point line at the imaginary '`' which was optimised
			 * when the line was written.
			 */
			line--;
		}
		else if (*line == ('`' + i))
			pos = TRUE;
		else if (*line == ('@' + i))
			pos = FALSE;
		else
			continue;

		/* reverse the pseudo-hex "printing" */
		shift = 0;
		diff = *++line - '0';
		while ((val = (*++line - '0')) <= 0xF)
		{
			shift += 4;
			diff += (val << shift);
		}
		if (pos)
			*new += diff;
		else
			*new -= diff;
	}
}
#endif /* CPU_40_STYLE && SYNCH_TIMERS */


int     tpending = 0;
/*
 * EOR
 */
/*
 * Here it is, check_I, probably one of the most grotty, hacked around functions
 * ever written.  I've (Mike) made an attempt to speed it up a bit, by doing
 * things like vastly reducing the number of accesses to sas (which can be
 * VERY expensive on a 386, and checking whether a for loop needs executing
 * before it starts (might save that variable initialisation!)
 *
 * Please think before you add anything that might slow it down...
 */

#define ACCESS8 ((opcode32 & 0xff00) >> 8)

void check_I IFN0()
{
IU32 i, j;
LIN_ADDR addr;
BPTS *ptr;
DATA_BPTS *dptr;
half_word temp_opcode;
IU16 check_I_cs;
LIN_ADDR check_I_ip;
IU32 opcode32;
IU32 current_opcode;

    /*
     * The guts of the automatic file compare
     */

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
    if (compress_stream || compare_stream)
    {
	char buff[(MAX_REGS*(1+8))+2];
	IU32 *tmp;

	ct_line_num++;
	if ((ct_line_num & 0xfffff) == 0)
	{
		/* Say still working every 1,000,000 instructions. */
		printf(".");
		fflush(stdout);
	}
	if (ct_line_num <= compare_skip)
	{
		char junk[(MAX_REGS*(1+8))+2];

		/* Junk the line, we wre not there yet... */
		if (fgets(junk, sizeof(junk), compare_stream) == NULL)
		{
			printf("End of compare file at instruction %ld.\n", ct_line_num);
			fclose(compare_stream);
			compare_stream = (FILE *)0;
			compare_skip = 0;
			force_yoda();
		}
		if (ct_line_num == compare_skip)
		{
			char junk[(MAX_REGS*(1+8))+2];

			/* Now set up the last from the current state. */
			ct_last[0] = GetInstructionPointer();
			ct_last[1] = getCS();
			ct_get_regs(&ct_last[2]);
			printf("Compare skip point reached, checking enabled...\n");
		}
		return;
	}
	check_I_cs = getCS();
	check_I_ip = GetInstructionPointer();

	ct_next[0] = check_I_ip;
	ct_next[1] = check_I_cs;
	
	ct_get_regs(&ct_next[2]);
	ct_make_line(buff, ct_last, ct_next);

	if (compress_stream)
		fprintf(compress_stream, "%s", buff);
	if (compare_stream)
	{
		char from_trace[(MAX_REGS*(1+8))+2];

		if (fgets(from_trace, sizeof(from_trace), compare_stream) == NULL)
		{
			printf("End of compare file at instruction %ld.\n", ct_line_num);
			fclose(compare_stream);
			compare_stream = (FILE *)0;
			compare_skip = 0;
			force_yoda();
		}
		else
		if (strcmp(buff, from_trace) != 0)
		{
			IU32 ct_fixup[MAX_REGS];

			ct_read_line(from_trace, ct_last, ct_fixup);

			if (ct_show_reg_diffs(stdout, ct_fixup, ct_next, ct_last))
			{
				printf("\nCompress trace does not match at line %ld.\n", ct_line_num);
				/* Force us to agree, else we will fail all future lines! */
				ct_read_line(from_trace, ct_last, ct_next);

				fflush(compress_stream);
				force_yoda();
				/* It is believed (honest guv) that there is sufficient
				 * information in ct_last[] and prev to "correct" the
				 * registers. I.e We can get into Win/E if it kills us!
				 * It is just necessary to copy ct_fixup to ct_next
				 * and stomp on the registers that differ!
				 */
				ct_make_line(from_trace, ct_last, ct_next);
			}
		}	
		
	}	
	tmp = ct_next;
	ct_next = ct_last;
	ct_last = tmp;
	if ((ct_line_num == compare_break) || (ct_line_num == compress_break))
	{
		printf("\ncompare/compress instruction break encountered\n");
		fflush(compress_stream);
		force_yoda();
	}
    }
#endif /* CPU_40_STYLE && SYNCH_TIMERS */

    /*
     * EOR
     */

    check_I_cs = getCS();
    check_I_ip = GetInstructionPointer();
    addr = eff_addr(check_I_cs, check_I_ip);

#ifdef PCLABS_STATS
    log_stats(addr, sas_hw_at(addr), sas_hw_at(addr+1), sas_hw_at(addr+2));
    return;
#endif

    /* Lets get the next 4 bytes of code */

    opcode32 = sas_dw_at(addr);
    temp_opcode = opcode32 & 0xff;

#ifdef NPX
    if (compress_npx) {
	if (((temp_opcode == 0x26 || temp_opcode == 0x2e || temp_opcode == 0x36 || temp_opcode == 0x3e) &&
	    (ACCESS8 >= 0xd8 && ACCESS8 <= 0xdf)) || (temp_opcode >= 0xd8 && temp_opcode <= 0xdf))
	{
	    do_compress_npx(compress_npx);
	}
    }
#endif	/* NPX */

    /*
     * EOR
     */
    if(inst_mix_count)
	add_inst_mix();

	 if (back_trace_flags)
		 btrace(back_trace_flags);

#ifdef MUST_BLOCK_TIMERS
    if (timer_blocked)
    {
		host_graphics_tick();
    }
#endif /* MUST_BLOCK_TIMERS */

    if (head_br_regs != NULL)
    {
	if (check_reg_break())
		vader = 1;
    }

    host_yoda_check_I_extensions();

    if (vader)
    {
	force_yoda();
	vader = 0;
	set_last_address(check_I_cs, check_I_ip);
	return;
    }

    if ((temp_opcode >= 0xE4) && (temp_opcode <= 0xEF)) {
        if(temp_opcode == 0xE4 || temp_opcode == 0xE5 || temp_opcode == 0xE6 || temp_opcode == 0xE7){
	    /* get port from next argument */
	    for (i=0;i<access_break_count;i++){
		    if((access_breaks[i] < 0x100) && (access_breaks[i] == ACCESS8)){
			    force_yoda();
			    set_last_address(check_I_cs, check_I_ip);
			    return;
		    }
	    }
	}
	else if(temp_opcode == 0xEC || temp_opcode == 0xED || temp_opcode == 0xEE || temp_opcode == 0xEF){
	    /* get port from DX */
	    for (i=0;i<access_break_count;i++){
		    if(access_breaks[i] == getDX()){
			    force_yoda();
			    set_last_address(check_I_cs, check_I_ip);
			    return;
		    }
	    }
	}
    }

    if (int_break_count) {
	/*
	** Check for "bintx" breakpoints.
	*/
	IU8 val;

	val = getAH();
	for( i=0; i < int_break_count; i++ ){
    		if( temp_opcode == 0xCC || temp_opcode == 0xCD || temp_opcode == 0xCF ){
			if((int_breaks[i][0] == sas_hw_at(addr+1)) && (int_breaks[i][1]==val)){
				printf( "BINTX break\n" );
				force_yoda();
				set_last_address(check_I_cs, check_I_ip);
				return;
			}
		}
	}
    }

	/*
	** Check for "btf" breakpoint.
	*/
	if (tf_break_enabled && getTF()){
		printf( "BTF break\n" );
		force_yoda();
		set_last_address(check_I_cs, check_I_ip);
		return;
	}

	/*
	** Check for "bse" breakpoint.
	*/
	if (bse_seg != -1 && last_seg != bse_seg && check_I_cs == bse_seg){
		printf( "Break on entry to segment 0x%04x.\n", bse_seg);
		force_yoda();
		last_seg = check_I_cs;
		set_last_address(check_I_cs, check_I_ip);
		return;
	}
	last_seg = check_I_cs;

    /*
    ** Check for NPX opcode break/tracepoints
    */
    if	(bNPX && (
		    (
	 		(temp_opcode == 0x26 ||
			temp_opcode == 0x2e ||
			temp_opcode == 0x36 ||
			temp_opcode == 0x3e) &&
			(ACCESS8 >= 0xd8 && ACCESS8 <= 0xdf)
		    ) ||
		    (temp_opcode == 0x9b)
		      ||
		    (temp_opcode >= 0xd8 && temp_opcode <= 0xdf)
		)
	)
    {
	{
		if( bNPX_stop )
			force_yoda();
		else
			trace("", trace_type);
		set_last_address(check_I_cs, check_I_ip);
		return;
	}
    }

    if (opcode_break_count) {
	/*
	** Check for opcode breakpoints: 8, 16, 24 or 32 bits.
	*/
	for (i = 0; i < opcode_break_count; i++) {

	    /*
	    ** Check the current opcode against the set of requested break opcodes.
	    ** When "b286-2" mode is ON we get a bit more selective.
	    ** This mode breaks upon instructions that do exist on an 8088 but behave
	    ** differently on an 80286.
	    ** These opcodes are:
	    **       0x54 - push sp, pushes decremented sp
	    **       0xd2 and 0xd3 - shift/rotate only uses low 5 bits of shift count in CL
	    **	 0xf6 and 0xf7 - idiv does not cause exception if quotient 80 or 8000
	    ** Attempt to break when one of these opcodes will behave differently not just when
	    ** they are used because there are lots and lots of shifts and rotates.
	    */

	    if ((opcode32 & opcode_breaks[i].mask) == opcode_breaks[i].op){
		    current_opcode = opcode_breaks[i].op;
		    if( b286_2 ){
			    /*
			    ** Is it a b286_2 group opcode ?
			    */
			    switch( current_opcode ){
			    case 0xd2:
			    case 0xd3:
				    /* shift/rotate */
				    if( (getCL()) > 31 ){
					    /*
					    ** either stop at yoda prompt or print out trace info
					    */
					    if( b286_2_stop )
						    force_yoda();
					    else
						    trace("", trace_type);
					    set_last_address(check_I_cs, check_I_ip);
				    }
				    return;
			    case 0xf6:	/* IDIV byte */
				    if( (getAL()) == 0x80 ){
					    if( b286_2_stop )
						    force_yoda();
					    else
						    trace("", trace_type);
					    set_last_address(check_I_cs, check_I_ip);
				    }
				    return;
			    case 0xf7:	/* IDIV word */
				    if( (getAX()) == 0x8000 ){
					    if( b286_2_stop )
						    force_yoda();
					    else
						    trace("", trace_type);
					    set_last_address(check_I_cs, check_I_ip);
				    }
				    return;
			    case 0x54:	/* PUSH SP */
				    if( b286_2_stop )
					    force_yoda();
				    else
					    trace("", trace_type);
				    set_last_address(check_I_cs, check_I_ip);
				    return;
			    default:
				    /*
				    ** Was not a b286-2 instruction so carry on.
				    */
				    break;
			    } /* end SWITCH */
		    }
		    if( b286_1 ){
			    switch( current_opcode ){
			    case 0x60 : /* push all */
			    case 0x61 : /* pop all */
			    case 0x62 : /* bound */
			    case 0x63 : /* arpl */
			    case 0x64 : /* illegal */
			    case 0x65 : /* illegal */
			    case 0x66 : /* illegal */
			    case 0x67 : /* illegal */
			    case 0x68 : /* push imm w */
			    case 0x69 : /* imul imm w */
			    case 0x6a : /* push imm b */
			    case 0x6b : /* imul imm b */
			    case 0x6c : /* ins b */
			    case 0x6d : /* ins w */
			    case 0x6e : /* outs b*/
			    case 0x6f : /* outs w */
			    case 0xc0 : /* shift imm b */
			    case 0xc1 : /* shift imm w */
			    case 0xc8 : /* enter */
			    case 0xc9 : /* leave */
			    case 0x0f : /* protected mode prefix */
			    case 0xf36c : /* rep prefix for ins and outs */
			    case 0xf36d : /* rep prefix for ins and outs */
			    case 0xf36e : /* rep prefix for ins and outs */
			    case 0xf36f : /* rep prefix for ins and outs */
			    case 0x54 : /* push sp, should not really be in this section but is rarely used */
				    if( b286_2_stop )
					    force_yoda();
				    else
					    trace("", trace_type);
				    set_last_address(check_I_cs, check_I_ip);
				    return;
			    default:
				    /*
				    ** Was not a b286-1 instruction so carry on.
				    */
				    break;
			    } /* end SWITCH */
		    }
#ifdef SPC386
		    if (((current_opcode & 0xffff) == 0x20cd)
			&& getPE() && CsIsBig(check_I_cs))
		    {
			    IU16 service;
			    LIN_ADDR nextip;
			    char *name;
			    struct VMM_services *vmm_ptr;

			    /* This is a Windows VMM call break */

			    nextip = GetInstructionPointer();
			    nextip += dasm((char *)-1, check_I_cs, check_I_ip, 0);
			    service = sas_w_at(effective_addr(check_I_cs, nextip));
			    for (vmm_ptr = VMM_services; vmm_ptr->name; vmm_ptr++)
			    {
				    if (vmm_ptr->value == service)
					    break;
			    }
			    printf("Windows VMM Call %04x %s\n", service, vmm_ptr->name);
		    }
#endif /* SPC386 */
		    /*
		    ** A normal break on opcode so lets break then.
		    */
		    if (opcode_breaks[i].stop == 1)
			force_yoda();
		    else
		    {
			int dbs = disable_bkpt;
			disable_bkpt = 1;
			trace("", trace_type);
			if (opcode_breaks[i].stop == 2)
			{
			    LIN_ADDR nextip;

#ifdef SPC386
			    nextip = GetInstructionPointer();
				    nextip += dasm((char *)-1, (word)getCS(), getEIP(), 0);
#else /* SPC386 */
			    nextip = dasm((char *)-1, (word)1, (word)getCS(), (word)getIP(), (word)1);
#endif /* SPC386 */
			    set_inst_break(getCS(), nextip, 1, 0, 1);
			    disable_timer = 0;
			}
			disable_bkpt = dbs;
		    }
		    set_last_address(check_I_cs, check_I_ip);
		    return;
	    }
	}
    }

    if (int_breakpoint && (temp_opcode == 0xCC || temp_opcode == 0xCD || temp_opcode == 0xCE))
    {
	force_yoda();
	set_last_address(check_I_cs, check_I_ip);
	return;
    }

	if(step_count != -1)
		if(step_count <= 1) {
			disable_bkpt = 0;
			step_count = -1;
			force_yoda();
			set_last_address(check_I_cs, check_I_ip);
			return;
		}	
		else
			step_count--;

	for (i=0;i<inst_break_count;i++) {
		ptr = &inst[i];
		if (!(ptr->valid)) continue;
		if(check_I_cs == ptr->cs && check_I_ip == ptr->ip) {
			if(ptr->stop == 1) {
				if (ptr->temp)
				{
					ptr->valid = 0;
					ptr->temp = 0;
					if (ptr++ == &inst[inst_break_count])
						inst_break_count--;
				}
				force_yoda();
				set_last_address(check_I_cs, check_I_ip);
				return;
			}
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
				set_last_address(check_I_cs, check_I_ip);
				return;
			}
		}
	}

	/*
	** Looking for change at address in HOST space over specified range.
	*/

   if (host_address_break_count) {
	for (i=0;i<host_address_break_count;i++) {
		IU8 *old, *now;
		dptr = &host_addresses[i];

		old = (IU8 *)&dptr->old_value[0];
		now = (IU8 *)dptr->data_addr;
		if (memcmp(old, now, dptr->len) != 0)
		{
			for( j=0; j < dptr->len; j++ ){
				if( old[ j ] != now[ j ] ){
					printf( "host address change at %08p old:%2x new:%2x\n",
					       (IU8 *)((dptr->data_addr)+j),
					       old[ j ],
					       now[ j ]
					       );
				}
			}
			if(dptr->stop) {
				force_yoda();
			}
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
			}
			for( j=0; j < dptr->len; j++ )
				old[ j ] = now[ j ];
			set_last_address(check_I_cs, check_I_ip);
			return;
		}
	}
    }

    if (data_words_break_count) {
	for (i=0;i<data_words_break_count;i++) {
		IBOOL changed = FALSE;

		dptr = &data_words[i];
		for( j=0; j < dptr->len; j++ ){
			if( dptr->old_value[ j ] != sas_w_at( dptr->data_addr + (j * 2)) ){
				printf( "Word change at %lx old:%x new:%x\n",
					(LIN_ADDR)((dptr->data_addr)+(j*2)),
 					dptr->old_value[ j ],
					sas_w_at( (dptr->data_addr)+(j*2) )
				);
				changed = TRUE;
			}
		}
		if (changed) {
			if (dptr->stop) {
				force_yoda();
			}
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
			}
			for( j=0; j < dptr->len; j++ )
				dptr->old_value[ j ] = sas_w_at( (dptr->data_addr)+(j*2) );
			set_last_address(check_I_cs, check_I_ip);
			return;
		}
	}
    }
	if(verbose)
		trace("Instruction Trace", trace_type);

	set_last_address(check_I_cs, check_I_ip);
#if defined(A2CPU) || defined(GISP_CPU)
        if (!fast)
        {
			cpu_interrupt (CPU_YODA_INT, 0);
        }
#endif
}

#ifdef DELTA
void    delta_check_I IFN0()
{
    delta_prompt = 1;
    check_I();
    delta_prompt = 0;
}
#endif /* DELTA */


void check_D IFN2(LIN_ADDR, addr, IS32, len)
{
int i;
BPTS *ptr;
	if(disable_bkpt == 1)
		return;
	for (i=0;i<data_bytes_break_count;i++) {
		ptr = &data_bytes[i];
		if ((addr <= ptr->end_addr && addr >= ptr->start_addr ) ||
		    ((addr + len) <= ptr->end_addr && (addr + len) >= ptr->start_addr ) ||
		    (addr < ptr->start_addr && (addr + len) > ptr->end_addr ))  {
			printf("Mem Address : %08x+%04x b\n", addr, len);
			if(ptr->stop == 1)
				force_yoda();
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
			}
		}
	}
/*	for (i=0;i<data_words_break_count;i++) {
		ptr = &data_words[i];
		if(ptr->end_addr > addr && ptr->start_addr <= addr + len) {
			printf("Mem Address : %08x+%04x w\n", addr,len);
			if(ptr->stop == 1)
				force_yoda();
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
			}
		}
	}*/
}

LOCAL	void	print_inst_mix IFN1(int, key)
{
    int i /*,y*/;

#ifndef SFELLOW
    if (out_stream == NULL)
	out_stream = stdout;
#endif /* !SFELLOW */

    if (key != 0)
        printf("Opcode %x has been called %d times\n", key, inst_mix[key]);
    else
    {
        fprintf(trace_file, "Instruction Mix Dump Start:\n");
        for(i = 0; i < INST_MIX_LENGTH; i++)
          if(inst_mix[i] != 0)
            fprintf(trace_file, "%05x %d\n", i, inst_mix[i]);
        fprintf(trace_file, "Instruction Mix Dump End:\n");
    }
}

LOCAL	void	add_inst_mix IFN0()
{
    LIN_ADDR addr;
    addr = eff_addr( getCS(), GetInstructionPointer() );
    inst_mix[(sas_hw_at(addr) << 8) + sas_hw_at(addr + 1)]++;
}

LOCAL	void	cga_test IFN0()
{
#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
    /*
     * Write test pattern to cga
     */

    sys_addr addr;
    char str[80];
    int num_it, j, bytes, mode;
    char ch;

    addr = 0xb8000L;

    printf("Number of iterations: ");
    gets(str);
    sscanf(str,"%d", &num_it);

    if (num_it == 0)
    {
  	reset();
    }
    else
    {
        printf("Number of bytes per write: ");
        gets(str);
        sscanf(str,"%d", &bytes);

   	if (bytes == 1)
	{
            printf("Use single byte function ? [y/n]: ");
            gets(str);
            sscanf(str,"%c", &ch);

     	    if (ch == 'Y' || ch == 'y')
	        mode = 0;
	    else
	        mode = 1;
	}
	else
	    mode = 1;

	setAH(0);
        setAL(4);
        bop(BIOS_VIDEO_IO);

	switch (mode)
	{
	case 0: for(j = 0; j < num_it; j++)
        	{
	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0, 0x4000);
  	    	    addr = addr + 0x2000;

	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0x55, 0x4000);
  	    	    addr = addr + 0x2000;

	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0xff, 0x4000);
  	    	    addr = addr + 0x2000;
       	        }
		break;
	case 1: for(j = 0; j < num_it; j++)
        	{
	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0, 0x4000);
  	    	    addr = addr + 0x2000;

	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0x55, 0x4000);
  	    	    addr = addr + 0x2000;

	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0xff, 0x4000);
  	    	    addr = addr + 0x2000;
       	        }
	        break;
	}
    }
#endif /* SFELLOW */
}

/*
 * Back trace mode
 * set up info to go into back trace cyclic buffer
 * print current back trace buffer
 */

LOCAL	void	do_back_trace IFN0()
{
char	ans[81];
char	file[80];

	printf("back trace: regs, inst, code, flags, CS:IP, print, status, zero ");

#ifdef DELTA
	printf( "last_dest_addr " );
#endif /* DELTA */

	printf( "\n" );
	printf("Enter: r/i/c/f/C/p/s/Z/l/F ? ");
	gets(ans);
	switch (ans[0]) {
		case 'r': back_trace_flags |= DUMP_REG; break;
		case 'i': back_trace_flags |= DUMP_INST; break;
		case 'c': back_trace_flags |= DUMP_CODE; break;
		case 'f': back_trace_flags |= DUMP_FLAGS; break;
		case 'C': back_trace_flags |= DUMP_CSIP; break;
		case 'p': print_back_trace(); break;
		case 's': printf("back trace flags:%x\n", back_trace_flags);
			 if (back_trace_flags & DUMP_REG) printf ("registers\n");
			 if (back_trace_flags & DUMP_INST) printf ("instructions\n");
			 if (back_trace_flags & DUMP_CODE) printf ("code\n");
			 if (back_trace_flags & DUMP_FLAGS) printf ("flags\n");
			 if (back_trace_flags & DUMP_CSIP) printf ("CS:IP\n");
			 break;
		case 'Z': back_trace_flags = 0; break;
		case 'F':
#ifdef SFELLOW
			printf("F option is not supported on Stringfellows.\n");
#else /* SFELLOW */
	        	printf("file to be written to ? ");
		        gets(file);
        		file_back_trace(file);
#endif /* SFELLOW */
        		break;

#ifdef DELTA
      		case 'l': back_trace_flags |= LAST_DEST; break;
#endif /* DELTA */

		default : printf("bad choice\n");
	}
}

intr IFN0()
{
    /* Control-C has been typed !! */

    vader = 1;
}

yoda_intr IFN1(int, signo)
{
#if	defined(CPU_40_STYLE) && !defined(CCPU)

	EnterDebug("Intr");

#endif	/* CPU_40_STYLE && !CCPU */

#ifndef SFELLOW
    printf("Intercepted signal %d\n", signo);
#endif /* !SFELLOW */

	if (trace_file != stdout)
		printf("Output is redirected to a file\n");

	force_yoda();

#if	defined(CPU_40_STYLE) && !defined(CCPU)

	LeaveDebug();

#endif	/* CPU_40_STYLE && !CCPU */
}

#ifdef NPX
LOCAL	void	do_compress_npx IFN1(FILE *, fp)
{
	int	ip = eff_addr(getCS(), GetInstructionPointer() );
	int	i;
	extern  CHAR   *host_get_287_reg_as_string IPT2(int, reg_no, BOOL, in_nex);
	extern	ULONG	get_287_sp IPT0();
	extern	USHORT	get_287_tag_word IPT0();
	extern	ULONG	get_287_status_word IPT0();
	extern	ULONG	get_287_control_word IPT0();

	ULONG	sw287 = get_287_status_word () | ((get_287_sp() & 0x7) << 11);
	ULONG	cw287 = get_287_control_word ();
	ULONG	tw287 = get_287_tag_word();

        double  register_287;
	char buff[256];

#ifdef SPC386
	dasm(buff, (word)getCS(), (IU32)GetInstructionPointer(), SIXTEEN_BIT);
#else
	dasm((char *)0,(word)0,(word)getCS(), (word)GetInstructionPointer(), (word)1);
#endif /* SPC386 */
	fprintf(fp,"%sc%04x s%04x t%04x", buff, cw287, sw287, tw287);
	for (i=0;i<8;i++)
		fprintf(fp," %s", host_get_287_reg_as_string(i, FALSE));
	fprintf(fp,"\n");
}
#endif	/* NPX */

GLOBAL void	da_block IFN3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len)
{
	LIN_ADDR loop, loop1;
	half_word ch;
	LIN_ADDR addr;

	if ((len == 0) || (len == YODA_LEN_UNSPECIFIED)) {
		len=0x100;
		if ((cs==0) && (ip==0)) {
			cs=last_da_cs;
			ip=last_da_ip;
		}
	}
	addr = eff_addr(cs,ip);
	if (len >= 16) {
		for (loop=0; loop<=(len-16); loop+=16) {
			if (loop != len) {
				fprintf(trace_file,"%04x:%04x  ",cs,ip+loop);
			}
			for (loop1=0;loop1<16;loop1++) {
				fprintf(trace_file,"%02x ",sas_hw_at(addr+loop+loop1));
			}
			fprintf(trace_file,"   ");
			for (loop1=0;loop1<16;loop1++) {
				ch=sas_hw_at(addr+loop+loop1);
				if ((ch < 32) || (ch >127)) {
					fprintf(trace_file,".");
				} else {
					fprintf(trace_file,"%c",ch);
				}
			}
			if ((loop+16)<len) {
				fprintf(trace_file,"\n");
			}
		}
		len -= loop;
		ip += loop;
		addr = eff_addr(cs,ip);
	}
	if (len >0) {
		fprintf(trace_file,"%04x:%04x  ",cs,ip);
		for (loop=0;loop<len;loop++) {
			fprintf(trace_file,"%02x ",sas_hw_at(addr+loop));
		}
		for (;loop<16;loop++) {
			fprintf(trace_file,"   ");
		}
		fprintf(trace_file,"   ");
		for (loop=0;loop<len;loop++) {
			ch=sas_hw_at(addr+loop);
			if ((ch < 32) || (ch >127)) {
				fprintf(trace_file,".");
			} else {
				fprintf(trace_file,"%c",ch);
			}
		}
	}
	fprintf(trace_file,"\n");
	ip += len;
	if (ip & 0xf0000L) {
		cs += ((ip & 0xf0000L)>>4);
		ip &= 0xffff;
	}
	cs &= 0xffff;
	last_da_cs=cs;
	last_da_ip=ip;
}
#endif /* nPROD */


/*----------------------------------------------------------------------*/
/*		PCLABS STATS						*/
/*----------------------------------------------------------------------*/
#ifdef PCLABS_STATS

#define N 0
#define Y 1

LOCAL UTINY single_byte_instruction[256] = {
/* 0 */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,N,
/* 1 */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,Y,
/* 2 */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,Y,
/* 3 */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,Y,

/* 4 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* 5 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* 6 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* 7 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,

/* 8 */	N,N,N,N,	N,N,N,N,	N,N,N,N,	N,N,N,N,
/* 9 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* A */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* B */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,

/* C */	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* D */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	N,N,N,N,
/* E */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* F */	Y,Y,Y,Y,	Y,Y,N,N,	Y,Y,Y,Y,	Y,Y,N,N };

FILE *stats_file;

LOCAL ULONG instr_counts[0x10000];
LOCAL ULONG zerof_instr_counts[0x10000];

LOCAL ULONG es_prefixes;
LOCAL ULONG ss_prefixes;
LOCAL ULONG ds_prefixes;
LOCAL ULONG cs_prefixes;
LOCAL ULONG rep_prefixes;
LOCAL ULONG repe_prefixes;
LOCAL ULONG lock_prefixes;

LOCAL BOOL  was_a_conditional_jump;
LOCAL BOOL  was_a_0f;
LOCAL ULONG previous_addr;
LOCAL ULONG previous_index;


LOCAL BOOL is_it_a_conditional_jump IFN1(ULONG, b1)
{
    if (b1 >= 0x70 && b1 <= 0x7f)
	return (TRUE);
    if (b1 >= 0xe0 && b1 <= 0xe3)
	return (TRUE);
    return (FALSE);
}


LOCAL log_stats IFN4(LIN_ADDR, addr, ULONG, b1, ULONG, b2, ULONG, b3)
{
    BOOL is_a_conditional_jump, is_a_0f;
    ULONG index;

    addr = getCS_BASE() + GetInstructionPointer();

    b1 &= 0xff;
    b2 &= 0xff;
    b3 &= 0xff;

   /* determine instruction key */
   /* ------------------------- */

    is_a_0f = FALSE;
    if (b1 == 0x0f)
    {
	/* 0f case */
	/* ------- */

	is_a_0f = TRUE;
	is_a_conditional_jump = FALSE;
        index = (b2 << 8) | b3;
    }
    else if (b1 == 0x26 || b1 == 0x36 || b1 == 0x2E || b1 == 0x3E ||
             b1 == 0xF2 || b1 == 0xF3 || b1 == 0xF0)
    {
	/* prefix case */
	/* ----------- */

	is_a_conditional_jump = is_it_a_conditional_jump(b2);
	if (single_byte_instruction[b2])
	    index = b2 << 8;
	else
	    index = (b2 << 8) | b3;
	switch (b1)
	{
	    case 0x26:
		es_prefixes++;
		break;

	    case 0x36:
		ss_prefixes++;
		break;

	    case 0x2E:
		ds_prefixes++;
		break;

	    case 0x3E:
		cs_prefixes++;
		break;

	    case 0xF2:
		rep_prefixes++;
		break;

	    case 0xF3:
		repe_prefixes++;
		break;

	    case 0xF0:
		lock_prefixes++;
		break;
	}
    }
    else
    {
	/* non prefix case */
	/* --------------- */

	is_a_conditional_jump = is_it_a_conditional_jump(b1);
	if (single_byte_instruction[b1])
	    index = b1 << 8;
	else
	    index = (b1 << 8) | b2;
    }

    if (was_a_conditional_jump)
    {
	if (addr != (previous_addr + 2))
	    previous_index++;
    }
    if (was_a_0f)
        zerof_instr_counts[previous_index]++;
    else
        instr_counts[previous_index]++;
    previous_index = index;
    previous_addr  = addr;
    was_a_conditional_jump = is_a_conditional_jump;
    was_a_0f = is_a_0f;
}


LOCAL clear_stats IFN0()
{
    ULONG i;
    for (i = 0; i < 0x10000; i++)
    {
	instr_counts[i] = 0;
	zerof_instr_counts[i] = 0;
    }

    es_prefixes = 0;
    ss_prefixes = 0;
    ds_prefixes = 0;
    cs_prefixes = 0;
    rep_prefixes = 0;
    repe_prefixes = 0;
    lock_prefixes = 0;
    was_a_conditional_jump = FALSE;
    was_a_0f = FALSE;
}


struct DISPLAY_COMMAND {
    ULONG	command;
    ULONG	from;
    ULONG	to;
    ULONG	number;
    char	*string;
    char	*group;
};

LOCAL char *previous_group;

#define RANGE	1
#define LOCK	2
#define REPNZ	3
#define REP	4
#define SELMEM	5
#define SELREG	6
#define POINT	7
#define ALLMEM	8
#define ALLREG	9
#define ALL	10
#define SEL5	11
#define ES_PREFIX 	12
#define CS_PREFIX 	13
#define SS_PREFIX 	14
#define DS_PREFIX 	15
#define USE_NORMAL	16
#define USE_ZEROF	17
#define SELALL		18
#define FPINVALID	19

LOCAL struct DISPLAY_COMMAND commands[] = {

    	POINT,	0x7001,	0,	112,	"JO_Ib",	"jcc_Taken",
    	POINT,	0x7101,	0,	113,	"JNO_Ib",	"jcc_Taken",
    	POINT,	0x7201,	0,	114,	"JC_Ib",	"jcc_Taken",
    	POINT,	0x7301,	0,	115,	"JNC_Ib",	"jcc_Taken",
    	POINT,	0x7401,	0,	116,	"JZ_Ib",	"jcc_Taken",
    	POINT,	0x7501,	0,	117,	"JNZ_Ib",	"jcc_Taken",
    	POINT,	0x7601,	0,	118,	"JBE_Ib",	"jcc_Taken",
    	POINT,	0x7701,	0,	119,	"JNBE_Ib",	"jcc_Taken",
    	POINT,	0x7801,	0,	120,	"JS_Ib",	"jcc_Taken",
    	POINT,	0x7901,	0,	121,	"JNS_Ib",	"jcc_Taken",
    	POINT,	0x7A01,	0,	122,	"JP_Ib",	"jcc_Taken",
    	POINT,	0x7B01,	0,	123,	"JNP_Ib",	"jcc_Taken",
    	POINT,	0x7C01,	0,	124,	"JL_Ib",	"jcc_Taken",
    	POINT,	0x7D01,	0,	125,	"JNL_Ib",	"jcc_Taken",
    	POINT,	0x7E01,	0,	126,	"JLE_Ib",	"jcc_Taken",
    	POINT,	0x7F01,	0,	127,	"JNLE_Ib",	"jcc_Taken",
	LOCK,	0,	0,	240,	"LOCK_prefix",	"jcc_Taken",
	REPNZ,	0,	0,	242,	"REPNZ_prefix",	"jcc_Taken",
	REP,	0,	0,	243,	"REP_prefix",	"jcc_Taken",

    	POINT,	0x7000,	0x7000,	112,	"JO_Ib",	"jcc_Ntaken",
    	POINT,	0x7100,	0x7100,	113,	"JNO_Ib",	"jcc_Ntaken",
    	POINT,	0x7200,	0x7200,	114,	"JC_Ib",	"jcc_Ntaken",
    	POINT,	0x7300,	0x7300,	115,	"JNC_Ib",	"jcc_Ntaken",
    	POINT,	0x7400,	0x7400,	116,	"JZ_Ib",	"jcc_Ntaken",
    	POINT,	0x7500,	0x7500,	117,	"JNZ_Ib",	"jcc_Ntaken",
    	POINT,	0x7600,	0x7600,	118,	"JBE_Ib",	"jcc_Ntaken",
    	POINT,	0x7700,	0x7700,	119,	"JNBE_Ib",	"jcc_Ntaken",
    	POINT,	0x7800,	0x7800,	120,	"JS_Ib",	"jcc_Ntaken",
    	POINT,	0x7900,	0x7900,	121,	"JNS_Ib",	"jcc_Ntaken",
    	POINT,	0x7A00,	0x7A00,	122,	"JP_Ib",	"jcc_Ntaken",
    	POINT,	0x7B00,	0x7B00,	123,	"JNP_Ib",	"jcc_Ntaken",
    	POINT,	0x7C00,	0x7C00,	124,	"JL_Ib",	"jcc_Ntaken",
    	POINT,	0x7D00,	0x7D00,	125,	"JNL_Ib",	"jcc_Ntaken",
    	POINT,	0x7E00,	0x7E00,	126,	"JLE_Ib",	"jcc_Ntaken",
    	POINT,	0x7F00,	0x7F00,	127,	"JNLE_Ib",	"jcc_Ntaken",

	POINT,	0xE900,	0xE900,	233,	"JMPn_Iw",	"jump",
	POINT,	0xEB00,	0xEB00,	235,	"JMPn_Ib",	"jump",

	SELMEM,	0xFF00,	0x20,	660,	"JMPn_EA",	"jump_in",
	SELREG,	0xFF00,	0x20,	660,	"JMPn_EA",	"jump_in_r",
	POINT,	0xE800,	0,	232,	"CALLn_Iw",	"call",
	SELMEM,	0xFF00,	0x10,	658,	"CALLn_EA",	"call_in",
	SELREG,	0xFF00,	0x10,	658,	"CALLn_EA",	"call_in_r",
	POINT,	0xC200,	0,	194,	"RET_Is",	"ret",
	POINT,	0xC300,	0,	195,	"RETn",		"ret",

	POINT,	0xE001,	0,	224,	"LOOPNZb_Ib",	"loop/jcx_Taken",
	POINT,	0xE101,	0,	225,	"LOOPNb_Ib",	"loop/jcx_Taken",
	POINT,	0xE201,	0,	226,	"LOOP_Ib",	"loop/jcx_Taken",
	POINT,	0xE301,	0,	227,	"JCXZb_Ib",	"loop/jcx_Taken",
	
	POINT,	0xE000,	0,	224,	"LOOPNZb_Ib",	"loop/jcx_NTaken",
	POINT,	0xE100,	0,	225,	"LOOPNb_Ib",	"loop/jcx_NTaken",
	POINT,	0xE200,	0,	226,	"LOOP_Ib",	"loop/jcx_NTaken",
	POINT,	0xE300,	0,	227,	"JCXZb_Ib",	"loop/jcx_NTaken",
	
	ALLMEM,	0x8800,	0,	136,	"MOVb_R_EA",	"mov_r,m",
	ALLMEM,	0x8900,	0,	137,	"MOVw_R_EA",	"mov_r,m",
	POINT,	0xA200,	0,	162,	"MOVb_AL_EA",	"mov_r,m",
	POINT,	0xA300,	0,	163,	"MOVb_AX_EA",	"mov_r,m",

	ALLREG,	0x8600,	0,	134,	"XCHGb_EA_R",	"mov_r,r",
	ALLREG,	0x8700,	0,	135,	"XCHGw_EA_R",	"mov_r,r",
	ALLREG,	0x8800,	0,	136,	"MOVb_R_EA",	"mov_r,r",
	ALLREG,	0x8900,	0,	137,	"MOVw_R_EA",	"mov_r,r",
	ALLREG,	0x8A00,	0,	138,	"MOVb_EA_R",	"mov_r,r",
	ALLREG,	0x8B00,	0,	139,	"MOVw_EA_R",	"mov_r,r",
	POINT,	0x9100,	0,	145,	"XCHG_CX_AX",	"mov_r,r",
	POINT,	0x9200,	0,	146,	"XCHG_DX_AX",	"mov_r,r",
	POINT,	0x9300,	0,	147,	"XCHG_BX_AX",	"mov_r,r",
	POINT,	0x9400,	0,	148,	"XCHG_SP_AX",	"mov_r,r",
	POINT,	0x9500,	0,	149,	"XCHG_BP_AX",	"mov_r,r",
	POINT,	0x9600,	0,	150,	"XCHG_SI_AX",	"mov_r,r",
	POINT,	0x9700,	0,	151,	"XCHG_DI_AX",	"mov_r,r",

	ALLMEM,	0x8600,	0,	134,	"XCHGb_EA_R",	"mov_m,r",
	ALLMEM,	0x8700,	0,	135,	"XCHGw_EA_R",	"mov_m,r",
	ALLMEM,	0x8A00,	0,	138,	"MOVb_EA_R",	"mov_m,r",
	ALLMEM,	0x8B00,	0,	139,	"MOVw_EA_R",	"mov_m,r",
	POINT,	0xA000,	0,	160,	"MOVb_EA_AL",	"mov_m,r",
	POINT,	0xA100,	0,	161,	"MOVw_EA_AX",	"mov_m,r",

	POINT,	0xB000,	0,	176,	"MOVb_Ib_AL",	"mov_i,r",
	POINT,	0xB100,	0,	177,	"MOVb_Ib_CL",	"mov_i,r",
	POINT,	0xB200,	0,	178,	"MOVb_Ib_DL",	"mov_i,r",
	POINT,	0xB300,	0,	179,	"MOVb_Ib_BL",	"mov_i,r",
	POINT,	0xB400,	0,	180,	"MOVb_Ib_AH",	"mov_i,r",
	POINT,	0xB500,	0,	181,	"MOVb_Ib_CH",	"mov_i,r",
	POINT,	0xB600,	0,	182,	"MOVb_Ib_DH",	"mov_i,r",
	POINT,	0xB700,	0,	183,	"MOVb_Ib_BH",	"mov_i,r",
	POINT,	0xB800,	0,	184,	"MOVw_Iw_AX",	"mov_i,r",
	POINT,	0xB900,	0,	185,	"MOVw_Iw_CX",	"mov_i,r",
	POINT,	0xBA00,	0,	186,	"MOVw_Iw_DX",	"mov_i,r",
	POINT,	0xBB00,	0,	187,	"MOVw_Iw_BX",	"mov_i,r",
	POINT,	0xBC00,	0,	188,	"MOVw_Iw_SP",	"mov_i,r",
	POINT,	0xBD00,	0,	189,	"MOVw_Iw_BP",	"mov_i,r",
	POINT,	0xBE00,	0,	190,	"MOVw_Iw_SI",	"mov_i,r",
	POINT,	0xBF00,	0,	191,	"MOVw_Iw_DI",	"mov_i,r",
	SELREG,	0xC600,	0,	198,	"MOVb_Ib_EA",	"mov_i,r",
	SELREG,	0xC700,	0,	199,	"MOVw_Iw_EA",	"mov_i,r",

	SELMEM,	0xC600,	0,	198,	"MOVb_Ib_EA",	"mov_i,m",
	SELMEM,	0xC700,	0,	199,	"MOVw_Iw_EA",	"mov_i,m",

	POINT,	0x5000,	0,	80,	"PUSHw_AX",	"push_r",
	POINT,	0x5100,	0,	81,	"PUSHw_CX",	"push_r",
	POINT,	0x5200,	0,	82,	"PUSHw_DX",	"push_r",
	POINT,	0x5300,	0,	83,	"PUSHw_BX",	"push_r",
	POINT,	0x5400,	0,	84,	"PUSHw_SP",	"push_r",
	POINT,	0x5500,	0,	85,	"PUSHw_BP",	"push_r",
	POINT,	0x5600,	0,	86,	"PUSHw_SI",	"push_r",
	POINT,	0x5700,	0,	87,	"PUSHw_DI",	"push_r",
	SELREG,	0xFF00,	0x30,	662,	"PUSHw_EA",	"push_r",

	SELMEM,	0xFF00,	0x30,	662,	"PUSHw_EA",	"push_m",

	POINT,	0x6800,	0,	104,	"PUSHw_Iw",	"push_i",
	POINT,	0x6A00,	0,	106,	"PUSHb_Ib",	"push_i",

	POINT,	0x5800,	0,	88,	"POPw_AX",	"pop_r",
	POINT,	0x5900,	0,	89,	"POPw_CX",	"pop_r",
	POINT,	0x5A00,	0,	90,	"POPw_DX",	"pop_r",
	POINT,	0x5B00,	0,	91,	"POPw_BX",	"pop_r",
	POINT,	0x5C00,	0,	92,	"POPw_SP",	"pop_r",
	POINT,	0x5D00,	0,	93,	"POPw_BP",	"pop_r",
	POINT,	0x5E00,	0,	94,	"POPw_SI",	"pop_r",
	POINT,	0x5F00,	0,	95,	"POPw_DI",	"pop_r",
	SELREG,	0x8F00,	0x0,	143,	"POPw_EA",	"pop_r",

	SELMEM,	0x8F00,	0x0,	143,	"POPw_EA",	"pop_m",

	ALLMEM,	0x3800,	0,	56,	"CMPb_R_EA",	"cmp_m,r",
	ALLMEM,	0x3900,	0,	57,	"CMPw_R_EA",	"cmp_m,r",
	ALLMEM,	0x3A00,	0,	58,	"CMPb_EA_R",	"cmp_m,r",
	ALLMEM,	0x3B00,	0,	59,	"CMPw_EA_R",	"cmp_m,r",
	ALLMEM, 0x8400,	0,	132,	"TESTb_R_EA",	"cmp_m,r",
	ALLMEM, 0x8500,	0,	133,	"TESTw_R_EA",	"cmp_m,r",

	ALLREG,	0x3800,	0,	56,	"CMPb_R_EA",	"cmp_r,r",
	ALLREG,	0x3900,	0,	57,	"CMPw_R_EA",	"cmp_r,r",
	ALLREG,	0x3A00,	0,	58,	"CMPb_EA_R",	"cmp_r,r",
	ALLREG,	0x3B00,	0,	59,	"CMPw_EA_R",	"cmp_r,r",
	ALLREG, 0x8400,	0,	132,	"TESTb_R_EA",	"cmp_r,r",
	ALLREG, 0x8500,	0,	133,	"TESTw_R_EA",	"cmp_r,r",

	POINT,	0x3C00,	0,	60,	"CMPb_Ib_AL",	"cmp_i,r",
	POINT,	0x3D00,	0,	61,	"CMPw_Iw_AX",	"cmp_i,r",
	POINT,	0xA800,	0,	168,	"TESTb_Ib_AL",	"cmp_i,r",
	POINT,	0xA900,	0,	169,	"TESTw_Iw_AX",	"cmp_i,r",
	SELREG,	0x8000,	0x38,	519,	"CMPb_Ib_EA",	"cmp_i,r",
	SELREG,	0x8100,	0x38,	527,	"CMPw_Iw_EA",	"cmp_i,r",
	SELREG,	0x8300,	0x38,	543,	"CMPw_Ib_EA",	"cmp_i,r",
	SELREG,	0xF600,	0x0,	632,	"TESTb_Ib_EA",	"cmp_i,r",
	SELREG,	0xF700,	0x0,	640,	"TESTw_Iw_EA",	"cmp_i,r",

	SELMEM,	0x8000,	0x38,	519,	"CMPb_Ib_EA",	"cmp_i,m",
	SELMEM,	0x8100,	0x38,	527,	"CMPw_Iw_EA",	"cmp_i,m",
	SELMEM,	0x8300,	0x38,	543,	"CMPw_Ib_EA",	"cmp_i,m",
	SELMEM,	0xF600,	0x0,	632,	"TESTb_Ib_EA",	"cmp_i,m",
	SELMEM,	0xF700,	0x0,	640,	"TESTw_Iw_EA",	"cmp_i,m",
	
	ALLMEM,	0x0200,	0,	2,	"ADDb_EA_R",	"alu_m,r",
	ALLMEM,	0x0300,	0,	3,	"ADDw_EA_R",	"alu_m,r",
	ALLMEM,	0x0A00,	0,	10,	"ORb_EA_R",	"alu_m,r",
	ALLMEM,	0x0B00,	0,	11,	"ORw_EA_R",	"alu_m,r",
	ALLMEM,	0x1200,	0,	18,	"ADCb_EA_R",	"alu_m,r",
	ALLMEM,	0x1300,	0,	19,	"ADCw_EA_R",	"alu_m,r",
	ALLMEM,	0x1A00,	0,	26,	"SBBb_EA_R",	"alu_m,r",
	ALLMEM,	0x1B00,	0,	27,	"SBBw_EA_R",	"alu_m,r",
	ALLMEM,	0x2200,	0,	34,	"ANDb_EA_R",	"alu_m,r",
	ALLMEM,	0x2300,	0,	35,	"ANDw_EA_R",	"alu_m,r",
	ALLMEM,	0x2A00,	0,	42,	"SUBb_EA_R",	"alu_m,r",
	ALLMEM,	0x2B00,	0,	43,	"SUBw_EA_R",	"alu_m,r",
	ALLMEM,	0x3200,	0,	50,	"XORb_EA_R",	"alu_m,r",
	ALLMEM,	0x3300,	0,	51,	"XORw_EA_R",	"alu_m,r",
	
	ALLREG,	0x0000,	0,	0,	"ADDb_R_EA",	"alu_r,r",
	ALLREG,	0x0100,	0,	1,	"ADDw_R_EA",	"alu_r,r",
	ALLREG,	0x0200,	0,	2,	"ADDb_EA_R",	"alu_r,r",
	ALLREG,	0x0300,	0,	3,	"ADDw_EA_R",	"alu_r,r",
	ALLREG,	0x0800,	0,	8,	"ORb_R_EA",	"alu_r,r",
	ALLREG,	0x0900,	0,	9,	"ORw_R_EA",	"alu_r,r",
	ALLREG,	0x0A00,	0,	10,	"ORb_EA_R",	"alu_r,r",
	ALLREG,	0x0B00,	0,	11,	"ORw_EA_R",	"alu_r,r",
	ALLREG,	0x1000,	0,	16,	"ADCb_R_EA",	"alu_r,r",
	ALLREG,	0x1100,	0,	17,	"ADCw_R_EA",	"alu_r,r",
	ALLREG,	0x1200,	0,	18,	"ADCb_EA_R",	"alu_r,r",
	ALLREG,	0x1300,	0,	19,	"ADCw_EA_R",	"alu_r,r",
	ALLREG,	0x1800,	0,	24,	"SBBb_R_EA",	"alu_r,r",
	ALLREG,	0x1900,	0,	25,	"SBBw_R_EA",	"alu_r,r",
	ALLREG,	0x1A00,	0,	26,	"SBBb_EA_R",	"alu_r,r",
	ALLREG,	0x1B00,	0,	27,	"SBBw_EA_R",	"alu_r,r",
	ALLREG,	0x2000,	0,	32,	"ANDb_R_EA",	"alu_r,r",
	ALLREG,	0x2100,	0,	33,	"ANDw_R_EA",	"alu_r,r",
	ALLREG,	0x2200,	0,	34,	"ANDb_EA_R",	"alu_r,r",
	ALLREG,	0x2300,	0,	35,	"ANDw_EA_R",	"alu_r,r",
	ALLREG,	0x2800,	0,	40,	"SUBb_R_EA",	"alu_r,r",
	ALLREG,	0x2900,	0,	41,	"SUBw_R_EA",	"alu_r,r",
	ALLREG,	0x2A00,	0,	42,	"SUBb_EA_R",	"alu_r,r",
	ALLREG,	0x2B00,	0,	43,	"SUBw_EA_R",	"alu_r,r",
	ALLREG,	0x3000,	0,	48,	"XORb_R_EA",	"alu_r,r",
	ALLREG,	0x3100,	0,	49,	"XORw_R_EA",	"alu_r,r",
	ALLREG,	0x3200,	0,	50,	"XORb_EA_R",	"alu_r,r",
	ALLREG,	0x3300,	0,	51,	"XORw_EA_R",	"alu_r,r",

	ALLMEM,	0x0000,	0,	0,	"ADDb_R_EA",	"alu_r,m",
	ALLMEM,	0x0100,	0,	1,	"ADDw_R_EA",	"alu_r,m",
	ALLMEM,	0x0800,	0,	8,	"ORb_R_EA",	"alu_r,m",
	ALLMEM,	0x0900,	0,	9,	"ORw_R_EA",	"alu_r,m",
	ALLMEM,	0x1000,	0,	16,	"ADCb_R_EA",	"alu_r,m",
	ALLMEM,	0x1100,	0,	17,	"ADCw_R_EA",	"alu_r,m",
	ALLMEM,	0x1800,	0,	24,	"SBBb_R_EA",	"alu_r,m",
	ALLMEM,	0x1900,	0,	25,	"SBBw_R_EA",	"alu_r,m",
	ALLMEM,	0x2000,	0,	32,	"ANDb_R_EA",	"alu_r,m",
	ALLMEM,	0x2100,	0,	33,	"ANDw_R_EA",	"alu_r,m",
	ALLMEM,	0x2800,	0,	40,	"SUBb_R_EA",	"alu_r,m",
	ALLMEM,	0x2900,	0,	41,	"SUBw_R_EA",	"alu_r,m",
	ALLMEM,	0x3000,	0,	48,	"XORb_R_EA",	"alu_r,m",
	ALLMEM,	0x3100,	0,	49,	"XORw_R_EA",	"alu_r,m",

	POINT,	0x0400,	0,	4,	"ADDb_Ib_AL",	"alu_i,r",
	POINT,	0x0500,	0,	5,	"ADDw_Iw_AX",	"alu_i,r",
	POINT,	0x0C00,	0,	12,	"ORb_Ib_AL",	"alu_i,r",
	POINT,	0x0D00,	0,	13,	"ORw_Iw_AX",	"alu_i,r",
	POINT,	0x1400,	0,	20,	"ADCb_Ib_AL",	"alu_i,r",
	POINT,	0x1500,	0,	21,	"ADCw_Iw_AX",	"alu_i,r",
	POINT,	0x1C00,	0,	28,	"SBBb_Ib_AL",	"alu_i,r",
	POINT,	0x1D00,	0,	29,	"SBBw_Iw_AX",	"alu_i,r",
	POINT,	0x2400,	0,	36,	"ANDb_Ib_AL",	"alu_i,r",
	POINT,	0x2500,	0,	37,	"ANDw_Iw_AX",	"alu_i,r",
	POINT,	0x2C00,	0,	44,	"SUBb_Ib_AL",	"alu_i,r",
	POINT,	0x2D00,	0,	45,	"SUBw_Iw_AX",	"alu_i,r",
	POINT,	0x3400,	0,	52,	"XORb_Ib_AL",	"alu_i,r",
	POINT,	0x3500,	0,	53,	"XORw_Iw_AX",	"alu_i,r",
	SELREG,	0x8000,	0x0,	512,	"ADDb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x8,	513,	"ORb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x10,	514,	"ADCb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x18,	515,	"SBBb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x20,	516,	"ANDb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x28,	517,	"SUBb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x30,	518,	"XORb_Ib_EA",	"alu_i,r",
	SELREG,	0x8100,	0x0,	520,	"ADDw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x8,	521,	"ORw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x10,	522,	"ADCw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x18,	523,	"SBBw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x20,	524,	"ANDw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x28,	525,	"SUBw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x30,	526,	"XORw_Iw_EA",	"alu_i,r",
	SELREG,	0x8300,	0x0,	536,	"ADDw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x8,	537,	"ORw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x10,	538,	"ADCw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x18,	539,	"SBBw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x20,	540,	"ANDw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x28,	541,	"SUBw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x30,	542,	"XORw_Ib_EA",	"alu_i,r",

	SELMEM,	0x8000,	0x0,	512,	"ADDb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x8,	513,	"ORb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x10,	514,	"ADCb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x18,	515,	"SBBb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x20,	516,	"ANDb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x28,	517,	"SUBb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x30,	518,	"XORb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x0,	520,	"ADDw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x8,	521,	"ORw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x10,	522,	"ADCw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x18,	523,	"SBBw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x20,	524,	"ANDw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x28,	525,	"SUBw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x30,	526,	"XORw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x0,	536,	"ADDw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x8,	537,	"ORw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x10,	538,	"ADCw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x18,	539,	"SBBw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x20,	540,	"ANDw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x28,	541,	"SUBw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x30,	542,	"XORw_Ib_EA",	"alu_i,m",
	
	POINT,	0x4000,	0,	64,	"INCw_AX",	"alu_r",
	POINT,	0x4100,	0,	65,	"INCw_CX",	"alu_r",
	POINT,	0x4200,	0,	66,	"INCw_DX",	"alu_r",
	POINT,	0x4300,	0,	67,	"INCw_BX",	"alu_r",
	POINT,	0x4400,	0,	68,	"INCw_SP",	"alu_r",
	POINT,	0x4500,	0,	69,	"INCw_BP",	"alu_r",
	POINT,	0x4600,	0,	70,	"INCw_SI",	"alu_r",
	POINT,	0x4700,	0,	71,	"INCw_DI",	"alu_r",
	POINT,	0x4800,	0,	72,	"DECw_AX",	"alu_r",
	POINT,	0x4900,	0,	73,	"DECw_CX",	"alu_r",
	POINT,	0x4A00,	0,	74,	"DECw_DX",	"alu_r",
	POINT,	0x4B00,	0,	75,	"DECw_BX",	"alu_r",
	POINT,	0x4C00,	0,	76,	"DECw_SP",	"alu_r",
	POINT,	0x4D00,	0,	77,	"DECw_BP",	"alu_r",
	POINT,	0x4E00,	0,	78,	"DECw_SI",	"alu_r",
	POINT,	0x4F00,	0,	79,	"DECw_DI",	"alu_r",
	POINT,	0x9800,	0,	152,	"CBW",		"alu_r",
	POINT,	0x9900,	0,	153,	"CBD",		"alu_r",
	SELREG,	0xF600,	0x10,	634,	"NOTb_EA",	"alu_r",
	SELREG,	0xF600,	0x18,	635,	"NEGb_EA",	"alu_r",
	SELREG,	0xF700,	0x10,	642,	"NOTw_EA",	"alu_r",
	SELREG,	0xF700,	0x18,	643,	"NEGw_EA",	"alu_r",
	SELREG,	0xFE00,	0x0,	648,	"INCb_EA",	"alu_r",
	SELREG,	0xFE00,	0x8,	649,	"DECb_EA",	"alu_r",
	SELREG,	0xFF00,	0x0,	656,	"INCw_EA",	"alu_r",
	SELREG,	0xFF00,	0x8,	657,	"DECw_EA",	"alu_r",

	SELMEM,	0xF600,	0x10,	634,	"NOTb_EA",	"alu_m",
	SELMEM,	0xF600,	0x18,	635,	"NEGb_EA",	"alu_m",
	SELMEM,	0xF700,	0x10,	642,	"NOTw_EA",	"alu_m",
	SELMEM,	0xF700,	0x18,	643,	"NEGw_EA",	"alu_m",
	SELMEM,	0xFE00,	0x0,	648,	"INCb_EA",	"alu_m",
	SELMEM,	0xFE00,	0x8,	649,	"DECb_EA",	"alu_m",
	SELMEM,	0xFF00,	0x0,	656,	"INCw_EA",	"alu_m",
	SELMEM,	0xFF00,	0x8,	657,	"DECw_EA",	"alu_m",

	ALL,	0x8D00,	0,	141,	"LEAw_EA_R",	"lea",

	POINT,	0x9000,	0,	144,	"NOP",		"nop",

	ALL,	0x6900,	0,	105,	"IMULw_EA_Iw_R","mul",
	ALL,	0x6B00,	0,	107,	"IMULb_EA_Ib_R","mul",
	SELALL,	0xF600,	0x20,	636,	"MULb_EA",	"mul",
	SELALL,	0xF600,	0x28,	637,	"IMULb_EA",	"mul",
	SELALL,	0xF700,	0x20,	644,	"MULw_EA",	"mul",
	SELALL,	0xF700,	0x28,	645,	"IMULw_EA",	"mul",

	SELALL,	0xF600,	0x30,	638,	"DIVb_EA",	"div",
	SELALL,	0xF600,	0x38,	639,	"IDIVb_EA",	"div",
	SELALL,	0xF700,	0x30,	646,	"DIVw_EA",	"div",
	SELALL,	0xF700,	0x38,	647,	"IDIVw_EA",	"div",
	
	POINT,	0x2700,	0,	39,	"DAA",		"ascii/dec",
	POINT,	0x2F00,	0,	47,	"DAS",		"ascii/dec",
	POINT,	0x3700,	0,	55,	"AAA",		"ascii/dec",
	POINT,	0x3F00,	0,	63,	"AAS",		"ascii/dec",
	POINT,	0xD400,	0,	212,	"AAM",		"ascii/dec",
	POINT,	0xD500,	0,	213,	"AAD",		"ascii/dec",
	
	SELALL,	0xD000,	0x00,	600,	"ROLb_1_EA",	"sh_rot_1",
	SELALL,	0xD000,	0x08,	601,	"RORb_1_EA",	"sh_rot_1",
	SELALL,	0xD000,	0x20,	604,	"SHLb_1_EA",	"sh_rot_1",
	SELALL,	0xD000,	0x28,	605,	"SHRb_1_EA",	"sh_rot_1",
	SELALL,	0xD000,	0x38,	607,	"SARb_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x00,	608,	"ROLw_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x08,	609,	"RORw_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x20,	612,	"SHLw_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x28,	613,	"SHRw_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x38,	615,	"SARw_1_EA",	"sh_rot_1",

	SELALL,	0xC000,	0x00,	568,	"ROLb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC000,	0x08,	569,	"RORb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC000,	0x20,	572,	"SHLb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC000,	0x28,	573,	"SHRb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC000,	0x38,	575,	"SARb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x00,	576,	"ROLw_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x08,	577,	"RORw_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x20,	580,	"SHLw_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x28,	581,	"SHRw_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x38,	583,	"SARw_Ib_EA",	"sh_rot_i",

	SELALL,	0xD200,	0x00,	616,	"ROLb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD200,	0x08,	617,	"RORb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD200,	0x20,	620,	"SHLb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD200,	0x28,	621,	"SHRb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD200,	0x38,	623,	"SARb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x00,	624,	"ROLw_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x08,	625,	"RORw_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x20,	628,	"SHLw_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x28,	629,	"SHRw_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x38,	631,	"SARw_CL_EA",	"sh_rot_cl",

	SELALL,	0xD000,	0x10,	602,	"RCLb_1_EA",	"sh_rot_c_1",
	SELALL,	0xD000,	0x18,	603,	"RCRb_1_EA",	"sh_rot_c_1",
	SELALL,	0xD100,	0x10,	610,	"RCLw_1_EA",	"sh_rot_c_1",
	SELALL,	0xD100,	0x18,	611,	"RCRw_1_EA",	"sh_rot_c_1",

	SELALL,	0xC000,	0x10,	570,	"RCLb_Ib_EA",	"sh_rot_c_i",
	SELALL,	0xC000,	0x18,	571,	"RCRb_Ib_EA",	"sh_rot_c_i",
	SELALL,	0xC100,	0x10,	578,	"RCLw_Ib_EA",	"sh_rot_c_i",
	SELALL,	0xC100,	0x18,	579,	"RCRw_Ib_EA",	"sh_rot_c_i",

	SELALL,	0xD200,	0x10,	618,	"RCLb_CL_EA",	"sh_rot_c_cl",
	SELALL,	0xD200,	0x18,	619,	"RCRb_CL_EA",	"sh_rot_c_cl",
	SELALL,	0xD300,	0x10,	626,	"RCLw_CL_EA",	"sh_rot_c_cl",
	SELALL,	0xD300,	0x18,	627,	"RCRw_CL_EA",	"sh_rot_c_cl",

	POINT,	0xCC00,	0,	204,	"INT_3",	"int",
	POINT,	0xCD00,	0,	205,	"INT_TYPE",	"int",
	POINT,	0xCE00,	0,	206,	"INTO",		"int",
	POINT,	0xCF00,	0,	207,	"IRETf",	"int",
	
	POINT,	0x9E00,	0,	158,	"SAHF",		"flag",
	POINT,	0x9F00,	0,	159,	"LAHF",		"flag",
	POINT,	0xF500,	0,	245,	"CMC",		"flag",
	POINT,	0xF800,	0,	248,	"CLC",		"flag",
	POINT,	0xF900,	0,	249,	"STC",		"flag",
	POINT,	0xFC00,	0,	252,	"CLD",		"flag",
	POINT,	0xFD00,	0,	253,	"STD",		"flag",

	SELALL,	0xD800,	0x00,	688,	"FADDs_EA",	"fp",
	SELALL,	0xD800,	0x08,	689,	"FMULs_EA",	"fp",
	SELALL,	0xD800,	0x10,	690,	"FCOMs_EA",	"fp",
	SELALL,	0xD800,	0x18,	691,	"FCOMPs_EA",	"fp",
	SELALL,	0xD800,	0x20,	692,	"FSUBs_EA",	"fp",
	SELALL,	0xD800,	0x28,	693,	"FSUBRs_EA",	"fp",
	SELALL,	0xD800,	0x30,	694,	"FDIVs_EA",	"fp",
	SELALL,	0xD800,	0x38,	695,	"FDIVRs_EA",	"fp",

	SEL5,	0xD800,	0xC0,	696,	"FADD_Si_S0",	"fp",
	SEL5,	0xD800,	0xC8,	697,	"FMUL_Si_S0",	"fp",
	SEL5,	0xD800,	0xD0,	698,	"FCOM_Si_S0",	"fp",
	SEL5,	0xD800,	0xD8,	699,	"FCOMP_Si_S0",	"fp",
	SEL5,	0xD800,	0xE0,	700,	"FSUB_Si_S0",	"fp",
	SEL5,	0xD800,	0xE8,	701,	"FSUBR_Si_S0",	"fp",
	SEL5,	0xD800,	0xF0,	702,	"FDIV_Si_S0",	"fp",
	SEL5,	0xD800,	0xF8,	703,	"FDIVR_Si_S0",	"fp",

	SELALL,	0xDA00,	0x00,	704,	"FIADDs_EA",	"fp",
	SELALL,	0xDA00,	0x08,	705,	"FIMULs_EA",	"fp",
	SELALL,	0xDA00,	0x10,	706,	"FICOMs_EA",	"fp",
	SELALL,	0xDA00,	0x18,	707,	"FICOMPs_EA",	"fp",
	SELALL,	0xDA00,	0x20,	708,	"FISUBs_EA",	"fp",
	SELALL,	0xDA00,	0x28,	709,	"FISUBRs_EA",	"fp",
	SELALL,	0xDA00,	0x30,	710,	"FIDIVs_EA",	"fp",
	SELALL,	0xDA00,	0x38,	711,	"FIDIVRs_EA",	"fp",

	FPINVALID,0,	0,	712,	"FP_INVALID",	"fp",

	POINT,	0xDED9,	0,	713,	"FUCOMPP",	"fp",
	
	SELALL,	0xDB00,	0x00,	720,	"FILDs_EA",	"fp",
	SELALL,	0xDB00,	0x10,	722,	"FISTs_EA",	"fp",
	SELALL,	0xDB00,	0x18,	723,	"FISTPs_EA",	"fp",
	SELALL,	0xDB00,	0x28,	725,	"FLDer_EA",	"fp",
	SELALL,	0xDB00,	0x38,	727,	"FSTPer_EA",	"fp",

	POINT,	0xDBE0,	0,	728,	"FENI_1",	"fp",
	POINT,	0xDBE1,	0,	729,	"FDISI_2",	"fp",
	POINT,	0xDBE2,	0,	730,	"FCLEX",	"fp",
	POINT,	0xDBE3,	0,	731,	"FINIT",	"fp",
	POINT,	0xDBE4,	0,	732,	"FSETPM",	"fp",

	SELALL,	0xDC00,	0x00,	736,	"FADDl_EA",	"fp",
	SELALL,	0xDC00,	0x08,	737,	"FMULl_EA",	"fp",
	SELALL,	0xDC00,	0x10,	738,	"FCOMl_EA",	"fp",
	SELALL,	0xDC00,	0x18,	739,	"FCOMPl_EA",	"fp",
	SELALL,	0xDC00,	0x20,	740,	"FSUBl_EA",	"fp",
	SELALL,	0xDC00,	0x28,	741,	"FSUBRl_EA",	"fp",
	SELALL,	0xDC00,	0x30,	742,	"FDIVl_EA",	"fp",
	SELALL,	0xDC00,	0x38,	743,	"FDIVRl_EA",	"fp",

	SEL5,	0xDC00,	0xC0,	744,	"FADD_S0_Si",	"fp",
	SEL5,	0xDC00,	0xC8,	745,	"FMUL_S0_Si",	"fp",
	SEL5,	0xDC00,	0xD0,	746,	"FCOM_2_S0_Si","fp",
	SEL5,	0xDC00,	0xD8,	747,	"FCOMP_3_S0_Si","fp",
	SEL5,	0xDC00,	0xE0,	748,	"FSUB_S0_Si",	"fp",
	SEL5,	0xDC00,	0xE8,	749,	"FSUBR_S0_Si",	"fp",
	SEL5,	0xDC00,	0xF0,	750,	"FDIV_S0_Si",	"fp",
	SEL5,	0xDC00,	0xF8,	751,	"FDIVR_S0_Si",	"fp",
		
	SELALL,	0xDD00,	0x00,	752,	"FLDl_EA",	"fp",
	SELALL,	0xDD00,	0x10,	754,	"FSTl_EA",	"fp",
	SELALL,	0xDD00,	0x18,	755,	"FSTPl_EA",	"fp",
	SELALL,	0xDD00,	0x20,	756,	"FRSTOR_EA",	"fp",
	SELALL,	0xDD00,	0x30,	758,	"FSAVE_EA",	"fp",
	SELALL,	0xDD00,	0x38,	759,	"FSTSW_EA",	"fp",

	SEL5,	0xDD00,	0xC0,	760,	"FFREE_Si",	"fp",
	SEL5,	0xDD00,	0xC8,	761,	"FXCH_4_Si_S0",	"fp",
	SEL5,	0xDD00,	0xD0,	762,	"FSTl_Si",	"fp",
	SEL5,	0xDD00,	0xD8,	763,	"FSTPl_Si",	"fp",
	
	SELALL,	0xDE00,	0x00,	768,	"FIADDw_EA",	"fp",
	SELALL,	0xDE00,	0x08,	769,	"FIMULw_EA",	"fp",
	SELALL,	0xDE00,	0x10,	770,	"FICOMw_EA",	"fp",
	SELALL,	0xDE00,	0x18,	771,	"FICOMPw_EA",	"fp",
	SELALL,	0xDE00,	0x20,	772,	"FISUBw_EA",	"fp",
	SELALL,	0xDE00,	0x28,	773,	"FISUBRw_EA",	"fp",
	SELALL,	0xDE00,	0x30,	774,	"FIDIVw_EA",	"fp",
	SELALL,	0xDE00,	0x38,	775,	"FIDIVRw_EA",	"fp",
	
	SEL5,	0xDE00,	0xC0,	776,	"FADDP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xC8,	777,	"FMULP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xD0,	778,	"FCOMP_5_Si_S0","fp",
	POINT,	0xDED9,	0,	779,	"FCOMPP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xE0,	780,	"FSUBRP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xE8,	781,	"FSUBP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xF0,	782,	"FDIVRP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xF8,	783,	"FDIVP_Si_S0",	"fp",
	
	SELALL,	0xDF00,	0x00,	784,	"FILDw_EA",	"fp",
	SELALL,	0xDF00,	0x10,	786,	"FISTw_EA",	"fp",
	SELALL,	0xDF00,	0x18,	787,	"FISTPw_EA",	"fp",
	SELALL,	0xDF00,	0x20,	788,	"FBLD_EA",	"fp",
	SELALL,	0xDF00,	0x28,	789,	"FILDl_EA",	"fp",
	SELALL,	0xDF00,	0x30,	790,	"FBSTP_EA",	"fp",
	SELALL,	0xDF00,	0x38,	791,	"FISTPl_EA",	"fp",

	SEL5,	0xDF00,	0xC0,	792,	"FFREE_6_Si",	"fp",
	SEL5,	0xDF00,	0xC8,	793,	"FXCH_7_S0_Si",	"fp",
	SEL5,	0xDF00,	0xD0,	794,	"FSTP_8_Si","fp",
	SEL5,	0xDF00,	0xD8,	795,	"FSTP_9_Si","fp",
	POINT,	0xDFE0,	0,	796,	"FSTSW_AX",	"fp",

	SELALL,	0xD900,	0x00,	800,	"FLDs_EA",	"fp",
	SELALL,	0xD900,	0x10,	802,	"FSTs_EA",	"fp",
	SELALL,	0xD900,	0x18,	803,	"FSTPs_EA",	"fp",
	SELALL,	0xD900,	0x20,	804,	"FLDENV_EA",	"fp",
	SELALL,	0xD900,	0x28,	805,	"FLDCW_EA",	"fp",
	SELALL,	0xD900,	0x30,	806,	"FSTENV_EA",	"fp",
	SELALL,	0xD900,	0x38,	807,	"FSTCW_EA",	"fp",

	SEL5,	0xD900,	0xC0,	808,	"FLD_Si",	"fp",
	SEL5,	0xD900,	0xC8,	809,	"FXCH_Si_S0",	"fp",
	POINT,	0xD9D0,	0,	810,	"FNOP",		"fp",
	SEL5,	0xD900,	0xD8,	811,	"FSTP_1_Si",	"fp",
	POINT,	0xD9E0,	0,	812,	"FCHS",		"fp",
	POINT,	0xD9E1,	0,	813,	"FABS",		"fp",
	POINT,	0xD9E4,	0,	814,	"FTST",		"fp",
	POINT,	0xD9E5,	0,	815,	"FXAM",		"fp",
	POINT,	0xD9E8,	0,	816,	"FLD1",		"fp",
	POINT,	0xD9E9,	0,	817,	"FLDL2T",	"fp",
	POINT,	0xD9EA,	0,	818,	"FLDL2E",	"fp",
	POINT,	0xD9EB,	0,	819,	"FLDLPI",	"fp",
	POINT,	0xD9EC,	0,	820,	"FLDLG2",	"fp",
	POINT,	0xD9ED,	0,	821,	"FLDLN2",	"fp",
	POINT,	0xD9EE,	0,	822,	"FLDZ",		"fp",
	POINT,	0xD9F0,	0,	824,	"F2XM1",	"fp",
	POINT,	0xD9F1,	0,	825,	"FYL2X",	"fp",
	POINT,	0xD9F2,	0,	826,	"FPTAN",	"fp",
	POINT,	0xD9F3,	0,	827,	"FPATAN",	"fp",
	POINT,	0xD9F4,	0,	828,	"FXTRACT",	"fp",
	POINT,	0xD9F5,	0,	829,	"FPREM1",	"fp",
	POINT,	0xD9F6,	0,	830,	"FDECSTP",	"fp",
	POINT,	0xD9F7,	0,	831,	"FINCSTP",	"fp",
	POINT,	0xD9F8,	0,	832,	"FPREM",	"fp",
	POINT,	0xD9F9,	0,	833,	"FYL2XP1",	"fp",
	POINT,	0xD9FA,	0,	834,	"FSQRT",	"fp",
	POINT,	0xD9FB,	0,	835,	"FSINCOS",	"fp",
	POINT,	0xD9FC,	0,	836,	"FRNDINT",	"fp",
	POINT,	0xD9FD,	0,	837,	"F_SCALE",	"fp",
	POINT,	0xD9FE,	0,	838,	"FSIN",		"fp",
	POINT,	0xD9FF,	0,	839,	"FCOS",		"fp",

	POINT,	0x9B00,	0,	155,	"FWAIT",	"fwait",

	POINT,	0xA400,	0,	164,	"MOVSb",	"movs",
	POINT,	0xA500,	0,	165,	"MOVSw",	"movs",

	POINT,	0xA600,	0,	166,	"CMPSb",	"cmps",
	POINT,	0xA700,	0,	167,	"CMPSw",	"cmps",

	POINT,	0xAE00,	0,	174,	"SCASb",	"scas",
	POINT,	0xAF00,	0,	175,	"SCASw",	"scas",

	POINT,	0xAA00,	0,	170,	"STOSb",	"stos",
	POINT,	0xAB00,	0,	171,	"STOSw",	"stos",

	POINT,	0xAC00,	0,	172,	"LODSb",	"lods",
	POINT,	0xAD00,	0,	173,	"LODSw",	"lods",

	POINT,	0x6C00,	0,	108,	"INSb",		"ins",
	POINT,	0x6D00,	0,	109,	"INSw",		"ins",

	POINT,	0x6E00,	0,	110,	"OUTSb",	"outs",
	POINT,	0x6F00,	0,	111,	"OUTSw",	"outs",

	POINT,	0xD700,	0,	215,	"XLATb",	"xlat",

	POINT,	0xEA00,	0,	234,	"JMPf_Ip",	"jmp_far",

	POINT,	0x9A00,	0,	154,	"CALLf_Ip",	"call_far",

	POINT,	0xCA00,	0,	202,	"RETf_Is",	"ret_far",
	POINT,	0xCB00,	0,	203,	"RETf",		"ret_far",

	SELMEM,	0xFF00,	0x28,	661,	"JMPf_EA",	"jmp_far_in",

	SELMEM,	0xFF00,	0x18,	659,	"CALLf_EA",	"call_far_in",

	POINT,	0x0600,	0,	6,	"PUSH_ES",	"push_s",
	POINT,	0x0E00,	0,	14,	"PUSH_CS",	"push_s",
	POINT,	0x1600,	0,	22,	"PUSH_SS",	"push_s",
	POINT,	0x1E00,	0,	30,	"PUSH_DS",	"push_s",

	POINT,	0x0700,	0,	6,	"POP_ES",	"pop_s",
	POINT,	0x1700,	0,	22,	"POP_SS",	"pop_s",
	POINT,	0x1F00,	0,	30,	"POP_DS",	"pop_s",

	SELREG,	0x8C00,	0x00,	544,	"MOVw_ES_EA",	"mov_s,r",
	SELREG,	0x8C00,	0x08,	545,	"MOVw_CS_EA",	"mov_s,r",
	SELREG,	0x8C00,	0x10,	546,	"MOVw_SS_EA",	"mov_s,r",
	SELREG,	0x8C00,	0x18,	547,	"MOVw_DS_EA",	"mov_s,r",

	SELREG,	0x8E00,	0x00,	552,	"MOVw_EA_ES",	"mov_r,s",
	SELREG,	0x8E00,	0x10,	554,	"MOVw_EA_SS",	"mov_r,s",
	SELREG,	0x8E00,	0x18,	555,	"MOVw_EA_DS",	"mov_r,s",

	SELMEM,	0x8E00,	0x00,	552,	"MOVw_EA_ES",	"mov_m,s",
	SELMEM,	0x8E00,	0x10,	554,	"MOVw_EA_SS",	"mov_m,s",
	SELMEM,	0x8E00,	0x18,	555,	"MOVw_EA_DS",	"mov_m,s",

	SELMEM,	0x8C00,	0x00,	999,	"MOVw_ES_EA",	"mov_s,m",
	SELMEM,	0x8C00,	0x08,	999,	"MOVw_CS_EA",	"mov_s,m",
	SELMEM,	0x8C00,	0x10,	999,	"MOVw_SS_EA",	"mov_s,m",
	SELMEM,	0x8C00,	0x18,	999,	"MOVw_DS_EA",	"mov_s,m",

	ALLMEM,	0xC400,	0,	196,	"LESw_EA_R",	"mov_m,p",
	ALLMEM,	0xC500,	0,	197,	"LDSw_EA_R",	"mov_m,p",

	POINT,	0xC800,	0,	200,	"ENTER",	"enter",
	POINT,	0xC900,	0,	201,	"LEAVE",	"leave",

	POINT,	0xE400,	0,	228,	"INb_Ib_AL",	"io",
	POINT,	0xE500,	0,	229,	"INw_Iw_AX",	"io",
	POINT,	0xE600,	0,	230,	"OUTb_Ib_AL",	"io",
	POINT,	0xE700,	0,	231,	"OUTw_Iw_AX",	"io",
	POINT,	0xEC00,	0,	236,	"INb_DX_AL",	"io",
	POINT,	0xED00,	0,	237,	"INw_DX_AX",	"io",
	POINT,	0xEE00,	0,	238,	"OUTb_DX_AL",	"io",
	POINT,	0xEF00,	0,	239,	"OUTw_DX_AX",	"io",

	POINT,	0x9C00,	0,	156,	"PUSHF",	"VM_sensitive",
	POINT,	0x9D00,	0,	157,	"POPF",		"VM_sensitive",
	POINT,	0xFA00,	0,	250,	"CLI",		"VM_sensitive",
	POINT,	0xFB00,	0,	251,	"STI",		"VM_sensitive",

	ES_PREFIX,0,	0,	38,	"ES_prefix",	"other86",
	DS_PREFIX,0,	0,	46,	"DS_prefix",	"other86",
	SS_PREFIX,0,	0,	54,	"SS_prefix",	"other86",
	CS_PREFIX,0,	0,	62,	"CS_prefix",	"other86",
	POINT,	0x6000,	0,	96,	"PUSHA",	"other86",
	POINT,	0x6100,	0,	97,	"POPA",		"other86",
	ALLMEM,	0x6200,	0,	98,	"BOUND",	"other86",

	POINT,	0x6300,	0,	99,	"ARPL",		"other286",

	USE_ZEROF,0,	0,	0,	"",		"",

	ALL,	0x0200,	0,	258,	"LARw_EA_R",	"other286",
	ALL,	0x0300,	0,	259,	"LSLw_EA_R",	"other286",
	ALL,	0x0600,	0,	262,	"CLTS",		"other286",
	SELALL,	0x0000,	0x00,	664,	"SLDTw_EA",	"other286",
	SELALL,	0x0000,	0x08,	665,	"STRw_EA",	"other286",
	SELALL,	0x0000,	0x10,	666,	"LLDTw_EA",	"other286",
	SELALL,	0x0000,	0x18,	667,	"LTRw_EA",	"other286",
	SELALL,	0x0000,	0x20,	668,	"VERRw_EA",	"other286",
	SELALL,	0x0000,	0x28,	669,	"VERWw_EA",	"other286",
	SELALL,	0x0100,	0x00,	672,	"SGDTw_EA",	"other286",
	SELALL,	0x0100,	0x08,	673,	"SIDTw_EA",	"other286",
	SELALL,	0x0100,	0x10,	674,	"LGDTw_EA",	"other286",
	SELALL,	0x0100,	0x18,	675,	"LIDTw_EA",	"other286",
	SELALL,	0x0100,	0x20,	676,	"SMSWw_EA",	"other286",
	SELALL,	0x0100,	0x30,	678,	"LMSWw_EA",	"other286",
	ALL,	0x0500,	0,	999,	"LOADALL",	"other286",

	USE_NORMAL,0,	0,	0,	"",		"",

    	RANGE,	0x7000,	0x7001,	112,	"JO_Ib",	".jcc",
    	RANGE,	0x7100,	0x7101,	113,	"JNO_Ib",	".jcc",
    	RANGE,	0x7200,	0x7201,	114,	"JC_Ib",	".jcc",
    	RANGE,	0x7300,	0x7301,	115,	"JNC_Ib",	".jcc",
    	RANGE,	0x7400,	0x7401,	116,	"JZ_Ib",	".jcc",
    	RANGE,	0x7500,	0x7501,	117,	"JNZ_Ib",	".jcc",
    	RANGE,	0x7600,	0x7601,	118,	"JBE_Ib",	".jcc",
    	RANGE,	0x7700,	0x7701,	119,	"JNBE_Ib",	".jcc",
    	RANGE,	0x7800,	0x7801,	120,	"JS_Ib",	".jcc",
    	RANGE,	0x7900,	0x7901,	121,	"JNS_Ib",	".jcc",
    	RANGE,	0x7A00,	0x7A01,	122,	"JP_Ib",	".jcc",
    	RANGE,	0x7B00,	0x7B01,	123,	"JNP_Ib",	".jcc",
    	RANGE,	0x7C00,	0x7C01,	124,	"JL_Ib",	".jcc",
    	RANGE,	0x7D00,	0x7D01,	125,	"JNL_Ib",	".jcc",
    	RANGE,	0x7E00,	0x7E01,	126,	"JLE_Ib",	".jcc",
    	RANGE,	0x7F00,	0x7F01,	127,	"JNLE_Ib",	".jcc",
	
	RANGE,	0xE000,	0xE001,	224,	"LOOPNZb_Ib",	".loop",
	RANGE,	0xE100,	0xE101,	225,	"LOOPNb_Ib",	".loop",
	RANGE,	0xE200,	0xE201,	226,	"LOOP_Ib",	".loop",
	RANGE,	0xE300,	0xE301,	227,	"JCXZb_Ib",	".loop",

	POINT,	0x9A00,	0,	154,	"CALLf_Ip",	".genT",
	POINT,	0xC200,	0,	194,	"RET_Is",	".genT",
	POINT,	0xC300,	0,	195,	"RETn",		".genT",
	POINT,	0xCA00,	0,	202,	"RETf_Is",	".genT",
	POINT,	0xCB00,	0,	203,	"RETf",		".genT",
	POINT,	0xCC00,	0,	204,	"INT_3",	".genT",
	POINT,	0xCD00,	0,	205,	"INT_TYPE",	".genT",
	POINT,	0xCE00,	0,	206,	"INTO",		".genT",
	POINT,	0xCF00,	0,	207,	"IRETf",	".genT",
	POINT,	0xE800,	0,	232,	"CALLn_Iw",	".genT",
	POINT,	0xE900,	0xE900,	233,	"JMPn_Iw",	".genT",
	POINT,	0xEA00,	0,	234,	"JMPf_Ip",	".genT",
	POINT,	0xEB00,	0xEB00,	235,	"JMPn_Ib",	".genT",
	SELALL,	0xFF00,	0x10,	658,	"CALLn_EA",	".genT",
	SELMEM,	0xFF00,	0x18,	659,	"CALLf_EA",	".genT",
	SELALL,	0xFF00,	0x20,	660,	"JMPn_EA",	".genT",
	SELMEM,	0xFF00,	0x28,	661,	"JMPf_EA",	".genT",

	0,	0,	0,	0,	"",		""};

LOCAL print_stats IFN0()
{
    ULONG i, j, total, sub_total, super_total, command, from, to, item;
    char *group;
    ULONG *counts_array;

    previous_group = "";
    counts_array = &instr_counts[0];
    item = 0;
    total = 0;
    super_total = 0;
    while (commands[item].command != 0)
    {
	command = commands[item].command;
	from = commands[item].from;
	to   = commands[item].to;
	group = commands[item].group;
	switch (command)
	{
	    case USE_NORMAL:
		counts_array = &instr_counts[0];
		break;

	    case USE_ZEROF:
		counts_array = &zerof_instr_counts[0];
		break;

	    case RANGE:
		sub_total = 0;
		for (i = from; i <= to; i++)
		    sub_total += counts_array[i];
		break;

	    case ES_PREFIX:
		sub_total = es_prefixes;
		break;

	    case CS_PREFIX:
		sub_total = cs_prefixes;
		break;

	    case SS_PREFIX:
		sub_total = ss_prefixes;
		break;

	    case DS_PREFIX:
		sub_total = ds_prefixes;
		break;

	    case LOCK:
		sub_total = lock_prefixes;
		break;

	    case REPNZ:
		sub_total = repe_prefixes;
		break;

	    case REP:
		sub_total = rep_prefixes;
		break;

	    case POINT:
		sub_total = counts_array[from];
		break;

	    case SELMEM:
		sub_total = 0;
		for (i = 0; i < 192; i++)
		    if ((i & 0x38) == to)
			sub_total += counts_array[from + i];
		break;

	    case ALLMEM:
		sub_total = 0;
		for (i = 0; i < 192; i++)
		    sub_total += counts_array[from + i];
		break;

	    case SELREG:
		sub_total = 0;
		for (i = 192; i < 256; i++)
		    if ((i & 0x38) == to)
			sub_total += counts_array[from + i];
		break;

	    case SELALL:
		sub_total = 0;
		for (i = 0; i < 256; i++)
		    if ((i & 0x38) == to)
			sub_total += counts_array[from + i];
		break;

	    case SEL5:
		sub_total = 0;
		for (i = 0; i < 256; i++)
		    if ((i & 0xF8) == to)
			sub_total += counts_array[from + i];
		break;

	    case ALLREG:
		sub_total = 0;
		for (i = 192; i < 256; i++)
		    sub_total += counts_array[from + i];
		break;

	    case ALL:
		sub_total = 0;
		for (i = 0; i < 256; i++)
		    sub_total += counts_array[from + i];
		break;

	    case FPINVALID:
		sub_total = 0;
		break;

	    default:
		printf("Unknown command\n");
	}

#if 0
	switch (command)
	{
	    case RANGE:
		for (i = from; i <= to; i++)
		    counts_array[i] = 0;
		break;

	    case POINT:
		counts_array[from] = 0;
		break;

	    case SELMEM:
		for (i = 0; i < 192; i++)
		    if ((i & 0x38) == to)
			counts_array[from + i] = 0;
		break;

	    case ALLMEM:
		for (i = 0; i < 192; i++)
		    counts_array[from + i] = 0;
		break;

	    case SELREG:
		for (i = 192; i < 256; i++)
		    if ((i & 0x38) == to)
			counts_array[from + i] = 0;
		break;

	    case SELALL:
		for (i = 0; i < 256; i++)
		    if ((i & 0x38) == to)
			counts_array[from + i] = 0;
		break;

	    case SEL5:
		for (i = 0; i < 256; i++)
		    if ((i & 0xF8) == to)
			counts_array[from + i] = 0;
		break;

	    case ALLREG:
		for (i = 192; i < 256; i++)
		    counts_array[from + i] = 0;
		break;

	    case ALL:
		for (i = 0; i < 256; i++)
		    counts_array[from + i] = 0;
		break;

	    default:
		printf("Unknown command\n");
	}
#endif

	if (command != USE_NORMAL && command != USE_ZEROF)
	{
	    if (strcmp(group, previous_group) != 0)
	    {
		if (item != 0)
		    fprintf(stats_file, "%s TOTAL = %d\n", previous_group, total);
		super_total += total;
		total = 0;
	        fprintf(stats_file, "\n%s\n", group);
	        previous_group = group;
	    }
	    total += sub_total;
	    fprintf(stats_file,"\t%d\t%-20s%d\n", commands[item].number,
				     commands[item].string,
			 	     sub_total);
	}

	item++;
    }
    fprintf(stats_file,"%s TOTAL = %d\n", previous_group, total);
    fprintf(stats_file,"\nGRAND TOTAL = %d\n", super_total);

#if 0
    for (i = 0; i < 0x10000; i++)
    {
	if (instr_counts[i])
	    printf("%d normals at %x\n", instr_counts[i], i);
	if (zerof_instr_counts[i])
	    printf("%d zerofs at %x\n", zerof_instr_counts[i], i);
    }
#endif
}

LOCAL char stats_file_name[20];
LOCAL ULONG stats_file_number;

GLOBAL start_pclabs IFN0()
{
    IMPORT int tick_multiple;
    do_condition_checks = 1;
    tick_multiple = 10;
    clear_stats();
    sprintf(&stats_file_name[0], "stats.%d", ++stats_file_number);
    stats_file = fopen(&stats_file_name[0], "w");
}


GLOBAL print_pclabs IFN0()
{
    IMPORT int tick_multiple;
    do_condition_checks = 0;
    tick_multiple = 0;
    print_stats();
    fclose(stats_file);
}

#endif /* PCLABS STATS */

/* extra functions called in FmDebug.c which support suspension and resumption
	of a separate filter process. BCN 3406 */
GLOBAL yoda_suspend_filter_process IFN0 ()
{
#ifdef host_suspend_filter_process
	host_suspend_filter_process();
#endif
}

GLOBAL yoda_resume_filter_process IFN0 ()
{
#ifdef	host_resume_filter_process
	host_resume_filter_process();
#endif
}

GLOBAL yoda_kill_filter_process IFN0 ()
{
#ifdef	host_kill_filter_process
	host_kill_filter_process();
#endif
}
#endif /* YODA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\floppy.c ===
#if defined(NEC_98)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif // NEC_98
#include "insignia.h"
#include "host_def.h"

extern void host_simulate();

/*
 * SoftPC Revision 3.0
 *
 *
 * Title	: Secondary SFD BIOS floppy diskette functions
 *
 *
 * Description	: This module defines the functions that the DISKETTE_IO
 *		  operating system call switches to on the value of AH:
 *
 *		  (AH=00H) reset the floppy diskette system
 *
 *		  (AH=01H) return the status of the floppy diskette system
 *
 *		  (AH=02H) read sectors from a floppy diskette
 *
 *		  (AH=03H) write sectors to a floppy diskette
 *
 *		  (AH=04H) verify sectors on a floppy diskette
 *
 *		  (AH=05H) format a track on a floppy diskette
 *
 *		  (AH=06H)
 *		     to    invalid
 *		  (AH=07H)
 *
 *		  (AH=08H) return floppy diskette system parameters
 *
 *		  (AH=09H)
 *		     to    invalid
 *		  (AH=14H)
 *
 *		  (AH=15H) return floppy diskette drive parameters
 *
 *		  (AH=16H) return floppy diskette drive change line status
 *
 *		  (AH=17H) set media density for a format operation
 *
 *		  (AH=18H) set media type for a format operation
 *
 *
 * Author	: Ross Beresford
 *
 *
 * Notes	: For a detailed description of the IBM Floppy Disk Adaptor,
 *		  and the INTEL Controller chips refer to the following
 *		  documents:
 *
 *		  - IBM PC/XT Technical Reference Manual
 *				(Section 1-109 Diskette Adaptor)
 *		  - INTEL Microsystems Components Handbook
 *				(Section 6-52 DMA Controller 8237A)
 *		  - INTEL Microsystems Components Handbook
 *				(Section 6-478 FDC 8272A)
 *
 * Mods:
 *      Tim September 1991. nec_term() changed two error code returns.
 * 	Helps Dos give correct error messages when no floppy in drive.
 */

/*
 *	
 *		#    #    ##       #     #####   ####
 *		#    #   #  #      #       #    #
 *		#    #  #    #     #       #     ####
 *		# ## #  ######     #       #         #
 *		##  ##  #    #     #       #    #    #
 *		#    #  #    #     #       #     ####
 *	
 * READ THIS: IMPORTANT NOTICE ABOUT WAITS
 *
 * The motor and head settle time waits etc used to be done
 * using a busy wait loop in a sub-CPU: this was what the
 * waitf() call was for, and this accurately emulated what
 * the real BIOS does.
 *
 * It was certainly a bad thing, however, as most
 * floppies we support are "soft" in the sense that
 * their underlying driver automatically waits for motor
 * start-up etc (examples are the slave, virtual, and
 * empty drive, and the real drive on the VAX ports).
 *
 * How should we deal with the few drives where we must
 * actually wait the correct time for motor start-up etc
 * before doing reads, writes, formats etc? The low
 * density BIOS relies on the GFI real diskette server
 * waiting for motor start-up in the driver itself (see
 * for example sun3_wang.c and ip32_flop.c). For the
 * moment the high density BIOS will do the same: it
 * might be better, however, for new GFI level functions
 * to be added to explicitly wait for driver events.
 */


/*
 * static char SccsID[]="@(#)floppy.c	1.22 09/19/94 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif

#include <stdio.h>
#if defined(NEC_98)
#include <stdlib.h>
#endif //NEC_98
#include TypesH

#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "dma.h"
#include "config.h"
#include "fla.h"
#include "gfi.h"
#include "equip.h"
#include "floppy.h"
#include "trace.h"
#include "debug.h"
#include "tape_io.h"
#include "cmos.h"
#include "cmosbios.h"
#include "rtc_bios.h"

#if defined(NEC_98)
#include <ntdddisk.h>

/*
**      DA/UA table definition
**      WARNING!! keep the following defines synchronized with floppy_i.c
*/
typedef struct {
        CHAR    DeviceName[29];
        UCHAR   Daua;
        UINT    FloppyNum;
        UINT    FdiskNum;
} DAUATBL;

extern DAUATBL  DauaTable[];

/*
**      Last accessed Track Number Table
**      WARNING!! keep the following defines synchronized with floppy_i.c
*/
typedef struct {
        UCHAR   cylinder;
        UCHAR   head;
} ACCESSTRACK;

extern ACCESSTRACK LastAccess[];

/*
**      Definition function
*/
MEDIA_TYPE GetFormatMedia IPT2( BYTE, daua, WORD, PhyBytesPerSec );
NTSTATUS FloppyOpenHandle IPT3( int, drive, PIO_STATUS_BLOCK, io_status_block, PHANDLE, fd);
NTSTATUS GetGeometry IPT3( HANDLE, fd, PIO_STATUS_BLOCK, io_status_block, PDISK_GEOMETRY, disk_geometry);
ULONG CalcActualLength IPT4( ULONG, RestCylLen, ULONG, RestTrkLen, BOOL*, fOverData, int, LogDrv);
void SetErrorCode IPT1( NTSTATUS, status );
void fl_disk_recal IPT1(int, drive);
void fl_disk_sense IPT1(int, drive);
void fl_disk_read_id IPT1(int, drive);
void SetSenseStatusHi IPT2( UCHAR, st3, PBYTE, ah_status);
void GetFdcStatus IPT2( HANDLE, fd, UCHAR, *st3 );
BOOL CheckDmaBoundary IPT3( UINT, segment, UINT, offset, UINT, length);
BOOL CheckDriveMode IPT1( HANDLE, fd );
BOOL Check144Mode IPT1( HANDLE, fd );
BOOL Check1MbInterface IPT1( int, drive );

extern int ConvToLogical IPT1( UINT, daua );
extern void SetDiskBiosCarryFlag IPT1( UINT, flag);

#endif // NEC_98

/*
 *	Definition of the diskette operation function jump table
 */

#if defined(NEC_98)
void ((*(fl_fnc_tab[FL_JUMP_TABLE_SIZE])) IPT1(int, drive)) =
{
        fl_fnc_err,
        fl_disk_verify,         // ah=x1h       verify sectors on a floppy diskette
        fl_fnc_err,
        fl_fnc_err,
        fl_disk_sense,          // ah=x4h       sense condition of floppy drive
        fl_disk_write,          // ah=x5h       write sectors to a floppy diskette
        fl_disk_read,           // ah=x6h       read sectors from a floppy diskette
        fl_disk_recal,          // ah=x7h       recalibrate floppy head
        fl_fnc_err,
        fl_fnc_err,
        fl_disk_read_id,        // ah=xAh       read id information from a floppy diskette
        fl_fnc_err,
        fl_fnc_err,
        fl_disk_format,         // ah=xDh       format a track on a floppy diskette
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
};
#else  // !NEC_98
void ((*(fl_fnc_tab[FL_JUMP_TABLE_SIZE])) IPT1(int, drive)) =
{
	fl_disk_reset,
	fl_disk_status,
	fl_disk_read,
	fl_disk_write,
	fl_disk_verify,
	fl_disk_format,
	fl_fnc_err,
	fl_fnc_err,
	fl_disk_parms,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_disk_type,
	fl_disk_change,
	fl_format_set,
	fl_set_media,
};
#endif // !NEC_98

#ifdef NTVDM
extern UTINY number_of_floppy;
#endif    /* NTVDM */

/*
 *	Functions defined later
 */

LOCAL half_word get_parm IPT1(int, index);
LOCAL cmos_type IPT2(int, drive, half_word *, type);
LOCAL wait_int IPT0();
LOCAL void nec_output IPT1(half_word, byte_value);
LOCAL results IPT0();
LOCAL void send_spec IPT0();
LOCAL void setup_end IPT1(int, sectors_transferred);
LOCAL void rd_wr_vf IPT3(int, drive, FDC_CMD_BLOCK *, fcbp, half_word, dma_type);
LOCAL void translate_new IPT1(int, drive);
LOCAL void fmt_init IPT1(int, drive);
LOCAL med_change IPT1(int, drive);
LOCAL chk_lastrate IPT1(int, drive);
LOCAL void send_rate IPT1(int, drive);
LOCAL fmtdma_set IPT0();
LOCAL void nec_init IPT2(int, drive, FDC_CMD_BLOCK *, fcbp);
LOCAL nec_term IPT0();
LOCAL dr_type_check IPT3(half_word, drive_type, word *, seg_ptr,
	word *, off_ptr);
LOCAL read_dskchng IPT1(int, drive);
LOCAL void setup_state IPT1(int, drive);
LOCAL setup_dbl IPT1(int, drive);
LOCAL dma_setup IPT1(half_word, dma_mode);
LOCAL void rwv_com IPT2(word, md_segment, word, md_offset);
LOCAL retry IPT1(int, drive);
LOCAL void dstate IPT1(int, drive);
LOCAL num_trans IPT0();
LOCAL void motor_on IPT1(int, drive);
LOCAL seek IPT2(int, drive, int, track);
LOCAL read_id IPT2(int, drive, int, head);
LOCAL turn_on IPT1(int, drive);
LOCAL void waitf IPT1(long, time);
LOCAL recal IPT1(int, drive);
LOCAL chk_stat_2 IPT0();

#if defined(NEC_98)
#define FLS_NORMAL_END          0x00
#define FLS_READY               0x00
#define FLS_WRITE_PROTECTED     0x10
#define FLS_DMA_BOUNDARY        0x20
#define FLS_END_OF_CYLINDER     0x30
#define FLS_EQUIPMENT_CHECK     0x40
#define FLS_OVER_RUN            0x50
#define FLS_NOT_READY           0x60
#define FLS_ERROR               0x80
#define FLS_TIME_OUT            0x90
#define FLS_DATA_ERROR          0xA0
#define FLS_BAD_CYLINDER        0xD0
#define FLS_MISSING_ID          0xE0

#define FLS_DOUBLE_SIDE         (1 << 0)
#define FLS_DETECTION_AI        (1 << 1)
#define FLS_HIGH_DENSITY        (1 << 2)
#define FLS_2MODE               (1 << 3)
#define FLS_AVAILABLE_1PT44MB   ((1 << 3)|(1 << 2))

#define FLP_VERIFY      0x01
#define FLP_SENSE       0x04
#define FLP_WRITE       0x05
#define FLP_READ        0x06
#define FLP_RECALIBRATE 0x07
#define FLP_READ_ID     0x0A
#define FLP_FORMAT      0x0D

#define MEDIA_IS_FLOPPY (1 << 4)
#define OP_MULTI_TRACK  (1 << 7)
#define OP_SEEK         (1 << 4)
#define OP_MFM_MODE     (1 << 6)
#define OP_NEW_SENSE    (1 << 7)
#define OP_SENSE2       ((1 << 7)|(1 << 6))

#define ST3_READY               (1 << 5)
#define ST3_WRITE_PROTECT       (1 << 6)
#define ST3_DOUBLE_SIDE         (1 << 3)

#define MEDIA_2D_DA     0x50

//----- Add-Start <93.12.28> Bug-Fix -----------------------------------
#define DEFAULT_PATTERN 0xe5
//----- Add-End --------------------------------------------------------

#endif // NEC_98
/*
 *	This macro defines the normal behaviour of the FDC after a reset.
 *	Sending a series of sense interrupt status commands following a
 *	reset, for each drive in the correct order, should elicit the
 *	expected result in ST0.
 */

#define	expected_st0(drive)	(ST0_INTERRUPT_CODE_0 | ST0_INTERRUPT_CODE_1 | drive)

LOCAL	UTINY	fl_nec_status[8];

#define LOAD_RESULT_BLOCK	sas_loads(BIOS_FDC_STATUS_BLOCK, fl_nec_status,\
					sizeof(fl_nec_status))

LOCAL BOOL rate_unitialised = TRUE;

/*
 *	Definition of the external functions
 */



/* reports whether drive is high density, replaces old test for dual card
which assumed high density a or b implied high density a, which it doesn't
now we can have two drives of any 3.5 / 5.25 combination */

LOCAL BOOL high_density IFN1(int, drive)
{
	half_word drive_type;

	if (cmos_type(drive, &drive_type) == FAILURE)
		return(FALSE);
	switch (drive_type)
	{
		case GFI_DRIVE_TYPE_12:
		case GFI_DRIVE_TYPE_144:
		case GFI_DRIVE_TYPE_288:
			return(TRUE);
		default:
			return(FALSE);
	}
}

void fl_disk_reset IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Reset the FDC and all drives. "drive" is not significant
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word motor_status, diskette_dor_reg, diskette_status;

	/*
	 *	Switch on interrupt enable and clear the reset bit in the
	 *	DOR to do the reset, then restore the reset bit
	 */

	sas_load(MOTOR_STATUS, &motor_status);
	diskette_dor_reg = (motor_status << 4) | (motor_status >> 4);
	diskette_dor_reg &= ~DOR_RESET;
	diskette_dor_reg |= DOR_INTERRUPTS;
	outb(DISKETTE_DOR_REG, diskette_dor_reg);

	diskette_dor_reg |= DOR_RESET;
	outb(DISKETTE_DOR_REG, diskette_dor_reg);

	/*
	 *	Set SEEK_STATUS up to force a recalibrate on all drives
	 */

	sas_store(SEEK_STATUS, 0);


	/*
	 *	Check FDC responds as expected, viz: a drive ready
	 *	transition for each drive potentially installed; if
	 *	not, then there is an error in the FDC.
	 */

	if (wait_int() == FAILURE)
	{
		/*
		 *	Problem with the FDC
		 *
		 * The reset implied by the outb(DISKETTE_DOR_REG) above
		 * should trigger a hardware interrupt, and the wait_int
		 * should have detected and processed it.
		 */
		always_trace0("FDC failed to interrupt after a reset - HW interrupts broken?");

		sas_load(FLOPPY_STATUS, &diskette_status);
		diskette_status |= FS_FDC_ERROR;
		sas_store(FLOPPY_STATUS, diskette_status);
	}
	else
	{
		for(drive = 0; drive < MAX_DISKETTES; drive++)
		{
			nec_output(FDC_SENSE_INT_STATUS);

			if (    (results() == FAILURE)
			     || (get_r3_ST0(fl_nec_status) != expected_st0(drive)))
			{
				/*
				 *	Problem with the FDC
				 */
				sas_load(FLOPPY_STATUS, &diskette_status);
				diskette_status |= FS_FDC_ERROR;
				sas_store(FLOPPY_STATUS, diskette_status);

				always_trace1("diskette_io: FDC error - drive %d moribund after reset", drive);
				break;
			}
		}


		/*
		 *	If all drives OK, send the specify command to the
		 *	FDC
		 */

		if (drive == MAX_DISKETTES)
			send_spec();
	}


	/*
	 *	Return, without setting sectors transferred
	 */

	setup_end(IGNORE_SECTORS_TRANSFERRED);
#endif // !NEC_98
}

void fl_disk_status IFN1(int, drive)
{
	/*
	 *	Set the diskette status, and return without setting
	 *	sectors transferred. "drive" is not significant
	 *
	 *	Register inputs:	
	 *		AH	diskette status
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	UNUSED(drive);
	
	sas_store(FLOPPY_STATUS, getAH());
	setup_end(IGNORE_SECTORS_TRANSFERRED);
}

void fl_disk_read IFN1(int, drive)
{
#if defined(NEC_98)
        /*
         *      Read sectors from the diskette in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              BX      data length in bytes
         *              DH      head number
         *              DL      sector number
         *              CH      sector length (N)
         *              CL      cylinder number
         *              ES:BP   buffer address
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;
        UINT ReqSectors;
        int LogDrv;
        ULONG TrackLength,RestCylLen,RestTrkLen,ActReadLen,ActReadSec,RemainReadLen;
        BOOL fOverRead;
        BYTE fHeadChng;
        host_addr inbuf;
        sys_addr pdata;
        UCHAR st3;
        LARGE_INTEGER StartOffset,LItemp;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check DMA boundary
        */
        if( !CheckDmaBoundary( getES(), getBP(), getBX() ) )
        {
                setAH(FLS_DMA_BOUNDARY);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

//----- Add-Start <94.01.15> Bug-Fix -----------------------------------
        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        /*
        **      check whether the specified sector length is valid.
        **      If specified sector length is not equal to actual sector
        **      length, then error returned.
        */
        if( (WORD)(128l << getCH()) != (WORD)disk_geometry.BytesPerSector )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }
//----- Add-End --------------------------------------------------------

        /*
        **      get read sectors
        */
        if( getBX() != 0 )
                ReqSectors = getBX() / (128 << getCH());
        else
                ReqSectors = (UINT)(0x10000l / (LONG)(128 << getCH()));

//----- Del-Start <94.01.15> Bug-Fix -----------------------------------
//      /*
//      **      convert from DA/UA to logical drive number (0 based)
//      */
//      LogDrv = ConvToLogical( getAL() );
//----- Del-End --------------------------------------------------------

        /*
        **      check read size
        */
        if( ReqSectors == 0 )
        {
                /*
                **      If request length is less than physical bytes/sector,
                **      then we do not perform to read.
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
                return;
        }

        /*
        **      check sector range
        */
        if( (getDL() < 1) || (getDL() > (int)disk_geometry.SectorsPerTrack) )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }

        TrackLength = disk_geometry.SectorsPerTrack * disk_geometry.BytesPerSector;

        //      RestTrkLen = TrackLength - (SectorNo.(DL) - 1) * BytesPerSector
        RestTrkLen = (disk_geometry.SectorsPerTrack - (ULONG)getDL() + 1) * disk_geometry.BytesPerSector;

        //      case HeadNo = 0:        RestCylLen = RestTrkLen + TrackLength
        //      case HeadNo = 1:        RestCylLen = RestTrkLen
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//              RestCylLen = RestTrkLen + ( !(getDH() & 0x01) ? 1l : 0l ) * TrackLength;
//      else
//              RestCylLen = RestTrkLen + ( (LastAccess[LogDrv].head == 0) ? 1l : 0l ) * TrackLength;
//----------------------------------------------------------------------
        if( !( getDH() & 0x01 ) )
                RestCylLen = RestTrkLen + TrackLength;
        else
                RestCylLen = RestTrkLen;
//----- Chg-End --------------------------------------------------------

        /*
        **      calcurate length which is read actually
        */
        ActReadLen = CalcActualLength( RestCylLen, RestTrkLen, &fOverRead, LogDrv);
        ActReadSec = ActReadLen / disk_geometry.BytesPerSector;

        /*
        **      check multi track read
        */
        if( getAH() & OP_MULTI_TRACK )
        {
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//              if( getAH() & OP_SEEK )
//              {
//                      if( (getDH() & 0x01) == 0 )
//                      {
//                              if( ActReadLen > RestTrkLen )
//                              {
//                                      RemainReadLen = ActReadLen - RestTrkLen;
//                                      ActReadLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainReadLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainReadLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//              else
//              {
//                      if( LastAccess[LogDrv].head == 0 )
//                      {
//                              if( ActReadLen > RestTrkLen )
//                              {
//                                      RemainReadLen = ActReadLen - RestTrkLen;
//                                      ActReadLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainReadLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainReadLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//----------------------------------------------------------------------
                if( (getDH() & 0x01) == 0 )
                {
                        if( ActReadLen > RestTrkLen )
                        {
                                RemainReadLen = ActReadLen - RestTrkLen;
                                ActReadLen = RestTrkLen;
                                fHeadChng = 1;
                        }
                        else
                        {
                                RemainReadLen = 0;
                                fHeadChng = 0;
                        }
                }
                else
                {
                        RemainReadLen = 0;
                        fHeadChng = 0;
                }
//----- Chg-End --------------------------------------------------------
        }
        else
        {
                RemainReadLen = 0;
                fHeadChng = 0;
        }

        /* read to where ? */
        pdata = effective_addr ( getES (), getBP () );

        if ( !(inbuf = (host_addr)sas_transbuf_address (pdata, ActReadLen)) )
        {
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                return;
        }

        /*
        **      calculate reading start offset on "drive".
        **
        **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
        **                      + SectorNo. ) * BytesPerSector
        */
        if( getAH() & OP_SEEK )
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
        else
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].head );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
        //      temp += HeadNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
        //      temp *= SectorsPerTrack
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
        //      temp += SectorNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDL() - 1) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
        //      StartOffset = temp * BytesPerSector
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

        /*
        **      now, go reading
        */
        status = NtReadFile(    fd,
                                0,
                                NULL,
                                NULL,
                                &io_status_block,
                                (PVOID)inbuf,
                                ActReadLen,
                                &StartOffset,
                                NULL
                                );

        /*
        **      save track number
        */
        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = getCL();
                LastAccess[LogDrv].head = getDH() & 0x01;
        }

        if (!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

        /* now store what we read */
        sas_stores_from_transbuf (pdata, inbuf, ActReadLen);

        /*
        **      if specified reading data from head 0 to 1,
        **      then perform to read remaining data.
        */
        if( fHeadChng )
        {
                /*
                **      read to where ?
                **      note: It has been already proved that buffer is not round
                **            dma boundary.
                */
                pdata = effective_addr ( getES(), (WORD)(getBP()+(WORD)ActReadLen) );

                if ( !(inbuf = (host_addr)sas_transbuf_address (pdata, RemainReadLen)) )
                {
                        NtClose(fd);
                        SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                        return;
                }

                /*
                **      calculate start offset to read remaining data on "drive".
                **
                **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
                **                      + SectorNo. ) * BytesPerSector
                **
                **      note: It is to be reading operation from head 1 & sector 1
                **            that remaining data exist.
                */
                if( getAH() & OP_SEEK )
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
                else
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
                //      temp += HeadNo.( = 1 )
                LItemp = RtlConvertUlongToLargeInteger( 1l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
                //      temp *= SectorsPerTrack
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
                //      temp += SectorNo.( = 0 )
                LItemp = RtlConvertUlongToLargeInteger( 0l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
                //      StartOffset = temp * BytesPerSector
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

                /*
                **      now, read remaining data
                */
                status = NtReadFile(    fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        (PVOID)inbuf,
                                        RemainReadLen,
                                        &StartOffset,
                                        NULL
                                        );

                /*
                **      save current head number
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = (getDH() & 0x01) + fHeadChng;
                }
                else
                        LastAccess[LogDrv].head += fHeadChng;

                if (!NT_SUCCESS(status))
                {
                        NtClose(fd);
                        SetErrorCode(status);
                        return;
                }

                /* now store what we read */
                sas_stores_from_transbuf (pdata, inbuf, RemainReadLen);
        }

        NtClose( fd );

        if( !fOverRead )
        {
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
        }
        else
        {
                setAH(FLS_END_OF_CYLINDER);
                SetDiskBiosCarryFlag(1);
        }

#else  // !NEC_98
	/*
	 *	Read sectors from the diskette in "drive"
	 *
	 *	Register inputs:	
	 *		DH	head number
	 *		CH	track number
	 *		CL	sector number
	 *		AL	number of sectors
	 *		ES:BX	buffer address
	 *	Register outputs:
	 *		AL	number of sectors read
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word motor_status;
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

	/*
	 *	Not a write operation
	 */
	
	sas_load(MOTOR_STATUS, &motor_status);
	motor_status &= ~MS_WRITE_OP;
	sas_store(MOTOR_STATUS, motor_status);


	/*
	 *	Fill in skeleton FDC command block and use generic
	 *	diskette transfer function to do the read
	 */

        put_c0_cmd(fdc_cmd_block, FDC_READ_DATA);
        put_c0_skip(fdc_cmd_block, 1);
        put_c0_MFM(fdc_cmd_block, 1);
        put_c0_MT(fdc_cmd_block, 1);
	rd_wr_vf(drive, fdc_cmd_block, BIOS_DMA_READ);
#endif // !NEC_98
}

void fl_disk_write IFN1(int, drive)
{
#if defined(NEC_98)
        /*
         *      Write sectors to the diskette in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              BX      data length in bytes
         *              DH      head number
         *              DL      sector number
         *              CH      sector length (N)
         *              CL      cylinder number
         *              ES:BP   buffer address
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;
        UINT ReqSectors;
        int LogDrv;
        ULONG TrackLength,RestCylLen,RestTrkLen,ActWriteLen,ActWriteSec,RemainWriteLen;
        BOOL fOverWrite;
        BYTE fHeadChng;
        host_addr outbuf;
        sys_addr pdata;
        UCHAR st3;
        LARGE_INTEGER StartOffset,LItemp;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check DMA boundary
        */
        if( !CheckDmaBoundary( getES(), getBP(), getBX()) )
        {
                setAH(FLS_DMA_BOUNDARY);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

//----- Add-Start <94.01.15> Bug-Fix -----------------------------------
        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        /*
        **      check whether the specified sector length is valid.
        **      If specified sector length is not equal to actual sector
        **      length, then error returned.
        */
        if( (WORD)(128l << getCH()) != (WORD)disk_geometry.BytesPerSector )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }
//----- Add-End --------------------------------------------------------

        /*
        **      get write sectors
        */
        if( getBX() != 0 )
                ReqSectors = getBX() / (128 << getCH());
        else
                ReqSectors = (UINT)(0x10000l / (LONG)(128 << getCH()));

//----- Del-Start <94.01.15> Bug-Fix ------------------------------------
//      /*
//      **      convert from DA/UA to logical drive number (0 based)
//      */
//      LogDrv = ConvToLogical( getAL() );
//----- Del-End ---------------------------------------------------------

        /*
        **      check write size
        */
        if( ReqSectors == 0 )
        {
                /*
                **      If request length is less than physical bytes/sector,
                **      then we do not perform to read.
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
                return;
        }

        /*
        **      check sector range
        */
        if( (getDL() < 1) || (getDL() > (int)(disk_geometry.SectorsPerTrack)) )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }

        TrackLength = disk_geometry.SectorsPerTrack * disk_geometry.BytesPerSector;

        //      RestTrkLen = TrackLength - (SectorNo.(DL) - 1) * BytesPerSector
        RestTrkLen = (disk_geometry.SectorsPerTrack - (ULONG)getDL() + 1) * disk_geometry.BytesPerSector;

        //      case HeadNo = 0:        ResCylLen = ResTrkLen + TrkLength
        //      case HeadNo = 1:        ResCylLen = RestTrkLen
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//              RestCylLen = RestTrkLen + ( !(getDH() & 0x01) ? 1l : 0l ) * TrackLength;
//      else
//              RestCylLen = RestTrkLen + ( (LastAccess[LogDrv].head == 0) ? 1l : 0l ) * TrackLength;
//----------------------------------------------------------------------
        if( !( getDH() & 0x01 ) )
                RestCylLen = RestTrkLen + TrackLength;
        else
                RestCylLen = RestTrkLen;
//----- Chg-End --------------------------------------------------------

        /*
        **      calcurate length which is written actually
        */
        ActWriteLen = CalcActualLength( RestCylLen, RestTrkLen, &fOverWrite, LogDrv);
        ActWriteSec = ActWriteLen / disk_geometry.BytesPerSector;

        /*
        **      check multi track write
        */
        if( getAH() & OP_MULTI_TRACK )
        {
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//              if( getAH() & OP_SEEK )
//              {
//                      if( (getDH() & 0x01) == 0 )
//                      {
//                              if( ActWriteLen > RestTrkLen )
//                              {
//                                      RemainWriteLen = ActWriteLen - RestTrkLen;
//                                      ActWriteLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainWriteLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainWriteLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//              else
//              {
//                      if( LastAccess[LogDrv].head == 0 )
//                      {
//                              if( ActWriteLen > RestTrkLen )
//                              {
//                                      RemainWriteLen = ActWriteLen - RestTrkLen;
//                                      ActWriteLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainWriteLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainWriteLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//----------------------------------------------------------------------
                if( (getDH() & 0x01) == 0 )
                {
                        if( ActWriteLen > RestTrkLen )
                        {
                                RemainWriteLen = ActWriteLen - RestTrkLen;
                                ActWriteLen = RestTrkLen;
                                fHeadChng = 1;
                        }
                        else
                        {
                                RemainWriteLen = 0;
                                fHeadChng = 0;
                        }
                }
                else
                {
                        RemainWriteLen = 0;
                        fHeadChng = 0;
                }
//----- Chg-End --------------------------------------------------------
        }
        else
        {
                RemainWriteLen = 0;
                fHeadChng = 0;
        }

        /* write from where ? */
        pdata = effective_addr (getES (), getBP ());

        if (!(outbuf = (host_addr)sas_transbuf_address (pdata, ActWriteLen)))
        {
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                return;
        }

        /* load our stuff to the transfer buffer */
        sas_loads_to_transbuf (pdata, outbuf, ActWriteLen);

        /*
        **      calculate writing start offset on "drive".
        **
        **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
        **                      + SectorNo. ) * BytesPerSector
        */
        if( getAH() & OP_SEEK )
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
        else
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder);
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].head );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-end --------------------------------------------------------
        }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
        //      temp += HeadNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
        //      temp *= SectorsPerTrack
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
        //      temp += SectorNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDL() - 1) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
        //      StartOffset = temp * BytesPerSector
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

        /*
        **      now, go writing
        */
        status = NtWriteFile(   fd,
                                0,
                                NULL,
                                NULL,
                                &io_status_block,
                                (PVOID)outbuf,
                                ActWriteLen,
                                &StartOffset,
                                NULL
                                );

        /*
        **      save track number
        */
        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = getCL();
                LastAccess[LogDrv].head = getDH() & 0x01;
        }

        if (!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

        /*
        **      if specified writing data from head 0 to 1,
        **      then perform to write remaining data.
        */
        if( fHeadChng )
        {
                /*
                **      write from where ?
                **      note: It has been already proved that buffer is not round
                **            dma boundary.
                */
                pdata = effective_addr ( getES(), (WORD)(getBP()+(WORD)ActWriteLen) );

                if (!(outbuf = (host_addr)sas_transbuf_address (pdata, RemainWriteLen)))
                {
                        NtClose(fd);
                        SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                        return;
                }

                /* load our stuff to the transfer buffer */
                sas_loads_to_transbuf (pdata, outbuf, RemainWriteLen);

                /*
                **      calculate start offset to write remaining data on "drive".
                **
                **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
                **                      + SectorNo. ) * BytesPerSector
                **
                **      note: It is to be writing operation from head 1 & sector 1
                **            that remaining data exist.
                */
                if( getAH() & OP_SEEK )
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
                else
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
                //      temp += HeadNo.( = 1 )
                LItemp = RtlConvertUlongToLargeInteger( 1l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
                //      temp *= SectorsPerTrack
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
                //      temp += SectorNo.( = 0 )
                LItemp = RtlConvertUlongToLargeInteger( 0l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
                //      StartOffset = temp * BytesPerSector
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

                /*
                **      now, write remaining data
                */
                status = NtWriteFile(   fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        (PVOID)outbuf,
                                        RemainWriteLen,
                                        &StartOffset,
                                        NULL
                                        );

                /*
                **      save current head number
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = (getDH() & 0x01) + fHeadChng;
                }
                else
                        LastAccess[LogDrv].head += fHeadChng;

                if (!NT_SUCCESS(status))
                {
                        NtClose(fd);
                        SetErrorCode(status);
                        return;
                }

        }

        NtClose( fd );

        if( !fOverWrite )
        {
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
        }
        else
        {
                setAH(FLS_END_OF_CYLINDER);
                SetDiskBiosCarryFlag(1);
        }

#else  // !NEC_98
	/*
	 *	Write sectors to the diskette in "drive"
	 *
	 *	Register inputs:	
	 *		DH	head number
	 *		CH	track number
	 *		CL	sector number
	 *		AL	number of sectors
	 *		ES:BX	buffer address
	 *	Register outputs:
	 *		AL	number of sectors written
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word motor_status;
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

	/*
	 *	A write operation
	 */
	
	sas_load(MOTOR_STATUS, &motor_status);
	motor_status |= MS_WRITE_OP;
	sas_store(MOTOR_STATUS, motor_status);


	/*
	 *	Fill in skeleton FDC command block and use generic
	 *	diskette transfer function to do the write
	 */

        put_c1_cmd(fdc_cmd_block, FDC_WRITE_DATA);
	put_c1_pad(fdc_cmd_block, 0);
	put_c1_MFM(fdc_cmd_block, 1);
	put_c1_MT(fdc_cmd_block, 1);
	rd_wr_vf(drive, fdc_cmd_block, BIOS_DMA_WRITE);
#endif // !NEC_98
}

void fl_disk_verify IFN1(int, drive)
{
#if defined(NEC_98)
        /*
         *      Verify sectors in the diskette in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              BX      data length in bytes
         *              DH      head number
         *              DL      sector number
         *              CH      sector length (N)
         *              CL      cylinder number
         *              ES:BP   buffer address
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;
        UINT ReqSectors;
        int LogDrv;
        ULONG TrackLength,RestCylLen,RestTrkLen,ActVerifyLen,ActVerifySec,RemainVerifyLen;
        BOOL fOverVerify;
        BYTE fHeadChng;
        UCHAR st3;
        PVOID temp_buffer;
        LARGE_INTEGER StartOffset, LItemp;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check DMA boundary
        */
        if( !CheckDmaBoundary( getES(), getBP(), getBX()) )
        {
                setAH(FLS_DMA_BOUNDARY);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

//----- Add-Start <94.01.15> Bug-Fix -----------------------------------
        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        /*
        **      check whether the specified sector length is valid.
        **      If specified sector length is not equal to actual sector
        **      length, then error returned.
        */
        if( (WORD)(128l << getCH()) != (WORD)disk_geometry.BytesPerSector )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }
//----- Add-End --------------------------------------------------------

        /*
        **      get verify sectors
        */
        if( getBX() != 0 )
                ReqSectors = getBX() / (128 << getCH());
        else
                ReqSectors = (UINT)(0x10000l / (LONG)(128 << getCH()));

//----- Del-Start <94.01.15> Bug-Fix -----------------------------------
//      /*
//      **      convert from DA/UA to logical drive number (0 based)
//      */
//      LogDrv = ConvToLogical( getAL() );
//----- Del-End --------------------------------------------------------

        /*
        **      check verify size
        */
        if( ReqSectors == 0 )
        {
                /*
                **      If request length is less than physical bytes/sector,
                **      then we do not perform to read.
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
                return;
        }

        /*
        **      check sector range
        */
        if( (getDL() < 1) || (getDL() > (int)(disk_geometry.SectorsPerTrack)) )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }

        TrackLength = disk_geometry.SectorsPerTrack * disk_geometry.BytesPerSector;

        //      RestTrkLen = TrackLength - (SectorNo.(DL) - 1) * BytesPerSector
        RestTrkLen = (disk_geometry.SectorsPerTrack - (ULONG)getDL() + 1) * disk_geometry.BytesPerSector;

        //      case HeadNo = 0:        ResCylLen = ResTrkLen + TrkLength
        //      case HeadNo = 1:        ResCylLen = RestTrkLen
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//              RestCylLen = RestTrkLen + ( !(getDH() & 0x01) ? 1l : 0l ) * TrackLength;
//      else
//              RestCylLen = RestTrkLen + ( (LastAccess[LogDrv].head == 0) ? 1l : 0l ) * TrackLength;
//----------------------------------------------------------------------
        if( !( getDH() & 0x01 ) )
                RestCylLen = RestTrkLen + TrackLength;
        else
                RestCylLen = RestTrkLen;
//----- Chg-End --------------------------------------------------------

        /*
        **      calcurate length which is verified actually
        */
        ActVerifyLen = CalcActualLength( RestCylLen, RestTrkLen, &fOverVerify, LogDrv);
        ActVerifySec = ActVerifyLen / disk_geometry.BytesPerSector;

        /*
        **      check multi track verify
        */
        if( getAH() & OP_MULTI_TRACK )
        {
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//              if( getAH() & OP_SEEK )
//              {
//                      if( (getDH() & 0x01) == 0 )
//                      {
//                              if( ActVerifyLen > RestTrkLen )
//                              {
//                                      RemainVerifyLen = ActVerifyLen - RestTrkLen;
//                                      ActVerifyLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainVerifyLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainVerifyLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//              else
//              {
//                      if( LastAccess[LogDrv].head == 0 )
//                      {
//                              if( ActVerifyLen > RestTrkLen )
//                              {
//                                      RemainVerifyLen = ActVerifyLen - RestTrkLen;
//                                      ActVerifyLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainVerifyLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainVerifyLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//----------------------------------------------------------------------
                if( (getDH() & 0x01) == 0 )
                {
                        if( ActVerifyLen > RestTrkLen )
                        {
                                RemainVerifyLen = ActVerifyLen - RestTrkLen;
                                ActVerifyLen = RestTrkLen;
                                fHeadChng = 1;
                        }
                        else
                        {
                                RemainVerifyLen = 0;
                                fHeadChng = 0;
                        }
                }
                else
                {
                        RemainVerifyLen = 0;
                        fHeadChng = 0;
                }
//----- Chg-End --------------------------------------------------------
        }
        else
        {
                RemainVerifyLen = 0;
                fHeadChng = 0;
        }

        /*
        **      allocate temporary buffer for verify operation
        */
        if( (temp_buffer=malloc( ActVerifyLen )) == NULL )
        {
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                return;
        }

        /*
        **      calculate verifying start offset on "drive".
        **
        **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
        **                      + SectorNo. ) * BytesPerSector
        */
        if( getAH() & OP_SEEK )
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
        else
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].head );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
        //      temp += HeadNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
        //      temp *= SectorsPerTrack
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
        //      temp += SectorNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDL() - 1) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
        //      StartOffset = temp * BytesPerSector
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

        /*
        **      now, go reading for verify
        */
        status = NtReadFile(    fd,
                                0,
                                NULL,
                                NULL,
                                &io_status_block,
                                (PVOID)temp_buffer,
                                ActVerifyLen,
                                &StartOffset,
                                NULL
                                );

        /*
        **      save track number
        */
        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = getCL();
                LastAccess[LogDrv].head = getDH() & 0x01;
        }

        if (!NT_SUCCESS(status))
        {
                free(temp_buffer);
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

        free(temp_buffer);

        /*
        **      if specified verifying data from head 0 to 1,
        **      then perform to verify remaining data.
        */
        if( fHeadChng )
        {
                /*
                **      read to where ?
                **      allocate temporary buffer for verify operation
                **      note: It has been already proved that buffer is not round
                **            dma boundary.
                */
                if( (temp_buffer=malloc( RemainVerifyLen )) == NULL )
                {
                        NtClose(fd);
                        SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                        return;
                }

                /*
                **      calculate start offset to verify remaining data on "drive".
                **
                **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
                **                      + SectorNo. ) * BytesPerSector
                **
                **      note: It is to be verifying operation from head 1 & sector 1
                **            that remaining data exist.
                */
                if( getAH() & OP_SEEK )
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
                else
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
                //      temp += HeadNo.( = 1 )
                LItemp = RtlConvertUlongToLargeInteger( 1l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
                //      temp *= SectorsPerTrack
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
                //      temp += SectorNo.( = 0 )
                LItemp = RtlConvertUlongToLargeInteger( 0l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
                //      StartOffset = temp * BytesPerSector
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

                /*
                **      now, go reading for verify remaining data
                */
                status = NtReadFile(    fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        (PVOID)temp_buffer,
                                        RemainVerifyLen,
                                        &StartOffset,
                                        NULL
                                        );

                /*
                **      save current head number
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = (getDH() & 0x01) + fHeadChng;
                }
                else
                        LastAccess[LogDrv].head += fHeadChng;

                if (!NT_SUCCESS(status))
                {
                        free(temp_buffer);
                        NtClose(fd);
                        SetErrorCode(status);
                        return;
                }

                free(temp_buffer);
        }

        NtClose( fd );

        if( !fOverVerify )
        {
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
        }
        else
        {
                setAH(FLS_END_OF_CYLINDER);
                SetDiskBiosCarryFlag(1);
        }

#else  // !NEC_98
	/*
	 *	Verify sectors in the diskette in "drive"
	 *
	 *	Register inputs:	
	 *		DH	head number
	 *		CH	track number
	 *		CL	sector number
	 *		AL	number of sectors
	 *	Register outputs:
	 *		AL	number of sectors verified
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word motor_status;
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

	
	/*
	 *	Not a write operation
	 */

	sas_load(MOTOR_STATUS, &motor_status);
	motor_status &= ~MS_WRITE_OP;
	sas_store(MOTOR_STATUS, motor_status);


	/*
	 *	Fill in skeleton FDC command block and use generic
	 *	diskette transfer function to do the verify
	 */

	put_c0_cmd(fdc_cmd_block, FDC_READ_DATA);
	put_c0_skip(fdc_cmd_block, 1);
	put_c0_MFM(fdc_cmd_block, 1);
	put_c0_MT(fdc_cmd_block, 1);
	rd_wr_vf(drive, fdc_cmd_block, BIOS_DMA_VERIFY);
#endif // !NEC_98
}

/*
** The low level 3.5 inch floppy format wants to know these params.
** For the funny format function.
** Have a look at hp_flop3.c FDC_FORMAT_TRACK bit.
*/
LOCAL int f_cyl, f_head, f_sector, f_N;
void GetFormatParams IFN4(int *, c, int *, h, int *, s, int *, n)
{
	*c = f_cyl;
	*h = f_head;
	*s = f_sector;
	*n = f_N;
}

void fl_disk_format IFN1(int, drive)
{
#if defined(NEC_98)
        /*
         *      Format the diskette in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              BX      DTL buffer length in byte
         *              DH      head number
         *              CH      sector length (N)
         *              CL      cylinder number
         *              ES:BP   address fields for the track
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        MEDIA_TYPE media_type;
        IO_STATUS_BLOCK io_status_block;
        int LogDrv;
        FORMAT_PARAMETERS format_param;
        BYTE daua;
        WORD PhyBytesPerSec,bad_track;
//----- Add-Start <93.12.28> Bug-Fix -----------------------------------
        ULONG TrackLength;
        PBYTE temp_buffer;
        BYTE PatternData;
        ULONG i;
        LARGE_INTEGER StartOffset,LItemp;
//----- Add-End --------------------------------------------------------

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check DMA boundary
        */
        if( !CheckDmaBoundary( getES(), getBP(), getBX()) )
        {
                setAH(FLS_DMA_BOUNDARY);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check FM mode
        */
        if( !( getAH() & OP_MFM_MODE ) )
        {
                setAH(FLS_MISSING_ID);
                SetDiskBiosCarryFlag(1);
                return;
        }

//----- Add-Start <94.01.15> Bug-Fix -----------------------------------
        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        /*
        **      check whether the specified sector length is valid.
        **      If specified sector length is greater than 2048,
        **      then error returned.
        */
        if( getCH() > 4 )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
//----- Del-Start <94.01.17> Bug-Fix -----------------------------------
//              NtClose(fd);
//----- Del-End --------------------------------------------------------
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }
//----- Add-End --------------------------------------------------------

        /*
        **      get requested media type
        */
        daua = (BYTE)getAL();
        PhyBytesPerSec = (WORD)( 128 << getCH() );
        if( (media_type = GetFormatMedia( daua, PhyBytesPerSec)) == Unknown )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        /*
        **      set up format parameter
        */
//----- Del-Start <94.01.15> Bug-Fix -----------------------------------
//      LogDrv = ConvToLogical( getAL() );
//----- Del-End --------------------------------------------------------
        format_param.MediaType = media_type;
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//      {
//              format_param.StartCylinderNumber =
//              format_param.EndCylinderNumber   = (DWORD)getCL();
//              format_param.StartHeadNumber     =
//              format_param.EndHeadNumber       = (DWORD)( getDH() & 0x01 );
//      }
//      else
//      {
//              format_param.StartCylinderNumber =
//              format_param.EndCylinderNumber   = (DWORD)LastAccess[LogDrv].cylinder;
//              format_param.StartHeadNumber     =
//              format_param.EndHeadNumber       = (DWORD)LastAccess[LogDrv].head;
//      }
//----------------------------------------------------------------------
        if( getAH() & OP_SEEK )
        {
                format_param.StartCylinderNumber =
                format_param.EndCylinderNumber   = (DWORD)getCL();
        }
        else
        {
                format_param.StartCylinderNumber =
                format_param.EndCylinderNumber   = (DWORD)LastAccess[LogDrv].cylinder;
        }
        format_param.StartHeadNumber     =
        format_param.EndHeadNumber       = (DWORD)( getDH() & 0x01 );
//----- Chg-End --------------------------------------------------------

        status = NtDeviceIoControlFile( fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        IOCTL_DISK_FORMAT_TRACKS,
                                        (PVOID)&format_param,
                                        sizeof(FORMAT_PARAMETERS),
                                        (PVOID)&bad_track,
                                        sizeof(bad_track)
                                        );

//----- Add-Start <93.12.29> Bug-Fix -----------------------------------
        /*
        **      save accessed cylinder number
        */
        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = (UCHAR)format_param.EndCylinderNumber;
                LastAccess[LogDrv].head = (UCHAR)format_param.EndHeadNumber;
        }
//----- Add-End --------------------------------------------------------

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

//----- Del-Start <93.12.28> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//      {
//              LastAccess[LogDrv].cylinder = (UCHAR)format_param.EndCylinderNumber;
//              LastAccess[LogDrv].head = (UCHAR)format_param.EndHeadNumber;
//      }
//----- Del-End --------------------------------------------------------

//----- Add-Start <93.12.28> Bug-Fix -----------------------------------
        /*
        **      if specified pattern data is different default
        **      pattern (E5H), then write specified pattern data
        **      to the track.
        */
        if( (PatternData = getDL()) != DEFAULT_PATTERN )
        {
                /*
                **      detection track length
                */
                switch( media_type )
                {
#if 1                                                                    // NEC 941110
                        case F5_1Pt23_1024:     TrackLength = 8l * 1024l;// NEC 941110
#else                                                                    // NEC 941110
                        case F5_1Pt2_1024:      TrackLength = 8l * 1024l;
#endif                                                                   // NEC 941110
                                                break;
                        case F3_1Pt44_512:      TrackLength = 18l * 512l;
                                                break;
                        case F5_1Pt2_512:       TrackLength = 15l * 512l;
                                                break;

                        case F3_720_512:        TrackLength = 9l * 512l;
                        default:                break;
                }

                /*
                **      allocate temporary buffer for writing pattern data
                */
                if( (temp_buffer=(PBYTE)malloc( TrackLength )) == NULL )
                {
                        NtClose(fd);
                        SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                        return;
                }

                /*
                **      fill temporary buffer with pattern data
                */
                for( i=0; i<TrackLength; i++)
                        temp_buffer[i] = PatternData;

                /*
                **      calculate writing start offset on "drive".
                **
                **      StartOffset = ( CylinderNo. * 2 + HeadNo. ) * SectorsPerTrack * BytesPerSector
                **                  = ( CylinderNo. * 2 + HeadNo. ) * TrackLength
                */
                //      temp = CylinderNo. * TracksPerCylinder( = 2 )
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)format_param.EndCylinderNumber );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, 2l );
                //      temp += HeadNo.
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)format_param.EndHeadNumber );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
                //      StartOffset = temp * TrackLength
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, TrackLength );

                /*
                **      now, write pattern data
                */
                status = NtWriteFile(   fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        (PVOID)temp_buffer,
                                        TrackLength,
                                        &StartOffset,
                                        NULL
                                        );

                /*
                **      note: we have already saved last accessed
                **            cylinder number.
                */

                if(!NT_SUCCESS(status))
                {
                        free((PVOID)temp_buffer);
                        NtClose(fd);
                        SetErrorCode(status);
                        return;
                }
        }
//----- Add-End --------------------------------------------------------

        NtClose(fd);
        setAH(FLS_NORMAL_END);
        SetDiskBiosCarryFlag(0);

#else  // !NEC_98
	/*
	 *	Format the diskette in "drive"
	 *
	 *	Register inputs:	
	 *		DH	head number
	 *		CH	track number
	 *		CL	sector number
	 *		AL	number of sectors
	 *		ES:BX	address fields for the track
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];
	half_word motor_status;

	/*
	** Set up format params so hp_flop3.c can find out what they are when
	** the format is about to happen.
	** cylinder, head, sector and Number of sectors.
	*/
	f_cyl = getCH();
	f_head = getDH();
	f_sector = getCL();
	f_N = getAL();

	/*
	 *	Establish the default format for the size of drive, unless
	 *	this has already been set up via previous calls to
	 *	diskette_io()
	 */

	translate_new(drive);
	fmt_init(drive);

	/*
	 *	A write operation
	 */

	sas_load(MOTOR_STATUS, &motor_status);
	motor_status |= MS_WRITE_OP;
	sas_store(MOTOR_STATUS, motor_status);


	/*
	 *	Don't proceed with the format if a DUAL card is installed
	 *	and the media has been changed
	 */

	if ((! high_density(drive)) || (med_change(drive) == SUCCESS))
	{

		/*
		 *	Send the specify command to the FDC, and establish
		 *	the data rate if necessary
		 */

		send_spec();
		if (chk_lastrate(drive) != FAILURE)
			send_rate(drive);

		/*
		 *	Prepare for DMA transfer that will do the format
		 */

		if (fmtdma_set() != FAILURE)
		{

			/*
			 *	Seek to the required track, and initialise
			 *	the FDC for the format
			 */

                        put_c3_cmd(fdc_cmd_block, FDC_FORMAT_TRACK);
			put_c3_pad1(fdc_cmd_block, 0);
			put_c3_MFM(fdc_cmd_block, 1);
			put_c3_pad(fdc_cmd_block, 0);
			nec_init(drive, fdc_cmd_block);


			/*
			 *	Send the remainder of the format
			 *	parameters to the FDC
			 */

			nec_output(get_parm(DT_N_FORMAT));
			nec_output(get_parm(DT_LAST_SECTOR));
			nec_output(get_parm(DT_FORMAT_GAP_LENGTH));
			nec_output(get_parm(DT_FORMAT_FILL_BYTE));


			/*
			 *	Complete the FDC command
			 */

			(void )nec_term();
		}
	}


	/*
	 *	Return without setting sectors transferred
	 */

	translate_old(drive);
	setup_end(IGNORE_SECTORS_TRANSFERRED);

#endif // !NEC_98
}

void fl_fnc_err IFN1(int, drive)
{
	/*
	 *	This routine sets the diskette status when an illegal
	 *	function number or drive number is passed to diskette_io();
	 *	"drive" is not significant
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	UNUSED(drive);
	
#if defined(NEC_98)
        /*
        **      Invalid command is normal end.
        */
        setAH(FLS_NORMAL_END);
        SetDiskBiosCarryFlag(0);

#else  // NEC_98
	setAH(FS_BAD_COMMAND);
	sas_store(FLOPPY_STATUS, FS_BAD_COMMAND);
	setCF(1);
#endif // !NEC_98
}

void fl_disk_parms IFN1(int, drive)
{
	/*
	 *	Return the drive parameters
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		CL	sectors/track
	 *		CH	maximum track number
	 *		BL	drive type
	 *		BH	0
	 *		DL	number of diskette drives
	 *		DH	maximum head number
	 *		ES:DI	parameter table address
	 *		AX	0
	 *		CF	0
	 */
	half_word disk_state, drive_type;
	half_word parameter;
	word segment, offset;
	EQUIPMENT_WORD equip_flag;


	/*
	 *	Set up number of diskette drives attached
	 */

	translate_new(drive);
	setBX(0);
	sas_loadw(EQUIP_FLAG, &equip_flag.all);
	if (equip_flag.bits.diskette_present == 0)
		setDL(0);
	else
		setDL((UCHAR)(equip_flag.bits.max_diskette + 1));


	/*
	 *	Set up drive dependent parameters
	 */

#ifdef NTVDM
	if (    (equip_flag.bits.diskette_present == 1)
	     && (drive < number_of_floppy))
#else
	if (    (equip_flag.bits.diskette_present == 1)
	     && (drive < MAX_FLOPPY))
#endif /* NTVDM */
	{

		if (! high_density(drive))
		{

			/*
			 *	Set up sectors/track, drive type and
			 *	maximum track number
			 */

			setCL(9);
			sas_load(FDD_STATUS+drive, &disk_state);
			if ((disk_state & DC_80_TRACK) == 0)
			{
				drive_type = GFI_DRIVE_TYPE_360;
				setCH(MAXIMUM_TRACK_ON_360);
			}
			else
			{
				drive_type = GFI_DRIVE_TYPE_720;
				setCH(MAXIMUM_TRACK_ON_720);
			}
			setBX(drive_type);


			/*
			 *	Set up maximum head and parameter table
			 *	address, return OK
			 */

			setDH(1);
			(void )dr_type_check(drive_type, &segment, &offset);
			setDI(offset);
			setES(segment);
			translate_old(drive);
			setAX(0);
			setCF(0);
			return;
		}


		/*
		 *	Dual card present: set maximum head number and
		 *	try to establish a parameter table entry for
		 *	the drive
		 */

		setDH(1);

		if (    cmos_type(drive, &drive_type) != FAILURE
		     && drive_type != GFI_DRIVE_TYPE_NULL
		     && dr_type_check(drive_type, &segment, &offset) != FAILURE)
		{


			/*
			 *	Set parameters from parameter table
			 */

			setBL(drive_type);
			sas_load(effective_addr(segment,offset)
					+ DT_LAST_SECTOR, &parameter);
			setCL(parameter);
			sas_load(effective_addr(segment,offset)
					+ DT_MAXIMUM_TRACK, &parameter);
			setCH(parameter);
			setDI(offset);
			setES(segment);
			translate_old(drive);
			setAX(0);
			setCF(0);
			return;
		}

		/*
		 *	Establish drive type from status
		 */

		sas_load(FDD_STATUS+drive, &disk_state);
		if ((disk_state & FS_MEDIA_DET) != 0)
		{
			switch(disk_state & RS_MASK)
			{
			case RS_250:
				if ((disk_state & DC_80_TRACK) == 0)
					drive_type = GFI_DRIVE_TYPE_360;
				else
					drive_type = GFI_DRIVE_TYPE_144;
				break;
			case RS_300:
				drive_type = GFI_DRIVE_TYPE_12;
				break;
			case RS_1000:
				drive_type = GFI_DRIVE_TYPE_288;
				break;
			default:
				drive_type = GFI_DRIVE_TYPE_144;
				break;
			}
			(void )dr_type_check(drive_type, &segment, &offset);


			/*
			 *	Set parameters from parameter table
			 */

			setBL(drive_type);
			sas_load(effective_addr(segment,offset)
				+ DT_LAST_SECTOR, &parameter);
			setCL(parameter);
			sas_load(effective_addr(segment,offset)
				+ DT_MAXIMUM_TRACK, &parameter);
			setCH(parameter);
			setDI(offset);
			setES(segment);
			translate_old(drive);
			setAX(0);
			setCF(0);
			return;
		}
	}


	/*
	 *	Arrive here if "drive" is invalid or if its type
	 *	could not be determined
	 */

	setCX(0);
	setDH(0);
	setDI(0);
	setES(0);
	translate_old(drive);
	setAX(0);
	setCF(0);
	return;
}

void fl_disk_type IFN1(int, drive)
{
	/*
	 *	Return the diskette drive type for "drive"
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		AH	drive type
	 *		CF	0
	 */
	half_word disk_state;
	EQUIPMENT_WORD equip_flag;

	note_trace1( GFI_VERBOSE, "floppy:fl_disk_type():drive=%x:", drive );
	if (high_density(drive))
	{
		/*
		 *	Dual card present: set type if "drive" valid
		 */
		note_trace0( GFI_VERBOSE, "floppy:fl_disk_type():DUAL CARD" );

		translate_new(drive);

		sas_load(FDD_STATUS+drive, &disk_state);
		if (disk_state == 0)
			setAH(DRIVE_IQ_UNKNOWN);
		else if ((disk_state & DC_80_TRACK) != 0)
			setAH(DRIVE_IQ_CHANGE_LINE);
		else
			setAH(DRIVE_IQ_NO_CHANGE_LINE);
		translate_old(drive);
	}
	else
	{
		note_trace0( GFI_VERBOSE,"floppy:fl_disk_type():NO DUAL CARD" );
		/*
		 *	Set no change line support if "drive" valid
		 */
		sas_loadw(EQUIP_FLAG, &equip_flag.all);
		if (equip_flag.bits.diskette_present)
			setAH(DRIVE_IQ_NO_CHANGE_LINE);
		else
			setAH(DRIVE_IQ_UNKNOWN);
	}

	setCF(0);

#ifndef PROD
switch( getAH() ){
case DRIVE_IQ_UNKNOWN: note_trace0( GFI_VERBOSE, "unknown drive\n" ); break;
case DRIVE_IQ_CHANGE_LINE: note_trace0( GFI_VERBOSE, "change line\n" ); break;
case DRIVE_IQ_NO_CHANGE_LINE: note_trace0( GFI_VERBOSE, "no change line\n" ); break;
default: note_trace0( GFI_VERBOSE, "bad AH return value\n" ); break;
}
#endif

}

void fl_disk_change IFN1(int, drive)
{
	/*
	 *	Return the state of the disk change line for "drive"
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word disk_state, diskette_status;

	note_trace1( GFI_VERBOSE, "floppy:fl_disk_change(%d)", drive);
	if (! high_density(drive))
	{
		/*
		 *	Only dual card supports change line, so call
		 *	the error function
		 */
		fl_fnc_err(drive);
	}
	else
	{
		translate_new(drive);
		sas_load(FDD_STATUS+drive, &disk_state);
		if (disk_state != 0)
		{
			/*
			 *	If "drive" is high density, check for
			 * 	a disk change
			 */
			if (    ((disk_state & DC_80_TRACK) == 0)
			     || (read_dskchng(drive) != SUCCESS))
			{
				sas_load(FLOPPY_STATUS, &diskette_status);
				diskette_status = FS_MEDIA_CHANGE;
				sas_store(FLOPPY_STATUS, diskette_status);
			}
		}
		else
		{
			/*
			 *	"drive" is invalid
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			diskette_status |= FS_TIME_OUT;
			sas_store(FLOPPY_STATUS, diskette_status);
		}


		/*
		 *	Return without setting sectors transferred
		 */

		translate_old(drive);
		setup_end(IGNORE_SECTORS_TRANSFERRED);
	}
}

void fl_format_set IFN1(int, drive)
{
	/*
	 *	Establish type of media to be used for subsequent format
	 *	operation
	 *
	 *	Register inputs:	
	 *		AL	media type
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word media_type = getAL(), disk_state, diskette_status;

	translate_new(drive);
	sas_load(FDD_STATUS+drive, &disk_state);
	disk_state &= ~(FS_MEDIA_DET | FS_DOUBLE_STEP | RS_MASK);
	sas_store(FDD_STATUS+drive, disk_state);

	if (media_type == MEDIA_TYPE_360_IN_360)
	{
		/*
		 *	Need to set low data rate
		 */
		disk_state |= (FS_MEDIA_DET | RS_250);
		sas_store(FDD_STATUS+drive, disk_state);
	}
	else
	{
		if (high_density(drive))
		{

			/*
			 *	Need to check for media change
			 */

			(void )med_change(drive);
			sas_load(FLOPPY_STATUS, &diskette_status);
			if (diskette_status == FS_TIME_OUT)
			{
				/*
				 *	Return without setting sectors
				 *	transferred
				 */
				translate_old(drive);
				setup_end(IGNORE_SECTORS_TRANSFERRED);
				return;
			}
		}

		switch(media_type)
		{
		case	MEDIA_TYPE_360_IN_12:
			/*
			 *	Need to set low density and double step
			 */
			disk_state |= (FS_MEDIA_DET | FS_DOUBLE_STEP | RS_300);
			sas_store(FDD_STATUS+drive, disk_state);
			break;
		case	MEDIA_TYPE_12_IN_12:
			/*
			 *	Need to set high density
			 */
			disk_state |= (FS_MEDIA_DET | RS_500);
			sas_store(FDD_STATUS+drive, disk_state);
			break;
		case	MEDIA_TYPE_720_IN_720:
			/*
			 *	Set 300kbs data rate if multi-format
			 *	supported on drive, otherwise 250kbs
			 */
			if (    ((disk_state & DC_DETERMINED) != 0)
			     && ((disk_state & DC_MULTI_RATE) != 0))
				disk_state |= (FS_MEDIA_DET | RS_300);
			else
				disk_state |= (FS_MEDIA_DET | RS_250);
			sas_store(FDD_STATUS+drive, disk_state);
			break;

		default:
			/*
			 *	Unsupported media type
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			diskette_status = FS_BAD_COMMAND;
			sas_store(FLOPPY_STATUS, diskette_status);
			break;
		}
	}

	/*
	 *	Return without setting sectors transferred
	 */

	translate_old(drive);
	setup_end(IGNORE_SECTORS_TRANSFERRED);
}

void fl_set_media IFN1(int, drive)
{
	/*
	 *	Set the type of media and data rate to be used in the
	 *	subsequent format operation
	 *
	 *	Register inputs:	
	 *		CH	maximum track number
	 *		CL	sectors/track
	 *	Register outputs:
	 *		ES:DI	parameter table address
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word max_track = getCH(), sectors = getCL();
	half_word dt_max_track, dt_sectors;
	half_word drive_type, diskette_status, disk_state, data_rate;
	half_word dt_drive_type;
	half_word lastrate;
	word md_segment, md_offset;
#ifdef NTVDM
	sys_addr dt_start = dr_type_addr;
	sys_addr dt_end = dr_type_addr + DR_CNT * DR_SIZE_OF_ENTRY;
#else
	sys_addr dt_start = DR_TYPE_ADDR;
	sys_addr dt_end = DR_TYPE_ADDR + DR_CNT * DR_SIZE_OF_ENTRY;
#endif
	sys_addr md_table;

	translate_new(drive);
	
	/*
	 *	Check for a media change on drives with a change line
	 */

	sas_load(FDD_STATUS+drive, &disk_state);
	if ((disk_state & DC_80_TRACK) != 0)
	{
		(void )med_change(drive);

		sas_load(FLOPPY_STATUS, &diskette_status);
		if (diskette_status == FS_TIME_OUT)
		{
			/*
			 *	Return without setting sectors
			 *	transferred
			 */
			translate_old(drive);
			setup_end(IGNORE_SECTORS_TRANSFERRED);
			return;
		}

		sas_store(FLOPPY_STATUS, FS_OK);
	}

	/*
	 *	Search the parameter table for the correct entry
	 */

	if (cmos_type(drive, &drive_type) == FAILURE)
	{
		sas_store(FLOPPY_STATUS, FS_MEDIA_NOT_FOUND);
	}
	else if (drive_type != 0)
	{
		if (dr_type_check(drive_type, &md_segment, &md_offset) == FAILURE)
		{
			sas_store(FLOPPY_STATUS, FS_MEDIA_NOT_FOUND);
		}
		else
		{
			/*
			 *	Try to find the parameter table entry which
			 *	has both the right drive type and matches
			 *	the max sector and max track numbers
			 */
			while (dt_start < dt_end)
			{
				sas_load(dt_start, &dt_drive_type);
				if ((dt_drive_type & ~DR_WRONG_MEDIA) == drive_type)
				{
					sas_loadw(dt_start+sizeof(half_word), &md_offset);
					md_table = effective_addr(md_segment, md_offset);

					sas_load(md_table + DT_LAST_SECTOR, &dt_sectors);
					sas_load(md_table + DT_MAXIMUM_TRACK, &dt_max_track);
					if (dt_sectors == sectors && dt_max_track == max_track)
						break;
				}

				dt_start += DR_SIZE_OF_ENTRY;
			}

			if (dt_start >= dt_end)
			{
				/*
				 *	Failed to find an entry
				 */
				sas_store(FLOPPY_STATUS, FS_MEDIA_NOT_FOUND);
			}
			else
			{
				/*
				 *	Update disk state and store
				 *	parameter table address
				 */

				sas_load(md_table+DT_DATA_TRANS_RATE, &data_rate);
				if (data_rate == RS_300)
					data_rate |= FS_DOUBLE_STEP;

				data_rate |= FS_MEDIA_DET;
				sas_load(FDD_STATUS+drive, &disk_state);

/*	CHECK - IN CASE OF 2 DRIVES
 * check last rate against the new data rate set
 * in the status byte. If they differ
 * set BIOS RATE STATUS byte to reflect old rate status
 * for this drive as it may have been altered by an
 * access to the other drive. This may result in a call
 * to send_rate not being performed because the old
 * rate status (possibly for the other drive) matching the
 * new data rate for this drive, when actually the last rate
 * attempted for this drive was different. Thus the
 * controller for this drive is at an old rate (for low
 * density say) and we are assuming it has been previously
 * set to the updated (high) state when it has not!
 * In all this will ensure the updated data rate being sent
 * for the drive concerned !
 */
				if ((disk_state & RS_MASK) != (data_rate & RS_MASK))
				{
					sas_load(RATE_STATUS, &lastrate);
					/*LINTIGNORE*/
					lastrate &= ~RS_MASK;
					lastrate |= disk_state & RS_MASK;
					sas_store(RATE_STATUS, lastrate);
				}
				
				disk_state &= ~(FS_MEDIA_DET | FS_DOUBLE_STEP | RS_MASK);
				disk_state |= data_rate;
				sas_store(FDD_STATUS+drive, disk_state);

				setES(md_segment);
				setDI(md_offset);
			}
		}
	}

	/*
	 *	Return without setting sectors transferred
	 */

	translate_old(drive);
	setup_end(IGNORE_SECTORS_TRANSFERRED);
}

LOCAL dr_type_check IFN3(half_word, drive_type, word *, seg_ptr, word *, off_ptr)
{
	/*
	 *	Return the address of the first parameter table entry
	 *	that matches "drive_type"
	 */
	half_word dt_drive_type;
	sys_addr dt_start, dt_end;

#ifdef NTVDM
	*seg_ptr = dr_type_seg;

	dt_start = dr_type_addr;
	dt_end = dr_type_addr + DR_CNT * DR_SIZE_OF_ENTRY;
#else
	*seg_ptr = DISKETTE_IO_1_SEGMENT;

	dt_start = DR_TYPE_ADDR;
	dt_end = DR_TYPE_ADDR + DR_CNT * DR_SIZE_OF_ENTRY;
#endif  /* NTVDM */

	while (dt_start < dt_end)
	{
		sas_load(dt_start, &dt_drive_type);
		if (dt_drive_type == drive_type)
		{
			sas_loadw(dt_start+sizeof(half_word), off_ptr);
			return(SUCCESS);
		}

		dt_start += DR_SIZE_OF_ENTRY;
	}

	return(FAILURE);
}

LOCAL void send_spec IFN0()
{
	/*
	 *	Send a specify command to the FDC using data from the
	 *	parameter table pointed to by @DISK_POINTER
	 */
	nec_output(FDC_SPECIFY);
	nec_output(get_parm(DT_SPECIFY1));
	nec_output(get_parm(DT_SPECIFY2));
}

LOCAL void send_spec_md IFN2(word, segment, word, offset)
{
	/*
	 *	Send a specify command to the FDC using data from the
	 *	parameter table pointed to by "segment" and "offset"
 	 */
	half_word parameter;
	
	nec_output(FDC_SPECIFY);
	sas_load(effective_addr(segment, offset+DT_SPECIFY1), &parameter);
	nec_output(parameter);
	sas_load(effective_addr(segment, offset+DT_SPECIFY2), &parameter);
	nec_output(parameter);
}

LOCAL void translate_new IFN1(int, drive)
{
	/*
	 *	Translates diskette state locations from compatible
	 *	mode to new architecture
	 */
	half_word hf_cntrl, disk_state;

	sas_load(DRIVE_CAPABILITY, &hf_cntrl);

#ifdef NTVDM
	if (high_density(drive) && (drive < number_of_floppy))
#else
	if (high_density(drive) && (drive < MAX_FLOPPY))
#endif /* NTVDM */
	{
		sas_load(FDD_STATUS+drive, &disk_state);
		if (disk_state == 0)
		{
			/*
			 *	Try to establish drive capability
			 */
			drive_detect(drive);
		}
		else
		{
			/*
			 *	Copy drive capability bits
			 */
			hf_cntrl >>= (drive << 2);
			hf_cntrl &= DC_MASK;
			disk_state &= ~DC_MASK;
			disk_state |= hf_cntrl;
			sas_store(FDD_STATUS+drive, disk_state);
		}
	}
}

void translate_old IFN1(int, drive)
{
	/*
	 *	Translates diskette state locations from new
	 *	architecture to compatible mode
	 */
	half_word hf_cntrl, disk_state, mode, drive_type;
	int shift_count = drive << 2;

	sas_load(DRIVE_CAPABILITY, &hf_cntrl);
	sas_load(FDD_STATUS+drive, &disk_state);

#ifdef NTVDM
	if (high_density(drive) && (drive < number_of_floppy) && (disk_state != 0))
#else
	if (high_density(drive) && (drive < MAX_FLOPPY) && (disk_state != 0))
#endif  /* NTVDM */

	{
		/*
		 *	Copy drive capability bits
		 */
		if ((hf_cntrl & (DC_MULTI_RATE << shift_count)) == 0)
		{
			hf_cntrl &= ~(DC_MASK << shift_count);
			hf_cntrl |= (disk_state & DC_MASK) << shift_count;
			sas_store(DRIVE_CAPABILITY, hf_cntrl);
		}

		/*
		 *	Copy media type bits
		 */

		switch (disk_state & RS_MASK)
		{
		case RS_500:
			/*
			 *	Drive should be a 1.2M
			 */
			if (    (cmos_type(drive, &drive_type) != FAILURE)
			     && (drive_type == GFI_DRIVE_TYPE_12))
			{
				mode = FS_12_IN_12;
				if ((disk_state & FS_MEDIA_DET) != 0)
					mode = media_determined(mode);
			}
			else
			{
				mode = FS_DRIVE_SICK;
			}
			break;

		case RS_300:
			/*
			 *	Should be double-stepping for 360K floppy
			 *	in 1.2M drive
			 */
			mode = FS_360_IN_12;
			if ((disk_state & FS_DOUBLE_STEP) != 0)
			{
				if ((disk_state & FS_MEDIA_DET) != 0)
					mode = media_determined(mode);
			}
			else
			{
				mode = FS_DRIVE_SICK;
			}
			break;

		case RS_250:
			/*
			 *	Should be 360K floppy in 360K drive,
			 *	ie 250kbs and 40 track
			 */
			if ((disk_state & DC_80_TRACK) == 0)
			{
				mode = FS_360_IN_360;
				if ((disk_state & FS_MEDIA_DET) != 0)
					mode = media_determined(mode);
			}
			else
			{
				mode = FS_DRIVE_SICK;
			}
			break;

		case RS_1000:
			/*
			 *	Drive should be a 2.88M
			 */
			if (    (cmos_type(drive, &drive_type) != FAILURE)
			     && (drive_type == GFI_DRIVE_TYPE_288))
			{
				mode = FS_288_IN_288;
				if ((disk_state & FS_MEDIA_DET) != 0)
					mode = media_determined(mode);
			}
			else
			{
				mode = FS_DRIVE_SICK;
			}
			break;

		default:
			/*
			 *	Weird data rate
			 */
			mode = FS_DRIVE_SICK;
			break;
		}

		disk_state &= ~DC_MASK;
		disk_state |= mode;
		sas_store(FDD_STATUS+drive, disk_state);
	}
}

LOCAL void rd_wr_vf IFN3(int, drive, FDC_CMD_BLOCK *, fcbp, half_word, dma_type)
{
	/*
	 *	Common read, write and verify; main loop for data rate
	 *	retries
	 */
	half_word data_rate, dt_data_rate, drive_type, dt_drive_type;
	half_word disk_state;
	sys_addr dt_start, dt_end;
	int sectors_transferred;
	word md_segment, md_offset;
	/*
	 *	Establish initial data rate, then loop through each
	 *	possible data rate
	 */
	translate_new(drive);
	setup_state(drive);
	while ((! high_density(drive)) || med_change(drive) == SUCCESS)
	{
		sas_load(FDD_STATUS+drive, &disk_state);
		data_rate = (half_word)(disk_state & RS_MASK);
		if (cmos_type(drive, &drive_type) != FAILURE)
		{
			/*
			 *	Check CMOS value against what is really
			 *	known about the drive
			 */
			/*
			 * The original code here had a very bad case of "Bad-C"
			 * if-if-else troubles, but replacing the code with
			 * the switch statement originally intended breaks
			 * 5.25" floppies. I have removed the redundant bits
			 * of the code, but BEWARE - there is a another
			 * fault somewhere to cancel out this one!
			 * William Roberts - 9/2/93
			 */
			if (drive_type == GFI_DRIVE_TYPE_360)
			{
				if ((disk_state & DC_80_TRACK) != 0)
				{
					drive_type = GFI_DRIVE_TYPE_12;
				}
		     /* else if (drive_type == GFI_DRIVE_TYPE_12) ... */
			}

			/*
			** dr_type_check() looks for the first matching drive
			** value in the small table and returns a
			** pointer to the coresponding entry in the big
			** parameter table.
			** The segment is used later on but the offset is
			** determined by a subsequent search of the table below.
			** These table live in ROM (see bios2.rom) fe00:c80
			*/
			if (    (drive_type != GFI_DRIVE_TYPE_NULL)
			     && (dr_type_check(drive_type, &md_segment, &md_offset) != FAILURE))
			{
				/*
				 *	Try to find parameter table entry with
				 *	right drive type and current data rate
				 */
#ifdef NTVDM
				dt_start = dr_type_addr;
				dt_end = dr_type_addr + DR_CNT * DR_SIZE_OF_ENTRY;
#else
				dt_start = DR_TYPE_ADDR;
				dt_end = DR_TYPE_ADDR + DR_CNT * DR_SIZE_OF_ENTRY;
#endif /* NTVDM */
				while (dt_start < dt_end)
				{
					/*
					** get drive type from table
					*/
					sas_load(dt_start, &dt_drive_type);
					if ((dt_drive_type & ~DR_WRONG_MEDIA) == drive_type)
					{
						/*
						** get data rate from table
						*/
						sas_loadw(dt_start+sizeof(half_word), &md_offset);
						sas_load(effective_addr(md_segment, md_offset) + DT_DATA_TRANS_RATE, &dt_data_rate);
						/*
						** if table rate matches that
						** selected by setup_state()
						** then try current table entry
						** parameters.
						*/
						if (data_rate == dt_data_rate)
							break;
					}

					dt_start += DR_SIZE_OF_ENTRY;
				}
				if (dt_start >= dt_end)
				{
					/*
					 *	Assume media matches drive
					 */
#ifdef NTVDM
					md_segment = dr_type_seg;
					md_offset = dr_type_off;
					if ((disk_state & DC_80_TRACK) == 0)
						md_offset += MD_TBL1_OFFSET;
					else
						md_offset += MD_TBL3_OFFSET;
#else
					md_segment = DISKETTE_IO_1_SEGMENT;
					if ((disk_state & DC_80_TRACK) == 0)
						md_offset = MD_TBL1_OFFSET;
					else
						md_offset = MD_TBL3_OFFSET;
#endif  /* NTVDM */
						
				}
			}
			else
			{
				/*
				 *	Assume media matches drive
				 */
#ifdef NTVDM
				md_segment = dr_type_seg;
				md_offset = dr_type_off;
				if ((disk_state & DC_80_TRACK) == 0)
					md_offset += MD_TBL1_OFFSET;
				else
					md_offset += MD_TBL3_OFFSET;
#else
				md_segment = DISKETTE_IO_1_SEGMENT;
				if ((disk_state & DC_80_TRACK) == 0)
					md_offset = MD_TBL1_OFFSET;
				else
					md_offset = MD_TBL3_OFFSET;
#endif	/* NTVDM */
			}
		}
		else
		{
			/*
			 *	Assume media matches drive
			 */
#ifdef NTVDM
			md_segment = dr_type_seg;
			md_offset = dr_type_off;
			if ((disk_state & DC_80_TRACK) == 0)
				md_offset += MD_TBL1_OFFSET;
			else
				md_offset += MD_TBL3_OFFSET;
#else
			md_segment = DISKETTE_IO_1_SEGMENT;
			if ((disk_state & DC_80_TRACK) == 0)
				md_offset = MD_TBL1_OFFSET;
			else
				md_offset = MD_TBL3_OFFSET;
#endif /* NTVDM */
		}

		/*
		 *	Send a specify command to the FDC; change the
		 *	rate if it has been updated
		 */
		send_spec_md(md_segment, md_offset);
		if (chk_lastrate(drive) != FAILURE)
			send_rate(drive);

		/*
		 *	Decide whether double stepping is required for
		 *	the data rate currently being tried
		 */

		if (setup_dbl(drive) != FAILURE)
		{
			if (dma_setup(dma_type) == FAILURE)
			{
				translate_old(drive);
				setup_end(IGNORE_SECTORS_TRANSFERRED);
				return;
			}

			/*
			 *	Attempt the transfer
			 */
			nec_init(drive, fcbp);
			rwv_com(md_segment, md_offset);
			(void )nec_term();
		}

		/*
		** Will select next data rate in range specified by
		** setup_state() and try again.
		** When there are no more rates give up.
		*/
		if (retry(drive) == SUCCESS)
			break;
	}

	/*
	 *	Determine the current drive state and return, setting
	 *	the number of sectors actually transferred
	 */
	dstate(drive);
	sectors_transferred = num_trans();
	translate_old(drive);
	setup_end(sectors_transferred);
}

LOCAL void setup_state IFN1(int, drive)
{
#ifndef NEC_98
	half_word	drive_type;	/* Floppy unit type specified by CMOS */

	/*
	 *	Initialises start and end data rates
	 */
	half_word disk_state, start_rate, end_rate, lastrate;

	if (high_density(drive))
	{
		sas_load(FDD_STATUS+drive, &disk_state);
#ifndef NTVDM
		if ((disk_state & FS_MEDIA_DET) == 0)
		{

			/*
			 *	Set up first and last data rates to
			 *	try
			 */
			if (    ((disk_state & DC_DETERMINED) != 0)
			     && ((disk_state & DC_MULTI_RATE) == 0) )
			{
				/* not a multi-rate drive */
				start_rate = end_rate = RS_250;
			}
			else
			{
				/* multi-rate drive */
/*
 * The real BIOS always sets up start_rate=500 and end_rate=300
 * If we attempt this then some bug (not yet found) will cause the following
 * sequence to fail (5.25") low density read followed by high density read.
 * This gives rate transitions 500 -> 250 -> 300 -> 500 ...
 * Read the drive type from CMOS and adjust the start and end rates to match.
 * The CMOS drive type is set up during cmos_post() by calling config_inquire().
*/
if( cmos_type( drive, &drive_type ) != FAILURE ){
	switch( drive_type ){
		case GFI_DRIVE_TYPE_360:
		case GFI_DRIVE_TYPE_12:
			start_rate = RS_300;	/* different to Real BIOS */
			end_rate   = RS_500;
			break;
		case GFI_DRIVE_TYPE_720:
		case GFI_DRIVE_TYPE_144:
			start_rate = RS_500;	/* same as Real BIOS */
			end_rate   = RS_300;
			break;
/*
 * We don't know what the real BIOS does here.  These values work
 * fine.  Any code in rd_wr_vf that gets confused will drop out to
 * default high density values if neither of the following two
 * rates work.
 */

		case GFI_DRIVE_TYPE_288:
			start_rate = RS_1000;
			end_rate   = RS_300;
			break;
		default:
			always_trace1( "setup_state(): Bad Drive from CMOS:%x",
			                drive_type );
			break;
	}
}else{
	always_trace0( "setup_state(): CMOS read failure: Drive Type" );
}

                        }

#else /* NTVDM */

		if ((disk_state & FS_MEDIA_DET) == 0)
		{

    if( cmos_type( drive, &drive_type ) != FAILURE ){
	switch( drive_type ){
		case GFI_DRIVE_TYPE_360:
		case GFI_DRIVE_TYPE_720:
			start_rate =
			end_rate = RS_250;
			break;

		case GFI_DRIVE_TYPE_12:
			start_rate = RS_300;	/* different to Real BIOS */
			end_rate   = RS_500;
			break;
		case GFI_DRIVE_TYPE_144:
			start_rate = RS_500;	/* same as Real BIOS */
			end_rate   = RS_250;
			break;
/*
 * We don't know what the real BIOS does here.  These values work
 * fine.  Any code in rd_wr_vf that gets confused will drop out to
 * default high density values if neither of the following two
 * rates work.
 */

		case GFI_DRIVE_TYPE_288:
			start_rate = RS_1000;
			end_rate   = RS_300;
			break;
		default:
			always_trace1( "setup_state(): Bad Drive from CMOS:%x",
			                drive_type );
			break;
	}
    }else{
	always_trace0( "setup_state(): CMOS read failure: Drive Type" );
    }

#endif /* NTVDM */

			/*
			 *	Set up disk state with current data
			 *	rate; clear double stepping, which
			 *	may be re-established by a call to
			 *	setup_dbl()
			 */
			disk_state &= ~(RS_MASK | FS_DOUBLE_STEP);
			disk_state |= start_rate;
			sas_store(FDD_STATUS+drive, disk_state);

			/*
			 *	Store final rate to try in rate data
			 */
			sas_load(RATE_STATUS, &lastrate);
			lastrate &= ~(RS_MASK >> 4);
			lastrate |= (end_rate >> 4);
			sas_store(RATE_STATUS, lastrate);
		}
	}
#endif // !NEC_98
}

LOCAL void fmt_init IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	If the media type has not already been set up, establish
	 *	the default media type for the drive type
	 */
	half_word disk_state, drive_type;

	if (high_density(drive))
	{
		sas_load(FDD_STATUS+drive, &disk_state);
		if ((disk_state & FS_MEDIA_DET) == 0)
		{
			if (    (cmos_type(drive, &drive_type) != FAILURE)
			     && (drive_type != 0))
			{
				disk_state &= ~(FS_MEDIA_DET | FS_DOUBLE_STEP | RS_MASK);
				switch(drive_type)
				{
				case GFI_DRIVE_TYPE_360:
					disk_state |= (FS_MEDIA_DET | RS_250);
					break;
				case GFI_DRIVE_TYPE_12:
				case GFI_DRIVE_TYPE_144:
					disk_state |= (FS_MEDIA_DET | RS_500);
					break;
				case GFI_DRIVE_TYPE_288:
					disk_state |= (FS_MEDIA_DET | RS_1000);
					break;
				case GFI_DRIVE_TYPE_720:
					if ((disk_state & (DC_DETERMINED|DC_MULTI_RATE))
							== (DC_DETERMINED|DC_MULTI_RATE))
						disk_state |= (FS_MEDIA_DET | RS_300);
					else
						disk_state |= (FS_MEDIA_DET | RS_250);
					break;
				default:
					disk_state = 0;
					break;
				}
			}
			else
			{
				disk_state = 0;
			}
			sas_store(FDD_STATUS+drive, disk_state);
		}
	}
#endif // !NEC_98
}

LOCAL med_change IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Checks for media change, resets media change,
	 *	checks media change again
	 */
	half_word disk_state, motor_status;
	
	if (high_density(drive))
	{
		if (read_dskchng(drive) == SUCCESS)
			return(SUCCESS);

		/*
		 *	Media has been changed - set media state to
		 *	undetermined
		 */
		sas_load(FDD_STATUS+drive, &disk_state);
		disk_state &= ~FS_MEDIA_DET;
		sas_store(FDD_STATUS+drive, disk_state);

		/*
		 *	Start up the motor, since opening the
		 *	door may have turned the motor off
		 */
		sas_load(MOTOR_STATUS, &motor_status);
		motor_status &= ~(1 << drive);
		sas_store(MOTOR_STATUS, motor_status);
		motor_on(drive);

		/*
		 *	This sequence of seeks should reset the
		 *	disk change line, if the door is left
		 *	alone
		 */
		fl_disk_reset(drive);
		(void )seek(drive, 1);
		(void )seek(drive, 0);

		/*
		 *	If disk change line still active, assume drive
		 *	is empty or door has been left open
		 */
		if (read_dskchng(drive) == SUCCESS)
			sas_store(FLOPPY_STATUS, FS_MEDIA_CHANGE);
		else
			sas_store(FLOPPY_STATUS, FS_TIME_OUT);
	}
	return(FAILURE);
#endif // !NEC_98
}

LOCAL void send_rate IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Update the data rate for "drive"
	 */
	half_word lastrate, disk_state;

	if (high_density(drive))
	{

		/*
		 *	Update the adapter data rate
		 */
		sas_load(RATE_STATUS, &lastrate);
		lastrate &= ~RS_MASK;
		sas_load(FDD_STATUS+drive, &disk_state);
		disk_state &= RS_MASK;
		lastrate |= disk_state;
		sas_store(RATE_STATUS, lastrate);

		/*
		 *	Establish the new data rate for the drive via
		 *	the floppy adapter
		 */

		outb(DISKETTE_DCR_REG, (IU8)(disk_state >> 6));
	}
#endif // !NEC_98
}

LOCAL chk_lastrate IFN1(int, drive)
{
	/*
	 *	Reply whether the adapter data rate is different to
	 *	the disk state data rate
	 */
	half_word lastrate, disk_state;

	if (rate_unitialised)
	{
		rate_unitialised = FALSE;
		return(SUCCESS);
	}
	
	sas_load(RATE_STATUS, &lastrate);
	sas_load(FDD_STATUS+drive, &disk_state);
	return((lastrate & RS_MASK) != (disk_state & RS_MASK)
			? SUCCESS : FAILURE);
}

LOCAL dma_setup IFN1(half_word, dma_mode)
{
#ifndef NEC_98
	/*
	 *	This routine sets up the DMA for read/write/verify
	 *	operations
	 */
	DMA_ADDRESS dma_address;
	reg byte_count;

	/*
	 *	Disable interrupts
	 */

	setIF(0);

	/*
	 *	Set up the DMA adapter's internal state and mode
	 */

	outb(DMA_CLEAR_FLIP_FLOP, dma_mode);
	outb(DMA_WRITE_MODE_REG, dma_mode);

	/*
	 *	Output the address to the DMA adapter as a page address
	 *	and 16 bit offset
	 */
	if (dma_mode == BIOS_DMA_VERIFY)
		dma_address.all = 0;
	else
		dma_address.all = effective_addr(getES(), getBX());
	outb(DMA_CH2_ADDRESS, dma_address.parts.low);
	outb(DMA_CH2_ADDRESS, dma_address.parts.high);
	outb(DMA_FLA_PAGE_REG, dma_address.parts.page);

	/*
	 *	Calculate the number of bytes to be transferred from the
	 *	number of sectors, and the sector size. Subtract one
	 *	because the DMA count must wrap to 0xFFFF before it
	 *	stops
	 */

	byte_count.X = ((unsigned int)getAL() << (7 + get_parm(DT_N_FORMAT))) - 1;
	outb(DMA_CH2_COUNT, byte_count.byte.low);
	outb(DMA_CH2_COUNT, byte_count.byte.high);

	/*
	 *	Enable interrupts
	 */

	setIF(1);

	/*
	 *	Set up diskette channel for the operation, checking
	 *	for wrapping of the bottom 16 bits of the address
	 */

	outb(DMA_WRITE_ONE_MASK_BIT, DMA_DISKETTE_CHANNEL);
	if (((long)dma_address.words.low + (long)byte_count.X) > 0xffff)
	{
		sas_store(FLOPPY_STATUS, FS_DMA_BOUNDARY);
		return(FAILURE);
	}

	return(SUCCESS);
#endif // !NEC_98
}

LOCAL fmtdma_set IFN0()
{
#ifndef NEC_98
	/*
	 *	This routine sets up the DMA for format operations
	 */
	DMA_ADDRESS dma_address;
	reg byte_count;

	/*
	 *	Disable interrupts
	 */

	setIF(0);

	/*
	 *	Set up the DMA adapter's internal state and mode
	 */

	outb(DMA_CLEAR_FLIP_FLOP, BIOS_DMA_WRITE);
	outb(DMA_WRITE_MODE_REG, BIOS_DMA_WRITE);

	/*
	 *	Output the address to the DMA adapter as a page address
	 *	and 16 bit offset
	 */
	dma_address.all = effective_addr(getES(), getBX());
	outb(DMA_CH2_ADDRESS, dma_address.parts.low);
	outb(DMA_CH2_ADDRESS, dma_address.parts.high);
	outb(DMA_FLA_PAGE_REG, dma_address.parts.page);

	/*
	 *	Calculate the number of bytes to be transferred from the
	 *	number of sectors per track, given that 4 bytes (C,H,R,N)
	 *	are needed to define each sector's address mark. Subtract
	 *	one because the DMA count must wrap to 0xFFFF before it
	 *	stops
	 */

	byte_count.X = ((unsigned int)get_parm(DT_LAST_SECTOR) << 2) - 1;
	outb(DMA_CH2_COUNT, byte_count.byte.low);
	outb(DMA_CH2_COUNT, byte_count.byte.high);

	/*
	 *	Enable interrupts
	 */

	setIF(1);

	/*
	 *	Set up diskette channel for the operation, checking
	 *	for wrapping of the bottom 16 bits of the address
	 */

#ifndef NTVDM
	/* we don't have to worry about this on NT */
	outb(DMA_WRITE_ONE_MASK_BIT, DMA_DISKETTE_CHANNEL);
	if (((long)dma_address.words.low + (long)byte_count.X) > 0xffff)
	{
		sas_store(FLOPPY_STATUS, FS_DMA_BOUNDARY);
		return(FAILURE);
	}
#endif

	return(SUCCESS);
#endif // !NEC_98
}

LOCAL void nec_init IFN2(int, drive, FDC_CMD_BLOCK *, fcbp)
{
	/*
	 *	This routine seeks to the requested track and
	 *	initialises the FDC for the read/write/verify
	 *	operation.
	 */

	motor_on(drive);
	if (seek(drive, (int)getCH()) != FAILURE)
	{
		nec_output(fcbp[0]);
		put_c2_head(fcbp, getDH());
		put_c2_drive(fcbp, drive);
		put_c2_pad1(fcbp, 0);
		nec_output(fcbp[1]);
	}
}

LOCAL void rwv_com IFN2(word, md_segment, word, md_offset)
{
	/*
	 *	This routine send read/write/verify parameters to the
	 *	FDC
	 */
	half_word md_gap;

	/*
	 *	Output track number, head number and sector number
	 */
	nec_output(getCH());
	nec_output(getDH());
	nec_output(getCL());

	/*
	 *	Output bytes/sector and sectors/track
	 */
	nec_output(get_parm(DT_N_FORMAT));
	nec_output(get_parm(DT_LAST_SECTOR));

	/*
	 *	Output gap length
	 */
	sas_load(effective_addr(md_segment, md_offset)+DT_GAP_LENGTH, &md_gap);
	nec_output(md_gap);

	/*
	 *	 Output data length
	 */
	nec_output(get_parm(DT_DTL));
}

LOCAL nec_term IFN0()
{
	/*
	 *	This routine waits for the operation then interprets
	 *	the results from the FDC
	 */
	half_word diskette_status;
	int wait_int_result;

	wait_int_result = wait_int();
	if (results() != FAILURE && wait_int_result != FAILURE)
	{
		/*
		 *	Result phase completed
		 */
		if ((get_r0_ST0(fl_nec_status) &
			(ST0_INTERRUPT_CODE_0 | ST0_INTERRUPT_CODE_1)) != 0)
		{
			/*
			 *	Command did not terminate normally
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			if ((get_r0_ST0(fl_nec_status) & ST0_INTERRUPT_CODE_0)
								== 0)
			{
				/*
				 *	Problem with the FDC
				 */
				diskette_status |= FS_FDC_ERROR;

				always_trace0("diskette_io: FDC error - emetic command");
			}
			else
			{
				/*
				 *	Abnormal termination - set
				 *	diskette status up accordingly
				 */
				if (get_r0_ST1(fl_nec_status) &
						ST1_END_OF_CYLINDER)
				{
					diskette_status |= FS_SECTOR_NOT_FOUND;
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_DATA_ERROR)
				{
					diskette_status |= FS_CRC_ERROR;
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_OVERRUN)
				{
					diskette_status |= FS_DMA_ERROR;
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_NO_DATA)
				{
					diskette_status |= FS_FDC_ERROR; /* Tim Sept 91, was FS_SECTOR_NOT_FOUND */
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_NOT_WRITEABLE)
				{
					diskette_status |= FS_WRITE_PROTECTED;
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_MISSING_ADDRESS_MARK)
				{
					diskette_status |= FS_BAD_ADDRESS_MARK;
				}
				else
				{
					/*
					 *	Problem with the FDC
					 */
					diskette_status |= FS_TIME_OUT; /* Tim Sept 91, was FS_FDC_ERROR */
					always_trace0("diskette_io: FDC error - perverted result");
				}
			}
			sas_store(FLOPPY_STATUS, diskette_status);
		}
	}
	sas_load(FLOPPY_STATUS, &diskette_status);
	return((diskette_status == FS_OK) ? SUCCESS : FAILURE);
}

LOCAL void dstate IFN1(int, drive)
{
	/*
	 *	Determine the drive state after a successful operation
	 */
	half_word diskette_status, disk_state, drive_type;

	if (high_density(drive))
	{
		sas_load(FLOPPY_STATUS, &diskette_status);
		if (diskette_status == 0)
		{
			/*
			 *	Command successful, both media and drive
			 *	are now determined
			 */
			sas_load(FDD_STATUS+drive, &disk_state);
			disk_state |= FS_MEDIA_DET;
			if ((disk_state & DC_DETERMINED) == 0)
			{
				if (    ((disk_state & RS_MASK) == RS_250)
				     && (cmos_type(drive, &drive_type) != FAILURE)
				     && (drive_type != GFI_DRIVE_TYPE_144)
				     && (drive_type != GFI_DRIVE_TYPE_288) )
				{
					/*
					 *	No multi-format capability
					 */
					disk_state &= ~DC_MULTI_RATE;
					disk_state |= DC_DETERMINED;
				}
				else
				{
					/*
					 *	Multi-format capability
					 */
					disk_state |= (DC_DETERMINED | DC_MULTI_RATE);
				}
			}
			sas_store(FDD_STATUS+drive, disk_state);
		}
	}
}

LOCAL retry IFN1(int, drive)
{
	/*
	 *	Determines whether a retry is necessary. If retry is
	 *	required then state information is updated for retry
	 */
	half_word diskette_status, disk_state, data_rate, lastrate;

	sas_load(FLOPPY_STATUS, &diskette_status);
	if (diskette_status != FS_OK && diskette_status != FS_TIME_OUT)
	{
		sas_load(FDD_STATUS+drive, &disk_state);	
		if ((disk_state & FS_MEDIA_DET) == 0)
		{
			sas_load(RATE_STATUS, &lastrate);
			if ((data_rate = (half_word)((disk_state & RS_MASK))) !=
					((lastrate << 4) & RS_MASK))
			{
				/*
				 *	Last command failed, the media
				 *	is still unknown, and there are
				 *	more data rates to check, so set
				 *	up next data rate
				 */
				data_rate = next_rate(data_rate);
			
				/*
				 *	Reset state and go for retry
				 */
				disk_state &= ~(RS_MASK | FS_DOUBLE_STEP);
				disk_state |= data_rate;
				sas_store(FDD_STATUS+drive, disk_state);	
				sas_store(FLOPPY_STATUS, FS_OK);
				return(FAILURE);
			}
		}
	}

	/*
	 *	Retry not worthwhile
	 */
	return(SUCCESS);
}

LOCAL num_trans IFN0()
{
	/*
	 *	This routine calculates the number of sectors that
	 *	were actually transferred to/from the diskette
	 */
	half_word diskette_status;
	int sectors_per_track, sectors_transferred = 0;

	sas_load(FLOPPY_STATUS, &diskette_status);
	if (diskette_status == 0)
	{
		/*
		 *	Number of sectors = final sector - initial sector
		 */
		LOAD_RESULT_BLOCK;
		sectors_transferred = get_r0_sector(fl_nec_status) - getCL();

		/*
		 *	Adjustments for spanning heads or tracks
		 */
		sectors_per_track = (int)get_parm(DT_LAST_SECTOR);
		LOAD_RESULT_BLOCK;
		if (get_r0_head(fl_nec_status) != getDH())
			sectors_transferred += sectors_per_track;
		else if (get_r0_cyl(fl_nec_status) != getCH())
			sectors_transferred += (sectors_per_track * 2);
	}

	return(sectors_transferred);
}

LOCAL void setup_end IFN1(int, sectors_transferred)
{
	/*
	 *	Restore MOTOR_COUNT to parameter provided in table;
	 *	set return status values and sectors transferred,
	 *	where applicable
	 */
	half_word diskette_status;

	sas_store(MOTOR_COUNT, get_parm(DT_MOTOR_WAIT));

	sas_load(FLOPPY_STATUS, &diskette_status);
	setAH(diskette_status);
	if (diskette_status != 0)
	{
		/*
		 *	Operation failed
		 */
		if (sectors_transferred != IGNORE_SECTORS_TRANSFERRED)
			setAL(0);
		setCF(1);
	}
	else
	{
		/*
		 *	Operation succeeded
		 */
		if (sectors_transferred != IGNORE_SECTORS_TRANSFERRED)
			setAL((UCHAR)(sectors_transferred));
		setCF(0);
	}
}

LOCAL setup_dbl IFN1(int, drive)
{
	/*
	 *	Check whether media requires to be double-stepped to
	 *	be read at the current data rate
	 */
	half_word disk_state;
	int track, max_track;
	
	if (high_density(drive))
	{
		sas_load(FDD_STATUS+drive, &disk_state);
		if ((disk_state & FS_MEDIA_DET) == 0)
		{
			/*
			 *	First check track 0 to get out quickly if
			 *	the media is unformatted
			 */
			sas_store(SEEK_STATUS, 0);
			motor_on(drive);
			(void )seek(drive, 0);
			if (read_id(drive, 0) != FAILURE)
			{

				/*
				 *	Try reading ids from cylinder 2 to
				 *	the last cylinder on both heads. If
				 *	the putative track number disagrees
				 *	with what is on the disk, then
				 *	double stepping is required
				 */
				if ((disk_state & DC_80_TRACK) == 0)
					max_track = 0x50;
				else
					max_track = 0xa0;

				for (track = 4; track < max_track; track++)
				{
					/* ensure motor stays on */
					sas_store(MOTOR_COUNT, MC_MAXIMUM);

					sas_store(FLOPPY_STATUS, FS_OK);
					(void )seek(drive, track/2);
					if (read_id(drive, track%2) == SUCCESS)
					{
						LOAD_RESULT_BLOCK;
						sas_store(FDD_TRACK+drive,
  						    get_r0_cyl(fl_nec_status));
						if ((track/2) !=
					 	    get_r0_cyl(fl_nec_status))
						{
							disk_state |= FS_DOUBLE_STEP;
							sas_store(FDD_STATUS+drive, disk_state);
						}
						return(SUCCESS);
					}
				}
			}
			return(FAILURE);
		}
	}

	return(SUCCESS);
}

LOCAL read_id IFN2(int, drive, int, head)
{
	/*
	 *	Perform the read id function
	 */
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

        put_c4_cmd(fdc_cmd_block, FDC_READ_ID);
	put_c4_pad1(fdc_cmd_block, 0);
	put_c4_MFM(fdc_cmd_block, 1);
	put_c4_pad(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[0]);

	put_c4_drive(fdc_cmd_block, drive);
	put_c4_head(fdc_cmd_block, head);
	put_c4_pad2(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[1]);
	
	return(nec_term());
}

LOCAL cmos_type IFN2(int, drive, half_word *, type)
{
	/*	
	 *	Returns diskette type from the soft CMOS
	 */
	half_word cmos_byte;

	/*
	 *	Check the CMOS battery and checksum
	 */
	cmos_byte = cmos_read(CMOS_DIAG);
	if ((cmos_byte & (BAD_CKSUM|BAD_BAT)) != 0)
		return(FAILURE);

	/*
	 *	Read the CMOS diskette drive type byte and return
	 *	the nibble for the drive requested. The types for
	 *	drive 0 and 1 are given in the high and low nibbles
	 *	respectively.
	 */
	cmos_byte = cmos_read(CMOS_DISKETTE);
	if (drive == 0)
		cmos_byte >>= 4;
	*type = cmos_byte & 0xf;

	return(SUCCESS);
}

LOCAL half_word get_parm IFN1(int, index)
{
	/*
	 *	Return the byte in the current diskette parameter table
	 *	offset by "index"
	 */
	half_word value;
	word segment, offset;

	sas_loadw(DISK_POINTER_ADDR, &offset);
	sas_loadw(DISK_POINTER_ADDR + 2, &segment);

	sas_load(effective_addr(segment, offset+index), &value);

#ifndef PROD
        {
                char *parm_name = "Unknown???";

#define DT_PARM_NAME(x,y)       case x: parm_name = y; break;

                switch (index) {
                DT_PARM_NAME(DT_SPECIFY1,"SPECIFY1");
                DT_PARM_NAME(DT_SPECIFY2,"SPECIFY2");
                DT_PARM_NAME(DT_MOTOR_WAIT,"MOTOR_WAIT");
                DT_PARM_NAME(DT_N_FORMAT,"N_FORMAT");
                DT_PARM_NAME(DT_LAST_SECTOR,"LAST_SECTOR");
                DT_PARM_NAME(DT_GAP_LENGTH,"GAP_LENGTH");
                DT_PARM_NAME(DT_DTL,"DTL");
                DT_PARM_NAME(DT_FORMAT_GAP_LENGTH,"FORMAT_GAP_LENGTH");
                DT_PARM_NAME(DT_FORMAT_FILL_BYTE,"FORMAT_FILL_BYTE");
                DT_PARM_NAME(DT_HEAD_SETTLE,"HEAD_SETTLE");
                DT_PARM_NAME(DT_MOTOR_START,"MOTOR_START");
                DT_PARM_NAME(DT_MAXIMUM_TRACK,"MAXIMUM_TRACK");
                DT_PARM_NAME(DT_DATA_TRANS_RATE,"DATA_TRANS_RATE");
                }

        note_trace5(FLOPBIOS_VERBOSE,
		"diskette_io:get_parm(%04x:%04x+%02x) %s=%02x)",
                 segment, offset, index, parm_name, value);
        }
#endif /* PROD */

	return(value);
}

LOCAL void motor_on IFN1(int, drive)
{
	/*
	 *	Turn motor on and wait for motor start up time
	 */
	double_word time_to_wait;

	/*
	 *	If motor was previously off - wait for the start-up time
	 */
	if (turn_on(drive) != FAILURE)
	{
		/*
		 *	Notify OS that BIOS is about to wait for motor
		 *	start up
		 */
#ifndef	JOKER
		word savedAX, savedCX, savedDX, savedCS, savedIP;

		translate_old(drive);

		savedAX = getAX();
		savedCS = getCS();
		savedIP = getIP();

		setAH(INT15_DEVICE_BUSY);
		setAL(INT15_DEVICE_FLOPPY_MOTOR);
#ifdef NTVDM
		setCS(int15_seg);
		setIP(int15_off);
#else
		setCS(RCPU_INT15_SEGMENT);
		setIP(RCPU_INT15_OFFSET);
#endif /* NTVDM */

		host_simulate();

		setAX(savedAX);
		setCS(savedCS);
		setIP(savedIP);

		translate_new(drive);

		/*
		 *	Quit if operating system handled wait and motor
		 *	is still on
		 */
		if (getCF() && turn_on(drive) == FAILURE)
			return;
		
#endif	/* JOKER */

		/*
		 *	Get time to wait in 1/8 second units - minimum
		 *	wait time 1 second
		 */
		if ((time_to_wait = get_parm(DT_MOTOR_START)) < WAIT_A_SECOND)
			time_to_wait = WAIT_A_SECOND;

		/*
		 *	Convert time to wait into microseconds
		 */

		time_to_wait *= 125000L;

		/* at this point the real BIOS sets CX,DX to time_to_wait;
		   we don't actually need to wait at all, so request
		   the minimum length wait */

#ifndef	JOKER

		/*
		 *	Ask OS to do wait
		 */
		savedAX = getAX();
		savedCX = getCX();
		savedDX = getDX();
		savedCS = getCS();
		savedIP = getIP();

		setAH(INT15_WAIT);
		setCX(0);
		setDX(1);
#ifdef NTVDM
		setCS(int15_seg);
		setIP(int15_off);
#else
		setCS(RCPU_INT15_SEGMENT);
		setIP(RCPU_INT15_OFFSET);
#endif /* NTVDM */

		host_simulate();

		setAX(savedAX);
		setCX(savedCX);
		setDX(savedDX);
		setCS(savedCS);
		setIP(savedIP);

		/*
		 *	Quit if wait succeeded
		 */
		if (!getCF())
			return;
		
#endif	/* JOKER */

		/*
		 *	Need to do fixed wait locally
		 */
		waitf(time_to_wait);
	}
}

LOCAL turn_on IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Turn motor on and return wait state
	 */
	half_word motor_status, drive_select_desired, motor_on_desired;
	half_word drive_select, status_desired, old_motor_on, new_motor_on;
	half_word diskette_dor_reg;

	/*
	 *	Disable interrupts
	 */
	setIF(0);

	/*
	 *	Make sure the motor stays on as long as possible
	 */
	sas_store(MOTOR_COUNT, MC_MAXIMUM);

	/*
	 *	Get existing and desired drive select and motor on
	 */
	sas_load(MOTOR_STATUS, &motor_status);
	drive_select = (half_word)(motor_status & MS_DRIVE_SELECT_MASK);
	drive_select_desired = (drive << 4);
	motor_on_desired = (1 << drive);

	if (    (drive_select != drive_select_desired)
	     || ((motor_on_desired & motor_status) == 0))
	{
		/*
		 *	Store desired motor status
		 */
		status_desired = motor_on_desired | drive_select_desired;
		old_motor_on = (half_word)(motor_status & MS_MOTOR_ON_MASK);
		motor_status &= ~MS_DRIVE_SELECT_MASK;
		motor_status |= status_desired;
		sas_store(MOTOR_STATUS, motor_status);

		/*
		 *	Switch on motor of selected drive via a write
		 *	to the floppy adapter's Digital Output Register
		 */
		new_motor_on = (half_word)(motor_status & MS_MOTOR_ON_MASK);
		setIF(1);
		diskette_dor_reg = motor_status << 4;
		diskette_dor_reg |= (motor_status & MS_DRIVE_SELECT_MASK) >> 4;
		diskette_dor_reg |= (DOR_INTERRUPTS | DOR_RESET);
		outb(DISKETTE_DOR_REG, diskette_dor_reg);

		/*
		 *	Flag success only if the motor was switched on,
		 *	and not just reselected
		 */
		if (new_motor_on != old_motor_on)
			return(SUCCESS);
	}

	/*
	 *	Enable interrupts
	 */
	setIF(1);
	return(FAILURE);
#endif // !NEC_98
}

LOCAL void hd_wait IFN1(int, drive)
{
	/*
	 *	Wait for head settle time
	 */
	half_word motor_status, disk_state;
	word time_to_wait;
#ifndef	JOKER
	word savedAX, savedCX, savedDX, savedCS, savedIP;
#endif

	/*
	 *	Get head settle time; for write operations, the minimum
	 *	head settle times may need to be enforced
	 */
	time_to_wait = get_parm(DT_HEAD_SETTLE);
	sas_load(MOTOR_STATUS, &motor_status);
	if ((motor_status & MS_WRITE_OP) != 0)
	{
		if (time_to_wait == 0)
		{
			/*
			 *	Use minimum wait times according to the
			 *	media type
			 */
			sas_load(FDD_STATUS+drive, &disk_state);
			if ((disk_state & RS_MASK) == RS_250)
				time_to_wait = HEAD_SETTLE_360;
			else
				time_to_wait = HEAD_SETTLE_12;
		}
	}
	else if (time_to_wait == 0)
		return;

	/*
	 *	Convert time to wait into microseconds
	 */

	time_to_wait *= 1000;

	/* at this point the real BIOS sets CX,DX to time_to_wait;
	   we don't actually need to wait at all, so request
	   a zero length wait */

#ifndef	JOKER

	/*
	 *	Ask OS to do wait
	 */
	savedAX = getAX();
	savedCX = getCX();
	savedDX = getDX();
	savedCS = getCS();
	savedIP = getIP();

	setAH(INT15_WAIT);
	setCX(0);
	setDX(1);

#ifdef NTVDM
	setCS(int15_seg);
	setIP(int15_off);
#else
	setCS(RCPU_INT15_SEGMENT);
	setIP(RCPU_INT15_OFFSET);
#endif /* NTVDM */

	host_simulate();

	setAX(savedAX);
	setCX(savedCX);
	setDX(savedDX);
	setCS(savedCS);
	setIP(savedIP);

	/*
	 *	Quit if wait succeeded
	 */
	if (!getCF())
		return;

#endif	/* JOKER */

	/*
	 *	Need to do fixed wait locally
	 */
	waitf(time_to_wait);
}

LOCAL void nec_output IFN1(half_word, byte_value)
{
#ifndef NEC_98
	/*
	 *	This routine sends a byte to the FDC after testing for
	 *	correct direction and controller ready. If the FDC does
	 *	not respond after a few tries, it is assumed that there
	 *	is a bug in our FDC emulation
	 */
	half_word diskette_status_reg;
	int count;

	/*
	 *	Wait for ready and correct direction
	 */
	count = 0;
	do
	{
		if (count++ >= FDC_TIME_OUT)
		{
			always_trace0("diskette_io: FDC error - input repletion");
			return;
		}
		inb(DISKETTE_STATUS_REG, &diskette_status_reg);
	} while ((diskette_status_reg & (DSR_RQM | DSR_DIO)) != DSR_RQM);

	/*
	 *	Output the byte
	 */
	outb(DISKETTE_DATA_REG, byte_value);

	/*
	 *	Do fixed wait for FDC update cycle time
	 */
	waitf(FDC_SETTLE);
#endif // !NEC_98
}

LOCAL seek IFN2(int, drive, int, track)
{
	/*
	 *	This routine will move the head on the named drive
	 *	to the named track. If the drive has not been accessed
	 *	since the drive reset command was issued, the drive
	 *	will be recalibrated
	 */
	half_word seek_status, disk_track, disk_state;
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];
	int status;

	note_trace2(FLOPBIOS_VERBOSE, "diskette_io:seek(drive=%d,track=%d)",
							drive, track);

	/*
	 *	Check if recalibration required before seek
	 */
	sas_load(SEEK_STATUS, &seek_status);
	if ((seek_status & (1 << drive)) == 0)
	{
		/*
		 *	Update the seek status and recalibrate
		 */
		sas_store(SEEK_STATUS, (IU8)(seek_status | (1 << drive)));
		if (recal(drive) != SUCCESS)
		{
			sas_store(FLOPPY_STATUS, FS_OK);
			if (recal(drive) == FAILURE)
				return(FAILURE);
		}

		/*
		 *	Drive will now be at track 0
		 */
		sas_store(FDD_TRACK+drive, 0);
		if (track == 0)
		{
			/*
			 *	No need to seek
			 */
			hd_wait(drive);
			return(SUCCESS);
		}
	}

	/*
	 *	Allow for double stepping
	 */
	sas_load(FDD_STATUS+drive, &disk_state);
	if ((disk_state & FS_DOUBLE_STEP) != 0)
		track *= 2;

	/*
	 *	Update current track number
	 */
	sas_load(FDD_TRACK+drive, &disk_track);
	if (disk_track == track)
	{
		/*
		 *	No need to seek
		 */
		return(SUCCESS);
	}
	sas_store(FDD_TRACK+drive, (IU8)track);

	/*
	 *	Do the seek and check the results
	 */
        put_c8_cmd(fdc_cmd_block, FDC_SEEK);
	put_c8_pad(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[0]);
	put_c8_drive(fdc_cmd_block, drive);
	put_c8_head(fdc_cmd_block, 0);
	put_c8_pad1(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[1]);
	put_c8_new_cyl(fdc_cmd_block, ((unsigned char)track));
	nec_output(fdc_cmd_block[2]);
	status = chk_stat_2();

	/*
	 *	Wait for head settle time
	 */
	hd_wait(drive);
	return(status);
}

LOCAL recal IFN1(int, drive)
{
	/*
	 *	Send recalibrate drive command to the FDC and check the
	 *	results
 	 */
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

	note_trace1(FLOPBIOS_VERBOSE, "diskette_io:recal(drive=%d)", drive);

	put_c5_cmd(fdc_cmd_block, FDC_RECALIBRATE);
	put_c5_pad(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[0]);
	put_c5_drive(fdc_cmd_block, drive);
	put_c5_pad1(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[1]);
	return(chk_stat_2());
}

LOCAL chk_stat_2 IFN0()
{
	/*
	 *	This routine handles the interrupt received after
	 *	recalibrate, seek or reset to the adapter. The
	 *	interrupt is waited for, the interrupt status
	 *	sensed, and the result returned to the caller
	 */
	half_word diskette_status;

	/*
	 *	Check for interrupt
	 */
	if (wait_int() != FAILURE)
	{
		/*
		 *	Sense the interrupt and check the results
		 */
		nec_output(FDC_SENSE_INT_STATUS);
		if (results() != FAILURE)
		{

			if ((get_r3_ST0(fl_nec_status) & (ST0_SEEK_END | ST0_INTERRUPT_CODE_0))
				!= (ST0_SEEK_END | ST0_INTERRUPT_CODE_0))
			{
				return(SUCCESS);
			}
		
			/*
			 *	Abnormal termination of command
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			diskette_status |= FS_SEEK_ERROR;
			sas_store(FLOPPY_STATUS, diskette_status);
		}
	}

	return(FAILURE);
}

LOCAL wait_int IFN0()
{
	/*
	 *	Check whether an interrupt occurred; if it did, return
	 *	SUCCESS; if there was a time out return FAILURE
	 */
	half_word seek_status, diskette_status;
#ifndef	JOKER
	word savedAX, savedCS, savedIP;

	/*
	 *	Enable interrupts
	 */

	setIF(1);	

	/*
	 *	Notify OS that BIOS is about to "wait" for a
	 *	diskette interrupt. Any pending diskette
	 *	interrupt will be serviced here, so there's
	 *	no need for a subsequent sub-cpu call to
	 *	wait for the interrupt
	 *
 	 *	[[WTR - is this true, we do do 2 host_simulates...? ]]
	 */
	savedAX = getAX();
	savedCS = getCS();
	savedIP = getIP();

	setAH(INT15_DEVICE_BUSY);
	setAL(INT15_DEVICE_FLOPPY);

#ifdef NTVDM
	setCS(int15_seg);
	setIP(int15_off);
#else
	setCS(RCPU_INT15_SEGMENT);
	setIP(RCPU_INT15_OFFSET);
#endif  /* NTVDM */

	host_simulate();

	setAX(savedAX);
	setCS(savedCS);
	setIP(savedIP);

	/*
	 *	Call sub-cpu to do the "wait" for interrupt, saving
	 *	registers that would otherwise be corrupted
	 */
#ifdef FLOPPIES_KEEP_TRYING
   try_again:
#endif
	savedCS = getCS();
	savedIP = getIP();

#ifdef NTVDM
	setCS(wait_int_seg);
	setIP(wait_int_off);
#else
	setCS(RCPU_WAIT_INT_SEGMENT);
	setIP(RCPU_WAIT_INT_OFFSET);
#endif /* NTVDM */

	host_simulate();

	setCS(savedCS);
	setIP(savedIP);


#else	/* JOKER */


	/* Since we can't have a recursive CPU call, we'd be
	** well stuffed but for the fact that the default diskette
	** interrupt on SoftPC is actually a BOP which calls the "C"
	** function diskette_int() in "floppy_io.c". So most, if not
	** all, of the action takes place on the host side anyway.
	**
	** FieldFloppyInterrupts() simply checks if an interrupt
	** was generated, and does what the diskette_int() does,
	** but without the recursive CPU call.
	*/

	FieldFloppyInterrupts();

#endif	/* JOKER */


	/*
	 *	Check for success, or time out
	 */
	sas_load(SEEK_STATUS, &seek_status);
	if ((seek_status & SS_INT_OCCURRED) == 0)
	{

#ifdef FLOPPIES_KEEP_TRYING
		extern IBOOL fdc_interrupt_pending;

		/* If the CPU is very slow, or interrupt emulation
		 * has changed for the worst, then the low-priority
		 * floppy interrupt may not get through in the execution
	 	 * of the instructions allotted. This code looks at a
		 * global variable maintained by fla.c, which says whether
		 * or not the ICA has an un-processed diskette interrupt
		 * pending.
		 */
		if (fdc_interrupt_pending) {
			always_trace0("fdc_interrupt_pending, so try again");
			goto try_again;
		}
#endif /* FLOPPIES_KEEP_TRYING */

		sas_load(FLOPPY_STATUS, &diskette_status);
		diskette_status |= FS_TIME_OUT;
		sas_store(FLOPPY_STATUS, diskette_status);
		return(FAILURE);
	}
	else
	{
		seek_status &= ~SS_INT_OCCURRED;
		sas_store(SEEK_STATUS, seek_status);
		return(SUCCESS);
	}
}

LOCAL results IFN0()
{
#ifndef NEC_98

	/*
	 *	This routine will read anything that the FDC controller
	 *	returns following an interrupt
	 */
	half_word diskette_status_reg, diskette_status;
	int count;
	UTINY	val;

	/*
	 *	Wait for ready and direction
	 */
	count = 0;
	do
	{
		if (count++ >= FDC_TIME_OUT)
		{
			/*
			 *	Expect to return here when there is a
			 *	time out (not an FDC error)
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			diskette_status |= FS_TIME_OUT;
			sas_store(FLOPPY_STATUS, diskette_status);

			LOAD_RESULT_BLOCK;
			return(FAILURE);
		}
		inb(DISKETTE_STATUS_REG, &diskette_status_reg);
	} while ((diskette_status_reg & (DSR_RQM | DSR_DIO))
						!= (DSR_RQM | DSR_DIO));

	/*
	 *	Extract the results from the FDC
	 */
	count = 0;
	do
	{
		/*
		 *	Read a byte of result data
		 */
		inb(DISKETTE_DATA_REG, &val);
		sas_store( BIOS_FDC_STATUS_BLOCK + count, val );
		count++;

		/*
		 *	Do fixed wait for FDC update cycle time
		 */
		waitf(FDC_SETTLE);

		/*
		 *	Check for further result bytes
		 */
		inb(DISKETTE_STATUS_REG, &diskette_status_reg);
	} while ((diskette_status_reg & FDC_BUSY) && (count < MAX_RESULT_LEN));

	LOAD_RESULT_BLOCK;
	if ((diskette_status_reg & FDC_BUSY) && (count == MAX_RESULT_LEN))
	{
		/*
		 *	Problem with the FDC
		 */
		sas_load(FLOPPY_STATUS, &diskette_status);
		diskette_status |= FS_FDC_ERROR;
		sas_store(FLOPPY_STATUS, diskette_status);

		always_trace0("diskette_io: FDC error - output overdose");
		return(FAILURE);
	}

	return(SUCCESS);
#endif // !NEC_98
}

LOCAL read_dskchng IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Reads the state of the disk change line for "drive"
	 */
	half_word diskette_dir_reg;

	/*
	 *	Switch to the required drive
	 */
	motor_on(drive);

	/*
	 *	Read the diskette changed bit from the Digital Input
	 *	register
	 */
	inb(DISKETTE_DIR_REG, &diskette_dir_reg);
	return(((diskette_dir_reg & DIR_DISKETTE_CHANGE) != 0) ? FAILURE : SUCCESS);
#endif // !NEC_98
}

void drive_detect IFN1(int, drive)
{
	/*
	 *	Determines whether drive is 80 or 40 tracks
	 *	and updates state information accordingly
 	 */
	half_word disk_state;
	int track;

	/*
	 *	This method of determining the number of tracks on the
	 *	drive depends on seeking to a track that lies beyond the
	 *	last track of a 40 track drive, but is valid on an 80
	 *	track drive.
	 *
	 *	At this point the real track number on a 40 track drive
	 *	will be out of step with what the FDC thinks it is.
	 *
	 *	By seeking downwards to track 0, and observing when a
	 *	sense drive status reports that the drive is really at
	 *	track 0, a 40 and 80 track drive can be distinguished.
	 */
	note_trace1( GFI_VERBOSE, "drive_detect():start: DRIVE %x", drive );
	motor_on(drive);
	if (    (recal(drive) == SUCCESS)
             && (seek(drive, FDD_CLONK_TRACK) == SUCCESS))
	{
		track = FDD_JUDDER_TRACK + 1;
		do
		{
			if (--track < 0)
			{
				/*
				 *	40 track drive
				 */
				note_trace0( GFI_VERBOSE,
				             "drive_detect(): 40 TRACK" );
				sas_load(FDD_STATUS+drive, &disk_state);
				disk_state |= (DC_DETERMINED | FS_MEDIA_DET | RS_250);
				sas_store(FDD_STATUS+drive, disk_state);
				return;
			}

			if (seek(drive, track) != SUCCESS)
			{
				always_trace0( "drive_detect(): FAILURE" );
				return;
			}

			nec_output(FDC_SENSE_DRIVE_STATUS);
			nec_output((half_word)drive);
			(void )results();
		} while (get_r2_ST3_track_0(fl_nec_status) != 1);

		/*
		 *	Drive reports that it is at track 0; what does
		 *	the FDC think?
		 */
		if (track != 0)
		{
			note_trace0( GFI_VERBOSE, "drive_detect(): 40 TRACK" );
			/*
			 *	Must be a 40 track drive
			 */
			sas_load(FDD_STATUS+drive, &disk_state);
			disk_state |= (DC_DETERMINED | FS_MEDIA_DET | RS_250);
			sas_store(FDD_STATUS+drive, disk_state);
			return;
		}
		else
		{
			/*
			 *	Must be an 80 track drive
			 */
			note_trace0( GFI_VERBOSE, "drive_detect(): 80 TRACK" );
			sas_load(FDD_STATUS+drive, &disk_state);
			disk_state |= DC_80_TRACK;
			sas_store(FDD_STATUS+drive, disk_state);
			return;
		}
	}
}

LOCAL void waitf IFN1(long, time)
{
	UNUSED(time);
	/*
	 *	Fixed wait of "time" microseconds
	 */
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void fl_diskette_setup IFN0()
{
	/*
	 *	Identify what types of drives are installed in the system
	 *	and initialise the diskette BIOS state variables to known
	 *	values. Do not change declaration of rtc_wait to rtc_wait_flag
	 *	as there is a macro (yes MACRO!!) of the same name declared in
	 *	rtc_bios.h.
	 */
	half_word rtc_wait, lastrate;
	int drive;

	/*
	 *	Disable RTC wait function
	 */
	sas_load(RTC_WAIT_FLAG_ADDR, &rtc_wait);
	rtc_wait |= 1;
	sas_store(RTC_WAIT_FLAG_ADDR, rtc_wait);

	/*
	 *	Initialise other variables in the diskette data
	 *	area
	 */
	sas_storew(FDD_STATUS, 0);
	sas_storew(FDD_STATUS+1, 0);	/* drive b as well */
	sas_load(RATE_STATUS, &lastrate);
	rate_unitialised = TRUE;
	lastrate &= ~(RS_MASK | (RS_MASK >> 4));
	lastrate |= RS_MASK;
	sas_store(RATE_STATUS, lastrate);
	sas_store(SEEK_STATUS, 0);
	sas_store(MOTOR_COUNT, 0);
	sas_store(MOTOR_STATUS, 0);
	sas_store(FLOPPY_STATUS, 0);

	/*
	 *	Try to determine the type of each drive
	 */
	for (drive = 0; drive < MAX_FLOPPY; drive++)
	{
		drive_detect(drive);

		
		translate_old(drive);
	}
	
	/*
	 *	Force an immediate recalibrate
	 */
	sas_store(SEEK_STATUS, 0);

	/*
	 *	Enable RTC wait function
	 */
	sas_load(RTC_WAIT_FLAG_ADDR, &rtc_wait);
	rtc_wait &= ~1;
	sas_store(RTC_WAIT_FLAG_ADDR, rtc_wait);

	/*
	 *	Return without setting sectors transferred
	 */
	setup_end(IGNORE_SECTORS_TRANSFERRED);
}
#if defined(NEC_98)

NTSTATUS FloppyOpenHandle IFN3( int, drive,
                           PIO_STATUS_BLOCK, io_status_block,
                           PHANDLE, fd)
{

    PUNICODE_STRING unicode_string;
    ANSI_STRING ansi_string;
    OBJECT_ATTRIBUTES   floppy_obj;
    int drv;            // logical drive number
    NTSTATUS status;

    /*
    **  get device name
    */
    for( drv=0; drv<MAX_FLOPPY; drv++)
    {
        if(DauaTable[drv].FloppyNum == (UINT)drive)
                break;
    }
    if( drv == MAX_FLOPPY )
    {
        status = STATUS_UNSUCCESSFUL;
        return status;
    }

    RtlInitAnsiString( &ansi_string, DauaTable[drv].DeviceName);

    unicode_string =  &NtCurrentTeb()->StaticUnicodeString;

    status = RtlAnsiStringToUnicodeString(unicode_string,
                                          &ansi_string,
                                          FALSE
                                          );
    if ( !NT_SUCCESS(status) )
        return status;

    InitializeObjectAttributes(
                               &floppy_obj,
                               unicode_string,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    // this call will fail if the current user is not
    // the administrator or the volume is locked by other process.
    status = NtOpenFile(
                        fd,
                        FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                        &floppy_obj,
                        io_status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

    return status;

}

void SetErrorCode IFN1( NTSTATUS, status )
{

        switch( status )
        {
                case STATUS_IO_TIMEOUT:
                case STATUS_TIMEOUT:
                                        setAH(FLS_TIME_OUT);
                                        break;
                case STATUS_UNRECOGNIZED_MEDIA:
                case STATUS_NONEXISTENT_SECTOR:
                case STATUS_END_OF_FILE:
                case STATUS_FLOPPY_ID_MARK_NOT_FOUND:
                case STATUS_FLOPPY_WRONG_CYLINDER:
                                        setAH(FLS_MISSING_ID);
                                        break;
                case STATUS_DEVICE_DATA_ERROR:
                case STATUS_CRC_ERROR:
                                        setAH(FLS_DATA_ERROR);
                                        break;
                case STATUS_DATA_OVERRUN:
                                        setAH(FLS_OVER_RUN);
                                        break;
                case STATUS_MEDIA_WRITE_PROTECTED:
                                        setAH(FLS_WRITE_PROTECTED);
                                        break;
                case STATUS_DEVICE_NOT_READY:
                case STATUS_NO_MEDIA_IN_DEVICE:
                                        setAH(FLS_NOT_READY);
                                        break;
                default:                setAH(FLS_ERROR);
                                        break;
        }
        SetDiskBiosCarryFlag(1);
}

NTSTATUS GetGeometry IFN3(  HANDLE, fd,
                        PIO_STATUS_BLOCK, io_status_block,
                        PDISK_GEOMETRY, disk_geometry)
{
        NTSTATUS status;

    // get geomerty information, the caller wants this
        status = NtDeviceIoControlFile(fd,
                                        0,
                                        NULL,
                                        NULL,
                                        io_status_block,
                                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        NULL,
                                        0,
                                        (PVOID)disk_geometry,
                                        sizeof (DISK_GEOMETRY)
                                        );
        return status;
}

ULONG CalcActualLength IFN4( ULONG, RestCylLen, ULONG, RestTrkLen, BOOL*, fOverData, int, LogDrv)
{
        ULONG ActOpLen;
        ULONG PhyBytesPerSec;

        /*
        **      get requested length
        */
        ActOpLen = (ULONG)getBX();
        PhyBytesPerSec = 128 << (ULONG)getCH();
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( (getAH() & OP_SEEK) ? ((getDH() & 0x01) == 0) : (LastAccess[LogDrv].head == 0) )
//----------------------------------------------------------------------
        if( !( getDH() & 0x01 ) )
//----- Chg-End --------------------------------------------------------
        {
                if( getAH() & OP_MULTI_TRACK )
                {
                        if( ActOpLen > RestCylLen )
                        {
                                ActOpLen = RestCylLen;
                                *fOverData = TRUE;
                        }
                        else
                        {
                                ActOpLen = (ActOpLen / PhyBytesPerSec) * PhyBytesPerSec;
                                *fOverData = FALSE;
                        }
                }
                else
                {
                        if( ActOpLen > RestTrkLen )
                        {
                                ActOpLen = RestTrkLen;
                                *fOverData = TRUE;
                        }
                        else
                        {
                                ActOpLen = (ActOpLen / PhyBytesPerSec) * PhyBytesPerSec;
                                *fOverData = FALSE;
                        }
                }
        }
        else
        {
                if( ActOpLen > RestTrkLen )
                {
                        ActOpLen = RestTrkLen;
                        *fOverData = TRUE;
                }
                else
                {
                        ActOpLen = (ActOpLen / PhyBytesPerSec) * PhyBytesPerSec;
                        *fOverData = FALSE;
                }
        }

        return ActOpLen;

}

BOOL CheckDmaBoundary IFN3( UINT, segment, UINT, offset, UINT, length)
{

        ULONG EffectStart;
        ULONG EffectEnd;

        EffectStart = ((ULONG)segment << 4) + (ULONG)offset;
        if( length == 0 )
                EffectEnd = EffectStart + (64l * 1024l);
        else
                EffectEnd = EffectStart + length;

        /*
        **      Check Bank Boundary.
        **
        **      note:if length equal to 64KB ,then buffer is across surely
        **           bank boundary.
        */
        if( length != 0 )
        {
                if( (EffectStart & 0xffff0000l) != (EffectEnd & 0xffff0000l) )
                        return FALSE;
        }
        else
        {
                if( (EffectStart & 0x0000ffffl) != 0x00000000l )
                        return FALSE;
        }

        /*
        **      check segment wrap around
        **
        **      note: if length equal to 64kb, then buffer is surely
        **            to wrap around.
        */
        if( length != 0 )
        {
                if( ((ULONG)offset + (ULONG)length) > 0x10000l )
                        return FALSE;
        }

        return TRUE;

}

void fl_disk_recal IFN1( int, drive)
{
        /*
         *      recalibrate head in "drive"
         *
         *      Register inputs:
         *              AH      command code
         *              AL      DA/UA
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */

        WORD savedBX,savedCX,savedDX,savedES,savedBP;
        BYTE AHstatus, SecLenN;
        int LogDrv;
        NTSTATUS status;
        IO_STATUS_BLOCK io_status_block;
        HANDLE fd;
        DISK_GEOMETRY disk_geometry;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        LogDrv = ConvToLogical( (UINT)getAL() );

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                AHstatus = getAH();
                if( (AHstatus != FLS_EQUIPMENT_CHECK) && (AHstatus != FLS_TIME_OUT) )
                {
                        /*
                        **      Assume that the head is moved to track 0.
                        */
                        LastAccess[LogDrv].cylinder =
                        LastAccess[LogDrv].head     = 0;
                        SetErrorCode((NTSTATUS)STATUS_SUCCESS);
                }
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                AHstatus = getAH();
                if( (AHstatus != FLS_EQUIPMENT_CHECK) && (AHstatus != FLS_TIME_OUT) )
                {
                        /*
                        **      Assume that the head is moved to track 0.
                        */
                        LastAccess[LogDrv].cylinder =
                        LastAccess[LogDrv].head     = 0;
                        SetErrorCode((NTSTATUS)STATUS_SUCCESS);
                }
                return;
        }

        NtClose( fd );

        savedBX = getBX();
        savedCX = getCX();
        savedDX = getDX();
        savedES = getES();
        savedBP = getBP();

        setAX( (WORD)( ( (WORD)getAX() & 0x00ff ) | 0xd100 ) );
        setBX( (WORD)disk_geometry.BytesPerSector );
        setCL( 0 );
        setDH( 0 );
        setDL( 1 );

        for( SecLenN=0; disk_geometry.BytesPerSector > 128; SecLenN++)
                disk_geometry.BytesPerSector /= 2;

        setCH( SecLenN );
        setES( 0x0000 );
        setBP( 0x0000 );

        fl_disk_verify( drive );

        AHstatus = getAH();
        if( (getCF() == 1) && ( (AHstatus != FLS_EQUIPMENT_CHECK)&&
                                (AHstatus != FLS_TIME_OUT) ) )
        {
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
        }

        /*
        **      Assume that the head is moved to track 0.
        */
        LastAccess[LogDrv].cylinder =
        LastAccess[LogDrv].head     = 0;

        setBX(savedBX);
        setCX(savedCX);
        setDX(savedDX);
        setES(savedES);
        setBP(savedBP);
}

void fl_disk_sense IFN1( int, drive)
{
        /*
         *      sense condition in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        UCHAR status_st3 = 0;
        BOOL fFixedMode;
        BOOL f1Pt44Mode;
        BYTE ah_status;
        HANDLE fd;
        IO_STATUS_BLOCK io_status_block;
        NTSTATUS status;
        DISK_GEOMETRY DiskGeometry;
        PVOID temp_buffer;
        LARGE_INTEGER StartOffset;
        int LogDrv;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        /*
        **      check whether drive is fixed mode, and 1.44MB media
        **      id available.
        */
        fFixedMode = CheckDriveMode( fd );
        f1Pt44Mode = Check144Mode( fd );

        /*
        **      get drive parameter for dummy reaad
        */
        status = GetGeometry(fd,&io_status_block,&DiskGeometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                ah_status = getAH();
                SetErrorCode(status);

                if( (ah_status & OP_SENSE2) == OP_SENSE2 )
                {
                        if( f1Pt44Mode )
                                setAH( (BYTE)(getAH() | FLS_AVAILABLE_1PT44MB) );
                        else
                                setAH( (BYTE)(getAH() & ~FLS_AVAILABLE_1PT44MB) );
                }
                else if ( (ah_status & OP_NEW_SENSE) == OP_NEW_SENSE )
                {
                        if ( !fFixedMode )
                                setAH( (BYTE)(getAH() | FLS_2MODE) );
                        else
                                setAH( (BYTE)(getAH() & ~FLS_2MODE) );
                }

                return;
        }

        /*
        **      get FDC status
        */
        GetFdcStatus( fd, &status_st3 );

        NtClose( fd );

        if( (getAH() & OP_SENSE2) == OP_SENSE2 )
        {
                /*
                **      operate SENSE2(ah=c4h) command
                */

                SetSenseStatusHi( status_st3, &ah_status);

                if( f1Pt44Mode )
                        ah_status |= FLS_AVAILABLE_1PT44MB;
                else
                        ah_status &= ~FLS_AVAILABLE_1PT44MB;
        }
        else if( getAH() & OP_NEW_SENSE )
        {
                /*
                **      operate NewSENSE(ah=84h) command
                */

                SetSenseStatusHi( status_st3, &ah_status);

                if( fFixedMode )
                    ah_status &= ~(FLS_2MODE | FLS_HIGH_DENSITY | FLS_DETECTION_AI);
                else
                {
                    ah_status |= FLS_2MODE;
                    if( Check1MbInterface( drive ) )
                        ah_status &= ~(FLS_HIGH_DENSITY | FLS_DETECTION_AI);
                    else
                    {
                        ah_status &= FLS_DETECTION_AI;
                        ah_status |= FLS_HIGH_DENSITY;
                    }
                }
        }
        else
                /*
                **      operate SENSE(ah=04h) command
                */
                SetSenseStatusHi( status_st3, &ah_status);

        setAH(ah_status);
        if( ah_status >= FLS_DMA_BOUNDARY )
                SetDiskBiosCarryFlag(1);
        else
                SetDiskBiosCarryFlag(0);
        return;
}

void fl_disk_read_id IFN1( int, drive)
{
        /*
         *      read id information in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              CL      cylinder number
         *              DH      head number
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;
        int LogDrv;
        word savedAX;
        UCHAR SecLenN = 0;
        LARGE_INTEGER SpcfydCylNo;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

        NtClose( fd );

//----- Chg-Start <93.12.29> Bug-Fix ---------------------------------
//      /*
//      **      recalibrate
//      */
//      savedAX = getAX();
//      setAH(FLP_RECALIBRATE);
//      fl_disk_recal( drive );
//      setAX( savedAX );
//
//      LogDrv = ConvToLogical( getAL() );
//      LastAccess[LogDrv].cylinder = 0;
//      LastAccess[LogDrv].head = 0;
//
//      /*
//      **      check cylinder number validation
//      */
//      SpcfydCylNo = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
//      if( RtlLargeIntegerGreaterThanOrEqualTo( SpcfydCylNo, disk_geometry.Cylinders ) )
//      {
//              SetErrorCode( (NTSTATUS)STATUS_NONEXISTENT_SECTOR );
//              return;
//      }
//--------------------------------------------------------------------

        LogDrv = ConvToLogical( getAL() );

        if( getAH() & OP_SEEK )
        {
                /*
                **      check cylinder number validation
                */
                SpcfydCylNo = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                if( RtlLargeIntegerGreaterThanOrEqualTo( SpcfydCylNo, disk_geometry.Cylinders ) )
                {
                        SetErrorCode( (NTSTATUS)STATUS_NONEXISTENT_SECTOR );
                        return;
                }
        }

        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = getCL();
                LastAccess[LogDrv].head = getDH() & 0x01;
        }

        setCL( LastAccess[LogDrv].cylinder );
        setDH( LastAccess[LogDrv].head );
//----- Chg-End ------------------------------------------------------

        /*
        **      calculate sector length N
        */
        for( SecLenN=0; disk_geometry.BytesPerSector > 128; SecLenN++)
                disk_geometry.BytesPerSector /= 2;

        setCH( SecLenN );
        setDL( (BYTE)disk_geometry.SectorsPerTrack );
        setAH( FLS_NORMAL_END );
        SetDiskBiosCarryFlag(0);

}

void SetSenseStatusHi IFN2( UCHAR, st3, PBYTE, ah_status)
{

        if( st3 & ST3_WRITE_PROTECT )
                *ah_status = FLS_WRITE_PROTECTED;
        else if( st3 & ST3_READY )
                *ah_status = FLS_READY;

        if( st3 & ST3_DOUBLE_SIDE )
                *ah_status |= FLS_DOUBLE_SIDE;

}

BOOL CheckDriveMode IFN1( HANDLE, fd )
{

        BOOL fFixedMode;
        BOOL f2HD = FALSE;
        BOOL f2DD = FALSE;
        DISK_GEOMETRY   disk_geometry[20];
        ULONG   media_types;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;

        status = NtDeviceIoControlFile(fd,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &io_status_block,
                                       IOCTL_DISK_GET_MEDIA_TYPES,
                                       NULL,
                                       0L,
                                       (PVOID)&disk_geometry,
                                       sizeof(disk_geometry)
                                       );

        if (!NT_SUCCESS(status))
        {
            fFixedMode = TRUE;
            return fFixedMode;
        }

        media_types = io_status_block.Information / sizeof(DISK_GEOMETRY);

        for (; media_types != 0; media_types--)
        {
                switch (disk_geometry[media_types - 1].MediaType)
                {
                        case F3_1Pt2_512:                                // NEC 970620
                        case F5_1Pt2_512:
                        case F3_1Pt44_512:
#if 1                                                                    // NEC 941110
                        case F3_1Pt23_1024:                              // NEC 970620
                        case F5_1Pt23_1024:                              // NEC 941110
#else                                                                    // NEC 941110
                        case F5_1Pt2_1024:
#endif                                                                   // NEC 941110
                                f2HD = TRUE;
                                break;
                        case F3_720_512:
                        case F5_720_512:                                 // NEC 970620
                        case F3_640_512:
                        case F5_640_512:                                 // NEC 970620
                                f2DD = TRUE;
                        default:
                                break;
                }
        }

        if( (f2HD == TRUE) && (f2DD == TRUE) )
                fFixedMode = FALSE;
        else
                fFixedMode = TRUE;

        return fFixedMode;
}

BOOL Check144Mode IFN1( HANDLE, fd )
{

        BOOL f144Mode;
        DISK_GEOMETRY   disk_geometry[20];
        ULONG   media_types;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;

        status = NtDeviceIoControlFile(fd,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &io_status_block,
                                       IOCTL_DISK_GET_MEDIA_TYPES,
                                       NULL,
                                       0L,
                                       (PVOID)&disk_geometry,
                                       sizeof(disk_geometry)
                                       );

        if (!NT_SUCCESS(status))
        {
            f144Mode = FALSE;
            return f144Mode;
        }

        media_types = io_status_block.Information / sizeof(DISK_GEOMETRY);

        f144Mode = FALSE;

        for (; media_types != 0; media_types--)
        {
                switch (disk_geometry[media_types - 1].MediaType)
                {
                        case F3_1Pt44_512:
                                f144Mode = TRUE;
                        default:
                                break;
                }
        }

        return f144Mode;

}

BOOL Check1MbInterface IFN1( int, drive )
{

        half_word disk_equip2;
        UINT daua;
        int LogDrv;

        /*
        **      get system common area
        */
        sas_load( BIOS_NEC98_DISK_EQUIP2, &disk_equip2);

        daua = getAL();
        LogDrv = ConvToLogical( daua );

        if( disk_equip2 & ( 1 << (DauaTable[LogDrv].FloppyNum+4) ) )
                return FALSE;
        else
                return TRUE;

}

MEDIA_TYPE GetFormatMedia IFN2( BYTE, daua, WORD, PhyBytesPerSec )
{

        MEDIA_TYPE media_type;
        BYTE da;

        da = daua & 0xf0;
        switch( PhyBytesPerSec )
        {
#if 1                                                           // NEC 941110
                case 1024:      media_type = F5_1Pt23_1024;     // NEC 941110
#else                                                           // NEC 941110
                case 1024:      media_type = F5_1Pt2_1024;
#endif                                                          // NEC 941110
                                break;
                case 512:       if( da == 0x30 )
                                        media_type = F3_1Pt44_512;
                                else if( da == 0x90 )
                                        media_type = F5_1Pt2_512;
                                else
                                        media_type = F3_720_512;
                                break;
                case 256:
                case 128:

                default:        media_type = Unknown;
                                break;
        }

        return media_type;
}

void    GetFdcStatus IFN2( HANDLE, fd, UCHAR, *st3 )
{
        IO_STATUS_BLOCK io_status_block;

        /*
        **      get FDC status
        */
        NtDeviceIoControlFile(  fd,
                                0,
                                NULL,
                                NULL,
                                &io_status_block,
                                IOCTL_DISK_SENSE_DEVICE,
                                NULL,
                                0,
                                (PVOID)st3,
                                sizeof (UCHAR)
                                );
}

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\gfi_mpty.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * SoftPC Version 2.0
 *
 * Title	: Generic Floppy Interface Empty Module
 *
 * Description	: This module acts as a pseudo GFI diskette server, in the
 *		  case when the diskette in question does not physically exist
 *		  (eg accessing drive B: on a one drive system).
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 * Mods: (r3.2) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 */

#ifdef SCCSID
static char SccsID[]="@(#)gfi_empty.c	1.13 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "ios.h"
#include "trace.h"
#include "config.h"
#include "fla.h"
#include "gfi.h"
#include "trace.h"
#include "debug.h"


/* Routines called via vector table. These are all local now;
** The prototype typedefs are defined in gfi.h which is now th. only
** base floppy header file needed.        GM.
*/

LOCAL SHORT gfi_empty_drive_on
	IPT1( UTINY, drive );
LOCAL SHORT gfi_empty_drive_off
	IPT1( UTINY, drive );
LOCAL SHORT gfi_empty_change
	IPT1( UTINY, drive );
LOCAL SHORT gfi_empty_drive_type
	IPT1( UTINY, drive );
LOCAL SHORT gfi_empty_high
	IPT2( UTINY, drive, half_word, n);
LOCAL SHORT gfi_empty_reset
	IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
LOCAL SHORT gfi_empty_command
	IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res );
LOCAL VOID gfi_empty_init
	IPT1( UTINY, drive );


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */


/********************************************************/

/* Turn the empty floppy on and off. This forms an orthogonal interface
** with the host/generic floppy module which also has a XXX_active() func.
** 'Activating' the empty floppy means de-activating the real/slave one,
** and vice versa.
**
** NB: This is for SoftPC (gfi); the actual closing/opening must still be
** done in your floppy code! Also note that deactivating the empty floppy
** means activating the host one, but this is never done like that.
**                               GM.
*/

GLOBAL SHORT
gfi_empty_active IFN3(UTINY, hostID, BOOL, active, CHAR *, err)
{
UTINY drive = hostID - C_FLOPPY_A_DEVICE;

UNUSED( active );
UNUSED( err );

        gfi_empty_init(drive);
        return(C_CONFIG_OP_OK);
}

/********************************************************/


LOCAL VOID gfi_empty_init IFN1(UTINY,drive)
{
    /*
     * Initialise the floppy on the required drive:
     *
     *      0  - Drive A
     *      1  - Drive B
     */

    gfi_function_table[drive].command_fn	= gfi_empty_command;
    gfi_function_table[drive].drive_on_fn	= gfi_empty_drive_on;
    gfi_function_table[drive].drive_off_fn	= gfi_empty_drive_off;
    gfi_function_table[drive].reset_fn		= gfi_empty_reset;
    gfi_function_table[drive].high_fn		= gfi_empty_high;
    gfi_function_table[drive].drive_type_fn	= gfi_empty_drive_type;
    gfi_function_table[drive].change_fn		= gfi_empty_change;
}

/********************************************************/

LOCAL SHORT
gfi_empty_command
	IFN2(FDC_CMD_BLOCK *, command_block, FDC_RESULT_BLOCK *,result_block)
{
   int ret_stat = FAILURE;
   half_word D;

   /* Clear result status registers */
   put_r0_ST0 (result_block, 0);
   put_r0_ST1 (result_block, 0);
   put_r0_ST2 (result_block, 0);

   switch (get_type_cmd (command_block))
      {
   case FDC_READ_DATA:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf (trace_file, "\tGFI-empty: Read Data Command \n");
#endif
      break;

   case FDC_WRITE_DATA:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf (trace_file,"\tGFI-empty: Write Data Command\n");	
#endif
      break;

   case FDC_READ_TRACK:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file,"\tGFI-empty: Read Track Command \n");
#endif
      break;

   case FDC_SPECIFY:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "\tGFI-empty: Specify command\n");
#endif
      break;

   case FDC_READ_ID:
#ifndef PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "\tGFI-empty: read id command\n");
#endif
      break;

   case FDC_RECALIBRATE:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf (trace_file, "\tGFI-empty: Recalibrate command\n");
#endif
      /* Controller tries 77 pulses to get drive to head 0,
	 but fails, so we set Equipment Check */
      D = get_c5_drive(command_block);
      put_r1_ST0_unit(result_block, D);
      put_r1_ST0_equipment(result_block, 1);
      put_r1_ST0_seek_end(result_block, 1);
      put_r1_ST0_int_code(result_block, 1);
      ret_stat = SUCCESS;
      break;

   case FDC_SENSE_DRIVE_STATUS:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf (trace_file, "\tGFI-empty: Sense Drive Status command\n");
#endif
      break;

   case FDC_SEEK:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "\tGFI-empty: Seek command\n");
#endif
      break;

   case FDC_FORMAT_TRACK:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "\tGFI-empty: Format Track command\n");
#endif
      break;

#ifndef	PROD
   default:
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "GFI-empty: Unimplemented command, type %x\n",
	                      get_type_cmd (command_block));
#endif
      }

   return ((SHORT)ret_stat);
   }


LOCAL SHORT gfi_empty_drive_on IFN1(UTINY,drive)
{
#ifdef PROD
	UNUSED(drive);
#endif
    note_trace1(GFI_VERBOSE, "GFI-Empty: Drive on command - drive %x", drive);
    return(SUCCESS);
}

LOCAL SHORT gfi_empty_drive_off IFN1(UTINY,drive)
{
#ifdef PROD
	UNUSED(drive);
#endif
    note_trace1(GFI_VERBOSE, "GFI-Empty: Drive off command - drive %x", drive);
    return(SUCCESS);
}

LOCAL SHORT gfi_empty_high IFN2(UTINY,drive, half_word, rate)
{
	UNUSED(rate);
#ifdef PROD
	UNUSED(drive);
#endif
	
    note_trace1(GFI_VERBOSE, "GFI-Empty: Set high density command - drive %x",
                drive);
    return(FAILURE);
}


LOCAL SHORT gfi_empty_drive_type IFN1(UTINY,drive)
{
#ifdef PROD
	UNUSED(drive);
#endif
    note_trace1(GFI_VERBOSE, "GFI-Empty: Drive type command - drive %x", drive);
    return( GFI_DRIVE_TYPE_NULL );
}

LOCAL SHORT gfi_empty_change IFN1(UTINY,drive)
{
#ifdef PROD
	UNUSED(drive);
#endif
	note_trace1(GFI_VERBOSE, "GFI-Empty: Disk changed command - drive %x", drive);
    return(TRUE);
}


LOCAL SHORT gfi_empty_reset IFN2(FDC_RESULT_BLOCK *,result_block,UTINY, drive)
{
	UNUSED(drive);
	
	note_trace0(GFI_VERBOSE, "GFI-Empty: Reset command");

    /*
     * Fake up the Sense Interrupt Status result phase.  We don't know the
     * Present Cylinder No, so leave as zero.
     */

    put_r3_ST0(result_block, 0);
    put_r3_PCN(result_block, 0);

    return(SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\gfi.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * SoftPC Version 2.0
 *
 * Title	: Generic Floppy Interface (GFI)
 *
 * Description	: GFI is a layer that insulates the Floppy Adaptor (FLA)
 *		  from the type of device that is attached to VPC.  It
 *		  supports the slave PC, Virtual Diskette and a real
 *		  device attached to the host.
 *
 *		  GFI provides a suite of functions which can
 *		  be called to action Floppy commands.  GFI will
 *		  route these to the current resident device.
 *
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 * Mods: (r3.2) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 */

#ifdef SCCSID
static char SccsID[]="@(#)gfi.c	1.16 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "error.h"
#include "config.h"
#include "trace.h"
#include "fla.h"
#include "gfi.h"
#include "gfitest.h"
#include "error.h"
#include "debug.h"

/*
 * ============================================================================
 * External definitions
 * ============================================================================
 */

/*
 * The command/result phases of the FDC are described in the following database.
 *
 * The structure contains
 *
 *	- number of command bytes
 *	- number of result bytes
 *	- number of GFI result bytes
 *	- command class
 *	- result class
 *	- if dma is required
 *	- if an interrupt is generated
 *
 * A command byte count of 0 indicates a command that is handled by the FLA
 * itself and not passed to GFI.
 *
 * Note that Sense Interrupt Status is not considered a generic GFI command
 * but as a terminating command for the seek and recalibrate commands.
 * These two commands now have "result" phases as far as gfi is concerned
 * since the gfi level will ensure that a Sense Interrupt Status is performed
 * to provide the result phase.
 */

FDC_DATA_ENTRY gfi_fdc_description[] =
{
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 2, 0, TRUE,	TRUE  },	/* read track */
	{ 3, 0, 0, 6, 0, FALSE,	FALSE },	/* specify */
	{ 2, 1, 1, 7, 2, FALSE,	FALSE },	/* sense drive status */
	{ 9, 7, 7, 1, 0, TRUE,	TRUE  },	/* write data */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* read data */
	{ 2, 0, 2, 5, 0, FALSE,	TRUE  },	/* recalibrate */
	{ 0, 2, 2, 0, 3, FALSE,	FALSE },	/* sense int status  */
	{ 9, 7, 7, 1, 0, TRUE,	TRUE  },	/* write deleted data */
	{ 2, 7, 7, 4, 0, FALSE,	TRUE  },	/* read ID */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* read deleted data */
	{ 6, 7, 7, 3, 0, TRUE,	TRUE  },	/* format track */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 3, 0, 2, 8, 3, FALSE,	TRUE  },	/* seek */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* scan equal */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* scan equal */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* scan equal */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
};

/*
 * The function table that is built by the init function of the
 * individual GFI servers.
 */

GFI_FUNCTION_ENTRY gfi_function_table[MAX_DISKETTES];


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

GLOBAL SHORT gfi_fdc_command
IFN2(FDC_CMD_BLOCK *,command_block,FDC_RESULT_BLOCK *,result_block)
{
    /*
     * The main FDC command.  Route to the correct module.
     */

    int i;
    int ret_stat = SUCCESS;

#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
	gfi_test_command(command_block, result_block);
#endif

    if (get_type_cmd(command_block) == FDC_SPECIFY)
    {
	/*
	 * A specify command relates to all drives so call each in turn.
 	 * Not that even the empty drive allows specifies.
	 */

	for (i = 0; i < MAX_DISKETTES; i++)
	{
            put_type_drive(command_block, i);
	    /* some host floppies like to know the correct drive number */
	    (*gfi_function_table[i].command_fn)(command_block, result_block);
	}
    }
    else
 	/*
	 * All other commands specify the drive in the command.
   	 */

	ret_stat = (*gfi_function_table[get_type_drive(command_block)].command_fn)(command_block, result_block);

    return((SHORT)ret_stat);
}


GLOBAL SHORT gfi_drive_on IFN1(UTINY,drive)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
	gfi_test_drive_on(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].drive_on_fn)(drive));
}

GLOBAL SHORT gfi_drive_off IFN1(UTINY,drive)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
	gfi_test_drive_off(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].drive_off_fn)(drive));
}


GLOBAL SHORT gfi_reset IFN2(FDC_RESULT_BLOCK *,result_block, UTINY, drive)
{
    /*
     * Reset the specified drive.
     */

#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
	gfi_test_reset(result_block);
#endif

    /*
     * Reset the appropriate drive.
     */

    (*gfi_function_table[drive].reset_fn)(result_block, drive);

    /*
     * The result phase returns the data for a subsequent Sense Interrupt
     * Status, and should contain a "termination due to state change".
     */

    put_r3_ST0(result_block, 0);
    put_r1_ST0_int_code(result_block, 3);
    put_r3_PCN(result_block, 0);

    return(SUCCESS);
}

/*
** Set the specified datarate.
*/
GLOBAL SHORT gfi_high IFN2(UTINY,drive,half_word,datarate)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        gfi_test_high(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].high_fn)(drive,datarate));
}


GLOBAL SHORT gfi_drive_type IFN1(UTINY,drive)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        gfi_test_drive_type(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].drive_type_fn)(drive));
}

GLOBAL SHORT gfi_change IFN1(UTINY,drive)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        gfi_test_change(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].change_fn)(drive));
}

GLOBAL SHORT
gfi_floppy_valid
IFN4(UTINY, hostID, ConfigValues *,vals, NameTable *,table, CHAR *,err)
{
	UNUSED(table);
#ifdef SLAVEPC
	if (hostID == C_SLAVEPC_DEVICE)
		return host_slave_port_validate(host_expand_environment_vars(
			vals->string), err);
#endif /* SLAVEPC */

	return host_gfi_rdiskette_valid(hostID, vals, err);
}

GLOBAL VOID
gfi_floppy_change IFN2(UTINY, hostID, BOOL, apply)
{
#ifdef SLAVEPC
	if (hostID == C_SLAVEPC_DEVICE)
	{
		gfi_slave_change(hostID, apply);
		return;
	}
#endif /* SLAVEPC */

	host_gfi_rdiskette_change(hostID, apply);
}

GLOBAL SHORT
gfi_floppy_active IFN3(UTINY, hostID, BOOL, active, CHAR *,err)
{
#ifdef SLAVEPC
	if (hostID == C_SLAVEPC_DEVICE)
		return gfi_slave_active(hostID, active, err);
#endif /* SLAVEPC */

	return host_gfi_rdiskette_active(hostID, active, err);
}

GLOBAL VOID
gfi_attach_adapter IFN2(UTINY, adapter, BOOL, attach)
{
#ifdef SLAVEPC
	if (host_runtime_inquire(C_FLOPPY_SERVER) == GFI_SLAVE_SERVER)
	{
		if (adapter == 1)
			return;	/* No B adapter for slave PC */

		/* First cleaup the other possible adapters */
		if (config_get_active(C_FLOPPY_A_DEVICE))
			config_activate(C_FLOPPY_A_DEVICE, FALSE);
#ifdef FLOPPY_B
		if (config_get_active(C_FLOPPY_B_DEVICE))
			config_activate(C_FLOPPY_B_DEVICE, FALSE);
#endif /* FLOPPY_B */

		/* Activate the SLAVEPC device handler */
		config_activate(C_SLAVEPC_DEVICE, attach);
		return;
	}
	/* Must be a GFI_REAL_DISKETTE_SERVER */
	if (config_get_active(C_SLAVEPC_DEVICE))
		config_activate(C_SLAVEPC_DEVICE, FALSE);
#endif /* SLAVEPC */

	config_activate((UTINY)(C_FLOPPY_A_DEVICE + adapter), attach);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * function will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

/*
 * Initialize the GFI module.  Fill the function table with the GFI
 * "empty" server module (which will cause a timeout when accessed).
 */

GLOBAL VOID gfi_init IFN0()
{
	int i;

	host_runtime_set(C_FLOPPY_SERVER, GFI_REAL_DISKETTE_SERVER);

	for (i = 0; i < MAX_DISKETTES; i++)
		gfi_empty_active((UTINY)(C_FLOPPY_A_DEVICE+i),TRUE,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\floppy_i.c ===
#include "insignia.h"
#include "host_def.h"

extern void host_simulate();
/*
 * SoftPC Revision 3.0
 *
 *
 * Title	: Primary SFD BIOS floppy diskette functions
 *
 *
 * Description	: This module defines the floppy diskette BIOS functions
 *		  that are invoked directly from BOP instructions:
 *
 *		  diskette_io()		floppy diskette access functions
 *
 *		  diskette_post()	floppy diskette POST function
 *
 *		  diskette_int()	floppy diskette interrupt handler
 *
 *
 * Author	: Ross Beresford
 *
 *
 * Notes	:
 *
 */


/*
 * static char SccsID[]="@(#)floppy_io.c	1.14 03/02/94 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif

#include <stdio.h>
#include TypesH
#include "xt.h"
#include "bios.h"
#include "ios.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "gfi.h"
#include "fla.h"
#include "sas.h"
#include "floppy.h"
#include "equip.h"
#include "trace.h"
#include "ica.h"
#include "debug.h"

#include "tape_io.h"

#ifdef NTVDM
extern UTINY number_of_floppy;

#endif	/* NTVDM */

#ifndef	PROD
/*
 *	Internal functions (for tracing)
 */

static void rwvf_dump(op)
int	op;
{
	fprintf(trace_file, "(drive=%d,head=%d,track=%d,sec=%d,nsecs=%d",
		getDL(), getDH(), getCH(), getCL(), getAL());
	if (op != FL_DISK_VERF)
		fprintf(trace_file, ",addr=%x:%x", getES(), getBX());

	fprintf(trace_file, ")\n");
}


static void call_dump(op)
int op;
{
	half_word diskette_status;

	switch(op)
	{
	case	FL_DISK_RESET:
		fprintf(trace_file, "diskette_io:RESET()\n");
		break;
	case	FL_DISK_STATUS:
		fprintf(trace_file, "diskette_io:STATUS");
		sas_load(FLOPPY_STATUS, &diskette_status);
		fprintf(trace_file, "(status=0x%x)\n", diskette_status);
		break;
	case	FL_DISK_READ:
		fprintf(trace_file, "diskette_io:READ");
		rwvf_dump(op);
		break;
	case	FL_DISK_WRITE:
		fprintf(trace_file, "diskette_io:WRITE");
		rwvf_dump(op);
		break;
	case	FL_DISK_VERF:
		fprintf(trace_file, "diskette_io:VERIFY");
		rwvf_dump(op);
		break;
	case	FL_DISK_FORMAT:
		fprintf(trace_file, "diskette_io:FORMAT");
		rwvf_dump(op);
		break;
	case	FL_DISK_PARMS:
		fprintf(trace_file, "diskette_io:PARAMS(drive=%d)\n", getDL());
		break;
	case	FL_DISK_TYPE:
		fprintf(trace_file, "diskette_io:TYPE(drive=%d)\n", getDL());
		break;
	case	FL_DISK_CHANGE:
		fprintf(trace_file, "diskette_io:CHANGE(drive=%d)\n", getDL());
		break;
	case	FL_FORMAT_SET:
		fprintf(trace_file,
			"diskette_io:SET_FORMAT(drive=%d,type=", getDL());
		switch(getAL())
		{
		case MEDIA_TYPE_360_IN_360:
			fprintf(trace_file, "360K media in 360K drive)\n");
			break;
		case MEDIA_TYPE_360_IN_12:
			fprintf(trace_file, "360K media in 1.2M drive)\n");
			break;
		case MEDIA_TYPE_12_IN_12:
			fprintf(trace_file, "1.2M media in 1.2M drive)\n");
			break;
		case MEDIA_TYPE_720_IN_720:
			fprintf(trace_file, "720K media in 720K drive)\n");
			break;
		case MEDIA_TYPE_720_IN_144:
			fprintf(trace_file, "720K media in 1.44M drive)\n");
			break;
		case MEDIA_TYPE_144_IN_144:
			fprintf(trace_file, "1.44M media in 1.44M drive)\n");
			break;
		default:
			fprintf(trace_file, "SILLY)\n");
			break;
		}
		break;
	case	FL_SET_MEDIA:
		fprintf(trace_file,
			"diskette_io:SET_MEDIA(drive=%d,tracks=%d,sectors=%d)\n",
			getDL(), getCH(), getCL());
		break;
	
	default:
		fprintf(trace_file, "diskette_io:UNRECOGNISED(op=0x%x)\n", op);
		break;
	}
}


static void gen_dump()
{
	int status = getAH();

	fprintf(trace_file, "status=");

	if (status & FS_CRC_ERROR)
		fprintf(trace_file, "FS_CRC_ERROR|");
	if (status & FS_FDC_ERROR)
		fprintf(trace_file, "FS_FDC_ERROR|");
	if (status & FS_SEEK_ERROR)
		fprintf(trace_file, "FS_SEEK_ERROR|");
	if (status & FS_TIME_OUT)
		fprintf(trace_file, "FS_TIME_OUT|");
	switch (status & 0xf)
	{
	case FS_OK:
		fprintf(trace_file, "FS_OK");
		break;
	case FS_BAD_COMMAND:
		fprintf(trace_file, "FS_BAD_COMMAND");
		break;
	case FS_BAD_ADDRESS_MARK:
		fprintf(trace_file, "FS_BAD_ADDRESS_MARK");
		break;
	case FS_WRITE_PROTECTED:
		fprintf(trace_file, "FS_WRITE_PROTECTED");
		break;
	case FS_SECTOR_NOT_FOUND:
		fprintf(trace_file, "FS_SECTOR_NOT_FOUND");
		break;
	case FS_MEDIA_CHANGE:
		fprintf(trace_file, "FS_MEDIA_CHANGE");
		break;
	case FS_DMA_ERROR:
		fprintf(trace_file, "FS_DMA_ERROR");
		break;
	case FS_DMA_BOUNDARY:
		fprintf(trace_file, "FS_DMA_BOUNDARY");
		break;
	case FS_MEDIA_NOT_FOUND:
		fprintf(trace_file, "FS_MEDIA_NOT_FOUND");
		break;
	default:
		fprintf(trace_file, "SILLY");
		break;
	}
	fprintf(trace_file, ")\n");
}


static void return_dump(op)
int op;
{
	fprintf(trace_file, "diskette_io:RETURN(");
	switch(op)
	{
	case	FL_DISK_TYPE:
		switch(getAH())
		{
		case DRIVE_IQ_UNKNOWN:
			fprintf(trace_file, "ABSENT");
			break;
		case DRIVE_IQ_NO_CHANGE_LINE:
			fprintf(trace_file, "NO CHANGE LINE");
			break;
		case DRIVE_IQ_CHANGE_LINE:
			fprintf(trace_file, "CHANGE LINE");
			break;
		case DRIVE_IQ_RESERVED:
			fprintf(trace_file, "RESERVED");
			break;
		default:
			fprintf(trace_file, "SILLY");
			break;
		}
		fprintf(trace_file, ")\n");
		break;
	case	FL_DISK_PARMS:
		fprintf(trace_file, "addr=%x:%x,tracks=%d,sectors=%d,heads=%d,drives=%d,type=",
			getES(), getDI(), getCH(), getCL(), getDH(), getDL());
		switch(getBL())
		{
		case GFI_DRIVE_TYPE_NULL:
			fprintf(trace_file, "NULL,");
			break;
		case GFI_DRIVE_TYPE_360:
			fprintf(trace_file, "360K,");
			break;
		case GFI_DRIVE_TYPE_12:
			fprintf(trace_file, "1.2M,");
			break;
		case GFI_DRIVE_TYPE_720:
			fprintf(trace_file, "720K,");
			break;
		case GFI_DRIVE_TYPE_144:
			fprintf(trace_file, "1.44M,");
			break;
		case GFI_DRIVE_TYPE_288:
			fprintf(trace_file, "2.88M,");
			break;
		default:
			fprintf(trace_file, "SILLY,");
			break;
		}
		gen_dump();
		break;
	case	FL_SET_MEDIA:
		fprintf(trace_file, "addr=%x:%x,", getES(), getDI());
		gen_dump();
		break;
	case	FL_DISK_READ:
	case	FL_DISK_WRITE:
	case	FL_DISK_VERF:
	case	FL_DISK_FORMAT:
		fprintf(trace_file, "nsecs=%d,", getAL());
		gen_dump();
		break;
	case	FL_DISK_CHANGE:
	case	FL_DISK_RESET:
	case	FL_DISK_STATUS:
	case	FL_FNC_ERR:
	case	FL_FORMAT_SET:
		gen_dump();
		break;
	default:
		break;
	}

}
#endif /* nPROD */


void diskette_io()
{
	/*
	 *	Check for valid call and use secondary functions to
	 *	perform the required operation
	 *
	 *	Register inputs:
	 *		AH	operation required
	 *		DL	drive number
	 */
	half_word diskette_status;
	int op = getAH(), drive = getDL();


#ifndef	PROD
	if (io_verbose & FLOPBIOS_VERBOSE)
		call_dump(op);
#endif

#ifndef	JOKER
	/*
	 *	Enable interrupts
	 */

	setIF(1);	
#endif	/* JOKER */

	/*
	 *	Check operation required, using known invalid function
	 *	if operation is out of range
	 */

	if (!fl_operation_in_range(op))
		op = FL_FNC_ERR;

	/*
	 *	If the drive number is applicable in the operation, check it
	 */


	if (op != FL_DISK_RESET && op != FL_DISK_STATUS && op != FL_DISK_PARMS)
#ifdef NTVDM
		if (drive >= number_of_floppy)
#else
		if (drive >= MAX_FLOPPY)
#endif /* NTVDM */
			op = FL_FNC_ERR;




	/*
	 *	Save previous diskette status, initialise current diskette
	 *	status to OK
	 */

	sas_load(FLOPPY_STATUS, &diskette_status);
	setAH(diskette_status);
	sas_store(FLOPPY_STATUS, FS_OK);


	/*
	 *	Do the operation
	 */

	(*fl_fnc_tab[op])(drive);




#ifndef	PROD
	if (io_verbose & FLOPBIOS_VERBOSE)
		return_dump(op);
#endif
}


#ifndef	JOKER		/* Floppies handled v. weirdly on JOKER */

void diskette_int()
{
	/*
	 * The diskette interrupt service routine.  Mark the Seek Status to say
	 * the interrupt has occurred and terminate the interrupt.
	 */
	half_word seek_status;
	word savedAX, savedCS, savedIP;

	note_trace0(FLOPBIOS_VERBOSE, "diskette_int()");
	sas_load(SEEK_STATUS, &seek_status);
	sas_store(SEEK_STATUS, (IU8)(seek_status | SS_INT_OCCURRED));

	outb(ICA0_PORT_0, END_INTERRUPT);

	/*
	 *	Enable interrupts
	 */

	setIF(1);	

	/*
	 *	Notify OS that BIOS has completed a "wait" for
	 *	a diskette interrupt
	 */
	savedAX = getAX();
	savedCS = getCS();
	savedIP = getIP();

	setAH(INT15_INTERRUPT_COMPLETE);
	setAL(INT15_DEVICE_FLOPPY);
#ifdef NTVDM
	setCS(int15_seg);
	setIP(int15_off);
#else
	setCS(RCPU_INT15_SEGMENT);
	setIP(RCPU_INT15_OFFSET);
#endif /* NTVDM */

	host_simulate();

	setAX(savedAX);
	setCS(savedCS);
	setIP(savedIP);
}

#endif	/* ndef JOKER */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void diskette_post()
{
	/*
	 *	This routine performs the diskette BIOS initialisation
	 *	functionality in the POST.
	 */
	half_word diskette_id_reg, hf_cntrl, interrupt_mask;
#ifndef NTVDM
	half_word disk_state;
#endif
	EQUIPMENT_WORD equip_flag;

	note_trace0(FLOPBIOS_VERBOSE, "diskette_post()");

	/*
	 *	Set the diskette data rate to 250 kbs (low density)
	 */

	outb(DISKETTE_DCR_REG, DCR_RATE_250);

	/*
	 *	If there are any diskettes installed, check whether
	 *	they are accessed via a DUAL card or the old-style
	 *	adapter card
	 */

	sas_loadw(EQUIP_FLAG, &equip_flag.all);
	if (equip_flag.bits.diskette_present)
	{
		/*
		 *	Enable diskette interrupts
		 */

		inb(ICA0_PORT_1, &interrupt_mask);
		interrupt_mask &= ~(1 << CPU_DISKETTE_INT);
		outb(ICA0_PORT_1, interrupt_mask);

		/*
		 *	If a DUAL diskette/fixed disk adapter is fitted,
		 *	set the drive indicator for drive 0 accordingly
		 */

		inb(DISKETTE_ID_REG, &diskette_id_reg);
		sas_load(DRIVE_CAPABILITY, &hf_cntrl);
		hf_cntrl &= ~DC_DUAL;
		if ((diskette_id_reg & IDR_ID_MASK) == DUAL_CARD_ID)
			hf_cntrl |= DC_DUAL;
		sas_store(DRIVE_CAPABILITY, hf_cntrl);

#ifndef NTVDM	/* prevent floppies showing up in bios data area */
		/*
		 *	Setup the diskette BIOS state according to the
		 *	types of drives installed
		 */
		fl_diskette_setup();

		/*
		 *	If a second drive was discovered, update the
		 *	equipment flag accordingly
		 */

		sas_load(FDD_STATUS+1, &disk_state);
		if (disk_state != 0)
		{
			sas_loadw(EQUIP_FLAG, &equip_flag.all);
			equip_flag.bits.max_diskette = 1;
			sas_storew(EQUIP_FLAG, equip_flag.all);
		}
#endif  /* NTVDM */
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\gfi_sflp.c ===
#include "insignia.h"
#include "host_def.h"
/*[
	Name:		gfi_sflop.c
	Derived From:	2.0 gfi_sflop.c
	Author:		Jerry Kramskoy
	Created On:	Unknown
	Sccs ID:	@(#)gfi_sflop.c	1.16 08/14/92
	Purpose:
		Interface between FLA and the IBM PC. The PC acts as a server
		for remote procedure calls from the base product to access
		the 8272A controller.
	Notes:	Invalid FDC commands should be trapped by FLA

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/
#ifdef SLAVEPC

/* bigger than max pkt so as to accom extra header chars*/
#define MEGAPKTPLUS 1040

USHORT megapkt = 512;        /* packet size should be in range 120 < mega < 1024 */

#include <stdio.h>
#include TypesH
#include TimeH

#include "xt.h"
#include "bios.h"
#include "timeval.h"
#include "config.h"
#include "timer.h"
#include "dma.h"
#include "gfi.h"
#include "gfisflop.h"
#include "host.h"
#include "error.h"
#include "trace.h"
#include "fla.h"
#include "debug.h"

#ifdef SEGMENTATION
/*
 * The following #define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SLAVE_FLOPPY.seg"
#endif

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */
#undef  NO

#define DMA_DISKETTE_CHANNEL	2
#define NO	                2
#define MRD                     1
#define MWT	                0


/*
 * FDC command definitions
 * =======================
 */

typedef struct {
		int comid;		/* FDC command numbers */
		int dma;		/* see below */
   		int intstatus;		/* see below */
   		int delay;		/* delay needed */
		int n_resblk;		/* number of result bytes */
 		int n_comblk;		/* number of command bytes */
		} FDC_CMD_INFO;

/*
 * dma flag
 *     = NO  ... no dma for this command
 *     = MRD ... dma read (mem -> FDC)
 *     = MWT ... dma write (FDC -> mem)
 */

/* interrupt status
 *    = 0 ... command does not generate an interrupt.
 *    = 1 ... command does generate interrupt which is cleared by 
 *	      reading the FDC
 *    = 2 ... command generates an interrupt ... a sense interrupt command
 *	      must be issued to get the FDC results and re-enable further
 *	      command input to the FDC
 */

FDC_CMD_INFO fdc_cmd_info[] = {
/*
 *	  com_id	dma	intstatus	n_resblk
 *	  				delay		n_comblk
 */
	{ RDDATA,	MWT,	1,	0,	7,	9	},
	{ RDDELDATA,	MWT,	1,	0,	7,	9	},
	{ WTDATA,	MRD,	1,	0,	7,	9	},
	{ WTDELDATA,	MRD,	1,	0,	7,	9	},
	{ RDTRACK,	MWT,	1,	0,	7,	9	},
	{ RDID,		NO,	1,	0,	7,	2	},
	{ FMTTRACK,	MRD,	1,	0,	7,	6	},
	{ SCANEQ,	MRD,	1,	0,	7,	9	},
	{ SCANLE,	MRD,	1,	0,	7,	9	},
	{ SCANHE,	MRD,	1,	0,	7,	9	},
	{ RECAL,	NO,	2,	0,	2,	2	},
	{ SENSINT,	NO,	0,	0,	2,	1	},
	{ SPECIFY,	NO,	0,	1,	0,	3	},
	{ SENSDRIVE,	NO,	0,	0,	1,	2	},
	{ SEEK,		NO,	2,	0,	2,	3	},
};

#define	MAX_FDC_CMD	sizeof(fdc_cmd_info)/sizeof(fdc_cmd_info[0])

LOCAL UTINY sensint = 8;
LOCAL half_word channel = DMA_DISKETTE_CHANNEL;

LOCAL SHORT gfi_slave_drive_off IPT1( UTINY, drive );
LOCAL SHORT gfi_slave_drive_on IPT1( UTINY, drive );
LOCAL SHORT gfi_slave_change_line IPT1( UTINY, drive );
LOCAL SHORT gfi_slave_drive_type IPT1( UTINY, drive );
LOCAL SHORT gfi_slave_high IPT2( UTINY, drive, half_word, n);
LOCAL SHORT gfi_slave_reset IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
LOCAL SHORT gfi_slave_command IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res);
LOCAL wt_diskdata IPT2(unsigned int,n,int *,status);
LOCAL void cominfo IPT2(FDC_CMD_BLOCK *,cmd_block,FDC_CMD_INFO *,cmd_info);

LOCAL BOOL slave_opened;
LOCAL UTINY slave_type[MAX_DISKETTES];
LOCAL SHORT old_a_type, old_b_type;

/*
 * ============================================================================
 * External functions 
 * ============================================================================
 */
GLOBAL void gfi_slave_change IFN2(UTINY, hostID, BOOL, apply)
{
	int status;

	UNUSED(hostID);
	
	if (apply && slave_opened)
	{
		logout(&status);
		host_runtime_set(C_FLOPPY_SERVER, GFI_REAL_DISKETTE_SERVER);
		host_rpc_close();
		slave_opened = FALSE;
	}
}


GLOBAL SHORT gfi_slave_active IFN3(UTINY, hostID, BOOL, active, CHAR *, err)
{
	GFI_FUNCTION_ENTRY *tabP;
	int status;
	SHORT result;
	UTINY i;
	BOOL slaveServer;

	UNUSED(hostID);
	UNUSED(err);
	
	slaveServer = (host_runtime_inquire(C_FLOPPY_SERVER)==GFI_SLAVE_SERVER);
	if (active)
	{
		CHAR *slaveName = host_expand_environment_vars((CHAR *)
			config_inquire(C_SLAVEPC_DEVICE, NULL));
			
		if (!*slaveName)
		{
			if (slaveServer)
			{
				gfi_empty_active(hostID,TRUE,err);
			}
			config_set_active(C_SLAVEPC_DEVICE, FALSE);
			return C_CONFIG_OP_OK;
		}
		
		/*
		 * When SoftPC has already started talking to SlavePC just
		 * return that the open operation is ok, no need to attempt
		 * to re-open the link.  Maintain the flag telling us
		 * whether SlavePC is attached.
		 */
		if (!slave_opened)
		{
			if ( result = host_rpc_open(slaveName) )
				return result;		/* failed to open */
			else
			{
				if (!host_rpc_reset())
				{
					login(&status);
					if (status != SUCCESS)
					{
						host_rpc_close();
						return EG_SLAVEPC_NO_LOGIN;
					}
				}
				else
				{
					host_rpc_close();
					return EG_SLAVEPC_NO_RESET;
				}
			} 
		}

		slave_opened = TRUE;

		if (!slaveServer)
			return C_CONFIG_OP_OK;

		for ( i = 0; i < MAX_DISKETTES; i ++)
		{
			if (gfi_slave_drive_type(i) == GFI_DRIVE_TYPE_NULL)
				continue;

			tabP = &gfi_function_table[i];
			tabP->command_fn	= gfi_slave_command;
			tabP->drive_on_fn	= gfi_slave_drive_on;
			tabP->drive_off_fn	= gfi_slave_drive_off;
			tabP->reset_fn		= gfi_slave_reset;
			tabP->high_fn		= gfi_slave_high;
			tabP->drive_type_fn	= gfi_slave_drive_type;
			tabP->change_fn		= gfi_slave_change_line;
		}
	}
	else	/* detach the floppy */
	{
		gfi_slave_drive_type(0);
		gfi_slave_drive_type(1);

		if (slave_opened)
		{
			logout(&status);

			status = host_rpc_close();
			slave_opened = FALSE;
		}

		assert0(!status,  "gfi_sfloppy: host_rpc_close() failed\n");

		if (!slaveServer)
			return C_CONFIG_OP_OK;

		for ( i = 0; i < MAX_DISKETTES; i ++)
			gfi_empty_active(C_FLOPPY_A_DEVICE+i,TRUE,err);

		gfi_function_table[0].drive_type_fn = gfi_slave_drive_type;

		if (slave_type[1] != GFI_DRIVE_TYPE_NULL)
			gfi_function_table[1].drive_type_fn =
				gfi_slave_drive_type;
	}

	return C_CONFIG_OP_OK;
}

/****************************** on *****************************
 * purpose
 *	provide interface to slave PC for turning on drive motor
 ***************************************************************
 */
LOCAL SHORT
gfi_slave_drive_on IFN1(UTINY, drive)
{
   int status;
   static unsigned char DRIVE_A_ON = 0x1c;
   static unsigned char DRIVE_B_ON = 0x2d;

   note_trace1( GFI_VERBOSE, "GFI-slavefloppy: DRIVE %x ON", drive );
#ifndef PROD
#endif
   timer_int_enabled = 0;
   if( drive==0 )
       wt_digital_output_register(DRIVE_A_ON, 0, &status);
   else if( drive==1 )
       wt_digital_output_register(DRIVE_B_ON, 0, &status);
   else
       always_trace0( "gfi_slave_drive_on(): ERROR: bad drive parameter" );
   timer_int_enabled = 1;
   return(SUCCESS);
}





/****************************** off *****************************
 * purpose
 *	provide interface to slave PC for turning off drive motor
 ****************************************************************
 */
LOCAL SHORT
gfi_slave_drive_off IFN1(UTINY, drive)
{
   int status;
   static unsigned char DRIVE_A_OFF = 0xc;
   static unsigned char DRIVE_B_OFF = 0xd;

   note_trace1( GFI_VERBOSE, "GFI-slavefloppy: DRIVE %x OFF", drive );
#ifndef PROD
#endif
   timer_int_enabled = 0;
   if( drive==0 )
       wt_digital_output_register(DRIVE_A_OFF, 0, &status);
   else if( drive==1 )
       wt_digital_output_register(DRIVE_B_OFF, 0, &status);
   else
       always_trace0( "gfi_slave_drive_off(): ERROR: bad drive parameter" );
   timer_int_enabled = 1;
   return(SUCCESS);
}

/***************************** high ****************************
 * purpose
 *	provide interface to slave PC for selecting specified data rate
 ***************************************************************
 */
LOCAL SHORT
gfi_slave_high IFN2(UTINY, drive, half_word, rate)
{
int	status;

	UNUSED(drive);
	
	switch( rate ){
		case 0: datarate( DCR_RATE_500, &status ); break;
		case 1: datarate( DCR_RATE_300, &status ); break;
		case 2: datarate( DCR_RATE_250, &status ); break;
		default:
			always_trace0("ERROR:gfi_slave_high(): bad rate value");
			break;
	}
	if( status != SUCCESS )
		always_trace0( "ERROR: gfi_slave_high()" );
	return(status);
}


/************************** drive type *************************
 * purpose
 *	provide interface to slave PC for returning drive type
 ***************************************************************
 */
LOCAL SHORT
gfi_slave_drive_type IFN1(UTINY, drive)
{
	int	status;
	unsigned char	dtype;

	/*
	 * Return the last drive type if the slave device is
	 * not currently opened.
	 */
	if (!slave_opened)
		return (slave_type[drive]);

	note_trace1( GFI_VERBOSE, "gfi_slave_drive_type(): drive %x", drive );
	drivetype( drive, &dtype, &status );
	note_trace2( GFI_VERBOSE, "dtype=%x status=%x", dtype, status );
#ifndef PROD
	switch( dtype )
	{
		case GFI_DRIVE_TYPE_NULL:
			note_trace0( GFI_VERBOSE, "Bad drive" );
			break;
		case GFI_DRIVE_TYPE_360:
			note_trace0( GFI_VERBOSE, "360k" );
			break;
		case GFI_DRIVE_TYPE_12:
			note_trace0( GFI_VERBOSE, "1.2M" );
			break;
		case GFI_DRIVE_TYPE_720:
			note_trace0( GFI_VERBOSE, "720k" );
			break;
		case GFI_DRIVE_TYPE_144:
			note_trace0( GFI_VERBOSE, "1.44M" );
			break;
		default: always_trace0( "Unrecognised drive value" );
			break;
	}
#endif /* !PROD */

	if ( status != SUCCESS )
		always_trace0( "ERROR: gfi_slave_drive_type()" );

	slave_type[drive] = dtype;
	return dtype;
	/* return(GFI_DRIVE_TYPE_360); */
}

/************************* diskette change *********************
 * purpose
 *	provide interface to slave PC for diskette change notification
 ***************************************************************
 */
LOCAL SHORT
gfi_slave_change_line IFN1(UTINY, drive)
{
	int	status, changed;

	diskchange( drive, &changed, &status );
	note_trace2( GFI_VERBOSE, "drive %x %s",
	             drive, changed ? "CHANGED" : "NOT CHANGED" );
	if( changed!=1 && changed!=0 )
		always_trace1( "ERROR: gfi_slave_change_line(): bad value:%x", changed );
	if( status != SUCCESS )
		always_trace0( "ERROR: gfi_slave_change_line()" );
	return( changed );
}



/****************************** reset *****************************
 * purpose
 *	provide interface to slave PC for resetting the FDC
 ******************************************************************
 */
LOCAL SHORT
gfi_slave_reset IFN2(FDC_RESULT_BLOCK *, r, UTINY, drive)
{
   int status, i;
   static unsigned char DRIVE_RESET = 0x08;
   static unsigned char DRIVE_A_OFF = 0x0c;
   static unsigned char DRIVE_B_OFF = 0x0d;
   static unsigned char RECALIBRATE[] = {7, 0};
   unsigned char res[10];
   unsigned char drive_off;
   int nres;

	note_trace1( GFI_VERBOSE, "GFI-slavefloppy: Reset command drive %x", drive );
#ifndef PROD
#endif
	if( drive==0 )
		drive_off = DRIVE_A_OFF;
	else if( drive==1 )
		drive_off = DRIVE_B_OFF;
	else
		always_trace0( "gfi_slave_reset(): ERROR: bad drive parameter");

   clrintflag(&status);
   if (status != FDCSUCCESS)
       return(status);
   wt_digital_output_register(DRIVE_RESET, 0, &status);
   if (status == FDCSUCCESS)
   {
       timer_int_enabled = 0;
       wt_digital_output_register(drive_off, 1, &status);
       timer_int_enabled = 1;
       if (status == FDCSUCCESS)
       {
           wt_floppy_disk_controller(1,&sensint,0, 0, &status);
	   if (status == FDCSUCCESS)
	   {
	       rd_floppy_disk_controller(&nres, res, &status);
	       if (status == FDCSUCCESS)
	       {
		   for (i=0; i<nres; i++)
		       r[i] = res[i];
#ifndef PROD
#endif
/*    
		   gfi_slave_drive_on();
		   gfi_slave_command(RECALIBRATE, res);
		   gfi_slave_drive_off();
 */
	       }
	       else
		   always_trace1("RESET error 3, status = %x", status);
	   }
	   else
	       always_trace1("RESET error 2, status = %x", status);
       }
       else
	   always_trace1("RESET error 1, status = %x", status);
   }
   else
       always_trace1("RESET error 1, status = %x", status);
}

/*
** A macro to tell us something when something goes wrong
*/
#define failure(i)	always_trace0( "failed" ); return( i );

/**************************** command *****************************
 * purpose
 *	provide interface to slave PC for performing FDC commands
 ******************************************************************
 */

LOCAL SHORT
gfi_slave_command
          IFN2(FDC_CMD_BLOCK *, c, FDC_RESULT_BLOCK *,r)
{
   FDC_CMD_INFO info;
   sys_addr dummy;
   word ndma;
   int err, status, nres;
   unsigned int nXfer;

   err = 0;

   note_trace1( GFI_VERBOSE, "GFI-slavefloppy: Command %x", get_type_cmd(c));
#ifndef PROD
#endif

   cominfo(c,&info);
   if (info.comid == -1)
   {
	failure(LOGICAL);
   }

/*
 * determine how much data is needed for this command
 * in case we are doing DMA or 'pseudo-nonDMA'
 */

   if (!fla_ndma)
   {
   	dma_enquire(channel, &dummy, &ndma);
	nXfer = ndma+1;
   }
   else
   {
	fla_ndma_enquire(&nXfer);
	ndma = nXfer-1;
   }
   note_trace3( GFI_VERBOSE, "Bytes to transfer nXfer=%x ndma=%x mode=%s",
                nXfer, ndma, fla_ndma ? "NON-DMA" : "DMA" );

/*
 * set up the slave PC's disk buffer
 * with any data to be read by the FDC
 */

   if (info.dma == MRD)
       if (wt_diskdata(nXfer,  &status))
       {
	   failure(LOGICAL);
       }
       else
       {
	   if (status != FDCSUCCESS)
           {
	       failure(PROTOCOL);
           }
       }

/*
 * set up the DMA controller for the transfer
 */

   if (info.dma != NO)
       if (wt_dma_controller((unsigned int) ndma, info.dma, &status))
       {
           failure(LOGICAL);
       }
       else
          if (status != FDCSUCCESS)
          {
	      failure(PROTOCOL);
          }


/* 
 * issue the FDC command. Block the slavePC from 
 * returning until an interrupt or timeout
 * (provided the command is meant to interrupt!!)
 */

   clrintflag(&status);
   if (status != FDCSUCCESS)
   {
       failure(PROTOCOL);
   }

   if (wt_floppy_disk_controller(info.n_comblk, c, info.intstatus, 
		info.delay, &status))
   {
       failure(LOGICAL);
   }
   else
       if (status != FDCSUCCESS)
       {
           failure(PROTOCOL);
       }




/*
 * issue a sense interrupt command if required
 */

   if (info.intstatus == 2)
       if (wt_floppy_disk_controller(1, &sensint, 0, 0, &status))
       {
           failure(LOGICAL);
       }
       else
           if (status != FDCSUCCESS)
           {
               failure(PROTOCOL);
           }


/* delay if needed
 */

    if (info.delay)
    {
        timer_int_enabled = 0;
        timer_int_enabled = 1;
    }


/*
 * read the FDC results
 */

   if (info.n_resblk)
       if (rd_floppy_disk_controller(&nres, r, &status))
       {
	   failure(LOGICAL);
       }
       else
	   if (status != FDCSUCCESS)
           {
	       failure(PROTOCOL);
           }
	   else
   	       if (nres != info.n_resblk)
	       {
#ifndef	PROD
		   printf("result block discrepancy !!!\n");
#endif
       		   failure(PROTOCOL);
	       }


/* dump out results 
 */
#ifndef PROD
#endif

/*
 * read back any data from
 * the diskette
 */

   if (info.dma == MWT && !(r[1] & 4))
   {
       if (rd_diskdata(nXfer,  &status))
       {
	   failure(LOGICAL);
       }
       else
	   if (status != FDCSUCCESS)
           {
	       failure(PROTOCOL);
           }
   }


   return(0);
}


/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */






/******************************* wt_diskdata *********************************
 */
LOCAL wt_diskdata IFN2(unsigned int,n,int *,status)
{
   char diskdata[MEGAPKTPLUS];
   word nbytes, ln;
   int ioff;

   ln = (word) n;
   ioff = 0;
   while (ln > 0)
   {
      nbytes = (ln > megapkt)? megapkt: ln;
      dma_request(channel, diskdata, nbytes);
      if (wt_disk_buffer(nbytes, diskdata, ioff, status))
	  return(1);
      else
    	if (*status != FDCSUCCESS)
	      break;
      ln -= nbytes;
      ioff += nbytes;
   }
   return(0);
}





/******************************* rd_diskdata *********************************
 */
rd_diskdata(n, status)
unsigned int  n;
int *status;

{
   char diskdata[1024];
   word nbytes, ln;
   int ioff;
   int errors=0;

   ln = (word) n;
   ioff = 0;
   note_trace1( GFI_VERBOSE, "Reading 0x%x bytes...", n );
   while (ln > 0)
   {
      nbytes = (ln > megapkt)? megapkt: ln;
      if (rd_disk_buffer(nbytes, diskdata, ioff, status)){
	  return(1);
      }
      dma_request(channel, diskdata, nbytes);
      if (*status != FDCSUCCESS){
          ++errors;
          break;
      }
      ln -= nbytes;
      ioff += nbytes;
   }
#ifndef PROD
   if( errors>0 ){
      note_trace3( GFI_VERBOSE,
                   "Read 0x%x bytes of 0x%x with errors=%d",ioff , n, errors );
   }else
      note_trace1( GFI_VERBOSE, "Read 0x%x bytes OK", ioff );
#endif
   return(0);
}


/****************************** cominfo *************************************
 */

LOCAL void cominfo IFN2(FDC_CMD_BLOCK *,cmd_block,FDC_CMD_INFO *,cmd_info)
{
    int i;

    for (i = 0; i < MAX_FDC_CMD; i++)
	if (fdc_cmd_info[i].comid == get_c0_cmd(cmd_block))
	    break;

    if (i >= MAX_FDC_CMD)
	cmd_info->comid = -1;
    else if (fdc_cmd_info[i].comid == SENSINT)
	cmd_info->comid = -2;
    else
	*cmd_info = fdc_cmd_info[i];
}
#endif /* SLAVEPC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\gfi_ibm.c ===
#include "insignia.h"
#include "host_def.h"
#ifdef SLAVEPC

/* max size of packet with headers and trailers */
#define MEGAPKTPLUS 1040

/*
 * VPC-XT Revision 1.0
 *
 * Title	: Client Remote Procedure Call Library for FDC, FDD
 *
 * Description	: Interface to RS232 link to slave IBM PC. Packages
 *		  up diskette requests, calls the remote procedure 
 *		  on the PC, and returns the results.
 *
 * Author	: Jerry Kramskoy
 *
 * Notes	: 
 */

/* from gfi_sflop.c */
extern int megapkt;

#include <stdio.h>
#include TypesH

#include "xt.h"
#include "config.h"
#include "gfi.h"
#include "gfisflop.h"
#include "host.h"
#include "error.h"
#include "trace.h"
#include "fla.h"
#include "debug.h"

#ifdef SEGMENTATION
/*
 * The following #define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SLAVE_FLOPPY.seg"
#endif

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */
#ifdef SCCSID
static char SccsID[]="@(#)gfi_IBM.c	1.9 8/10/92 Copyright Insignia Solutions Ltd.";
#endif

/*
 * ============================================================================
 * External functions 
 * ============================================================================
 */

/*
** Set the diskete data rate.
** 2 send paramaters: Command ID and data rate.
** 1 result parameter: Command ID.
*/
datarate( drate, status )
unsigned char drate;
int *status;
{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	*status = LINERR;
	cmd_pkt[0] = DATARATE;
	cmd_pkt[1] = drate;
	if (!host_rpc_action(2, cmd_pkt, &res_len, res_pkt))
		if (res_len == 1 && res_pkt[0] == DATARATE)
			*status = FDCSUCCESS;
	return(0);
}
/*
** Get the drive type.
** 1 send paramater: Command ID.
** 2 result parameters: Command ID and disk type.
*/
drivetype( drive, dtype, status )
int drive;
unsigned char *dtype;
int *status;
{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	*status = LINERR;
	cmd_pkt[0] = DRIVETYPE;
	cmd_pkt[1] = (unsigned char)drive;
	if (!host_rpc_action(2, cmd_pkt, &res_len, res_pkt))
		if (res_len == 2 && res_pkt[0] == DRIVETYPE){
			*status = FDCSUCCESS;
			*dtype = res_pkt[1];
		}
	return(0);
}
/*
** Get the diskette change status.
** 1 send paramater: Command ID.
** 2 result parameters: Command ID and changed.
*/
diskchange( drive, changed, status )
int drive, *changed, *status;
{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	*status = LINERR;
	cmd_pkt[0] = DISKCHANGE;
	cmd_pkt[1] = (unsigned char)drive;
	if (!host_rpc_action(2, cmd_pkt, &res_len, res_pkt))
		if (res_len == 2 && res_pkt[0] == DISKCHANGE){
			*status = FDCSUCCESS;
			*changed = (int) res_pkt[1];
		}
	return(0);
}

	clrintflag(status)
	int *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   *status = LINERR;
	   cmd_pkt[0] = CLRINTFLAG;
	   if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	       if (res_len == 1 && res_pkt[0] == CLRINTFLAG)
	           *status = FDCSUCCESS;
	   return(0);
	}




	login(status)
	int *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   *status = LINERR;
	   cmd_pkt[0] = LOGIN;
	   if (!host_rpc_reset())
	       if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	           if (res_len == 1 && res_pkt[0] == LOGIN)
		       *status = FDCSUCCESS;
	   return(0);
	}



	logout(status)
	int *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   cmd_pkt[0] = LOGOUT;
	   *status = LINERR;
	   if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	       if (res_len == 1 && res_pkt[0] == LOGOUT)
		   *status = FDCSUCCESS;
	   return(0);
	}





	wt_dma_controller(ndma, dirn, status)
	int ndma, dirn, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	unsigned char *pkt_ptr;
	   unsigned short lndma;
	   err = 1;
	   if (ndma >= 0 && ndma <= 0xffff)
	   {
	       err = 0;
	       *status = LINERR;
	       lndma = (unsigned short) ndma;
	       pkt_ptr = (unsigned char *) &lndma;
	       cmd_pkt[0] = WTDMA;
#ifdef	BIGEND
	       /* Bigendian e.g. mc68000 */
	       cmd_pkt[1] = *pkt_ptr;
	       cmd_pkt[2] = *(pkt_ptr+1);
#else
	       /* Little endian e.g. VAX */
	       cmd_pkt[1] = *(pkt_ptr+1);
	       cmd_pkt[2] = *pkt_ptr;
#endif
	       cmd_pkt[3] = (unsigned char) dirn;
	       if (!host_rpc_action(4, cmd_pkt, &res_len, res_pkt))
	           if (res_len == 1 && res_pkt[0] == WTDMA)
		       *status = FDCSUCCESS;
	   }
	   return(err);
	}





	wt_digital_output_register(dorbyte, block, status)
	unsigned char dorbyte;
	int block, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   *status = LINERR;
	   cmd_pkt[0] = WTDOR;
	   cmd_pkt[1] = dorbyte;
	   cmd_pkt[2] = (unsigned char) block;
	   if (!host_rpc_action(3, cmd_pkt, &res_len, res_pkt))
	       if (res_len == 2 && res_pkt[0] == WTDOR)
		   *status = (int) res_pkt[1];
	   return(0);
	}





	test_interrupt(intstate, status)
	int *intstate, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   *status = LINERR;
	   cmd_pkt[0] = TESTINT;
	   if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	       if (res_len == 2 && res_pkt[0] == TESTINT)
		   {
		       *intstate = (int) res_pkt[1];
		       *status = FDCSUCCESS;
		   }
	   return(0);
	}


	wt_floppy_disk_controller(ncom, command, block, delay, status)
	unsigned char *command;
	int ncom, block, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	unsigned char *pkt_ptr;
	int	i;

#ifndef PROD
	if( io_verbose & GFI_VERBOSE )
	{
		fprintf(trace_file,"gfi_IBM: cmd ");
		for( i = 0; i < ncom; i++ )
			fprintf(trace_file,"%x ",*(command + i) );
		fprintf(trace_file,"\n");
	}
#endif
	   err = 1;
	   if (ncom > 0 && ncom < 10)
	   {
	       err = 0;
	       *status = LINERR;
	       cmd_pkt[0] = WTFDC;
	       cmd_pkt[1] = (unsigned char) ncom;
	       cmd_pkt[2] = (unsigned char) block;
	       cmd_pkt[3] = (unsigned char) delay;
	       pkt_ptr = &cmd_pkt[4];
	       for (i=0; i<ncom; i++)
		   *pkt_ptr++ = *command++;
	       if (!host_rpc_action(4+ncom, cmd_pkt, &res_len, res_pkt))
	           if (res_len == 2 && res_pkt[0] == WTFDC)
		       *status = (int) res_pkt[1];
	   }
           return(err);
	}




	rd_floppy_disk_controller(nres, result, status)
	int *nres, *status;
        unsigned char *result;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;
	unsigned char *pkt_ptr;
	int	i;

	    *status = LINERR;
	    cmd_pkt[0] = RDFDC;
	    if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	        if (res_len >= 3 && res_pkt[0] == RDFDC)
		{
		    *nres = res_pkt[2];
		    if (*nres>=0 && *nres<8)
		    {
		        *status = res_pkt[1];
		        pkt_ptr = &res_pkt[3];
		        for (i=0; i< *nres; i++)
			    *result++ = *pkt_ptr++;
		    }
		}
#ifndef PROD
	if( io_verbose & GFI_VERBOSE )
	{
		fprintf(trace_file,"gfi_IBM: res ");
		for( i = 0; i < *nres; i++ )
			fprintf(trace_file,"%x ",*(result - *nres + i) );
		fprintf(trace_file,"\n");

	}
#endif
	    return(0);
	}






static unsigned char *q;  /* spare ptr */

	wt_disk_buffer(ndwt, diskdata, ioff, status)
	unsigned char *diskdata;
	int ndwt, ioff, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	unsigned char *pkt_ptr;
	int	i;

	   unsigned short lioff, nndwt;
	   err = 1;
	   if (ndwt <= megapkt)
	   {
	       err = 0;
	       *status = LINERR;
	       cmd_pkt[0] = WTDISKB;

		nndwt = (unsigned short) ndwt;
                q = (unsigned char *) &nndwt;

	       lioff = (unsigned short) ioff;
	       pkt_ptr = (unsigned char *) &lioff;
#ifdef	BIGEND
	       /* Bigendian e.g. mc68000 */
                cmd_pkt[1] = *q++;
                cmd_pkt[2] = *q;
                cmd_pkt[3] = *pkt_ptr++;
                cmd_pkt[4] = *pkt_ptr;
#else
	       /* Little endian e.g. VAX */
                cmd_pkt[1] = *(q+1);
                cmd_pkt[2] = *q;
                cmd_pkt[3] = *(pkt_ptr+1);
                cmd_pkt[4] = *pkt_ptr;
#endif
	       pkt_ptr = &cmd_pkt[5];
	       for (i=0; i<ndwt; i++)
		   *pkt_ptr++ = *diskdata++;

	       if (!host_rpc_action(5+ndwt, cmd_pkt, &res_len, res_pkt))
	           if (res_len == 1 && res_pkt[0] == WTDISKB)
		       *status = FDCSUCCESS;
	   }
           return(err);
	}






	rd_disk_buffer(ndrd, diskdata, ioff, status)
	unsigned char *diskdata;
	int ndrd, ioff, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;
	unsigned char *pkt_ptr;
	int	i;
	    unsigned short lioff, nndrd;
	    *status = LINERR;
	    cmd_pkt[0] = RDDISKB;

	    nndrd = (unsigned short) ndrd;
            q = (unsigned char *) &nndrd;
	    lioff = (unsigned short) ioff;
	    pkt_ptr = (unsigned char *) &lioff;
#ifdef	BIGEND
	    /* Bigendian e.g. mc68000 */
        cmd_pkt[1] = *q++;
        cmd_pkt[2] = *q;
        cmd_pkt[3] = *pkt_ptr++;
        cmd_pkt[4] = *pkt_ptr;
#else
       /* Little endian e.g. VAX */
        cmd_pkt[1] = *(q+1);
        cmd_pkt[2] = *q;
        cmd_pkt[3] = *(pkt_ptr+1);
        cmd_pkt[4] = *pkt_ptr;
#endif
	    if (!host_rpc_action(5, cmd_pkt, &res_len, res_pkt))
            {
	        if (res_len == ndrd+1 && res_pkt[0] == RDDISKB)
		{
	            *status = FDCSUCCESS;
	    	    pkt_ptr = &res_pkt[1];
	    	    for (i=0; i<ndrd; i++)
		        *diskdata++ = *pkt_ptr++;
		}
		else
		{
                    always_trace1( "host_rpc_action():BAD LENGTH:%x", res_len );
		}
            }
            else
            {
                always_trace0( "host_rpc_action():FAILED" );
            }
           return(0);
	}




	printPC(string, status)
	int *status;
	char *string;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	int	i;

	    err = 1;
	    if ((i = strlen(string)) <= 100)
	    {
		err = 0;
                *status = LINERR;
		cmd_pkt[0] = PRINTSTRING;
		cmd_pkt[1] = (unsigned char) i;
		strcpy(&cmd_pkt[2], string);
		if (!host_rpc_action(3+i, cmd_pkt, &res_len, res_pkt))
		    if (res_len == 1 && res_pkt[0] == PRINTSTRING)
			*status = FDCSUCCESS;
	    }
	    return(err);
	}





	flagPC(nflags, flags, status)
	int nflags, *status;
	unsigned char *flags;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	unsigned char *pkt_ptr;
	int	i;

	    err = 1;
	    if (nflags > 0 && nflags <= MAXFLAGS)
	    {
		err = 0;
		*status = LINERR;
		cmd_pkt[0] = IBMFLAGS;
		cmd_pkt[1] = (unsigned char) nflags;
		pkt_ptr = &cmd_pkt[2];
	        for (i=0; i<nflags; i++)
		    *pkt_ptr++ = *flags++;
		if (!host_rpc_action(2+nflags, cmd_pkt, &res_len, res_pkt))
		    if (res_len == 1 && res_pkt[0] == IBMFLAGS)
			*status = FDCSUCCESS;
	    }
	}




	sflagPC(flagindx, mask, status)
	int *status;
	unsigned char flagindx, mask;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

		*status = LINERR;
		cmd_pkt[0] = SIBMFLAG;
		cmd_pkt[1] = flagindx;
		cmd_pkt[2] = mask;
		if (!host_rpc_action(3, cmd_pkt, &res_len, res_pkt))
		    if (res_len == 1 && res_pkt[0] == SIBMFLAG)
			*status = FDCSUCCESS;
	}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\gfi_test.c ===
#include "insignia.h"
#include "host_def.h"
#ifndef PROD
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Generic Floppy Interface Test Module
 *
 * Description	: This module acts as a pseudo GFI diskette server, simply
 *		  tracing out the calls made and returning success.  
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 * Mods: (r3.2) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 */

#ifdef SCCSID
static char SccsID[]="@(#)gfi_test.c	1.9 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_TEST_FLOPPY.seg"
#endif


/*
 *    O/S include files.
 */
#endif /* not PROD */
#include <stdio.h>
#include TypesH
#ifndef PROD

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "config.h"
#include "ios.h"
#include "trace.h"
#include "fla.h"
#include "gfi.h"
#include "gfitest.h"


/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

static void print_cmd();

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */


int gfi_test_command(command_block, result_block)
FDC_CMD_BLOCK *command_block;
FDC_RESULT_BLOCK *result_block;
{

    UNUSED(result_block);
	
    fprintf(trace_file, "GFI: Command received - ");
    switch(get_c0_cmd(command_block))
    {
    case FDC_READ_TRACK   	: fprintf(trace_file, "Read a track\n");
				  print_cmd(command_block);
				  break;

    case FDC_SPECIFY 		: fprintf(trace_file, "Specify\n");
				  print_cmd(command_block);
				  break;

    case FDC_SENSE_DRIVE_STATUS	: fprintf(trace_file, "Sense Drive Status\n");
				  print_cmd(command_block);
				  break;

    case FDC_WRITE_DATA	    	: fprintf(trace_file, "Write Data\n");
				  print_cmd(command_block);
				  break;

    case FDC_READ_DATA    	: fprintf(trace_file, "Read Data\n");
				  print_cmd(command_block);
				  break;

    case FDC_RECALIBRATE 	: fprintf(trace_file, "Recalibrate\n");
				  print_cmd(command_block);
				  break;

    case FDC_SENSE_INT_STATUS	: fprintf(trace_file, "<Illegal call> Sense Interrupt Status\n");
				  break;

    case FDC_WRITE_DELETED_DATA : fprintf(trace_file, "Write Deleted Data\n");
				  print_cmd(command_block);
				  break;

    case FDC_READ_ID    	: fprintf(trace_file, "Read ID\n");
				  print_cmd(command_block);
				  break;

    case FDC_READ_DELETED_DATA  : fprintf(trace_file, "Read Deleted Data\n");
				  print_cmd(command_block);
				  break;

    case FDC_FORMAT_TRACK    	: fprintf(trace_file, "Format a track\n");
				  print_cmd(command_block);
				  break;

    case FDC_SEEK    		: fprintf(trace_file, "Seek\n");
				  print_cmd(command_block);
				  break;

    case FDC_SCAN_EQUAL		: fprintf(trace_file, "Scan Equal\n");
				  print_cmd(command_block);
				  break;

    case FDC_SCAN_LOW_OR_EQUAL  : fprintf(trace_file, "Scan Low or Equal\n");
				  print_cmd(command_block);
				  break;

    case FDC_SCAN_HIGH_OR_EQUAL : fprintf(trace_file, "Scan High or Equal\n");
				  print_cmd(command_block);
				  break;

    default			: fprintf(trace_file, "Unknown command %x\n", get_c0_cmd(command_block));
				  break;
    }

    return(SUCCESS);
}


int gfi_test_drive_on(drive)
int drive;
{
    fprintf(trace_file, "GFI: Drive on command - drive %x\n", drive);

    return(SUCCESS);
}

int gfi_test_drive_off(drive)
int drive;
{
    fprintf(trace_file, "GFI: Drive off command - drive %x\n", drive);

    return(SUCCESS);
}

int gfi_test_high(drive)
int drive;
{
    fprintf(trace_file, "GFI: Set high density command - drive %x\n", drive);

    return(SUCCESS);
}

int gfi_test_drive_type(drive)
int drive;
{
    fprintf(trace_file, "GFI: Drive type command - drive %x\n", drive);

    return(GFI_DRIVE_TYPE_360);
}

int gfi_test_change(drive)
int drive;
{
    fprintf(trace_file, "GFI: Disk changed command - drive %x\n", drive);

    return(TRUE);
}

int gfi_test_reset(result_block)
FDC_RESULT_BLOCK *result_block;
{
    UNUSED(result_block);
	
	fprintf(trace_file, "GFI: Reset command\n");

    return(SUCCESS);
}


/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

static void print_cmd(cmd_block)
FDC_CMD_BLOCK *cmd_block;
{
    switch(gfi_fdc_description[get_type_cmd(cmd_block)].cmd_class)
    {
    case 0 : fprintf(trace_file, "MT: %x    MFM: %x    Skip: %x    Head: %x    Drive: %x\n",
		    get_c0_MT(cmd_block), get_c0_MFM(cmd_block), 
		    get_c0_skip(cmd_block), 
		    get_c0_head(cmd_block), get_c0_drive(cmd_block));
	     fprintf(trace_file, "Cyl: %x   Hd: %x     Sec: %x     N: %x       EOT: %x     GPL: %x    DTL: %x\n",
		    get_c0_cyl(cmd_block), get_c0_hd(cmd_block), 
		    get_c0_sector(cmd_block), get_c0_N(cmd_block),
		    get_c0_EOT(cmd_block), get_c0_GPL(cmd_block), 
		    get_c0_DTL(cmd_block));
	     break;

    case 1 : fprintf(trace_file, "MT: %x    MFM: %x    Head: %x    Drive: %x\n",
		    get_c1_MT(cmd_block), get_c1_MFM(cmd_block), 
		    get_c1_head(cmd_block), get_c1_drive(cmd_block));
	     fprintf(trace_file, "Cyl: %x   Hd: %x     Sec: %x     N: %x       EOT: %x     GPL: %x    DTL: %x\n",
		    get_c1_cyl(cmd_block), get_c1_hd(cmd_block),
		    get_c1_sector(cmd_block), get_c1_N(cmd_block), 
		    get_c1_EOT(cmd_block), get_c1_GPL(cmd_block),
		    get_c1_DTL(cmd_block));
	     break;

    case 2 : fprintf(trace_file, "MFM: %x   Head: %x    Drive: %x\n",
		    get_c2_MFM(cmd_block), get_c2_head(cmd_block),
		    get_c2_drive(cmd_block));
	     fprintf(trace_file, "Cyl: %x   Hd: %x     Sec: %x     N: %x       EOT: %x     GPL: %x    DTL: %x\n",
		    get_c2_cyl(cmd_block), get_c2_hd(cmd_block),
		    get_c2_sector(cmd_block), get_c2_N(cmd_block),
		    get_c2_EOT(cmd_block), get_c2_GPL(cmd_block),
		    get_c2_DTL(cmd_block));
	     break;

    case 3 : fprintf(trace_file, "MFM: %x   Head: %x    Drive: %x\n",
		    get_c3_MFM(cmd_block), get_c3_head(cmd_block),
		    get_c3_drive(cmd_block));
	     fprintf(trace_file, "N: %x     SC: %x      GPL: %x    Fill: %x\n",
		    get_c3_N(cmd_block), get_c3_SC(cmd_block),
		    get_c3_GPL(cmd_block), get_c3_filler(cmd_block));
	     break;

    case 4 : fprintf(trace_file, "MFM: %x   Head: %x    Drive: %x\n",
		    get_c4_MFM(cmd_block), get_c4_head(cmd_block),
		    get_c4_drive(cmd_block));
	     break;

    case 5 : fprintf(trace_file, "Drive: %x\n", get_c5_drive(cmd_block));
	     break;

    case 6 : fprintf(trace_file, "SRT: %x   HUT: %x     HLT: %x     ND: %x\n",
		    get_c6_SRT(cmd_block), get_c6_HUT(cmd_block),
		    get_c6_HLT(cmd_block), get_c6_ND(cmd_block));
	     break;

    case 7 : fprintf(trace_file, "Head: %x    Drive: %x\n",
		    get_c7_head(cmd_block), get_c7_drive(cmd_block));
	     break;

    case 8 : fprintf(trace_file, "Head: %x    Drive: %x    New cyl: %x\n",
		    get_c8_head(cmd_block), get_c8_drive(cmd_block),
		    get_c8_new_cyl(cmd_block));
	     break;

    }
}
#endif /* nPROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\disks\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=disks
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=floppy.c      \
    ..\floppy_i.c    \
    ..\diskbios.c    \
    ..\fdisk.c       \
    ..\fla.c \
    ..\gfi.c \
    ..\gfi_ibm.c     \
    ..\gfi_mpty.c    \
    ..\gfi_sflp.c    \
    ..\gfi_test.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\dos\emm_mngr.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA MODULE SPECIFICATION
			-----------------------------
SccsID		: @(#)emm_mngr.c	1.24 08/31/93 Copyright Insignia Solutions Ltd.
FILE NAME	: emm_mngr.c
MODULE NAME	: 'Middle layer' of Expanded Memory Manager

	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: April '88

PURPOSE		: Contains all the routines that communicate with
		the arrays and data structures that hold the
		necessary Expanded Memory Manager Data.


The Following Routines are defined:
		1. init_expanded_memory()
		2. free_expanded_memory()
		3. get_new_handle()
		4. free_handle()
		5. reallocate_handle()
		6. handle_ok()
		7. set_no_pages()
		8. set_EM_pageno()
		9. set_map()
		10. set_name()
		11. get_no_pages()
		12. get_EM_pageno()
		13. get_map()
		14. get_name()
		15. alloc_page()
		16. free_page()
		17. map_page()
		18. unmap_page()
		19. map_saved()
		20. save_map()
		21. restore_map()
		22. copy_exchange_data()
		23. page_status()
	The following routines just return variables to the top layer				
		24. get_total_pages()
		25. get_unallocated_pages()
		26. get_base_address()
		27. get_total_handles()
		28. get_total_open_handles()
		29. get_no_phys_pages()
		30. get_page_seg()
		31. get_map_size()

=========================================================================

AMMENDMENTS	:

=========================================================================
*/


#ifdef LIM

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_LIM.seg"
#endif



#include <stdio.h>
#include <string.h>
#include <malloc.h>

#include TypesH

#include "xt.h"
#include CpuH
#include "sas.h"
#include "host_emm.h"
#include "emm.h"
#include "gmi.h"
#include "debug.h"
#ifndef PROD
#include "trace.h"
#endif
#include "timer.h"

#ifdef NTVDM
#include "error.h"
#endif	/* NTVDM */

typedef enum
{
	BYTE_OP,
	WORD_OP,
	STR_OP
} MM_LIM_op_type;

#ifdef NTVDM
/*	Local Variables			*/
static long
	handle[MAX_NO_HANDLES],		/* Array containing unique ID's	*/
					/* for each handle, these are	*/
					/* usually pointers, but this 	*/
					/* is host dependant		*/
	backfill;			/* backfill memory size 	*/
static unsigned short
	total_pages = 0,		/* no. of EM pages available	*/
	unallocated_pages = 0,		/* no. of unallocated EM pages	*/
	total_handles,			/* no of handles available	*/
	total_open_handles,		/* no. of allocated handles	*/
	*EM_page_mapped_array = NULL,	/* EMM page mapped array	*/
	*EM_page_mapped = NULL,		/* Expanded Memory pages	*/
					/* currently mapped in		*/
	page_offset,			/* offset in handle data at 	*/
					/* which page numbers start	*/
	map_size,			/* no of bytes rq'd to store map*/
	no_phys_pages = 0,		/* no. of phys. pages available	*/
	no_altreg_sets = 0;		/* no of alternative reg sets	*/
static unsigned short
	physical_page[MAX_NO_PAGES];	/* array containing segment	*/
					/* addresses of physical pages	*/

static unsigned short
	EM_start, EM_end;
static IU8
	* altreg_alloc_mask;		/* altref allocate mask */
static unsigned short
	next_free_altreg_set,		/* next free altreg set #, 0 based */
	free_altreg_sets,		/* number of free altreg */
	active_altreg_set = 0;		/* current active alt reg set	*/
static char
	name[NAME_LENGTH];		/* for storing handle name	*/

#define GET_EM_PAGE_MAPPED_PTR(set)	(EM_page_mapped_array + \
					(set * no_phys_pages))

/* get emm parameters, initialize housekeeping structures and
 *  reserve page frames.
 */

boolean lim_page_frame_init(PLIM_CONFIG_DATA lim_config_data)
{
    int 	i;
    unsigned short altreg_alloc_mask_size;  /* altreg allocation mask array size */

    no_phys_pages = get_lim_page_frames(physical_page, lim_config_data);

    /* The first 4 pages must be continuous and locate above 640KB
     * (the EMM primary page frame(physical pages 0, 1, 2 and 3)).
     * It is then followed by other pages located above 640KB and then
     * pages below 640KB(back fill)
     */
    if (!no_phys_pages)
	return FALSE;

    no_altreg_sets = lim_config_data->total_altreg_sets;
    backfill = lim_config_data->backfill;


    /* each mapping register set has no_phys_pages pages */
    EM_page_mapped_array = (unsigned short *)host_malloc(no_phys_pages * no_altreg_sets *
				   sizeof(short));
    if (EM_page_mapped_array == NULL) {
	host_error(EG_MALLOC_FAILURE, ERR_CONT, "");
	return FALSE;
    }
    /* one bit for each altreg set */
    altreg_alloc_mask_size = (no_altreg_sets + 7) / 8;
    altreg_alloc_mask = (unsigned char *)host_malloc(altreg_alloc_mask_size);
    if (altreg_alloc_mask == NULL) {
	host_free(EM_page_mapped_array);
	host_error(EG_MALLOC_FAILURE, ERR_CONT, "");
	return FALSE;
    }

    /* all altreg sets are free at this moment */
    for (i = 0; i < altreg_alloc_mask_size; i++)
	altreg_alloc_mask[i] = 0;

    next_free_altreg_set = 0;
    free_altreg_sets = no_altreg_sets;
    return TRUE;
}
#else


/*	Local Variables			*/
static long
#ifdef	macintosh
	*handle;
#else
	handle[MAX_NO_HANDLES];		/* Array containing unique ID's	*/
					/* for each handle, these are	*/
					/* usually pointers, but this 	*/
					/* is host dependant		*/
#endif /* !macintosh */

static short
	total_pages = 0,		/* no. of EM pages available	*/
	unallocated_pages = 0,		/* no. of unallocated EM pages	*/
	total_handles,			/* no of handles available	*/
	total_open_handles,		/* no. of allocated handles	*/
	EM_page_mapped[MAX_NO_PAGES],	/* Expanded Memory pages	*/
					/* currently mapped in		*/
	page_offset,			/* offset in handle data at 	*/
					/* which page numbers start	*/
	map_size,			/* no of bytes rq'd to store map*/
	no_phys_pages;			/* no. of phys. pages available	*/

static unsigned int
	EM_start,			/* start segment for EM mapping	*/
	EM_end;			/* 1st segment past end of EM	*/

static unsigned short
	physical_page[MAX_NO_PAGES];	/* array containing segment	*/
					/* addresses of physical pages	*/

static char
	name[NAME_LENGTH];		/* for storing handle name	*/

#endif

/*
===========================================================================

FUNCTION	: init_expanded_memory

PURPOSE		: This routine calls the routine to allocate the expanded
		memory pages and then sets up the arrays and variables that
		are used by the Expanded Memory Manager(EMM).

RETURNED STATUS	: SUCCESS - manager initialised succesfully
		  FAILURE - Failure to allocate space for Expanded Memory
		  	    pages.

DESCRIPTION	:

=========================================================================
*/
GLOBAL int init_expanded_memory IFN2(int, size, 	/* size of area in megabytes */
				     int, mem_limit	/* limit of conventional memory
							 * 256, 512 or 640KB */ )

{	
	short
		pages_above_640,	/* no of mappable locations	*/
		pages_below_640,	/*  available either side of 640*/
		EM_page_no,		/* page no. within exp. memory	*/
		physical_page_no;	/* page no. within map region	*/
	unsigned short
		base;			/* start segment of mappable 	*/
					/* memory below 640 KB		*/

	int	i, j;			/* loop counters		*/


	if (!no_phys_pages)
	    return FAILURE;

	/* get space for expanded memory pages	*/

	if(host_initialise_EM((short)size) != SUCCESS)
	{
#ifdef NTVDM
	    host_error(EG_EXPANDED_MEM_FAILURE, ERR_QU_CO, NULL);
#endif	/* NTVDM */
	    return(FAILURE);
	}

#ifdef	macintosh
	if (!handle)
	{
		handle = (long *)host_malloc(MAX_NO_HANDLES*sizeof(long));
	}
#endif	/* macintosh */

	/* Initialise EMM variables	*/

#ifndef NTVDM
	EM_start = 0xd000;
	EM_end   = 0xe000;
#else
	EM_start = physical_page[0];
	EM_end =  physical_page[0] + EMM_PAGE_SIZE * 4;
#endif
	total_pages = unallocated_pages = size * 0x100000 / EMM_PAGE_SIZE;

	/* always allow max handles (Used to be 32 handles/Meg expanded mem) */
	total_handles = MAX_NO_HANDLES;
	total_open_handles = 0;
	for(i = 0; i < total_handles; i++)
		handle[i] = (long) NULL;

#ifdef NTVDM
	map_size = no_phys_pages * NSIZE;
	page_offset = MAP_OFFSET + map_size;	
	pages_below_640 = (SHORT)(backfill / EMM_PAGE_SIZE);
	pages_above_640 = no_phys_pages - pages_below_640;

	/* initialize active mapping register to set 0 */
	EM_page_mapped = EM_page_mapped_array;
	allocate_altreg_set(&active_altreg_set);

	for (i = 0; i < no_phys_pages; i++)
	    EM_page_mapped[i] = (unsigned short)EMPTY;

	if (get_new_handle(0) != 0)
	    return FAILURE;
	set_no_pages(0, 0);
#else

	pages_above_640 = (effective_addr(EM_end,0) - effective_addr(EM_start,0)) / EMM_PAGE_SIZE;
	pages_below_640 = ((640 - mem_limit) * 1024) / EMM_PAGE_SIZE;
	no_phys_pages = pages_above_640 + pages_below_640;

	map_size = no_phys_pages * NSIZE;
	page_offset = MAP_OFFSET + map_size;	

	/*
	 * set up addresses and mapping status of physical pages
	 */
	for( i = 0; i < pages_above_640; i++ )
	{
		physical_page[i] = EM_start + (i * EMM_PAGE_SIZE >> 4);
		EM_page_mapped[i] = EMPTY;
	}
	base = mem_limit * 64;

	for(i = pages_above_640, j = 0; i < no_phys_pages; i++)
	{
		physical_page[i] = base + (j++ * EMM_PAGE_SIZE >> 4);
		EM_page_mapped[i] = EMPTY;
	}
	/*
	 * Allocate handle 0 with any pages required for back filling
	 */
	if(get_new_handle(pages_below_640) != 0)
		return(FAILURE);

	for(i = 0, physical_page_no = pages_above_640; i < pages_below_640; i++)
	{
		if((EM_page_no = alloc_page()) == FAILURE)
			return (FAILURE);

		set_EMpage_no(0, i, EM_page_no);

		if(map_page(EM_page_no, physical_page_no++) == FAILURE)
			return(FAILURE);
	}
	set_no_pages(0, pages_below_640);
#endif	/* NTVDM */

	/*
	 *	Set up necessary variables in Top level EMM function code
	 */
	reset_emm_funcs();

	/*
	** Map the address space taken up by LIM to RAM.
	** Without LIM it would be ROM.
	** The range seems to be fixed at segment D000 to F000.
	** Assumed that AT's have GMI and XT's do not.
	** XT's can use the old fashioned memset calls in
	** delta:manager:init_struc.c
	*/
#ifdef NTVDM
	/* every physical page must be connected as RAM */
	for (i = 0; i < pages_above_640; i++)
	    sas_connect_memory(effective_addr(physical_page[i], 0),
			       effective_addr(physical_page[i], EMM_PAGE_SIZE - 1),
			       SAS_RAM
			       );
#else

	sas_connect_memory(effective_addr(EM_start,0) , effective_addr(EM_end,0) -1 , SAS_RAM );
#endif

	sure_note_trace3(LIM_VERBOSE,"initialised EMM, total pages= %#x, pages above 640= %#x, pages below 640 = %#x",no_phys_pages, pages_above_640, pages_below_640);

	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: free_expanded_memory

PURPOSE		: This routine calls frees all memory allocated for the
		expanded memory manager and resets the variables that
		are used by the Expanded Memory Manager(EMM).

RETURNED STATUS	: SUCCESS -

DESCRIPTION	: If total_pages = 0, this indicates that expanded
		memory hasn't been initialised, so the routine simply
		does nothing and returns.

=========================================================================
*/
GLOBAL void free_expanded_memory IFN0()

{	
	short 	handle_no;

	if(total_pages == 0)
		return;

	/* free space allocated for each handle	*/

	handle_no = 0;
	while(total_open_handles > 0)
	{
		while(!handle_ok(handle_no))
			handle_no++;

		free_handle(handle_no++);
	}
	/*
	 *	Free space for expanded memory pages
	 */
	host_deinitialise_EM();

	total_pages = 0;

	return;
}

/*
===========================================================================

FUNCTION	: get_new_handle()

PURPOSE		: Finds the next free handle no., allocates storage space
		for recording the EMM data associated with this handle,
		and stores the 'storage ID' in the handle array.

RETURNED STATUS	: SUCCESS - new handle allocated successfully
		 FAILURE - Error occurred in trying to allocate storage
		           space for handle data

DESCRIPTION	: see emm.h for a description of space required for
		 storing handle data e.g. PAGE_OFFSET & NSIZE


=========================================================================
*/
GLOBAL short get_new_handle IFN1(short, no_pages)	/* No.of pages to store in handle */

{
	unsigned short	i;			/* loop count */
	short	handle_no;
	int	data_size;		/* no. of bytes of data storage */
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/

	sure_note_trace2(LIM_VERBOSE,"new handle request, current total handles= %d, pages requested = %d",total_handles, no_pages);

	handle_no = 0;

	do
		if (handle[handle_no] == (long) NULL)
			break;
	while(++handle_no < total_handles);

	if(handle_no >= total_handles)
		return(FAILURE);

	data_size = page_offset + (no_pages * NSIZE);

	if ((storage_ID = host_allocate_storage(data_size)) == (long) NULL)
		return(FAILURE);

	handle[handle_no] = storage_ID;

	for (i=0 ; i < no_phys_pages ; i++) {
		set_map_no(handle_no, (unsigned char)i, FREE);
	}

	total_open_handles++;

	sure_note_trace1(LIM_VERBOSE,"allocation OK, return handle=%d",handle_no);

	return(handle_no);
}

/*
===========================================================================

FUNCTION	: free_handle

PURPOSE		: frees the storage space allocated to the handle number.
		  Decrements the handles open count

RETURNED STATUS	: SUCCESS - space freed
		  FAILURE - unable to free space

DESCRIPTION	:

=========================================================================
*/
GLOBAL int free_handle IFN1(short, handle_no)	/* No.of handle to be freed */

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/

	sure_note_trace2(LIM_VERBOSE, "free handle %d request, total handles = %d",handle_no, total_handles);

	storage_ID = handle[handle_no];

	if(host_free_storage(storage_ID) != SUCCESS)
		return(FAILURE);	

	handle[handle_no] = (long) NULL;

	total_open_handles--;

	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: reallocate_handle

PURPOSE		: changes the number of pages allocated to a given handle

RETURNED STATUS	: SUCCESS - handle reallocated
		  FAILURE - unable to get space for new handle data

DESCRIPTION	:

=========================================================================
*/
GLOBAL int reallocate_handle IFN3(short, handle_no, 	/* handle to be reallocated */
				  short, old_page_count,/* current pages in handle  */
				  short, new_page_count)/* required pages for handle*/

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/

	short	size,			/* size of handle data area	*/
		new_size;		/* size of new handle data area	*/


	size = page_offset + (old_page_count * NSIZE);
	new_size = page_offset + (new_page_count * NSIZE);
	storage_ID = handle[handle_no];

	sure_note_trace3(LIM_VERBOSE,"reallocate pages for handle %d, old size=%#x, new size= %#x",handle_no, size, new_size);

	if((storage_ID = host_reallocate_storage(storage_ID, size, new_size)) ==
		(long) NULL)
		return(FAILURE);	

	handle[handle_no] = storage_ID;

	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: handle_ok

PURPOSE		: checks to see if the handle no. is valid - this should
		be called before every routine that uses a handle number
		to retrieve or set data in the handle data area

RETURNED STATUS	: TRUE	- Handle no. is valid
		FALSE	- Handle no. is invalid

DESCRIPTION	:

=========================================================================
*/
GLOBAL boolean handle_ok IFN1(short, handle_no)

{
#ifdef NTVDM
/* some *** applicaitons feed us a negtive handle number. Catch it and
   throw it to the hell*/

    if ((unsigned short)handle_no >= (unsigned short)total_handles) {
#else
	if(handle_no >= total_handles   ||   handle_no < 0) {
#endif

		sure_note_trace1(LIM_VERBOSE,"invalid handle %d",handle_no);
		return(FALSE);
	}

	if(handle[handle_no] == (long) NULL){
		sure_note_trace1(LIM_VERBOSE,"invalid handle %d",handle_no);
		return(FALSE);
	}

	return(TRUE);
}

/*
===========================================================================

FUNCTION	: set_no_pages

PURPOSE		: sets the no of pages variable in the specified handle

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL void set_no_pages IFN2(short, handle_no, short, no_pages)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	byte	*ptr;			/* pointer to storage area	*/

	storage_ID = handle[handle_no];		
	ptr = USEBLOCK(storage_ID);

	*(short *)ptr = no_pages;

	FORGETBLOCK(storage_ID)

	return;
}

/*
===========================================================================

FUNCTION	: set_EMpage_no

PURPOSE		: sets Expanded Memory page that is used for the specified
		logical page into the handle data storage area

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL void set_EMpage_no IFN3(short, handle_no,
			       short, logical_page_no,
			       short, EM_page_no)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	byte	*ptr;			/* pointer to storage area	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += (page_offset +(logical_page_no * NSIZE));
	*(short *)ptr = EM_page_no;

	FORGETBLOCK(storage_ID)

	return;
}

/*
===========================================================================

FUNCTION	: set_map_no

PURPOSE		: sets Expanded Memory page number in the map section of
		the handle data storage area

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL void set_map_no IFN3(short, handle_no,
			    unsigned char, physical_page_no,
			    short, EM_page_no)

{
	long		storage_ID;	/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += (MAP_OFFSET +(physical_page_no * NSIZE));
	*(short *)ptr = EM_page_no;

	FORGETBLOCK(storage_ID)

	return;
}

/*
===========================================================================

FUNCTION	: set_name

PURPOSE		: writes a name into the name section of the handle data
		 storage area

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL void set_name IFN2(short, handle_no,
		          char *, new_name)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/


	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += NAME_OFFSET;
	strncpy((char *)ptr, new_name, NAME_LENGTH);
        ptr[NAME_LENGTH-1] = '\0';
	FORGETBLOCK(storage_ID)

	return;
}

/*
===========================================================================

FUNCTION	: get_no_pages

PURPOSE		: gets the number of pages assigned to the specified handle

RETURNED STATUS	: no of pages returned

DESCRIPTION	:

=========================================================================
*/
GLOBAL short get_no_pages IFN1(short, handle_no)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	byte	*ptr;			/* pointer to storage area	*/
	short 	no_pages;		/* no. of pages in handle	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);

	no_pages = *(short *)ptr;

	FORGETBLOCK(storage_ID)

	return(no_pages);
}

/*
===========================================================================

FUNCTION	: get_EMpage_no

PURPOSE		: returns the Expanded Memory page no. used for the
		 specified logical page in the given handle

RETURNED STATUS	: Expanded Memory page no. returned

DESCRIPTION	:

=========================================================================
*/
GLOBAL short get_EMpage_no IFN2(short, handle_no,
				short, logical_page_no)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	byte	*ptr;			/* pointer to storage area	*/
	short	EM_page_no;		/* Expanded Memory page number	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += (page_offset +(logical_page_no * NSIZE));
	EM_page_no = *(short *)ptr;

	FORGETBLOCK(storage_ID)

	return(EM_page_no);
}

/*
===========================================================================

FUNCTION	: get_map_no

PURPOSE		: returns the Expanded Memory page no. saved in the map
		attached to the given handle

RETURNED STATUS	: page no. in map returned

DESCRIPTION	:

=========================================================================
*/
GLOBAL short get_map_no IFN2(short, handle_no,
			     unsigned char, physical_page_no)

{
	long		storage_ID;	/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/
	short		EM_page_no;	/* Expanded Memory page number	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += (MAP_OFFSET +(physical_page_no * NSIZE));
	EM_page_no = *(short *)ptr;

	FORGETBLOCK(storage_ID)

	return(EM_page_no);
}

/*
===========================================================================

FUNCTION	: get_name

PURPOSE		: returns a pointer to the name assigned to the given handle

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL char *get_name IFN1(short, handle_no)

{
	long		storage_ID;	/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += NAME_OFFSET;
	strncpy(name, (char *)ptr, NAME_LENGTH);
        name[NAME_LENGTH - 1] = 0;       
 
	FORGETBLOCK(storage_ID)

	return(name);
}

/*
===========================================================================

FUNCTION	: alloc_page

PURPOSE		: allocates a page from expanded memory

RETURNED 	: >=0 = SUCCESS -  EM page no. returned
		  <0  = FAILURE - error occured in trying to allocate page

DESCRIPTION	:

=========================================================================
*/
GLOBAL short alloc_page IFN0()

{
	short	EM_page_no;		/* EM_page_no to be returned	*/


	if ((EM_page_no = host_alloc_page()) == FAILURE)
		return(FAILURE);

	unallocated_pages--;

	return(EM_page_no);
}

/*
===========================================================================

FUNCTION	: free_page

PURPOSE		: frees a page of expanded memory for further use

RETURNED 	: SUCCESS - page freed successfully
		  FAILURE - unable to free page

DESCRIPTION	:

=========================================================================
*/
GLOBAL int free_page IFN1(short, EM_page_no)

{

	short	physical_page_no;

	if (EM_page_no > total_pages)
		return(FAILURE);

	/* Removed from mapped pages table */

	for (physical_page_no=0; physical_page_no < no_phys_pages; physical_page_no++) {

		if (EM_page_mapped[physical_page_no] == EM_page_no) {
			EM_page_mapped[physical_page_no] = UNMAPPED;
			break;
		}

	}
				
	if (host_free_page(EM_page_no) != SUCCESS)
		return(FAILURE);

	unallocated_pages++;

	return(SUCCESS);
}

#ifndef NTVDM
/*
========================================================================

FUNCTION	: page_already_mapped

PURPOSE		: function to determine whether a EMM page is already
		  mapped to a different physical page within intel
		  memory
				
RETURNED 	: count of number of pages in addition to the page
		  passed which are mapped to the same logical page.
		  The page number of one of these mirror pages is
		  also returned via the pointer passed as an argument.

DESCRIPTION	:
			
========================================================================
*/

GLOBAL ULONG
page_already_mapped IFN2(short, EM_page_no,
			unsigned char *, physical_page_no)

{
	unsigned char	page, orig_page;
	ULONG	map_count;

	map_count = 0;
	orig_page = *physical_page_no;

	for( page = 0; page < (unsigned char) no_phys_pages; page++ )
	{
		if ((EM_page_mapped[page] == EM_page_no) &&
						(page != orig_page ))
		{
			sure_note_trace2( LIM_VERBOSE,
				"log page %x mapped to phys page %x",
						EM_page_no, page);

			*physical_page_no = page;
			map_count++;
		}
	}

	return( map_count );
}


LOCAL VOID
connect_MM_LIM_page IFN2( USHORT, segment, SHORT, EM_page_no )
{
	ULONG eff_addr;

#ifdef PROD
	UNUSED(EM_page_no);
#endif
	
	assert2( NO, "Connecting multi-mapped page, %d, at %x",
								EM_page_no, segment );

	eff_addr = effective_addr( segment, 0 );
	sas_connect_memory( eff_addr, eff_addr + EMM_PAGE_SIZE - 1,
									SAS_MM_LIM );
}

LOCAL VOID
disconnect_MM_LIM_page IFN4( USHORT, segment, SHORT, EM_page_no,
		ULONG, map_count, unsigned char, physical_page_no )
{
	ULONG eff_addr;

#ifdef PROD
	UNUSED(EM_page_no);
#endif
	
	sure_note_trace2(LIM_VERBOSE,
		"Unmapping multi-mapped page, %d, at %x",
						EM_page_no, segment );

	eff_addr = effective_addr( segment, 0 );
	sas_connect_memory( eff_addr, eff_addr + EMM_PAGE_SIZE - 1, SAS_RAM );

	if( map_count == 1 )
	{
		/*
		 * We have to disconnect the last page of this group,
		 * by connecting it as SAS_RAM.
		 */

		segment = physical_page[physical_page_no];
		eff_addr = effective_addr( segment, 0 );

		sure_note_trace2(LIM_VERBOSE,
			"Unmapping last multi-mapped page, %d, at %x",
								EM_page_no, segment );

		sas_connect_memory( eff_addr, eff_addr + EMM_PAGE_SIZE - 1,
										SAS_RAM );
	}
}

#endif	/* !NTVDM */

/*
========================================================================

FUNCTION	: map_page

PURPOSE		: maps a page from expanded memory into Intel physical
		address space

RETURNED 	: SUCCESS - page mapped successfully
		  FAILURE - unable to map page

DESCRIPTION	:

========================================================================
*/
GLOBAL int map_page IFN2(short, EM_page_no,
			 unsigned char, physical_page_no)

{
	USHORT	segment;	/* segment address of page in	*/
				/* physical address space	*/
	unsigned char	phys_page;
	ULONG		map_count;
			
	segment = physical_page[physical_page_no];

	/*
	 *	make sure that a page is not already mapped in
	 * 	if it is - return it to Expanded Memory
	 */
	sure_note_trace2(LIM_VERBOSE,
		"map page %#x to phys page %#x",
			EM_page_no,physical_page_no);

	if(EM_page_mapped[physical_page_no] != EMPTY)
	{
		sure_note_trace1(LIM_VERBOSE,
				"phys page already mapped to page %#x",
						EM_page_mapped[physical_page_no]);

		if(EM_page_mapped[physical_page_no] == EM_page_no)
		{
			sure_note_trace0(LIM_VERBOSE,
					"remap of same page, so do nothing");

			return(SUCCESS);
		}

#ifndef NTVDM
		/*
		 * We want to return the current contents of this physical
		 * page to the logical page ( to sync up the logical page ).
		 * We have to check first that this physical page is not a
		 * mirror of some other page - if it is we have to disconnect
		 * it from the group of pages it is mirroring.
		 */

		phys_page = physical_page_no;

		if( map_count = page_already_mapped(
				EM_page_mapped[physical_page_no], &phys_page))
		{
			disconnect_MM_LIM_page( segment, EM_page_no,
								map_count, phys_page );
		}

		/*
		 * We can now unmap the physical page and indicate
		 * that it is really unmapped.
		 */
		if(host_unmap_page(segment,
				EM_page_mapped[physical_page_no]) != SUCCESS)
		{
			return(FAILURE);
		}
		EM_page_mapped [physical_page_no] = EMPTY;
#endif

	}
#ifndef NTVDM

	/*
	 * If this logical page is already mapped, make sure the
	 * new mapping has an up to date copy
	 */
	
	phys_page = physical_page_no;

	if (page_already_mapped(EM_page_no, &phys_page))
	{
		/*
		 * We now want to get the LIM logical page up to date with
		 * the physical pages that are currently mapped to it. We
		 * don't want to set EM_page_mapped [phys_page] to EMPTY
		 * after the host_unmap_page().  If we did we wouldn't notice
		 * that we had a multiply-mapped page and the patch up code
		 * wouldn't get called.
		 */

		host_update_logical_page( physical_page[phys_page],
									EM_page_no );

		/*
		 * Connect new page and "mirror" page as MM_LIM.  This may
		 * mean some pages get connected as MM_LIM multiple times
		 * - inefficient but not wrong otherwise.  This connection
		 * has to be made for all hosts - even those that can do
		 * mapping themselves.  This is to make sure that the CPU
		 * data structures associated with all pages get updated
		 * when a multi-mapped write occurs.
		 */

		connect_MM_LIM_page( segment, EM_page_no );

		connect_MM_LIM_page( physical_page[phys_page], EM_page_no );
	}
#endif
	if(host_map_page(EM_page_no, segment) != SUCCESS)
		return(FAILURE);

	EM_page_mapped[physical_page_no] = EM_page_no;

	sure_note_trace0(LIM_VERBOSE,"map OK");
	return(SUCCESS);
}

/*
========================================================================

FUNCTION	: unmap_page

PURPOSE		: unmaps a page from Intel physical address space back to
		expanded memory

RETURNED 	: SUCCESS - page unmapped successfully
		  FAILURE - error in unmapping page

DESCRIPTION	:

========================================================================
*/
GLOBAL int unmap_page IFN1(unsigned char, physical_page_no)

{
	short		EM_page_no;	/* EM_page_no currently mapped	*/
	unsigned short	segment;	/* segment address of page in	*/
					/* physical address space	*/
	SHORT		phys_page;
	ULONG		map_count;

	sure_note_trace1( LIM_VERBOSE,
				"unmap phys page %#x",physical_page_no);

	segment = physical_page[physical_page_no];

	if((EM_page_no = EM_page_mapped[physical_page_no]) == EMPTY)
	{
		/*
		 * Already done
		 */
		sure_note_trace0( LIM_VERBOSE,
					"already unmapped, so do nothing");

		return(SUCCESS);
	}

	phys_page = physical_page_no;

#ifndef NTVDM
	if( map_count = page_already_mapped( EM_page_no, (unsigned char *)&phys_page ))
	{
		disconnect_MM_LIM_page( segment, EM_page_no,
								map_count, phys_page );
	}
#endif

	if(host_unmap_page(segment, EM_page_no) != SUCCESS)
		return(FAILURE);

	EM_page_mapped[physical_page_no] = EMPTY;

	sure_note_trace0(LIM_VERBOSE,"unmap OK");
	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: map_saved

PURPOSE		: Checks to see if a map has been saved for the specified
		handle

RETURNED STATUS	: TRUE  -  A map is saved for this handle
		FALSE	-  No map has been saved

DESCRIPTION	: checks the first entry in the map for the value 'FREE'

=========================================================================
*/
GLOBAL boolean map_saved IFN1(short, handle_no)

{
	long		storage_ID;	/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/
	short		status;		/* value read from map		*/

	storage_ID = handle[handle_no];
	ptr = USEBLOCK(storage_ID);

	/*
	 * offset pointer to correct position
	 */

	ptr += MAP_OFFSET;
	status = *(short *)ptr;

	FORGETBLOCK(storage_ID)

	return((status == FREE) ? FALSE : TRUE);
}


/*
===========================================================================

FUNCTION	: save_map

PURPOSE		: takes a copy of the EM_page_mapped array and store it in
		the map section of the handle data storage area

RETURNED STATUS	: SUCCESS - everything OK
		  FAILURE - invalid segment no. passed in src array

DESCRIPTION	: if handle_no is >= 0 the map is stored in the data area
			assigned to that handle
		  if handle_no == -1 the map is stored in the array pointed
		  	to by dst_segment:dst_offset
		  if handle_no == -2 only the pages specified by the segment
		  	addresses in the src array (pointed to by
		  	src_segment:src_offset) are saved in the dst array
		  	(pointed to by dst_segment:dst_offset).

=========================================================================
*/
GLOBAL int save_map IFN5(short, handle_no,
			 unsigned short, dst_segment,
			 unsigned short, dst_offset,
			 unsigned short, src_segment,
			 unsigned short, src_offset)

{
	unsigned short	offset,		/* temp offset variable		*/
			segment,	/* segment address to be saved	*/
            i,		/* loop counter			*/
			page_no,	/* physical page no.		*/
			no_to_save;	/* no of pages in src array	*/

	if(handle_no >= 0)
		for (i = 0; i < no_phys_pages; i++)
			set_map_no(handle_no, (unsigned char) i, EM_page_mapped[i]);

	else if(handle_no == -1)
		for(i = 0; i < no_phys_pages; i++)
		{
			write_intel_word(dst_segment, dst_offset, EM_page_mapped[i]);
			dst_offset +=2;
		}

	else if(handle_no == -2)
	{
		offset = dst_offset;
		for(i  = 0; i < no_phys_pages; i++)
		{
#ifdef NTVDM
			write_intel_word(dst_segment, offset, LEAVE);
#else
			write_intel_word(dst_segment, offset, EMPTY);
#endif
			offset += 2;
		}
		read_intel_word(src_segment, src_offset, (word *)&no_to_save);
		for (i = 0; i < no_to_save; i++)
		{
			src_offset += 2;
			read_intel_word(src_segment, src_offset, &segment);
			/*
			 *	Find Physical page no.
			 */
			page_no = 0;
			do
				if(segment == physical_page[page_no])
					break;
			while(++page_no < no_phys_pages);

			if(page_no >= no_phys_pages)
				return (FAILURE);
			/*
			 *	Save EM page number in destination array	
			 */
			offset = dst_offset + (page_no * 2);
			write_intel_word(dst_segment, offset, EM_page_mapped[page_no]);
		}
	}
	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: restore_map

PURPOSE		: reads the specified map and returns 2 arrays specifying
		which pages have to be mapped out and which ones have to be
		mapped in

RETURNED STATUS	: SUCCESS - Map read successfully


DESCRIPTION	: A +ve handle number indicates that the map is stored
		within the handle data area.
		If the handle number is -ve the map will be read from the
		data pointed to by segment:offset

		Only page out - if there is a page currently mapped in and
		it is not being replaced by a copy of itself or an empty
		page
		Only page in - if new page is different to existing one
		and it is not empty

=========================================================================
*/
#ifdef ANSI
GLOBAL int restore_map (short handle_no,
			unsigned short segment,
			unsigned short offset,
			short pages_out[],
			short pages_in[])
#else
GLOBAL int restore_map (handle_no, segment, offset, pages_out, pages_in)
short handle_no;
unsigned short segment;
unsigned short offset;
short pages_out[];
short pages_in[];
#endif	/* ANSI */
{
	short	i,		/* loop counter				*/
		new_page,	/* page number read from map		*/
		old_page;	/* existing page number			*/

	for(i = 0; i < no_phys_pages; i++)
	{
		if(handle_no >= 0)
			new_page = get_map_no(handle_no, (unsigned char)i);
		else
		{
			read_intel_word(segment, offset, (word *)&new_page);
			offset += 2;
#ifdef NTVDM
			if(new_page < LEAVE || new_page >= total_pages)
#else
			if(new_page < EMPTY || new_page >= total_pages)
#endif /* NTVDM */
				return(FAILURE);
		}
		old_page = EM_page_mapped[i];

/*
		if(old_page != EMPTY && new_page != EMPTY && old_page != new_page )
*/
/* need to do unmap to empty state case to update the page copy in the LIM
   space in case of new maps of that page to other LIM slots. */
#ifdef NTVDM
		if(old_page != EMPTY && old_page != new_page && new_page != LEAVE)
#else
		if(old_page != EMPTY && old_page != new_page )
#endif
			pages_out[i] = old_page;
		else
			pages_out[i] = EMPTY;

#ifdef NTVDM
		if(new_page != EMPTY && new_page != old_page && new_page != LEAVE)
#else
		if(new_page != EMPTY && new_page != old_page)
#endif
			pages_in[i] = new_page;
		else
			pages_in[i] = EMPTY;
	}
	if(handle_no >= 0)
		set_map_no(handle_no, 0, FREE);

	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: copy_exchange_data

PURPOSE		: copies or exchanges data between conventional and
		expanded memory

RETURNED STATUS	: SUCCESS - everything ok
		FAILURE - Error ocurred in copying data

DESCRIPTION	: type - uses a bit pattern, bit 0 represents destination,
		bit 1 represents source, a set bit means expanded, a clear
		bit means conventional memory
		bit 2 represents exchange if set or move if it is clear

		e.g. 	0 (0000) = move conventional to conventional
		 	1 (0001) = move conventional to expanded
		 	6 (0110) = exchange expanded to conventional
		 	7 (0111) = exchange expanded to expanded

=========================================================================
*/
GLOBAL int copy_exchange_data IFN8(unsigned char, type,
				   short, src_handle,
				   unsigned short, src_seg_page,
				   unsigned short, src_offset,
				   short, dst_handle,
				   unsigned short, dst_seg_page,
				   unsigned short, dst_offset,
				   unsigned long, length)

{
	short		dst_EMpage,	/* EM page no . of destination	*/
			src_EMpage;	/* EM page no. of source	*/
	int		page_no;	/* phys. page no. of mapped page*/

	/*
	 * First check to see if the expanded memory page is mapped
	 * if it is - change the type to deal directly with the
	 * physical page that it is mapped to
	 */
	if( type & 1)
	{
		dst_EMpage = get_EMpage_no(dst_handle, dst_seg_page);
		if((page_no = page_status(dst_EMpage)) != UNMAPPED )
		{
			dst_seg_page = physical_page[page_no];
			type &= 6;
		}
	}
	if( type & 2)
	{
		src_EMpage = get_EMpage_no(src_handle, src_seg_page);
		if((page_no = page_status(src_EMpage)) != UNMAPPED )
		{
			src_seg_page = physical_page[page_no];
			type &= 5;
		}
	}

	switch(type)
	{
		case 0:	if(host_copy_con_to_con(length, src_seg_page, src_offset,
			   dst_seg_page, dst_offset) != SUCCESS)
				return(FAILURE);
			break;

		case 1:	if(host_copy_con_to_EM(length, src_seg_page, src_offset,
			   dst_EMpage, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 2:	if(host_copy_EM_to_con(length, src_EMpage, src_offset,
			   dst_seg_page, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 3:	if(host_copy_EM_to_EM(length, src_EMpage, src_offset,
			   dst_EMpage, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 4:	if(host_exchg_con_to_con(length, src_seg_page, src_offset,
			   dst_seg_page, dst_offset) != SUCCESS)
				return(FAILURE);
			break;

		case 5:	if(host_exchg_con_to_EM(length, src_seg_page, src_offset,
			   dst_EMpage, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 6:	if(host_exchg_con_to_EM(length, dst_seg_page, dst_offset,
			   src_EMpage, src_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 7:	if(host_exchg_EM_to_EM(length, src_EMpage, src_offset,
			   dst_EMpage, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		default: return(FAILURE);
	}
	return(SUCCESS);
}

/*
========================================================================

FUNCTION	: page_status

PURPOSE		: checks if a particular EM page is mapped or not

RETURNED STATUS	: page_no - physical page no returned if mapped
		  UNMAPPED - returned if not mapped

DESCRIPTION	:

========================================================================
*/

GLOBAL int page_status IFN1(short, EMpage_no)
{
	short physical_page_no = 0;
			/* position of page in physical memory	*/

	do
		if(EM_page_mapped[physical_page_no] == EMpage_no)
			break;
	while(++physical_page_no < no_phys_pages );

	if(physical_page_no >= no_phys_pages)
		return(UNMAPPED);
	else
		return(physical_page_no);
}

/*
========================================================================

FUNCTION	: phys_page_from_addr
		
PURPOSE		: determines the physical page number of a LIM page
		  from its Intel address.
		  		
RETURNED STATUS	: The physical page containing the LIM address.

DESCRIPTION	:
			
=======================================================================
*/

LOCAL SHORT
phys_page_from_addr IFN1( sys_addr, address )

{
	sys_addr	start;

	start = effective_addr( EM_start, 0x0 );

	return( (SHORT)((ULONG)(( address - start ) / EMM_PAGE_SIZE )));
}

/*
========================================================================

FUNCTION	: get_total_pages
		  get_unallocated_pages
		  get_base_address
		  get_total_handles
		  get_total_open_handles
		  get_no_phys_pages
		  get_page_seg
		  get_map_size

PURPOSE		: simply returns the reqested variables, to avoid
		having to use globals


RETURNED STATUS	: the following variables are returned , depending upon
		the routine called:-
			total_pages
			unallocated_pages
			base_address
			total_handles
			total_open_handles
			no_phys_pages
			physical_page[i]
			map_size

DESCRIPTION	:

========================================================================
*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_LIM2.seg"
#endif

GLOBAL short get_total_pages IFN0()
{
	return(total_pages);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_LIM.seg"
#endif

GLOBAL short get_unallocated_pages IFN0()
{
	return(unallocated_pages);
}

GLOBAL unsigned short get_base_address IFN0()
{
#ifdef NTVDM
	return(physical_page[0]);
#else
	return(EM_start);
#endif
}

GLOBAL short get_total_handles IFN0()
{
	return(total_handles);
}

GLOBAL short get_total_open_handles IFN0()
{
	return(total_open_handles);
}

GLOBAL short get_no_phys_pages IFN0()
{
	return(no_phys_pages);
}

GLOBAL unsigned short get_page_seg IFN1(unsigned char, page_no)
{
	return(physical_page[page_no]);
}

GLOBAL short get_map_size IFN0()
{
	return(map_size);
}

#ifdef NTVDM
GLOBAL short get_segment_page_no(unsigned short segment)
{
#if defined(LARGE_FRAME) && !defined(MONITOR)
	short i
	for (i = 0; i < no_phys_pages; i++)
	    if (physical_page[i] == segment)
		break;
	return(i);
#else
	return((segment - physical_page[0]) / EMM_PAGE_SIZE);
#endif

}
GLOBAL	unsigned short get_no_altreg_sets(void)
{
	return(no_altreg_sets);
}

GLOBAL unsigned short get_active_altreg_set(void)
{
	return(active_altreg_set);
}

GLOBAL boolean altreg_set_ok(unsigned short set)
{
    return(set < no_altreg_sets &&
	   (altreg_alloc_mask[set >> 3] & (1 << (set & 0x07))));

}

#if defined (NTVDM) && defined(MONITOR) && !defined(PROD)
/* these functions are provided for monitor to verify that
 * it has the same definitions of EMM_PAGE_SIZE and INTEL_PAGE_SIZE as
 * ours.
 */

GLOBAL unsigned short get_emm_page_size(void)
{
    return ((unsigned short)EMM_PAGE_SIZE);
}
GLOBAL unsigned short get_intel_page_size(void)
{
    return ((unsigned short) INTEL_PAGE_SIZE);
}
#endif

/* allocate a free alt mapping register set */

GLOBAL boolean allocate_altreg_set(unsigned short *altreg_set)
{
    short byte_offset, bit_offset;
    short  *page_mapped_ptr;
    IU8 mask;
    int i;
    /* this check is very important because we ** probably ** have
     * several unused bits in the allocation mask array
     */
    if (free_altreg_sets == 0)
	return (FALSE);

    /* use quick and dirty way to allocate a set */
    if (next_free_altreg_set < no_altreg_sets) {
	altreg_alloc_mask[next_free_altreg_set >> 3] |=
	       (0x1 << (next_free_altreg_set & 0x07));
	*altreg_set = next_free_altreg_set++;
    }
    else {
	for (byte_offset = 0; byte_offset < no_altreg_sets; byte_offset++) {
	    if (altreg_alloc_mask[byte_offset] != 0xFF) {
		mask = altreg_alloc_mask[byte_offset];
		bit_offset = 0;
		while (mask & (1 << bit_offset))
		    bit_offset++;
		break;
	    }
	}
	altreg_alloc_mask[byte_offset] |= (1 << bit_offset);
	*altreg_set = byte_offset * 8 + bit_offset;
    }
    /* a new alt reg set is just allocated, initialize its
     * mapping register to the current active set
     */
    page_mapped_ptr = GET_EM_PAGE_MAPPED_PTR(*altreg_set);
    for (i = 0; i < no_phys_pages; i++)
	page_mapped_ptr[i] = EM_page_mapped[i];
    return TRUE;
}
/* free the given alt mapping register set */
GLOBAL boolean deallocate_altreg_set(unsigned short set)
{

    /* can not deallocate set 0 or active set */
    if (set != 0 && set != active_altreg_set && set < no_altreg_sets &&
	altreg_alloc_mask[set >> 3] & (1 << (set &0x07))) {

	altreg_alloc_mask[set >> 3] &= (0xFE << (set & 0x07));
	free_altreg_sets++;
	if (free_altreg_sets == (no_altreg_sets - 1))
	    next_free_altreg_set = 1;
	return TRUE;
    }
    return FALSE;
}

/* This function activate the given alt mapping register set
 * input: alt reg set to be activated.
 * output: TRUE if the given set is activated.
 *	   FALSE if the given set is not activated.
 */

GLOBAL boolean activate_altreg_set(unsigned short set, short * page_in)
{
    int i;
    short * page_out, *page_in_ptr;
    short new_page, old_page, segment;


    if (active_altreg_set == set && page_in == NULL)
	return TRUE;

    /* get the mapping array to be mapped in*/
    page_in_ptr = GET_EM_PAGE_MAPPED_PTR(set);

    /* if no page-in override, use the altreg set current mapping */
    if (page_in == NULL)
	page_in = page_in_ptr;

    /* the active altreg is being paged out */
    page_out = GET_EM_PAGE_MAPPED_PTR(active_altreg_set);
    for ( i = 0; i < no_phys_pages; i++) {
	new_page = page_in[i];
	old_page = page_out[i];
	segment = physical_page[i];

	if (old_page != EMPTY && old_page != new_page) {
	    if (host_unmap_page(segment, old_page) != SUCCESS)
		return FALSE;
	}
	if(new_page != EMPTY && new_page != old_page) {
	    if (host_map_page(new_page, segment) != SUCCESS)
		return FALSE;
	}
	/* update the active-to-be set mapping */
	page_in_ptr[i] = new_page;
    }
    active_altreg_set = set;
    EM_page_mapped = page_in_ptr;
    return TRUE;
}
#endif	/* NTVDM */

#ifndef NTVDM

/*
========================================================================

FUNCTION	: LIM_b_write,
		  LIM_w_write,
		  LIM_str_write
		  patch_pages
		
PURPOSE		: LIM byte, word & string - called from write check
		  failure code in the CPU when a write to a multi-mapped
		  LIM page is detected.
		  patch_pages - generic code called from the other
		  three routines.
		  		
RETURNED STATUS	: None.

DESCRIPTION	:
			
========================================================================
*/

LOCAL VOID
patch_one_page_partial IFN4( sys_addr, intel_addr, sys_addr, eff_addr,
			MM_LIM_op_type, type, ULONG, data )

{
	ULONG		check_len;

	UNUSED( intel_addr );	/* Used in patch_one_page_full() */

	switch( type )
	{
		case BYTE_OP:
			check_len = 1;
			break;

		case WORD_OP:
			check_len = 2;
			break;

		case STR_OP:
			check_len = data;
			break;
	}

	sas_overwrite_memory( eff_addr, check_len );
}

LOCAL VOID
patch_one_page_full IFN4( sys_addr, intel_addr, sys_addr, eff_addr,
			MM_LIM_op_type, type, ULONG, data )

{
	sys_addr	check_addr;
	ULONG		check_len;

	switch( type )
	{
		case BYTE_OP:
			check_addr = eff_addr;
			check_len = 1;
			sas_store_no_check( eff_addr, data );
			break;

		case WORD_OP:
			check_addr = eff_addr;
			check_len = 2;
			sas_storew_no_check( eff_addr, data );
			break;

		case STR_OP:
			check_addr = eff_addr;
			check_len = data;
			do
			{
				sas_store_no_check( eff_addr,
					sas_hw_at_no_check(
							intel_addr ));
				intel_addr++;
				eff_addr++;
			}
			while( --data );
			break;
	}

	sas_overwrite_memory( check_addr, check_len );
}

LOCAL VOID
patch_pages IFN6( MM_LIM_op_type, type, ULONG, offset,
			SHORT, EM_page_no, SHORT, phys_page_no,
			ULONG, data, sys_addr, intel_addr )

{
	LONG		cnt01;
	sys_addr	eff_addr;

	for( cnt01 = 0; cnt01 < get_no_phys_pages(); cnt01++ )
	{
		if(( EM_page_mapped[cnt01] == EM_page_no ) &&
							( cnt01 != phys_page_no ))
		{
			eff_addr = effective_addr( get_page_seg(cnt01),
										offset );

			host_patch_one_page( intel_addr, eff_addr, type, data );

			sure_note_trace1(LIM_VERBOSE,
					"MM LIM write type %d", type );
			sure_note_trace2(LIM_VERBOSE,
					"log page 0x%x, phs page 0x%x",
								EM_page_no, cnt01 );
		}
	}
}

GLOBAL VOID
LIM_b_write IFN1( sys_addr, intel_addr )

{
	ULONG		limdata;
	SHORT		EM_page_no, phys_page_no;
	word		offset;

	phys_page_no = phys_page_from_addr( intel_addr );

	offset = intel_addr -
				effective_addr( get_page_seg(phys_page_no), 0x0 );

	EM_page_no = EM_page_mapped[phys_page_no];

	/*
	 * Get the data written in order to patch up this
	 * page's buddy pages.
	 */

	limdata = (ULONG) sas_hw_at_no_check( intel_addr );
	patch_pages( BYTE_OP, offset, EM_page_no, phys_page_no,
								limdata, intel_addr );

	/*
	 * Tell the CPU that this page has been written to.
	 */

	sas_overwrite_memory( intel_addr, 1 );
}

GLOBAL VOID
LIM_w_write IFN1( sys_addr, intel_addr )

{
	ULONG		limdata;
	SHORT		EM_page_no, phys_page_no;
	word		offset;

	phys_page_no = phys_page_from_addr( intel_addr );

	offset = intel_addr -
				effective_addr( get_page_seg(phys_page_no), 0x0 );

	EM_page_no = EM_page_mapped[phys_page_no];

	limdata = (ULONG) sas_w_at_no_check( intel_addr );
	patch_pages( WORD_OP, offset, EM_page_no, phys_page_no,
								limdata, intel_addr );

	sas_overwrite_memory( intel_addr, 2 );
}

GLOBAL VOID
LIM_str_write IFN2( sys_addr, intel_addr, ULONG, length )

{
   	SHORT		EM_page_no, phys_page_no;
	word		offset;

	phys_page_no = phys_page_from_addr( intel_addr );

	offset = intel_addr -
				effective_addr( get_page_seg(phys_page_no), 0x0 );

	EM_page_no = EM_page_mapped[phys_page_no];

	patch_pages( STR_OP, offset, EM_page_no, phys_page_no,
								length, intel_addr );

	sas_overwrite_memory( intel_addr, length );
}
#endif	/* !NTVDM */

#ifndef PROD
/*
===========================================================================

FUNCTION	: print_handle_data

PURPOSE		: used for debugging only - prints all the data stored
		for a given handle

RETURNED STATUS	: none

DESCRIPTION	:

=========================================================================
*/
GLOBAL void print_handle_data IFN1(short, handle_no)

{
	long	storage_ID;
	byte	*ptr;
	short	no_pages, i;
	char	*name_ptr;
	short	*map_ptr;
	short	*page_ptr;

	if ((storage_ID = handle[handle_no]) == 0)
	{
		printf("Unassigned handle - No. %d\n",handle_no);
		return;
	}
	ptr = USEBLOCK(storage_ID);
	name_ptr = (char *)ptr + NAME_OFFSET;
	map_ptr = (short *)(ptr + MAP_OFFSET);
	page_ptr = (short *)(ptr + page_offset);

	no_pages = *(short *)ptr;
	printf("Handle No. %d\n",handle_no);
	printf("No. of Pages = %d\n",no_pages);
	printf("Name         = '");
	for(i=0;i<8;i++)
		printf("%c",*name_ptr++);
	printf("'\n");
	printf("Map = ");
	for(i=0;i<no_phys_pages;i++)
		printf(" %d",*map_ptr++);
	printf("\n");
	for(i=0;i<no_pages;i++)
		printf("Page (%d)     = %d\n",i,*page_ptr++);

	FORGETBLOCK(storage_ID);

	return;
}
#endif	/* !PROD	*/
#endif 	/* LIM		*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\acc_efi.h ===
/*    0 0000  NA   SZ_B    DFLT   DS */		ACCESS_NA_NA,
/*    1 0001  NA   SZ_B    DFLT   SS */		ACCESS_NA_NA,
/*    2 0010  NA   SZ_B    ES     DS */		ACCESS_NA_NA,
/*    3 0011  NA   SZ_B    ES     SS */		ACCESS_NA_NA,
/*    4 0020  NA   SZ_B    CS     DS */		ACCESS_NA_NA,
/*    5 0021  NA   SZ_B    CS     SS */		ACCESS_NA_NA,
/*    6 0030  NA   SZ_B    SS     DS */		ACCESS_NA_NA,
/*    7 0031  NA   SZ_B    SS     SS */		ACCESS_NA_NA,
/*    8 0040  NA   SZ_B    DS     DS */		ACCESS_NA_NA,
/*    9 0041  NA   SZ_B    DS     SS */		ACCESS_NA_NA,
/*   10 0050  NA   SZ_B    FS     DS */		ACCESS_NA_NA,
/*   11 0051  NA   SZ_B    FS     SS */		ACCESS_NA_NA,
/*   12 0060  NA   SZ_B    GS     DS */		ACCESS_NA_NA,
/*   13 0061  NA   SZ_B    GS     SS */		ACCESS_NA_NA,
/*   14 0070  NA   SZ_B    -      DS */		ACCESS_NA_NA,
/*   15 0071  NA   SZ_B    -      SS */		ACCESS_NA_NA,
/*   16 0100  NA   SZ_B    DFLT   DS */		ACCESS_NA_NA,
/*   17 0101  NA   SZ_B    DFLT   SS */		ACCESS_NA_NA,
/*   18 0110  NA   SZ_B    ES     DS */		ACCESS_NA_NA,
/*   19 0111  NA   SZ_B    ES     SS */		ACCESS_NA_NA,
/*   20 0120  NA   SZ_B    CS     DS */		ACCESS_NA_NA,
/*   21 0121  NA   SZ_B    CS     SS */		ACCESS_NA_NA,
/*   22 0130  NA   SZ_B    SS     DS */		ACCESS_NA_NA,
/*   23 0131  NA   SZ_B    SS     SS */		ACCESS_NA_NA,
/*   24 0140  NA   SZ_B    DS     DS */		ACCESS_NA_NA,
/*   25 0141  NA   SZ_B    DS     SS */		ACCESS_NA_NA,
/*   26 0150  NA   SZ_B    FS     DS */		ACCESS_NA_NA,
/*   27 0151  NA   SZ_B    FS     SS */		ACCESS_NA_NA,
/*   28 0160  NA   SZ_B    GS     DS */		ACCESS_NA_NA,
/*   29 0161  NA   SZ_B    GS     SS */		ACCESS_NA_NA,
/*   30 0170  NA   SZ_B    -      DS */		ACCESS_NA_NA,
/*   31 0171  NA   SZ_B    -      SS */		ACCESS_NA_NA,
/*   32 0200  NA   SZ_W    DFLT   DS */		ACCESS_NA_NA,
/*   33 0201  NA   SZ_W    DFLT   SS */		ACCESS_NA_NA,
/*   34 0210  NA   SZ_W    ES     DS */		ACCESS_NA_NA,
/*   35 0211  NA   SZ_W    ES     SS */		ACCESS_NA_NA,
/*   36 0220  NA   SZ_W    CS     DS */		ACCESS_NA_NA,
/*   37 0221  NA   SZ_W    CS     SS */		ACCESS_NA_NA,
/*   38 0230  NA   SZ_W    SS     DS */		ACCESS_NA_NA,
/*   39 0231  NA   SZ_W    SS     SS */		ACCESS_NA_NA,
/*   40 0240  NA   SZ_W    DS     DS */		ACCESS_NA_NA,
/*   41 0241  NA   SZ_W    DS     SS */		ACCESS_NA_NA,
/*   42 0250  NA   SZ_W    FS     DS */		ACCESS_NA_NA,
/*   43 0251  NA   SZ_W    FS     SS */		ACCESS_NA_NA,
/*   44 0260  NA   SZ_W    GS     DS */		ACCESS_NA_NA,
/*   45 0261  NA   SZ_W    GS     SS */		ACCESS_NA_NA,
/*   46 0270  NA   SZ_W    -      DS */		ACCESS_NA_NA,
/*   47 0271  NA   SZ_W    -      SS */		ACCESS_NA_NA,
/*   48 0300  NA   SZ_D    DFLT   DS */		ACCESS_NA_NA,
/*   49 0301  NA   SZ_D    DFLT   SS */		ACCESS_NA_NA,
/*   50 0310  NA   SZ_D    ES     DS */		ACCESS_NA_NA,
/*   51 0311  NA   SZ_D    ES     SS */		ACCESS_NA_NA,
/*   52 0320  NA   SZ_D    CS     DS */		ACCESS_NA_NA,
/*   53 0321  NA   SZ_D    CS     SS */		ACCESS_NA_NA,
/*   54 0330  NA   SZ_D    SS     DS */		ACCESS_NA_NA,
/*   55 0331  NA   SZ_D    SS     SS */		ACCESS_NA_NA,
/*   56 0340  NA   SZ_D    DS     DS */		ACCESS_NA_NA,
/*   57 0341  NA   SZ_D    DS     SS */		ACCESS_NA_NA,
/*   58 0350  NA   SZ_D    FS     DS */		ACCESS_NA_NA,
/*   59 0351  NA   SZ_D    FS     SS */		ACCESS_NA_NA,
/*   60 0360  NA   SZ_D    GS     DS */		ACCESS_NA_NA,
/*   61 0361  NA   SZ_D    GS     SS */		ACCESS_NA_NA,
/*   62 0370  NA   SZ_D    -      DS */		ACCESS_NA_NA,
/*   63 0371  NA   SZ_D    -      SS */		ACCESS_NA_NA,
/*   64 0400  NA   SZ_W    DFLT   DS */		ACCESS_NA_NA,
/*   65 0401  NA   SZ_W    DFLT   SS */		ACCESS_NA_NA,
/*   66 0410  NA   SZ_W    ES     DS */		ACCESS_NA_NA,
/*   67 0411  NA   SZ_W    ES     SS */		ACCESS_NA_NA,
/*   68 0420  NA   SZ_W    CS     DS */		ACCESS_NA_NA,
/*   69 0421  NA   SZ_W    CS     SS */		ACCESS_NA_NA,
/*   70 0430  NA   SZ_W    SS     DS */		ACCESS_NA_NA,
/*   71 0431  NA   SZ_W    SS     SS */		ACCESS_NA_NA,
/*   72 0440  NA   SZ_W    DS     DS */		ACCESS_NA_NA,
/*   73 0441  NA   SZ_W    DS     SS */		ACCESS_NA_NA,
/*   74 0450  NA   SZ_W    FS     DS */		ACCESS_NA_NA,
/*   75 0451  NA   SZ_W    FS     SS */		ACCESS_NA_NA,
/*   76 0460  NA   SZ_W    GS     DS */		ACCESS_NA_NA,
/*   77 0461  NA   SZ_W    GS     SS */		ACCESS_NA_NA,
/*   78 0470  NA   SZ_W    -      DS */		ACCESS_NA_NA,
/*   79 0471  NA   SZ_W    -      SS */		ACCESS_NA_NA,
/*   80 0500  NA   -       DFLT   DS */		ACCESS_NA_NA,
/*   81 0501  NA   -       DFLT   SS */		ACCESS_NA_NA,
/*   82 0510  NA   -       ES     DS */		ACCESS_NA_NA,
/*   83 0511  NA   -       ES     SS */		ACCESS_NA_NA,
/*   84 0520  NA   -       CS     DS */		ACCESS_NA_NA,
/*   85 0521  NA   -       CS     SS */		ACCESS_NA_NA,
/*   86 0530  NA   -       SS     DS */		ACCESS_NA_NA,
/*   87 0531  NA   -       SS     SS */		ACCESS_NA_NA,
/*   88 0540  NA   -       DS     DS */		ACCESS_NA_NA,
/*   89 0541  NA   -       DS     SS */		ACCESS_NA_NA,
/*   90 0550  NA   -       FS     DS */		ACCESS_NA_NA,
/*   91 0551  NA   -       FS     SS */		ACCESS_NA_NA,
/*   92 0560  NA   -       GS     DS */		ACCESS_NA_NA,
/*   93 0561  NA   -       GS     SS */		ACCESS_NA_NA,
/*   94 0570  NA   -       -      DS */		ACCESS_NA_NA,
/*   95 0571  NA   -       -      SS */		ACCESS_NA_NA,
/*   96 0600  NA   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*   97 0601  NA   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*   98 0610  NA   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*   99 0611  NA   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  100 0620  NA   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  101 0621  NA   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  102 0630  NA   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  103 0631  NA   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  104 0640  NA   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  105 0641  NA   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  106 0650  NA   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  107 0651  NA   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  108 0660  NA   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  109 0661  NA   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  110 0670  NA   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  111 0671  NA   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  112 0700  NA   SZ_WD   DFLT   DS */		ACCESS_NA_NA,
/*  113 0701  NA   SZ_WD   DFLT   SS */		ACCESS_NA_NA,
/*  114 0710  NA   SZ_WD   ES     DS */		ACCESS_NA_NA,
/*  115 0711  NA   SZ_WD   ES     SS */		ACCESS_NA_NA,
/*  116 0720  NA   SZ_WD   CS     DS */		ACCESS_NA_NA,
/*  117 0721  NA   SZ_WD   CS     SS */		ACCESS_NA_NA,
/*  118 0730  NA   SZ_WD   SS     DS */		ACCESS_NA_NA,
/*  119 0731  NA   SZ_WD   SS     SS */		ACCESS_NA_NA,
/*  120 0740  NA   SZ_WD   DS     DS */		ACCESS_NA_NA,
/*  121 0741  NA   SZ_WD   DS     SS */		ACCESS_NA_NA,
/*  122 0750  NA   SZ_WD   FS     DS */		ACCESS_NA_NA,
/*  123 0751  NA   SZ_WD   FS     SS */		ACCESS_NA_NA,
/*  124 0760  NA   SZ_WD   GS     DS */		ACCESS_NA_NA,
/*  125 0761  NA   SZ_WD   GS     SS */		ACCESS_NA_NA,
/*  126 0770  NA   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  127 0771  NA   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  128 1000  RD   SZ_B    DFLT   DS */		ACCESS_DS_RD_B,
/*  129 1001  RD   SZ_B    DFLT   SS */		ACCESS_SS_RD_B,
/*  130 1010  RD   SZ_B    ES     DS */		ACCESS_ES_RD_B,
/*  131 1011  RD   SZ_B    ES     SS */		ACCESS_ES_RD_B,
/*  132 1020  RD   SZ_B    CS     DS */		ACCESS_CS_RD_B,
/*  133 1021  RD   SZ_B    CS     SS */		ACCESS_CS_RD_B,
/*  134 1030  RD   SZ_B    SS     DS */		ACCESS_SS_RD_B,
/*  135 1031  RD   SZ_B    SS     SS */		ACCESS_SS_RD_B,
/*  136 1040  RD   SZ_B    DS     DS */		ACCESS_DS_RD_B,
/*  137 1041  RD   SZ_B    DS     SS */		ACCESS_DS_RD_B,
/*  138 1050  RD   SZ_B    FS     DS */		ACCESS_FS_RD_B,
/*  139 1051  RD   SZ_B    FS     SS */		ACCESS_FS_RD_B,
/*  140 1060  RD   SZ_B    GS     DS */		ACCESS_GS_RD_B,
/*  141 1061  RD   SZ_B    GS     SS */		ACCESS_GS_RD_B,
/*  142 1070  RD   SZ_B    -      DS */		ACCESS_NA_NA,
/*  143 1071  RD   SZ_B    -      SS */		ACCESS_NA_NA,
/*  144 1100  RD   SZ_B    DFLT   DS */		ACCESS_DS_RD_B,
/*  145 1101  RD   SZ_B    DFLT   SS */		ACCESS_SS_RD_B,
/*  146 1110  RD   SZ_B    ES     DS */		ACCESS_ES_RD_B,
/*  147 1111  RD   SZ_B    ES     SS */		ACCESS_ES_RD_B,
/*  148 1120  RD   SZ_B    CS     DS */		ACCESS_CS_RD_B,
/*  149 1121  RD   SZ_B    CS     SS */		ACCESS_CS_RD_B,
/*  150 1130  RD   SZ_B    SS     DS */		ACCESS_SS_RD_B,
/*  151 1131  RD   SZ_B    SS     SS */		ACCESS_SS_RD_B,
/*  152 1140  RD   SZ_B    DS     DS */		ACCESS_DS_RD_B,
/*  153 1141  RD   SZ_B    DS     SS */		ACCESS_DS_RD_B,
/*  154 1150  RD   SZ_B    FS     DS */		ACCESS_FS_RD_B,
/*  155 1151  RD   SZ_B    FS     SS */		ACCESS_FS_RD_B,
/*  156 1160  RD   SZ_B    GS     DS */		ACCESS_GS_RD_B,
/*  157 1161  RD   SZ_B    GS     SS */		ACCESS_GS_RD_B,
/*  158 1170  RD   SZ_B    -      DS */		ACCESS_NA_NA,
/*  159 1171  RD   SZ_B    -      SS */		ACCESS_NA_NA,
/*  160 1200  RD   SZ_W    DFLT   DS */		ACCESS_DS_RD_W,
/*  161 1201  RD   SZ_W    DFLT   SS */		ACCESS_SS_RD_W,
/*  162 1210  RD   SZ_W    ES     DS */		ACCESS_ES_RD_W,
/*  163 1211  RD   SZ_W    ES     SS */		ACCESS_ES_RD_W,
/*  164 1220  RD   SZ_W    CS     DS */		ACCESS_CS_RD_W,
/*  165 1221  RD   SZ_W    CS     SS */		ACCESS_CS_RD_W,
/*  166 1230  RD   SZ_W    SS     DS */		ACCESS_SS_RD_W,
/*  167 1231  RD   SZ_W    SS     SS */		ACCESS_SS_RD_W,
/*  168 1240  RD   SZ_W    DS     DS */		ACCESS_DS_RD_W,
/*  169 1241  RD   SZ_W    DS     SS */		ACCESS_DS_RD_W,
/*  170 1250  RD   SZ_W    FS     DS */		ACCESS_FS_RD_W,
/*  171 1251  RD   SZ_W    FS     SS */		ACCESS_FS_RD_W,
/*  172 1260  RD   SZ_W    GS     DS */		ACCESS_GS_RD_W,
/*  173 1261  RD   SZ_W    GS     SS */		ACCESS_GS_RD_W,
/*  174 1270  RD   SZ_W    -      DS */		ACCESS_NA_NA,
/*  175 1271  RD   SZ_W    -      SS */		ACCESS_NA_NA,
/*  176 1300  RD   SZ_D    DFLT   DS */		ACCESS_DS_RD_D,
/*  177 1301  RD   SZ_D    DFLT   SS */		ACCESS_SS_RD_D,
/*  178 1310  RD   SZ_D    ES     DS */		ACCESS_ES_RD_D,
/*  179 1311  RD   SZ_D    ES     SS */		ACCESS_ES_RD_D,
/*  180 1320  RD   SZ_D    CS     DS */		ACCESS_CS_RD_D,
/*  181 1321  RD   SZ_D    CS     SS */		ACCESS_CS_RD_D,
/*  182 1330  RD   SZ_D    SS     DS */		ACCESS_SS_RD_D,
/*  183 1331  RD   SZ_D    SS     SS */		ACCESS_SS_RD_D,
/*  184 1340  RD   SZ_D    DS     DS */		ACCESS_DS_RD_D,
/*  185 1341  RD   SZ_D    DS     SS */		ACCESS_DS_RD_D,
/*  186 1350  RD   SZ_D    FS     DS */		ACCESS_FS_RD_D,
/*  187 1351  RD   SZ_D    FS     SS */		ACCESS_FS_RD_D,
/*  188 1360  RD   SZ_D    GS     DS */		ACCESS_GS_RD_D,
/*  189 1361  RD   SZ_D    GS     SS */		ACCESS_GS_RD_D,
/*  190 1370  RD   SZ_D    -      DS */		ACCESS_NA_NA,
/*  191 1371  RD   SZ_D    -      SS */		ACCESS_NA_NA,
/*  192 1400  RD   SZ_W    DFLT   DS */		ACCESS_DS_RD_W,
/*  193 1401  RD   SZ_W    DFLT   SS */		ACCESS_SS_RD_W,
/*  194 1410  RD   SZ_W    ES     DS */		ACCESS_ES_RD_W,
/*  195 1411  RD   SZ_W    ES     SS */		ACCESS_ES_RD_W,
/*  196 1420  RD   SZ_W    CS     DS */		ACCESS_CS_RD_W,
/*  197 1421  RD   SZ_W    CS     SS */		ACCESS_CS_RD_W,
/*  198 1430  RD   SZ_W    SS     DS */		ACCESS_SS_RD_W,
/*  199 1431  RD   SZ_W    SS     SS */		ACCESS_SS_RD_W,
/*  200 1440  RD   SZ_W    DS     DS */		ACCESS_DS_RD_W,
/*  201 1441  RD   SZ_W    DS     SS */		ACCESS_DS_RD_W,
/*  202 1450  RD   SZ_W    FS     DS */		ACCESS_FS_RD_W,
/*  203 1451  RD   SZ_W    FS     SS */		ACCESS_FS_RD_W,
/*  204 1460  RD   SZ_W    GS     DS */		ACCESS_GS_RD_W,
/*  205 1461  RD   SZ_W    GS     SS */		ACCESS_GS_RD_W,
/*  206 1470  RD   SZ_W    -      DS */		ACCESS_NA_NA,
/*  207 1471  RD   SZ_W    -      SS */		ACCESS_NA_NA,
/*  208 1500  RD   -       DFLT   DS */		ACCESS_NA_NA,
/*  209 1501  RD   -       DFLT   SS */		ACCESS_NA_NA,
/*  210 1510  RD   -       ES     DS */		ACCESS_NA_NA,
/*  211 1511  RD   -       ES     SS */		ACCESS_NA_NA,
/*  212 1520  RD   -       CS     DS */		ACCESS_NA_NA,
/*  213 1521  RD   -       CS     SS */		ACCESS_NA_NA,
/*  214 1530  RD   -       SS     DS */		ACCESS_NA_NA,
/*  215 1531  RD   -       SS     SS */		ACCESS_NA_NA,
/*  216 1540  RD   -       DS     DS */		ACCESS_NA_NA,
/*  217 1541  RD   -       DS     SS */		ACCESS_NA_NA,
/*  218 1550  RD   -       FS     DS */		ACCESS_NA_NA,
/*  219 1551  RD   -       FS     SS */		ACCESS_NA_NA,
/*  220 1560  RD   -       GS     DS */		ACCESS_NA_NA,
/*  221 1561  RD   -       GS     SS */		ACCESS_NA_NA,
/*  222 1570  RD   -       -      DS */		ACCESS_NA_NA,
/*  223 1571  RD   -       -      SS */		ACCESS_NA_NA,
/*  224 1600  RD   SZ_W2   DFLT   DS */		ACCESS_DS_RD_W2,
/*  225 1601  RD   SZ_W2   DFLT   SS */		ACCESS_SS_RD_W2,
/*  226 1610  RD   SZ_W2   ES     DS */		ACCESS_ES_RD_W2,
/*  227 1611  RD   SZ_W2   ES     SS */		ACCESS_ES_RD_W2,
/*  228 1620  RD   SZ_W2   CS     DS */		ACCESS_CS_RD_W2,
/*  229 1621  RD   SZ_W2   CS     SS */		ACCESS_CS_RD_W2,
/*  230 1630  RD   SZ_W2   SS     DS */		ACCESS_SS_RD_W2,
/*  231 1631  RD   SZ_W2   SS     SS */		ACCESS_SS_RD_W2,
/*  232 1640  RD   SZ_W2   DS     DS */		ACCESS_DS_RD_W2,
/*  233 1641  RD   SZ_W2   DS     SS */		ACCESS_DS_RD_W2,
/*  234 1650  RD   SZ_W2   FS     DS */		ACCESS_FS_RD_W2,
/*  235 1651  RD   SZ_W2   FS     SS */		ACCESS_FS_RD_W2,
/*  236 1660  RD   SZ_W2   GS     DS */		ACCESS_GS_RD_W2,
/*  237 1661  RD   SZ_W2   GS     SS */		ACCESS_GS_RD_W2,
/*  238 1670  RD   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  239 1671  RD   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  240 1700  RD   SZ_WD   DFLT   DS */		ACCESS_DS_RD_WD,
/*  241 1701  RD   SZ_WD   DFLT   SS */		ACCESS_SS_RD_WD,
/*  242 1710  RD   SZ_WD   ES     DS */		ACCESS_ES_RD_WD,
/*  243 1711  RD   SZ_WD   ES     SS */		ACCESS_ES_RD_WD,
/*  244 1720  RD   SZ_WD   CS     DS */		ACCESS_CS_RD_WD,
/*  245 1721  RD   SZ_WD   CS     SS */		ACCESS_CS_RD_WD,
/*  246 1730  RD   SZ_WD   SS     DS */		ACCESS_SS_RD_WD,
/*  247 1731  RD   SZ_WD   SS     SS */		ACCESS_SS_RD_WD,
/*  248 1740  RD   SZ_WD   DS     DS */		ACCESS_DS_RD_WD,
/*  249 1741  RD   SZ_WD   DS     SS */		ACCESS_DS_RD_WD,
/*  250 1750  RD   SZ_WD   FS     DS */		ACCESS_FS_RD_WD,
/*  251 1751  RD   SZ_WD   FS     SS */		ACCESS_FS_RD_WD,
/*  252 1760  RD   SZ_WD   GS     DS */		ACCESS_GS_RD_WD,
/*  253 1761  RD   SZ_WD   GS     SS */		ACCESS_GS_RD_WD,
/*  254 1770  RD   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  255 1771  RD   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  256 2000  WT   SZ_B    DFLT   DS */		ACCESS_DS_WT_B,
/*  257 2001  WT   SZ_B    DFLT   SS */		ACCESS_SS_WT_B,
/*  258 2010  WT   SZ_B    ES     DS */		ACCESS_ES_WT_B,
/*  259 2011  WT   SZ_B    ES     SS */		ACCESS_ES_WT_B,
/*  260 2020  WT   SZ_B    CS     DS */		ACCESS_CS_WT_B,
/*  261 2021  WT   SZ_B    CS     SS */		ACCESS_CS_WT_B,
/*  262 2030  WT   SZ_B    SS     DS */		ACCESS_SS_WT_B,
/*  263 2031  WT   SZ_B    SS     SS */		ACCESS_SS_WT_B,
/*  264 2040  WT   SZ_B    DS     DS */		ACCESS_DS_WT_B,
/*  265 2041  WT   SZ_B    DS     SS */		ACCESS_DS_WT_B,
/*  266 2050  WT   SZ_B    FS     DS */		ACCESS_FS_WT_B,
/*  267 2051  WT   SZ_B    FS     SS */		ACCESS_FS_WT_B,
/*  268 2060  WT   SZ_B    GS     DS */		ACCESS_GS_WT_B,
/*  269 2061  WT   SZ_B    GS     SS */		ACCESS_GS_WT_B,
/*  270 2070  WT   SZ_B    -      DS */		ACCESS_NA_NA,
/*  271 2071  WT   SZ_B    -      SS */		ACCESS_NA_NA,
/*  272 2100  WT   SZ_B    DFLT   DS */		ACCESS_DS_WT_B,
/*  273 2101  WT   SZ_B    DFLT   SS */		ACCESS_SS_WT_B,
/*  274 2110  WT   SZ_B    ES     DS */		ACCESS_ES_WT_B,
/*  275 2111  WT   SZ_B    ES     SS */		ACCESS_ES_WT_B,
/*  276 2120  WT   SZ_B    CS     DS */		ACCESS_CS_WT_B,
/*  277 2121  WT   SZ_B    CS     SS */		ACCESS_CS_WT_B,
/*  278 2130  WT   SZ_B    SS     DS */		ACCESS_SS_WT_B,
/*  279 2131  WT   SZ_B    SS     SS */		ACCESS_SS_WT_B,
/*  280 2140  WT   SZ_B    DS     DS */		ACCESS_DS_WT_B,
/*  281 2141  WT   SZ_B    DS     SS */		ACCESS_DS_WT_B,
/*  282 2150  WT   SZ_B    FS     DS */		ACCESS_FS_WT_B,
/*  283 2151  WT   SZ_B    FS     SS */		ACCESS_FS_WT_B,
/*  284 2160  WT   SZ_B    GS     DS */		ACCESS_GS_WT_B,
/*  285 2161  WT   SZ_B    GS     SS */		ACCESS_GS_WT_B,
/*  286 2170  WT   SZ_B    -      DS */		ACCESS_NA_NA,
/*  287 2171  WT   SZ_B    -      SS */		ACCESS_NA_NA,
/*  288 2200  WT   SZ_W    DFLT   DS */		ACCESS_DS_WT_W,
/*  289 2201  WT   SZ_W    DFLT   SS */		ACCESS_SS_WT_W,
/*  290 2210  WT   SZ_W    ES     DS */		ACCESS_ES_WT_W,
/*  291 2211  WT   SZ_W    ES     SS */		ACCESS_ES_WT_W,
/*  292 2220  WT   SZ_W    CS     DS */		ACCESS_CS_WT_W,
/*  293 2221  WT   SZ_W    CS     SS */		ACCESS_CS_WT_W,
/*  294 2230  WT   SZ_W    SS     DS */		ACCESS_SS_WT_W,
/*  295 2231  WT   SZ_W    SS     SS */		ACCESS_SS_WT_W,
/*  296 2240  WT   SZ_W    DS     DS */		ACCESS_DS_WT_W,
/*  297 2241  WT   SZ_W    DS     SS */		ACCESS_DS_WT_W,
/*  298 2250  WT   SZ_W    FS     DS */		ACCESS_FS_WT_W,
/*  299 2251  WT   SZ_W    FS     SS */		ACCESS_FS_WT_W,
/*  300 2260  WT   SZ_W    GS     DS */		ACCESS_GS_WT_W,
/*  301 2261  WT   SZ_W    GS     SS */		ACCESS_GS_WT_W,
/*  302 2270  WT   SZ_W    -      DS */		ACCESS_NA_NA,
/*  303 2271  WT   SZ_W    -      SS */		ACCESS_NA_NA,
/*  304 2300  WT   SZ_D    DFLT   DS */		ACCESS_DS_WT_D,
/*  305 2301  WT   SZ_D    DFLT   SS */		ACCESS_SS_WT_D,
/*  306 2310  WT   SZ_D    ES     DS */		ACCESS_ES_WT_D,
/*  307 2311  WT   SZ_D    ES     SS */		ACCESS_ES_WT_D,
/*  308 2320  WT   SZ_D    CS     DS */		ACCESS_CS_WT_D,
/*  309 2321  WT   SZ_D    CS     SS */		ACCESS_CS_WT_D,
/*  310 2330  WT   SZ_D    SS     DS */		ACCESS_SS_WT_D,
/*  311 2331  WT   SZ_D    SS     SS */		ACCESS_SS_WT_D,
/*  312 2340  WT   SZ_D    DS     DS */		ACCESS_DS_WT_D,
/*  313 2341  WT   SZ_D    DS     SS */		ACCESS_DS_WT_D,
/*  314 2350  WT   SZ_D    FS     DS */		ACCESS_FS_WT_D,
/*  315 2351  WT   SZ_D    FS     SS */		ACCESS_FS_WT_D,
/*  316 2360  WT   SZ_D    GS     DS */		ACCESS_GS_WT_D,
/*  317 2361  WT   SZ_D    GS     SS */		ACCESS_GS_WT_D,
/*  318 2370  WT   SZ_D    -      DS */		ACCESS_NA_NA,
/*  319 2371  WT   SZ_D    -      SS */		ACCESS_NA_NA,
/*  320 2400  WT   SZ_W    DFLT   DS */		ACCESS_DS_WT_W,
/*  321 2401  WT   SZ_W    DFLT   SS */		ACCESS_SS_WT_W,
/*  322 2410  WT   SZ_W    ES     DS */		ACCESS_ES_WT_W,
/*  323 2411  WT   SZ_W    ES     SS */		ACCESS_ES_WT_W,
/*  324 2420  WT   SZ_W    CS     DS */		ACCESS_CS_WT_W,
/*  325 2421  WT   SZ_W    CS     SS */		ACCESS_CS_WT_W,
/*  326 2430  WT   SZ_W    SS     DS */		ACCESS_SS_WT_W,
/*  327 2431  WT   SZ_W    SS     SS */		ACCESS_SS_WT_W,
/*  328 2440  WT   SZ_W    DS     DS */		ACCESS_DS_WT_W,
/*  329 2441  WT   SZ_W    DS     SS */		ACCESS_DS_WT_W,
/*  330 2450  WT   SZ_W    FS     DS */		ACCESS_FS_WT_W,
/*  331 2451  WT   SZ_W    FS     SS */		ACCESS_FS_WT_W,
/*  332 2460  WT   SZ_W    GS     DS */		ACCESS_GS_WT_W,
/*  333 2461  WT   SZ_W    GS     SS */		ACCESS_GS_WT_W,
/*  334 2470  WT   SZ_W    -      DS */		ACCESS_NA_NA,
/*  335 2471  WT   SZ_W    -      SS */		ACCESS_NA_NA,
/*  336 2500  WT   -       DFLT   DS */		ACCESS_NA_NA,
/*  337 2501  WT   -       DFLT   SS */		ACCESS_NA_NA,
/*  338 2510  WT   -       ES     DS */		ACCESS_NA_NA,
/*  339 2511  WT   -       ES     SS */		ACCESS_NA_NA,
/*  340 2520  WT   -       CS     DS */		ACCESS_NA_NA,
/*  341 2521  WT   -       CS     SS */		ACCESS_NA_NA,
/*  342 2530  WT   -       SS     DS */		ACCESS_NA_NA,
/*  343 2531  WT   -       SS     SS */		ACCESS_NA_NA,
/*  344 2540  WT   -       DS     DS */		ACCESS_NA_NA,
/*  345 2541  WT   -       DS     SS */		ACCESS_NA_NA,
/*  346 2550  WT   -       FS     DS */		ACCESS_NA_NA,
/*  347 2551  WT   -       FS     SS */		ACCESS_NA_NA,
/*  348 2560  WT   -       GS     DS */		ACCESS_NA_NA,
/*  349 2561  WT   -       GS     SS */		ACCESS_NA_NA,
/*  350 2570  WT   -       -      DS */		ACCESS_NA_NA,
/*  351 2571  WT   -       -      SS */		ACCESS_NA_NA,
/*  352 2600  WT   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*  353 2601  WT   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*  354 2610  WT   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*  355 2611  WT   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  356 2620  WT   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  357 2621  WT   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  358 2630  WT   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  359 2631  WT   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  360 2640  WT   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  361 2641  WT   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  362 2650  WT   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  363 2651  WT   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  364 2660  WT   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  365 2661  WT   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  366 2670  WT   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  367 2671  WT   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  368 2700  WT   SZ_WD   DFLT   DS */		ACCESS_DS_WT_WD,
/*  369 2701  WT   SZ_WD   DFLT   SS */		ACCESS_SS_WT_WD,
/*  370 2710  WT   SZ_WD   ES     DS */		ACCESS_ES_WT_WD,
/*  371 2711  WT   SZ_WD   ES     SS */		ACCESS_ES_WT_WD,
/*  372 2720  WT   SZ_WD   CS     DS */		ACCESS_CS_WT_WD,
/*  373 2721  WT   SZ_WD   CS     SS */		ACCESS_CS_WT_WD,
/*  374 2730  WT   SZ_WD   SS     DS */		ACCESS_SS_WT_WD,
/*  375 2731  WT   SZ_WD   SS     SS */		ACCESS_SS_WT_WD,
/*  376 2740  WT   SZ_WD   DS     DS */		ACCESS_DS_WT_WD,
/*  377 2741  WT   SZ_WD   DS     SS */		ACCESS_DS_WT_WD,
/*  378 2750  WT   SZ_WD   FS     DS */		ACCESS_FS_WT_WD,
/*  379 2751  WT   SZ_WD   FS     SS */		ACCESS_FS_WT_WD,
/*  380 2760  WT   SZ_WD   GS     DS */		ACCESS_GS_WT_WD,
/*  381 2761  WT   SZ_WD   GS     SS */		ACCESS_GS_WT_WD,
/*  382 2770  WT   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  383 2771  WT   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  384 3000  RW   SZ_B    DFLT   DS */		ACCESS_DS_RW_B,
/*  385 3001  RW   SZ_B    DFLT   SS */		ACCESS_SS_RW_B,
/*  386 3010  RW   SZ_B    ES     DS */		ACCESS_ES_RW_B,
/*  387 3011  RW   SZ_B    ES     SS */		ACCESS_ES_RW_B,
/*  388 3020  RW   SZ_B    CS     DS */		ACCESS_CS_RW_B,
/*  389 3021  RW   SZ_B    CS     SS */		ACCESS_CS_RW_B,
/*  390 3030  RW   SZ_B    SS     DS */		ACCESS_SS_RW_B,
/*  391 3031  RW   SZ_B    SS     SS */		ACCESS_SS_RW_B,
/*  392 3040  RW   SZ_B    DS     DS */		ACCESS_DS_RW_B,
/*  393 3041  RW   SZ_B    DS     SS */		ACCESS_DS_RW_B,
/*  394 3050  RW   SZ_B    FS     DS */		ACCESS_FS_RW_B,
/*  395 3051  RW   SZ_B    FS     SS */		ACCESS_FS_RW_B,
/*  396 3060  RW   SZ_B    GS     DS */		ACCESS_GS_RW_B,
/*  397 3061  RW   SZ_B    GS     SS */		ACCESS_GS_RW_B,
/*  398 3070  RW   SZ_B    -      DS */		ACCESS_NA_NA,
/*  399 3071  RW   SZ_B    -      SS */		ACCESS_NA_NA,
/*  400 3100  RW   SZ_B    DFLT   DS */		ACCESS_DS_RW_B,
/*  401 3101  RW   SZ_B    DFLT   SS */		ACCESS_SS_RW_B,
/*  402 3110  RW   SZ_B    ES     DS */		ACCESS_ES_RW_B,
/*  403 3111  RW   SZ_B    ES     SS */		ACCESS_ES_RW_B,
/*  404 3120  RW   SZ_B    CS     DS */		ACCESS_CS_RW_B,
/*  405 3121  RW   SZ_B    CS     SS */		ACCESS_CS_RW_B,
/*  406 3130  RW   SZ_B    SS     DS */		ACCESS_SS_RW_B,
/*  407 3131  RW   SZ_B    SS     SS */		ACCESS_SS_RW_B,
/*  408 3140  RW   SZ_B    DS     DS */		ACCESS_DS_RW_B,
/*  409 3141  RW   SZ_B    DS     SS */		ACCESS_DS_RW_B,
/*  410 3150  RW   SZ_B    FS     DS */		ACCESS_FS_RW_B,
/*  411 3151  RW   SZ_B    FS     SS */		ACCESS_FS_RW_B,
/*  412 3160  RW   SZ_B    GS     DS */		ACCESS_GS_RW_B,
/*  413 3161  RW   SZ_B    GS     SS */		ACCESS_GS_RW_B,
/*  414 3170  RW   SZ_B    -      DS */		ACCESS_NA_NA,
/*  415 3171  RW   SZ_B    -      SS */		ACCESS_NA_NA,
/*  416 3200  RW   SZ_W    DFLT   DS */		ACCESS_DS_RW_W,
/*  417 3201  RW   SZ_W    DFLT   SS */		ACCESS_SS_RW_W,
/*  418 3210  RW   SZ_W    ES     DS */		ACCESS_ES_RW_W,
/*  419 3211  RW   SZ_W    ES     SS */		ACCESS_ES_RW_W,
/*  420 3220  RW   SZ_W    CS     DS */		ACCESS_CS_RW_W,
/*  421 3221  RW   SZ_W    CS     SS */		ACCESS_CS_RW_W,
/*  422 3230  RW   SZ_W    SS     DS */		ACCESS_SS_RW_W,
/*  423 3231  RW   SZ_W    SS     SS */		ACCESS_SS_RW_W,
/*  424 3240  RW   SZ_W    DS     DS */		ACCESS_DS_RW_W,
/*  425 3241  RW   SZ_W    DS     SS */		ACCESS_DS_RW_W,
/*  426 3250  RW   SZ_W    FS     DS */		ACCESS_FS_RW_W,
/*  427 3251  RW   SZ_W    FS     SS */		ACCESS_FS_RW_W,
/*  428 3260  RW   SZ_W    GS     DS */		ACCESS_GS_RW_W,
/*  429 3261  RW   SZ_W    GS     SS */		ACCESS_GS_RW_W,
/*  430 3270  RW   SZ_W    -      DS */		ACCESS_NA_NA,
/*  431 3271  RW   SZ_W    -      SS */		ACCESS_NA_NA,
/*  432 3300  RW   SZ_D    DFLT   DS */		ACCESS_DS_RW_D,
/*  433 3301  RW   SZ_D    DFLT   SS */		ACCESS_SS_RW_D,
/*  434 3310  RW   SZ_D    ES     DS */		ACCESS_ES_RW_D,
/*  435 3311  RW   SZ_D    ES     SS */		ACCESS_ES_RW_D,
/*  436 3320  RW   SZ_D    CS     DS */		ACCESS_CS_RW_D,
/*  437 3321  RW   SZ_D    CS     SS */		ACCESS_CS_RW_D,
/*  438 3330  RW   SZ_D    SS     DS */		ACCESS_SS_RW_D,
/*  439 3331  RW   SZ_D    SS     SS */		ACCESS_SS_RW_D,
/*  440 3340  RW   SZ_D    DS     DS */		ACCESS_DS_RW_D,
/*  441 3341  RW   SZ_D    DS     SS */		ACCESS_DS_RW_D,
/*  442 3350  RW   SZ_D    FS     DS */		ACCESS_FS_RW_D,
/*  443 3351  RW   SZ_D    FS     SS */		ACCESS_FS_RW_D,
/*  444 3360  RW   SZ_D    GS     DS */		ACCESS_GS_RW_D,
/*  445 3361  RW   SZ_D    GS     SS */		ACCESS_GS_RW_D,
/*  446 3370  RW   SZ_D    -      DS */		ACCESS_NA_NA,
/*  447 3371  RW   SZ_D    -      SS */		ACCESS_NA_NA,
/*  448 3400  RW   SZ_W    DFLT   DS */		ACCESS_DS_RW_W,
/*  449 3401  RW   SZ_W    DFLT   SS */		ACCESS_SS_RW_W,
/*  450 3410  RW   SZ_W    ES     DS */		ACCESS_ES_RW_W,
/*  451 3411  RW   SZ_W    ES     SS */		ACCESS_ES_RW_W,
/*  452 3420  RW   SZ_W    CS     DS */		ACCESS_CS_RW_W,
/*  453 3421  RW   SZ_W    CS     SS */		ACCESS_CS_RW_W,
/*  454 3430  RW   SZ_W    SS     DS */		ACCESS_SS_RW_W,
/*  455 3431  RW   SZ_W    SS     SS */		ACCESS_SS_RW_W,
/*  456 3440  RW   SZ_W    DS     DS */		ACCESS_DS_RW_W,
/*  457 3441  RW   SZ_W    DS     SS */		ACCESS_DS_RW_W,
/*  458 3450  RW   SZ_W    FS     DS */		ACCESS_FS_RW_W,
/*  459 3451  RW   SZ_W    FS     SS */		ACCESS_FS_RW_W,
/*  460 3460  RW   SZ_W    GS     DS */		ACCESS_GS_RW_W,
/*  461 3461  RW   SZ_W    GS     SS */		ACCESS_GS_RW_W,
/*  462 3470  RW   SZ_W    -      DS */		ACCESS_NA_NA,
/*  463 3471  RW   SZ_W    -      SS */		ACCESS_NA_NA,
/*  464 3500  RW   -       DFLT   DS */		ACCESS_NA_NA,
/*  465 3501  RW   -       DFLT   SS */		ACCESS_NA_NA,
/*  466 3510  RW   -       ES     DS */		ACCESS_NA_NA,
/*  467 3511  RW   -       ES     SS */		ACCESS_NA_NA,
/*  468 3520  RW   -       CS     DS */		ACCESS_NA_NA,
/*  469 3521  RW   -       CS     SS */		ACCESS_NA_NA,
/*  470 3530  RW   -       SS     DS */		ACCESS_NA_NA,
/*  471 3531  RW   -       SS     SS */		ACCESS_NA_NA,
/*  472 3540  RW   -       DS     DS */		ACCESS_NA_NA,
/*  473 3541  RW   -       DS     SS */		ACCESS_NA_NA,
/*  474 3550  RW   -       FS     DS */		ACCESS_NA_NA,
/*  475 3551  RW   -       FS     SS */		ACCESS_NA_NA,
/*  476 3560  RW   -       GS     DS */		ACCESS_NA_NA,
/*  477 3561  RW   -       GS     SS */		ACCESS_NA_NA,
/*  478 3570  RW   -       -      DS */		ACCESS_NA_NA,
/*  479 3571  RW   -       -      SS */		ACCESS_NA_NA,
/*  480 3600  RW   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*  481 3601  RW   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*  482 3610  RW   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*  483 3611  RW   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  484 3620  RW   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  485 3621  RW   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  486 3630  RW   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  487 3631  RW   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  488 3640  RW   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  489 3641  RW   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  490 3650  RW   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  491 3651  RW   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  492 3660  RW   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  493 3661  RW   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  494 3670  RW   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  495 3671  RW   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  496 3700  RW   SZ_WD   DFLT   DS */		ACCESS_NA_NA,
/*  497 3701  RW   SZ_WD   DFLT   SS */		ACCESS_NA_NA,
/*  498 3710  RW   SZ_WD   ES     DS */		ACCESS_NA_NA,
/*  499 3711  RW   SZ_WD   ES     SS */		ACCESS_NA_NA,
/*  500 3720  RW   SZ_WD   CS     DS */		ACCESS_NA_NA,
/*  501 3721  RW   SZ_WD   CS     SS */		ACCESS_NA_NA,
/*  502 3730  RW   SZ_WD   SS     DS */		ACCESS_NA_NA,
/*  503 3731  RW   SZ_WD   SS     SS */		ACCESS_NA_NA,
/*  504 3740  RW   SZ_WD   DS     DS */		ACCESS_NA_NA,
/*  505 3741  RW   SZ_WD   DS     SS */		ACCESS_NA_NA,
/*  506 3750  RW   SZ_WD   FS     DS */		ACCESS_NA_NA,
/*  507 3751  RW   SZ_WD   FS     SS */		ACCESS_NA_NA,
/*  508 3760  RW   SZ_WD   GS     DS */		ACCESS_NA_NA,
/*  509 3761  RW   SZ_WD   GS     SS */		ACCESS_NA_NA,
/*  510 3770  RW   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  511 3771  RW   SZ_WD   -      SS */		ACCESS_NA_NA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\build_id.h ===
/*[
 *	==========================================================================
 *
 *	Name:		build_id.h
 *
 *	Author:		J. Box
 *	
 * 	create on	May 26th 1994
 *
 *	SCCS ID:	@(#)build_id.h	1.274 07/17/95
 *
 *	Purpose:	This file contains the Version ID No.s for this release
 *			of the Base.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
 *	==========================================================================
]*/

/*
 *	The build ID is of the form YMMDD and is squeezed into 16 bits in order
 *	to be able to be passed in a 16 bit intel register.
 *			S S S Y | Y Y Y M | M M M D | D D D D
 *			      12        8         4         0 
 *
 *	The top 3 bits are used to denote a 'Special' release that has deviated in
 *	some form from the official release. Lower case characters from a-g are
 *	used to denote these special releases, but are passed in the code below as
 *	integers from 0 to 7. 0 indicates official release, 1 indicates 1st special
 *	release (a), 2 indicates 2nd release (b), etc.etc.
 *
 *  WARNING WARNING WARNING
 *  Change the Numbers, but DO NOT CHANGE THE FORMAT OF THE FOLLOWING 4 LINES
 *  They are edited automatically by a build script that expects the format:-
 *	"define<space>DAY|MONTH|YEAR|SPECIAL<tab><tab>No."
 */

#define DAY		16		/* 1-31		5 bits	*/
#define MONTH		7		/* 1-12		4 bits	*/
#define YEAR		5		/* 0-9		4 bits	*/
#define SPECIAL		0		/* 0 - 7	3 bits; 1=a,2=b,3=c,4=d,5=e,6=f,7=g */

#define BUILD_ID_CODE	((DAY & 0x1f) | ((MONTH & 0xf)<<5) | ((YEAR & 0xf)<<9 ) | ((SPECIAL & 7)<<13))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\dos\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=dos
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=..\emm_mngr.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cdrom.h ===
/*
 * SoftPC V 3.0
 *
 * Title	: CDROM definitions
 *
 * Description	: Defintions for use of the CDROM
 *
 * Author	: WTG Charnell
 *
 * Notes	: 
 *
 */
 
/* SccsID[]="@(#)cdrom.h	1.11 11/20/92 Copyright Insignia Solutions Ltd."; */

/**********************************************************************
 *  Structure Definitions
 ************************/

#define PACKET	struct extended_command_buffer
struct extended_command_buffer {
    word	function;	/* Device driver command code		*/
    half_word	id;		/* Reserved - I.D. byte			*/
    half_word	drive;		/* Logical unit number of desired drive	*/
    half_word	command_mode;	/* Operational Mode, desired function	*/
    half_word	address_mode;	/* Addressing Mode, track,redbook,block */
    word	size;		/* Block size, Mode dependent operation	*/
    int		address;	/* Starting address, CDROM function	*/
    int		count;		/* bytes,word,blocks,sectors, etc. 	*/
    half_word	*buffer;	/* pointer for data transfer		*/
};

#define DRIVER_INFORMATION struct cdrom_device_driver
				/* ASCII text	 */
struct cdrom_device_driver {
    unsigned char   version[3];	/* Version number - driver	 */
    unsigned char   period;	/* Text separation		 */
    unsigned char   edition[3];	/* Edit number - file system	 */
    unsigned char   nul_string_1;   /* End of string delimiter	 */
    unsigned char   name[8];	/* Device Driver Name (type)	 */
    unsigned char   nul_string_2;   /* End of string delimiter	 */
    unsigned char   drives;	/* Number of drives installed	 */
    unsigned char   nul_string_3;   /* End of string delimiter	 */
    unsigned char   protocol;	/* Command Protocol		 */
    unsigned char   nul_string_4;   /* End of string delimiter	 */
};

#define DRIVE_STATUS struct cdrom_drive_status
struct cdrom_drive_status {
    unsigned char   unit;	/* Drive Unit Number of the CD-ROM	*/
    unsigned char   ldc0;	/* Last Drive Command - L.S.B.		*/
    unsigned char   ldc1;	/*  "     "      "                      */
    unsigned char   ldc2;	/*  "     "      "                      */
    unsigned char   ldc3;	/* Last Drive Command - M.S.B.		*/
    unsigned char   status;	/* Drive Status Byte			*/
    unsigned char   error;	/* Drive Error Byte			*/
    unsigned char   comm;	/* Drive Communication Error Code	*/
    unsigned char   sector;	/* Drive Address - sector number	*/
    unsigned char   second;	/*   "     "     - second		*/
    unsigned char   minute;	/*   "     "     - minute		*/
    unsigned char   disc_no;	/* Selected Disc Number - reserved	*/
    unsigned char   tracks;	/* Total number of tracks on disc	*/
    unsigned char   track_no;	/* Current Track - audio mode		*/
};

#define SIMPLE	struct original_command_buffer   
struct original_command_buffer {
    half_word	function;	/* Device driver command code		*/
    half_word	handle;		/* File or Volume handle		*/
    half_word	player;		/* Logical unit number of desired drive	*/
    half_word	count;		/* Number of block to read		*/
    int		address;	/* Starting address, CDROM function	*/
    half_word	*string;	/* Pointer address for driver status	*/
    half_word	*buffer;	/* Pointer address for data transfer	*/
};

#define CD_ERR_INVALID_DRIVE_NUM	0x6
#define CD_ERR_INVALID_ADDRESS		0x7
#define CD_ERR_INVALID_COUNT		0x8
#define CD_ERR_INVALID_FN_CODE		0x9
#define CD_ERR_UNCORECTABLE_DATA_ERR	0x11
#define CD_ERR_DRIVE_NOT_RESPONDING	0x12
#define CD_ERR_ADAPTER_DRIVE_ERROR	0x13
#define CD_ERR_MEDIA_CHANGED		0x14
#define CD_ERR_DRIVE_NOT_READY		0x15
#define CD_ERR_ADAPTER_ERROR		0x16
#define CD_ERR_DRIVE_REPORTED_ERROR	0x18
#define CD_ERR_ILLEGAL_DISC		0x19
#define CD_ERR_BYTES_NOT_TRANSFERRED	0x80
#define CD_ERR_FUNCTION_NOT_SUPPORTED	0x81
#define CD_ERR_COMMAND_NOT_FOR_TRACK	0x82
#define CD_ERR_DRIVE_IS_BUSY		0x83
#define CD_ERR_BUS_IS_BUSY		0x84
#define CD_ERR_DRIVER_NOT_INITIALISED	0x85
#define CD_ERR_INVALID_FN_MODE		0x86
#define CD_ERR_INVALID_ADDR_MODE	0x87
#define CD_ERR_INVALID_BL_SIZE		0x88

/*
 * The Bios Parameter Block has a variable structure dependant on the
 * command being called. The 1st 13 bytes, however, are always the same:
 *  Byte  0:	length of request header
 *  Byte  1:	Unit # for this request
 *  Byte  2:	Command Code
 *  Bytes 3&4:	Returned Status Word
 *  Bytes 5-12:	Reserved
 *
 * The driver fills in the Status Word (Bytes 3&4) to indicate success or
 * failure of operations. The status word is made up as follows:
 *  Bit 15:	Error (failure if set)
 *  Bits 12-14:	Reserved
 *  Bit  9:	Busy
 *  Bit  8:	Done
 *  Bits 7-0:	Error Code on failure
 */

/*
 * Shorthand for typical error returns in AX. The driver will copy this
 * into the Return Status word for us.
 */
#define DRIVE_NOT_READY	0x8002
#define BAD_FUNC	0x8003
#define WRITE_ERR	0x800A
#define READ_ERR	0x800B
#define GEN_ERR		0x800C
#define RESERVE_ERR	0x800D
#define FUNC_OK		0x0100	/* Done, No error, no chars waiting */

#define BUSY_BIT 	9
#define ERROR_BIT	15
#define DONE_BIT	8


/****************************************************************************
*	Original CD ROM command/function definitions
*
****************************************************************************/

#define ORIG_CD_GET_VERSION		0x10	/* Return ASCI version number      */
#define ORIG_CD_GET_ERROR_COUNT		0x11	/* Read  controller error counters */
#define ORIG_CD_CLEAR_CTRL_ERRORS	0x12	/* Clear controller error counters */
#define ORIG_CD_INIT_PLAYER		0x13	/* Initialize controller & drive nr */
#define ORIG_CD_SPIN_UP			0x14	/* Enable spindle motor		     */
#define ORIG_CD_SPIN_DOWN		0x15	/* Disable spindle motor	          */
#define ORIG_CD_CNVRT_BLK_NO		0x16	/* virtual to logical blk nr	     */
#define ORIG_CD_SEEK_ABS		0x17	/* Absolute seek to logical block # */
#define ORIG_CD_READ_ABS		0x18	/* Absolute read!		          */
#define ORIG_CD_READ_ABS_IGN		0x19	/* read, ignore data errors	     */
#define ORIG_CD_CLEAR_DRIVE_ERRORS	0x1A	/* Clear player errors		     */
#define ORIG_CD_READ_STATUS		0x1B	/* Read  player status		     */
#define ORIG_CD_READ_CHARACTERISTICS	0x1C	/* Read player characteristics	*/
#define ORIG_CD_FLUSH_BUFFER		0x1D	/* Flush cached Data buffers	     */
#define ORIG_CD_GET_LAST_STATUS		0x1E	/* Read "last" player status	     */


/****************************************************************************
;*	Extended CD ROM command/function definitions
;*
;*/

#define EXT_CD_REQUEST_DRIVER_INFO   	0x80 /* Report host adapter or driver info   */
#define EXT_CD_READ_ERR_COUNTERS	0x81 /* Report summary of error condition    */
#define EXT_CD_CLEAR_ERR_COUNTERS	0x82 /* Reset device driver error counters   */
#define EXT_CD_RESET_CDROM_DRIVE	0x83 /* Reset the specified drive            */
#define EXT_CD_CLEAR_DRIVE_ERR		0x84 /* Attempt to clear drive error cond.   */
#define EXT_CD_FORBID_MEDIA_REMOVAL	0x85 /*  Lock  drive door - CM2xx function   */
#define EXT_CD_PERMIT_MEDIA_REMOVAL	0x86 /* UnLock drive door - CM2xx function   */
#define EXT_CD_REQUEST_CHARACTERISTICS	0x87 /* Report drive characteristics         */
#define EXT_CD_REQUEST_STATUS		0x88 /* Report drive status                  */
#define EXT_CD_REQUEST_PREVIOUS_STATUS	0x89 /* Report previous status, this drive   */
#define EXT_CD_REQUEST_AUDIO_MODE	0x8A /* Report current mode - audio drive    */
#define EXT_CD_MODIFY_AUDIO_MODE	0x8B /* Change audio mode, this drive        */
#define	EXT_CD_FLUSH_DATA_BUFFER	0x8C /* Remove ( i.e. clear ) data buffer    */
#define EXT_CD_EXTRA			0x8D /* Reserved - next info type function   */
#define EXT_CD_LOGICAL_RESERVE_DRIVE	0x8E /* Reserve drive for this application   */
#define EXT_CD_LOGICAL_RELEASE_DRIVE	0x8F /* Release drive for next application   */
#define EXT_CD_REQUEST_DISC_CAPACITY	0x90 /* Report physical status - this disc   */
#define EXT_CD_REQUEST_TRACK_INFO	0x91 /* Report specific track information    */
#define EXT_CD_SPIN_UP_DISC		0x92 /* Start the drive spindle motor        */
#define EXT_CD_SPIN_DOWN_DISC		0x93 /*  Stop the drive spindle motor        */
#define EXT_CD_READ_DRIVE_DATA		0x94 /* Read Digital Data                    */
#define EXT_CD_WRITE_DATA		0x95 /* Reserved - command                   */
#define EXT_CD_SEEK_TO_ADDRESS		0x96 /* Seek to logical or physical addr.    */
#define EXT_CD_PLAY_AUDIO_TRACK	        0x97 /* Play a single audio track            */
#define EXT_CD_PAUSE_AUDIO_TRACK	0x98 /* Suspend play of audio track          */
#define EXT_CD_RESUME_AUDIO_PLAY	0x99 /* Resume play of audio track           */
#define EXT_CD_REQUEST_HEAD_LOCATION	0x9A /* Report position of optical head      */
#define EXT_CD_SET_UNIT_NUMBER		0x9B /* Set Unit Number in EEPROM	          */
#define EXT_CD_SET_SERIAL_NUMBER	0x9C /* Set Serial Number in EEPROM	     */

IMPORT void rqst_driver_info IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void read_error_counters IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void clear_error_counters IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void reset_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void clear_drive_error IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_drive_char IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_drive_status IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_last_drive_status IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_audio_mode IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void change_audio_mode IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void cd_flush_buffers IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void reserve_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void release_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_disc_capacity IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_track_info IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void spin_up_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void spin_down_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void cd_read_data IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void cd_seek IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void play_audio IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void pause_audio IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void resume_audio IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_head_location IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_org_driver_info IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void read_ignore_err IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void cd_not_supported IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_audstat IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_UPC_code IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_play_position IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_TOC_entry IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_TOC IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT LONG rqst_Volsize IPT0();
IMPORT void rqst_Audio_info IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT SHORT host_rqst_device_status IPT0();
IMPORT BOOL host_rqst_audio_status IPT0();
IMPORT void host_eject_disk IPT0();

IMPORT VOID init_cd_dvr IPT0();
IMPORT int check_for_changed_media IPT0();
IMPORT int open_cdrom IPT0();
IMPORT int close_cdrom IPT1(int, gen_fd);

IMPORT VOID setup_cds_ea IPT0();
IMPORT VOID get_cds_text IPT3(IU32, driveno, IU8 *, ptr, int, len);

IMPORT VOID term_cdrom IPT1( IU8, drive_num);
IMPORT VOID init_bcd_driver IPT0();

#if defined(GEN_DRVR)
#define MAX_DRIVER	10
#define CD_ROM_DRIVER_NUM	8
#else
#define MAX_DRIVER	1
#define CD_ROM_DRIVER_NUM	0
#endif /* GEN_DRVR */

/*
 *	Used by get_cdrom_drive().
 */
 
#ifdef	macintosh
#define UNKNOWN_DRIVE_NUMBER	('?' - 'A')
#else
#define UNKNOWN_DRIVE_NUMBER	-1
#endif	/* macintosh */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\base_def.h ===
/*
 *      Name:           base_def.h
 *
 *      Author:         Jeremy Maiden
 *
 *      Created on:     3rd November 1993
 *
 *      SccsID:         @(#)base_def.h	1.7 08/19/94
 *
 *      Purpose:        This file contains the base definitions of the Insignia
 *                      standard types and constants.
 *
 * 	Conforms to:	Version 2.1 of the Insignia C Coding Standards
 *
 *      (c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 */


/* You should use this macro wherever you have an argument to a
 * function which is unused.
 */
#ifndef UNUSED
#ifdef lint
#define UNUSED(x)	{ x; }
#else	/* !lint */
#define UNUSED(x)
#endif	/* lint */
#endif	/* UNUSED */

/*
 * Ansi extensions. See "1.5 insignia.h: macros" of coding standards....
 *
 * Note: CONST is now deprecated in favour of const, however
 * it is still in use
 */

#ifdef	ANSI
#define STRINGIFY(x)	#x
#define	CAT(x,y)	x ## y
#else	/* !ANSI */
#define STRINGIFY(x)    "x"
#define	CAT(x,y)	x y
#define	const		/* nothing */
#endif	/* ANSI */

#ifndef TRUE
#define TRUE	((IBOOL)!0)
#endif

#ifndef FALSE
#define FALSE	((IBOOL)0)
#endif

#define	PRIVATETYPE		/* documents private typedefs local to a source file */
/*
 * Insignia Standard Storage Classes
 */

#define GLOBAL                  /* Defined as nothing */
#define LOCAL   static          /* Local to the source file */
#define SAVED   static          /* For local static variables */
#define IMPORT  extern          /* To refer from another file */
#define FORWARD                 /* to refer from the same file */
#define FAST    register	/* High-speed Storage */

/*
 * Define types so that old code can be brought into the 4.0 masterpack
 */
#define ULONG	unsigned long
#define LONG	long

#define DOUBLE	double

#define VOID	void
#define	INT	int
#define	SHORT	IS16
#define	USHORT	IU16
#define TINY	IS8
#define	UTINY	IU8
#define WORD	IU16

/* types from xt.h */
#define boolean	IBOOL
#define byte	IU8
#define half_word	IU8
#define word	IU16
#define double_word	IU32
#define sys_addr	IU32
#define io_addr		IU16
#define host_addr	IU8 *
#define LIN_ADDR	IU32
#define PHY_ADDR	IU32

/*
** ANSI-independent function prototypes and definition macros.
**
** A function prototype looks like:
**
** IMPORT       USHORT  func    IPT2(UTINY, param0, CHAR *, param1);
**
** i.e. macro IPTn is used for a function with n parameters.
**
** The corresponding function definition looks like:
**
** GLOBAL       USHORT  funct   IFN2(UTINY, param0, CHAR *, param1)
** {
**      ... function body ...
** }
**
** Limitations: only parameters with declarations of the form "type name" can
** be handled. This rules out arrays (can use pointer syntax instead) and
** parameters which are pointers to functions or something similar. The previous** method of using ifdef ANSI must be used for these cases.
**
*/

#ifdef  ANSI
 
/* Function prototypes */
 
#define IPT0()                                  (void)
#define IPT1(t1, n1)                            (t1 n1)
#define IPT2(t1, n1, t2, n2)                    (t1 n1, t2 n2)
#define IPT3(t1, n1, t2, n2, t3, n3)            (t1 n1, t2 n2, t3 n3)
#define IPT4(t1, n1, t2, n2, t3, n3, t4, n4)    (t1 n1, t2 n2, t3 n3, t4 n4)
#define IPT5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5)
#define IPT6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6)
#define IPT7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7)
#define IPT8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8)
#define IPT9(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9)
#define IPT10(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10)
#define IPT11(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11)
#define IPT12(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12)
#define IPT13(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13)
#define IPT14(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13, t14 n14)
#define IPT15(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14, t15, n15) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13, t14 n14, t15 n15)
 
/* Function definitions */
 
#define IFN0()                                  (void)
#define IFN1(t1, n1)                            (t1 n1)
#define IFN2(t1, n1, t2, n2)                    (t1 n1, t2 n2)
#define IFN3(t1, n1, t2, n2, t3, n3)            (t1 n1, t2 n2, t3 n3)
#define IFN4(t1, n1, t2, n2, t3, n3, t4, n4)    (t1 n1, t2 n2, t3 n3, t4 n4)
#define IFN5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5)
#define IFN6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6)
#define IFN7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7)
#define IFN8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8)
#define IFN9(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9)
#define IFN10(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10)
#define IFN11(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11)
#define IFN12(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12)
#define IFN13(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13)
#define IFN14(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13, t14 n14)
#define IFN15(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14, t15, n15) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13, t14 n14, t15 n15)

#else   /* ANSI */
 
/* Function prototypes */
 
#define IPT0()                                                          ()
#define IPT1(t1, n1)                                                    ()
#define IPT2(t1, n1, t2, n2)                                            ()
#define IPT3(t1, n1, t2, n2, t3, n3)                                    ()
#define IPT4(t1, n1, t2, n2, t3, n3, t4, n4)                            ()
#define IPT5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5)                    ()
#define IPT6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6)            ()
#define IPT7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7)    ()
#define IPT8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        ()
#define IPT9(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9) \
        ()
#define IPT10(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10) \
        ()
#define IPT11(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11) \
        ()
#define IPT12(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12) \
        ()
#define IPT13(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13) \
        ()
#define IPT14(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14) \
        ()
#define IPT15(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14, t15, n15) \
        ()
 
/* Function definitions */
 
#define IFN0()                                  ()
#define IFN1(t1, n1)                            (n1) \
                                                t1 n1;
#define IFN2(t1, n1, t2, n2)                    (n1, n2) \
                                                t1 n1; t2 n2;
#define IFN3(t1, n1, t2, n2, t3, n3)            (n1, n2, n3) \
                                                t1 n1; t2 n2; t3 n3;
#define IFN4(t1, n1, t2, n2, t3, n3, t4, n4)    (n1, n2, n3, n4) \
                                                t1 n1; t2 n2; t3 n3; t4 n4;
#define IFN5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
                                                (n1, n2, n3, n4, n5) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5;
#define IFN6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
                                                (n1, n2, n3, n4, n5, n6) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6;
#define IFN7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
                                                (n1, n2, n3, n4, n5, n6, n7) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7;
#define IFN8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8;
#define IFN9(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8, n9)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; t9 n9;
#define IFN10(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; t9 n9;t10 n10;
#define IFN11(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9;t10 n10;t11 n11;
#define IFN12(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11, n12)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9;t10 n10;t11 n11;t12 n12;
#define IFN13(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11, n12, n13)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9; t10 n10; t11 n11; \
						t12 n12; t13 n13;
#define IFN14(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11, n12, n13, n14)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9; t10 n10; t11 n11; \
						t12 n12; t13 n13; t14 n14;
#define IFN15(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14, t15, n15) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11, n12, n13, n14, n15)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9; t10 n10; t11 n11; \
						t12 n12; t13 n13; t14 n14; \
						t15 n15;
#endif  /* ANSI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cdrom_fn.h ===
/*[
 *	Product:		SoftPC-AT Revision 3.0
 *	Name:			cdrom_fn.h
 *	Purpose:		Interface & defines used by cdrom_fn.c
 *
 *	Derived From:		next_cdrom.c, 1.5, 23/9/92, Jason Proctor
 *
 *	Sccs ID:		@(#)cdrom_fn.h	1.3 04/14/94
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/

/* CD addressing modes */
#define		kBlockAddressMode		0
#define		kRedbookAddressMode		1
#define		kTrackAddressMode		2

/* equate for special lead out track */
#define		kActualLeadOutTrack		0xaa
#define		kLeadOutTrack			100

/* values for device status
 * 0x282 => data only, read only, prefetch supported, no interleaving
 *	    only cooked reading, no audio channel manipulation, 
 *	    supports Redbook addressing, doesn't support R-W sub-channels
 */
#define		kDeviceStatus			0x282
#define		kAudioSupported			(1<<4)
#define		kNoDiskPresent			(1<<11)

/* data formats for read subchannel command */
#define		kCurrentPosDataFormat	1
#define		kMediaCatDataFormat		2
#define		kTrackStdDataFormat		3

/* bit mask for audio status bit */
#define		kAudioPlayInProgress	0x11


/* TYPEDEFS */

struct toc_info
{
	UTINY	control;
	UTINY	hour;
	UTINY	minute;
	UTINY	sec;
	UTINY	frame;
};

/* entire table of contents */
/* naudio/ndata hacked out by Jase as we don't need them */
struct toc_all
{
	UTINY		firsttrack;
	UTINY		lasttrack;
	struct toc_info	info[101];
};

typedef struct
{
	INT				cdDeviceFD;
	IUM32			cdAddressMode;
	IUM32			cdCommandMode;
	IUM32			cdBlockSize;
	IUM32			cdBlockAddress;
	IUM32			cdTransmitCount;
	IUM32			cdReceiveCount;
	struct toc_all	cdTOC;
	BOOL			cdChangedMedia;
	BOOL			cdOpen;
	BOOL			cdReadTOC;
	UTINY			*cdBuffer;
	UTINY			cdTempBuffer [256];
	CHAR			cdDeviceName [MAXPATHLEN];

} CDROMGlobalRec;

/* conveniently small MSF record */
typedef struct
{
	UTINY				msfMinutes;
	UTINY				msfSeconds;
	UTINY				msfFrames;

} MSFRec;

/* utility routines */

extern void		CreateMSF IPT2 (MSFRec *, startMSF, MSFRec *, endMSF);
extern IUM32		Redbook2HighSierra IPT1 (UTINY *, address);
extern void		HighSierra2Redbook IPT2 (IUM32, block, MSFRec *, msf);


/* host interface stuff */

extern void		host_set_cd_retn_stat IPT0 ();
extern void		host_cd_media_changed IPT0 ();

extern int		host_scsi_test_unit_ready IPT0 ();
extern int		host_scsi_seek IPT0 ();
extern int		host_scsi_read IPT0 ();
extern int		host_scsi_play_audio IPT0 ();
extern int		host_scsi_pause_resume_audio IPT1 (BOOL, pause);
extern int		host_scsi_read_UPC IPT0 ();
extern int		host_scsi_read_position IPT1 (BOOL, full);
extern int		host_scsi_audio_status IPT0 ();
extern int		host_scsi_playback_status IPT0 ();
extern int		host_scsi_set_blocksize IPT0 ();
extern int		host_scsi_read_TOC IPT0 ();

/* IMPORTED DATA */

/* imported from base/dos/cdrom.c */
extern BOOL				bl_red_book;
extern int				cd_retn_stat;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cg.h ===
#if defined(NEC_98)
#define         CG_WRITE_SECOND         0xA1
#define         CG_WRITE_FIRST          0xA3
#define         CG_WRITE_COUNTER        0xA5
#define         CG_WRITE_PATTERN        0xA9
#define         CG_READ_PATTERN         0xA9

#define         ANK_CHAR_START          0x0000
#define         ANK_CHAR_END            0x00FF
#define         JIS1_CHAR_START         0x0121
#define         JIS1_CHAR_END           0x077E
#define         HALF_CHAR_START         0x0921
#define         HALF_CHAR_END           0x0B7E
#define         NEC_CHAR_START          0x0C21
#define         NEC_CHAR_END            0x0D7E
#define         JIS1_KANJ_START         0x1021
#define         JIS1_KANJ_END           0x2F7E
#define         JIS2_KANJ_START         0x3021
#define         JIS2_KANJ_END           0x537E
#define         USER_GAIJ_START         0x5601
#define         USER_GAIJ_END           0x57FF
#define         LARG_KANJ_START         0x5921
#define         LARG_KANJ_END           0x5C7E

extern  BOOL    HIRESO_MODE;

//#define               PATTERN_BYTE_H  72
#define         PATTERN_BYTE_N  32

//#define               PATTERN_BYTE    (HIRESO_MODE ? PATTERN_BYTE_H : PATTERN_BYTE_N)
#define         PATTERN_BYTE            (PATTERN_BYTE_N)

//#define               CG_WINDOW_OFF_H         (0xE4000L)
#define         CG_WINDOW_OFF_N         (0xA4000L)

//#define               CG_WINDOW_OFF   (HIRESO_MODE ? CG_WINDOW_OFF_H : CG_WINDOW_OFF_N)
#define         CG_WINDOW_OFF           (CG_WINDOW_OFF_N)

#define         CG_WINDOW_START         (CG_WINDOW_OFF)
#define         CG_WINDOW_END           (CG_WINDOW_OFF+0x00FFFL)

typedef struct
{
                unsigned short  code;
                unsigned char   pattern[PATTERN_BYTE];
} GAIJ_GLOBS;

extern GAIJ_GLOBS *gaijglobs;

typedef struct
{
                unsigned short  code;
                unsigned char   counter;
                unsigned char   *cgwindow_ptr;
} CG_GLOBS;

extern CG_GLOBS cgglobs;

extern BOOL half_access;

IMPORT void cg_init IPT0();
IMPORT void cg_inb IPT2(io_addr, port, half_word *, value);
IMPORT void cg_outb IPT2(io_addr, port, half_word , value);
IMPORT void cg_post IPT0();

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\bios.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: BIOS definitions
 *
 * Description	: Defintions for users of the BIOS
 *
 * Author	: Henry Nash
 *
 * Notes	: This is a copy of bios.h from henry/kernel taken on
 *		  17 dec 86. Several lines have been added to support
 *		  the hard disk bios (marked HD-dr). See also bios.c.
 *
 * Mods: (r2.21): Added an external declaration of rom_basic().
 */

/* SccsID[]="@(#)bios.h	1.47 06/28/95 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * The following define the BOP call numbers for the BIOS functions.
 */

#define BIOS_RESET		0x0
#define BIOS_DUMMY_INT		0x1
#define BIOS_UNEXP_INT		0x2
#define BIOS_DRIVER_INCOMPAT	0x7
#define BIOS_TIMER_INT		0x8
#define BIOS_KB_INT		0x9
#define BIOS_DISK_INT		0xD	
#define BIOS_DISKETTE_INT	0xE
#define BIOS_PRINT_SCREEN	0x5
#define BIOS_VIDEO_IO		0x10
#define BIOS_EQUIPMENT		0x11
#define BIOS_MEMORY_SIZE	0x12
#define BIOS_DISK_IO		0x13
#define BIOS_RS232_IO		0x14
#define BIOS_CASSETTE_IO	0x15
#define BIOS_KEYBOARD_IO	0x16
#define BIOS_PRINTER_IO		0x17
#define BIOS_BASIC		0x18
#define BIOS_BOOT_STRAP		0x19
#define BIOS_TIME_OF_DAY	0x1A
#define BIOS_KEYBOARD_BREAK	0x1B
#define BIOS_USER_TIMER_INT	0x1C
#define BIOS_EXTEND_CHAR	0x1F
#define BIOS_DISKETTE_IO	0x40
#define EGA_FONT_INT		0x43	/* Pointer for the EGA graphics font */

/*
 * Private bootstrap functions
 */

#define BIOS_BOOTSTRAP_1	0x90
#define BIOS_BOOTSTRAP_2	0x91
#define BIOS_BOOTSTRAP_3	0x92

/*
 * Private diskette functions
 */

#define BIOS_FL_OPERATION_1	0xA0
#define BIOS_FL_OPERATION_2	0xA1
#define BIOS_FL_OPERATION_3	0xA2
#define BIOS_FL_RESET_2		0xA3

/*
 * Private hard disk function
 */

#define BIOS_HDA_COMMAND_CHECK	0xB0

/*
 * Mouse driver functions
 */

#define BIOS_MOUSE_INSTALL1	0xB8
#define BIOS_MOUSE_INSTALL2	0xB9
#define BIOS_MOUSE_INT1	0xBA
#define BIOS_MOUSE_INT2		0xBB
#define BIOS_MOUSE_IO_LANGUAGE	0xBC
#define BIOS_MOUSE_IO_INTERRUPT	0xBD
#define BIOS_MOUSE_VIDEO_IO	0xBE

/*
 * Get date function
 */

#define BIOS_GETDATE		0xBF

/*
 * Re-entrant CPU return function
 */

#define BIOS_CPU_RETURN		0xFE

/*
 * The following defines the structure of the Bios internal storage area.
 */

#define BIOS_VAR_SEGMENT	0x40
#define BIOS_VAR_START		((sys_addr)BIOS_VAR_SEGMENT * 16L)

/*
 * Address of memory size bios word variable.
 */

#define MEMORY_VAR            (BIOS_VAR_START + 0x13)

/*
 * The Bios FDC result data storage area
 */

#define BIOS_FDC_STATUS_BLOCK	BIOS_VAR_START + 0x42

/*
 * The BIOS hard disk data area. These variables are updated to their correct
 * values before every exit from disk_io.c/disk.c to the cpu.
*/

#define CMD_BLOCK	BIOS_VAR_START + 0x42

/*
 * The Bios Reset Flag
 */

#define RESET_FLAG	BIOS_VAR_START + 0x72

#define DISK_STATUS	BIOS_VAR_START + 0x74
#define HF_NUM		BIOS_VAR_START + 0x75
#define CONTROL_BYTE	BIOS_VAR_START + 0x76
#define PORT_OFF	BIOS_VAR_START + 0x77

/*
 * Bios Buffer space
 */

typedef union {
                 word wd;
                 struct {
                          half_word scan;
                          half_word ch;
                        } byte;
               } KEY_OCCURRENCE;

#define BIOS_KB_BUFFER_START    (BIOS_VAR_START + 0x80)
#define BIOS_KB_BUFFER_END      (BIOS_VAR_START + 0x82)
#define BIOS_KB_BUFFER_HEAD     (BIOS_VAR_START + 0x1a)
#define BIOS_KB_BUFFER_TAIL     (BIOS_VAR_START + 0x1c)
#define BIOS_KB_BUFFER          0x1e
#define BIOS_KB_BUFFER_SIZE     16

#define BIOS_VIRTUALISING_BYTE     (BIOS_VAR_START + 0xAC)

#define SOFT_FLAG	0x1234 		/* value indicating a soft reset */

/*
 * The number of diskettes supported by the Bios
 */

#define MAX_DISKETTES	4


#define	MODEL_BYTE		0xfc	/* system model byte		*/
#define SUB_MODEL_BYTE		02	/* system sub model type byte	*/
#define BIOS_LEVEL		0	/* BIOS revision level		*/

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern void (*BIOS[]) IPT0();

#ifndef bop
#define bop(n) (*BIOS[n])()
#endif /* bop */

#ifdef PTY
extern void com_bop_pty IPT0();
#endif

#ifdef GEN_DRVR
extern void gen_driver_io IPT0();
#endif

#ifdef LIM
extern void emm_init IPT0();
extern void emm_io IPT0();
extern void return_from_call IPT0();
#endif

#ifdef SUSPEND
extern void send_script IPT0();
#endif

#ifdef CDROM
extern void cdrom_ord_fns IPT0();
extern void cdrom_ext_fns IPT0();
extern void bcdrom_io IPT0();
#endif /* CDROM */

extern void worm_init IPT0();
extern void worm_io IPT0();

extern void cmd_install IPT0();
extern void cmd_load IPT0();

#ifdef DPMI
extern void DPMI_2F IPT0();
extern void DPMI_31 IPT0();
extern void DPMI_general IPT0();
extern void DPMI_int IPT0();
extern void DPMI_r0_int IPT0();
extern void DPMI_exc IPT0();
extern void DPMI_4B IPT0();
#endif

extern void reset IPT0();
extern void illegal_bop IPT0();
extern void illegal_op_int IPT0();
extern void illegal_dvr_bop IPT0();
extern void video_io IPT0();
extern void equipment IPT0();
extern void memory_size IPT0();
extern void diskette_io IPT0();
extern void diskette_int IPT0();
extern void disk_int IPT0();
extern void not_supported IPT0();
extern void rom_basic IPT0();
extern void keyboard_io IPT0();
extern void keyboard_int IPT0();
extern void printer_io IPT0();
extern void bootstrap IPT0();
extern void time_of_day IPT0();
extern void kb_idle_poll IPT0();
extern void time_int IPT0();
extern void disk_io IPT0();
extern void print_screen IPT0();
extern void rs232_io IPT0();
extern void dummy_int IPT0();
extern void unexpected_int IPT0();
extern void Get_build_id IPT0();

#ifdef WIN_VTD
extern void VtdTickSync IPT0();
#endif /* WIN_VTD */

#ifdef EGG
extern void ega_video_io IPT0();
#endif

extern void re_direct IPT0();
extern void D11_int IPT0();
extern void int_287 IPT0();

extern void mouse_install1 IPT0();
extern void mouse_install2 IPT0();
extern void mouse_int1 IPT0();
extern void mouse_int2 IPT0();
extern void mouse_io_interrupt IPT0();
extern void mouse_io_language IPT0();
extern void mouse_video_io IPT0();
extern void mouse_EM_callback IPT0();

extern void host_mouse_install1 IPT0();
extern void host_mouse_install2 IPT0();

extern void time_of_day_init IPT0();
extern void keyboard_init IPT0();

extern void cassette_io IPT0();

extern void fl_operation1 IPT0();
extern void fl_operation2 IPT0();
extern void fl_operation3 IPT0();
extern void fl_reset2 IPT0();
extern void fl_dummy IPT0();

extern void hda_command_check IPT0();	/* HD-dr */

extern void host_unsimulate IPT0();

extern void bootstrap1 IPT0();
extern void bootstrap2 IPT0();
extern void bootstrap3 IPT0();

#ifdef NOVELL
extern void DriverInitialize IPT0();
extern void DriverReadPacket IPT0();
extern void DriverSendPacket IPT0();
extern void DriverMulticastChange IPT0();
extern void DriverCloseSocket IPT0();
extern void DriverReset IPT0();
extern void DriverShutdown IPT0();
extern void DriverAddProtocol IPT0();
extern void DriverChangePromiscuous IPT0() ;
extern void DriverOpenSocket IPT0() ;
extern void DriverCloseSocket IPT0() ;
#ifdef NOVELL_CFM
extern void DriverCheckForMore IPT0() ;
#endif
#ifdef V4CLIENT
extern void DriverChangeIntStatus IPT0() ;
#endif	/* V4CLIENT */
#endif

#ifdef	MSWDVR
extern void ms_windows IPT0();
extern void msw_mouse IPT0();
extern void msw_copy IPT0();
extern void msw_copyInit IPT0();
extern void msw_keybd IPT0();
#endif

#ifdef	NOVELL_IPX
extern void IPXResInit  IPT0();
extern void IPXResEntry  IPT0();
extern void IPXResInterrupt  IPT0();
#endif

#ifdef	NOVELL_TCPIP
extern void TCPResInit  IPT0();
extern void TCPResEntry  IPT0();
#endif

#ifdef WINSOCK
extern void ISWSEntry IPT0();
#endif /* WINSOCK */

#ifdef SWINAPI
extern void User_call IPT0();
extern void Gdi_call IPT0();
extern void Swinapi_bop IPT0();
#endif /* SWINAPI */

#if	defined(SOFTWIN_API) || defined(SWIN_HFX)
extern void SoftWindowsInit IPT0();
extern void SoftWindowsTerm IPT0();
#endif	/* SOFTWIN_API or SWIN_HFX */

#if	defined(SOFTWIN_API)
extern void SoftWindowsApi IPT0();
#endif	/* SOFTWIN_API */

#ifdef SWIN_HAW
extern void msw_sound IPT0();
#endif	/* SWIN_HAW */

#ifdef ANSI
extern void host_reset(void);
#ifndef NTVDM
extern void reboot(void);
#endif /* ! NTVDM */
extern void display_string(char *);
extern void clear_string(void);
#else
extern void host_reset IPT0();
#ifndef NTVDM
extern void reboot IPT0();
#endif /* ! NTVDM */
extern void display_string IPT0();
extern void clear_string IPT0();
#endif /* ANSI */

#ifdef ANSI
extern void smeg_collect_data(void);
extern void smeg_freeze_data(void);
#else
extern void smeg_collect_data IPT0();
extern void smeg_freeze_data IPT0();
#endif /* ANSI */

extern void softpc_version IPT0();

#ifdef NTVDM
/* MS bop stubs */
extern void MS_bop_0(void), MS_bop_1(void), MS_bop_2(void);
extern void MS_bop_3(void), MS_bop_4(void), MS_bop_5(void);
extern void MS_bop_6(void), MS_bop_7(void), MS_bop_8(void);
extern void MS_bop_9(void), MS_bop_A(void), MS_bop_B(void);
extern void MS_bop_C(void), MS_bop_D(void), MS_bop_E(void);
extern void MS_bop_F(void);
extern void switch_to_real_mode(void);
#ifdef JAPAN
extern void MS_DosV_bop(void);
#elif defined(KOREA) // JAPAN
extern void MS_HDos_bop(void);
#endif // KOREA
#endif	/* NTVDM */

#ifdef GISP_CPU
extern void hg_bop_handler IPT0();
#endif	/* GISP_CPU */

#ifdef HFX
extern void test_for_us IPT0();
#endif /* HFX */

#ifdef DOS_APP_LIC
extern void DOS_AppLicense IPT0();
#endif

IMPORT int soft_reset;

#if	defined(SPC386) && defined(WDCTRL_BOP)
extern void wdctrl_bop IPT0();
#endif	/* SPC386 && WDCTRL_BOP */

#if defined(NEC_98)
//
// BIOS common area define for PC-9800
//

#define BIOS_NEC98_VAR_SEGMENT      0x0
#define BIOS_NEC98_VAR_START        ((sys_addr)BIOS_VAR_SEGMENT * 16L)

#define BIOS_NEC98_BIOS_FLAG2       0x0400
#define BIOS_NEC98_EXPMMSZ          0x0401
#define BIOS_NEC98_SYS_SEL          0x0402
#define BIOS_NEC98_WIN_386          0x0403
#define BIOS_NEC98_USER_SP          0x0404
#define BIOS_NEC98_USER_SS          0x0406
#define BIOS_NEC98_KB_SHIFT_COD     0x0408
#define BIOS_NEC98_KB_BUFFER_ADR    0x0410
#define BIOS_NEC98_KB_ENTRY_TBL_ADR 0x0414
#define BIOS_NEC98_KB_INT_ADR       0x0418
#define BIOS_NEC98_PR_TIME          0x041C
#define BIOS_NEC98_VD_PRT           0x041E
#define BIOS_NEC98_VD_NUL           0x0423
#define BIOS_NEC98_VD_REMAIN_SEC    0x0424
#define BIOS_NEC98_VD_REMAIN_LEN    0x0426
#define BIOS_NEC98_VD_DATA_OFF      0x0428
#define BIOS_NEC98_VDISK_EQUIP      0x042A
#define BIOS_NEC98_BRANCH_INT       0x042B
#define BIOS_NEC98_BRANCH_WORK      0x042C
#define BIOS_NEC98_VD_BOOT_WORK     0x0430
#define BIOS_NEC98_VD_ADD           0x0440
#define BIOS_NEC98_CAL_ROOT_LST     0x0444
#define BIOS_NEC98_CAL_BEEP_TIME    0x0448
#define BIOS_NEC98_CAL_TONE         0x044A
#define BIOS_NEC98_CAL_USER_OFF     0x044C
#define BIOS_NEC98_CAL_USER_SEG     0x044E
#define BIOS_NEC98_CRT_FONT         0x0450
#define BIOS_NEC98_CRT_P1           0x0452
#define BIOS_NEC98_CRT_P2           0x0453
#define BIOS_NEC98_CRT_P3           0x0454
#define BIOS_NEC98_MODE_CONTROL     0x0455
#define BIOS_NEC98_IN_BIOS          0x0456
#define BIOS_NEC98_AT_SWITCH        0x0457
#define BIOS_NEC98_BIOS_FLAG5       0x0458
#define BIOS_NEC98_CR_EXT_STS       0x0459
#define BIOS_NEC98_BIOS_FLAG6       0x045A
#define BIOS_NEC98_BIOS_FLAG7       0x045B
#define BIOS_NEC98_BIOS_FLAG8       0x045C
#define BIOS_NEC98_DISK_INF         0x0460
#define BIOS_NEC98_BIOS_FLAG1       0x0480
#define BIOS_NEC98_BIOS_FLAG3       0x0481
#define BIOS_NEC98_DISK_EQUIPS      0x0482
#define BIOS_NEC98_SCSI_WORK        0x0483
#define BIOS_NEC98_BIOS_FLAG4       0x0484
#define BIOS_NEC98_F2HD_TIME        0x0485
#define BIOS_NEC98_CPU_STEP         0x0486
#define BIOS_NEC98_RDISK_EQUIP      0x0488
#define BIOS_NEC98_RDISK_EXIT       0x0489
#define BIOS_NEC98_RDISK_STATUS     0x048E
#define BIOS_NEC98_OMNI_FLAG        0x048F
#define BIOS_NEC98_BEEP_TONE        0x0490
#define BIOS_NEC98_DISK_RESET       0x0492
#define BIOS_NEC98_F2HD_MODE        0x0493
#define BIOS_NEC98_DISK_EQUIP2      0x0494
#define BIOS_NEC98_GRAPH_CHG        0x0495
#define BIOS_NEC98_GRAPH_TAI        0x0496
#define BIOS_NEC98_OMNI_INTB1       0x049A
#define BIOS_NEC98_OMNI_B1OF        0x049C
#define BIOS_NEC98_OMNI_B2SE        0x049E
#define BIOS_NEC98_OMNI_INT1B       0x04A0
#define BIOS_NEC98_OMNI_1BOF        0x04A2
#define BIOS_NEC98_OMNI_1BSE        0x04A4
#define BIOS_NEC98_OMNI_INT1A       0x04A6
#define BIOS_NEC98_OMNI_1AOF        0x04A8
#define BIOS_NEC98_OMNI_1ASE        0x04AA
#define BIOS_NEC98_XROM_PTR         0x04AC
#define BIOS_NEC98_DISK_XROM        0x04B0
#define BIOS_NEC98_XROM_ID          0x04C0
#define BIOS_NEC98_ROM_XCHG         0x04F8
#define BIOS_NEC98_ROM_OFS          0x04FA
#define BIOS_NEC98_ROM_SEG          0x04FC
#define BIOS_NEC98_SCLK_USER        0x04FE
#define BIOS_NEC98_BIOS_FLAG        0x0500
#define BIOS_NEC98_KB_BUF           0x0502
#define BIOS_NEC98_KB_KEY_BUFFER    0x0502
#define BIOS_NEC98_KB_SHFT_TBL      0x0522
#define BIOS_NEC98_KB_BUFFER_SIZ    0x0522
#define BIOS_NEC98_KB_BUF_HEAD      0x0524
#define BIOS_NEC98_KB_HEAD_POINTER  0x0524
#define BIOS_NEC98_KB_BUF_TAIL      0x0526
#define BIOS_NEC98_KB_TAIL_POINTER  0x0526
#define BIOS_NEC98_KB_COUNT         0x0528
#define BIOS_NEC98_KB_BUFFER_COUNTER        0x0528
#define BIOS_NEC98_KB_RETRY         0x0529
#define BIOS_NEC98_KB_RETRY_COUNTER 0x0529
#define BIOS_NEC98_KB_KY_STS        0x052A
#define BIOS_NEC98_KB_KEY_STS_TBL   0x052A
#define BIOS_NEC98_KB_SHFT_STS      0x053A
#define BIOS_NEC98_KB_SHIFT_STS     0x053A
#define BIOS_NEC98_CR_RASTER        0x053B
#define BIOS_NEC98_CRT_RASTER       0x053B
#define BIOS_NEC98_CR_STS_FLAG      0x053C
#define BIOS_NEC98_CR_CNT           0x053D
#define BIOS_NEC98_CRT_CNT          0x053D
#define BIOS_NEC98_CR_OFST          0x053E
#define BIOS_NEC98_CRT_PRM_OFST     0x053E
#define BIOS_NEC98_CR_SEG_ADR       0x0540
#define BIOS_NEC98_CRT_PRM_SEG      0x0540
#define BIOS_NEC98_CR_V_INT_OFST    0x0542
#define BIOS_NEC98_CRTV_OFST        0x0542
#define BIOS_NEC98_CR_V_INT_SEG     0x0544
#define BIOS_NEC98_CRTV_SEG         0x0544
#define BIOS_NEC98_CR_FONT          0x0546
#define BIOS_NEC98_CRT_FLAG         0x0546
#define BIOS_NEC98_CR_WINDW_NO      0x0547
#define BIOS_NEC98_CRT_W_NO         0x0547
#define BIOS_NEC98_CR_W_VRAMADR     0x0548
#define BIOS_NEC98_CRT_W_ADR        0x0548
#define BIOS_NEC98_CR_W_RASTER      0x054A
#define BIOS_NEC98_CRT_W_RASTER     0x054A
#define BIOS_NEC98_PRXCRT           0x054C
#define BIOS_NEC98_PRXDUPD          0x054D
#define BIOS_NEC98_PRXGCPTN         0x054E
#define BIOS_NEC98_PRXGLS           0x054E
#define BIOS_NEC98_RS_OFST_ADR      0x0556
#define BIOS_NEC98_RS_CH0_OFST      0x0556
#define BIOS_NEC98_RS_SEG_ADR       0x0558
#define BIOS_NEC98_RS_CH0_SEG       0x0558
#define BIOS_NEC98_RS_SIFT          0x055A
#define BIOS_NEC98_RS_S_FLAG        0x055B
#define BIOS_NEC98_DISK_EQUIP       0x055C
#define BIOS_NEC98_DISK_INT         0x055E
#define BIOS_NEC98_DISK_TYPE        0x0560
#define BIOS_NEC98_DISK_MODE        0x0561
#define BIOS_NEC98_DISK_TIME        0x0562
#define BIOS_NEC98_DISK_RESULT      0x0564
#define BIOS_NEC98_DISK_BOOT        0x0584
#define BIOS_NEC98_DISK_STATUS      0x0585
#define BIOS_NEC98_DISK_SENSE       0x0586
#define BIOS_NEC98_CA_TIM_CNT       0x058A
#define BIOS_NEC98_DISK_WORK        0x058C
#define BIOS_NEC98_DISK_SEG         0x058E
#define BIOS_NEC98_HDSK_MOD2        0x0590
#define BIOS_NEC98_DMA_ALLOC_TBL    0x0591
#define BIOS_NEC98_NMI_STATUS1      0x0592
#define BIOS_NEC98_NMI_STATUS2      0x0593
#define BIOS_NEC98_EXPMMSZ2         0x0594
#define BIOS_NEC98_SLOW_GEAR        0x0596
#define BIOS_NEC98_PRXCRT2          0x0597
#define BIOS_NEC98_AT_TIME          0x0598
#define BIOS_NEC98_AT_MOFF          0x059A
#define BIOS_NEC98_RDISK_BANK       0x059C
#define BIOS_NEC98_CTRL_FLAG        0x059E
#define BIOS_NEC98_SCLK_COUNT       0x05A0
#define BIOS_NEC98_SAVE_MODE        0x05A1
#define BIOS_NEC98_SAVE_COUNT       0x05A2
#define BIOS_NEC98_FD_READY_STS     0x05A4
#define BIOS_NEC98_DISK_EQUIPS2     0x05A5
#define BIOS_NEC98_CARD_STATUS      0x05A6
#define BIOS_NEC98_CARD_STATUS2     0x05A7
#define BIOS_NEC98_CARD_EQUIP       0x05A8
#define BIOS_NEC98_ASP_FLAG         0x05BD
#define BIOS_NEC98_ASP_SLOT         0x05BE
#define BIOS_NEC98_BASIC_DIPSW      0x05C0
#define BIOS_NEC98_RS_D_FLAG        0x05C1
#define BIOS_NEC98_GPIBWORK         0x05C2
#define BIOS_NEC98_KB_CODE          0x05C6
#define BIOS_NEC98_F2DD_MODE        0x05CA
#define BIOS_NEC98_F2DD_COUNT       0x05CB
#define BIOS_NEC98_F2DD_POINTER     0x05CC
#define BIOS_NEC98_F2DD_RESULT      0x05D0
#define BIOS_NEC98_MUSIC_WORK       0x05E0
#define BIOS_NEC98_V_VOL_TYPE       0x05E4
#define BIOS_NEC98_OMNI_SERVER      0x05E6
#define BIOS_NEC98_OMNI_STATION     0x05E7
#define BIOS_NEC98_DISK_PRM0        0x05E8
#define BIOS_NEC98_DISK_PRM1        0x05EC
#define BIOS_NEC98_RS_CH1_OFST      0x05F0
#define BIOS_NEC98_RS_CH1_SEG       0x05F2
#define BIOS_NEC98_RS_CH2_OFST      0x05F4
#define BIOS_NEC98_RS_CH2_SEG       0x05F6
#define BIOS_NEC98_F2HD_POINTER     0x05F8
#define BIOS_NEC98_MOUSEW           0x05FC
#define BIOS_NEC98_BASIC_LDSR       0x05FE

extern  BOOL HIRESO_MODE;
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cga.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Colour Graphics Adaptor declarations
 *
 * Description	: Definitions for users of the CGA
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)cga.h	1.5 05/15/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

#ifdef HUNTER
#    define MC6845_REGS   18        /* No. of registers in a MC6845 chip     */
#endif


#ifdef BIT_ORDER1
typedef union                       /* Template for character attributes     */
{
    half_word all;
    struct 
    {
        HALF_WORD_BIT_FIELD blinking  :1;   /* Blinking attribute                    */
        HALF_WORD_BIT_FIELD background:3;   /* Background colour R,G,B               */
        HALF_WORD_BIT_FIELD bold      :1;   /* Intensity bit                         */
        HALF_WORD_BIT_FIELD foreground:3;   /* Foreground colour R,G,B               */
    } bits;
    struct 
    {
        HALF_WORD_BIT_FIELD background_and_blink:4;     
        HALF_WORD_BIT_FIELD foreground_and_bold :4;
    } plane;
} ATTRIBUTE;
#endif

#ifdef BIT_ORDER2
typedef union                       /* Template for character attributes     */
{
    half_word all;
    struct 
    {
        HALF_WORD_BIT_FIELD foreground:3;   /* Foreground colour R,G,B               */
        HALF_WORD_BIT_FIELD bold      :1;   /* Intensity bit                         */
        HALF_WORD_BIT_FIELD background:3;   /* Background colour R,G,B               */
        HALF_WORD_BIT_FIELD blinking  :1;   /* Blinking attribute                    */
    } bits;
    struct 
    {
        HALF_WORD_BIT_FIELD foreground_and_bold :4;
        HALF_WORD_BIT_FIELD background_and_blink:4;     
    } plane;
} ATTRIBUTE;
#endif

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef HUNTER
    extern half_word MC6845[];        /* The MC6845 data register values */
    extern half_word mode_reg;        /* MC6845 mode control register value */
#endif

extern void cga_init	IPT0();
extern void cga_term	IPT0();
extern void cga_inb	IPT2(io_addr, address, half_word *, value);
extern void cga_outb	IPT2(io_addr, address, half_word, value);

typedef	struct {
	int	mode;
	int	resolution;
	int	color_select;
	int	colormask;
} CGA_GLOBS;

extern	CGA_GLOBS	CGA_GLOBALS;

#define	set_cga_mode(val)		CGA_GLOBALS.mode = (val)
#define	set_cga_resolution(val)		CGA_GLOBALS.resolution = (val)
#define	set_cga_color_select(val)	CGA_GLOBALS.color_select = (val)
#define	set_cga_colormask(val)		CGA_GLOBALS.colormask = (val)

#define	get_cga_mode()			(CGA_GLOBALS.mode)
#define	get_cga_resolution()		(CGA_GLOBALS.resolution)
#define	get_cga_color_select()		(CGA_GLOBALS.color_select)
#define	get_cga_colormask()		(CGA_GLOBALS.colormask)

#if !defined(EGG) && !defined(A_VID) && !defined(C_VID)
/* This structure is defined solely so that we don't have to ifdef every
** reference to VGLOBS->dirty_flag and VGLOBS->screen_ptr in the base/host
** for a CGA-only build.
*/
typedef	struct
{
	ULONG dirty_flag;
	UTINY *screen_ptr;
} CGA_ONLY_GLOBS;

IMPORT CGA_ONLY_GLOBS *VGLOBS;
#endif	/* !EGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\ckmalloc.h ===
/*[
 *      Product:        SoftPC-AT Revision 3.0
 *
 *      Name:           ckmalloc.h
 *
 *      Author:         Jerry Sexton
 *
 *      Created On:     15th April 1991
 *
 *      Sccs ID:        @(#)ckmalloc.h	1.4 08/10/92
 *
 *      Purpose:        This header file defines a macro which programs can
 *                      use to exit cleanly if malloc fails.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
]*/

#include "error.h"
#include MemoryH

/*
 * Allocate `nitems' items of type `type' to `var' and exit cleanly on failure.
 */
#define check_malloc(var, nitems, type) \
        while ((var = (type *) host_malloc((nitems) * sizeof(type))) == NULL) \
        { \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        }

/*
 * Allocate `nitems' items of type `type' to `var' and exit cleanly on failure.
 * Similar to above, but memory is guaranteed to be of value zero.
 */
#define check_calloc(var, nitems, type) \
        while ((var = (type *) host_calloc((nitems), sizeof(type))) == NULL) \
        { \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        }

/*
 * Re-allocate a previously allocated pointer 'in_var', of type 'type', to a pointer
 * 'out_var' to 'nitems' of type 'type'
 */
#define check_realloc(out_var, in_var, nitems, type) \
        while ((out_var = (type *) host_realloc(in_var, (nitems) * sizeof(type))) == NULL) \
        { \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cmosbios.h ===
/* @(#)cmosbios.h	1.3 08/10/92 Copyright Insignia Solutions Ltd.
	
FILE NAME	: cmosbios.h

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: OCT '88


=========================================================================

AMMENDMENTS	:

=========================================================================
*/
extern void set_tod();
extern half_word cmos_read();
extern void cmos_write();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cmos.h ===
/*
 * SoftPC-AT Revision 2.0
 *
 * Title	: IBM PC-AT CMOS and Real-Time Clock declarations
 *
 * Description	: This module contains declarations that are used in
 *		  accessing the Motorola MC146818 chip.
 *
 * Author(s)	: Leigh Dworkin.
 *
 * Notes	: For a detailed description of the IBM CMOS RAM
 *		  and the Motorola MC146818A chip refer to the following 
 *		  documents:
 *
 *		  - IBM PC/AT Technical Reference Manual
 *				(Section 1-59 )
 *		  - Motorola Semiconductors Handbook
 *				(Section MC146818A)
 *
 */

/* SccsID[]="@(#)cmos.h	1.9 04/24/95 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */
/* define the CMOS ports */

#define CMOS_PORT_START 0x70
#define CMOS_PORT_END 0x7f

/* The following definitions are as in the AT BIOS Pg. 5-24 */
#define CMOS_PORT 0x70
#define CMOS_DATA 0x71
#define NMI	0x80

/* define the internal cmos adresses */
/* Real Time Clock */
#define CMOS_SECONDS 0x0
#define CMOS_SEC_ALARM 0x1
#define CMOS_MINUTES	0x2
#define CMOS_MIN_ALARM	0x3
#define CMOS_HOURS	0x4
#define CMOS_HR_ALARM	0x5
#define CMOS_DAY_WEEK	0x6
#define CMOS_DAY_MONTH	0x7
#define CMOS_MONTH	0x8
#define CMOS_YEAR	0x9
#define CMOS_REG_A	0xa
#define CMOS_REG_B	0xb
#define CMOS_REG_C	0xc
#define CMOS_REG_D	0xd


/* General purpose CMOS */
#define CMOS_DIAG	0xe
#define CMOS_SHUT_DOWN	0xf
#define CMOS_DISKETTE	0x10

#define CMOS_DISK	0x12

#define CMOS_EQUIP	0x14
#define CMOS_B_M_S_LO	0x15
#define CMOS_B_M_S_HI	0x16
#define CMOS_E_M_S_LO	0x17
#define CMOS_E_M_S_HI	0x18
#define CMOS_DISK_1	0x19
#define CMOS_DISK_2	0x1a

#define CMOS_CKSUM_HI	0x2e
#define CMOS_CKSUM_LO	0x2f
#define CMOS_U_M_S_LO	0x30
#define CMOS_U_M_S_HI	0x31
#define CMOS_CENTURY	0x32
#define CMOS_INFO128	0x33

/* define bits in individual bytes */
/* register D */
#define VRT	0x80
#define REG_D_INIT	(VRT)

/* register C */
#define C_IRQF	0x80
#define C_PF	0x40
#define C_AF	0x20
#define C_UF	0x10
#define C_CLEAR 0x00
#define REG_C_INIT	(C_CLEAR)

/* register B */
#define SET	0x80
#define PIE	0x40
#define AIE	0x20
#define UIE	0x10
#define SQWE	0x08
#define DM	0x04
#define _24_HR	0x02
#define DSE	0x01
#define REG_B_INIT	(_24_HR)

/* register A */
#define UIP	0x80
#define DV2	0x40
#define DV1	0x20
#define DV0	0x10
#define RS3	0x08
#define RS2	0x04
#define RS1	0x02
#define RS0	0x01
#define REG_A_INIT	(DV1|RS2|RS1)

/* Diagnostic Status Byte 0x0e */
/* As named in the BIOS */
#define CMOS_CLK_FAIL	0x04
#define HF_FAIL		0x08
#define W_MEM_SIZE	0x10
#define BAD_CONFIG	0x20
#define BAD_CKSUM	0x40
#define BAD_BAT		0x80

/* Shutdown Status Byte 0x0f */
#define SOFT_OR_UNEXP	0x0
#define AFTER_MEMSIZE	0x1
#define AFTER_MEMTEST	0x2
#define AFTER_MEMERR	0x3
#define BOOT_REQ	0x4
#define JMP_DWORD_ICA	0x5
#define TEST3_PASS	0x6
#define TEST3_FAIL	0x7
#define TEST1_FAIL	0x8
#define BLOCK_MOVE	0x9
#define JMP_DWORD_NOICA 0xa

/* Diskette Drive Type Byte 0x10 */
#define FIRST_FLOPPY_NULL	0x0
#define FIRST_FLOPPY_360	0x10
#define FIRST_FLOPPY_12		0x20
#define FIRST_FLOPPY_720	0x30
#define FIRST_FLOPPY_144	0x40
#define SECOND_FLOPPY_NULL	0x0
#define SECOND_FLOPPY_360	0x01
#define SECOND_FLOPPY_12	0x02
#define SECOND_FLOPPY_720	0x03
#define SECOND_FLOPPY_144	0x04

/* Fixed Disk Type Byte 0x12 */
#define NO_HARD_C	0x0
#define EXTENDED_C	0xf0
#define NO_HARD_D	0x0
#define EXTENDED_D	0x0f

/* Equipment Byte 0x14 */
#define ONE_DRIVE	0x0
#define TWO_DRIVES	0x40
#define OWN_BIOS	0x0
#define CGA_40_COLUMN	0x10
#define CGA_80_COLUMN	0x20
#define MDA_PRINTER	0x30
#define CO_PROCESSOR_PRESENT	0x02
#define COPROCESSOR_NOT_PRESENT	0x00
#define DISKETTE_PRESENT	0x01
#define DISKETTE_NOT_PRESENT	0x00

/* Masks for the Equipment Byte */
#define DRIVE_INFO	0x41
#define DISPLAY_INFO	0x30
#define NPX_INFO	0x02
#define RESVD_INFO	0x8C

/* Cmos initialisation data */

#define DIAG_INIT	0x0
#define SHUT_INIT	0x0
#define FLOP_INIT	0x20
#define CMOS_RESVD	0x0
#define DISK_INIT	0xf0

#define EQUIP_INIT	0x1
#define BM_LO_INIT	0x80
#define BM_HI_INIT	0x02
#define EXP_LO		0x0
#define EXP_HI		0x0
#define DISK_EXTEND	0x14
#define DISK2_EXTEND	0x0

#define CHK_HI_INIT	0x0
#define CHK_LO_INIT	0x0
#define EXT_LO_INIT	0x0
#define EXT_HI_INIT	0x0
#define CENT_INIT	0x19
#define INFO_128_INIT	0x80

/* Useful bit masks */
#define CMOS_ADDR_MASK 0x3f
#define CMOS_BIT_MASK 0x71
#define NMI_DISABLE 0x80
#define TOP_BIT	0x80
#define REST	0x7f

/* Bit masks used in the BIOS */
/* This is used for CMOS_INFO128 */
#define M640K		0x80

#define BAD_SHUT_DOWN	0x01
#define BAD_REG_D	0x02
#define BAD_DIAG	0x04
#define BAD_EQUIP	0x08
#define BAD_FLOPPY	0x10
#define BAD_DISK	0x20
#define BAD_BMS		0x40
#define BAD_XMS		0x80
#define BAD_CHECKSUM	0x100

#define CMOS_SIZE 64

/* Real Time Clock Periodic Interrupt Rates */
#define MAX_PIR		51
#define PIR_NONE	0
#define PIR_2HZ		1
#define PIR_4HZ		1
#define PIR_8HZ		1
#define PIR_16HZ	1
#define PIR_32HZ	1
#define PIR_64HZ	3
#define PIR_128HZ	6
#define PIR_256HZ	13
#define PIR_512HZ	26
#define PIR_1MHZ	MAX_PIR
#define PIR_2MHZ	MAX_PIR
#define PIR_4MHZ	MAX_PIR
#define PIR_8MHZ	MAX_PIR
#define PIR_16MHZ	MAX_PIR
#define PIR_32MHZ	MAX_PIR

#define DONT_CARE	0xc0

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 *	void cmos_init()
 *	{
 *		This function performs several distinct initialisation
 *		tasks associated with the CMOS :
 *
 *		cmos_io_attach() - attach the CMOS ports to the IO bus.
 *		cmos_hw_init() - initialise the MC146818A
 *		cmos_post() - perform the IBM POST specific to the CMOS
 *	}
 */
IMPORT VOID cmos_init IPT0();

/*
 *	void cmos_io_attach()
 *	{
 *		This function attaches the CMOS ports to the IO bus.
 *		Presently called from cmos_init(), this should be 
 *		called at some sensible place on machine powerup.
 *	}
 */
IMPORT VOID cmos_io_attach IPT0();

/*
 *	void cmos_hw_init()
 *	{
 *		This function resets the MC146818A to its default state.
 *	}
 */
IMPORT VOID cmos_hw_init IPT0();

/*
 *	void cmos_post()
 *	{
 *		This function is a very poor emulation of what goes on in
 *		the IBM power on system test to do with the CMOS. This is
 *		called via cmos_init() from reset() in reset.c. Ideally,
 *		reset() should be renamed post() and should only call this
 *		third initialisation function, rather than _io_attach and
 *		_hw_init too.
 *		NB. There is no emulation of the strange behaviour of the
 *		notorious SHUT_DOWN byte, which allows a user program to
 *		jump to a known location in the POST, or anywhere in Intel
 *		memory, after having pulsed the keyboard reset line.
 *	}
 */
IMPORT VOID cmos_post IPT0();

/*
 *	void rtc_init()
 *	{
 *		This function sets up the 12/24 hour mode and binary/bcd
 *		mode for the data stored in the CMOS bytes.
 *		It also initialises the time bytes to the current host
 *		time, and sets up the alarm to go off at the time specified
 *		in the alarm bytes.
 *	}
 */
IMPORT VOID rtc_init IPT0();

/*
 *	void cmos_inb(port, value)
 *	io_addr port;
 *	half_word *value;
 *	{
 *		This function is invoked when a read is performed on an
 *		I/O address "port" in the range of the CMOS.
 *
 *		The function maps the I/O address to the CMOS
 *		and returns the value of the requested
 *		register in "*value".
 *	}
 */
IMPORT VOID cmos_inb IPT2(io_addr, port, half_word *, value);

/*
 *	void cmos_outb(port, value)
 *	io_addr port;
 *	half_word value;
 *	{
 *		This function is invoked when a write is performed to an
 *		I/O address "port" in the range of the CMOS, or 
 *		may also be called directly from the BIOS.
 *
 *		The function maps the I/O address to the CMOS
 *		and sets the requested register to "value".
 *	}
 */
IMPORT VOID cmos_outb IPT2(io_addr, port, half_word, value);

#if defined(NTVDM) || defined(macintosh)
/*
 *	void cmos_pickup()
 *	{
 *		This is an extremely badly named function that picks up
 *		the data stored in the cmos.ram resource to emulate not
 *		losing data between invocations of SoftPC/AT. This is
 *		called from main() at application startup.
 *	}
 */
IMPORT VOID cmos_pickup IPT0();
#endif	/* defined(NTVDM) || defined(macintosh) */

/*	void cmos_update()
 *	{
 *		This function is called from terminate() on application
 *		exit. It stores the data held in the cmos to the cmos.ram
 *		resource.
 *	}
 */
IMPORT VOID cmos_update IPT0();

/*	void rtc_tick()
 *	{
 *		This function gets called from the base routine time_strobe()
 *		which gets called by the host 20 times a second. It toggles
 *		the periodic flag at 20Hz, the update flag at 1Hz in the
 *		CMOS register C and the update bit in CMOS register A. If
 *		periodic interrupts are enabled, a burst of interrupts are
 *		sent every 20th second. The chip is capable of up to 32 MHz,
 *		and we hope noone uses this feature!.
 *		NB. This is still to be tuned. The default DOS rate is 1MHz
 *		but we try to send 20 interrupts at 20Hz, and this blows the
 *		interrupt stack. Assuming programs use the BIOS interface
 *		(INT 15) it is possible to decrement a larger count less 
 *		often, to fool the PC program.
 *
 *		This is where the CMOS code checks for interrupts from
 *		the three available sources: periodic as described above,
 *		update triggered and alarm triggered.
 *	}
 */
IMPORT VOID rtc_tick IPT0();

/*
 *	void cmos_equip_update()
 *	{
 *		This routine updates the cmos bytes when the user changes
 *		graphics adapter from the User Interface. The EQUIP and
 *		CKSUM bytes are affected, and the user is not informed
 *		of the change.
 *	}
 */
IMPORT VOID cmos_equip_update IPT0();

/*
** int cmos_write_byte( cmos_byte:int, new_value:half_word )
** Writes the specified value into the specified cmos address.
** Returns 0 if OK, 1 if cmos address out of range (there are 64 cmos bytes).
**
*/
IMPORT int cmos_write_byte IPT2(int, cmos_byte, half_word, new_value);

/*
** int cmos_read_byte( cmos_byte:int, *value:half_word )
** Reads the specified value from the specified cmos address and returns it
** at the address specified by the value parameter.
** Returns 0 if OK, 1 if cmos address out of range (there are 64 cmos bytes).
**
*/
IMPORT INT cmos_read_byte IPT2(int, cmos_byte, half_word *, value);

/*
 * Functions to read and write to the cmos resource file.
 */
IMPORT INT 
host_read_resource IPT5(        
	INT, type,      /* Unused */
	CHAR *, name,    /* Name of resource */
	UTINY *, addr,    /* Address to read data into */
	INT, maxsize,   /* Max amount of data to read */
	INT, display_error);/* Controls message output */

IMPORT void host_write_resource IPT4(
	INT,type,               /* Unused */
	CHAR *,name,             /* Name of resource */
	UTINY *,addr,             /* Address of data to write */
	LONG,size);              /* Quantity of data to write */

/*
 *	This variable works like timer_int_enabled and can be used to
 *	disable real time clock interrupts totally during debugging
 */
extern int rtc_int_enabled;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cpu2.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title	: Definitions for the CPU 
 *
 * Description	: Structures, macros and definitions for access to the 
 *		  CPU registers
 *
 * Author	: Henry Nash
 *
 * Notes	: This file should be portable - but includes a file
 *		  host_cpu.h which contains machine specific definitions
 *		  of CPU register mappings etc.
 */

/* SccsID[]="@(#)cpu2.h	1.3 12/22/93 Copyright Insignia Solutions Ltd."; */

#include "host_cpu.h"

IMPORT VOID host_set_hw_int IPT0();
IMPORT VOID host_clear_hw_int IPT0();

/*
 * CPU Data Area
 * These externs are given before host_cpu.h is included so that the
 * variables may be gathreed into a structure and the externs overridden
* by #defines in host_cpu.h
 */

extern	word protected_mode;   /* =0 no proteced mode warning given
       		                   =1 proteced mode warning given */
extern  word            cpu_interrupt_map;
extern  half_word       cpu_int_translate[];
extern  word            cpu_int_delay;
extern  half_word       ica_lock;
extern  void            (*(jump_ptrs[]))();
extern  void            (*(b_write_ptrs[]))();
extern  void            (*(w_write_ptrs[]))();
extern  void            (*(b_fill_ptrs[]))();
extern  void            (*(w_fill_ptrs[]))();
#ifdef EGATEST
extern  void            (*(b_fwd_move_ptrs[]))();
extern  void            (*(w_fwd_move_ptrs[]))();
extern  void            (*(b_bwd_move_ptrs[]))();
extern  void            (*(w_bwd_move_ptrs[]))();
#else
extern  void            (*(b_move_ptrs[]))();
extern  void            (*(w_move_ptrs[]))();
#endif /* EGATEST */
extern  half_word       *haddr_of_src_string;
 
/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * The cpu opcode sliding frame
 */
 
#ifdef BACK_M
typedef struct
{
                half_word FOURTH_BYTE;
                half_word THIRD_BYTE;
                half_word SECOND_BYTE;
                half_word OPCODE;
}  OPCODE_FRAME;

typedef struct
{
                signed_char FOURTH_BYTE;
                signed_char THIRD_BYTE;
                signed_char SECOND_BYTE;
                signed_char OPCODE;
}  SIGNED_OPCODE_FRAME;
#else
typedef struct
{
                half_word OPCODE;
                half_word SECOND_BYTE;
                half_word THIRD_BYTE;
                half_word FOURTH_BYTE;
}  OPCODE_FRAME;

typedef struct
{
                signed_char OPCODE;
                signed_char SECOND_BYTE;
                signed_char THIRD_BYTE;
                signed_char FOURTH_BYTE;
}  SIGNED_OPCODE_FRAME;
#endif /* BACK_M */
 
/*
 * The new ICA uses the following for H/W ints:
 */
 
#define CPU_HW_INT		0
#define CPU_HW_INT_MASK		(1 << CPU_HW_INT)

/*
 * CPU software interrupt definitions
 */
 
#define CPU_SW_INT              8
#define CPU_SW_INT_MASK         (1 << CPU_SW_INT)

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern OPCODE_FRAME *opcode_frame;	/* C CPU and dasm only		    */

/*
 * External declarations for the 80286 registers
 */
 
extern reg A;           /* Accumulator          */
extern reg B;           /* Base                 */
extern reg C;           /* Count                */
extern reg D;           /* Data                 */
extern reg SP;          /* Stack Pointer        */
extern reg BP;          /* Base pointer         */
extern reg SI;          /* Source Index         */
extern reg DI;          /* Destination Index    */
extern reg IP;          /* Instruction Pointer  */
extern reg CS;          /* Code Segment         */
extern reg DS;          /* Data Segment         */
extern reg SS;          /* Stack Segment        */
extern reg ES;          /* Extra Segment        */
 
/*
 * External function declarations. These may be defined to other things.
 */

#ifndef	host_simulate
extern void host_simulate	IPT0();
#endif	/* host_simulate */

#ifndef	host_cpu_reset
extern void host_cpu_reset	IPT0();
#endif	/* host_cpu_reset */

#ifndef	host_cpu_init
extern void host_cpu_init	IPT0();
#endif	/* host_cpu_init */

#ifndef	host_cpu_interrupt
extern void host_cpu_interrupt	IPT0();
#endif	/* host_cpu_interrupt */

/*
 * Definition of Descriptor Table
 */

#ifdef BIGEND

union sixteenbits
{
	word X;

	struct
	{
		half_word lower;
		half_word upper;
	} word;
};

#endif	/* BIGEND */

#ifdef LITTLEND

union sixteenbits
{
	word X;

	struct
	{
		half_word upper;
		half_word lower;
	} word;
};

#endif	/* LITTLEND */

struct DESC_TABLE
{
	union sixteenbits misc;
	union sixteenbits base;
	union sixteenbits limit;
};

#define CPU_SIGALRM_EXCEPTION           15              /* SIGALRM signal
*/           
#define CPU_SIGALRM_EXCEPTION_MASK      (1 << CPU_SIGALRM_EXCEPTION)
 
#define CPU_TRAP_EXCEPTION              11              /* TRAP FLAG
*/
#define CPU_TRAP_EXCEPTION_MASK         (1 << CPU_TRAP_EXCEPTION)

#define CPU_YODA_EXCEPTION              13              /* YODA FLAG
*/
#define CPU_YODA_EXCEPTION_MASK         (1 << CPU_YODA_EXCEPTION)

#define CPU_SIGIO_EXCEPTION             14              /* SIGIO FLAG
*/
#define CPU_SIGIO_EXCEPTION_MASK        (1 << CPU_SIGIO_EXCEPTION)

#define CPU_RESET_EXCEPTION             12              /* RESET FLAG
*/
#define CPU_RESET_EXCEPTION_MASK        (1 << CPU_RESET_EXCEPTION)

#ifdef CCPU

IMPORT void sw_host_simulate IPT0();
IMPORT int selector_outside_table IPT2(word, selector, sys_addr *, descr_addr);
IMPORT void cpu_init IPT0();

/*
   Define descriptor 'super' types.
 */
#define INVALID				0x00
#define AVAILABLE_TSS			0x01
#define LDT_SEGMENT			0x02
#define BUSY_TSS			0x03
#define CALL_GATE			0x04
#define TASK_GATE			0x05
#define INTERRUPT_GATE			0x06
#define TRAP_GATE			0x07
#define EXPANDUP_READONLY_DATA		0x11
#define EXPANDUP_WRITEABLE_DATA		0x13
#define EXPANDDOWN_READONLY_DATA	0x15
#define EXPANDDOWN_WRITEABLE_DATA	0x17
#define NONCONFORM_NOREAD_CODE		0x19
#define NONCONFORM_READABLE_CODE	0x1b
#define CONFORM_NOREAD_CODE		0x1d
#define CONFORM_READABLE_CODE		0x1f

/* Code Segment (Private) */
extern half_word CS_AR;
extern sys_addr  CS_base;
extern word      CS_limit;

/* Data Segment (Private) */
extern half_word DS_AR;
extern sys_addr  DS_base;
extern word      DS_limit;

/* Stack Segment (Private) */
extern half_word SS_AR;
extern sys_addr  SS_base;
extern word      SS_limit;

/* Extra Segment (Private) */
extern half_word ES_AR;
extern sys_addr  ES_base;
extern word      ES_limit;
 
/* Local Descriptor Table Register (Private) */
extern sys_addr LDTR_base;  /* Base Address */
extern word     LDTR_limit; /* Segment 'size' */

/* Task Register (Private) */
extern sys_addr TR_base;  /* Base Address */
extern word     TR_limit; /* Segment 'size' */

/* Interrupt status, defines any abnormal processing */
extern int doing_contributory;
extern int doing_double_fault;

/* HOST - decoded access rights */
extern int ALC_CS;
extern int ALC_DS;
extern int ALC_ES;
extern int ALC_SS;

#define X_REAL 0
#define C_UPRO 1
#define C_DNRO 6
#define C_PROT 2
#define C_UPRW 7
#define C_DNRW 8
#define S_UP   3
#define S_DOWN 4
#define S_BAD  5
#define D_CODE 1
#define D_UPRO 1
#define D_DNRO 6
#define D_UPRW 7
#define D_DNRW 8
#define D_BAD  2

/*
 *
 *******************************************************************
 * The 'C' cpu register access functions.             		   *
 *******************************************************************
 *
 */

#define getCS_SELECTOR()	CS.X
#define getDS_SELECTOR()	DS.X
#define getSS_SELECTOR()	SS.X
#define getES_SELECTOR()	ES.X

#define getCS_AR()		CS_AR
#define getDS_AR()		DS_AR
#define getSS_AR()		SS_AR
#define getES_AR()		ES_AR

#define getCS_BASE()		CS_base
#define getDS_BASE()		DS_base
#define getSS_BASE()		SS_base
#define getES_BASE()		ES_base

#define getCS_LIMIT()		CS_limit
#define getDS_LIMIT()		DS_limit
#define getSS_LIMIT()		SS_limit
#define getES_LIMIT()		ES_limit

#define getLDT_BASE()		LDTR_base
#define getLDT_LIMIT()		LDTR_limit

#define getTR_BASE()	        TR_base
#define getTR_LIMIT()	        TR_limit

#define setCS_SELECTOR(val)	CS.X     = val
#define setDS_SELECTOR(val)	DS.X     = val
#define setSS_SELECTOR(val)	SS.X     = val
#define setES_SELECTOR(val)	ES.X     = val

#define setCS_AR(val)		CS_AR    = val
#define setDS_AR(val)		DS_AR    = val
#define setSS_AR(val)		SS_AR    = val
#define setES_AR(val)		ES_AR    = val

#define setCS_BASE(val)		CS_base  = val
#define setDS_BASE(val)		DS_base  = val
#define setSS_BASE(val)		SS_base  = val
#define setES_BASE(val)		ES_base  = val

#define setCS_LIMIT(val)	CS_limit = val
#define setDS_LIMIT(val)	DS_limit = val
#define setSS_LIMIT(val)	SS_limit = val
#define setES_LIMIT(val)	ES_limit = val

#define setLDT_BASE(val)	LDTR_base  = val
#define setLDT_LIMIT(val)	LDTR_limit = val

#define setTR_BASE(val)		TR_base  = val
#define setTR_LIMIT(val)	TR_limit = val
/*
 * The Machine Status Word structure
 */
typedef struct
{ 
     unsigned int :16;
     unsigned int reserved:12;
     unsigned int TS:1;
     unsigned int EM:1;
     unsigned int MP:1;
     unsigned int PE:1;
} mreg;
 
extern sys_addr address_line_mask;

extern int       CPL;   /* Current Privilege Level */
 
/* Global Descriptor Table Register */
extern sys_addr GDTR_base;  /* Base Address */
extern word     GDTR_limit; /* Segment 'size' */

/* Interrupt Descriptor Table Register */
extern sys_addr IDTR_base;  /* Base Address */
extern word     IDTR_limit; /* Segment 'size' */

/* Local Descriptor Table Register */
extern reg  LDTR;       /* Selector */

/* Task Register */
extern reg  TR;       /* Selector */

extern mreg MSW;     /* Machine Status Word */

extern int STATUS_CF;
extern int STATUS_SF;
extern int STATUS_ZF;
extern int STATUS_AF;
extern int STATUS_OF;
extern int STATUS_PF;
extern int STATUS_TF;
extern int STATUS_IF;
extern int STATUS_DF;
extern int STATUS_NT;
extern int STATUS_IOPL;

/*
**==========================================================================
** The CCPU basic register access macros. These may be overridden in
** host-cpu.h.
**==========================================================================
*/

#ifndef	getAX

/* READ functions  */
#define  getAX()	(A.X)
#define	 getAH()	(A.byte.high)
#define	 getAL()	(A.byte.low)
#define	 getBX()	(B.X)
#define	 getBH()	(B.byte.high)
#define	 getBL()	(B.byte.low)
#define	 getCX()	(C.X)
#define	 getCH()	(C.byte.high)
#define	 getCL()	(C.byte.low)
#define	 getDX()	(D.X)
#define	 getDH()	(D.byte.high)
#define	 getDL()	(D.byte.low)
#define	 getSP()	(SP.X)
#define	 getBP()	(BP.X)
#define	 getSI()	(SI.X)
#define	 getDI()	(DI.X)
#define	 getIP()	(IP.X)
#define	 getCS()	(CS.X)
#define	 getDS()	(DS.X)
#define	 getES()	(ES.X)
#define	 getSS()	(SS.X)
#define	 getMSW()	(m_s_w)
#define	 getDF()	(STATUS_DF)
#define	 getIF()	(STATUS_IF)
#define	 getTF()	(STATUS_TF)
#define	 getPF()	(STATUS_PF)
#define	 getAF()	(STATUS_AF)
#define	 getSF()	(STATUS_SF)
#define	 getZF()	(STATUS_ZF)
#define	 getOF()	(STATUS_OF)
#define	 getCF()    	(STATUS_CF)

#define getCPL()		(CPL)
#define getGDT_BASE()		(GDTR_base)
#define getGDT_LIMIT()		(GDTR_limit)
#define getIDT_BASE()		(IDTR_base)
#define getIDT_LIMIT()		(IDTR_limit)
#define getLDT_SELECTOR()		(LDTR.X)
#define getTR_SELECTOR()			(TR.X)
#define getMSW_reserved()	(MSW.reserved)
#define getTS()		(MSW.TS)
#define getEM()		(MSW.EM)
#define getMP()		(MSW.MP)
#define getPE()		(MSW.PE)
#define getNT()		(STATUS_NT)
#define getIOPL()	(STATUS_IOPL)
#define	 getSTATUS() 	(getCF()        |	\
			getOF()   << 11 |	\
			getZF()   << 6  |	\
			getSF()   << 7  |	\
			getAF()   << 4  |	\
			getPF()   << 2  |	\
			getTF()   << 8  |	\
			getIF()   << 9  |	\
			getDF()   << 10 |	\
			getIOPL() << 12 |	\
			getNT()   << 14)

extern	ext_load_CS();
extern	ext_load_DS();
extern	ext_load_ES();
extern	ext_load_SS();

/* WRITE functions  */
#define  setAX(val)	(A.X = (val))
#define	 setAH(val)	(A.byte.high = (val))
#define	 setAL(val)	(A.byte.low = (val))
#define	 setBX(val)	(B.X = (val))
#define	 setBH(val)	(B.byte.high = (val))
#define	 setBL(val)	(B.byte.low = (val))
#define	 setCX(val)	(C.X = (val))
#define	 setCH(val)	(C.byte.high = (val))
#define	 setCL(val)	(C.byte.low = (val))
#define	 setDX(val)	(D.X = (val))
#define	 setDH(val)	(D.byte.high = (val))
#define	 setDL(val)	(D.byte.low = (val))
#define	 setSP(val)	(SP.X = (val))
#define	 setBP(val)	(BP.X = (val))
#define	 setSI(val)	(SI.X = (val))
#define	 setDI(val)	(DI.X = (val))
#define	 setIP(val)	(IP.X = (val))
#define	 setCS(val)	ext_load_CS (val)
#define	 setDS(val)	ext_load_DS (val)
#define	 setES(val)	ext_load_ES (val)
#define	 setSS(val)	ext_load_SS (val)
#define	 setMSW(val)	(m_s_w = (val))
#define	 setDF(val)	(STATUS_DF = (val))
#define	 setIF(val)	(STATUS_IF = (val))
#define	 setTF(val)	(STATUS_TF = (val))
#define	 setPF(val)	(STATUS_PF = (val))
#define	 setAF(val)	(STATUS_AF = (val))
#define	 setSF(val)	(STATUS_SF = (val))
#define	 setZF(val)	(STATUS_ZF = (val))
#define	 setOF(val)	(STATUS_OF = (val))
#define	 setCF(val)	(STATUS_CF = (val))

#define setCPL(val)		(CPL = (val))
#define setGDT_BASE(val)	(GDTR_base = (val))
#define setGDT_LIMIT(val)	(GDTR_limit = (val))
#define setIDT_BASE(val)	(IDTR_base = (val))
#define setIDT_LIMIT(val)	(IDTR_limit = (val))
#define setLDT_SELECTOR(val)		(LDTR.X = (val))
#define setTR_SELECTOR(val)		(TR.X = (val))
#define setMSW_reserved(val)	(MSW.reserved = (val))
#define setTS(val)		(MSW.TS = (val))
#define setEM(val)		(MSW.EM = (val))
#define setMP(val)		(MSW.MP = (val))
#define setPE(val)		(MSW.PE = (val))
#define setNT(val)		(STATUS_NT = (val))
#define setIOPL(val)	(STATUS_IOPL = (val))

#endif	/* getAX - default CCPU register access macros */

#endif /* CCPU */

/*
 * No non-386 cpu can run in VM mode, so getVM is always zero.
 *
 * We also have definition of the GetInstructionPointer and GetStackPointer
 * interfaces, which on a non-386 can only be the 16 bit versions.
 */

#ifndef SPC386
#define getVM() 0
#define GetInstructionPointer() ((IU32)getIP())
#define GetStackPointer() ((IU32getSP())
#endif

#ifdef	CPU_PRIVATE
/*
 * Map new "private" cpu interface -> old interface
 */

#define	setIDT_BASE_LIMIT(base,limit)	{ setIDT_BASE(base); setIDT_LIMIT(limit); }
#define	setGDT_BASE_LIMIT(base,limit)	{ setGDT_BASE(base); setGDT_LIMIT(limit); }
#define	setLDT_BASE_LIMIT(base,limit)	{ setLDT_BASE(base); setLDT_LIMIT(limit); }
#define	setTR_BASE_LIMIT(base,limit)	{ setTR_BASE(base); setTR_LIMIT(limit); }

#define	setCS_BASE_LIMIT_AR(base,limit,ar)	{ setCS_BASE(base); setCS_LIMIT(limit); setCS_AR(ar); }
#define	setES_BASE_LIMIT_AR(base,limit,ar)	{ setES_BASE(base); setES_LIMIT(limit); setES_AR(ar); }
#define	setSS_BASE_LIMIT_AR(base,limit,ar)	{ setSS_BASE(base); setSS_LIMIT(limit); setSS_AR(ar); }
#define	setDS_BASE_LIMIT_AR(base,limit,ar)	{ setDS_BASE(base); setDS_LIMIT(limit); setDS_AR(ar); }
#define	setFS_BASE_LIMIT_AR(base,limit,ar)	{ setFS_BASE(base); setFS_LIMIT(limit); setFS_AR(ar); }
#define	setGS_BASE_LIMIT_AR(base,limit,ar)	{ setGS_BASE(base); setGS_LIMIT(limit); setGS_AR(ar); }

#endif	/* CPU_PRIVATE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cpu3.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Definitions for the 3.x CPU 
 *
 * Description	: Structures, macros and definitions for access to the 
 *		  CPU registers
 *
 * Author	: Wayne Plummer
 *
 * Derived from : cpu.h
 *
 * Notes	: This file should be portable - but includes a file
 *		  host_cpu.h which contains machine specific definitions
 *		  of CPU register mappings etc.
 */

/* SccsID[]="@(#)cpu3.h	1.5 12/22/93 Copyright Insignia Solutions Ltd."; */

#include "host_cpu.h"

IMPORT VOID host_set_hw_int IPT0();
IMPORT VOID host_clear_hw_int IPT0();

/*
 * These variables are obsolete - however they are referenced
 * by:-
 *
 *	1. ica.c
 */

extern  word            cpu_interrupt_map;
extern  half_word       cpu_int_translate[];
extern  word            cpu_int_delay;
extern  half_word       ica_lock;
extern  void            (*(jump_ptrs[]))();
extern  void            (*(b_write_ptrs[]))();
extern  void            (*(w_write_ptrs[]))();
extern  void            (*(b_fill_ptrs[]))();
extern  void            (*(w_fill_ptrs[]))();
extern  void            (*(b_move_ptrs[]))();
extern  void            (*(w_move_ptrs[]))();
extern  half_word       *haddr_of_src_string;

/*
 *	Host functions to be provided for the base to use with respect to the CPU.
 *	These must be done in host_cpu.h because some hosts may want functions and
 *	others may want #defines.
 */

/*
 *	This macro specifies the maximum recursion depth the CPU is required to support.
 *	(Note that a particular host may not actually use this value if it is capable
 *	of supporting abirtarily deep recursion).
 */
#define CPU_MAX_RECURSION	32

/*
 *	Interrupt types...
 */

typedef enum {	CPU_HW_RESET,
		CPU_TIMER_TICK,
		CPU_SW_INT,
		CPU_HW_INT,
		CPU_YODA_INT,
		CPU_SIGIO_EVENT
} CPU_INT_TYPE;

#ifdef CPU_PRIVATE
/*
   Function returns for private i/f procedures handling segment loading.
 */

#define SELECTOR_OK  0
#define GP_ERROR    13
#define NP_ERROR    11
#define SF_ERROR    12
#endif /* CPU_PRIVATE */

#ifdef CCPU

/* Fuctions provided by CPU */
IMPORT void		c_cpu_init	IPT0 ();
IMPORT void		c_cpu_interrupt	IPT2(CPU_INT_TYPE, type, IU16, number);
IMPORT void		c_cpu_simulate	IPT0();
IMPORT void		c_cpu_q_ev_set_count	IPT1(ULONG, new_count);
IMPORT ULONG		c_cpu_q_ev_get_count	IPT0();
IMPORT ULONG		c_cpu_calc_q_ev_inst_for_time	IPT1(ULONG, time);
IMPORT void		c_cpu_EOA_hook	IPT0();
IMPORT void		c_cpu_terminate	IPT0();

#define cpu_init		c_cpu_init
#define cpu_interrupt		c_cpu_interrupt
#define cpu_simulate		c_cpu_simulate
#define	host_q_ev_set_count	c_cpu_q_ev_set_count
#define	host_q_ev_get_count	c_cpu_q_ev_get_count
#ifndef host_calc_q_ev_inst_for_time
#define	host_calc_q_ev_inst_for_time	c_cpu_calc_q_ev_inst_for_time
#endif /* host_calc_q_ev_inst_for_time */
#define cpu_EOA_hook		c_cpu_EOA_hook
#define cpu_terminate		c_cpu_terminate

#ifndef CCPU_MAIN


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Byte Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT half_word c_getAL	IPT0();
IMPORT half_word c_getCL	IPT0();
IMPORT half_word c_getDL	IPT0();
IMPORT half_word c_getBL	IPT0();
IMPORT half_word c_getAH	IPT0();
IMPORT half_word c_getCH	IPT0();
IMPORT half_word c_getDH	IPT0();
IMPORT half_word c_getBH	IPT0();
   
IMPORT void c_setAL	IPT1(half_word, val);
IMPORT void c_setCL	IPT1(half_word, val);
IMPORT void c_setDL	IPT1(half_word, val);
IMPORT void c_setBL	IPT1(half_word, val);
IMPORT void c_setAH	IPT1(half_word, val);
IMPORT void c_setCH	IPT1(half_word, val);
IMPORT void c_setDH	IPT1(half_word, val);
IMPORT void c_setBH	IPT1(half_word, val);

#define getAL() c_getAL()
#define getCL() c_getCL()
#define getDL() c_getDL()
#define getBL() c_getBL()
#define getAH() c_getAH()
#define getCH() c_getCH()
#define getDH() c_getDH()
#define getBH() c_getBH()

#define setAL(x) c_setAL(x)
#define setCL(x) c_setCL(x)
#define setDL(x) c_setDL(x)
#define setBL(x) c_setBL(x)
#define setAH(x) c_setAH(x)
#define setCH(x) c_setCH(x)
#define setDH(x) c_setDH(x)
#define setBH(x) c_setBH(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Word Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT word c_getAX	IPT0();
IMPORT word c_getCX	IPT0();
IMPORT word c_getDX	IPT0();
IMPORT word c_getBX	IPT0();
IMPORT word c_getSP	IPT0();
IMPORT word c_getBP	IPT0();
IMPORT word c_getSI	IPT0();
IMPORT word c_getDI	IPT0();
IMPORT word c_getIP	IPT0();

IMPORT void c_setAX	IPT1(word, val);
IMPORT void c_setCX	IPT1(word, val);
IMPORT void c_setDX	IPT1(word, val);
IMPORT void c_setBX	IPT1(word, val);
IMPORT void c_setSP	IPT1(word, val);
IMPORT void c_setBP	IPT1(word, val);
IMPORT void c_setSI	IPT1(word, val);
IMPORT void c_setDI	IPT1(word, val);
IMPORT void c_setIP	IPT1(word, val);

#define getAX() c_getAX()
#define getCX() c_getCX()
#define getDX() c_getDX()
#define getBX() c_getBX()
#define getSP() c_getSP()
#define getBP() c_getBP()
#define getSI() c_getSI()
#define getDI() c_getDI()
#define getIP() c_getIP()

#define setAX(x) c_setAX(x)
#define setCX(x) c_setCX(x)
#define setDX(x) c_setDX(x)
#define setBX(x) c_setBX(x)
#define setSP(x) c_setSP(x)
#define setBP(x) c_setBP(x)
#define setSI(x) c_setSI(x)
#define setDI(x) c_setDI(x)
#define setIP(x) c_setIP(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Segment Registers.                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT word c_getES	IPT0();
IMPORT word c_getCS	IPT0();
IMPORT word c_getSS	IPT0();
IMPORT word c_getDS	IPT0();

IMPORT INT c_setES	IPT1(word, val);
IMPORT INT c_setCS	IPT1(word, val);
IMPORT INT c_setSS	IPT1(word, val);
IMPORT INT c_setDS	IPT1(word, val);

#define getES() c_getES()
#define getCS() c_getCS()
#define getSS() c_getSS()
#define getDS() c_getDS()

#define setES(x) c_setES(x)
#define setCS(x) c_setCS(x)
#define setSS(x) c_setSS(x)
#define setDS(x) c_setDS(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Full(Private) Segment Registers.                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef CPU_PRIVATE

IMPORT word c_getES_SELECTOR	IPT0();
IMPORT word c_getCS_SELECTOR	IPT0();
IMPORT word c_getSS_SELECTOR	IPT0();
IMPORT word c_getDS_SELECTOR	IPT0();

IMPORT word c_getCS_LIMIT	IPT0();
IMPORT word c_getDS_LIMIT	IPT0();
IMPORT word c_getES_LIMIT	IPT0();
IMPORT word c_getSS_LIMIT	IPT0();

IMPORT long c_getCS_BASE	IPT0();
IMPORT long c_getDS_BASE	IPT0();
IMPORT long c_getES_BASE	IPT0();
IMPORT long c_getSS_BASE	IPT0();

IMPORT half_word c_getCS_AR	IPT0();
IMPORT half_word c_getDS_AR	IPT0();
IMPORT half_word c_getES_AR	IPT0();
IMPORT half_word c_getSS_AR	IPT0();

IMPORT void c_setES_SELECTOR	IPT1(word, val);
IMPORT void c_setCS_SELECTOR	IPT1(word, val);
IMPORT void c_setSS_SELECTOR	IPT1(word, val);
IMPORT void c_setDS_SELECTOR	IPT1(word, val);

IMPORT void c_setCS_LIMIT	IPT1(word, val);
IMPORT void c_setDS_LIMIT	IPT1(word, val);
IMPORT void c_setES_LIMIT	IPT1(word, val);
IMPORT void c_setSS_LIMIT	IPT1(word, val);

IMPORT void c_setCS_BASE	IPT1(long, val);
IMPORT void c_setDS_BASE	IPT1(long, val);
IMPORT void c_setES_BASE	IPT1(long, val);
IMPORT void c_setSS_BASE	IPT1(long, val);

IMPORT void c_setCS_AR	IPT1(half_word, val);
IMPORT void c_setDS_AR	IPT1(half_word, val);
IMPORT void c_setES_AR	IPT1(half_word, val);
IMPORT void c_setSS_AR	IPT1(half_word, val);

#define getES_SELECTOR c_getES_SELECTOR
#define getCS_SELECTOR c_getCS_SELECTOR
#define getSS_SELECTOR c_getSS_SELECTOR
#define getDS_SELECTOR c_getDS_SELECTOR

#define getDS_LIMIT c_getDS_LIMIT
#define getCS_LIMIT c_getCS_LIMIT
#define getES_LIMIT c_getES_LIMIT
#define getSS_LIMIT c_getSS_LIMIT

#define getDS_BASE c_getDS_BASE
#define getCS_BASE c_getCS_BASE
#define getES_BASE c_getES_BASE
#define getSS_BASE c_getSS_BASE

#define getDS_AR c_getDS_AR
#define getCS_AR c_getCS_AR
#define getES_AR c_getES_AR
#define getSS_AR c_getSS_AR

#define setES_SELECTOR c_setES_SELECTOR
#define setCS_SELECTOR c_setCS_SELECTOR
#define setSS_SELECTOR c_setSS_SELECTOR
#define setDS_SELECTOR c_setDS_SELECTOR

#define setDS_LIMIT c_setDS_LIMIT
#define setCS_LIMIT c_setCS_LIMIT
#define setES_LIMIT c_setES_LIMIT
#define setSS_LIMIT c_setSS_LIMIT

#define setDS_BASE c_setDS_BASE
#define setCS_BASE c_setCS_BASE
#define setES_BASE c_setES_BASE
#define setSS_BASE c_setSS_BASE

#define setDS_AR c_setDS_AR
#define setCS_AR c_setCS_AR
#define setES_AR c_setES_AR
#define setSS_AR c_setSS_AR

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Flags.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT INT c_getAF	IPT0();
IMPORT INT c_getCF	IPT0();
IMPORT INT c_getDF	IPT0();
IMPORT INT c_getIF	IPT0();
IMPORT INT c_getOF	IPT0();
IMPORT INT c_getPF	IPT0();
IMPORT INT c_getSF	IPT0();
IMPORT INT c_getTF	IPT0();
IMPORT INT c_getZF	IPT0();
IMPORT INT c_getIOPL	IPT0();
IMPORT INT c_getNT	IPT0();
IMPORT word c_getSTATUS	IPT0();

IMPORT void c_setAF	IPT1(INT, val);
IMPORT void c_setCF	IPT1(INT, val);
IMPORT void c_setDF	IPT1(INT, val);
IMPORT void c_setIF	IPT1(INT, val);
IMPORT void c_setOF	IPT1(INT, val);
IMPORT void c_setPF	IPT1(INT, val);
IMPORT void c_setSF	IPT1(INT, val);
IMPORT void c_setTF	IPT1(INT, val);
IMPORT void c_setZF	IPT1(INT, val);
IMPORT void c_setIOPL	IPT1(INT, val);
IMPORT void c_setNT	IPT1(INT, val);

#define getAF()     c_getAF()
#define getCF()     c_getCF()
#define getDF()     c_getDF()
#define getIF()     c_getIF()
#define getOF()     c_getOF()
#define getPF()     c_getPF()
#define getSF()     c_getSF()
#define getTF()     c_getTF()
#define getZF()     c_getZF()
#define getIOPL()   c_getIOPL()
#define getNT()     c_getNT()
#define getSTATUS() c_getSTATUS()

#define setAF(x)     c_setAF(x)
#define setCF(x)     c_setCF(x)
#define setDF(x)     c_setDF(x)
#define setIF(x)     c_setIF(x)
#define setOF(x)     c_setOF(x)
#define setPF(x)     c_setPF(x)
#define setSF(x)     c_setSF(x)
#define setTF(x)     c_setTF(x)
#define setZF(x)     c_setZF(x)
#define setIOPL(x)   c_setIOPL(x)
#define setNT(x)     c_setNT(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Machine Status Word.                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT INT c_getPE	IPT0();
IMPORT INT c_getMP	IPT0();
IMPORT INT c_getEM	IPT0();
IMPORT INT c_getTS	IPT0();
IMPORT word c_getMSW	IPT0();

#define getPE() c_getPE()
#define getMP() c_getMP()
#define getEM() c_getEM()
#define getTS() c_getTS()
#define getMSW() c_getMSW()

#ifdef CPU_PRIVATE

IMPORT void c_setPE	IPT1(INT, val);
IMPORT void c_setMP	IPT1(INT, val);
IMPORT void c_setEM	IPT1(INT, val);
IMPORT void c_setTS	IPT1(INT, val);
IMPORT void c_setMSW	IPT1(word, val);

#define setPE(x) c_setPE(x)
#define setMP(x) c_setMP(x)
#define setEM(x) c_setEM(x)
#define setTS(x) c_setTS(x)
#define setMSW(x) c_setMSW(x)

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Descriptor Registers.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT sys_addr c_getGDT_BASE	IPT0();
IMPORT sys_addr c_getIDT_BASE	IPT0();
IMPORT sys_addr c_getLDT_BASE	IPT0();
IMPORT sys_addr c_getTR_BASE	IPT0();
IMPORT word c_getGDT_LIMIT	IPT0();
IMPORT word c_getIDT_LIMIT	IPT0();
IMPORT word c_getLDT_LIMIT	IPT0();
IMPORT word c_getTR_LIMIT	IPT0();
IMPORT word c_getLDT_SELECTOR	IPT0();
IMPORT word c_getTR_SELECTOR	IPT0();

#define getGDT_BASE() c_getGDT_BASE()
#define getIDT_BASE() c_getIDT_BASE()
#define getLDT_BASE() c_getLDT_BASE()
#define getTR_BASE()  c_getTR_BASE()
#define getGDT_LIMIT() c_getGDT_LIMIT()
#define getIDT_LIMIT() c_getIDT_LIMIT()
#define getLDT_LIMIT() c_getLDT_LIMIT()
#define getTR_LIMIT()  c_getTR_LIMIT()
#define getLDT_SELECTOR() c_getLDT_SELECTOR()
#define getTR_SELECTOR()  c_getTR_SELECTOR()

#ifdef CPU_PRIVATE

IMPORT void c_setGDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setIDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setLDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setTR_BASE	IPT1(sys_addr, val);
IMPORT void c_setGDT_LIMIT	IPT1(word, val);
IMPORT void c_setIDT_LIMIT	IPT1(word, val);
IMPORT void c_setLDT_LIMIT	IPT1(word, val);
IMPORT void c_setTR_LIMIT	IPT1(word, val);
IMPORT void c_setLDT_SELECTOR	IPT1(word, val);
IMPORT void c_setTR_SELECTOR	IPT1(word, val);

#define setGDT_BASE(x) c_setGDT_BASE(x)
#define setIDT_BASE(x) c_setIDT_BASE(x)
#define setLDT_BASE(x) c_setLDT_BASE(x)
#define setTR_BASE(x)  c_setTR_BASE(x)
#define setGDT_LIMIT(x) c_setGDT_LIMIT(x)
#define setIDT_LIMIT(x) c_setIDT_LIMIT(x)
#define setLDT_LIMIT(x) c_setLDT_LIMIT(x)
#define setTR_LIMIT(x)  c_setTR_LIMIT(x)
#define setLDT_SELECTOR(x) c_setLDT_SELECTOR(x)
#define setTR_SELECTOR(x)  c_setTR_SELECTOR(x)

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Current Privilege Level.                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef CPU_PRIVATE

IMPORT INT c_getCPL	IPT0();
IMPORT VOID c_setCPL	IPT1(INT, val);

#define getCPL() c_getCPL()
#define setCPL(x) c_setCPL(x)

#endif /* CPU_PRIVATE */

#endif /* CCPU_MAIN */

#endif /* CCPU */

#ifdef A3CPU

/*
 *	Function imports...
 */

/*
 *	cpu_init() - Initialises the 3.0 CPU.
 */

IMPORT VOID		a3_cpu_init IPT0();

/*
 *	cpu_interrupt() - Interrupts the 3.0 CPU.
 */
#ifdef SWITCHED_CPU
IMPORT VOID		a3_cpu_interrupt IPT2(CPU_INT_TYPE, type, IU16, number);
#else
IMPORT VOID		a3_cpu_interrupt();
#endif

/*
 *	cpu_simulate() - Performs INTEL CPU emulation.
 */
IMPORT VOID		_asm_simulate();

IMPORT VOID		a3_cpu_q_ev_set_count();
IMPORT ULONG		a3_cpu_q_ev_get_count();

#ifndef SWITCHED_CPU

extern IU32 a3_cpu_calc_q_ev_inst_for_time IPT1 (IU32, time);

/*
 *	cpu_EOA_hook() - Resets the 3.0 CPU prior to running the next application.
 */
IMPORT VOID		a3_cpu_EOA_hook();

/*
 *	cpu_terminate() - Closes down the CPU.
 */
IMPORT VOID		a3_cpu_terminate();

/*
 *	Intel register Access...
 */

IMPORT half_word	a3_getAL();
IMPORT half_word	a3_getBL();
IMPORT half_word	a3_getCL();
IMPORT half_word	a3_getDL();
IMPORT half_word	a3_getAH();
IMPORT half_word	a3_getBH();
IMPORT half_word	a3_getCH();
IMPORT half_word	a3_getDH();

IMPORT word		a3_getAX();
IMPORT word		a3_getBX();
IMPORT word		a3_getCX();
IMPORT word		a3_getDX();
IMPORT word		a3_getSP();
IMPORT word		a3_getBP();
IMPORT word		a3_getSI();
IMPORT word		a3_getDI();

IMPORT word		a3_getIP();

IMPORT word		a3_getCS();
IMPORT word		a3_getDS();
IMPORT word		a3_getES();
IMPORT word		a3_getSS();

IMPORT word		a3_getAF();
IMPORT word		a3_getCF();
IMPORT word		a3_getDF();
IMPORT word		a3_getIF();
IMPORT word		a3_getIOPL();
IMPORT word		a3_getNT();
IMPORT word		a3_getOF();
IMPORT word		a3_getPF();
IMPORT word		a3_getSF();
IMPORT word		a3_getTF();
IMPORT word		a3_getZF();

IMPORT word		a3_getSTATUS();

IMPORT word		a3_getEM();
IMPORT word		a3_getMP();
IMPORT word		a3_getPE();
IMPORT word		a3_getTS();

IMPORT word		a3_getMSW();

IMPORT sys_addr		a3_getGDT_BASE();
IMPORT word		a3_getGDT_LIMIT();

IMPORT sys_addr		a3_getIDT_BASE();
IMPORT word		a3_getIDT_LIMIT();

IMPORT sys_addr		a3_getLDT_BASE();
IMPORT word		a3_getLDT_LIMIT();
IMPORT word		a3_getLDT_SELECTOR();

IMPORT sys_addr		a3_getTR_BASE();
IMPORT word		a3_getTR_LIMIT();
IMPORT word		a3_getTR_SELECTOR();

IMPORT VOID		a3_setAL();
IMPORT VOID		a3_setCL();
IMPORT VOID		a3_setDL();
IMPORT VOID		a3_setBL();
IMPORT VOID		a3_setAH();
IMPORT VOID		a3_setCH();
IMPORT VOID		a3_setDH();
IMPORT VOID		a3_setBH();

IMPORT VOID		a3_setAX();
IMPORT VOID		a3_setCX();
IMPORT VOID		a3_setDX();
IMPORT VOID		a3_setBX();
IMPORT VOID		a3_setSP();
IMPORT VOID		a3_setBP();
IMPORT VOID		a3_setSI();
IMPORT VOID		a3_setDI();

IMPORT VOID		a3_setIP();

IMPORT INT		a3_setES();
IMPORT INT		a3_setCS();
IMPORT INT		a3_setSS();
IMPORT INT		a3_setDS();

IMPORT VOID		a3_setCF();
IMPORT VOID		a3_setPF();
IMPORT VOID		a3_setAF();
IMPORT VOID		a3_setZF();
IMPORT VOID		a3_setSF();
IMPORT VOID		a3_setTF();
IMPORT VOID		a3_setIF();
IMPORT VOID		a3_setDF();
IMPORT VOID		a3_setOF();
IMPORT VOID		a3_setIOPL();
IMPORT VOID		a3_setNT();

#ifdef CPU_PRIVATE

IMPORT word		a3_p_getCPL();
IMPORT word		a3_p_getES_SELECTOR();
IMPORT sys_addr		a3_p_getES_BASE();
IMPORT word		a3_p_getES_LIMIT();
IMPORT half_word	a3_p_getES_AR();
IMPORT VOID		a3_p_setES_SELECTOR();
IMPORT VOID		a3_p_setES_BASE();
IMPORT VOID		a3_p_setES_LIMIT();
IMPORT VOID		a3_p_setES_AR();
IMPORT word		a3_p_getCS_SELECTOR();
IMPORT sys_addr		a3_p_getCS_BASE();
IMPORT word		a3_p_getCS_LIMIT();
IMPORT half_word	a3_p_getCS_AR();
IMPORT VOID		a3_p_setCS_SELECTOR();
IMPORT VOID		a3_p_setCS_BASE();
IMPORT VOID		a3_p_setCS_LIMIT();
IMPORT VOID		a3_p_setCS_AR();
IMPORT word		a3_p_getDS_SELECTOR();
IMPORT sys_addr		a3_p_getDS_BASE();
IMPORT word		a3_p_getDS_LIMIT();
IMPORT half_word	a3_p_getDS_AR();
IMPORT VOID		a3_p_setDS_SELECTOR();
IMPORT VOID		a3_p_setDS_BASE();
IMPORT VOID		a3_p_setDS_LIMIT();
IMPORT VOID		a3_p_setDS_AR();
IMPORT word		a3_p_getSS_SELECTOR();
IMPORT sys_addr		a3_p_getSS_BASE();
IMPORT word		a3_p_getSS_LIMIT();
IMPORT half_word	a3_p_getSS_AR();
IMPORT VOID		a3_p_setSS_SELECTOR();
IMPORT VOID		a3_p_setSS_BASE();
IMPORT VOID		a3_p_setSS_LIMIT();
IMPORT VOID		a3_p_setSS_AR();
IMPORT VOID		a3_p_setPE();
IMPORT VOID		a3_p_setMP();
IMPORT VOID		a3_p_setEM();
IMPORT VOID		a3_p_setTS();
IMPORT VOID		a3_p_setMSW();
IMPORT VOID		a3_p_setCPL();
IMPORT VOID		a3_p_setGDT_BASE();
IMPORT VOID		a3_p_setGDT_LIMIT();
IMPORT VOID		a3_p_setIDT_BASE();
IMPORT VOID		a3_p_setIDT_LIMIT();
IMPORT VOID		a3_p_setLDT_SELECTOR();
IMPORT VOID		a3_p_setLDT_BASE();
IMPORT VOID		a3_p_setLDT_LIMIT();
IMPORT VOID		a3_p_setTR_SELECTOR();
IMPORT VOID		a3_p_setTR_BASE();
IMPORT VOID		a3_p_setTR_LIMIT();

#endif /* CPU_PRIVATE */
#endif /* SWITCHED_CPU */


/*
 *	Macro definitions...
 */

#define cpu_init		a3_cpu_init
#define cpu_simulate		_asm_simulate
#define	host_q_ev_set_count	a3_cpu_q_ev_set_count
#define	host_q_ev_get_count	a3_cpu_q_ev_get_count
#ifndef host_calc_q_ev_inst_for_time
#define	host_calc_q_ev_inst_for_time	a3_cpu_calc_q_ev_inst_for_time
#endif /* host_calc_q_ev_inst_for_time */
#define cpu_EOA_hook		a3_cpu_EOA_hook
#define cpu_terminate		a3_cpu_terminate

/*
 *	Intel register Access...
 */

#ifndef getAX

#define cpu_interrupt		a3_cpu_interrupt

#define getAL		a3_getAL
#define getBL		a3_getBL
#define getCL		a3_getCL
#define getDL		a3_getDL
#define getAH		a3_getAH
#define getBH		a3_getBH
#define getCH		a3_getCH
#define getDH		a3_getDH
#define getAX		a3_getAX
#define getBX		a3_getBX
#define getCX		a3_getCX
#define getDX		a3_getDX
#define getSP		a3_getSP
#define getBP		a3_getBP
#define getSI		a3_getSI
#define getDI		a3_getDI
#define getIP		a3_getIP
#define getCS		a3_getCS
#define getDS		a3_getDS
#define getES		a3_getES
#define getSS		a3_getSS
#define getAF		a3_getAF
#define getCF		a3_getCF
#define getDF		a3_getDF
#define getIF		a3_getIF
#define getIOPL		a3_getIOPL
#define getNT		a3_getNT
#define getOF		a3_getOF
#define getPF		a3_getPF
#define getSF		a3_getSF
#define getTF		a3_getTF
#define getZF		a3_getZF
#define getSTATUS	a3_getSTATUS
#define getEM		a3_getEM
#define getMP		a3_getMP
#define getPE		a3_getPE
#define getTS		a3_getTS
#define getMSW		a3_getMSW
#define getGDT_BASE	a3_getGDT_BASE
#define getGDT_LIMIT	a3_getGDT_LIMIT
#define getIDT_BASE	a3_getIDT_BASE
#define getIDT_LIMIT	a3_getIDT_LIMIT
#define getLDT_BASE	a3_getLDT_BASE
#define getLDT_LIMIT	a3_getLDT_LIMIT
#define getLDT_SELECTOR	a3_getLDT_SELECTOR
#define getTR_BASE	a3_getTR_BASE
#define getTR_LIMIT	a3_getTR_LIMIT
#define getTR_SELECTOR	a3_getTR_SELECTOR
#define setAL		a3_setAL
#define setCL		a3_setCL
#define setDL		a3_setDL
#define setBL		a3_setBL
#define setAH		a3_setAH
#define setCH		a3_setCH
#define setDH		a3_setDH
#define setBH		a3_setBH
#define setAX		a3_setAX
#define setCX		a3_setCX
#define setDX		a3_setDX
#define setBX		a3_setBX
#define setSP		a3_setSP
#define setBP		a3_setBP
#define setSI		a3_setSI
#define setDI		a3_setDI
#define setIP		a3_setIP
#define setES		a3_setES
#define setCS		a3_setCS
#define setSS		a3_setSS
#define setDS		a3_setDS
#define setCF		a3_setCF
#define setPF		a3_setPF
#define setAF		a3_setAF
#define setZF		a3_setZF
#define setSF		a3_setSF
#define setTF		a3_setTF
#define setIF		a3_setIF
#define setDF		a3_setDF
#define setOF		a3_setOF
#define setIOPL		a3_setIOPL
#define setNT		a3_setNT

#endif /* getAX */

#ifdef CPU_PRIVATE

#define getCPL		a3_p_getCPL
#define getES_SELECTOR	a3_p_getES_SELECTOR
#define getCS_SELECTOR	a3_p_getCS_SELECTOR
#define getSS_SELECTOR	a3_p_getSS_SELECTOR
#define getDS_SELECTOR	a3_p_getDS_SELECTOR
#define getES_BASE	a3_p_getES_BASE
#define getCS_BASE	a3_p_getCS_BASE
#define getDS_BASE	a3_p_getDS_BASE
#define getSS_BASE	a3_p_getSS_BASE
#define getES_LIMIT	a3_p_getES_LIMIT
#define getCS_LIMIT	a3_p_getCS_LIMIT
#define getDS_LIMIT	a3_p_getDS_LIMIT
#define getSS_LIMIT	a3_p_getSS_LIMIT
#define getES_AR	a3_p_getES_AR
#define getCS_AR	a3_p_getCS_AR
#define getDS_AR	a3_p_getDS_AR
#define getSS_AR	a3_p_getSS_AR
#define setES_SELECTOR	a3_p_setES_SELECTOR
#define setCS_SELECTOR	a3_p_setCS_SELECTOR
#define setSS_SELECTOR	a3_p_setSS_SELECTOR
#define setDS_SELECTOR	a3_p_setDS_SELECTOR
#define setES_BASE	a3_p_setES_BASE
#define setCS_BASE	a3_p_setCS_BASE
#define setDS_BASE	a3_p_setDS_BASE
#define setSS_BASE	a3_p_setSS_BASE
#define setES_LIMIT	a3_p_setES_LIMIT
#define setCS_LIMIT	a3_p_setCS_LIMIT
#define setDS_LIMIT	a3_p_setDS_LIMIT
#define setSS_LIMIT	a3_p_setSS_LIMIT
#define setES_AR	a3_p_setES_AR
#define setCS_AR	a3_p_setCS_AR
#define setDS_AR	a3_p_setDS_AR
#define setSS_AR	a3_p_setSS_AR
#define setPE		a3_p_setPE
#define setMP		a3_p_setMP
#define setEM		a3_p_setEM
#define setTS		a3_p_setTS
#define setMSW		a3_p_setMSW
#define setCPL		a3_p_setCPL
#define setGDT_BASE	a3_p_setGDT_BASE
#define setGDT_LIMIT	a3_p_setGDT_LIMIT
#define setIDT_BASE	a3_p_setIDT_BASE
#define setIDT_LIMIT	a3_p_setIDT_LIMIT
#define setLDT_SELECTOR	a3_p_setLDT_SELECTOR
#define setLDT_BASE	a3_p_setLDT_BASE
#define setLDT_LIMIT	a3_p_setLDT_LIMIT
#define setTR_SELECTOR	a3_p_setTR_SELECTOR
#define setTR_BASE	a3_p_setTR_BASE
#define setTR_LIMIT	a3_p_setTR_LIMIT

#endif /* CPU_PRIVATE */

#endif /* A3CPU */

#ifdef SPC386
/*
 * New additions for SPC386 builds follow...
 * eventually it would be nice to change the start of this file to conform
 * to the new style when there is effort to spare.
 *
 *       Wayne Plummer 19/3/93 (GISP project)
 */

#ifdef CCPU
IMPORT void c_setSTATUS	IPT1(IU16, val);
#define setSTATUS()  c_setSTATUS()
#else
IMPORT VOID		a3_setSTATUS IPT1(IU16, val);
#define setSTATUS	a3_setSTATUS
#endif


#ifdef CCPU
IMPORT IU32 c_getEFLAGS	IPT0();
#define getEFLAGS() c_getEFLAGS()
#else
IMPORT IU32		a3_getEFLAGS();
#define getEFLAGS	a3_getEFLAGS
#endif

#ifdef CCPU
IMPORT void c_setEFLAGS	IPT1(IU32, val);
#define setEFLAGS()  c_setEFLAGS()
#else
IMPORT VOID		a3_setEFLAGS IPT1(IU32, val);
#define setEFLAGS	a3_setEFLAGS
#endif


#ifdef CCPU
IMPORT   IU32   c_getEAX               IPT0();
#define           getEAX               c_getEAX
#else
IMPORT   IU32  a3_getEAX               IPT0();
#define           getEAX               a3_getEAX
#endif

#ifdef CCPU
IMPORT   IU32   c_getEBX               IPT0();
#define           getEBX               c_getEBX
#else
IMPORT   IU32  a3_getEBX               IPT0();
#define           getEBX               a3_getEBX
#endif

#ifdef CCPU
IMPORT   IU32   c_getECX               IPT0();
#define           getECX               c_getECX
#else
IMPORT   IU32  a3_getECX               IPT0();
#define           getECX               a3_getECX
#endif

#ifdef CCPU
IMPORT   IU32   c_getEDX               IPT0();
#define           getEDX               c_getEDX
#else
IMPORT   IU32  a3_getEDX               IPT0();
#define           getEDX               a3_getEDX
#endif

#ifdef CCPU
IMPORT   IU32   c_getESP               IPT0();
#define           getESP               c_getESP
#else
IMPORT   IU32  a3_getESP               IPT0();
#define           getESP               a3_getESP
#endif

#ifdef CCPU
IMPORT   IU32   c_getEBP               IPT0();
#define           getEBP               c_getEBP
#else
IMPORT   IU32  a3_getEBP               IPT0();
#define           getEBP               a3_getEBP
#endif

#ifdef CCPU
IMPORT   IU32   c_getESI               IPT0();
#define           getESI               c_getESI
#else
IMPORT   IU32  a3_getESI               IPT0();
#define           getESI               a3_getESI
#endif

#ifdef CCPU
IMPORT   IU32   c_getEDI               IPT0();
#define           getEDI               c_getEDI
#else
IMPORT   IU32  a3_getEDI               IPT0();
#define           getEDI               a3_getEDI
#endif

#ifdef CCPU
IMPORT   IU32   c_getEIP               IPT0();
#define           getEIP               c_getEIP
#else
IMPORT   IU32  a3_getEIP               IPT0();
#define           getEIP               a3_getEIP
#endif

#ifdef CCPU
IMPORT   IU16   c_getFS                IPT0();
#define           getFS                c_getFS 
#else
IMPORT   IU16  a3_getFS                IPT0();
#define           getFS                a3_getFS 
#endif

#ifdef CCPU
IMPORT   IU16   c_getGS                IPT0();
#define           getGS                c_getGS 
#else
IMPORT   IU16  a3_getGS                IPT0();
#define           getGS                a3_getGS 
#endif

#ifdef CCPU
IMPORT   IU16   c_getVM                IPT0();
#define           getVM                c_getVM 
#else
IMPORT   IU16  a3_getVM                IPT0();
#define           getVM                a3_getVM 
#endif

#ifdef CCPU
IMPORT   IU16   c_getPG                IPT0();
#define           getPG                c_getPG 
#else
IMPORT   IU16  a3_getPG                IPT0();
#define           getPG                a3_getPG 
#endif

#ifdef CCPU
IMPORT   VOID   c_setEAX               IPT1(IU32, val);
#define           setEAX               c_setEAX
#else
IMPORT   IU32  a3_setEAX               IPT1(IU32, val);
#define           setEAX               a3_setEAX
#endif

#ifdef CCPU
IMPORT   VOID   c_setEBX               IPT1(IU32, val);
#define           setEBX               c_setEBX
#else
IMPORT   IU32  a3_setEBX               IPT1(IU32, val);
#define           setEBX               a3_setEBX
#endif

#ifdef CCPU
IMPORT   VOID   c_setECX               IPT1(IU32, val);
#define           setECX               c_setECX
#else
IMPORT   IU32  a3_setECX               IPT1(IU32, val);
#define           setECX               a3_setECX
#endif

#ifdef CCPU
IMPORT   VOID   c_setEDX               IPT1(IU32, val);
#define           setEDX               c_setEDX
#else
IMPORT   IU32  a3_setEDX               IPT1(IU32, val);
#define           setEDX               a3_setEDX
#endif

#ifdef CCPU
IMPORT   VOID   c_setESP               IPT1(IU32, val);
#define           setESP               c_setESP
#else
IMPORT   IU32  a3_setESP               IPT1(IU32, val);
#define           setESP               a3_setESP
#endif

#ifdef CCPU
IMPORT   VOID   c_setEBP               IPT1(IU32, val);
#define           setEBP               c_setEBP
#else
IMPORT   IU32  a3_setEBP               IPT1(IU32, val);
#define           setEBP               a3_setEBP
#endif

#ifdef CCPU
IMPORT   VOID   c_setESI               IPT1(IU32, val);
#define           setESI               c_setESI
#else
IMPORT   IU32  a3_setESI               IPT1(IU32, val);
#define           setESI               a3_setESI
#endif

#ifdef CCPU
IMPORT   VOID   c_setEDI               IPT1(IU32, val);
#define           setEDI               c_setEDI
#else
IMPORT   IU32  a3_setEDI               IPT1(IU32, val);
#define           setEDI               a3_setEDI
#endif

#ifdef CCPU
IMPORT   VOID   c_setEIP               IPT1(IU32, val);
#define           setEIP               c_setEIP
#else
IMPORT   IU32  a3_setEIP               IPT1(IU32, val);
#define           setEIP               a3_setEIP
#endif

#ifdef CCPU
IMPORT   VOID   c_setFS                IPT1(IU16, val);
#define           setFS                c_setFS 
#else
IMPORT   IU32  a3_setFS                IPT1(IU16, val);
#define           setFS                a3_setFS 
#endif

#ifdef CCPU
IMPORT   VOID   c_setGS                IPT1(IU16, val);
#define           setGS                c_setGS 
#else
IMPORT   IU32  a3_setGS                IPT1(IU16, val);
#define           setGS                a3_setGS 
#endif

#ifdef IRET_HOOKS
#ifdef CCPU
IMPORT   VOID c_Cpu_set_hook_selector  IPT1(IU16, selector);
#define  Cpu_set_hook_selector         c_Cpu_set_hook_selector
#else
IMPORT   VOID a3_Cpu_set_hook_selector IPT1(IU16, selector);
#define  Cpu_set_hook_selector         a3_Cpu_set_hook_selector
#endif
#endif /* IRET_HOOKS */

#ifdef CPU_PRIVATE

#ifdef CCPU
IMPORT	IU32	c_getFS_BASE		IPT0();
#define		getFS_BASE		c_getFS_BASE 
#else
IMPORT	IU32	a3_p_getFS_BASE		IPT0();
#define		getFS_BASE		a3_p_getFS_BASE 
#endif

#ifdef CCPU
IMPORT	IU16	c_getFS_LIMIT		IPT0();
#define		getFS_LIMIT		c_getFS_LIMIT 
#else
IMPORT	IU16	a3_p_getFS_LIMIT	IPT0();
#define		getFS_LIMIT		a3_p_getFS_LIMIT 
#endif

#ifdef CCPU
IMPORT	IU8	c_getFS_AR		IPT0();
#define		getFS_AR		c_getFS_AR 
#else
IMPORT	IU8	a3_p_getFS_AR		IPT0();
#define		getFS_AR		a3_p_getFS_AR 
#endif

#ifdef CCPU
IMPORT	IU32	c_getGS_BASE		IPT0();
#define		getGS_BASE		c_getGS_BASE 
#else
IMPORT	IU32	a3_p_getGS_BASE		IPT0();
#define		getGS_BASE		a3_p_getGS_BASE 
#endif

#ifdef CCPU
IMPORT	IU16	c_getGS_LIMIT		IPT0();
#define		getGS_LIMIT		c_getGS_LIMIT 
#else
IMPORT	IU16	a3_p_getGS_LIMIT	IPT0();
#define		getGS_LIMIT		a3_p_getGS_LIMIT 
#endif

#ifdef CCPU
IMPORT	IU8	c_getGS_AR		IPT0();
#define		getGS_AR		c_getGS_AR 
#else
IMPORT	IU8	a3_p_getGS_AR		IPT0();
#define		getGS_AR		a3_p_getGS_AR 
#endif

#ifdef CCPU
IMPORT	void	c_setFS_BASE		IPT1(IU32, base);
#define		setFS_BASE		c_setFS_BASE 
#else
IMPORT	void	a3_p_setFS_BASE		IPT1(IU32, base);
#define		setFS_BASE		a3_p_setFS_BASE 
#endif

#ifdef CCPU
IMPORT	void	c_setFS_LIMIT		IPT1(IU16, limit);
#define		setFS_LIMIT		c_setFS_LIMIT 
#else
IMPORT	void	a3_p_setFS_LIMIT	IPT1(IU16, limit);
#define		setFS_LIMIT		a3_p_setFS_LIMIT 
#endif

#ifdef CCPU
IMPORT	void	c_setFS_AR		IPT1(IU8, ar);
#define		setFS_AR		c_setFS_AR 
#else
IMPORT	void	a3_p_setFS_AR		IPT1(IU8, ar);
#define		setFS_AR		a3_p_setFS_AR 
#endif


#ifdef CCPU
IMPORT	void	c_setGS_BASE		IPT1(IU32, base);
#define		setGS_BASE		c_setGS_BASE 
#else
IMPORT	void	a3_p_setGS_BASE		IPT1(IU32, base);
#define		setGS_BASE		a3_p_setGS_BASE 
#endif

#ifdef CCPU
IMPORT	void	c_setGS_LIMIT		IPT1(IU16, limit);
#define		setGS_LIMIT		c_setGS_LIMIT 
#else
IMPORT	void	a3_p_setGS_LIMIT	IPT1(IU16, limit);
#define		setGS_LIMIT		a3_p_setGS_LIMIT 
#endif

#ifdef CCPU
IMPORT	void	c_setGS_AR		IPT1(IU8, ar);
#define		setGS_AR		c_setGS_AR 
#else
IMPORT	void	a3_p_setGS_AR		IPT1(IU8, ar);
#define		setGS_AR		a3_p_setGS_AR 
#endif

#ifndef CCPU
/*
 * These functions get the (E)IP or (E)SP correctly whatever size stack
 * or code segment is in use.
 */
extern IU32 GetInstructionPointer IPT0();
extern IU32 GetStackPointer IPT0();
#endif /* CCPU */
#endif /* CPU_PRIVATE */
#endif /* SPC386 */

#ifdef IRET_HOOKS
/*
 * The interfaces provided by the CPU so that the ICA can initiate and
 * terminate an iret hook.
 */

extern void Cpu_do_hook IPT2(IUM8, line, IBOOL, is_hooked);
extern void Cpu_inter_hook_processing IPT1(IUM8, line);
extern void Cpu_unhook IPT1(IUM8, line_number);
#ifdef GISP_CPU
extern void Cpu_set_hook_selector IPT1(IU16, selector);
extern void Cpu_hook_bop IPT0();
#endif

#endif /* IRET_HOOKS */

/*
 * No non-386 cpu can run in VM mode, so getVM is always zero.
 * The same is true for GISP, but it has its own version of this interface.
 *
 * We also have definition of the GetInstructionPointer and GetStackPointer
 * interfaces, which on a non-386 can only be the 16 bit versions.
 */

#ifndef SPC386
#define getVM() 0
#define GetInstructionPointer() ((IU32)getIP())
#define GetStackPointer() ((IU32getSP())
#endif

#ifdef SWIN_CPU_OPTS
extern IBOOL Cpu_find_dcache_entry IPT2(IU16, seg, LIN_ADDR *, base);
#endif

#ifdef	CPU_PRIVATE
/*
 * Map new "private" cpu interface -> old interface
 */

#define	setIDT_BASE_LIMIT(base,limit)	{ setIDT_BASE(base); setIDT_LIMIT(limit); }
#define	setGDT_BASE_LIMIT(base,limit)	{ setGDT_BASE(base); setGDT_LIMIT(limit); }
#define	setLDT_BASE_LIMIT(base,limit)	{ setLDT_BASE(base); setLDT_LIMIT(limit); }
#define	setTR_BASE_LIMIT(base,limit)	{ setTR_BASE(base); setTR_LIMIT(limit); }

#define	setCS_BASE_LIMIT_AR(base,limit,ar)	{ setCS_BASE(base); setCS_LIMIT(limit); setCS_AR(ar); }
#define	setES_BASE_LIMIT_AR(base,limit,ar)	{ setES_BASE(base); setES_LIMIT(limit); setES_AR(ar); }
#define	setSS_BASE_LIMIT_AR(base,limit,ar)	{ setSS_BASE(base); setSS_LIMIT(limit); setSS_AR(ar); }
#define	setDS_BASE_LIMIT_AR(base,limit,ar)	{ setDS_BASE(base); setDS_LIMIT(limit); setDS_AR(ar); }
#define	setFS_BASE_LIMIT_AR(base,limit,ar)	{ setFS_BASE(base); setFS_LIMIT(limit); setFS_AR(ar); }
#define	setGS_BASE_LIMIT_AR(base,limit,ar)	{ setGS_BASE(base); setGS_LIMIT(limit); setGS_AR(ar); }

#endif	/* CPU_PRIVATE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cpu_vid.h ===
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		cpu_vid.h

 Description:

		This module supports the interface between the cpu
		and the video emulation code.

 Author:
		John Shanly

 Date:
		12 April 1991

 SccsID		@(#)cpu_vid.h	1.11 03/09/94

	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.

======================================================================
]*/

typedef struct
{
	void	(*b_write) IPT2(ULONG, value, ULONG, offset);
	void	(*w_write) IPT2(ULONG, value, ULONG, offset);

#ifndef	NO_STRING_OPERATIONS

	void	(*b_fill) IPT3(ULONG, value, ULONG, offset, ULONG, count);
	void	(*w_fill) IPT3(ULONG, value, ULONG, offset, ULONG, count);
	void	(*b_fwd_move) IPT4(ULONG, offset, ULONG, eas, ULONG, count,
		ULONG, src_flag);
	void	(*b_bwd_move) IPT4(ULONG, offset, ULONG, eas, ULONG, count,
		ULONG, src_flag);
	void	(*w_fwd_move) IPT4(ULONG, offset, ULONG, eas, ULONG, count,
		ULONG, src_flag);
	void	(*w_bwd_move) IPT4(ULONG, offset, ULONG, eas, ULONG, count,
		ULONG, src_flag);

#endif	/* NO_STRING_OPERATIONS */

} WRT_POINTERS;

typedef struct
{
	void	(*b_write) IPT2(IU8, eaOff, IU32, eaVal);
	void	(*w_write) IPT2(IU16, eaOff, IU32, eaVal);
	void	(*d_write) IPT2(IU32, eaOff, IU32, eaVal);
	void	(*b_fill) IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
	void	(*w_fill) IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
	void	(*d_fill) IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
	void	(*b_fwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*b_bwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*w_fwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*w_bwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*d_fwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*d_bwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
} EVID_WRT_POINTERS;

typedef struct
{
	WRT_POINTERS	mode_0[32];
	WRT_POINTERS	mode_1[2];
	WRT_POINTERS	mode_2[16];
#ifdef VGG
	WRT_POINTERS	mode_3[16];
#endif
} CHN_TABLE;

typedef struct
{
	CHN_TABLE	nch;
#ifdef VGG
	CHN_TABLE	ch4;
#endif
} MODE_TABLE;

extern MODE_TABLE mode_table;

typedef struct 
{
	IU32 (*b_read) IPT1(ULONG, offset);
	IU32 (*w_read) IPT1(ULONG, offset);

#ifndef	NO_STRING_OPERATIONS
	void (*str_read) IPT3(IU8 *, dest, ULONG, offset, ULONG, count);
#endif	/* NO_STRING_OPERATIONS */

} READ_POINTERS; 

typedef struct 
{
	IU32 (*b_read) IPT1(IU32, eaOff);
	IU32 (*w_read) IPT1(IU32, eaOff);
	IU32 (*d_read) IPT1(IU32, eaOff);
	void (*str_fwd_read) IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
	void (*str_bwd_read) IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
} EVID_READ_POINTERS; 

extern READ_POINTERS read_pointers;

#ifndef Cpu_set_vid_wrt_ptrs
extern void Cpu_set_vid_wrt_ptrs IPT1( WRT_POINTERS *, ptrs );
extern void Cpu_set_vid_rd_ptrs IPT1( READ_POINTERS *, ptrs );
#endif /* Cpu_set_vid_wrt_ptrs */

#ifndef CPU_40_STYLE
#ifdef A3CPU

#ifdef C_VID
extern WRT_POINTERS Glue_writes;
#endif /* C_VID */

#else /* A3CPU */

#ifdef C_VID
extern MEM_HANDLERS Glue_writes;
#endif /* C_VID */

#endif /* A3CPU */
#endif /* CPU_40_STYLE */

extern WRT_POINTERS simple_writes;
extern WRT_POINTERS dth_md0_writes, dth_md1_writes, dth_md2_writes, dth_md3_writes;
extern WRT_POINTERS ch2_md0, ch2_md1, ch2_md2, ch2_md3, ch2_mdcopy;

extern READ_POINTERS Glue_reads;

extern READ_POINTERS simple_reads, pointers_RAM_off;
extern READ_POINTERS pointers_mode0_nch, pointers_mode0_ch4, pointers_mode0_ch2;
extern READ_POINTERS pointers_mode1_nch, pointers_mode1_ch4, pointers_mode1_ch2;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cpu.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Definitions for the CPU
 *
 * Description	: Structures, macros and definitions for access to the
 *		  CPU registers
 *
 * Author	: Henry Nash
 *
 * Notes	: This file should be portable - but includes a file
 *		  host_cpu.h which contains machine specific definitions
 *		  of CPU register mappings etc.
 */

/* SccsID[]="@(#)cpu.h	1.28 12/10/92 Copyright Insignia Solutions Ltd."; */

#if defined(NTVDM) && defined(MONITOR)

#include "host_cpu.h"

IMPORT VOID host_set_hw_int IPT0();
IMPORT VOID host_clear_hw_int IPT0();

#ifdef CPU_30_STYLE

/*
 * These variables are obsolete - however they are referenced
 * by:-
 *
 *	1. ica.c
 */

extern  word            cpu_interrupt_map;
extern  half_word       cpu_int_translate[];
extern  word            cpu_int_delay;
extern  half_word       ica_lock;
extern  void            (*(jump_ptrs[]))();
extern  void            (*(b_write_ptrs[]))();
extern  void            (*(w_write_ptrs[]))();
extern  void            (*(b_fill_ptrs[]))();
extern  void            (*(w_fill_ptrs[]))();
extern  void            (*(b_move_ptrs[]))();
extern  void            (*(w_move_ptrs[]))();
extern  half_word       *haddr_of_src_string;

/*
 *	Host functions to be provided for the base to use with respect to the CPU.
 *	These must be done in host_cpu.h because some hosts may want functions and
 *	others may want #defines.
 */

/*
 *	This macro specifies the maximum recursion depth the CPU is required to support.
 *	(Note that a particular host may not actually use this value if it is capable
 *	of supporting abirtarily deep recursion).
 */
#define CPU_MAX_RECURSION	32

/*
 *	Interrupt types...
 */

typedef enum {	CPU_HW_RESET,
		CPU_TIMER_TICK,
		CPU_SW_INT,
		CPU_HW_INT,
		CPU_YODA_INT,
		CPU_SIGIO_EVENT
} CPU_INT_TYPE;

#ifdef CPU_PRIVATE
/*
   Function returns for private i/f procedures handling segment loading.
 */

#define SELECTOR_OK  0
#define GP_ERROR    13
#define NP_ERROR    11
#define SF_ERROR    12
#endif /* CPU_PRIVATE */

#ifdef CCPU

/* Fuctions provided by CPU */
IMPORT void		c_cpu_init	IPT0();
IMPORT void		c_cpu_interrupt	IPT2(CPU_INT_TYPE, type, USHORT, number);
IMPORT void		c_cpu_simulate	IPT0();
IMPORT void		c_cpu_q_ev_set_count	IPT1(ULONG, new_count);
IMPORT ULONG		c_cpu_q_ev_get_count	IPT0();
IMPORT ULONG		c_cpu_calc_q_ev_inst_for_time	IPT1(ULONG, time);
IMPORT void		c_cpu_EOA_hook	IPT0();
IMPORT void		c_cpu_terminate	IPT0();

#define cpu_init		c_cpu_init
#define cpu_interrupt		c_cpu_interrupt
#define cpu_simulate		c_cpu_simulate
#define	host_q_ev_set_count	c_cpu_q_ev_set_count
#define	host_q_ev_get_count	c_cpu_q_ev_get_count
#ifndef host_calc_q_ev_inst_for_time
#define	host_calc_q_ev_inst_for_time	c_cpu_calc_q_ev_inst_for_time
#endif /* host_calc_q_ev_inst_for_time */
#define cpu_EOA_hook		c_cpu_EOA_hook
#define cpu_terminate		c_cpu_terminate

#ifndef CCPU_MAIN


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Byte Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT half_word c_getAL	IPT0();
IMPORT half_word c_getCL	IPT0();
IMPORT half_word c_getDL	IPT0();
IMPORT half_word c_getBL	IPT0();
IMPORT half_word c_getAH	IPT0();
IMPORT half_word c_getCH	IPT0();
IMPORT half_word c_getDH	IPT0();
IMPORT half_word c_getBH	IPT0();

IMPORT void c_setAL	IPT1(half_word, val);
IMPORT void c_setCL	IPT1(half_word, val);
IMPORT void c_setDL	IPT1(half_word, val);
IMPORT void c_setBL	IPT1(half_word, val);
IMPORT void c_setAH	IPT1(half_word, val);
IMPORT void c_setCH	IPT1(half_word, val);
IMPORT void c_setDH	IPT1(half_word, val);
IMPORT void c_setBH	IPT1(half_word, val);

#define getAL() c_getAL()
#define getCL() c_getCL()
#define getDL() c_getDL()
#define getBL() c_getBL()
#define getAH() c_getAH()
#define getCH() c_getCH()
#define getDH() c_getDH()
#define getBH() c_getBH()

#define setAL(x) c_setAL(x)
#define setCL(x) c_setCL(x)
#define setDL(x) c_setDL(x)
#define setBL(x) c_setBL(x)
#define setAH(x) c_setAH(x)
#define setCH(x) c_setCH(x)
#define setDH(x) c_setDH(x)
#define setBH(x) c_setBH(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Word Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT word c_getAX	IPT0();
IMPORT word c_getCX	IPT0();
IMPORT word c_getDX	IPT0();
IMPORT word c_getBX	IPT0();
IMPORT word c_getSP	IPT0();
IMPORT word c_getBP	IPT0();
IMPORT word c_getSI	IPT0();
IMPORT word c_getDI	IPT0();
IMPORT word c_getIP	IPT0();

IMPORT void c_setAX	IPT1(word, val);
IMPORT void c_setCX	IPT1(word, val);
IMPORT void c_setDX	IPT1(word, val);
IMPORT void c_setBX	IPT1(word, val);
IMPORT void c_setSP	IPT1(word, val);
IMPORT void c_setBP	IPT1(word, val);
IMPORT void c_setSI	IPT1(word, val);
IMPORT void c_setDI	IPT1(word, val);
IMPORT void c_setIP	IPT1(word, val);

#define getAX() c_getAX()
#define getCX() c_getCX()
#define getDX() c_getDX()
#define getBX() c_getBX()
#define getSP() c_getSP()
#define getBP() c_getBP()
#define getSI() c_getSI()
#define getDI() c_getDI()
#define getIP() c_getIP()

#define setAX(x) c_setAX(x)
#define setCX(x) c_setCX(x)
#define setDX(x) c_setDX(x)
#define setBX(x) c_setBX(x)
#define setSP(x) c_setSP(x)
#define setBP(x) c_setBP(x)
#define setSI(x) c_setSI(x)
#define setDI(x) c_setDI(x)
#define setIP(x) c_setIP(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Segment Registers.                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT word c_getES	IPT0();
IMPORT word c_getCS	IPT0();
IMPORT word c_getSS	IPT0();
IMPORT word c_getDS	IPT0();

IMPORT INT c_setES	IPT1(word, val);
IMPORT INT c_setCS	IPT1(word, val);
IMPORT INT c_setSS	IPT1(word, val);
IMPORT INT c_setDS	IPT1(word, val);

#define getES() c_getES()
#define getCS() c_getCS()
#define getSS() c_getSS()
#define getDS() c_getDS()

#define setES(x) c_setES(x)
#define setCS(x) c_setCS(x)
#define setSS(x) c_setSS(x)
#define setDS(x) c_setDS(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Full(Private) Segment Registers.                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef CPU_PRIVATE

IMPORT word c_getES_SELECTOR	IPT0();
IMPORT word c_getCS_SELECTOR	IPT0();
IMPORT word c_getSS_SELECTOR	IPT0();
IMPORT word c_getDS_SELECTOR	IPT0();

IMPORT word c_getCS_LIMIT	IPT0();
IMPORT word c_getDS_LIMIT	IPT0();
IMPORT word c_getES_LIMIT	IPT0();
IMPORT word c_getSS_LIMIT	IPT0();

IMPORT long c_getCS_BASE	IPT0();
IMPORT long c_getDS_BASE	IPT0();
IMPORT long c_getES_BASE	IPT0();
IMPORT long c_getSS_BASE	IPT0();

IMPORT half_word c_getCS_AR	IPT0();
IMPORT half_word c_getDS_AR	IPT0();
IMPORT half_word c_getES_AR	IPT0();
IMPORT half_word c_getSS_AR	IPT0();

IMPORT void c_setES_SELECTOR	IPT1(word, val);
IMPORT void c_setCS_SELECTOR	IPT1(word, val);
IMPORT void c_setSS_SELECTOR	IPT1(word, val);
IMPORT void c_setDS_SELECTOR	IPT1(word, val);

IMPORT void c_setCS_LIMIT	IPT1(word, val);
IMPORT void c_setDS_LIMIT	IPT1(word, val);
IMPORT void c_setES_LIMIT	IPT1(word, val);
IMPORT void c_setSS_LIMIT	IPT1(word, val);

IMPORT void c_setCS_BASE	IPT1(long, val);
IMPORT void c_setDS_BASE	IPT1(long, val);
IMPORT void c_setES_BASE	IPT1(long, val);
IMPORT void c_setSS_BASE	IPT1(long, val);

IMPORT void c_setCS_AR	IPT1(half_word, val);
IMPORT void c_setDS_AR	IPT1(half_word, val);
IMPORT void c_setES_AR	IPT1(half_word, val);
IMPORT void c_setSS_AR	IPT1(half_word, val);

#define getES_SELECTOR c_getES_SELECTOR
#define getCS_SELECTOR c_getCS_SELECTOR
#define getSS_SELECTOR c_getSS_SELECTOR
#define getDS_SELECTOR c_getDS_SELECTOR

#define getDS_LIMIT c_getDS_LIMIT
#define getCS_LIMIT c_getCS_LIMIT
#define getES_LIMIT c_getES_LIMIT
#define getSS_LIMIT c_getSS_LIMIT

#define getDS_BASE c_getDS_BASE
#define getCS_BASE c_getCS_BASE
#define getES_BASE c_getES_BASE
#define getSS_BASE c_getSS_BASE

#define getDS_AR c_getDS_AR
#define getCS_AR c_getCS_AR
#define getES_AR c_getES_AR
#define getSS_AR c_getSS_AR

#define setES_SELECTOR c_setES_SELECTOR
#define setCS_SELECTOR c_setCS_SELECTOR
#define setSS_SELECTOR c_setSS_SELECTOR
#define setDS_SELECTOR c_setDS_SELECTOR

#define setDS_LIMIT c_setDS_LIMIT
#define setCS_LIMIT c_setCS_LIMIT
#define setES_LIMIT c_setES_LIMIT
#define setSS_LIMIT c_setSS_LIMIT

#define setDS_BASE c_setDS_BASE
#define setCS_BASE c_setCS_BASE
#define setES_BASE c_setES_BASE
#define setSS_BASE c_setSS_BASE

#define setDS_AR c_setDS_AR
#define setCS_AR c_setCS_AR
#define setES_AR c_setES_AR
#define setSS_AR c_setSS_AR

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Flags.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT INT c_getAF	IPT0();
IMPORT INT c_getCF	IPT0();
IMPORT INT c_getDF	IPT0();
IMPORT INT c_getIF	IPT0();
IMPORT INT c_getOF	IPT0();
IMPORT INT c_getPF	IPT0();
IMPORT INT c_getSF	IPT0();
IMPORT INT c_getTF	IPT0();
IMPORT INT c_getZF	IPT0();
IMPORT INT c_getIOPL	IPT0();
IMPORT INT c_getNT	IPT0();
IMPORT word c_getSTATUS	IPT0();

IMPORT void c_setAF	IPT1(INT, val);
IMPORT void c_setCF	IPT1(INT, val);
IMPORT void c_setDF	IPT1(INT, val);
IMPORT void c_setIF	IPT1(INT, val);
IMPORT void c_setOF	IPT1(INT, val);
IMPORT void c_setPF	IPT1(INT, val);
IMPORT void c_setSF	IPT1(INT, val);
IMPORT void c_setTF	IPT1(INT, val);
IMPORT void c_setZF	IPT1(INT, val);
IMPORT void c_setIOPL	IPT1(INT, val);
IMPORT void c_setNT	IPT1(INT, val);

#define getAF()     c_getAF()
#define getCF()     c_getCF()
#define getDF()     c_getDF()
#define getIF()     c_getIF()
#define getOF()     c_getOF()
#define getPF()     c_getPF()
#define getSF()     c_getSF()
#define getTF()     c_getTF()
#define getZF()     c_getZF()
#define getIOPL()   c_getIOPL()
#define getNT()     c_getNT()
#define getSTATUS() c_getSTATUS()

#define setAF(x)     c_setAF(x)
#define setCF(x)     c_setCF(x)
#define setDF(x)     c_setDF(x)
#define setIF(x)     c_setIF(x)
#define setOF(x)     c_setOF(x)
#define setPF(x)     c_setPF(x)
#define setSF(x)     c_setSF(x)
#define setTF(x)     c_setTF(x)
#define setZF(x)     c_setZF(x)
#define setIOPL(x)   c_setIOPL(x)
#define setNT(x)     c_setNT(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Machine Status Word.                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT INT c_getPE	IPT0();
IMPORT INT c_getMP	IPT0();
IMPORT INT c_getEM	IPT0();
IMPORT INT c_getTS	IPT0();
IMPORT word c_getMSW	IPT0();

#define getPE() c_getPE()
#define getMP() c_getMP()
#define getEM() c_getEM()
#define getTS() c_getTS()
#define getMSW() c_getMSW()

#ifdef CPU_PRIVATE

IMPORT void c_setPE	IPT1(INT, val);
IMPORT void c_setMP	IPT1(INT, val);
IMPORT void c_setEM	IPT1(INT, val);
IMPORT void c_setTS	IPT1(INT, val);
IMPORT void c_setMSW	IPT1(word, val);

#define setPE(x) c_setPE(x)
#define setMP(x) c_setMP(x)
#define setEM(x) c_setEM(x)
#define setTS(x) c_setTS(x)
#define setMSW(x) c_setMSW(x)

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Descriptor Registers.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT sys_addr c_getGDT_BASE	IPT0();
IMPORT sys_addr c_getIDT_BASE	IPT0();
IMPORT sys_addr c_getLDT_BASE	IPT0();
IMPORT sys_addr c_getTR_BASE	IPT0();
IMPORT word c_getGDT_LIMIT	IPT0();
IMPORT word c_getIDT_LIMIT	IPT0();
IMPORT word c_getLDT_LIMIT	IPT0();
IMPORT word c_getTR_LIMIT	IPT0();
IMPORT word c_getLDT_SELECTOR	IPT0();
IMPORT word c_getTR_SELECTOR	IPT0();

#define getGDT_BASE() c_getGDT_BASE()
#define getIDT_BASE() c_getIDT_BASE()
#define getLDT_BASE() c_getLDT_BASE()
#define getTR_BASE()  c_getTR_BASE()
#define getGDT_LIMIT() c_getGDT_LIMIT()
#define getIDT_LIMIT() c_getIDT_LIMIT()
#define getLDT_LIMIT() c_getLDT_LIMIT()
#define getTR_LIMIT()  c_getTR_LIMIT()
#define getLDT_SELECTOR() c_getLDT_SELECTOR()
#define getTR_SELECTOR()  c_getTR_SELECTOR()

#ifdef CPU_PRIVATE

IMPORT void c_setGDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setIDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setLDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setTR_BASE	IPT1(sys_addr, val);
IMPORT void c_setGDT_LIMIT	IPT1(word, val);
IMPORT void c_setIDT_LIMIT	IPT1(word, val);
IMPORT void c_setLDT_LIMIT	IPT1(word, val);
IMPORT void c_setTR_LIMIT	IPT1(word, val);
IMPORT void c_setLDT_SELECTOR	IPT1(word, val);
IMPORT void c_setTR_SELECTOR	IPT1(word, val);

#define setGDT_BASE(x) c_setGDT_BASE(x)
#define setIDT_BASE(x) c_setIDT_BASE(x)
#define setLDT_BASE(x) c_setLDT_BASE(x)
#define setTR_BASE(x)  c_setTR_BASE(x)
#define setGDT_LIMIT(x) c_setGDT_LIMIT(x)
#define setIDT_LIMIT(x) c_setIDT_LIMIT(x)
#define setLDT_LIMIT(x) c_setLDT_LIMIT(x)
#define setTR_LIMIT(x)  c_setTR_LIMIT(x)
#define setLDT_SELECTOR(x) c_setLDT_SELECTOR(x)
#define setTR_SELECTOR(x)  c_setTR_SELECTOR(x)

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Current Privilege Level.                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef CPU_PRIVATE

IMPORT INT c_getCPL	IPT0();
IMPORT VOID c_setCPL	IPT1(INT, val);

#define getCPL() c_getCPL()
#define setCPL(x) c_setCPL(x)

#endif /* CPU_PRIVATE */

#endif /* CCPU_MAIN */

#endif /* CCPU */

#ifdef A3CPU

/*
 *	Function imports...
 */

/*
 *	cpu_init() - Initialises the 3.0 CPU.
 */

IMPORT VOID		a3_cpu_init();

/*
 *	cpu_interrupt() - Interrupts the 3.0 CPU.
 */
#ifdef SWITCHED_CPU
IMPORT VOID		a3_cpu_interrupt IPT2(CPU_INT_TYPE, type, IU16, number);
#else
IMPORT VOID		a3_cpu_interrupt();
#endif

/*
 *	cpu_simulate() - Performs INTEL CPU emulation.
 */
IMPORT VOID		_asm_simulate();

IMPORT VOID		a3_cpu_q_ev_set_count();
IMPORT ULONG		a3_cpu_q_ev_get_count();

#ifndef SWITCHED_CPU

IMPORT ULONG		a3_cpu_calc_q_ev_inst_for_time();

/*
 *	cpu_EOA_hook() - Resets the 3.0 CPU prior to running the next application.
 */
IMPORT VOID		a3_cpu_EOA_hook();

/*
 *	cpu_terminate() - Closes down the CPU.
 */
IMPORT VOID		a3_cpu_terminate();

IMPORT VOID C_garbage_collect_odd_based_selectors IFN0();

/*
 *	Intel register Access...
 */

#ifdef NTVDM
IMPORT half_word        getAL();
IMPORT half_word        getBL();
IMPORT half_word        getCL();
IMPORT half_word        getDL();
IMPORT half_word        getAH();
IMPORT half_word        getBH();
IMPORT half_word        getCH();
IMPORT half_word        getDH();

IMPORT word             getAX();
IMPORT word             getBX();
IMPORT word             getCX();
IMPORT word             getDX();
IMPORT word             getSP();
IMPORT word             getBP();
IMPORT word             getSI();
IMPORT word             getDI();

IMPORT word             getIP();

IMPORT word             getCS();
IMPORT word             getDS();
IMPORT word             getES();
IMPORT word             getSS();

IMPORT word             getAF();
IMPORT word             getCF();
IMPORT word             getDF();
IMPORT word             getIF();
IMPORT word		a3_getIOPL();
IMPORT word		a3_getNT();
IMPORT word             getOF();
IMPORT word             getPF();
IMPORT word             getSF();
IMPORT word             getTF();
IMPORT word             getZF();

IMPORT word		a3_getSTATUS();

IMPORT word		a3_getEM();
IMPORT word		a3_getMP();
IMPORT word		a3_getPE();
IMPORT word		a3_getTS();

IMPORT word             getMSW();

IMPORT sys_addr		a3_getGDT_BASE();
IMPORT word		a3_getGDT_LIMIT();

IMPORT sys_addr		a3_getIDT_BASE();
IMPORT word		a3_getIDT_LIMIT();

IMPORT sys_addr		a3_getLDT_BASE();
IMPORT word		a3_getLDT_LIMIT();
IMPORT word		a3_getLDT_SELECTOR();

IMPORT sys_addr		a3_getTR_BASE();
IMPORT word		a3_getTR_LIMIT();
IMPORT word		a3_getTR_SELECTOR();

IMPORT VOID             setAL();
IMPORT VOID             setCL();
IMPORT VOID             setDL();
IMPORT VOID             setBL();
IMPORT VOID             setAH();
IMPORT VOID             setCH();
IMPORT VOID             setDH();
IMPORT VOID             setBH();

IMPORT VOID             setAX();
IMPORT VOID             setCX();
IMPORT VOID             setDX();
IMPORT VOID             setBX();
IMPORT VOID             setSP();
IMPORT VOID             setBP();
IMPORT VOID             setSI();
IMPORT VOID             setDI();

IMPORT VOID             setIP();

IMPORT INT              setES();
IMPORT INT              setCS();
IMPORT INT              setSS();
IMPORT INT              setDS();

IMPORT VOID             setCF();
IMPORT VOID             setPF();
IMPORT VOID             setAF();
IMPORT VOID             setZF();
IMPORT VOID             setSF();
IMPORT VOID             setTF();
IMPORT VOID             setIF();
IMPORT VOID             setDF();
IMPORT VOID             setOF();
IMPORT VOID		a3_setIOPL();
IMPORT VOID             a3_setNT();


#else
IMPORT half_word	a3_getAL();
IMPORT half_word	a3_getBL();
IMPORT half_word	a3_getCL();
IMPORT half_word	a3_getDL();
IMPORT half_word	a3_getAH();
IMPORT half_word	a3_getBH();
IMPORT half_word	a3_getCH();
IMPORT half_word	a3_getDH();

IMPORT word		a3_getAX();
IMPORT word		a3_getBX();
IMPORT word		a3_getCX();
IMPORT word		a3_getDX();
IMPORT word		a3_getSP();
IMPORT word		a3_getBP();
IMPORT word		a3_getSI();
IMPORT word		a3_getDI();

IMPORT word		a3_getIP();

IMPORT word		a3_getCS();
IMPORT word		a3_getDS();
IMPORT word		a3_getES();
IMPORT word		a3_getSS();

IMPORT word		a3_getAF();
IMPORT word		a3_getCF();
IMPORT word		a3_getDF();
IMPORT word		a3_getIF();
IMPORT word		a3_getIOPL();
IMPORT word		a3_getNT();
IMPORT word		a3_getOF();
IMPORT word		a3_getPF();
IMPORT word		a3_getSF();
IMPORT word		a3_getTF();
IMPORT word		a3_getZF();

IMPORT word		a3_getSTATUS();

IMPORT word		a3_getEM();
IMPORT word		a3_getMP();
IMPORT word		a3_getPE();
IMPORT word		a3_getTS();

IMPORT word		a3_getMSW();

IMPORT sys_addr		a3_getGDT_BASE();
IMPORT word		a3_getGDT_LIMIT();

IMPORT sys_addr		a3_getIDT_BASE();
IMPORT word		a3_getIDT_LIMIT();

IMPORT sys_addr		a3_getLDT_BASE();
IMPORT word		a3_getLDT_LIMIT();
IMPORT word		a3_getLDT_SELECTOR();

IMPORT sys_addr		a3_getTR_BASE();
IMPORT word		a3_getTR_LIMIT();
IMPORT word		a3_getTR_SELECTOR();

IMPORT VOID		a3_setAL();
IMPORT VOID		a3_setCL();
IMPORT VOID		a3_setDL();
IMPORT VOID		a3_setBL();
IMPORT VOID		a3_setAH();
IMPORT VOID		a3_setCH();
IMPORT VOID		a3_setDH();
IMPORT VOID		a3_setBH();

IMPORT VOID		a3_setAX();
IMPORT VOID		a3_setCX();
IMPORT VOID		a3_setDX();
IMPORT VOID		a3_setBX();
IMPORT VOID		a3_setSP();
IMPORT VOID		a3_setBP();
IMPORT VOID		a3_setSI();
IMPORT VOID		a3_setDI();

IMPORT VOID		a3_setIP();

IMPORT INT		a3_setES();
IMPORT INT		a3_setCS();
IMPORT INT		a3_setSS();
IMPORT INT		a3_setDS();

IMPORT VOID		a3_setCF();
IMPORT VOID		a3_setPF();
IMPORT VOID		a3_setAF();
IMPORT VOID		a3_setZF();
IMPORT VOID		a3_setSF();
IMPORT VOID		a3_setTF();
IMPORT VOID		a3_setIF();
IMPORT VOID		a3_setDF();
IMPORT VOID		a3_setOF();
IMPORT VOID		a3_setIOPL();
IMPORT VOID             a3_setNT();
#endif /* NTVDM */


#ifdef CPU_PRIVATE

IMPORT word		a3_p_getCPL();
IMPORT word		a3_p_getES_SELECTOR();
IMPORT sys_addr		a3_p_getES_BASE();
IMPORT word		a3_p_getES_LIMIT();
IMPORT half_word	a3_p_getES_AR();
IMPORT VOID		a3_p_setES_SELECTOR();
IMPORT VOID		a3_p_setES_BASE();
IMPORT VOID		a3_p_setES_LIMIT();
IMPORT VOID		a3_p_setES_AR();
IMPORT word		a3_p_getCS_SELECTOR();
IMPORT sys_addr		a3_p_getCS_BASE();
IMPORT word		a3_p_getCS_LIMIT();
IMPORT half_word	a3_p_getCS_AR();
IMPORT VOID		a3_p_setCS_SELECTOR();
IMPORT VOID		a3_p_setCS_BASE();
IMPORT VOID		a3_p_setCS_LIMIT();
IMPORT VOID		a3_p_setCS_AR();
IMPORT word		a3_p_getDS_SELECTOR();
IMPORT sys_addr		a3_p_getDS_BASE();
IMPORT word		a3_p_getDS_LIMIT();
IMPORT half_word	a3_p_getDS_AR();
IMPORT VOID		a3_p_setDS_SELECTOR();
IMPORT VOID		a3_p_setDS_BASE();
IMPORT VOID		a3_p_setDS_LIMIT();
IMPORT VOID		a3_p_setDS_AR();
IMPORT word		a3_p_getSS_SELECTOR();
IMPORT sys_addr		a3_p_getSS_BASE();
IMPORT word		a3_p_getSS_LIMIT();
IMPORT half_word	a3_p_getSS_AR();
IMPORT VOID		a3_p_setSS_SELECTOR();
IMPORT VOID		a3_p_setSS_BASE();
IMPORT VOID		a3_p_setSS_LIMIT();
IMPORT VOID		a3_p_setSS_AR();
IMPORT VOID		a3_p_setPE();
IMPORT VOID		a3_p_setMP();
IMPORT VOID		a3_p_setEM();
IMPORT VOID		a3_p_setTS();
IMPORT VOID		a3_p_setMSW();
IMPORT VOID		a3_p_setCPL();
IMPORT VOID		a3_p_setGDT_BASE();
IMPORT VOID		a3_p_setGDT_LIMIT();
IMPORT VOID		a3_p_setIDT_BASE();
IMPORT VOID		a3_p_setIDT_LIMIT();
IMPORT VOID		a3_p_setLDT_SELECTOR();
IMPORT VOID		a3_p_setLDT_BASE();
IMPORT VOID		a3_p_setLDT_LIMIT();
IMPORT VOID		a3_p_setTR_SELECTOR();
IMPORT VOID		a3_p_setTR_BASE();
IMPORT VOID		a3_p_setTR_LIMIT();

#endif /* CPU_PRIVATE */
#endif /* SWITCHED_CPU */


/*
 *	Macro definitions...
 */

#define cpu_init		a3_cpu_init
#define cpu_simulate		_asm_simulate
#define	host_q_ev_set_count	a3_cpu_q_ev_set_count
#define	host_q_ev_get_count	a3_cpu_q_ev_get_count
#ifndef host_calc_q_ev_inst_for_time
#define	host_calc_q_ev_inst_for_time	a3_cpu_calc_q_ev_inst_for_time
#endif /* host_calc_q_ev_inst_for_time */
#define cpu_EOA_hook		a3_cpu_EOA_hook
#define cpu_terminate		a3_cpu_terminate

/*
 *	Intel register Access...
 */

#ifndef getAX

#define cpu_interrupt		a3_cpu_interrupt

#ifdef NTVDM

#define getIOPL		a3_getIOPL
#define getNT		a3_getNT
#define getSTATUS	a3_getSTATUS
#define getEM		a3_getEM
#define getMP		a3_getMP
#define getPE		a3_getPE
#define getTS		a3_getTS
#define getGDT_BASE	a3_getGDT_BASE
#define getGDT_LIMIT	a3_getGDT_LIMIT
#define getIDT_BASE	a3_getIDT_BASE
#define getIDT_LIMIT	a3_getIDT_LIMIT
#define getLDT_BASE	a3_getLDT_BASE
#define getLDT_LIMIT	a3_getLDT_LIMIT
#define getLDT_SELECTOR	a3_getLDT_SELECTOR
#define getTR_BASE	a3_getTR_BASE
#define getTR_LIMIT	a3_getTR_LIMIT
#define getTR_SELECTOR	a3_getTR_SELECTOR
#define setIOPL		a3_setIOPL
#define setNT		a3_setNT


#else

#define getAL		a3_getAL
#define getBL		a3_getBL
#define getCL		a3_getCL
#define getDL		a3_getDL
#define getAH		a3_getAH
#define getBH		a3_getBH
#define getCH		a3_getCH
#define getDH		a3_getDH
#define getAX		a3_getAX
#define getBX		a3_getBX
#define getCX		a3_getCX
#define getDX		a3_getDX
#define getSP		a3_getSP
#define getBP		a3_getBP
#define getSI		a3_getSI
#define getDI		a3_getDI
#define getIP		a3_getIP
#define getCS		a3_getCS
#define getDS		a3_getDS
#define getES		a3_getES
#define getSS		a3_getSS
#define getAF		a3_getAF
#define getCF		a3_getCF
#define getDF		a3_getDF
#define getIF		a3_getIF
#define getIOPL		a3_getIOPL
#define getNT		a3_getNT
#define getOF		a3_getOF
#define getPF		a3_getPF
#define getSF		a3_getSF
#define getTF		a3_getTF
#define getZF		a3_getZF
#define getSTATUS	a3_getSTATUS
#define getEM		a3_getEM
#define getMP		a3_getMP
#define getPE		a3_getPE
#define getTS		a3_getTS
#define getMSW		a3_getMSW
#define getGDT_BASE	a3_getGDT_BASE
#define getGDT_LIMIT	a3_getGDT_LIMIT
#define getIDT_BASE	a3_getIDT_BASE
#define getIDT_LIMIT	a3_getIDT_LIMIT
#define getLDT_BASE	a3_getLDT_BASE
#define getLDT_LIMIT	a3_getLDT_LIMIT
#define getLDT_SELECTOR	a3_getLDT_SELECTOR
#define getTR_BASE	a3_getTR_BASE
#define getTR_LIMIT	a3_getTR_LIMIT
#define getTR_SELECTOR	a3_getTR_SELECTOR
#define setAL		a3_setAL
#define setCL		a3_setCL
#define setDL		a3_setDL
#define setBL		a3_setBL
#define setAH		a3_setAH
#define setCH		a3_setCH
#define setDH		a3_setDH
#define setBH		a3_setBH
#define setAX		a3_setAX
#define setCX		a3_setCX
#define setDX		a3_setDX
#define setBX		a3_setBX
#define setSP		a3_setSP
#define setBP		a3_setBP
#define setSI		a3_setSI
#define setDI		a3_setDI
#define setIP		a3_setIP
#define setES		a3_setES
#define setCS		a3_setCS
#define setSS		a3_setSS
#define setDS		a3_setDS
#define setCF		a3_setCF
#define setPF		a3_setPF
#define setAF		a3_setAF
#define setZF		a3_setZF
#define setSF		a3_setSF
#define setTF		a3_setTF
#define setIF		a3_setIF
#define setDF		a3_setDF
#define setOF		a3_setOF
#define setIOPL		a3_setIOPL
#define setNT		a3_setNT

#endif	/* NTVDM */

#endif /* getAX */

#ifdef CPU_PRIVATE

#define getCPL		a3_p_getCPL
#define getES_SELECTOR	a3_p_getES_SELECTOR
#define getCS_SELECTOR	a3_p_getCS_SELECTOR
#define getSS_SELECTOR	a3_p_getSS_SELECTOR
#define getDS_SELECTOR	a3_p_getDS_SELECTOR
#define getES_BASE	a3_p_getES_BASE
#define getCS_BASE	a3_p_getCS_BASE
#define getDS_BASE	a3_p_getDS_BASE
#define getSS_BASE	a3_p_getSS_BASE
#define getES_LIMIT	a3_p_getES_LIMIT
#define getCS_LIMIT	a3_p_getCS_LIMIT
#define getDS_LIMIT	a3_p_getDS_LIMIT
#define getSS_LIMIT	a3_p_getSS_LIMIT
#define getES_AR	a3_p_getES_AR
#define getCS_AR	a3_p_getCS_AR
#define getDS_AR	a3_p_getDS_AR
#define getSS_AR	a3_p_getSS_AR
#define setES_SELECTOR	a3_p_setES_SELECTOR
#define setCS_SELECTOR	a3_p_setCS_SELECTOR
#define setSS_SELECTOR	a3_p_setSS_SELECTOR
#define setDS_SELECTOR	a3_p_setDS_SELECTOR
#define setES_BASE	a3_p_setES_BASE
#define setCS_BASE	a3_p_setCS_BASE
#define setDS_BASE	a3_p_setDS_BASE
#define setSS_BASE	a3_p_setSS_BASE
#define setES_LIMIT	a3_p_setES_LIMIT
#define setCS_LIMIT	a3_p_setCS_LIMIT
#define setDS_LIMIT	a3_p_setDS_LIMIT
#define setSS_LIMIT	a3_p_setSS_LIMIT
#define setES_AR	a3_p_setES_AR
#define setCS_AR	a3_p_setCS_AR
#define setDS_AR	a3_p_setDS_AR
#define setSS_AR	a3_p_setSS_AR
#define setPE		a3_p_setPE
#define setMP		a3_p_setMP
#define setEM		a3_p_setEM
#define setTS		a3_p_setTS
#define setMSW		a3_p_setMSW
#define setCPL		a3_p_setCPL
#define setGDT_BASE	a3_p_setGDT_BASE
#define setGDT_LIMIT	a3_p_setGDT_LIMIT
#define setIDT_BASE	a3_p_setIDT_BASE
#define setIDT_LIMIT	a3_p_setIDT_LIMIT
#define setLDT_SELECTOR	a3_p_setLDT_SELECTOR
#define setLDT_BASE	a3_p_setLDT_BASE
#define setLDT_LIMIT	a3_p_setLDT_LIMIT
#define setTR_SELECTOR	a3_p_setTR_SELECTOR
#define setTR_BASE	a3_p_setTR_BASE
#define setTR_LIMIT	a3_p_setTR_LIMIT

#endif /* CPU_PRIVATE */
#else
extern IU8  getIOPL();
extern IBOOL getNT();
extern IBOOL getTS();
extern IBOOL getEM();
extern IBOOL getMP();
extern word getCPL();
extern IU32 getEFLAGS();
extern IU32 getFLAGS();

#endif /* A3CPU */

#else /* CPU_30_STYLE */

/*
 * CPU Data Area
 * These externs are given before host_cpu.h is included so that the
 * variables may be gathreed into a structure and the externs overridden
* by #defines in host_cpu.h
 */

extern	word protected_mode;   /* =0 no proteced mode warning given
       		                   =1 proteced mode warning given */
extern  word            cpu_interrupt_map;
extern  half_word       cpu_int_translate[];
extern  word            cpu_int_delay;
extern  half_word       ica_lock;
extern  void            (*(jump_ptrs[]))();
extern  void            (*(b_write_ptrs[]))();
extern  void            (*(w_write_ptrs[]))();
extern  void            (*(b_fill_ptrs[]))();
extern  void            (*(w_fill_ptrs[]))();
#ifdef EGATEST
extern  void            (*(b_fwd_move_ptrs[]))();
extern  void            (*(w_fwd_move_ptrs[]))();
extern  void            (*(b_bwd_move_ptrs[]))();
extern  void            (*(w_bwd_move_ptrs[]))();
#else
extern  void            (*(b_move_ptrs[]))();
extern  void            (*(w_move_ptrs[]))();
#endif /* EGATEST */
extern  half_word       *haddr_of_src_string;

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * The cpu opcode sliding frame
 */

#ifdef BACK_M
typedef struct
{
                half_word FOURTH_BYTE;
                half_word THIRD_BYTE;
                half_word SECOND_BYTE;
                half_word OPCODE;
}  OPCODE_FRAME;

typedef struct
{
                signed_char FOURTH_BYTE;
                signed_char THIRD_BYTE;
                signed_char SECOND_BYTE;
                signed_char OPCODE;
}  SIGNED_OPCODE_FRAME;
#else
typedef struct
{
                half_word OPCODE;
                half_word SECOND_BYTE;
                half_word THIRD_BYTE;
                half_word FOURTH_BYTE;
}  OPCODE_FRAME;

typedef struct
{
                signed_char OPCODE;
                signed_char SECOND_BYTE;
                signed_char THIRD_BYTE;
                signed_char FOURTH_BYTE;
}  SIGNED_OPCODE_FRAME;
#endif /* BACK_M */

/*
 * The new ICA uses the following for H/W ints:
 */

#define CPU_HW_INT		0
#define CPU_HW_INT_MASK		(1 << CPU_HW_INT)

/*
 * CPU software interrupt definitions
 */

#define CPU_SW_INT              8
#define CPU_SW_INT_MASK         (1 << CPU_SW_INT)

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern OPCODE_FRAME *opcode_frame;	/* C CPU and dasm only		    */

/*
 * External declarations for the 80286 registers
 */

extern reg A;           /* Accumulator          */
extern reg B;           /* Base                 */
extern reg C;           /* Count                */
extern reg D;           /* Data                 */
extern reg SP;          /* Stack Pointer        */
extern reg BP;          /* Base pointer         */
extern reg SI;          /* Source Index         */
extern reg DI;          /* Destination Index    */
extern reg IP;          /* Instruction Pointer  */
extern reg CS;          /* Code Segment         */
extern reg DS;          /* Data Segment         */
extern reg SS;          /* Stack Segment        */
extern reg ES;          /* Extra Segment        */

/*
 * External function declarations. These may be defined to other things.
 */

#ifndef	host_simulate
extern void host_simulate	IPT0();
#endif	/* host_simulate */

#ifndef	host_cpu_reset
extern void host_cpu_reset	IPT0();
#endif	/* host_cpu_reset */

#ifndef	host_cpu_init
extern void host_cpu_init	IPT0();
#endif	/* host_cpu_init */

#ifndef	host_cpu_interrupt
extern void host_cpu_interrupt	IPT0();
#endif	/* host_cpu_interrupt */

/*
 * Definition of Descriptor Table
 */

#ifdef BIGEND

union sixteenbits
{
	word X;

	struct
	{
		half_word lower;
		half_word upper;
	} word;
};

#endif	/* BIGEND */

#ifdef LITTLEND

union sixteenbits
{
	word X;

	struct
	{
		half_word upper;
		half_word lower;
	} word;
};

#endif	/* LITTLEND */

struct DESC_TABLE
{
	union sixteenbits misc;
	union sixteenbits base;
	union sixteenbits limit;
};

#define CPU_SIGALRM_EXCEPTION           15              /* SIGALRM signal
*/
#define CPU_SIGALRM_EXCEPTION_MASK      (1 << CPU_SIGALRM_EXCEPTION)

#define CPU_TRAP_EXCEPTION              11              /* TRAP FLAG
*/
#define CPU_TRAP_EXCEPTION_MASK         (1 << CPU_TRAP_EXCEPTION)

#define CPU_YODA_EXCEPTION              13              /* YODA FLAG
*/
#define CPU_YODA_EXCEPTION_MASK         (1 << CPU_YODA_EXCEPTION)

#define CPU_SIGIO_EXCEPTION             14              /* SIGIO FLAG
*/
#define CPU_SIGIO_EXCEPTION_MASK        (1 << CPU_SIGIO_EXCEPTION)

#define CPU_RESET_EXCEPTION             12              /* RESET FLAG
*/
#define CPU_RESET_EXCEPTION_MASK        (1 << CPU_RESET_EXCEPTION)

#ifdef CCPU

IMPORT void sw_host_simulate IPT0();
IMPORT int selector_outside_table IPT2(word, selector, sys_addr *, descr_addr);
IMPORT void cpu_init IPT0();

/*
   Define descriptor 'super' types.
 */
#define INVALID				0x00
#define AVAILABLE_TSS			0x01
#define LDT_SEGMENT			0x02
#define BUSY_TSS			0x03
#define CALL_GATE			0x04
#define TASK_GATE			0x05
#define INTERRUPT_GATE			0x06
#define TRAP_GATE			0x07
#define EXPANDUP_READONLY_DATA		0x11
#define EXPANDUP_WRITEABLE_DATA		0x13
#define EXPANDDOWN_READONLY_DATA	0x15
#define EXPANDDOWN_WRITEABLE_DATA	0x17
#define NONCONFORM_NOREAD_CODE		0x19
#define NONCONFORM_READABLE_CODE	0x1b
#define CONFORM_NOREAD_CODE		0x1d
#define CONFORM_READABLE_CODE		0x1f

/* Code Segment (Private) */
extern half_word CS_AR;
extern sys_addr  CS_base;
extern word      CS_limit;

/* Data Segment (Private) */
extern half_word DS_AR;
extern sys_addr  DS_base;
extern word      DS_limit;

/* Stack Segment (Private) */
extern half_word SS_AR;
extern sys_addr  SS_base;
extern word      SS_limit;

/* Extra Segment (Private) */
extern half_word ES_AR;
extern sys_addr  ES_base;
extern word      ES_limit;

/* Local Descriptor Table Register (Private) */
extern sys_addr LDTR_base;  /* Base Address */
extern word     LDTR_limit; /* Segment 'size' */

/* Task Register (Private) */
extern sys_addr TR_base;  /* Base Address */
extern word     TR_limit; /* Segment 'size' */

/* Interrupt status, defines any abnormal processing */
extern int doing_contributory;
extern int doing_double_fault;

/* HOST - decoded access rights */
extern int ALC_CS;
extern int ALC_DS;
extern int ALC_ES;
extern int ALC_SS;

#define X_REAL 0
#define C_UPRO 1
#define C_DNRO 6
#define C_PROT 2
#define C_UPRW 7
#define C_DNRW 8
#define S_UP   3
#define S_DOWN 4
#define S_BAD  5
#define D_CODE 1
#define D_UPRO 1
#define D_DNRO 6
#define D_UPRW 7
#define D_DNRW 8
#define D_BAD  2

/*
 *
 *******************************************************************
 * The 'C' cpu register access functions.             		   *
 *******************************************************************
 *
 */

#define getCS_SELECTOR()	CS.X
#define getDS_SELECTOR()	DS.X
#define getSS_SELECTOR()	SS.X
#define getES_SELECTOR()	ES.X

#define getCS_AR()		CS_AR
#define getDS_AR()		DS_AR
#define getSS_AR()		SS_AR
#define getES_AR()		ES_AR

#define getCS_BASE()		CS_base
#define getDS_BASE()		DS_base
#define getSS_BASE()		SS_base
#define getES_BASE()		ES_base

#define getCS_LIMIT()		CS_limit
#define getDS_LIMIT()		DS_limit
#define getSS_LIMIT()		SS_limit
#define getES_LIMIT()		ES_limit

#define getLDT_BASE()		LDTR_base
#define getLDT_LIMIT()		LDTR_limit

#define getTR_BASE()	        TR_base
#define getTR_LIMIT()	        TR_limit

#define setCS_SELECTOR(val)	CS.X     = val
#define setDS_SELECTOR(val)	DS.X     = val
#define setSS_SELECTOR(val)	SS.X     = val
#define setES_SELECTOR(val)	ES.X     = val

#define setCS_AR(val)		CS_AR    = val
#define setDS_AR(val)		DS_AR    = val
#define setSS_AR(val)		SS_AR    = val
#define setES_AR(val)		ES_AR    = val

#define setCS_BASE(val)		CS_base  = val
#define setDS_BASE(val)		DS_base  = val
#define setSS_BASE(val)		SS_base  = val
#define setES_BASE(val)		ES_base  = val

#define setCS_LIMIT(val)	CS_limit = val
#define setDS_LIMIT(val)	DS_limit = val
#define setSS_LIMIT(val)	SS_limit = val
#define setES_LIMIT(val)	ES_limit = val

#define setLDT_BASE(val)	LDTR_base  = val
#define setLDT_LIMIT(val)	LDTR_limit = val

#define setTR_BASE(val)		TR_base  = val
#define setTR_LIMIT(val)	TR_limit = val
/*
 * The Machine Status Word structure
 */
typedef struct
{
     unsigned int :16;
     unsigned int reserved:12;
     unsigned int TS:1;
     unsigned int EM:1;
     unsigned int MP:1;
     unsigned int PE:1;
} mreg;

extern sys_addr address_line_mask;

extern int       CPL;   /* Current Privilege Level */

/* Global Descriptor Table Register */
extern sys_addr GDTR_base;  /* Base Address */
extern word     GDTR_limit; /* Segment 'size' */

/* Interrupt Descriptor Table Register */
extern sys_addr IDTR_base;  /* Base Address */
extern word     IDTR_limit; /* Segment 'size' */

/* Local Descriptor Table Register */
extern reg  LDTR;       /* Selector */

/* Task Register */
extern reg  TR;       /* Selector */

extern mreg MSW;     /* Machine Status Word */

extern int STATUS_CF;
extern int STATUS_SF;
extern int STATUS_ZF;
extern int STATUS_AF;
extern int STATUS_OF;
extern int STATUS_PF;
extern int STATUS_TF;
extern int STATUS_IF;
extern int STATUS_DF;
extern int STATUS_NT;
extern int STATUS_IOPL;

/*
**==========================================================================
** The CCPU basic register access macros. These may be overridden in
** host-cpu.h.
**==========================================================================
*/

#ifndef	getAX

/* READ functions  */
#define  getAX()	(A.X)
#define	 getAH()	(A.byte.high)
#define	 getAL()	(A.byte.low)
#define	 getBX()	(B.X)
#define	 getBH()	(B.byte.high)
#define	 getBL()	(B.byte.low)
#define	 getCX()	(C.X)
#define	 getCH()	(C.byte.high)
#define	 getCL()	(C.byte.low)
#define	 getDX()	(D.X)
#define	 getDH()	(D.byte.high)
#define	 getDL()	(D.byte.low)
#define	 getSP()	(SP.X)
#define	 getBP()	(BP.X)
#define	 getSI()	(SI.X)
#define	 getDI()	(DI.X)
#define	 getIP()	(IP.X)
#define	 getCS()	(CS.X)
#define	 getDS()	(DS.X)
#define	 getES()	(ES.X)
#define	 getSS()	(SS.X)
#define	 getMSW()	(m_s_w)
#define	 getDF()	(STATUS_DF)
#define	 getIF()	(STATUS_IF)
#define	 getTF()	(STATUS_TF)
#define	 getPF()	(STATUS_PF)
#define	 getAF()	(STATUS_AF)
#define	 getSF()	(STATUS_SF)
#define	 getZF()	(STATUS_ZF)
#define	 getOF()	(STATUS_OF)
#define	 getCF()    	(STATUS_CF)

#define getCPL()		(CPL)
#define getGDT_BASE()		(GDTR_base)
#define getGDT_LIMIT()		(GDTR_limit)
#define getIDT_BASE()		(IDTR_base)
#define getIDT_LIMIT()		(IDTR_limit)
#define getLDT_SELECTOR()		(LDTR.X)
#define getTR_SELECTOR()			(TR.X)
#define getMSW_reserved()	(MSW.reserved)
#define getTS()		(MSW.TS)
#define getEM()		(MSW.EM)
#define getMP()		(MSW.MP)
#define getPE()		(MSW.PE)
#define getNT()		(STATUS_NT)
#define getIOPL()	(STATUS_IOPL)
#define	 getSTATUS() 	(getCF()        |	\
			getOF()   << 11 |	\
			getZF()   << 6  |	\
			getSF()   << 7  |	\
			getAF()   << 4  |	\
			getPF()   << 2  |	\
			getTF()   << 8  |	\
			getIF()   << 9  |	\
			getDF()   << 10 |	\
			getIOPL() << 12 |	\
			getNT()   << 14)

extern	ext_load_CS();
extern	ext_load_DS();
extern	ext_load_ES();
extern	ext_load_SS();

/* WRITE functions  */
#define  setAX(val)	(A.X = (val))
#define	 setAH(val)	(A.byte.high = (val))
#define	 setAL(val)	(A.byte.low = (val))
#define	 setBX(val)	(B.X = (val))
#define	 setBH(val)	(B.byte.high = (val))
#define	 setBL(val)	(B.byte.low = (val))
#define	 setCX(val)	(C.X = (val))
#define	 setCH(val)	(C.byte.high = (val))
#define	 setCL(val)	(C.byte.low = (val))
#define	 setDX(val)	(D.X = (val))
#define	 setDH(val)	(D.byte.high = (val))
#define	 setDL(val)	(D.byte.low = (val))
#define	 setSP(val)	(SP.X = (val))
#define	 setBP(val)	(BP.X = (val))
#define	 setSI(val)	(SI.X = (val))
#define	 setDI(val)	(DI.X = (val))
#define	 setIP(val)	(IP.X = (val))
#define	 setCS(val)	ext_load_CS (val)
#define	 setDS(val)	ext_load_DS (val)
#define	 setES(val)	ext_load_ES (val)
#define	 setSS(val)	ext_load_SS (val)
#define	 setMSW(val)	(m_s_w = (val))
#define	 setDF(val)	(STATUS_DF = (val))
#define	 setIF(val)	(STATUS_IF = (val))
#define	 setTF(val)	(STATUS_TF = (val))
#define	 setPF(val)	(STATUS_PF = (val))
#define	 setAF(val)	(STATUS_AF = (val))
#define	 setSF(val)	(STATUS_SF = (val))
#define	 setZF(val)	(STATUS_ZF = (val))
#define	 setOF(val)	(STATUS_OF = (val))
#define	 setCF(val)	(STATUS_CF = (val))

#define setCPL(val)		(CPL = (val))
#define setGDT_BASE(val)	(GDTR_base = (val))
#define setGDT_LIMIT(val)	(GDTR_limit = (val))
#define setIDT_BASE(val)	(IDTR_base = (val))
#define setIDT_LIMIT(val)	(IDTR_limit = (val))
#define setLDT_SELECTOR(val)		(LDTR.X = (val))
#define setTR_SELECTOR(val)		(TR.X = (val))
#define setMSW_reserved(val)	(MSW.reserved = (val))
#define setTS(val)		(MSW.TS = (val))
#define setEM(val)		(MSW.EM = (val))
#define setMP(val)		(MSW.MP = (val))
#define setPE(val)		(MSW.PE = (val))
#define setNT(val)		(STATUS_NT = (val))
#define setIOPL(val)	(STATUS_IOPL = (val))

#else

#endif	/* getAX - default CCPU register access macros */

#endif /* CCPU */

#endif /* CPU_30_STYLE */
#endif /* NTVDM && MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\config.h ===
#ifndef _CONFIG_H
#define _CONFIG_H
/*[
**************************************************************************

	Name:		config.h
	Author:		J.D. Richemont
	Created On:	
	Sccs ID:	@(#)config.h	1.44 04/24/95
	Purpose:	General (base+host) configuration defines + typedefs.

	See SoftPC Version 3.0 Configuration Interface - Design Document

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
	Changing this file by adding a new config type requires some hosts
	to recompile their message catalogs or nls stuff. Don't forget to
	put this in the host impact field on the BCN. Also, please only add
	new config types to the END of the current list, otherwise it is
	a real pain to edit the host catalogs!
WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING

**************************************************************************
]*/

/* Make sure error.h gets included - it is necessary for the typedefs referred
** to from the ANSI declarations.
*/
#ifndef _INS_ERROR_H
#include "error.h"
#endif	/* _INS_ERROR_H */

/* General messages returned from config funcs */

#define C_CONFIG_OP_OK      0	/* General 'all went well' message */
#define C_CONFIG_NOT_VALID -1	/* the config item is not valid */

#define COMMENT_MARK	'#'
#define PAD_CHAR	' '
#define MIN_PAD_LEN	8

/*
 * Below are the definitions of the masks used by with the flags field
 * of the config structure.  Note there are currently four unused bits
 * 0x04 0x08 0x10 and 0x20
 *
 * The first group is used as the config entry type.
 * 
 * C_SYSTEM_ONLY - indicates resource comes from the system config file only
 * C_DO_RESET    - Changing this element by default will cause a SoftPC reboot
 * C_EXPERT_OPTION - If missing from .spcconfig, take default without
 *		asking user.
 */
#define C_TYPE_MASK		((UTINY) 0x03)
#define	C_NAME_RECORD		((UTINY) 0x00)
#define	C_STRING_RECORD		((UTINY) 0x01)
#define	C_NUMBER_RECORD		((UTINY) 0x02)
#define	C_RECORD_DELETE		((UTINY) 0x03)

#define C_EXPERT_OPTION		((UTINY) 0x10)
#define C_INIT_ACTIVE		((UTINY) 0x20)
#define C_SYSTEM_ONLY		((UTINY) 0x40)
#define C_DO_RESET		((UTINY) 0x80)

/* 
 * Note: config processes the Configuration file in hostID order so the
 * ordering of hostIDs is significant.
 *
 * These items are usually system only fields and must be validated
 * before the later config items that refer to them
 *
 * EG if C_EXTEND_MAX_SIZE is not validated before then the check in
 * C_EXTENDED_MEM_SIZE is against whatever max was malloced.
 *
 * =====================================================================
 * 	To avoid backwards compatibility problems,
 *	never change any of the numbers.
 * =====================================================================
 */

#define C_FILE_DEFAULT		0
#ifdef macintosh
#define C_PRINTER_DEFAULT	1
#define C_PLOTTER_DEFAULT	2
#define C_DATACOMM_DEFAULT	4
#else	/* macintosh */
#define C_DEVICE_DEFAULT	1
#endif	/* macintosh */
#define C_PIPE_DEFAULT		3
#define C_DRIVE_MAX_SIZE	5

#define C_EXTEND_MAX_SIZE	6
#define C_EXPAND_MAX_SIZE	7

/* Extended Mem Size validation depends on Extended MAX size */
#define C_EXTENDED_MEM_SIZE	8
#define	C_MEM_SIZE		C_EXTENDED_MEM_SIZE

/* LIM size validation depends on Expanded MAX size */
#define C_LIM_SIZE		9
#define C_MEM_LIMIT		10



/* Spares for hosts to provide their own system only fields which need
** early validation.
*/
#define C_HOST_SYSTEM_0		11
#define	C_HOST_SYSTEM_1		12
#define	C_HOST_SYSTEM_2		13
#define	C_HOST_SYSTEM_3		14
#define	C_HOST_SYSTEM_4		15

#define	C_SECURE		16
#define C_SECURE_MASK           17

#define	C_CDROM_DEVICE		18

#define C_SWITCHNPX		24

#define C_HARD_DISK1_NAME	25
#define C_HARD_DISK2_NAME	26
#define C_FSA_DIRECTORY		27

/*
 * Extra config options used by multiple-HFX
 */
#define C_FSA_DIR_D		28
#define C_FSA_DIR_E		29
#define C_FSA_DIR_F		30
#define C_FSA_DIR_G		31
#define C_FSA_DIR_H		32
#define C_FSA_DIR_I		33
#define C_FSA_DIR_J		34
#define C_FSA_DIR_K		35
#define C_FSA_DIR_L		36
#define C_FSA_DIR_M		37
#define C_FSA_DIR_N		38
#define C_FSA_DIR_O		39
#define C_FSA_DIR_P		40
#define C_FSA_DIR_Q		41
#define C_FSA_DIR_R		42
#define C_FSA_DIR_S		43
#define C_FSA_DIR_T		44
#define C_FSA_DIR_U		45
#define C_FSA_DIR_V		46
#define C_FSA_DIR_W		47
#define C_FSA_DIR_X		48
#define C_FSA_DIR_Y		49
#define C_FSA_DIR_Z		50

#define C_FLOPPY_A_DEVICE	51
#define C_FLOPPY_B_DEVICE	52
#define C_SLAVEPC_DEVICE	53

#define C_GFX_ADAPTER		54
#define C_WIN_SIZE		55

#define C_MSWIN_WIDTH		56
#define C_MSWIN_HEIGHT		57
#define C_MSWIN_COLOURS		58

#define C_SOUND			59

/*
 * All of the lpt hostID's must be kept sequential because
 * the lpt code tends to do (hostID - C_LPT1_NAME)
 * calculations to index into an array of structures.
 */
#define C_LPT1_TYPE		60
#define C_LPT2_TYPE		( C_LPT1_TYPE+1 )	/*61*/
#define C_LPT3_TYPE		( C_LPT1_TYPE+2 )	/*62*/
#define C_LPT4_TYPE		( C_LPT1_TYPE+3 )	/*63*/

#define C_LPT1_NAME		64
#define C_LPT2_NAME		( C_LPT1_NAME+1 )	/*65*/
#define C_LPT3_NAME		( C_LPT1_NAME+2 )	/*66*/
#define C_LPT4_NAME		( C_LPT1_NAME+3 )	/*67*/

#define	C_LPTFLUSH1		68
#define	C_LPTFLUSH2		( C_LPTFLUSH1+1 )	/*69*/
#define	C_LPTFLUSH3		( C_LPTFLUSH1+2 )	/*70*/
#define	C_LPTFLUSH4		( C_LPTFLUSH1+3 )	/*71*/

#define C_FLUSHTIME1		72
#define C_FLUSHTIME2		( C_FLUSHTIME1+1 )	/*73*/
#define C_FLUSHTIME3		( C_FLUSHTIME1+2 )	/*74*/
#define C_FLUSHTIME4		( C_FLUSHTIME1+3 )	/*75*/

#define C_LPT1_OTHER_NAME	76
#define C_LPT2_OTHER_NAME	( C_LPT1_OTHER_NAME+1)	/*77*/
#define C_LPT3_OTHER_NAME	( C_LPT1_OTHER_NAME+2)	/*78*/
#define C_LPT4_OTHER_NAME	( C_LPT1_OTHER_NAME+3)	/*79*/

/* com hostIDs need to be grouped, same reason as lpt hostIDs
 */
#define C_COM1_TYPE		80
#define C_COM2_TYPE		( C_COM1_TYPE+1 )	/*81*/
#define C_COM3_TYPE		( C_COM1_TYPE+2 )	/*82*/
#define C_COM4_TYPE		( C_COM1_TYPE+3 )	/*83*/

#define C_COM1_NAME		84
#define C_COM2_NAME		( C_COM1_NAME+1 )	/*85*/
#define C_COM3_NAME		( C_COM1_NAME+2 )	/*86*/
#define C_COM4_NAME		( C_COM1_NAME+3 )	/*87*/

#define C_COM1_XON		88
#define C_COM2_XON		( C_COM1_XON+1)		/*89*/
#define C_COM3_XON		( C_COM1_XON+2)		/*90*/
#define C_COM4_XON		( C_COM1_XON+3)		/*91*/

#define	C_AUTOFREEZE		92
#define C_AUTOFLUSH		93
#define C_AUTOFLUSH_DELAY	94
#define	C_KEYBD_MAP		95

#define C_DOS_CMD		96

#define C_SOUND_DEVICE		97
#define C_SOUND_LEVEL		98

#define C_RODISK_PANEL		99


#define C_HU_FILENAME		100
#define C_HU_MODE		101
#define C_HU_BIOS	        102
#define C_HU_REPORT		103
#define C_HU_SDTYPE		104
#define C_HU_CHKMODE		105
#define C_HU_CHATTR		106
#define C_HU_SETTLNO		107
#define C_HU_FUDGENO		108
#define C_HU_DELAY		109
#define C_HU_GFXERR		110
#define C_HU_TS			111
#define C_HU_NUM		112

/* Strings for Boolean value - we allow for 6 possibilities */

#define C_BOOL_VALUES		113 /* to 118 */

/* COMMS adapter destination types */

#define ADAPTER_TYPE_FILE	119
#define ADAPTER_TYPE_PRINTER	120
#define ADAPTER_TYPE_PLOTTER	121
#define ADAPTER_TYPE_PIPE	122
#define ADAPTER_TYPE_DATACOMM	123
#define ADAPTER_TYPE_NULL	124
#define ADAPTER_TYPE_DEVICE	125

#define C_MSWIN_RESIZE		126

/* Enable Windows PostScript printer flushing */

#define C_LPT1_PSFLUSH		127
#define C_LPT2_PSFLUSH		(C_LPT1_PSFLUSH + 1)
#define C_LPT3_PSFLUSH		(C_LPT2_PSFLUSH + 1)
#define C_LPT4_PSFLUSH		(C_LPT3_PSFLUSH + 1)

#define C_COM1_PSFLUSH		131
#define C_COM2_PSFLUSH		(C_COM1_PSFLUSH + 1)
#define C_COM3_PSFLUSH		(C_COM2_PSFLUSH + 1)
#define C_COM4_PSFLUSH		(C_COM3_PSFLUSH + 1)


#if !defined(NTVDM) && !defined(macintosh)
#define C_CMOS			135
#endif

#if defined(NTVDM)
#define C_VDMLPT1_NAME		140
#define C_VDMLPT2_NAME		(C_VDMLPT1_NAME + 1)
#define C_VDMLPT3_NAME		(C_VDMLPT1_NAME + 2)
#define C_COM_SYNCWRITE 	C_VDMLPT3_NAME + 1
#define C_COM_TXBUFFER_SIZE	C_COM_SYNCWRITE + 1
#endif


/* Host-specific entries in the message catalogue start at
 * the following number plus 1 - note that the value must
 * fit into an IU8, so 255 is an upper limit
 */
#define LAST_BASE_CONFIG_DEFINE	240



/* Names of runtime vars that host_runtime_set/_inquire() will use.
 * These do not appear in the message catalogue anywhere.
 */
typedef enum
{
         C_NPX_ENABLED=0,	C_HD1_CYLS,	C_HD2_CYLS,
	 C_AUTOFLUSH_ON,	C_LPTFLUSH1_ON,	C_LPTFLUSH2_ON,
	 C_LPTFLUSH3_ON,	C_COM1_FLOW,	C_COM2_FLOW,
	 C_COM3_FLOW,		C_COM4_FLOW,	C_SOUND_ON,
	 C_MOUSE_ATTACHED,	C_FLOPPY_SERVER,
	 C_COM1_ATTACHED,	C_COM2_ATTACHED,
	 C_DRIVEC_ATTACHED,	C_DRIVED_ATTACHED,
	 C_LAST_RUNTIME
} RuntimeEnum;

/*********** Definitions for states of things **************/

/* Graphics adapter types */

#define NO_ADAPTOR      0xff
#define MDA             0
#define CGA             1
#define CGA_MONO        2
#define EGA             3
#define HERCULES        4
#define VGA             5


/* Floppy drive states
 * This is only used by the system that mainatins the interloack between
 * slave PC and a real device emulation
 */
#define GFI_REAL_DISKETTE_SERVER     0
#define GFI_SLAVE_SERVER             1    /* Please always be last */


/*************** Structure definitions ******************/

typedef struct 
{
	CHAR string[MAXPATHLEN];
	SHORT index;
	BOOL rebootReqd;
} ConfigValues;

typedef struct
{
	CHAR *string;
	SHORT value;
} ntable;

#define NameTable ntable

typedef struct
{
	CHAR *optionName;
	NameTable *table;
	SHORT (*valid)  IPT4( UTINY, hostID, ConfigValues, *vals,
			     NameTable, table[], CHAR, errString[] );
	VOID (*change)  IPT2( UTINY, hostID, BOOL, apply);
	SHORT (*active) IPT3( UTINY, hostID, BOOL, active, CHAR, errString[]);
	UTINY hostID;
	UTINY flags;
} OptionDescription;

typedef struct _resource_node
{
	CHAR *line;			/* resource string */
	CHAR *arg;			/* a pointer to the argument */
	struct _resource_node *next;	/* pointer to next node in list */
	SHORT allocLen;			/* length of string allocated */
} LineNode;

/* Base Config functions declarations */

extern void config IPT0();
extern void *config_inquire IPT2(UTINY, hostID, ConfigValues *, values);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
extern void config_get IPT2(UTINY, hostID, ConfigValues **, values);
extern void config_unget IPT1(UTINY, hostID);
extern void config_unget_all IPT0();
extern SHORT config_put IPT2(UTINY, hostID, ErrDataPtr, errDataP);
extern void config_put_all IPT0();
extern void IPT0config_get_all();
extern BOOL config_reboot_check IPT0();
extern SHORT config_check IPT2(UTINY, hostID, ErrDataPtr, errDataP);
extern void config_store IPT0();
#endif

extern void config_activate IPT2(UTINY, hostID, BOOL, reqState);
extern void config_set_active IPT2(UTINY, hostID, BOOL, state);
extern BOOL config_get_active IPT1(UTINY, hostID);
extern LineNode *add_resource_node IPT1(CHAR *, str);
extern CHAR *translate_to_string IPT2(SHORT, value, NameTable, table[]);
extern SHORT translate_to_value IPT2(CHAR *, string, NameTable, table[]);
extern UTINY find_hostID IPT1(CHAR *, name);
extern CHAR *find_optionname IPT1(UTINY, hostID);
extern void host_config_init IPT1(OptionDescription *, common_defs);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
extern SHORT host_read_resource_file IPT2(BOOL, system, ErrDataPtr, err_buf);
extern SHORT host_write_resource_file IPT2(LineNode *, head,
                                           ErrDataPtr, err_buf);
#endif

extern void *host_inquire_extn IPT2(UTINY, hostID, ConfigValues *, values);
extern SHORT host_runtime_inquire IPT1(UTINY, what);
extern void host_runtime_set IPT2(UTINY, what, SHORT, value);
extern void host_runtime_init IPT0();
extern SHORT validate_item IPT4(UTINY, hostID, ConfigValues *, value,
                                NameTable *, table, CHAR, err[]);
extern CHAR *convert_to_external IPT1(UTINY, hostID);

#ifndef host_expand_environment_vars
extern CHAR *host_expand_environment_vars IPT1(const char *, string);
#endif /* nhost_expand_environment_vars */

extern CHAR ptr_to_empty[];

#ifdef SWITCHNPX
extern IS32 Npx_enabled;
#endif /* SWITCHNPX */

/* Dumb Terminal UIF Flag */
extern IBOOL Config_has_been_edited;

#include "host_cfg.h"

#endif /* _CONFIG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cntlbop.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: cntlbop.h
 *
 * Description	: Definitions for use by the control bop functions.
 *
 * Author	: J. Koprowski
 *
 * Notes	: None
 */


/* SccsID[]=" @(#) @(#)cntlbop.h	1.4 08/10/92  01/20/89 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Return codes from control bop type functions.
 */

#ifndef SUCCESS
#define SUCCESS 		0	/* Generic success code. */
#endif

#define ERR_NO_FUNCTION		1	/* Function not implemented. */
#define ERR_WRONG_HOST		2	/* Function call was for a different
					   host. */
#define ERR_INVALID_PARAMETER	3	/* Invalid parameter (out of range,
					   malformed etc.) */
#define ERR_WRONG_HARDWARE 	4	/* Hardware not present or
					   inappropriate. */
#define ERR_OUT_OF_SPACE	5	/* Insufficient memory or disk space. */
#define ERR_RESOURCE_SHORTAGE	6	/* Other resource shortage. */

/*
 * N.B. Error codes seven through fifteen are reserved for general errors.
 * Codes of sixteen and over are for use by the host routines and are
 * specified in host_bop.h.
 */

/*
 * Control bop table structure.
 */
typedef struct
{
    unsigned int code;
    void (*function)();
} control_bop_array;

/*
 * Generic host type code used for base functions.
 */
#define GENERIC 	1

#ifndef NULL
#define NULL	0L
#endif
/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern void control_bop IPT0();
extern control_bop_array host_bop_table[];

#if defined(DUMB_TERMINAL) && !defined(NO_SERIAL_UIF)
extern void flatog   IPT0();
extern void flbtog   IPT0();
extern void slvtog   IPT0();
extern void comtog   IPT0();
extern void D_kyhot  IPT0();
extern void D_kyhot2 IPT0();
#endif /* DUMB_TERMINAL && !SERIAL_UIF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\crtc.h ===
#if defined(NEC_98)
/* CRTC include file */

/* CRTC port address */

#define CRTC_SET_PL  0x70
#define CRTC_SET_BL  0x72
#define CRTC_SET_CL  0x74
#define CRTC_SET_SSL 0x76
#define CRTC_SET_SUR 0x78
#define CRTC_SET_SDR 0x7A

/* CRTC structures */

typedef struct
{
        unsigned char   regpl;
        unsigned char   regbl;
        unsigned char   regcl;
        unsigned char   regssl;
        unsigned char   regsur;
        unsigned char   regsdr;
} CRTC_GLOBS;

extern CRTC_GLOBS crtcglobs;

IMPORT void text_gdc_init IPT0();
IMPORT void text_gdc_outb IPT2(io_addr, port, half_word, value);
IMPORT void text_gdc_post IPT0();
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\cpu4.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Definitions for the 80386 CPU 
 *
 * Description	: Structures, macros and definitions for access to the 
 *		  CPU registers
 *
 * Author	: Wayne Plummer
 *
 * Derived From : cpu.h
 *
 * Notes	: This file should be portable - but includes a file
 *		  host_cpu.h which contains machine specific definitions
 *		  of CPU register mappings etc.
 *
 * SccsID	: @(#)cpu4.h	1.12 10/21/94
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991-1994. All rights reserved.
 */

#include "host_cpu.h"

IMPORT VOID host_set_hw_int IPT0();
IMPORT VOID host_clear_hw_int IPT0();


/*
 *	Host functions to be provided for the base to use with respect to the CPU.
 *	These must be done in host_cpu.h because some hosts may want functions and
 *	others may want #defines.
 */

/*
 *	This macro specifies the maximum recursion depth the CPU is required to support.
 *	(Note that a particular host may not actually use this value if it is capable
 *	of supporting abirtarily deep recursion).
 */
#define CPU_MAX_RECURSION	32

/*
 *	Interrupt types...
 */

#include <CpuInt_c.h>
typedef enum CPU_INT_TYPE CPU_INT_TYPE;

#ifdef CPU_PRIVATE
/*
   Function returns for private i/f procedures handling segment loading.
 */

#define GP_ERROR    13
#define NP_ERROR    11
#define SF_ERROR    12
#endif /* CPU_PRIVATE */

/*
 * Include the main part of the cpu interface, which at present is generated
 */
#include	<cpu4gen.h>

IMPORT void		cpuEnableInterrupts IPT1(IBOOL, yes_or_no);

#ifdef IRET_HOOKS
#ifdef CCPU
IMPORT   VOID c_Cpu_set_hook_selector  IPT1(IU16, selector);
#define  Cpu_set_hook_selector         c_Cpu_set_hook_selector
#else
IMPORT   VOID a3_Cpu_set_hook_selector IPT1(IU16, selector);
#define  Cpu_set_hook_selector         a3_Cpu_set_hook_selector
#endif
#endif /* IRET_HOOKS */

/*
 * These functions get the (E)IP or (E)SP correctly whatever size stack
 * or code segment is in use.  For anything but GISP, we always hold
 * the IP as a 32 bit quantity, so we don't have to worry about the
 * distinction.
 */

#ifdef GISP_CPU
extern IU32 GetInstructionPointer IPT0();
#else
#define GetInstructionPointer getEIP
#endif
extern IU32 GetStackPointer IPT0();


#ifdef IRET_HOOKS
/*
 * The interfaces provided by the CPU so that the ICA can initiate and
 * terminate an iret hook.
 */

extern void Cpu_do_hook IPT2(IUM8, line, IBOOL, is_hooked);
extern void Cpu_inter_hook_processing IPT1(IUM8, line);
extern void Cpu_unhook IPT1(IUM8, line_number);
#ifdef GISP_CPU
extern void Cpu_set_hook_selector IPT1(IU16, selector);
extern void Cpu_hook_bop IPT0();
#endif

#endif /* IRET_HOOKS */

/*
 * This function lets ios.c determine whether it is OK for it to go
 * ahead and do an in or out instruction, or whether the CPU wants to take
 * it over instead.
 */

/* However, it is sometimes defined as a macro */

#if !defined(CCPU) && !defined(PROD)
extern IBOOL IOVirtualised IPT4(io_addr, io_address, IU32 *, value, LIN_ADDR, offset, IU8, width);
#endif

#ifndef CCPU
/*
 * Npx functions:
 */
#ifndef PROD
GLOBAL IU32 a_getNpxControlReg	IPT0();
GLOBAL IU32 a_getNpxStatusReg	IPT0();
GLOBAL IU32 a_getNpxTagwordReg	IPT0();
GLOBAL char *a_getNpxStackReg	IPT2(IU32, reg_num, char *, buffer);
#endif /* PROD */

#ifdef PIG
GLOBAL void a_setNpxControlReg	IPT1(IU32, newControl);
GLOBAL void a_setNpxStatusReg	IPT1(IU32, newStatus);
#endif /* PIG */
#endif /* !CCPU */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\debug.h ===
/*
 * SccsID = @(#)debug.h	1.5 01/23/95 Copyright Insignia Solutions Ltd.
 *
 * The following values are used to indicate which ega setting decided that
 * the display should be disabled. The global variable display_disabled
 * should be 1 (or more) of these values.
 *
 */

#define	ASYNC_RESET		1
#define	SYNC_RESET		2
#define	VIDEO_DRIVERS_DISABLED	4

#ifndef	YES
#define	YES	1
#define	NO	0
#endif

#ifdef	PROD
#define	NON_PROD(x)
#define	PROD_ONLY(x)	x
#else
#define	NON_PROD(x)	x
#define	PROD_ONLY(x)
#endif

#ifndef	PROD
#include <stdio.h>
#include "trace.h"

#ifndef	newline
#define	newline	fprintf(trace_file, "\n")
#endif

#ifndef	file_id
#define	file_id		fprintf(trace_file, "%s:%d ", __FILE__, __LINE__ ) 
#endif

#define	note_entrance0(str)			if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str);newline; }
#define	note_entrance1(str,p1)			if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str,p1);newline; }
#define	note_entrance2(str,p1,p2)		if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str,p1,p2);newline; }
#define	note_entrance3(str,p1,p2,p3)		if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str,p1,p2,p3);newline; }
#define	note_entrance4(str,p1,p2,p3,p4)		if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str,p1,p2,p3,p4);newline; }
#define note_write_state0(str)			if (io_verbose & EGA_WRITE_VERBOSE) { file_id;fprintf(trace_file, str);newline; }
#define note_write_state1(str,p1)		if (io_verbose & EGA_WRITE_VERBOSE) { file_id;fprintf(trace_file, str,p1);newline; }
#define note_write_state2(str,p1,p2)		if (io_verbose & EGA_WRITE_VERBOSE) { file_id;fprintf(trace_file, str,p1,p2);newline; }
#define note_write_state3(str,p1,p2,p3)		if (io_verbose & EGA_WRITE_VERBOSE) { file_id;fprintf(trace_file, str,p1,p2,p3);newline; }
#define	note_display_state0(str)		if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str);newline; }
#define	note_display_state1(str,p1)		if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str,p1);newline; }
#define	note_display_state2(str,p1,p2)		if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str,p1,p2);newline; }
#define	note_display_state3(str,p1,p2,p3)	if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str,p1,p2,p3);newline; }
#define	do_display_trace(str,thing_to_do)	if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str);newline;thing_to_do; }

/*
 * Generic tracing stuff to avoid nasty defines everywhere
 */

#define	note_trace0(trace_bit,str)		if (io_verbose & (trace_bit)) { file_id; fprintf(trace_file, str); newline; }
#define	note_trace1(trace_bit,str,p0)		if (io_verbose & (trace_bit)) { file_id;fprintf(trace_file, str,p0);newline; }
#define	note_trace2(trace_bit,str,p0,p1)	if (io_verbose & (trace_bit)) { file_id;fprintf(trace_file, str,p0,p1);newline; }
#define	note_trace3(trace_bit,str,p0,p1,p2)	if (io_verbose & (trace_bit)) { file_id;fprintf(trace_file, str,p0,p1,p2);newline; }
#define	note_trace4(trace_bit,str,p0,p1,p2,p3)	if (io_verbose & (trace_bit)) { file_id;fprintf(trace_file, str,p0,p1,p2,p3);newline; }
#define	note_trace5(trace_bit,str,p0,p1,p2,p3,p4) \
	if (io_verbose & (trace_bit)) { \
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; }
#define	note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5) \
	if (io_verbose & (trace_bit)) { \
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; }
#define	note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6) \
	if (io_verbose & (trace_bit)) { \
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; }
#define	note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
	if (io_verbose & (trace_bit)) { \
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7); \
		newline; }


#define	always_trace0(str)		{ \
                      file_id;fprintf(trace_file, str);newline; }
#define	always_trace1(str,p0)		{ \
                      file_id;fprintf(trace_file, str,p0);newline; }
#define	always_trace2(str,p0,p1)	{ \
                      file_id;fprintf(trace_file, str,p0,p1);newline; }
#define	always_trace3(str,p0,p1,p2)	{ \
                      file_id;\
                      fprintf(trace_file, str,p0,p1,p2);newline; }
#define	always_trace4(str,p0,p1,p2,p3){ \
                      file_id; \
                      fprintf(trace_file, str,p0,p1,p2,p3); newline; }
#define	always_trace5(str,p0,p1,p2,p3,p4){ \
                      file_id; \
                      fprintf(trace_file, str,p0,p1,p2,p3,p4); newline; }
#define	always_trace6(str,p0,p1,p2,p3,p4,p5){ \
                      file_id; \
                      fprintf(trace_file, str,p0,p1,p2,p3,p4,p5); newline; }
#define	always_trace7(str,p0,p1,p2,p3,p4,p5,p6){ \
                      file_id; \
                      fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6); newline; }
#define	always_trace8(str,p0,p1,p2,p3,p4,p5,p6,p7){ \
                      file_id; \
                      fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7);newline;}

/*
** The _no_nl macros also print messages when appropriate, but they do
** not put a new line afterwards.
*/
#define	note_trace0_no_nl(trace_bit, str)				\
		if (io_verbose & (trace_bit)){ 				\
 			fprintf(trace_file, str);			\
			fflush( trace_file );				\
		}
#define	note_trace1_no_nl(trace_bit, str, p0)				\
		if (io_verbose & (trace_bit)){ 				\
 			fprintf(trace_file, str, p0);			\
			fflush( trace_file );				\
		}
#define	note_trace2_no_nl(trace_bit, str, p0, p1)			\
		if (io_verbose & (trace_bit)){ 				\
 			fprintf(trace_file, str, p0, p1);		\
			fflush( trace_file );				\
		}

#define	sure_note_trace0(trace_bit,str)		\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id; fprintf(trace_file, str); newline; \
			host_release_timer();\
		}
#define	sure_note_trace1(trace_bit,str,p0)		\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id;fprintf(trace_file, str,p0);newline; \
			host_release_timer();\
		}
#define	sure_note_trace2(trace_bit,str,p0,p1)	\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id;fprintf(trace_file, str,p0,p1);newline; \
			host_release_timer();\
		}
#define	sure_note_trace3(trace_bit,str,p0,p1,p2)	\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id;fprintf(trace_file, str,p0,p1,p2);newline; \
			host_release_timer();\
		}
#define	sure_note_trace4(trace_bit,str,p0,p1,p2,p3)	\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id;fprintf(trace_file, str,p0,p1,p2,p3);newline; \
			host_release_timer();\
		}
#define	sure_note_trace5(trace_bit,str,p0,p1,p2,p3,p4) \
		if (io_verbose & (trace_bit)) { \
			host_block_timer();\
			file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4);\
			newline; \
			host_release_timer();\
		}
#define	sure_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5) \
		if (io_verbose & (trace_bit)) { \
			host_block_timer();\
			file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);\
			newline; \
			host_release_timer();\
		}
#define	sure_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6) \
		if (io_verbose & (trace_bit)) { \
			host_block_timer();\
			file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);\
			newline; \
			host_release_timer();\
		}
#define	sure_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
	if (io_verbose & (trace_bit)) { \
			host_block_timer();\
			file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7); \
			newline; \
			host_release_timer();\
		}

#define	sub_note_trace0(trace_bit,str)		\
	if (sub_io_verbose & (trace_bit))\
	{ file_id; fprintf(trace_file, str); newline; }
#define	sub_note_trace1(trace_bit,str,p0)	\
	if (sub_io_verbose & (trace_bit))\
	{ file_id;fprintf(trace_file, str,p0);newline; }
#define	sub_note_trace2(trace_bit,str,p0,p1)	\
	if (sub_io_verbose & (trace_bit))\
	{ file_id;fprintf(trace_file, str,p0,p1);newline; }
#define	sub_note_trace3(trace_bit,str,p0,p1,p2)	\
	if (sub_io_verbose & (trace_bit))\
	{ file_id;fprintf(trace_file, str,p0,p1,p2);newline; }
#define	sub_note_trace4(trace_bit,str,p0,p1,p2,p3)	\
	if (sub_io_verbose & (trace_bit))\
	{ file_id;fprintf(trace_file, str,p0,p1,p2,p3);newline; }
#define	sub_note_trace5(trace_bit,str,p0,p1,p2,p3,p4) \
	if (sub_io_verbose & (trace_bit))\
	{file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; }
#define	sub_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5) \
	if (sub_io_verbose & (trace_bit))\
	{file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; }
#define	sub_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6) \
	if (sub_io_verbose & (trace_bit))\
	{file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; }
#define	sub_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
	if (sub_io_verbose & (trace_bit))\
	{file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7);newline; }

#define	sure_sub_note_trace0(trace_bit,str)		\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id; fprintf(trace_file, str); newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace1(trace_bit,str,p0)	\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id;fprintf(trace_file, str,p0);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace2(trace_bit,str,p0,p1)	\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id;fprintf(trace_file, str,p0,p1);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace3(trace_bit,str,p0,p1,p2)	\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id;fprintf(trace_file, str,p0,p1,p2);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace4(trace_bit,str,p0,p1,p2,p3)	\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id;fprintf(trace_file, str,p0,p1,p2,p3);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace5(trace_bit,str,p0,p1,p2,p3,p4) \
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5) \
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6) \
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7);newline; \
		host_release_timer();\
	}

#define	assert0(test,str)			if (!(test)) { file_id;fprintf(trace_file,str);newline; }
#define	assert1(test,str,p1)			if (!(test)) { file_id;fprintf(trace_file,str,p1);newline; }
#define	assert2(test,str,p1,p2)			if (!(test)) { file_id;fprintf(trace_file,str,p1,p2);newline; }
#define	assert3(test,str,p1,p2,p3)		if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3);newline; }
#define	assert4(test,str,p1,p2,p3,p4)		if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4);newline; }
#define	assert5(test,str,p1,p2,p3,p4,p5)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5);newline; }
#define	assert6(test,str,p1,p2,p3,p4,p5,p6)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6);newline; }
#define	assert7(test,str,p1,p2,p3,p4,p5,p6,p7)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6,p7);newline; }
#define	assert8(test,str,p1,p2,p3,p4,p5,p6,p7,p8)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6,p7,p8);newline; }

#define	assert0_do(test,str,do)			if (!(test)) { file_id;fprintf(trace_file,str);newline;do; }
#define	assert1_do(test,str,p1,do)		if (!(test)) { file_id;fprintf(trace_file,str,p1);newline;do; }
#define	assert2_do(test,str,p1,p2,do)		if (!(test)) { file_id;fprintf(trace_file,str,p1,p2);newline;do; }
#define	assert3_do(test,str,p1,p2,p3,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3);newline;do; }
#define	assert4_do(test,str,p1,p2,p3,p4,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4);newline;do; }
#define	assert5_do(test,str,p1,p2,p3,p4,p5,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5);newline;do; }
#define	assert6_do(test,str,p1,p2,p3,p4,p5,p6,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6);newline;do; }
#define	assert7_do(test,str,p1,p2,p3,p4,p5,p6,p7,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6,p7);newline;do; }
#define	assert8_do(test,str,p1,p2,p3,p4,p5,p6,p7,p8,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6,p7,p8);newline;do; }

#else /* PROD */

#ifdef HUNTER
#include <stdio.h>
#include "trace.h"
#endif /* HUNTER */

#define	init_debugging()
#define	note_entrance0(str)
#define	note_entrance1(str,p1)
#define	note_entrance2(str,p1,p2)
#define	note_entrance3(str,p1,p2,p3)
#define	note_entrance4(str,p1,p2,p3,p4)
#define note_write_state0(str)
#define note_write_state1(str,p1)
#define note_write_state2(str,p1,p2)
#define note_write_state3(str,p1,p2,p3)
#define	note_display_state0(str)
#define	note_display_state1(str,p1)
#define	note_display_state2(str,p1,p2)
#define	note_display_state3(str,p1,p2,p3)
#define	do_display_trace(str,thing_to_do)
#define	note_trace0(trace_bit,str)
#define	note_trace1(trace_bit,str,p0)
#define	note_trace2(trace_bit,str,p0,p1)
#define	note_trace3(trace_bit,str,p0,p1,p2)
#define	note_trace4(trace_bit,str,p0,p1,p2,p3)
#define	note_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	always_trace0(str)
#define	always_trace1(str,p0)
#define	always_trace2(str,p0,p1)
#define	always_trace3(str,p0,p1,p2)
#define	always_trace4(str,p0,p1,p2,p3)
#define	always_trace5(str,p0,p1,p2,p3,p4)
#define	always_trace6(str,p0,p1,p2,p3,p4,p5)
#define	always_trace7(str,p0,p1,p2,p3,p4,p5,p6)
#define	always_trace8(str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	note_trace0_no_nl(trace_bit,str)
#define	note_trace1_no_nl(trace_bit,str,p0)
#define	note_trace2_no_nl(trace_bit,str,p0,p1)
#define	sure_note_trace0(trace_bit,str)
#define	sure_note_trace1(trace_bit,str,p0)
#define	sure_note_trace2(trace_bit,str,p0,p1)
#define	sure_note_trace3(trace_bit,str,p0,p1,p2)
#define	sure_note_trace4(trace_bit,str,p0,p1,p2,p3)
#define	sure_note_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	sure_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	sure_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	sure_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	sub_note_trace0(trace_bit,str)
#define	sub_note_trace1(trace_bit,str,p0)
#define	sub_note_trace2(trace_bit,str,p0,p1)
#define	sub_note_trace3(trace_bit,str,p0,p1,p2)
#define	sub_note_trace4(trace_bit,str,p0,p1,p2,p3)
#define	sub_note_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	sub_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	sub_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	sub_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	sure_sub_note_trace0(trace_bit,str)
#define	sure_sub_note_trace1(trace_bit,str,p0)
#define	sure_sub_note_trace2(trace_bit,str,p0,p1)
#define	sure_sub_note_trace3(trace_bit,str,p0,p1,p2)
#define	sure_sub_note_trace4(trace_bit,str,p0,p1,p2,p3)
#define	sure_sub_note_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	sure_sub_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	sure_sub_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	sure_sub_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)

#define	assert0(test,str)
#define	assert1(test,str,p1)
#define	assert2(test,str,p1,p2)
#define	assert3(test,str,p1,p2,p3)
#define	assert4(test,str,p1,p2,p3,p4)
#define	assert5(test,str,p1,p2,p3,p4,p5)
#define	assert6(test,str,p1,p2,p3,p4,p5,p6)
#define	assert7(test,str,p1,p2,p3,p4,p5,p6,p7)
#define	assert8(test,str,p1,p2,p3,p4,p5,p6,p7,p8)

#define	assert0_do(test,str,do)
#define	assert1_do(test,str,p1,do)
#define	assert2_do(test,str,p1,p2,do)
#define	assert3_do(test,str,p1,p2,p3,do)
#define	assert4_do(test,str,p1,p2,p3,p4,do)
#define	assert5_do(test,str,p1,p2,p3,p4,p5,do)
#define	assert6_do(test,str,p1,p2,p3,p4,p5,p6,do)
#define	assert7_do(test,str,p1,p2,p3,p4,p5,p6,p7,do)
#define	assert8_do(test,str,p1,p2,p3,p4,p5,p6,p7,p8,do)

#endif /* PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\dasm.h ===
/* 
   dasm.h

   Define interface to dis-assembly function.
 */

/*
   static char SccsID[]="@(#)dasm.h	1.4 08/19/94 Copyright Insignia Solutions Ltd.";
 */

extern IU16 dasm IPT4(char *, txt, IU16, seg, LIN_ADDR, off, SIZE_SPECIFIER, default_size);

/* Also available is the internal interface which allows a private
 * copy of Intel bytes to be dasm'ed even if they are not within M[]
 * Hence the caller supplies the "sas_hw_at" fucntion an any suitable
 * LIN_ADDR. The seg:off is used solely for printing.
 * This is the routine called by dasm() with p = effective_addr(seg, off)
 * and byte_at = sas_hw_at. This procedure can return -1 if it is unable
 * to return a byte.
 */
#ifdef DASM_INTERNAL
#include <decode.h>
extern IU16 dasm_internal IPT8(
   char *, txt,	/* Buffer to hold dis-assembly text (-1 means not required) */
   IU16, seg,	/* Segment for xxxx:... text in dis-assembly */
   LIN_ADDR, off,	/* ditto offset */
   SIZE_SPECIFIER, default_size,/* 16BIT or 32BIT code segment */
   LIN_ADDR, p,			/* linear address of start of instruction */
   read_byte_proc, byte_at,	/* like sas_hw_at() to use to read intel */
   char *, fmt,			/* sprintf format for first line seg:offset */
   char *, newline);		/* strcat text to separate lines */
#endif	/* DASM_INTERNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\dfa.h ===
/*[
 *      Name:		dfa.h
 *
 *      Derived From:	DEC 3.0 dfa.gi and pk_dfa.gi
 *
 *      Author:         Justin Koprowski
 *
 *      Created On:	18th February 1992
 *
 *      Sccs ID:        @(#)dfa.h	1.5 01/29/93
 *
 *      Purpose:	DFA definitions
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/

/* DFA global functions */

IMPORT VOID dfa_run IPT1(USHORT, isymb);
IMPORT LONG dfa_load IPT2(CHAR *, file, LONG *, err);
IMPORT VOID dfa_init IPT0();

/* 
 * mapping to use for displaying IBM extended
 * ASCII char.
 */

typedef struct {
	SHORT	hostval;/* host character to use */
	SHORT 	cset;	/* host character set to use */
} gmap_;

/* 
 * this gets initialised from the compiled
 * description file (see dfa_build() in dfa.c)
 * as does dispcap below
 */

IMPORT gmap_ dfa_glist[256];

#define NALTCHARSETS 6+1	/* 6 alt.+base */

typedef struct {
	CHAR *spcon;		/* terminal start up string */	
	CHAR *spcoff;		/* terminal shutdown string */
	CHAR *shiftin;		/* activate base char set */
	CHAR *shiftout;		/* activate selected alt.char set */
	CHAR *alt[NALTCHARSETS]; /* select alt.char sets */
	CHAR *ctldisp;		/* display control codes */
	CHAR *ctlact;		/* interpret control codes */
} dispcap_;

IMPORT dispcap_ dispcap;

#define DFA_NOFILE	1
#define DFA_BADFILE	2
#define DFA_NOMEM	3


/* 
 * define structure of keyboard input machine header
 * as found at front of its definition file
 */

#define DFA_MAGIC	0x01d1

typedef struct {
	SHORT	magic;			/* some daft signature			*/
	SHORT	startstateid;		/* the starting DFA state		*/
	SHORT	nDFAstates;		/* number of deterministic states	*/
	SHORT   nalphabet;		/* number of symbols in input alphabet  */
	SHORT	n_in_tlist;		/* size of transition list block	*/
	SHORT	n_in_alist;		/* size of acceptance actions block	*/
	SHORT	nindices;		/* #.capability strings for display */
	SHORT	sizeofcapstrings;	/* #.bytes for all cap.strings */
} machineHdr_, *machineHdrPtr_;


/* 
 * pseudocodes for semantic actions on machine accepting
 * an input string
 */

#define SEM_SELECTINTERP        0
#define SEM_LOCK        	1
#define SEM_LOCK1       	2
#define SEM_UNLK        	3
#define SEM_UNLK1       	4
#define SEM_UNLK2       	5
#define SEM_TOGLOCK        	6
#define SEM_TOGLOCK1       	7
#define SEM_TOGLOCK2       	8
#define SEM_SWITCH      	9
#define SEM_KYHOT       	10
#define SEM_KYHOT2      	11
#define SEM_REFRESH     	12
#define SEM_UNPUT     		13
#define SEM_ALOCK1       	14
#define SEM_ASPC       		15
#define SEM_EXIT       		16
#define SEM_KYHOT3      	17
#define SEM_FLATOG              18
#define SEM_FLBTOG              19
#define SEM_SLVTOG              20
#define SEM_COMTOG              21
#define SEM_EDSPC               22
#define SEM_LSTSET              23

/* 
 * indicate how transition list is packed for a given DFA state
 * Indexed is an array of next state id's, indexed by the input
 * symbol.
 * Unindexed is an array of (state id, input symbol) pairs which
 * are searched for match on input symbol.
 */

#define PINDEXED        	1
#define PUNINDEXED      	2

/* 
 * indicate the importance of a given DFA state.
 * upon reaching an ENDSTATE, can undertake the semantic actions
 * provided there are no further transitions from this state.
 * if there are, then must wait to see what next input symbol is.
 * If this doesn't match, we can definitely undertake these actions
 */

#define STARTSTATE      1
#define ENDSTATE        2
#define INTERMEDIATE    0
#define ILLEGAL		0xffff

#define	WILDC		0x101
 
typedef struct {
        UTINY attrib;   	/* state attribute (start, end etc.) 	*/
        UTINY howpacked; 	/* INDEXED or UNINDEXED 		*/
        SHORT ntrans;           /* #.members of transition list 	*/
        ULONG nextstates;	/* offset within packed trans.list area */
                                /* to start of this list 		*/
        ULONG actions; 		/* offset into action list area for	*/
                                /* actions for this state (if acceptor) */
} packedDFA_, *packedDFAPtr_;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\decode.h ===
/* 
   decode.h

   Define all data types and functions supported by the Intel
   instruction decoder.
 */

/*
   static char SccsID[]="@(#)decode.h	1.5 08/25/94 Copyright Insignia Solutions Ltd.";
 */

#ifndef	_DECODE_H_
#define	_DECODE_H_

typedef struct
   {
   UTINY  arg_type;        /* Decoded operand type. */
   USHORT identifier;      /* Identifier within a specific type */
   UTINY  sub_id;          /* Sub-identifier */
   UTINY  addressability;  /* How the operand is addressed */
   ULONG  arg_values[2];   /* Specific values for operand. */
   } DECODED_ARG;

typedef struct
   {
   UTINY operand_size;       /* Operand size for inst. */
   UTINY address_size;       /* Address size for inst. */
   UTINY prefix_sz;          /* Nr. of prefix bytes (maybe 0).             */
   UTINY inst_sz;            /* Nr. bytes in inst. (includes prefix bytes) */
   USHORT inst_id;           /* Decoded instruction identifier.            */
   DECODED_ARG args[3];      /* Three operands arg1, arg2, arg3 are        */
			     /* allowed.                                   */
   } DECODED_INST;

/*
   The allowable types of address size.
 */
#define ADDR_16		(UTINY)0
#define ADDR_32		(UTINY)1

/*
   The allowable types of operand size.
 */
#define OP_16 (UTINY)0
#define OP_32 (UTINY)1


#ifdef ANSI
typedef IS32 (*read_byte_proc) (LIN_ADDR);
#else
typedef IS32 (*read_byte_proc) ();
#endif

extern void decode IPT4(
	LIN_ADDR, p,
	DECODED_INST *, d_inst,
	SIZE_SPECIFIER, default_size,
	read_byte_proc, func		
);
#endif	/* _DECODE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\disk_geo.h ===
/*[
 *	Name:		disk_geom.h
 *
 *	Derived From:	n/a
 *
 *	Author:		Dave Howell.
 *
 *	Created:	September 1992.
 *
 * 	Sccs ID:        @(#)disk_geom.h	1.1 01/12/93
 *
 *	Purpose:	This header is the interface to disk_geom.c, and provides
 *				definitions of some disk geometry constants.
 *
 *	Interface:	n/a
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 *
]*/

/*
 *	Interface to disk_geom.c
 */

IMPORT BOOL do_geom_validation IPT4 (	unsigned long,   	dos_size,
										SHORT *, 			nCylinders,
										UTINY *, 			nHeads,
										UTINY *, 			nSectors);

/*
 *	Some manifest constants used in disk calculations.
 */

#define	ONEMEG					1024 * 1024
#define HD_MAX_DISKALLOCUN			32
#define HD_SECTORS_PER_TRACK	 		17
#define HD_HEADS_PER_DRIVE	  		4
#define HD_BYTES_PER_SECTOR	  		512
#define HD_SECTORS_PER_CYL (HD_HEADS_PER_DRIVE * HD_SECTORS_PER_TRACK)
#define HD_BYTES_PER_CYL   (HD_BYTES_PER_SECTOR * HD_SECTORS_PER_CYL)
#define HD_DISKALLOCUNSIZE (HD_BYTES_PER_CYL * 30)
#define SECTORS 0x0c		/* offset in buffer for sectors in partition
				 * marker */
#define MAX_PARTITIONS  5
#define START_PARTITION 0x1be
#define SIZE_PARTITION  16
#define SIGNATURE_LEN   2

#define checkbaddrive(d)	if ( (d) != 0 && (d) != 1) host_error(EG_OWNUP,ERR_QUIT,"illegal driveid (host_fdisk)");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\dsktrace.h ===
/* SccsId = @(#)dsktrace.h	1.9 04/12/95 */
/*
 * dsktrace.h
 *
 *	Jerry Kramskoy
 *	(reworked due to CI by Ade Brownlow )
 *
 */

/* to use disk traceing, must set the relevant bit(s) with the yoda 
 * 'it' command (e.g it 20), which then lets user select info required
 * AJO 15/12/92; Can also use yoda trace command, for which these constants
 * were changed from (1 << 2) to 0x4 style cos' Alpha/OSF/1 compiler won't
 * initialise a constant expression of this kind.
 */

/* trace fixed disk bios entry and exit
 * (with status and CF on exit)
 */
#define		CALL	0x1		/* reserved */

/* give info about BIOS command
 */
#define		CMDINFO	0x2

/* give information about execution of BIOS command
 * (gives results, and parameters of commands)
 */
#define		XINFO	0x4

/* give execution status of BIOS command
 * (flags errors during polls of disk controller, etc)
 */
#define		XSTAT	0x8

/* trace physical attach,detach
 */
#define		PAD	0x10

/* trace io attach,detach
 */
#define		IOAD	0x20

/* trace inb's, outb's, etc
 */
#define		PORTIO	0x40

/* trace fixed disk IRQ line
 */
#define		INTRUPT	0x80

/* trace fixed disk hw activity
 * (selects PORTIO, INTRUPT also)
 */
#define		HWXINFO	0x100

/* disk data dump
 */
#define		DDATA	0x200

/* trace host physical io (file pointer locn pre read(), write())
 */
#define		PHYSIO	0x400

/* to activate fixed disk controller tracing, must set DHW bit
 */
#define		DHW	0x4000

/* to activate disk BIOS tracing, must set DBIOS bit
 */

#define		DBIOS	0x8000

/* wdctrl_bop reads/writes
 */
#define		WDCTRL	0x10000

/*
 * handles to be used when bundling up multiple trace output
 */
#define INW_TRACE_HNDL	1
#define OUTW_TRACE_HNDL	2


/* disk tracing macro
 */
#ifndef PROD
#define dt0(infoid,hndl,fmt) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,0,hndl,fmt,0,0,0,0,0);}
#define dt1(infoid,hndl,fmt,i) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,1,hndl,fmt,i,0,0,0,0);}
#define dt2(infoid,hndl,fmt,i,j) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,2,hndl,fmt,i,j,0,0,0);}
#define dt3(infoid,hndl,fmt,i,j,k) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,3,hndl,fmt,i,j,k,0,0);}
#define dt4(infoid,hndl,fmt,i,j,k,l) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,4,hndl,fmt,i,j,k,l,0);}
#define dt5(infoid,hndl,fmt,i,j,k,l,m) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,5,hndl,fmt,i,j,k,l,m);}
#else
#define dt0(infoid,hndl,fmt) ;
#define dt1(infoid,hndl,fmt,i) ;
#define dt2(infoid,hndl,fmt,i,j) ;
#define dt3(infoid,hndl,fmt,i,j,k) ;
#define dt4(infoid,hndl,fmt,i,j,k,l) ;
#define dt5(infoid,hndl,fmt,i,j,k,l,m) ;
#endif

#ifndef PROD
VOID	setdisktrace();
IMPORT	IU32 disktraceinfo;
#ifdef ANSI
void disktrace (int, int, int, char *, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long);
#else
VOID	disktrace();
#endif /* ANSI */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\dpmi.h ===
/*
 * SoftPC AT Revision 2.0
 *
 * Title        : DPMI host definitions
 *
 * Description  : Definitions for the DPMI TSR host
 *
 * Author       : WTG Charnell
 *
 * Notes        : None
 */



/* SccsID[]="@(#)dpmi.h	1.1 08/06/93 Copyright Insignia Solutions Ltd."; */

#define LDT_INCR        8
#define LDT_DESC_MASK   7       /* LDT desc , prot level 3 */
#define LDT_SHIFT       3
#define LDT_ALLOC_LIMIT	0x1fff	/* max avail LDT selectors */
#define	MIN_EMM_BLOCK	0x14000	/* amount of EMM needed by TSR */
#define MEM_HANDLE_BLOCK_SIZE	0x100	/* DPMI mem handles are obtained in blocks of this size */
#define CALL_INST_SIZE	7	/* 32 bit far call = 7 bytes */
#define PUSH_JMP_SIZE	8	/* PUSH word then far jmp = 8 bytes */
#define STACKLET_SIZE	192	/* safe size according to DOSX */
#define MAX_WP_HANDLE	4	/* maximnum active watchpoints (386 dbg regs) */

#define INIT_R0_SP	0x7e
#define INIT_LOCKED_SP	0xffe
#define RM_SEG_SIZE	0x900
#define NUM_CALLBACKS	32
#define METASTACK_LIMIT	20

#define	DPMI_FN_VERB	0x1
#define	DPMI_MDSW_VERB	0x2
#define	DPMI_INT_VERB	0x4
#define	DPMI_GEN_VERB	0x8
#define DPMI_STACK_VERB	0x10
#define DPMI_ERROR_VERB	0x20


typedef struct
{
	BOOL allocated;
	BOOL rm_seg;
} LDT_alloct;

typedef struct mem_alloc
{
	IU32 base_addr;
	IU32 size;
	IU32 handle;
	IU16 selector;
	struct mem_alloc *next;
} mem_alloct;

typedef struct 
{
	IU16 segment;
	IU32 offset;
} DPMI_intvect;

typedef struct
{
        IU16	CS;
        IU16	DS;
        IU16	ES;
        IU16	SS;
        IU32	SP;
        IU32	IP;
	IU32	DI;
	IU32	SI;
	IU32	BP;
	IU32	AX;
	IU32	BX;
	IU32	CX;
	IU32	DX;
	IU32	Flags;
	BOOL	wrapping;
	BOOL	already_iretted;
} DPMI_saved_state;

typedef struct
{
	DPMI_intvect rm_vec;
	DPMI_intvect rm_call_struct;
	DPMI_intvect pm_routine;
	IU16 rm_stack_alias;
	BOOL used;
} DPMI_callbackt;

typedef struct
{
	DPMI_intvect wp_addr;
	IU8	wp_size;
	IU8	wp_type;
	IU8	reg;
	BOOL	wp_hit;
	BOOL	used;
} DPMI_debugwpt;

typedef struct
{
	IU32	DCR;
	IU32	DSR;
	IU32	DR[5];
} debug_regt;

extern IU16 allocate_one_desc IPT0();

extern VOID setup_LDT_desc IPT4( IU16, selector, IU32, base, IU32, limit, 
			IU16, access_rights);

extern VOID DPMI_exc_ret IPT0();

extern VOID push_rm_sp IPT1(IU16, spval);

extern VOID pop_rm_sp IPT0();

extern IU16 get_next_rm_sp IPT0();

extern VOID free_rm_sp_entry IPT0();

extern VOID push_locked_sp IPT1(IU16, spval);

extern VOID pop_locked_sp IPT0();

extern IU16 get_next_locked_sp IPT0();

extern VOID free_locked_sp_entry IPT0();

extern VOID Reserve_one_desc IPT1(IU16, sel);

extern VOID dpmi_trace IPT9(IU32, mask, char*, str, char*, p1,
        char *, p2, char *, p3, char *, p4, char *, p5, char *, p6,
        char *, p7);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\dma.h ===
/*
 * SoftPC-AT Revision 2.0
 *
 * Title	: IBM PC-AT DMA Adaptor declarations
 *
 * Description	: This module contains declarations that are used in
 *		  accessing the DMA Adaptor emulation
 *
 * Author(s)	: Ross Beresford
 *
 * Notes	: For a detailed description of the IBM DMA Adaptor,
 *		  and the INTEL DMA Controller chips refer to the following 
 *		  documents:
 *
 *		  - IBM PC/AT Technical Reference Manual
 *				(Section 1-9 Direct Memory Access)
 *		  - INTEL Microsystems Components Handbook
 *				(Section 2-52 DMA Controller 8237A)
 *
 *		  A more succinct account of the DMA adaptor follows:
 *

 * DMA Adaptor:
 * -----------
 *
 * The DMA "adaptor" is really just a part of the AT System Board. This
 * is its block diagram:
 *
 *                +-----------+                                             
 *        000-01F |8237A-5 | 0|                                 A0-A7       
 * IOS <-+------> |  DMA   | 1| -------------------------------------+      
 *       |        | CNTRL  | 2|      +-------+                       |      
 *       |        |   0    | 3| ---> |ALS 573|                 A8-A15|      
 *       |        +-----------+      |  DMA  | ----------------------+      
 *       |           ^               |ADDRESS|                       |      
 *       |            \              | LATCH |      +-------+        |      
 *       |             \ cascade     +-------+      | LS612 |        |      
 *       |080-09F       \                           |       | A16-A23|      
 *       +----------------------------------------> |  DMA  | -------+      
 *       |                \                         |  PAGE | A17-A23|      
 *       |        +-----------+                     |  REG  |        |      
 *       |        |8237A-5 | 4|                     +-------+        |      
 *       +------> |  DMA   | 5| -------------------------------------+      
 *        0C0-0DF | CNTRL  | 6|      +-------+                 A9-A16|      
 *                |   1    | 7| ---> |ALS 573|                       |      
 *                +-----------+      |  DMA  | ----------------------+-> SAS
 *                                   |ADDRESS|                  A1-A8       
 *                                   | LATCH |                              
 *                                   +-------+                              

 * DMA Controllers:
 * ---------------
 *
 * The 8237A-5 DMA controller chips used are restricted to 4 DMA
 * channels each: thus, 2 DMA controller chips are required to give the
 * AT's 7 DMA channels.
 *
 * The 8237A-5 DMA controller chips support more than one device by
 * "cascading" them: that is, connecting the control inputs of the
 * "additional" device to the control outputs of the "initial" device.
 * One channel in the initial device must be dedicated to serving
 * each additional device by setting it to "cascade mode".
 *
 * On the AT system board, channel 4 of DMA Controller 1 is set to
 * "cascade mode", and serves DMA Controller 0.
 *
 * Channels 0-3 (on DMA Controller 0) are used to support 8-bit I/O
 * devices and provide transfers of up to 64K bytes: the 16-bit addresses
 * generated by the DMA Controller are mapped directly onto bits A0-A15
 * of a 24 bit system address.
 *
 * Channels 5-7 (on DMA Controller 1) are used to support 16-bit I/O
 * devices and provide transfers of up to 128K bytes: the 16-bit addresses
 * generated by the DMA Controller are mapped onto bits A1-A16 of a
 * 24 bit system address, and bit A0 is set to 0.
 *
 * The state of a controller is defined by a set of internal registers
 * and a flip-flop: the internal registers are used in setting up and
 * performing a DMA transfer; the First/Last Flip-Flop controls which
 * byte of a 16 bit address is accessed from the I/O bus.
 *
 * The state information for a controller is represented by a DMA_CNTRL
 * object.

 * DMA Address Latches:
 * -------------------
 *
 * Each DMA Controller has an ALS573 DMA Address Latch associated with
 * it. These are required because of a restriction in the design of the
 * DMA Controller: in order to reduce its pin count it does not directly
 * output bits A8-A15 onto the address bus, but uses an external latch.
 * 
 * Since the address latches do not have any separate functional
 * identity, their state and behaviour is included in with the
 * controllers.

 * DMA Page Registers:
 * ------------------
 *
 * An LS612 DMA Page Register chip is used to establish the constant top
 * bits of the system address for a DMA transfer; each DMA channel has a
 * byte register in the chip for this purpose.
 * 
 * In DMA channels 0-3, bits A16-A23 of the 24 bit system address are
 * established from bits D0-D7 of the page register for the channel.
 * 
 * In DMA channels 5-7, bits A17-A23 of the 24 bit system address are
 * established from bits D1-D7 of the page register for the channel:
 * Bit D0 is not used for these channels, since bit A16 of the system
 * address is established by the DMA controller for these channels.
 *
 * The state information for the page register chip is represented
 * by a DMA_PAGE object.
 */ 

/* SccsID[]="@(#)dma.h	1.7 11/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * DMA CONTROLLER
 */

/* the number of channels per controller */
#define	DMA_CONTROLLER_CHANNELS	4

/* a flip-flop; it toggles between the values 0 and 1 */
typedef	unsigned int	DMA_FLIP_FLOP;

/* a DMA address; it is indexed by the flip-flop value */
typedef	half_word	DMA_WORD[2];

/* a DMA command */
#ifdef BIT_ORDER1
typedef union
{
	half_word all;
	struct
	{
		 HALF_WORD_BIT_FIELD DACK_high:1;       /* not supported */
		 HALF_WORD_BIT_FIELD DREQ_high:1;	/* not supported */
		 HALF_WORD_BIT_FIELD extended_write:1;  /* not supported */
		 HALF_WORD_BIT_FIELD rotate_priority:1;	  
		 HALF_WORD_BIT_FIELD compressed_timing:1;/* not supported */
		 HALF_WORD_BIT_FIELD controller_disable:1;
		 HALF_WORD_BIT_FIELD ch0_address_hold:1;/* not supported */
		 HALF_WORD_BIT_FIELD mm_enable:1;       /* not supported */
       } bits;
} DMA_COMMAND;
#endif
#ifdef BIT_ORDER2
typedef union
{
 	half_word all;
	struct
	{
		 HALF_WORD_BIT_FIELD mm_enable:1;       /* not supported */
		 HALF_WORD_BIT_FIELD ch0_address_hold:1;/* not supported */
		 HALF_WORD_BIT_FIELD controller_disable:1;
		 HALF_WORD_BIT_FIELD compressed_timing:1; /* not supported */
		 HALF_WORD_BIT_FIELD rotate_priority:1;	  
		 HALF_WORD_BIT_FIELD extended_write:1;  /* not supported */
		 HALF_WORD_BIT_FIELD DREQ_high:1;       /* not supported */
		 HALF_WORD_BIT_FIELD DACK_high:1;	/* not supported */
	} bits;
} DMA_COMMAND;
#endif

/* a DMA mode */
#ifdef BIT_ORDER1
typedef union
{
 	half_word all;
	struct
	{
		 HALF_WORD_BIT_FIELD mode:2;	    /* single/block/demand/cascade */
		 HALF_WORD_BIT_FIELD address_dec:1; /* inc or dec count  */
		 HALF_WORD_BIT_FIELD auto_init:1;   /* autoinitialize ?  */
		 HALF_WORD_BIT_FIELD transfer_type:2; /* read/write/verify */
		 HALF_WORD_BIT_FIELD scratch:2;     /* channel select mapped here */
       } bits;
} DMA_MODE;
#endif
#ifdef BIT_ORDER2
typedef union
{
 	half_word all;
	struct
	{
		 HALF_WORD_BIT_FIELD scratch:2;     /* channel select mapped here */
		 HALF_WORD_BIT_FIELD transfer_type:2; /* read/write/verify */
		 HALF_WORD_BIT_FIELD auto_init:1;   /* autoinitialize ?  */
		 HALF_WORD_BIT_FIELD address_dec:1; /* inc or dec count  */
		 HALF_WORD_BIT_FIELD mode:2;	    /* single/block/demand/cascade */
       } bits;
} DMA_MODE;
#endif

#if defined(NEC_98)

#ifdef BIT_ORDER1
typedef union
{
        half_word all;
        struct
        {
                HALF_WORD_BIT_FIELD reserve:4;
                HALF_WORD_BIT_FIELD incrementmode:2;
                HALF_WORD_BIT_FIELD scratch:2;
        } bits;
} DMA_BANK_MODE;
#endif

#ifdef BIT_ORDER2
typedef union
{
        half_word all;
        struct
        {
                HALF_WORD_BIT_FIELD scratch:2;
                HALF_WORD_BIT_FIELD incrementmode:2;
                HALF_WORD_BIT_FIELD reserve:4;
        } bits;
} DMA_BANK_MODE;
#endif

#define DMA_64K_MODE            0
#define DMA_1M_MODE             1
#define DMA_16M_MODE            3

#endif // NEC_98

/* DMA Mode register mode bit settings */
#define DMA_DEMAND_MODE		0
#define DMA_SINGLE_MODE		1
#define DMA_BLOCK_MODE		2
#define DMA_CASCADE_MODE	3

/* DMA Mode register transfer type bit settings */
#define DMA_VERIFY_TRANSFER	0
#define DMA_WRITE_TRANSFER	1
#define DMA_READ_TRANSFER	2
#define DMA_ILLEGAL_TRANSFER	3

/* a DMA status */
#ifdef BIT_ORDER1
typedef union
{
	half_word all;
	struct
	{
		HALF_WORD_BIT_FIELD request:4;		/* request pending   */
		HALF_WORD_BIT_FIELD terminal_count:4;	/* terminal count reached */
	} bits;
} DMA_STATUS;
#endif
#ifdef BIT_ORDER2
typedef union
{
	half_word all;
	struct {
		HALF_WORD_BIT_FIELD terminal_count:4;	/* terminal count reached */
		HALF_WORD_BIT_FIELD request:4;		/* request pending   */
	} bits;
} DMA_STATUS;
#endif

/* a DMA mask register (only the bottom 4 bits are meaningful) */
typedef	half_word	DMA_MASK;

/* a DMA Controller state */
typedef struct
{
	DMA_WORD	base_address[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	base_count[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	current_address[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	current_count[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	temporary_address[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	temporary_count[DMA_CONTROLLER_CHANNELS];
	DMA_STATUS	status;
	DMA_COMMAND	command;
	half_word	temporary;
	DMA_MODE	mode[DMA_CONTROLLER_CHANNELS];
	DMA_MASK	mask;
	half_word	request;
	DMA_FLIP_FLOP	first_last;
#if defined(NEC_98)
        DMA_BANK_MODE   bank_mode[DMA_CONTROLLER_CHANNELS];
#endif // NEC_98
} DMA_CNTRL;

/*
 * DMA PAGE REGISTERS
 */

/* the number of channels per page register chip */
#define	DMA_PAGE_CHANNELS	16

/* a DMA Page Register chip state */
typedef	struct
{
	half_word	page[DMA_PAGE_CHANNELS];
} DMA_PAGE;

/*
 * DMA ADAPTOR
 */

/* the number of controllers per adaptor */
#if defined(NEC_98)
#define DMA_ADAPTOR_CONTROLLERS 1
#else  // !NEC_98
#define	DMA_ADAPTOR_CONTROLLERS	2
#endif // !NEC_98

/* the numbering convention for the controllers */
#define	DMA_CONTROLLER	0
#define	DMA1_CONTROLLER	1

/* a DMA adaptor state */
typedef	struct
{
	DMA_CNTRL	controller[DMA_ADAPTOR_CONTROLLERS];
	DMA_PAGE	pages;
} DMA_ADAPT;

/* the number of logical channels per adaptor */
#define	DMA_ADAPTOR_CHANNELS	\
	(DMA_ADAPTOR_CONTROLLERS * DMA_CONTROLLER_CHANNELS)

/* macros for converting between logical and physical channel numbers */
#define	dma_logical_channel(controller, channel)	\
		(controller*DMA_CONTROLLER_CHANNELS + channel)
#define	dma_physical_channel(channel)	\
		(channel%DMA_CONTROLLER_CHANNELS)
#define	dma_physical_controller(channel)	\
		(channel/DMA_CONTROLLER_CHANNELS)

/* macro for building a system address dependent on the channel */
#define	dma_system_address(channel, page, offset) \
	( (channel < 4) \
	? (((sys_addr)(page & 0xff) << 16) | ((sys_addr)(offset & 0xffff) << 0)) \
	: (((sys_addr)(page & 0xfe) << 16) | ((sys_addr)(offset & 0xffff) << 1)) )

/* macro for determining the DMA unit size dependent on the channel */
#define	dma_unit_size(channel) ( (channel < 4) ? 1 : 2)

/* the channel assignments */
#define	DMA_RESERVED_CHANNEL_0	0
#if defined(NEC_98)
#define DMA_RESERVED_CHANNEL_1  1
#define DMA_RESERVED_CHANNEL_2  2
#define DMA_RESERVED_CHANNEL_3  3
#define DMA_DISKETTE_CHANNEL    2
#else  // !NEC_98
#define	DMA_SDLC_CHANNEL	1
#define	DMA_DISKETTE_CHANNEL	2
#define	DMA_DISK_CHANNEL	3
#define	DMA_CASCADE_CHANNEL	4
#define	DMA_RESERVED_CHANNEL_5	5
#define	DMA_RESERVED_CHANNEL_6	6
#define	DMA_RESERVED_CHANNEL_7	7
#define DMA_FAKE_CHANNEL_1	8
#define DMA_FAKE_CHANNEL_2	9
#define DMA_FAKE_CHANNEL_3	10
#define DMA_FAKE_CHANNEL_4	11
#define DMA_FAKE_CHANNEL_5	12
#define DMA_FAKE_CHANNEL_6	13
#define DMA_FAKE_CHANNEL_7	14
#define DMA_REFRESH_CHANNEL	15
#endif  // !NEC_98

/* these masks define the redundant bits of the I/O addresses */
#define	DMA_REDUNDANT_BITS	0x10
#define	DMA1_REDUNDANT_BITS	0x01
#define	DMA_PAGE_REDUNDANT_BITS	0x10

/*
 * DMA Address - the following union is used only in the BIOS functions
 * to help determine how a system address should be expressed in terms
 * of its component parts.
 * It is not used within the DMA emulation
 */
#ifdef BIGEND
typedef union
{
	sys_addr all;
	half_word array[4];
	struct
	{
		half_word pad;
		half_word page;
		half_word high;
		half_word low;
	} parts;
	struct
	{
		word high;
		word low;
	} words;
} DMA_ADDRESS;
#endif
#ifdef LITTLEND
typedef union
{
	sys_addr all;
	half_word array[4];
	struct
	{
		half_word low;
		half_word high;
		half_word page;
		half_word pad;
	} parts;
	struct
	{
		word low;
		word high;
	} words;
} DMA_ADDRESS;
#endif

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 *	void dma_init()
 *	{
 *		This function performs several distinct initialisation
 *		tasks associated with the DMA adaptor:
 *
 *		the DMA Controller chips and the DMA Page Register chip
 *		are connected to the I/O bus;
 *
 *		a hardware reset is performed for each DMA Controller
 *		chip;
 *	}
 */
IMPORT VOID dma_init IPT0();

/*
 *	void dma_post()
 *	{
 *		the mode register for each DMA channel is set up to the
 *		normal value for an AT.
 *	}
 */
IMPORT VOID dma_post IPT0();

/*
 *	void dma_inb(port, value)
 *	io_addr port;
 *	half_word *value;
 *	{
 *		This function is invoked when a read is performed on an
 *		I/O address "port" in the range of one of the DMA
 *		Controller chips. dma_inb() may also be called directly
 *		from the BIOS.
 *
 *		The function maps the I/O address to the particular DMA
 *		controller and returns the value of the requested
 *		register in "*value".
 *	}
 */
IMPORT VOID dma_inb IPT2(io_addr, port, half_word *, value);

/*
 *	void dma_outb(port, value)
 *	io_addr port;
 *	half_word value;
 *	{
 *		This function is invoked when a write is performed to an
 *		I/O address "port" in the range of one of the DMA
 *		Controller chips. dma_outb() may also be called directly
 *		from the BIOS.
 *
 *		The function maps the I/O address to the particular DMA
 *		controller and sets the requested register to "value".
 *	}
 */
IMPORT VOID dma_outb IPT2(io_addr, port, half_word, value);

/*
 *	void dma_page_inb(port, value)
 *	io_addr port;
 *	half_word *value;
 *	{
 *		This function is invoked when a read is performed on an
 *		I/O address "port" in the range of the DMA Page Register
 *		chip. dma_page_inb() may also be called directly from the
 *		BIOS.
 *
 *		The function maps the I/O address to a particular DMA
 *		page register and returns its value in "*value".
 *	}
 */
IMPORT VOID dma_page_inb IPT2(io_addr, port, half_word *, value);

/*
 *	void dma_page_outb(port, value)
 *	io_addr port;
 *	half_word value;
 *	{
 *		This function is invoked when a write is performed to an
 *		I/O address "port" in the range of the DMA Page Register
 *		chip. dma_page_outb() may also be called directly from the
 *		BIOS.
 *
 *		The function maps the I/O address to a particular DMA
 *		page register and sets it to "value".
 *	}
 */
IMPORT VOID dma_page_outb IPT2(io_addr, port, half_word, value);

/*
 *	dma_request(channel, hw_buffer, length)
 *	half_word channel;
 *	char *hw_buffer;
 *	word length;
 *	{
 *		I/O devices call this function to initiate a DMA
 *		transfer. It is analogous to raising the DREQ line
 *		on the DMA controller for the channel.
 *
 *		The DMA channel to be used is passed in "channel";
 *		"hw_buffer" is the address in the device's memory
 *		space of the buffer that should be read from or written
 *		into the system address space; "length" is the maximum
 *		number of units to be transferred: the unit is a
 *		half_word for channels 0-3 and a word for channels 5-7.
 *
 *		The function returns TRUE if more transfers can be
 *		accepted or FALSE if the terminal count has been
 *		reached.
 *	}
 */
IMPORT int dma_request IPT3(half_word, port, char *, hw_buffer, word, length);

/*
 *	void dma_enquire(channel, address, length)
 *	half_word channel;
 *	sys_addr *address;
 *	word *length;
 *	{
 *		I/O devices call this function to find out how the
 *		DMA controller has been programmed up to do a transfer.
 *
 *		The DMA channel to be accessed is passed in "channel";
 *		the address in system address space that will be read
 *		or written in the transfer is returned in "*address";
 *		"length" is the number of units that have been
 *		requested: the unit is a half_word for channels 0-3
 *		and a word for channels 5-7.
 *	}
 */
IMPORT VOID dma_enquire IPT3(half_word, channel, sys_addr *, address, word *, length);

#ifdef NTVDM
/*
 * BOOL dmaGetAdaptor
 *
 * Used by MS for third party Vdds to retrieve current DMA settings
 *
 * entry: void
 * exit : DMA_ADAPT * , pointer to the DMA_ADAPT structure
 *
 */
DMA_ADAPT *dmaGetAdaptor();
#endif	/* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\dterm.h ===
/*[
	Name:		DTerm.h
	Derived From:	Unknown
	Author:		Paul Murray
	Created On:	July 1990
	Sccs ID:	08/10/92 @(#)DTerm.h	1.6
	Purpose:	MACROS, labels etc. used in the Dumb Terminal

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#define TBUFSIZ 20480
#define HIWATER TBUFSIZ - 400

#define PC_DISPLAY_WIDTH        80
#define PC_DISPLAY_HEIGHT       25
#define PC_DISPLAY_HPELS        8
#define PC_DISPLAY_VPELS        16
#define MAX_DIRTY_COUNT         8001          /* Max number of dirty bits  */

#define ERH_DUMBTERM 0
#define DT_NORMAL 0
#define DT_ERROR 1
#define DT_SCROLL_UP 0
#define DT_SCROLL_DOWN 1
#define DT_CURSOR_OFF 0
#define DT_CURSOR_ON 1
#define CURSOR_MODE_BASE 0

#ifndef EHS_MSG_LEN
#define EHS_MSG_LEN 1024
#endif

#define DT_NLS_KEY_SIZE		80	/* Size of strings for key compares */

#define EMIT    1
#define BUFFER  0
#define ROWS1_24        124     /* default dumb term rows displayed (for 24 line
 screen) */
#define ROWS0_23        23      /* display rows 0 - 23 instead  */

#define SCREEN_WIDTH 639
#define SCREEN_HEIGHT 199
#define TEXT_LINE_HEIGHT 8
#define BLACK_BACKGROUND 0


#define PC_CURSOR_BAD_ROW -1
#define PC_CURSOR_BAD_COL -1

#define TICKS_PER_FLUSH 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\d_inst.h ===
/* 
   d_inst.h

   Define all Decoded Instruction Types.
 */

/*
   static char SccsID[]="@(#)d_inst.h	1.1 08/03/93 Copyright Insignia Solutions Ltd.";
 */


/*
   The Decoded Intel Instructions.
   -------------------------------

   Number Field: col(-c)=32, width(-w)=3.
 */

#define I_AAA		(USHORT)  0
#define I_AAD		(USHORT)  1
#define I_AAM		(USHORT)  2
#define I_AAS		(USHORT)  3
#define I_ADC8		(USHORT)  4
#define I_ADC16		(USHORT)  5
#define I_ADC32		(USHORT)  6
#define I_ADD8		(USHORT)  7
#define I_ADD16		(USHORT)  8
#define I_ADD32		(USHORT)  9
#define I_AND8		(USHORT) 10
#define I_AND16		(USHORT) 11
#define I_AND32		(USHORT) 12
#define I_ARPL		(USHORT) 13
#define I_BOUND16	(USHORT) 14
#define I_BOUND32	(USHORT) 15
#define I_BSF16		(USHORT) 16
#define I_BSF32		(USHORT) 17
#define I_BSR16		(USHORT) 18
#define I_BSR32		(USHORT) 19
#define I_BSWAP		(USHORT) 20
#define I_BT16		(USHORT) 21
#define I_BT32		(USHORT) 22
#define I_BTC16		(USHORT) 23
#define I_BTC32		(USHORT) 24
#define I_BTR16		(USHORT) 25
#define I_BTR32		(USHORT) 26
#define I_BTS16		(USHORT) 27
#define I_BTS32		(USHORT) 28
#define I_CALLF16	(USHORT) 29
#define I_CALLF32	(USHORT) 30
#define I_CALLN16	(USHORT) 31
#define I_CALLN32	(USHORT) 32
#define I_CALLR16	(USHORT) 33
#define I_CALLR32	(USHORT) 34
#define I_CBW		(USHORT) 35
#define I_CDQ		(USHORT) 36
#define I_CLC		(USHORT) 37
#define I_CLD		(USHORT) 38
#define I_CLI		(USHORT) 39
#define I_CLTS		(USHORT) 40
#define I_CMC		(USHORT) 41
#define I_CMP8		(USHORT) 42
#define I_CMP16		(USHORT) 43
#define I_CMP32		(USHORT) 44
#define I_CMPSB		(USHORT) 45
#define I_CMPSD		(USHORT) 46
#define I_CMPSW		(USHORT) 47
#define I_CMPXCHG8	(USHORT) 48
#define I_CMPXCHG16	(USHORT) 49
#define I_CMPXCHG32	(USHORT) 50
#define I_CWD		(USHORT) 51
#define I_CWDE		(USHORT) 52
#define I_DAA		(USHORT) 53
#define I_DAS		(USHORT) 54
#define I_DEC8		(USHORT) 55
#define I_DEC16		(USHORT) 56
#define I_DEC32		(USHORT) 57
#define I_DIV8		(USHORT) 58
#define I_DIV16		(USHORT) 59
#define I_DIV32		(USHORT) 60
#define I_ENTER16	(USHORT) 61
#define I_ENTER32	(USHORT) 62
#define I_F2XM1		(USHORT) 63
#define I_FABS		(USHORT) 64
#define I_FADD		(USHORT) 65
#define I_FADDP		(USHORT) 66
#define I_FBLD		(USHORT) 67
#define I_FBSTP		(USHORT) 68
#define I_FCHS		(USHORT) 69
#define I_FCLEX		(USHORT) 70
#define I_FCOM		(USHORT) 71
#define I_FCOMP		(USHORT) 72
#define I_FCOMPP	(USHORT) 73
#define I_FCOS		(USHORT) 74
#define I_FDECSTP	(USHORT) 75
#define I_FDIV		(USHORT) 76
#define I_FDIVP		(USHORT) 77
#define I_FDIVR		(USHORT) 78
#define I_FDIVRP	(USHORT) 79
#define I_FFREE		(USHORT) 80
#define I_FFREEP	(USHORT) 81
#define I_FIADD		(USHORT) 82
#define I_FICOM		(USHORT) 83
#define I_FICOMP	(USHORT) 84
#define I_FIDIV		(USHORT) 85
#define I_FIDIVR	(USHORT) 86
#define I_FILD		(USHORT) 87
#define I_FIMUL		(USHORT) 88
#define I_FINCSTP	(USHORT) 89
#define I_FINIT		(USHORT) 90
#define I_FIST		(USHORT) 91
#define I_FISTP		(USHORT) 92
#define I_FISUB		(USHORT) 93
#define I_FISUBR	(USHORT) 94
#define I_FLD		(USHORT) 95
#define I_FLD1		(USHORT) 96
#define I_FLDCW		(USHORT) 97
#define I_FLDENV16	(USHORT) 98
#define I_FLDENV32	(USHORT) 99
#define I_FLDL2E	(USHORT)100
#define I_FLDL2T	(USHORT)101
#define I_FLDLG2	(USHORT)102
#define I_FLDLN2	(USHORT)103
#define I_FLDPI		(USHORT)104
#define I_FLDZ		(USHORT)105
#define I_FMUL		(USHORT)106
#define I_FMULP		(USHORT)107
#define I_FNOP		(USHORT)108
#define I_FPATAN	(USHORT)109
#define I_FPREM		(USHORT)110
#define I_FPREM1	(USHORT)111
#define I_FPTAN		(USHORT)112
#define I_FRNDINT	(USHORT)113
#define I_FRSTOR16	(USHORT)114
#define I_FRSTOR32	(USHORT)115
#define I_FSAVE16	(USHORT)116
#define I_FSAVE32	(USHORT)117
#define I_FSCALE	(USHORT)118
#define I_FSETPM	(USHORT)119
#define I_FSIN		(USHORT)120
#define I_FSINCOS	(USHORT)121
#define I_FSQRT		(USHORT)122
#define I_FST		(USHORT)123
#define I_FSTCW		(USHORT)124
#define I_FSTENV16	(USHORT)125
#define I_FSTENV32	(USHORT)126
#define I_FSTP		(USHORT)127
#define I_FSTSW		(USHORT)128
#define I_FSUB		(USHORT)129
#define I_FSUBP		(USHORT)130
#define I_FSUBR		(USHORT)131
#define I_FSUBRP	(USHORT)132
#define I_FTST		(USHORT)133
#define I_FUCOM		(USHORT)134
#define I_FUCOMP	(USHORT)135
#define I_FUCOMPP	(USHORT)136
#define I_FXAM		(USHORT)137
#define I_FXCH		(USHORT)138
#define I_FXTRACT	(USHORT)139
#define I_FYL2X		(USHORT)140
#define I_FYL2XP1	(USHORT)141
#define I_HLT		(USHORT)142
#define I_IDIV8		(USHORT)143
#define I_IDIV16	(USHORT)144
#define I_IDIV32	(USHORT)145
#define I_IMUL8		(USHORT)146
#define I_IMUL16	(USHORT)147
#define I_IMUL32	(USHORT)148
#define I_IMUL16T2	(USHORT)149
#define I_IMUL16T3	(USHORT)150
#define I_IMUL32T2	(USHORT)151
#define I_IMUL32T3	(USHORT)152
#define I_IN8		(USHORT)153
#define I_IN16		(USHORT)154
#define I_IN32		(USHORT)155
#define I_INC8		(USHORT)156
#define I_INC16		(USHORT)157
#define I_INC32		(USHORT)158
#define I_INSB		(USHORT)159
#define I_INSD		(USHORT)160
#define I_INSW		(USHORT)161
#define I_INT3		(USHORT)162
#define I_INT		(USHORT)163
#define I_INTO		(USHORT)164
#define I_INVD		(USHORT)165
#define I_INVLPG	(USHORT)166
#define I_IRET		(USHORT)167
#define I_IRETD		(USHORT)168
#define I_JB16		(USHORT)169
#define I_JB32		(USHORT)170
#define I_JBE16		(USHORT)171
#define I_JBE32		(USHORT)172
#define I_JCXZ		(USHORT)173
#define I_JECXZ		(USHORT)174
#define I_JL16		(USHORT)175
#define I_JL32		(USHORT)176
#define I_JLE16		(USHORT)177
#define I_JLE32		(USHORT)178
#define I_JMPF16	(USHORT)179
#define I_JMPF32	(USHORT)180
#define I_JMPN		(USHORT)181
#define I_JMPR16	(USHORT)182
#define I_JMPR32	(USHORT)183
#define I_JNB16		(USHORT)184
#define I_JNB32		(USHORT)185
#define I_JNBE16	(USHORT)186
#define I_JNBE32	(USHORT)187
#define I_JNL16		(USHORT)188
#define I_JNL32		(USHORT)189
#define I_JNLE16	(USHORT)190
#define I_JNLE32	(USHORT)191
#define I_JNO16		(USHORT)192
#define I_JNO32		(USHORT)193
#define I_JNP16		(USHORT)194
#define I_JNP32		(USHORT)195
#define I_JNS16		(USHORT)196
#define I_JNS32		(USHORT)197
#define I_JNZ16		(USHORT)198
#define I_JNZ32		(USHORT)199
#define I_JO16		(USHORT)200
#define I_JO32		(USHORT)201
#define I_JP16		(USHORT)202
#define I_JP32		(USHORT)203
#define I_JS16		(USHORT)204
#define I_JS32		(USHORT)205
#define I_JZ16		(USHORT)206
#define I_JZ32		(USHORT)207
#define I_LAHF		(USHORT)208
#define I_LAR		(USHORT)209
#define I_LDS		(USHORT)210
#define I_LEA		(USHORT)211
#define I_LEAVE16	(USHORT)212
#define I_LEAVE32	(USHORT)213
#define I_LES		(USHORT)214
#define I_LFS		(USHORT)215
#define I_LGDT16	(USHORT)216
#define I_LGDT32	(USHORT)217
#define I_LGS		(USHORT)218
#define I_LIDT16	(USHORT)219
#define I_LIDT32	(USHORT)220
#define I_LLDT		(USHORT)221
#define I_LMSW		(USHORT)222
#define I_LOADALL	(USHORT)223
#define I_LOCK		(USHORT)224
#define I_LODSB		(USHORT)225
#define I_LODSD		(USHORT)226
#define I_LODSW		(USHORT)227
#define I_LOOP16	(USHORT)228
#define I_LOOP32	(USHORT)229
#define I_LOOPE16	(USHORT)230
#define I_LOOPE32	(USHORT)231
#define I_LOOPNE16	(USHORT)232
#define I_LOOPNE32	(USHORT)233
#define I_LSL		(USHORT)234
#define I_LSS		(USHORT)235
#define I_LTR		(USHORT)236
#define I_MOV_SR	(USHORT)237
#define I_MOV_CR	(USHORT)238
#define I_MOV_DR	(USHORT)239
#define I_MOV_TR	(USHORT)240
#define I_MOV8		(USHORT)241
#define I_MOV16		(USHORT)242
#define I_MOV32		(USHORT)243
#define I_MOVSB		(USHORT)244
#define I_MOVSD		(USHORT)245
#define I_MOVSW		(USHORT)246
#define I_MOVSX8	(USHORT)247
#define I_MOVSX16	(USHORT)248
#define I_MOVZX8	(USHORT)249
#define I_MOVZX16	(USHORT)250
#define I_MUL8		(USHORT)251
#define I_MUL16		(USHORT)252
#define I_MUL32		(USHORT)253
#define I_NEG8		(USHORT)254
#define I_NEG16		(USHORT)255
#define I_NEG32		(USHORT)256
#define I_NOP		(USHORT)257
#define I_NOT8		(USHORT)258
#define I_NOT16		(USHORT)259
#define I_NOT32		(USHORT)260
#define I_OR8		(USHORT)261
#define I_OR16		(USHORT)262
#define I_OR32		(USHORT)263
#define I_OUT8		(USHORT)264
#define I_OUT16		(USHORT)265
#define I_OUT32		(USHORT)266
#define I_OUTSB		(USHORT)267
#define I_OUTSD		(USHORT)268
#define I_OUTSW		(USHORT)269
#define I_POP16		(USHORT)270
#define I_POP32		(USHORT)271
#define I_POP_SR	(USHORT)272
#define I_POPA		(USHORT)273
#define I_POPAD		(USHORT)274
#define I_POPF		(USHORT)275
#define I_POPFD		(USHORT)276
#define I_PUSH16	(USHORT)277
#define I_PUSH32	(USHORT)278
#define I_PUSHA		(USHORT)279
#define I_PUSHAD	(USHORT)280
#define I_PUSHF		(USHORT)281
#define I_PUSHFD	(USHORT)282
#define I_RCL8		(USHORT)283
#define I_RCL16		(USHORT)284
#define I_RCL32		(USHORT)285
#define I_RCR8		(USHORT)286
#define I_RCR16		(USHORT)287
#define I_RCR32		(USHORT)288
#define I_RETF16	(USHORT)289
#define I_RETF32	(USHORT)290
#define I_RETN16	(USHORT)291
#define I_RETN32	(USHORT)292
#define I_ROL8		(USHORT)293
#define I_ROL16		(USHORT)294
#define I_ROL32		(USHORT)295
#define I_ROR8		(USHORT)296
#define I_ROR16		(USHORT)297
#define I_ROR32		(USHORT)298
#define I_R_INSB	(USHORT)299 /* REP   INS  */
#define I_R_INSD	(USHORT)300 /* REP   INS  */
#define I_R_INSW	(USHORT)301 /* REP   INS  */
#define I_R_OUTSB	(USHORT)302 /* REP   OUTS */
#define I_R_OUTSD	(USHORT)303 /* REP   OUTS */
#define I_R_OUTSW	(USHORT)304 /* REP   OUTS */
#define I_R_LODSB	(USHORT)305 /* REP   LODS */
#define I_R_LODSD	(USHORT)306 /* REP   LODS */
#define I_R_LODSW	(USHORT)307 /* REP   LODS */
#define I_R_MOVSB	(USHORT)308 /* REP   MOVS */
#define I_R_MOVSD	(USHORT)309 /* REP   MOVS */
#define I_R_MOVSW	(USHORT)310 /* REP   MOVS */
#define I_R_STOSB	(USHORT)311 /* REP   STOS */
#define I_R_STOSD	(USHORT)312 /* REP   STOS */
#define I_R_STOSW	(USHORT)313 /* REP   STOS */
#define I_RE_CMPSB	(USHORT)314 /* REPE  CMPS */
#define I_RE_CMPSD	(USHORT)315 /* REPE  CMPS */
#define I_RE_CMPSW	(USHORT)316 /* REPE  CMPS */
#define I_RNE_CMPSB	(USHORT)317 /* REPNE CMPS */
#define I_RNE_CMPSD	(USHORT)318 /* REPNE CMPS */
#define I_RNE_CMPSW	(USHORT)319 /* REPNE CMPS */
#define I_RE_SCASB	(USHORT)320 /* REPE  SCAS */
#define I_RE_SCASD	(USHORT)321 /* REPE  SCAS */
#define I_RE_SCASW	(USHORT)322 /* REPE  SCAS */
#define I_RNE_SCASB	(USHORT)323 /* REPNE SCAS */
#define I_RNE_SCASD	(USHORT)324 /* REPNE SCAS */
#define I_RNE_SCASW	(USHORT)325 /* REPNE SCAS */
#define I_SAHF		(USHORT)326
#define I_SAR8		(USHORT)327
#define I_SAR16		(USHORT)328
#define I_SAR32		(USHORT)329
#define I_SBB8		(USHORT)330
#define I_SBB16		(USHORT)331
#define I_SBB32		(USHORT)332
#define I_SCASB		(USHORT)333
#define I_SCASD		(USHORT)334
#define I_SCASW		(USHORT)335
#define I_SETB		(USHORT)336
#define I_SETBE		(USHORT)337
#define I_SETL		(USHORT)338
#define I_SETLE		(USHORT)339
#define I_SETNB		(USHORT)340
#define I_SETNBE	(USHORT)341
#define I_SETNL		(USHORT)342
#define I_SETNLE	(USHORT)343
#define I_SETNO		(USHORT)344
#define I_SETNP		(USHORT)345
#define I_SETNS		(USHORT)346
#define I_SETNZ		(USHORT)347
#define I_SETO		(USHORT)348
#define I_SETP		(USHORT)349
#define I_SETS		(USHORT)350
#define I_SETZ		(USHORT)351
#define I_SGDT16	(USHORT)352
#define I_SGDT32	(USHORT)353
#define I_SHL8		(USHORT)354
#define I_SHL16		(USHORT)355
#define I_SHL32		(USHORT)356
#define I_SHLD16	(USHORT)357
#define I_SHLD32	(USHORT)358
#define I_SHR8		(USHORT)359
#define I_SHR16		(USHORT)360
#define I_SHR32		(USHORT)361
#define I_SHRD16	(USHORT)362
#define I_SHRD32	(USHORT)363
#define I_SIDT16	(USHORT)364
#define I_SIDT32	(USHORT)365
#define I_SLDT		(USHORT)366
#define I_SMSW		(USHORT)367
#define I_STC		(USHORT)368
#define I_STD		(USHORT)369
#define I_STI		(USHORT)370
#define I_STOSB		(USHORT)371
#define I_STOSD		(USHORT)372
#define I_STOSW		(USHORT)373
#define I_STR		(USHORT)374
#define I_SUB8		(USHORT)375
#define I_SUB16		(USHORT)376
#define I_SUB32		(USHORT)377
#define I_TEST8		(USHORT)378
#define I_TEST16	(USHORT)379
#define I_TEST32	(USHORT)380
#define I_VERR		(USHORT)381
#define I_VERW		(USHORT)382
#define I_WAIT		(USHORT)383
#define I_WBINVD	(USHORT)384
#define I_XADD8		(USHORT)385
#define I_XADD16	(USHORT)386
#define I_XADD32	(USHORT)387
#define I_XCHG8		(USHORT)388
#define I_XCHG16	(USHORT)389
#define I_XCHG32	(USHORT)390
#define I_XLAT		(USHORT)391
#define I_XOR8		(USHORT)392
#define I_XOR16		(USHORT)393
#define I_XOR32		(USHORT)394
#define I_ZBADOP	(USHORT)395
#define I_ZBOP		(USHORT)396 /* Insignia's own BOP */
#define I_ZFRSRVD	(USHORT)397 /* Intel Floating Point reserved */
#define I_ZRSRVD	(USHORT)398 /* Intel reserved */
#define I_ZZEXIT	(USHORT)399 /* Insignia's PIG exit opcode */

#define MAX_DECODED_INST 399

/*
   End of  Decoded Intel Instructions.
   -----------------------------------
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\inc\egacpu.h ===
/*
 * SccsID = @(#)egacpu.h	1.22 10/24/94 Copyright Insignia Solutions Ltd.
 */

typedef enum
{
	WRITE_MODE,
	PLANES_ENABLED,
	ROTATION,
	CHAINED,
	BIT_PROT,
	FUNCTION,
	SET_RESET,
	ENABLE_SET_RESET,
	RAM_ENABLED,
	RAM_MOVED
} CHANGE_TYPE;

typedef union
{
#ifdef BIT_ORDER1
	struct
	{
		unsigned unused:27;
		unsigned sr:1;
		unsigned bp:1;
		unsigned func:2;
		unsigned pe:1;
	} state;
	struct
	{
		